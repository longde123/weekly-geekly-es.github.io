<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🌳 🔀 😑 Authentification du dongle matériel du périphérique Linux sur les systèmes de niveau supérieur 🥡 👩🏾‍🏫 🌡️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="L'IoT industriel surveille, planifie et automatise les systèmes d'ingénierie des installations industrielles, des bâtiments et des installations comme...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Authentification du dongle matériel du périphérique Linux sur les systèmes de niveau supérieur</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/oleg-bunin/blog/476304/">  L'IoT industriel surveille, planifie et automatise les systèmes d'ingénierie des installations industrielles, des bâtiments et des installations commerciales.  Des capteurs de divers paramètres, compteurs et contrôleurs collectent des données de ces objets, par exemple, la température et l'humidité dans la salle des serveurs, les relevés des compteurs d'eau dans les immeubles à appartements, le niveau de dioxyde de carbone dans les chambres.  Les contrôleurs traitent ces informations et envoient tout au "cloud". <br><br>  Wiren Board fabrique des contrôleurs Linux pour l'IoT industriel.  Les appareils collectent les données des puits de pétrole et des succursales bancaires, surveillent le microclimat des serveurs et des supermarchés.  Les contrôleurs s'intègrent aux systèmes de haut niveau des entreprises partenaires.  Les systèmes authentifient les appareils - ils comprennent qu'ils parlent avec leur capteur, et non avec quelqu'un d'autre, puis ils autorisent.  À ce stade, un problème se pose - il y a des milliers de contrôleurs, des centaines de clients, mais il n'y a pas de système d'intégration unique.  Les méthodes traditionnelles simples, telles que les paires login / mot de passe, sont vulnérables aux attaques et peu pratiques à déployer. <br><br><img src="https://habrastorage.org/webt/sk/xm/mt/skxmmtcf6uhcrlm0xkcqilqwjuo.jpeg"><br><br>  Par conséquent, la société a développé une authentification dans les systèmes de haut niveau à l'aide de clés matérielles - basée sur une cryptographie asymétrique standard utilisant un élément protégé par le matériel pour stocker les clés.  Désormais, un système d'intégration unifié n'est plus nécessaire - l'authentification et l'autorisation sont protégées et fonctionnent dès le départ.  <b>Evgeny Boger</b> vous expliquera comment procéder: comment ils ont choisi la «puce cryptographique», comment ils l'ont vissée au matériel et à Linux, comment les bibliothèques et les logiciels communs ont été créés pour être amis avec elle.  Accent particulier sur le déploiement: introduction de l'initialisation des appareils en production, introduction de la prise en charge de divers logiciels de haut niveau, y compris chez quelqu'un d'autre et fermé. <br><a name="habracut"></a><br>  <b>À propos de l'orateur:</b> <b>Eugene Boger</b> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" class="user_link">evgeny_boger</a> ) - CTO et co-fondateur de Wiren Board.  Engagé dans des systèmes embarqués et, en particulier, Linux embarqué. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/tbXmNAs5IrM" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><h2>  Les problèmes </h2><br>  Pour commencer, ce que nous faisons et d'où vient ce problème.  Chez Wiren Board, nous concevons et fabriquons des équipements en Russie.  Il s'appelait auparavant M2M, mais maintenant - IoT industriel.  Il s'agit de l'automatisation des systèmes d'ingénierie du bâtiment, de la surveillance et de la planification.  En bref, tout le travail ressemble à ceci: capteurs de divers paramètres, actionneurs, compteurs et contrôleurs (edge-computing ou IoT-gateway) collectent différentes données des objets, les traitent, exécutent la logique locale, puis les rassemblent dans un grand système de répartition, de surveillance ou de contrôle . <br><br><img src="https://habrastorage.org/webt/ns/fh/xa/nsfhxa9qezcmcuuc9y8kijenyhw.jpeg"><br><br>  Nous n'avons pas tout un écosystème, contrairement à certains concurrents.  Nous fabriquons des équipements qui s'intègrent à plusieurs systèmes de haut niveau de nos partenaires.  Il existe de nombreuses entreprises partenaires et elles partagent la responsabilité.  Sans de bons moyens techniques, l'intégration ne fonctionnera pas - elle ne peut tout simplement pas être négociée. <br><br>  Il existe deux solutions simples pour résoudre ces problèmes.  La première consiste <b>à donner le nom d'utilisateur / mot de passe au client</b> , comme tout le monde le fait, et la seconde consiste à <b>générer et à coudre le «secret» sur le lieu de travail</b> .  Les deux options ne nous convenaient pas - je vais vous dire pourquoi. <br><br><h2>  Solutions simples </h2><br>  <b>La première solution consiste à attribuer un nom d'utilisateur et un mot de passe au client</b> .  Nous le faisons tous jusqu'à récemment. <br><br>  Pour authentifier un appareil qui envoie des données à un système, vous pouvez créer une clé secrète - conditionnellement identifiant / mot de passe ("secret").  Elle sera courante sur les contrôleurs et sur un système de niveau supérieur qui collecte les données de plusieurs contrôleurs. <br><br>  Un couple de nom d'utilisateur / mot de passe (un «secret» commun) doit en quelque sorte être donné au client - l'entreprise ou la personne.  Quelqu'un doit générer une paire secrète, l'envoyer par e-mail, authentifier le client par son numéro de compte.  Il s'agit de la procédure standard - faible technologie. <br><br>  <b>Problème</b> .  C'est que nous avons beaucoup de tels systèmes.  Notre client, et il peut envoyer des données au système de notre partenaire.  Il s'agit d'une interaction complexe entre toutes les parties concernées. <br><br>  En plus du problème de nombreux systèmes, il y en a d'autres. <br><br><ul><li>  <b>Mauvaise livraison et livraison au client</b> . <br></li><li>  <b>Les identifiants et mots de passe sont stockés sur le serveur</b> .  Si nous stockons également des hachages, cela nous protégera un peu des fuites.  Mais même ainsi, un sentiment désagréable apparaît lorsque les clés secrètes de tous les contrôleurs clients sont stockées sur le serveur.  Certains d'entre eux peuvent effectuer des tâches critiques: éclairage extérieur, surveillance des plates-formes pétrolières. <br></li><li>  <b>Synchronisation entre services</b> . <br></li><li>  <b>Récupération des pertes</b> .  On ne sait pas quoi faire en cas de perte, lorsque le client a effacé la mémoire du contrôleur - dans quelle mémoire dois-je écrire?  Vous devez le répéter encore une fois. <br></li><li>  <b>Protection contre la copie des détails</b> .  Il existe des systèmes de surveillance payants qui fournissent au client un service et facturent des frais d'abonnement.  Je ne veux pas que le client final puisse contourner le système par notre intermédiaire - payez une fois, mais utilisez-en deux. <br></li></ul><br>  <b>La deuxième solution est de générer et de recoudre un «secret» de production</b> .  Il s'agit d'une amélioration par rapport à la solution précédente. <br><br>  Le schéma est le suivant: nous, en tant que fabricant de contrôleurs, pré-générons des noms d'utilisateur et des mots de passe pour tout le monde, les cousons dans notre système et les entrons dans l'équipement.  Les identifiants et mots de passe de l'équipement ne peuvent être ni lus ni modifiés.  C'est mieux que l'option précédente, car elle ne nécessite pas d'interaction entre les personnes. <br><br>  <b>Les problèmes</b> .  Tous les problèmes subsistent, sauf le premier, mais le principal est la <b>synchronisation entre les services et l'intranet</b> .  Il y a beaucoup de services et on ne sait pas comment les synchroniser - pour cette raison, nous n'avons pas pu implémenter la deuxième solution.  Nous avons des clients qui utilisent des équipements dans leurs réseaux fermés.  Nous avons sorti un nouveau contrôleur, l'avons vendu à un client et son système est fermé.  Il est mis en place, il fonctionne une fois, et il est difficile de transmettre davantage les «secrets».  Signaler par lots?  Tout est compliqué dans les organisations, bien que techniquement simple. <br><br>  Les deux solutions ne nous convenaient pas.  Par conséquent, nous avons décidé de prendre un chemin différent.  Mais avant cela, ils ont décidé de définir des buts et objectifs communs. <br><br><h2>  Tâches et objectifs </h2><br>  Premières tâches courantes. <br><br>  <b>Authentification</b>  C'est un moyen de comprendre qui parle au système de niveau supérieur, qui se connecte exactement au système de répartition. <br><br><blockquote>  L'authentification n'est pas l'octroi ou la délimitation de droits d'accès, mais une façon de comprendre qui nous parle. </blockquote><br>  <b>La tâche d'envoyer des données</b> .  Nos contrôleurs sont des ordinateurs Linux conçus pour une tâche spéciale.  Nous avons besoin d'eux pour envoyer des données à des systèmes de haut niveau, se connecter via VPN.  Dans le même temps, nous voulons que la répartition fonctionne «prête à l'emploi» - sans les paramètres et l'interaction de nos clients et utilisateurs finaux du système avec nous et avec les clients. <br><br>  <b>Autres tâches</b> .  Il s'agit d'une connexion fiable, du cryptage du canal de données, mais un autre problème est l' <b>autorisation</b> .  La tâche d'autorisation est associée à des services externes et est divisée en trois parties. <br><br><ul><li>  <b>Service constructeur gratuit</b> .  Fournissez l'accès par le numéro de série de l'appareil. <br></li><li>  <b>Listes blanches de numéros de série</b> pour le service de nos partenaires - liez les achats et les accès au compte du client. <br></li><li>  <b>Licences</b>  Autorisez ou refusez l'accès en fonction des options spécifiées dans le certificat. <br></li></ul><br>  Les objectifs sont ce que nous voulons atteindre lorsque nous résolvons des problèmes. <br><br>  <b>Délivrance et livraison au client</b> .  Sans la participation des gens - l'information est cousue par des robots en production. <br><br>  <b>Récupération des pertes</b> .  Nous voulons qu'il n'y ait aucune perte de détails secrets. <br><br>  <b>Livraison de la production aux services</b> .  Nous voulons nous en passer, pour que vous n'ayez rien à livrer aux services.  Lors du lancement de nouveaux équipements, nous ne souhaitons pas mettre à jour les bases de données de tous les services qui devraient authentifier ces appareils. <br><br>  <b>Stockage sur le serveur</b> .  Il est conseillé de ne rien y stocker du tout. <br><br>  <b>Synchronisation entre les services et l'intranet</b> .  Il est également conseillé de ne rien synchroniser - car nous ne stockerons rien. <br><br>  <b>Protection contre la copie des détails</b> .  Nous voulons quelque chose de secret, pour lequel l'argent est pris, il était impossible de copier et de recevoir gratuitement. <br><br><h2>  La signature numérique se précipite à la rescousse </h2><br><blockquote>  La signature numérique électronique (EDS) est une technologie autour de laquelle tout fonctionne pour nous. </blockquote><br>  C’est comme une signature ordinaire, uniquement numérique.  EDS est facile à vérifier, mais difficile à simuler.  Les vérités familières de la cryptographie, vieilles de plusieurs décennies. <br><br>  Une signature électronique est quelque chose qui peut être compté par un message si vous connaissez la clé privée secrète (clé privée).  Si vous connaissez la clé publique (clé publique), il est facile de vérifier que la signature électronique du message est correcte.  Le nom est clair - le public a coutume d'informer tout le monde, et le secret n'est que pour celui qui signe. <br><br><blockquote>  Toutes les signatures et clés ne sont que des chiffres. </blockquote><br>  Dans notre cas, il s'agit de 32 octets de données, ce qui fonctionne sur la «magie» mathématique.  Les mathématiques garantissent que la signature est facile à vérifier, mais difficile à simuler. <br><br>  Nous utilisons la signature ECDSA-256 + SHA-256: <br><br><ul><li> <code>e = HASH(m)</code> - la fonction de hachage cryptographique convertit irréversiblement le message m en nombre e; <br></li><li>  <code>private key (dA)</code> - nombre aléatoire; <br></li><li>  <code>public key (QA)</code> - générée à partir d'une clé privée, mais pas l'inverse; <br></li><li>  <code>signature (r,s) = sign(private key, e)</code> - signature; <br></li><li>  <code>verify(public key, signature, e)</code> - vérification de la signature. <br></li></ul><br><h3>  Authentification EDS.  Première tentative </h3><br>  Que peut-on faire pour notre tâche en utilisant ce mécanisme délicat, qui fonctionne dans un sens simplement et dans l'autre difficile? <br><br>  <b>Délivrance et livraison au client</b> .  Nous générons une clé privée aléatoire pour chaque appareil de la production.  Nous ne le disons à personne, car nous ne le connaissons même pas, et nous écrivons sur l'appareil. <br><br>  <b>Livraison de la production aux services</b> .  Ensuite, nous utilisons uniquement la clé publique de cet appareil pour l'authentification sur les services.  Sur les services, nous stockons uniquement une liste de clés publiques au lieu de mots de passe. <br><br>  Algorithme de contrôle de santé standard: <br><br><ul><li>  le service envoie un message aléatoire <code>m</code> au contrôleur; <br></li><li>  contrôleur: <code>sign(private key, m)</code> ; <br></li><li>  le contrôleur envoie une signature au service; <br></li><li>  service: <code>verify(public key, signature, m)</code> . <br></li></ul><br>  La seule chose que nous avons décidé de cette manière est que nous <b>ne stockons plus de "secrets" communs sur nos services</b> sous forme ouverte ou en cache.  Ce n'est pas ce que nous voulons. <br><br><h3>  Authentification EDS.  Deuxième tentative </h3><br>  Nous ne voulons pas stocker quelque chose sur les services.  Pour ce faire, nous pouvons forcer nos appareils à envoyer leurs clés publiques au service. <br><br>  À la dernière étape, nous avons résolu deux problèmes.  Le premier - nous avons <b>vérifié qu'ils avaient donné la clé du service</b> .  Nous avons une clé publique, ce qui signifie que nous avons également créé une clé privée.  La seconde - nous nous sommes assurés que l' <b>appareil possède une clé privée</b> , qui se trouve quelque part sur le lecteur flash USB.  Si l'appareil peut signer quelque chose, il possède une clé privée. <br><br>  Maintenant, l'appareil enverra également la clé publique au service.  Comment vérifier que personne ne l'a intercepté, ne l'a pas simulé et que tout fonctionne? <br><br>  <b>Vérification de la clé publique</b> .  Nous nous créons une autre clé publique.  Il sera notre clé en tant que fabricant.  Il s'agit de la clé racine "clé privée racine + clé publique".  Avec cette clé secrète racine en production, nous signerons la clé publique de l'appareil et nous enregistrerons cette signature sur l'appareil.  L'appareil doit envoyer sa clé publique et la signature de sa clé publique au service.  Le service peut désormais vérifier la clé publique de l'appareil.  S'il est signé avec la clé privée racine, nous avons émis cette clé. <br><br><blockquote>  Seul le fabricant - nous pouvons créer et stocker une signature sur l'appareil, mais tout vérifier. </blockquote>  Nous publions la clé publique sur le site dans la rubrique "Contacts".  Tout le monde peut le prendre et vérifier la clé publique de l'appareil qui a envoyé l'appareil au service.  Ensuite, vous pouvez vérifier que l'appareil lui-même possède sa propre clé privée. <br><br>  L'algorithme général ressemble à ceci. <br><br><ul><li>  <code>(once) random root private key</code> ; <br></li><li>  <code>factory: random device private key</code> ; <br></li><li>  <code>factory: sign(root private key, device public key) = signature_1</code> ; <br></li><li>  <code>device-&gt;service:  device public key + signature_1</code> ; <br></li><li> <code>service: verify(root public key, signature_1, device public key)?</code> <br> </li></ul><br><h3>  Résultat de la deuxième tentative </h3><br>  Nous avons résolu le problème de la <b>livraison</b> au client - les informations sont cousues sur le site de production et <b>rien n'a besoin d'être restauré</b> . <br><br>  Il est important que nous ayons résolu le problème de la <b>fourniture de «secrets» aux services de haut niveau</b> , car tout ce qui doit être stocké sur le service est la clé publique du fabricant.  La clé entière fait 33 octets.  Avec leur aide et leur magie mathématique, vous pouvez continuer à établir une connexion de prise de contact et vérifier que l'appareil possède la clé privée correspondante. <br><br>  <b>Sur le serveur,</b> nous stockons uniquement la clé du fabricant (clé publique racine). <br><br>  Nous n'avons pas de <b>synchronisation entre les services et l'intranet</b> , dont nous avons déjà parlé.  De plus, nous n'avons aucune <b>protection contre la copie de détails</b> . <br><br>  La seule chose que nous avons oubliée est l' <b>authentification</b> .  L'appareil a envoyé une clé privée, et nous avons vérifié que nous l'avons fait et délivré, et vérifié que l'appareil en est le propriétaire.  Mais nous ne savons pas de quel type d'appareil il s'agit et nous en produisons des milliers. <br><br>  Par conséquent, nous avons appliqué une astuce appelée «Certificat». <br><br><h2>  Authentification et certificats </h2><br>  À cette étape, dans toute la magie mathématique avec les signatures et leurs contrôles, nous ajoutons <b>des informations supplémentaires - un certificat</b> .  Pour ce faire, nous signons en usine non seulement la clé publique (clé publique de l'appareil), mais la clé avec des informations supplémentaires. <br><br>  Informations supplémentaires dans notre cas. <br><br><ul><li>  Date de fabrication et fabricant. <br></li><li>  Configuration du modèle et du matériel. <br></li><li>  Numéro de série par lequel l'appareil peut être authentifié. <br></li><li>  Options: matériel et logiciel.  Différentes configurations peuvent ne pas différer physiquement les unes des autres, mais le certificat contiendra des informations sur ce que le client a payé. <br></li><li>  Nom du client et numéro de compte. <br></li></ul><br>  Nous signerons toutes ces informations avec la clé publique avec notre clé de producteur - clé publique racine.  Après cela, les informations iront aux services et ils pourront s'assurer qu'ils sont corrects.  Comme ce sont nos services et ceux de nos partenaires, ils nous font confiance. <br><br><h3>  Statut de l'objectif </h3><br>  Les informations sont également cousues à l'usine et la <b>livraison</b> aux services n'est pas nécessaire.  <b>Sur le serveur, nous</b> stockons uniquement la clé du fabricant. <br><br>  <b>Récupération des pertes</b> .  Nous cousons toutes les informations des certificats dans la mémoire flash de l'appareil.  Théoriquement, il peut être supprimé accidentellement ou intentionnellement, mais il n'y a rien de secret dans ces informations dans le certificat.  Même la signature elle-même n'est pas secrète - il y a une clé publique et la signature avec notre clé.  Le seul secret du certificat est le volume des ventes d'appareils avec différentes options. <br><br>  Le certificat peut être stocké en usine et envoyé au client s'il l'a perdu.  Les clients effacent rarement spécifiquement la zone de service de la mémoire.  Habituellement, nous le faisons pendant la procédure de récupération de l'appareil: l'appareil est arrivé du client, il est complètement passé par l'initialisation, tout est effacé, il est téléchargé à nouveau et le certificat est copié de la base de données d'usine. <br><br>  Nous n'avons pas de <b>récupération de</b> perte, de protection contre la copie et de <b>synchronisation entre les services</b> . <br><br>  <b>Au stade de l'authentification,</b> nous recevons et vérifions le certificat.  Nous savons de quel type d'appareil il s'agit - nous connaissons le fabricant, le modèle et le numéro de série, ce qu'il peut et ne peut pas. <br><br><h3>  Se connecter </h3><br>  Le certificat vous permet de stocker des informations pour autorisation. <br><br>  <b>Service constructeur gratuit</b> .  Connaissant le numéro de série de l'appareil, vous pouvez donner accès à tout le monde.  Dans nos services, nous donnons accès à tous nos clients de base. <br><br>  <b>Listes blanches de numéros de série</b> .  Pour le service de nos partenaires, vous pouvez créer un tableau avec une liste blanche de numéros de série: «Le client Vasily nous a acheté deux contrôleurs avec de tels numéros de série associés à son compte» <br><br>  <b>Licences</b>  Vous pouvez vendre quelque chose à l'avance, puis autoriser ou refuser l'accès en <b>fonction des options</b> spécifiées dans le certificat - un contrôleur avec une licence pour le système X. <br><br>  Il n'y a pas de base commune entre les services, fabricant ou fabricant de systèmes.  Tout fonctionne exclusivement sur les informations du contrôleur qui sont signées par nous, en tant que fabricant, lors de l'authentification dans le système. <br><br><h2>  Certificat intermédiaire </h2><br>  Un autre problème technique que nous avons résolu sur la route.  Dans le schéma dont je viens de parler, il existe un certificat racine du fabricant - clé privée racine.  Il est physiquement nécessaire à chaque fois que vous créez un appareil.  Mais s'il existe de nombreux appareils, cette clé nécessite un accès constant pour un cercle limité de personnes.  C'est mauvais, car si vous le perdez, vous devrez mettre à jour les clés publiques sur tous les services, et cela ne devrait pas arriver aux attaquants.  Ce sont de gros problèmes d'organisation.  Mais il y a une solution. <br><br><blockquote>  Nous introduisons des clés intermédiaires dans un lot d'appareils qui ne sont pas si effrayants à perdre. </blockquote><br>  Nous avons fait de même, seule la chaîne est plus longue. <br><br><img src="https://habrastorage.org/webt/x-/mb/s3/x-mbs3xfmihxr-qjdmpm7f5buey.jpeg"><br><br>  Avec un certificat constructeur, nous signons la clé intermédiaire.  Physiquement, il s'agit d'un "lecteur flash", qui est remis au contremaître à l'usine pendant une journée.  Le matériel limite le nombre d'appareils qu'une clé peut signer.  Au milieu du schéma, nous avons ajouté un certificat intermédiaire, sinon rien n'a changé. <br><br><h2>  Magasin de clés sécurisé </h2><br>  Dans tout cela, nous n'avons pas suffisamment de <b>protection pour la clé privée de l'appareil</b> - c'est toujours un fichier qui se trouve sur une clé USB.  Un attaquant peut le copier, mais très probablement il le perdra ou ouvrira accidentellement l'accès. <br><br>  Dans le cas idéal, il serait bon de protéger la clé privée de l'appareil contre la copie - mettez-la dans une boîte noire. <br><br>  La boîte noire effectue 4 opérations: <br><br><ul><li>  à l'intérieur de lui-même génère une clé sur demande, mais ne donne pas; <br></li><li>  donne la clé publique; <br></li><li>  Signe un message <br></li><li>  vérifie la signature. <br></li></ul><br><img src="https://habrastorage.org/webt/by/ck/zf/byckzfred-odhrigx-ayq2gkytk.jpeg"><br>  <i>Pour vérifier la signature, vous n'avez besoin que d'une clé publique, donc trois opérations suffisent.</i> <br><br>  À ma connaissance, cela devrait être une solution matérielle, de préférence distincte du processeur.  Il existe plusieurs options, dont la meilleure est un <b>processeur cryptographique spécial à l'intérieur du SoC</b> ou en tant que puce distincte. <br><br>  La première option de boîte noire que nous avons examinée est le <b>module CAAM</b> dans les processeurs NXP i.mx 6, 7, 8 que nous utilisons.  Le problème est qu'il est implémenté par programme dans la ROM de démarrage du processeur. <br><br>  Il peut contenir des bogues qui peuvent être trouvés et même exploités via d'autres fonctionnalités du processeur.  Il y a quelques années, un trou a été découvert dans ce module qui permettait de contourner la vérification de signature lors du téléchargement du firmware.  Ce n'est pas la fonctionnalité dont nous avons besoin, mais les sédiments restent.  Un autre problème est qu'il est difficile d'importer des processeurs avec ce module en Russie; ils nécessitent de remplir des documents. <br><br>  Par conséquent, nous avons pris une puce distincte.  J'avoue honnêtement, je comptais sur le fait que si nous ne pouvons pas l'apporter en Russie, nous trouverons quelque chose - la puce est petite, elle coûte 1 $.  Mais tout s'est bien passé - ils ont trouvé la puce <b>Microchip ATECC</b> , qui a déjà tous les papiers. <br><br><h2>  Microchip ATECC608A </h2><br>  Il s'agit d'une petite puce séparée qui coûte un sou.  La puce est connectée via I2C - deux «jambes» du processeur, que vous pouvez également partager avec d'autres périphériques.  La puce a un brochage standard.  Nous avons utilisé la puce dans les premières versions de l'équipement et l'avons simplement soudée sur une autre puce avec le même protocole et le même brochage, car elle est standard. <br><br>  La puce peut faire ce dont nous avons besoin: lire les signatures, stocker les clés et bien plus encore. <br><br><img src="https://habrastorage.org/webt/_h/sb/jb/_hsbjbw9dyvjo2ta5emvp_wuqk4.jpeg"><br><br>  CARACTÉRISTIQUES <br><br><ul><li>  16 emplacements pour clés; <br></li><li>  peut lire les signatures ECSDSA, hachages, MAC et crypter AES, peut DH; <br></li><li>  possède un générateur de nombres aléatoires et des compteurs cryptographiques; <br></li><li>  Boîtiers: SOIC-8, DFN6; <br></li><li>  protocoles: I2C, monofil; <br></li><li>  ~0,7$@1000pcs. <br></li></ul><br><h3>  Comment travailler avec un microcircuit </h3><br>  Il existe une <b>documentation</b> décente <b>pour cela</b> , mais sous la NDA.  Si vous écrivez immédiatement à gamma.spb.ru, ils vous le donneront dans 2 semaines.  Si dans une autre entreprise - après 3 mois.  Nous avons écrit à deux sociétés, et lorsque nous avons tout fait, un autre revendeur Microchip nous a répondu. <br><br>  <b>Il y a peu d'appendices</b> et ils sont pires que la moyenne.  Il existe un <b>logiciel</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">sur GitHub</a> - une bibliothèque avec HAL.  C'est drôle - la documentation est sous le NDA, et le logiciel qui y est écrit est sur GitHub.  Le logiciel ne prend pas en charge Linux, mais prend en charge le Raspberry Pi et Atmel MK - c'est un peu différent.  Les développeurs estiment que sur tous les équipements, il n'y a qu'un seul bus I2C, par exemple, les jambes sont appelées comme sur le Raspberry Pi. <br><br>  Il y a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">intégration</a> avec <b>OpenSSL</b> - cela ne fonctionne pas bien, mais c'est le cas.  <b>Il n'y a aucun exemple sous Linux</b> et aucun travail avec la <b>personnalisation</b> . <br><br><h3>  Personnalisation de la puce </h3><br><blockquote>  La personnalisation est le plus gros casse-tête avec la puce. </blockquote><br>  Le problème est que la puce peut faire beaucoup de choses.  Il dispose de 16 emplacements dans lesquels 16 clés sont stockées: données utilisateur ou clés publiques, ou stockage temporaire pour d'autres emplacements - il existe de nombreuses options. <br><br>  Vous devez en quelque sorte restreindre l'accès aux emplacements, et il existe également de nombreuses options de configuration: restreindre par mot de passe, par authentification dans un autre emplacement, au moment de l'accès aux usines. <br><br><img src="https://habrastorage.org/webt/-a/du/mm/-adumml8w8ijipo3nbep8jz5nry.jpeg"><br>  <i>Dans le tableau, le type de clé, l'accès en lecture et en écriture, la relation entre les emplacements - SlotConfig, KeyConfig.</i> <br><br>  Dans le masque de bits (16 bits) de chaque clé que nous utilisons, il y a des nombres différents partout. <br><br>  Le plus triste est que la zone de configuration est unique, ce qui définit les fonctions des emplacements.  Nous avons raté 50 jetons avant de tout faire correctement.  La puce ne fonctionne <b>qu'après verrouillage de la configuration</b> .  Séparément, il y a un <b>verrou pour les emplacements individuels</b> <br><br>  Il n'y a pas de documentation dans les exemples ou dans le logiciel.  Il y a de la documentation pour des bits individuels, mais tout y est compliqué.  Dans tous les exemples de Microchip, il est écrit: «Téléchargez un tel bloc, et cela fonctionnera en quelque sorte pour vous, comme dans l'exemple d'envoi de données à Amazon.» <br><br>  Cela a pris beaucoup de temps, mais dans le processus, ils ont fait un utilitaire cool. <br><br><h3>  Utilitaire Atecc-util </h3><br>  Il s'agit d'un utilitaire de console qui peut exécuter la plupart des fonctions de la puce et vous permet de travailler un peu plus facilement.  Il est disponible <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">sur GitHub</a> sous une licence MIT. <br><br>  L'utilitaire utilise CryptoAuthLib.  Elle sait travailler plus amicalement avec la zone de configuration, elle sait travailler avec SHA, MAC, ECDSA, DH.  L'interface est conviviale par lots, car nous avons créé l'utilitaire pour une utilisation dans les scripts en premier lieu.  Le fait qu'une personne puisse la provoquer est une caractéristique secondaire.  L'utilitaire peut faire une liste - un plan de commandes: "Tout d'abord, personnalisez cette zone, puis notez une telle clé." <br><br>  Un exemple d'appel d'un utilitaire est tout à fait lisible par l'homme. <br><br><pre> <code class="plaintext hljs">atecc - b 10 - c 'serial' - c 'read-config /tmp/config.dump'</code> </pre> <br>  L'utilitaire est construit sous Linux, sous AMD64 - il est dans le paquet Debian. <br><br><img src="https://habrastorage.org/webt/lc/yr/bs/lcyrbsjcuggnfwuzetwwjy3auxg.jpeg"><br><br><h3>  Autres outils de personnalisation </h3><br>  Nous avons une plaque Excel pour lire les bits.  Si vous nous montrez un scan NDA avec Microchip, nous vous le donnerons. <br><br><img src="https://habrastorage.org/webt/gs/j5/r9/gsj5r9tr6ngrcascp8tqxdq6dla.jpeg"><br><br>  Nous avons tout couvert avec des tests, car il existe de nombreuses options lorsque vous pouvez oublier un bit et qu'une commande de service lira votre clé privée.  Les tests testent le véritable appareil.  Ils se tournent vers le microcircuit et vérifient la configuration correcte sur l'appareil: peut-on lire cet emplacement, peut-on faire une telle signature? <br><br>  Parallèlement aux bits, nous avons créé une liste de garanties que cet appareil doit satisfaire et vérifié le fonctionnement de tout.  Nous utilisons le <b>cadre des chauves</b> - <b>souris</b> - une chose très intéressante.  Cela ressemble à ceci. <br><br><img src="https://habrastorage.org/webt/wr/kd/op/wrkdopidmf6zn2ko70ue36p7fxc.jpeg"><br>  <i>Liste de tests pour un exemple.</i>  <i>Les supérieurs sont passés, mais les inférieurs ne le sont pas.</i> <br><br><h3>  Paramètres dans les appareils </h3><br>  <b>Pour nous, nous n'utilisons que deux emplacements</b> pour la tâche dont je parle.  Dans les deux, nous stockons la clé privée de l'appareil.  La différence est que le premier est associé à un <b>certificat permanent</b> , délivré en 1970 pour 200 ans. <br><br>  Cela est dû au fait que dans IoT, le temps n'est pas toujours synchronisé.  L'infrastructure de certificat implique de vérifier la validité d'un certificat.  Si la synchronisation sur les appareils est interrompue, certains services vitaux peuvent échouer, par exemple VPN. <br><br>  Par conséquent, <b>un emplacement est infini - permanent</b> .  Il est généré une fois et ne change pas pendant la durée de vie de l'appareil.  Pour cette clé, un certificat est généré pendant 200 ans - pour les réseaux fermés. <br><br>  Un autre emplacement est en cours de mise à jour.  La durée de vie maximale d'un certificat est d'un an.  Cela se fait au cas où quelque chose est compromis.  Une clé d'appareil pouvant être mise à jour privée est générée lorsque la période de validité du certificat d'appareil expire.  Utilisé pour l'authentification dans les réseaux ouverts, mis à jour une fois par mois ou moins, avec un certificat. <br><br>  <b>Pour les utilisateurs, nous avons généré diverses combinaisons</b> , dont plusieurs emplacements pour les clés ECDSA privées.  Les utilisateurs peuvent générer leur clé dans un emplacement séparé s'ils ne font pas confiance à notre clé privée.  Pour cela, vous ne devez faire confiance qu'à Microchip.  Les utilisateurs peuvent lire les signatures, chiffrer - nous avons donné tout ce que la puce peut faire. <br><br>  Jusqu'à présent, malheureusement, personne n'a utilisé, mais nous l'espérons. <br><br><h3>  Infrastructure: clés intermédiaires </h3><br>  J'ai déjà dit qu'à un moment donné, nous avons implémenté des certificats intermédiaires afin de ne pas briller avec un certificat racine qui ne devrait pas être perdu.  Il n'apparaît jamais dans une usine. <br><br><img src="https://habrastorage.org/webt/uh/m0/dl/uhm0dl6mdkegvzwl2avlsqpe7kc.jpeg"><br><br>  Les certificats physiquement intermédiaires sont une puce ATECC508A.  Il diffère légèrement du 608, mais en 508, il existe des fonctionnalités utiles pour les touches, mais en 608, il n'est plus là. <br><br>  La puce est connectée via un adaptateur USB-I2C.  Il s'agit d'USBISP avec un micrologiciel USB-i2c minuscule - un programmeur qui peut être flashé dans un pont USB-I2C.  Les certificats intermédiaires signent les certificats d'appareil avec leur clé privée. <br><br>  Deux caractéristiques du microcircuit se sont avérées utiles pour nous. <br><br>  <b>Emplacement de protection par mot de passe matériel</b> .  La puce ne peut être programmée pour lire la signature que si deux conditions sont remplies: <br><br><ul><li>  lorsque l'appareil est coincé dans un ordinateur; <br></li><li>  mot de passe saisi. <br></li></ul><br>  Nous remettons au contremaître à la production une clé intermédiaire et un mot de passe pour plusieurs contrôleurs.  En conséquence, vous devez voler à la fois la clé et le mot de passe pour y accéder.  Nous avons eu cette opportunité gratuitement, mais cela améliore la sécurité du système. <br><br>  <b>Limite matérielle du nombre d'utilisations</b> .  Le compteur cryptographique à l'intérieur ne peut qu'augmenter.  Lorsqu'il atteint une fois une limite prédéterminée, le microcircuit ne signe rien d'autre. <br><br><img src="https://habrastorage.org/webt/tm/qv/4-/tmqv4-eakpcudfupub3oy6nt9bw.jpeg"><br><br><h2>  OpenSSL sur le client </h2><br>  Voyons comment tout fonctionne sur le client.  Nous avons OpenSSL sur le contrôleur.  Nous n'avons rien inventé - c'est TLS ordinaire, PKI ordinaire.  Nous avions également besoin d'une bibliothèque cliente.  Dans la grande majorité des logiciels Linux, il est utilisé pour une connexion sécurisée. <br><br>  Nous avons pris le code de Microchip, l'avons ajouté un peu, pris en charge le nouveau OpenSSL <br>  1.1.  Par conséquent, il sait comment travailler avec une clé matérielle - le matériel prend en charge les mots de passe pour les clés privées. <br><br>  Cela ressemble à ceci. <br><br><pre> <code class="plaintext hljs">openssl req -new -engine ateccx08 -keyform engine -key ATECCx08:00:04:C0:00 -subj "/CN=wirenboard-AP6V5MDG" -out device AP6V5MDG.csr</code> </pre> <br>  Il s'agit d'un appel à OpenSSL standard et d'une instruction d'utilisation du module moteur approprié.  La clé est définie ici: adresse, modèle et les deux derniers octets sont le numéro de l'emplacement utilisé.  Tout est transmis comme s'il s'agissait d'un fichier clé, mais ce n'est pas un fichier - vous devez entrer dans l'appareil. <br><br><h2>  SSL sur le serveur </h2><br>  Tout SSL fonctionne sur le serveur, y compris OpenSSL.  Aucune modification et builds personnalisés côté serveur ne sont nécessaires.  Tout ce qui est nécessaire sur le serveur est <b>de pouvoir vérifier la chaîne du bundle de certificats</b> (certificat de périphérique + certificat intermédiaire), et <b>stocker notre clé publique</b> , que nous avons publiée sur le site - Wiren Board ROOT CA. <br><br>  TLS standard indique que les deux parties doivent s'authentifier mutuellement.    —   —   .    —    handshake. <br><br>         :    .    ,         .   letsencrypt    SSL,   ,      . <br><br>       ,    — MQTT. <br><br><h2> MQTT: mosquitto   </h2><br>          IBM.               . <br><br> Mosquitto —       ,   ,  Linux.    ,   OpenSSL engine (  )    «keyfile»,     . <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="></a>   ,  20 . <br><br>     bundle. <br><br><img src="https://habrastorage.org/webt/ea/ju/ge/eajugei4pidm4h7ramzyhh-vpkq.jpeg"><br><br>             . <br><br><pre> <code class="plaintext hljs">mosquitto_sub -h mqtt.wirenboard.com -p 8884 -cert /etc/ssl/device/device_bundle.crt.pem --key 'engine:ateccx08:ATECCx08:00:04:C0:00' --capath /etc/ssl/certs/ -t /# -v</code> </pre> <br>     .     —    <code>-cert</code> .   bundle- — .      <code>--key</code> .       . <br><br>  ,    <code>--capath</code> ,    .       SSL-,     letsencrypt. <br><br>   <b> </b> . <br><br><pre> <code class="plaintext hljs">root@wirenboard-AXXVJI62:~# cat /etc/mosquitto/conf.d/bridge-hw.conf connection wb_devices_cloud.wirenboard-AXXVJI62 address contactless.ru:8884 bridge_capath /etc/ssl/certs/ bridge_certfile /etc/ssl/device/device_bundle.crt.pem bridge_keyfile engine:ateccx08:ATECCx08:00:04:C0:00 notifications true notification_topic /client/wirenboard-AXXVJI62/bridge_status topic/# both 1 ""/dient/wirenboard-AXXVJI62</code> </pre> <br> Mosquito-     . <br><br> <b>   Mosquitto</b> —    . <br><br><pre> <code class="plaintext hljs">per _listener_settings true listener 8884 0.0.0.0 cafile/etc/mosquitto/certs/WirenBoard_Root_CA.crt certfile /etc/letsencrypt/live/contactless.ru/fullchain.pem keyfile/etc/letsencrypt/live/contactless.ru/privkey.pem require.certificate true use_identity_as_username true password_file /etc/mosquitto/passwd.conf allow_anonymous false acl_file /etc/mosquitto/ad.conf :~$ cat /etc/mosquitto/acl.conf pattern write /client/%u/# pattern read /client/%u/#</code> </pre> <br>   —  . <br><br><ul><li>  Root CA  letsencrypt-   —   .     . <br></li><li>    Mosquitto.           <code>username</code>      MQTT. <br></li><li>  ,     , ,   (CN) wirenboard-AXXVJI62,   ,      . <br></li><li> <code>per_listener_settings:</code>   ,      / (&gt;1.5.5). <br></li></ul><br>    MQTT-  Wiren Board IoT Cloud Platform. <br><br><h2>  Openvpn </h2><br> OpenVPN  ,      ,     .   ,                . <br><br>  OpenVPN <b> </b>   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="></a> ,   .       ,   : bundle,  , engine. <br><br><pre> <code class="plaintext hljs">openvpn --capath /etc/ssl/certs/ --cert /etc/ssl/device/device_bundle.crt.pem --key engine:ateccx08:ATECCx08:00:04:C0:00</code> </pre> <br> <b> </b>    letsencrypt. <br><br><pre> <code class="plaintext hljs">ca /etc/openvpn/WirenBoard_Root_CA.crt cert /etc/letsencrypt/live/vpn1.wirenboard.com/fullchain.pem key /etc/letsencrypt/live/vpn1.wirenboard.com/privkey.pem</code> </pre> <br>     —       .      -  . <br><br><h2>  Nginx </h2><br>   . Nginx   ,    ,        , SSL.      nginx     web-,  reverse-proxy.   —      nginx. <br><br> nginx   ,  HTTP-,       .   ,       : Common Name,      ,        .   ,   400. <br><br><pre> <code class="plaintext hljs">ssl_client_certificate WirenBoard_Root_CA.crt; ssl_verify_client on;</code> </pre> <br> <b>nginx  </b> .     — ,     HTTP.  Linux-   nginx  ,        SSL,   ,   OpenSSL. <br><br>    wget  , bash    ,   HTTP-  TLS   .    10 . <br><br><pre> <code class="plaintext hljs">server { listen 8080; location / { proxy_pass https://example.com; proxy_ssl_name example.com; proxy_ssl_server_name on; proxy_ssl_certificate/etc/ssl/device/device_bundle.crt.pem; proxy_ssl_certificate_key engine:ateccx08;ATECCx08:00:04:C0:00; } }</code> </pre> <br><h2>   </h2><br>      <b>Wiren Board 6</b> ,     .     ,       . <br><br>         web-   cloud.wirenboard.com  OpenVPN  .     Grafana  InfluxDB,      MQTT.     saymon.info —    (MQTT)  . <br><br>      ,  -  ,     , Grafana, MQTT-,   ,  , .   — . <br><br>  ,    ,   : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="> </a> —  OpenSSL    ,  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="> </a> —  .  ! <br><br><blockquote>           <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">InoThings Conf 2019</a> .   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">YouTube-</a>       2019 .    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="></a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="></a>  Telegram.     ,  ,       IoT. </blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr476304/">https://habr.com/ru/post/fr476304/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr476292/index.html">SVG ou toile?</a></li>
<li><a href="../fr476294/index.html">Réseau de jeu distribué comme alternative à GFN: comment et pourquoi il peut décoller, là où il fonctionne déjà en Fédération de Russie</a></li>
<li><a href="../fr476296/index.html">21 novembre, Meetup d'ingénierie produit: qui est ingénieur produit?</a></li>
<li><a href="../fr476298/index.html">Parcourez les épines des vélos, première partie: découvrez les bases de la personnalisation du débogueur Visual Studio à l'aide de plugins</a></li>
<li><a href="../fr476300/index.html">Le magazine Tram est une star brillamment éclairée et rapidement fanée de l'avant-garde russe pour enfants</a></li>
<li><a href="../fr476306/index.html">Instructions TelegramBot pour créer des fonctionnalités de base pour le bot. (Partie 1)</a></li>
<li><a href="../fr476308/index.html">Les 5 meilleures pratiques de développement logiciel à suivre en 2020</a></li>
<li><a href="../fr476310/index.html">CRM visage humain</a></li>
<li><a href="../fr476312/index.html">React ou Angular ou Vue.js - que choisir?</a></li>
<li><a href="../fr476316/index.html">Vue Storefront: Remplissez les données dans ES</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>