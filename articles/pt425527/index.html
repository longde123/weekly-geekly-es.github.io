<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üîÅ üôçüèº üë∞üèæ Listas em Kotlin. Abordagem Haskell üë®üèæ‚Äçüéì üë©üèº‚Äçüåæ ‚ú¥Ô∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Haskell √© uma linguagem totalmente funcional e extremamente concisa. Quem j√° tentou escrever c√≥digo em Haskell percebe como √© conciso e elegante o que...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Listas em Kotlin. Abordagem Haskell</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/425527/">  Haskell √© uma linguagem totalmente funcional e extremamente concisa.  Quem j√° tentou escrever c√≥digo em Haskell percebe como √© conciso e elegante o que escreve a mesma coisa em uma linguagem imperativa.  Conseguir o mesmo em Java, na minha opini√£o, √© imposs√≠vel, mas o Kotlin permite que voc√™ se mova nessa dire√ß√£o e experimente um estilo totalmente funcional.  Podemos derivar todas as fun√ß√µes complexas que precisamos desde a base das 3 fun√ß√µes mais famosas: mapear, filtrar, reduzir.  Al√©m disso, criei um <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">reposit√≥rio</a> que voc√™ pode estudar e ver os testes. <br><a name="habracut"></a><br>  Antes de come√ßar, gostaria de chamar a aten√ß√£o para o fato de que n√£o vale a pena implementar uma abordagem funcional dessa maneira, porque o c√≥digo ser√° extremamente lento e n√£o deve ser usado em aplicativos de produ√ß√£o.  Certamente existem op√ß√µes para aprimor√°-lo, mas o objetivo do artigo n√£o √© revelar essas op√ß√µes, mas considerar uma abordagem alternativa para escrever c√≥digo.  De qualquer forma, o entendimento dessa abordagem o ajudar√° com estruturas de dados recursivas, e voc√™ poder√° apreciar a beleza e a eleg√¢ncia de como o c√≥digo √© lido e o qu√£o mais f√°cil √© entender. <br><br><h3>  Fun√ß√µes b√°sicas </h3><br>  As listas desempenham um papel muito importante na linguagem e muitas fun√ß√µes √∫teis s√£o implementadas para elas.  Vejamos alguns deles e como eles podem ser implementados no Kotlin. <br><br><pre><code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">head</span></span> (x:_) = x head [] = badHead</code> </pre> <br>  Se houver elementos na lista, retornaremos o primeiro, caso contr√°rio, retornaremos um erro. <br>  N√£o temos a oportunidade de escrever esse c√≥digo, mas, em geral, se voc√™ olhar de perto, √© muito parecido com o modelo.  Tamb√©m usaremos a fun√ß√£o de extens√£o para poder usar posteriormente esse m√©todo em listas e ter uma maneira um pouco mais concisa de obter o valor, sem os colchetes no final, como uma chamada de m√©todo. <br><br><pre> <code class="hljs kotlin"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> &lt;T&gt; List&lt;T&gt;.head: T <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>() = <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.isEmpty()) { <span class="hljs-literal"><span class="hljs-literal">true</span></span> -&gt; <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> NoSuchElementException(<span class="hljs-string"><span class="hljs-string">"List is empty."</span></span>) <span class="hljs-literal"><span class="hljs-literal">false</span></span> -&gt; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>[<span class="hljs-number"><span class="hljs-number">0</span></span>] }</code> </pre><br>  Para usar convenientemente a recurs√£o, tamb√©m gostar√≠amos de dividir a lista no primeiro elemento + em todos os outros.  Vamos tentar implementar a fun√ß√£o tail para isso. <br><br>  Aqui est√° o que parece no haskell: <br><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">tail</span></span> (_:xs) = xs tail [] = errorEmptyList <span class="hljs-string"><span class="hljs-string">"tail"</span></span></code> </pre><br>  Infelizmente, o Kotlin n√£o fornece um n√≠vel de correspond√™ncia de padr√µes que os desenvolvedores possam descrever no mesmo estilo; portanto, aqui temos que escrever um pouco quando. <br><br><pre> <code class="hljs xml">val <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">T</span></span></span><span class="hljs-tag">&gt;</span></span> List<span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">T</span></span></span><span class="hljs-tag">&gt;</span></span>.tail: List<span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">T</span></span></span><span class="hljs-tag">&gt;</span></span> get() = drop(1)</code> </pre><br>  √â um pouco desonesto usar uma fun√ß√£o da biblioteca de idiomas, mas, por outro lado, ter√≠amos que escrever c√≥digo para esse m√©todo, portanto, seria melhor usar m√©todos j√° em funcionamento. <br><br>  Agora podemos dividir a lista no primeiro elemento + no restante da lista.  Tamb√©m precisamos da fun√ß√£o de concatenar a lista e um elemento, que ser√° usado ativamente posteriormente para convers√£o e outras opera√ß√µes na lista. <br><br><pre> <code class="hljs kotlin"><span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">&lt;T&gt;</span></span></span><span class="hljs-function"> List</span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">&lt;T&gt;</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">plus</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">T</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: List&lt;T&gt; = ArrayList(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>).also { it.add(x) }</code> </pre><br>  Agora, podemos adicionar uma lista ao elemento no final, e nossa implementa√ß√£o da fun√ß√£o map fica funcionando e pronta para uso.  Infelizmente, novamente, n√£o h√° como adicionar um objeto √† lista de maneira mais conveniente; portanto, usamos o m√©todo <b>add</b> . <br><br>  No momento, temos quase tudo o que precisamos.  A √∫nica coisa que precisamos agora √© ser capaz de descrever a condi√ß√£o de contorno para sair da recurs√£o.  Para fazer isso, usaremos o m√©todo <b>isEmpty ()</b> padr√£o.  Vamos parar e ver o que temos no momento: <br><br><ul><li>  isEmpty () - existem elementos na lista </li><li>  head - o primeiro elemento da lista </li><li>  tail - uma lista sem o primeiro elemento </li><li>  list + elemento - podemos concatenar a lista com um objeto </li></ul><br>  Na verdade, √© tudo o que precisamos para obter todos os m√©todos que precisamos. <br>  Para meu gosto, seria mais conveniente usar a compara√ß√£o do comprimento da lista nas declara√ß√µes <b>when</b> .  O Kotlin j√° nos fornece o <b>tamanho</b> para obter o tamanho dessa lista.  No entanto, suponha que queremos implement√°-lo n√≥s mesmos.  Com nossa funcionalidade, ser√° bastante simples: <br><br><pre> <code class="hljs kotlin"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> &lt;T&gt; List&lt;T&gt;.size: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>() = <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.isEmpty()) { <span class="hljs-literal"><span class="hljs-literal">true</span></span> -&gt; <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span> -&gt; <span class="hljs-number"><span class="hljs-number">1</span></span> + <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.tail.size }</code> </pre><br><h3>  Aplica√ß√£o de fun√ß√µes b√°sicas </h3><br>  Considere o exemplo mais comum.  Suponha que tenhamos uma lista de n√∫meros inteiros e que queremos resumir, esquecendo a exist√™ncia de ciclos.  Tudo o que temos s√£o os m√©todos que derivamos acima e recurs√£o.  Para fazer isso, usaremos a mesma abordagem ao calcular o tamanho da lista: <br><br><pre> <code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sum</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(xs: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">List</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;)</span></span></span></span>: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> (xs.size) { <span class="hljs-number"><span class="hljs-number">0</span></span> -&gt; <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> -&gt; xs.head + sum(xs.tail) }</code> </pre><br>  A ideia √© muito simples: se n√£o houver elementos na lista, a soma ser√° 0;  caso contr√°rio, √© a soma do primeiro elemento e uma chamada recursiva da soma da cauda. <br><br>  Apesar de n√£o nos importarmos com velocidade e otimiza√ß√µes neste c√≥digo, n√£o podemos deixar de lembrar os recursos do idioma para usar a recurs√£o de cauda.  Recurs√£o de cauda √© um caso especial de recurs√£o em que uma chamada recursiva √© a √∫ltima opera√ß√£o antes de retornar de uma fun√ß√£o.  Esse tipo de recurs√£o √© digno de nota porque √© garantido para permitir que voc√™ reconstrua o c√≥digo para itera√ß√£o.  Como voc√™ sabe, o principal problema da recurs√£o √© que, durante a execu√ß√£o da fun√ß√£o, √© necess√°rio armazenar a pilha de chamadas para que, quando a condi√ß√£o de limite for atingida, voc√™ possa voltar e recalcular o resultado final. <br><br>  Pode parecer que a fun√ß√£o da quantidade que descrevemos seja exatamente assim, porque a √∫ltima chamada √© <b>soma (xs.tail)</b> .  No entanto, isso n√£o √© verdade.  Se voc√™ descrever o c√≥digo de maneira um pouco diferente, ficar√° √≥bvio: <br><br><pre> <code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sum</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(xs: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">List</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;)</span></span></span></span>: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> (xs.size) { <span class="hljs-number"><span class="hljs-number">0</span></span> -&gt; <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> -&gt; { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> head = xs.head <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> tailSum = sum(xs.tail) head + tailSum } }</code> </pre><br>  Agora vemos que, de fato, a √∫ltima chamada √© a soma do primeiro elemento e a parte restante da cauda. <br><br>  A boa not√≠cia √© que, se voc√™ adicionar o modificador <b>tailrec</b> a uma fun√ß√£o, o IDE informar√° que a fun√ß√£o n√£o √©.  No entanto, corrigir isso √© bem direto.  Um truque comum que corrige uma fun√ß√£o √© usar uma vari√°vel auxiliar para armazenar os resultados.  √â assim: <br><br><pre> <code class="hljs kotlin"><span class="hljs-keyword"><span class="hljs-keyword">tailrec</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sum</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(xs: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">List</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;, acum: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> (xs.size) { <span class="hljs-number"><span class="hljs-number">0</span></span> -&gt; acum <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> -&gt; sum(xs.tail, xs.head + acum) }</code> </pre><br>  Para calcular a soma dos elementos, basta passar 0. como o segundo par√¢metro n√£o √© necess√°rio. <br><br><pre> <code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sum</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(xs: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">List</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;)</span></span></span></span>:<span class="hljs-built_in"><span class="hljs-built_in">Int</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">tailrec</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sumInner</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(xs: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">List</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;, acum: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> (xs.size) { <span class="hljs-number"><span class="hljs-number">0</span></span> -&gt; acum <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> -&gt; sumInner(xs.tail, xs.head + acum) } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> sumInner(xs, <span class="hljs-number"><span class="hljs-number">0</span></span>) }</code> </pre><br>  Tendo esse conhecimento, voc√™ pode ver que a fun√ß√£o de tamanho que implementamos acima n√£o satisfaz as condi√ß√µes necess√°rias para a recurs√£o da cauda. <br><br>  Agora estamos prontos para implementar o mapa, filtrar e reduzir usando o Kotlin.  Mais tarde veremos que bastava perceber que apenas o √∫ltimo, e o restante, de um modo geral, s√£o derivados dele.  Mas as primeiras coisas primeiro. <br><br><h3>  Fun√ß√µes principais </h3><br><h4>  MAPA </h4><br>  Uma implementa√ß√£o iterativa dessa fun√ß√£o envolve movimento seq√ºencial pela lista, usando a fun√ß√£o de convers√£o e adicionando todos os elementos recebidos √† nova cole√ß√£o.  Usaremos chamadas recursivas em que a condi√ß√£o de contorno √© uma lista vazia.  A implementa√ß√£o ficar√° assim: <br><br><pre> <code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">&lt;T, R&gt;</span></span></span><span class="hljs-function"> List</span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">&lt;T&gt;</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">map</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(f: (</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">T</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> -&gt; R): List&lt;R&gt; = <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.size) { <span class="hljs-number"><span class="hljs-number">0</span></span> -&gt; listOf() <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> -&gt; f(head) + tail.map(f) }</code> </pre><br>  Se n√£o houver elementos na lista original, retornaremos uma lista vazia; caso contr√°rio, aplicaremos a transforma√ß√£o ao primeiro elemento e adicionaremos uma chamada recursiva ao final pelo restante da lista. <br><br>  No entanto, ainda n√£o temos uma fun√ß√£o para concatenar um elemento e uma lista.  Mas j√° podemos perceber isso.  Para come√ßar, derivamos um caso mais geral de concatena√ß√£o de um par de listas e, depois disso, o usamos para adicionar outra lista ao elemento. <br><br><pre> <code class="hljs xml">operator fun <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">T</span></span></span><span class="hljs-tag">&gt;</span></span> List<span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">T</span></span></span><span class="hljs-tag">&gt;</span></span>.plus(xs: List<span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">T</span></span></span><span class="hljs-tag">&gt;</span></span>): List<span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">T</span></span></span><span class="hljs-tag">&gt;</span></span> = when (xs.size) { 0 -&gt; ArrayList(this) else -&gt; (this + xs.head) + xs.tail } operator fun <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">T</span></span></span><span class="hljs-tag">&gt;</span></span> T.plus(xs: List<span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">T</span></span></span><span class="hljs-tag">&gt;</span></span>): List<span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">T</span></span></span><span class="hljs-tag">&gt;</span></span> = listOf(this) + xs</code> </pre><br><h4>  Filtro </h4><br>  A implementa√ß√£o ser√° muito semelhante ao mapa.  A √∫nica diferen√ßa √© que voc√™ precisa entender se precisa adicionar o elemento atual ao resultado.  Para fazer isso, chamaremos o lambda que recebemos como par√¢metro.  A implementa√ß√£o ter√° a seguinte apar√™ncia: <br><br><pre> <code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">&lt;T&gt;</span></span></span><span class="hljs-function"> List</span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">&lt;T&gt;</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">filter</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(f: (</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">T</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Boolean</span></span>): List&lt;T&gt; = <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.size) { <span class="hljs-number"><span class="hljs-number">0</span></span> -&gt; listOf() <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> -&gt; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (f(head)) head + tail.filter(f) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> tail.filter(f) }</code> </pre><br>  Se o elemento atual atender √† condi√ß√£o do filtro, adicione-o recursivamente ao final da lista, caso contr√°rio, continuaremos trabalhando apenas com o final da lista. <br><br><h4>  REDUZIR </h4><br>  A mais dif√≠cil de entender e, ao mesmo tempo, a fun√ß√£o mais poderosa (no mundo funcional, √© conhecida como <b>fold</b> ).  Na maioria das vezes, √© usado para recolher uma lista para um √∫nico item.  Voc√™ tem um certo valor inicial <b>s0</b> e tamb√©m h√° uma lista de elementos <b>a []</b> e uma fun√ß√£o <b>f</b> , que retorna um novo para o valor inicial e o pr√≥ximo elemento da lista.  <b>f (s0, a [0]) = s1</b> .  E assim, passamos sequencialmente por toda a lista de elementos, obtendo algum tipo de valor √∫nico na sa√≠da.  Um exemplo bastante comum √© a soma dos elementos da matriz.  Nesse caso, o valor inicial √© 0 e a fun√ß√£o retorna a soma de dois elementos: <b>f (s, a [i]) = s + a [i]</b> .  Considere como podemos implementar recursivamente essa fun√ß√£o. <br><br><pre> <code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">&lt;T, R&gt;</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">reduce</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(s: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">T</span></span></span></span><span class="hljs-function"><span class="hljs-params">, xs: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">List</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">R</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;, f: (</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">T</span></span></span></span><span class="hljs-function"><span class="hljs-params">, R)</span></span></span></span> -&gt; T): T = <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> (xs.size) { <span class="hljs-number"><span class="hljs-number">0</span></span> -&gt; s <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> -&gt; reduce(f(s, xs.head), xs.tail, f) }</code> </pre><br>  Em princ√≠pio, a implementa√ß√£o √© exatamente a mesma que analisamos acima.  Se n√£o houver elementos na lista, retornamos o valor atual, caso contr√°rio, calculamos o novo primeiro elemento e, novamente, chamamos a fun√ß√£o de redu√ß√£o para ele e o final da lista. <br><br>  Observe que tamb√©m podemos criar modifica√ß√µes nessa fun√ß√£o.  Por exemplo, n√£o passe o valor inicial, mas use o primeiro elemento da lista para isso.  Para entender que reduzir n√£o termina a√≠, imagine que usamos uma lista diferente como valor inicial.  Nesse caso, cada vez na itera√ß√£o, armazenaremos n√£o um valor, mas uma lista, gra√ßas √† qual nossas capacidades aumentam bastante.  Por exemplo, vamos tentar aplicar a fun√ß√£o de redu√ß√£o de forma que a sa√≠da seja a lista original: <br><br><pre> <code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">&lt;T&gt;</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">reduceSame</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(xs: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">List</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">T</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;)</span></span></span></span> = reduce(listOf&lt;T&gt;(), xs) { ys, s -&gt; ys + s }</code> </pre><br>  Agora, eu acho, voc√™ acha que poder√≠amos usar o filtro de redu√ß√£o, para uma implementa√ß√£o alternativa do mapa.  Desde que aprendemos a retornar exatamente a mesma lista com redu√ß√£o, precisamos fazer muito poucas altera√ß√µes para poder converter cada elemento.  Para filtro, tudo √© muito parecido. <br><br><pre> <code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">&lt;T, R&gt;</span></span></span><span class="hljs-function"> List</span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">&lt;T&gt;</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">map2</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(f: (</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">T</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> -&gt; R): List&lt;R&gt; = reduce(mutableListOf(), <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>) { xs, s -&gt; (xs + f(s)).toMutableList() } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">&lt;T&gt;</span></span></span><span class="hljs-function"> List</span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">&lt;T&gt;</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">filter2</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(f: (</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">T</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Boolean</span></span>): List&lt;T&gt; = reduce(mutableListOf(), <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>) { ys, s -&gt; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (f(s)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span><span class="hljs-symbol"><span class="hljs-symbol">@reduce</span></span> (ys + s).toMutableList() <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> ys }</code> </pre><br>  Al√©m disso, eles frequentemente esquecem que tamb√©m podemos usar a redu√ß√£o n√£o desde o in√≠cio da lista, mas do final.  Claro, podemos apenas expandir a lista e, depois disso, reduzir, mas isso n√£o √© interessante.  Vamos tentar escrever e entender como reduzir funciona para recolher a lista na ordem inversa. <br><br><pre> <code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">&lt;T, R&gt;</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">reduceRight</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(s: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">T</span></span></span></span><span class="hljs-function"><span class="hljs-params">, xs: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">List</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">R</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;, f: (</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">T</span></span></span></span><span class="hljs-function"><span class="hljs-params">, R)</span></span></span></span> -&gt; T): T = <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> (xs.size) { <span class="hljs-number"><span class="hljs-number">0</span></span> -&gt; s <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> -&gt; f(reduceRight(s, xs.tail, f), xs.head) }</code> </pre><br>  Se a lista n√£o estiver vazia, aplicamos a fun√ß√£o f ao resultado de dobrar a cauda da lista e o cabe√ßalho da lista.  Assim, o primeiro elemento ser√° processado por √∫ltimo;  pen√∫ltimo - 2¬∫ e assim por diante.  Para esta op√ß√£o, voc√™ tamb√©m pode adicionar modifica√ß√µes que usar√£o o √∫ltimo elemento da lista como um valor inicial, etc. <br><br>  Quase sempre, ao trabalhar com listas, voc√™ pode usar alguma combina√ß√£o dessas 3 fun√ß√µes para obter o resultado em que est√° interessado. <br><br>  Vamos tamb√©m implementar a fun√ß√£o <b>zip</b> , que nos permitir√° combinar 2 listas. <br>  Na entrada, temos 2 listas.  E queremos retornar uma lista de pares cujo comprimento √© igual ao m√≠nimo das listas originais. <br><br>  Como sempre, voc√™ precisa pensar em sair da recurs√£o e escrever uma fun√ß√£o. <br><br><pre> <code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">&lt;T, R&gt;</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">zip</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(xs: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">List</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">T</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;, ys: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">List</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">R</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;)</span></span></span></span>: List&lt;Pair&lt;T, R&gt;&gt; { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> (xs.isEmpty() || ys.isEmpty()) { <span class="hljs-literal"><span class="hljs-literal">true</span></span> -&gt; listOf() <span class="hljs-literal"><span class="hljs-literal">false</span></span> -&gt; Pair(xs.head, ys.head) + zip(xs.tail, ys.tail) } }</code> </pre><br>  Voc√™ pode adicionar suas pr√≥prias modifica√ß√µes, o que permitir√°, em vez de retornar um par de elementos, aplicar uma determinada fun√ß√£o a dois elementos.  No Haskell, essa fun√ß√£o √© chamada <b>zipWith</b> .  E √© implementado com a funcionalidade que conseguimos escrever de maneira muito simples: <br><br><pre> <code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">&lt;T, R, C&gt;</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">zipWith</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(xs: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">List</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">T</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;, ys: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">List</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">R</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;, f: (</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">T</span></span></span></span><span class="hljs-function"><span class="hljs-params">, R)</span></span></span></span> -&gt; C): List&lt;C&gt; = zip(xs, ys).map { f(it.first, it.second) }</code> </pre><br>  Muitas vezes, ao usar a abordagem funcional, surgem problemas quando voc√™ precisa executar manipula√ß√µes baseadas n√£o em objetos em listas, mas com base em √≠ndices.  Por exemplo, precisamos somar todos os elementos pares de uma lista.  Voc√™ pode tentar fazer isso com reduzir, mantendo o valor atual como Pair &lt;Int, Boolean&gt; e adicionando o valor se flag == true e aceitar a nega√ß√£o do flag toda vez na pr√≥xima etapa.  No entanto, isso n√£o parece muito bonito, e o leitor ter√° que descobrir o que voc√™ deseja expressar com este c√≥digo.  Kotlin tem seq√º√™ncias infinitas e s√£o √≥timas para resolver esse problema.  Se analisarmos o que queremos fazer, acontece que queremos filtrar todos os elementos com √≠ndices √≠mpares e somar os demais.  E para obter √≠ndices, basta chamar <b>zip</b> para a lista e <b>sequ√™ncia</b> [0,1,2 ..] <br><br><pre> <code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sumWithEvenIndexes</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(xs: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">List</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;)</span></span></span></span> = zip(xs, generateSequence(<span class="hljs-number"><span class="hljs-number">0</span></span>) { it + <span class="hljs-number"><span class="hljs-number">1</span></span> }.take(xs.size).toList()) .filter { it.second % <span class="hljs-number"><span class="hljs-number">2</span></span> == <span class="hljs-number"><span class="hljs-number">0</span></span> } .map { it.first } .sum()</code> </pre><br>  Na biblioteca padr√£o Kotlin, voc√™ pode encontrar a fun√ß√£o zip para o par de seq√º√™ncias. <br><br>  Agora, vejamos uma tarefa simples que me inspirou a escrever este guia e como sua implementa√ß√£o se parece em uma linguagem imperativa no Kotlin e no final em Haskell. <br><br>  √â necess√°rio calcular a quantidade m√°xima entre pares de n√∫meros adjacentes em uma matriz de n√∫meros inteiros.  O comprimento da matriz √© maior que 1 e voc√™ n√£o precisa se preocupar em transbordar ao somar elementos. <br><br>  Abordagem imperativa do Java: <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Integer </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">maxSum</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(List&lt;Integer&gt; array)</span></span></span><span class="hljs-function"> </span></span>{ Integer max = array.get(<span class="hljs-number"><span class="hljs-number">0</span></span>) + array.get(<span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">2</span></span>; i &lt; array.size(); i++) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (array.get(i) + array.get(i-<span class="hljs-number"><span class="hljs-number">1</span></span>) &gt; max) max = array.get(i) + array.get(i-<span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> max; }</code> </pre><br>  Uma abordagem funcional no Kotlin usando fun√ß√µes escritas (proponho implementar a fun√ß√£o max como um treinamento): <br><br><pre> <code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">maxSum</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(xs: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">List</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;)</span></span></span></span> = zipWith(xs, xs.tail, {a, b -&gt; a + b}).max()</code> </pre><br>  Implementa√ß√£o Haskell: <br><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">maxSum</span></span> xs = maximum $ zipWith (+) xs (tail xs)</code> </pre><br>  Como podemos ver, o que implementamos no Kotlin (a prop√≥sito, poder√≠amos usar o reduzir para resolver esse problema) √© muito semelhante ao que pode ser escrito em Haskell. <br><br><h3>  Conclus√£o </h3><br>  Sem d√∫vida, isso n√£o deve ser usado no desenvolvimento, porque tudo foi implementado de maneira n√£o otimizada apenas para demonstrar uma abordagem funcional.  Al√©m disso, quase tudo o que foi escrito est√° na biblioteca padr√£o do Kotlin; portanto, talvez no futuro, em vez de escrever outro loop for, voc√™ use o estilo funcional que o Kotlin nos fornece. <br><br>  Provavelmente o mais dif√≠cil no estilo funcional √© que o problema pode ser resolvido de maneiras diferentes.  O mais √≥bvio pode ser complicado e dif√≠cil de entender no futuro, e escrever o mais compreens√≠vel pode levar tempo e reflex√£o.  A √∫nica coisa que pode ajudar no dom√≠nio √© a pr√°tica e o treinamento constantes. <br><br>  PS: Como mencionado acima, voc√™ pode ver o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">reposit√≥rio</a> com todos os exemplos que est√£o no artigo.  Execute os testes e veja como funciona! <br><br>  PPS: voc√™ tamb√©m pode procurar uma abordagem alternativa que implemente <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">funcionalidade</a> semelhante. <br><br>  E n√£o deixe de ver mais tarde <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">https://arrow-kt.io/</a> .  Na minha opini√£o, voc√™ n√£o deve olhar para l√° imediatamente, porque tudo parece bem assustador, mas mais tarde, quando functores e m√¥nadas n√£o o assustarem, n√£o deixe de estud√°-lo. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt425527/">https://habr.com/ru/post/pt425527/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt425511/index.html">Recursos n√£o √≥bvios do aplicativo Rotativa para gerar PDF no aplicativo ASP.NET MVC</a></li>
<li><a href="../pt425515/index.html">Apple bloqueia reparo independente de novos modelos de MacBook</a></li>
<li><a href="../pt425517/index.html">Como o Yandex criou uma previs√£o global de precipita√ß√£o usando radares e sat√©lites</a></li>
<li><a href="../pt425521/index.html">M√©todos protegidos no JavaScript ES5</a></li>
<li><a href="../pt425525/index.html">Tim Berners-Lee entra em p√¢nico: "Um pequeno passo para a web ..."</a></li>
<li><a href="../pt425529/index.html">Sans Forgetica: uma fonte que permite memorizar um pouco melhor o que voc√™ l√™</a></li>
<li><a href="../pt425531/index.html">Arrefecimento por l√≠quido de trav√µes. Op√ß√µes de desenvolvimento do sistema</a></li>
<li><a href="../pt425533/index.html">Como trabalhar na nuvem: da verifica√ß√£o da confiabilidade de um data center ao gerenciamento de uma infraestrutura virtual</a></li>
<li><a href="../pt425537/index.html">Como combinar Java, Js e gr√°ficos com arte, ou a hist√≥ria de como um teatro interativo foi criado</a></li>
<li><a href="../pt425541/index.html">Como rapidamente e sem chips desnecess√°rios contornar a imutabilidade do endere√ßo do sensor HTU21</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>