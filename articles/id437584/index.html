<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ‘©ğŸ½â€ğŸ¤â€ğŸ‘©ğŸ¼ ğŸ’§ ğŸ‘§ğŸ¾ Dasar-Dasar Matematika dari Tata Letak Otomatis ğŸ‘¨ğŸ¾â€ğŸ’¼ ğŸ–ï¸ ğŸ§”</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Banyak pengembang percaya bahwa Tata Letak Otomatis adalah rem dan masalah, dan sangat sulit untuk men-debug itu. Dan bagus jika kesimpulan ini dibuat...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Dasar-Dasar Matematika dari Tata Letak Otomatis</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/oleg-bunin/blog/437584/">  Banyak pengembang percaya bahwa Tata Letak Otomatis adalah rem dan masalah, dan sangat sulit untuk men-debug itu.  Dan bagus jika kesimpulan ini dibuat berdasarkan pengalaman saya sendiri, dan kadang-kadang hanya "Saya dengar, saya bahkan tidak akan mencoba berteman dengannya". <br><br>  Tapi mungkin alasannya bukan di luar, tetapi di dalam.  Misalnya, burung yang paling berbahaya di dunia kasuari tidak akan menyerang orang tanpa alasan, hanya untuk membela diri.  Karenanya, coba asumsikan sesaat bahwa ini bukan Tata Letak Otomatis yang buruk, dan Anda tidak cukup memahaminya dan tidak tahu cara memasak.  Inilah yang dilakukan Anton Sergeyev dan menggali teori untuk memahami segala sesuatu dengan tepat.  Kami ditawari pemerasan siap pakai tentang dasar matematika dari Tata Letak Otomatis. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/xm/53/dw/xm53dwqnl0lczpswansphdrgbpi.png" width="360"></div><br><br><a name="habracut"></a><br>  Tata Letak Otomatis adalah <strong>sistem tata letak</strong> .  Sebelum membahasnya, mari kita bicara tentang pengaturan huruf modern secara umum.  Lalu mari kita berurusan dengan <strong>Tata Letak Otomatis</strong> - kita akan mencari tahu <strong>tugas apa yang dipecahkan</strong> dan bagaimana melakukannya.  Pertimbangkan <strong>fitur</strong> - <strong>fitur dalam penerapan Tata Letak Otomatis di iOS</strong> , dan coba kembangkan <strong>tip-tip praktis</strong> yang dapat membantu Anda mengatasinya. <br><br>  Cerita ini akan sangat dekat dengan artikel matematika, jadi pertama-tama kita sepakat tentang notasi untuk berbicara dalam bahasa yang sama. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/-eGciYD9i3I" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  <strong>Tentang pembicara:</strong> Anton Sergeev ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" class="user_link">antonsergeev88</a> ) bekerja di tim Yandex.Mart, berurusan dengan klien seluler untuk Maps di iOS.  Sebelum pengembangan ponsel, ia berurusan dengan sistem kontrol pembangkit listrik, di mana biaya kesalahan dalam kode terlalu tinggi untuk ditoleransi. <br><br><h2>  Penunjukan <br></h2><br>  Sistem persamaan linear sudah biasa bagi kita sejak sekolah - mereka ditunjukkan oleh kurung kurawal, dan solusinya sudah tanpa.  Juga, sistem persamaan linear memiliki entitas yang beroperasi dengan Tata Letak Otomatis - pembatasan.  Mereka ditunjukkan oleh garis lurus. <br><br><img src="https://habrastorage.org/webt/ql/qb/sa/qlqbsasmt7hb37gbgal6han6-4c.png"><br><br>  Yang aneh dan, seperti yang sudah kita ketahui, burung berbahaya tidak sengaja dicat di sudut atas slide.  Untuk menghormati kasuari (lat. Kasuari), yang, tentu saja, tinggal di Australia, sebuah algoritma diberi nama di semua iPhone kami. <br><br>  Tata Letak Otomatis memiliki batasannya sendiri, kami akan menunjukkannya dengan warna sesuai urutan prioritas: merah - wajib;  kuning - tinggi;  biru - rendah. <br><br><h2>  Tata letak <br></h2><br>  Ketika saya sedang membuat presentasi, saya meletakkan berbagai elemen di layar, misalnya, kasuari.  Untuk melakukan ini, saya memutuskan bahwa kasuari adalah gambar persegi panjang.  Anda perlu mengaturnya pada selembar yang memiliki sumbu dan sistem koordinatnya sendiri, dan untuk ini saya menentukan koordinat sudut kiri atas, lebar dan tinggi. <br><br><img src="https://habrastorage.org/webt/5s/rq/ci/5srqci-zsre1tg_nbnn3grczdno.png"><br><br>  Mengetahui keempat nilai ini cukup untuk mewakili Tampilan apa pun. <br><br><h3>  Algoritma No. 1 <br></h3><br>  Saat menempatkan kasuari di atas kertas, kami dengan sederhana menggambarkan algoritma tata letak pertama: <br><br><ul><li>  tentukan koordinat dan ukuran; </li><li>  terapkan ke UIView. </li></ul><br>  Algoritma berfungsi, tetapi cukup sulit untuk digunakan, jadi kami akan menyederhanakannya lebih lanjut. <br><br>  Misalkan di bawah ini adalah solusi untuk beberapa sistem persamaan linear. <br><br><img src="https://habrastorage.org/webt/ca/6i/ab/ca6iabqohj0bqr1rmujisor9fv4.png"><br><br>  Sistem persamaan linear adalah istimewa karena banyak operasi didefinisikan di atasnya: garis lipat, mengalikannya dengan konstanta, dll.  Operasi-operasi ini disebut transformasi linear, dan dengan bantuan mereka sistem dikurangi menjadi bentuk sewenang-wenang. <br><br>  Keindahan dari transformasi linear adalah mereka dapat dibalik.  Ini membawa kita ke ide yang menarik dan agak halus yang dengannya seluruh tata letak modern dimulai. <br><br>  Biarkan ada View - persegi panjang dengan koordinat dan ukurannya.  Kami ingin mengaturnya sehingga pusat bertepatan dengan poin yang diberikan.  Kami memodelkan pusat menggunakan transformasi linear - <strong>koordinat sudut kiri atas + setengah lebar</strong> . <br><br><img src="https://habrastorage.org/webt/yg/el/ic/ygelic6e5xa6orhvnaz7g5p_cki.png"><br><br>  Kami memodelkan pusat dengan transformasi linear, bukan: hanya ada koordinat titik kiri atas, lebar dan tinggi. <br><br>  Demikian pula, Anda dapat mensimulasikan lekukan lain, misalnya, 20 poin dari sudut kanan. <br><br><blockquote>  Ini adalah ide transformasi linear yang memungkinkan kita untuk membuat berbagai sistem penyusunan huruf. <br></blockquote><br>  Pertimbangkan contoh sederhana.  Kami menulis sebuah sistem yang kami gunakan dengan koordinat tengah dan kanan, lebar dan hubungan antara lebar dan tinggi.  Kami memecahkan sistem dan mendapatkan jawabannya. <br><br><img src="https://habrastorage.org/webt/hc/xc/hu/hcxchuyy2qvuvati_laj8afryig.png"><br><br>  Jadi kita sampai pada algoritma kedua. <br><br><h3>  Algoritma No. 2 <br></h3><br>  Iterasi kedua algoritma terdiri dari item berikut: <br><br><ul><li>  membuat sistem persamaan linear; </li><li>  kita menyelesaikannya; </li><li>  terapkan solusi untuk UIView. </li></ul><br>  Bayangkan bahwa kita berada di abad kedua puluh, pada saat peralatan komputer masih dalam masa pertumbuhan, dan kita adalah orang pertama yang menciptakan sistem tata letak kita sendiri.  Diciptakan, dikemas, diberikan kepada pengguna, dan ia mulai menggunakannya - mengisi parameter awal dan mentransfernya ke sistem kami. <br><br><img src="https://habrastorage.org/webt/8b/np/wk/8bnpwkt2ufktqh1wa7dtumctozs.png"><br><br>  Ada masalah - sistem ini tidak memiliki solusi tunggal.  Masalahnya tidak luar biasa, benar-benar semua sistem tata letak berjalan ke dalamnya, dan disebut <strong>kurangnya solusi</strong> . <br><br>  Tidak banyak jalan keluar dari situasi ini: <br><br><ul><li>  Anda bisa <strong>jatuh</strong> - ini adalah metode yang sangat umum.  Mereka yang bekerja dengan MacOS tahu bahwa NSLayoutConstraintManager melakukan hal itu. </li><li>  <strong>Kembalikan nilai default</strong> .  Dalam konteks tata letak, kami selalu dapat mengembalikan semua nol. </li><li>  Cara yang lebih terkenal dan rumit adalah <strong>untuk mencegah input yang salah</strong> .  Metode ini digunakan oleh sistem tata letak yang populer, misalnya, <strong>Yoga</strong> , yang dikenal sebagai <strong>Layout Flex</strong> .  Sistem semacam itu mencoba membuat antarmuka yang tidak memungkinkan input yang salah. </li><li>  Ada cara lain untuk menyelesaikan semua masalah - untuk <strong>memikirkan kembali semuanya dari awal</strong> dan awalnya <strong>untuk mencegah terjadinya masalah ini</strong> .  Tata Letak Otomatis berjalan seperti itu. </li></ul><br><h2>  Tata Letak Otomatis  Pernyataan dan solusi masalah <br></h2><br>  Kami memiliki gambar persegi panjang dan untuk mengidentifikasinya secara unik, kami membutuhkan 4 parameter: <br><br><ul><li>  koordinat sudut kiri atas; </li><li>  lebar dan tinggi. </li></ul><br><img src="https://habrastorage.org/webt/9k/m4/mn/9km4mnazc-bszyeglny7jgury1k.png"><br><br>  Tata Letak Otomatis sangat bertele-tele.  Dibandingkan dengan sistem persamaan linear, jauh lebih sulit untuk menempatkan segala sesuatu di layar dengannya.  Karena itu, kami akan mempertimbangkan, tanpa kehilangan keumuman, kasus satu dimensi. <br><br><img src="https://habrastorage.org/webt/yy/g-/bz/yyg-bzfkdyhagrqn28bj7ruydg8.png"><br><br>  Semuanya sangat sederhana: ruang adalah garis lurus, dan semua benda yang dapat ditempatkan di dalamnya adalah titik pada garis lurus.  Satu nilai: <strong>X = X <sub>P sudah</sub></strong> cukup untuk menentukan posisi titik. <br><br>  Pertimbangkan pendekatan Tata Letak Otomatis.  Ada ruang di mana pembatasan ditetapkan.  Solusi yang ingin kita dapatkan adalah <strong>X = X <sub>0</sub></strong> , dan tidak ada yang lain. <br><br>  Ada masalah - kami belum mendefinisikan operasi dengan pembatasan.  Kami tidak dapat secara langsung menyimpulkan dari catatan bahwa <strong>X = X <sub>0</sub></strong> , kami tidak dapat melipatgandakan apa pun atau menambahkan sesuatu ke apa pun.  Untuk melakukan ini, kita perlu mengubah batasan menjadi apa yang bisa kita kerjakan - menjadi sistem persamaan dan ketidaksetaraan. <br><br><img src="https://habrastorage.org/webt/dc/ru/gr/dcrugrl3rwq6esfcnrlz89ora8o.png"><br><br>  Tata Letak Otomatis mengubah sistem persamaan dan ketidaksetaraan sebagai berikut. <br><br><ul><li>  Pertama memperkenalkan 2 variabel tambahan yang <strong>tidak negatif</strong> dan saling <strong>bergantung</strong> .  Setidaknya satu dari mereka sama dengan nol. </li><li>  Batasan itu sendiri dikonversi ke notasi <strong>X = X <sub>0</sub> + a <sup>+</sup> - a <sup>-</sup></strong> . </li></ul><br>  Poin <strong>X <sub>0</sub></strong> <sub>&nbsp;</sub>  - solusi sistem: jika <strong><sup>+</sup></strong> dan <strong>a <sup>-</sup></strong> sama dengan nol, maka ini akan menjadi benar.  Tetapi <strong>poin lain</strong> pada baris ini akan menjadi solusi. <br><br>  Oleh karena itu, perlu untuk menemukan yang terbaik di antara banyak solusi.  Untuk melakukan ini, kami memperkenalkan fungsional - fungsi biasa yang mengembalikan angka, dan kami dapat membandingkan angka.  Kami menggambar grafik dan mencatat bahwa solusi yang awalnya ingin kami dapatkan adalah minimum. <br><br>  Punya <strong>masalah pemrograman linier</strong> .  Inilah yang dilakukan Auto Layout dengan kendala, yang tidak hanya dalam bentuk persamaan, tetapi juga ketidaksetaraan. <br><br><h3>  Kendala ketimpangan <br></h3><br>  Dalam kasus pembatasan ketimpangan, transformasi terjadi dengan cara yang sama dengan persamaan: dua variabel tambahan diperkenalkan dan semua ini dikumpulkan dalam sistem.  Hanya fungsional yang berbeda, dan sama dengan <strong><sup>-</sup></strong> . <br><br><img src="https://habrastorage.org/webt/su/lp/db/sulpdbiqpzdvnd2s23qwo3zg3p0.png"><br><br>  Grafik di atas menunjukkan mengapa demikian - nilai <strong><sup>+</sup></strong> dengan <strong>a <sup>-</sup> = 0</strong> (dari <strong>X <sub>0</sub></strong> hingga <strong>+ âˆ</strong> ) akan menjadi solusi optimal untuk masalah tersebut. <br><br>  Mari kita coba menggabungkan dua batasan persamaan dan ketidaksetaraan ini menjadi satu - karena pembatasan tidak hidup dalam isolasi, mereka diterapkan bersama ke seluruh sistem. <br><br><img src="https://habrastorage.org/webt/kv/p4/ed/kvp4ed32qay13--nhn6neefffd0.png"><br><br>  Untuk setiap kendala, sepasang variabel tambahan diperkenalkan, dan fungsional dikompilasi.  Karena kami ingin semua batasan ini dipenuhi secara bersamaan, <strong>fungsional akan sama dengan jumlah semua fungsional dari setiap batasan</strong> . <br><br>  Kami mengumpulkan fungsi f dan melihat solusinya adalah <strong>X <sub>1</sub></strong> .  Seperti yang kami harapkan, membuat batasan.  Jadi kita sampai pada algoritma ketiga. <br><br><h3>  Algoritma No. 3 <br></h3><br>  Untuk melakukan sesuatu, Anda perlu: <br><br><ul><li>  membuat sistem kendala linier; </li><li>  mengubahnya menjadi masalah pemrograman linier; </li><li>  memecahkan masalah dengan cara apa pun yang diketahui, misalnya, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">metode simpleks</a> yang digunakan dalam Tata Letak Otomatis; </li><li>  terapkan solusi untuk UIView. </li></ul><br>  Algoritma ini tampaknya cukup, tetapi pertimbangkan kasus berikut: kami mengubah set awal kendala sehingga kendala kedua sekarang <strong>X â‰¥ X</strong> <strong><sub>2</sub></strong> . <br><br><img src="https://habrastorage.org/webt/li/dd/at/liddathmoov5umsnhvnoevax6jy.png"><br><br>  Solusi apa yang kita harapkan untuk dilihat? <br><br><ul><li>  <strong>X <sub>1</sub></strong> ?  Memang, dalam batasan pertama ditulis demikian: <strong>X = X <sub>1</sub></strong> , dan solusi ini bertentangan dengan pembatasan kedua. </li><li>  <strong>X <sub>2</sub></strong> ?  Akan ada konflik dengan pembatasan pertama. </li></ul><br>  Untuk keluar dari situasi tersebut, kami akan melakukan transformasi yang sudah kami ketahui caranya. <br><br>  Grafik fungsi baru terlihat berbeda: titik apa pun dari interval dari <strong>X <sub>1</sub></strong> hingga <strong>X <sub>2</sub></strong> akan menjadi solusi yang benar dari sistem.  Ini disebut <strong>ketidakpastian</strong> . <br><br><h3>  Ketidakpastian <br></h3><br>  Tata Letak Otomatis memiliki mekanisme untuk memecahkan masalah seperti itu - <strong>prioritas</strong> .  Saya mengingatkan Anda bahwa kuning akan menunjukkan prioritas tinggi, dan biru - rendah. <br><br><img src="https://habrastorage.org/webt/7e/go/is/7egoisncevkoitvo8fdxkvcdg7g.png"><br><br>  Konversi pembatasan.  Harap dicatat bahwa sistem yang dihasilkan hanya hitam.  Kami tahu cara bekerja dengannya, dan tidak ada informasi tentang batasan di dalamnya.  Ada dalam fungsi, yang akan ada dua.  Tata Letak Otomatis pertama-tama akan meminimalkan yang pertama dan kemudian yang kedua. <br><br>  Dalam masalah pemrograman linier, kami mencari bukan untuk solusi itu sendiri, tetapi untuk berbagai solusi yang layak.  Tentu saja, kami ingin area ini hanya satu titik, dan Tata Letak Otomatis bertindak dengan cara yang sama.  Pertama, meminimalkan fungsional prioritas tertinggi pada ( <strong>-</strong> <strong>âˆ,</strong> <strong>+ âˆ)</strong> dan, pada output, menerima domain solusi yang layak.  Tata Letak Otomatis memecahkan masalah pemrograman linier kedua yang sudah ada pada kisaran nilai yang diizinkan yang diperoleh.  Mekanisme seperti ini disebut <strong>hierarki kendala</strong> , dan dalam masalah ini memberikan poin <strong>X2</strong> . <br><br><h3>  Algoritma No. 4 <br></h3><br><ul><li>  Buat hierarki kendala linier; </li><li>  mengubahnya menjadi tugas pemrograman linier; </li><li>  memecahkan secara berurutan masalah pemrograman linier - dari prioritas tertinggi ke prioritas terendah. </li><li>  terapkan solusi untuk UlView. </li></ul><br>  Mari kita lihat kembali tugas sebelumnya.  Kami bukan ahli matematika, tetapi insinyur, dan insinyur mana pun harus bingung di sini. <br><br>  Ada masalah serius di sini - <strong>tak terbatas</strong> , dan saya tidak tahu apa itu. <br><br>  Algoritma Cassowary di bawah kap Auto Layout bukanlah mekanisme yang ada yang dengan mudah jatuh pada tugas Tata Letak Otomatis, tetapi dianggap sebagai alat tata letak, dan itu menyediakan mekanisme khusus untuk melarikan diri dari infinity di awal.  Untuk ini, beberapa jenis pembatasan ditemukan: <br><br><ul><li>  <strong>Parameter</strong> adalah kendala yang telah kami kerjakan.  Mereka disebut <strong>preferensi</strong> dalam aslinya <strong>,</strong> kadang-kadang dalam dokumentasi Apple - <strong>batasan opsional</strong> . </li><li>  <strong>Persyaratan</strong> atau persyaratan - pembatasan dengan prioritas yang <strong>diperlukan</strong> . </li></ul><br>  Mari kita lihat bagaimana persyaratan dengan prioritas tersebut ditransformasikan dari sudut pandang matematika. <br><br><img src="https://habrastorage.org/webt/hm/mn/my/hmmnmycwgdfq9vuip1xeylz4caq.png"><br><br>  Kami lagi memiliki garis lurus dengan dua poin, dan batasan pertama adalah <strong>X = X <sub>1</sub></strong> .  Pada slide, warnanya merah, yaitu pembatasan ini dengan prioritas yang diperlukan - kami akan menyebutnya persyaratan. <br><br>  Tata Letak Otomatis mengubahnya menjadi sistem persamaan linear yang berisi satu persamaan <strong>X = X <sub>1</sub></strong> .  Tidak lebih - tidak ada tugas pemrograman linier, tidak ada optimasi. <br><br>  Situasinya mirip dengan ketidaksetaraan, tetapi sedikit lebih rumit - <strong>variabel tambahan</strong> akan muncul yang dapat mengambil nilai lebih dari 0. Untuk nilai apa pun yang lebih besar dari 0, batasan ini akan dipenuhi.  Harap perhatikan bahwa di sini tidak ada tugas dan optimisasi pemrograman linier. <br><br>  Mari kita coba menggabungkan semua ini bersama-sama, mengumpulkan dua persyaratan dan mengubahnya menjadi satu sistem.  Seorang pembaca yang penuh perhatian, mencatat bahwa kami datang ke masalah yang sama dengan yang kami mulai - <strong>persyaratan harus konsisten</strong> . <br><br><img src="https://habrastorage.org/webt/lj/fu/wx/ljfuwxbedffz_agc5ydwoxiv0os.png"><br><br>  Kendala dari jenis yang <strong>dibutuhkan</strong> atau persyaratan adalah alat yang <strong>sangat kuat,</strong> tetapi bukan yang utama, tetapi alat bantu.  Ini khusus diperkenalkan di Tata Letak Otomatis untuk memecahkan masalah interval tak terbatas, harus digunakan dengan hati-hati. <br><br>  Mari kita coba menggabungkan semua jenis batasan yang kita temui dalam satu sistem.  Misalkan kita ingin menyelesaikan masalah bukan pada seluruh baris, tetapi hanya antara <strong>X <sub>0</sub></strong> dan <strong>X <sub>3</sub> .</strong>  Mengubah semua ini menjadi sistem persamaan linear dan ketidaksetaraan, kami mendapatkan yang berikut ini. <br><br><img src="https://habrastorage.org/webt/nl/3k/lw/nl3klwil0nepuuqyjq-nmxxo0rs.png"><br><br>  Relatif terhadap sistem sebelumnya, dua variabel tambahan ditambahkan - <strong>c</strong> dan <strong>d</strong> , tetapi mereka tidak akan masuk ke fungsional, karena pembatasan dari jenis yang diperlukan tidak mempengaruhi fungsional dalam bentuk aslinya. <br><br>  Tampaknya tugasnya tidak banyak berubah - kami meminimalkan yang sama seperti sebelumnya, tetapi rentang awal nilai yang dapat diterima berubah, sekarang dari <strong>X <sub>0</sub></strong> ke <strong>X <sub>3</sub></strong> . <br><br><blockquote>  Dari sudut pandang matematis, persyaratan - batasan dari tipe yang diperlukan - adalah kemampuan untuk memperkenalkan persamaan tambahan ke dalam sistem tanpa memodifikasi fungsinya. <br></blockquote><br>  Anda harus sangat berhati-hati dengan ini, karena penyalahgunaan berlebihan dari batasan yang diperlukan akan menyebabkan <strong>masalah tanpa solusi</strong> , dan Tata Letak Otomatis tidak akan mengatasinya. <br><br>  Kami tiba di algoritma kelima terakhir. <br><br><h3>  Algoritma No. 5 <br></h3><br><ul><li>  Tetapkan batasan yang diperlukan - persyaratan tata letak; </li><li>  membuat hierarki kendala linier; </li><li>  mengubah semua kendala menjadi masalah pemrograman linier; </li><li>  memecahkan masalah pemrograman linier; </li><li>  terapkan solusi untuk UlView. </li></ul><br>  Kami memeriksa Cassowary - sebuah algoritma yang ada di dalam Auto Layout, tetapi ketika itu diterapkan, berbagai fitur muncul. <br><br><h3>  Fitur IOS <br></h3><br>  <strong>Tidak ada perhitungan di layoutSubviews ()</strong> . <br><br>  Kapan mereka diproduksi?  Jawab: selalu, kapan saja Auto Layout dihitung.  Penghitungan terjadi tepat ketika kita menambahkan kendala ke tampilan kita, atau mengaktifkannya menggunakan metode API modern untuk bekerja dengan kendala. <br><br><img src="https://habrastorage.org/webt/rf/rf/ca/rfrfca8zmtb5ukabvarjdfygbii.png"><br><br>  Pandangan kami berbentuk persegi panjang, tetapi masalahnya adalah bahwa informasi ini tidak terkandung di dalam Kasuari, perlu juga ditambahkan di sana.  Kami memiliki mekanisme untuk memperkenalkan batasan tambahan.  Jika kami memperkenalkan untuk setiap tampilan serangkaian kendala dengan lebar dan tinggi positif, maka kami akan selalu mendapatkan persegi panjang di output.  Itulah sebabnya kami tidak dapat mengimbangi tampilan Tata Letak Otomatis dengan dimensi negatif. <br><br>  Fitur kedua adalah <strong>intrinsicContentSize</strong> - ukuran intrinsik yang dapat diatur untuk setiap tampilan. <br><br><img src="https://habrastorage.org/webt/of/dx/dr/ofdxdrma4ob54homy7amohpvove.png"><br><br>  Ini adalah antarmuka sederhana untuk membuat 4 kendala ketimpangan tambahan yang akan ditempatkan dalam sistem.  Mekanisme ini sangat nyaman, memungkinkan Anda untuk mengurangi jumlah pembatasan eksplisit, yang menyederhanakan penggunaan Tata Letak Otomatis.  Poin terakhir dan tertipis yang sering dilupakan adalah <strong>TranslateAutoresizingMaskIntoConstraints.</strong> <br><br><img src="https://habrastorage.org/webt/xz/pz/su/xzpzsulxwqohzm-ehd5rz2kg148.png"><br><br>  Ini adalah <strong>penopang yang</strong> diperkenalkan kembali pada zaman iOS 5, sehingga kode lama tidak rusak setelah munculnya Tata Letak Otomatis. <br><br>  Bayangkan sebuah situasi: kami memaksakan pandangan pada kendala.  Di dalam tampilan, kami menggunakan tampilan, yang tidak tahu apa-apa tentang kendala, semua mengeset pada bingkai, tapi di dalamnya mengetikan tampilan, yang telah lama diterjemahkan ke dalam kendala. <br><br><blockquote>  Saya mengingatkan Anda bahwa tidak ada bingkai yang masuk ke dalam tugas Tata Letak Otomatis Kasuari, hanya batasan. <br></blockquote><br>  Ukuran dan posisi tampilan yang runtuh pada bingkai tidak sepenuhnya ditentukan melalui kendala.  Saat menghitung ukuran dan posisi semua tampilan lain, ukuran yang salah akan diperhitungkan, meskipun setelah Tata Letak Otomatis kami akan menerapkan bingkai yang benar di sana. <br><br>  Untuk menghindari situasi ini, jika nilai variabel TranslateAutoresizingMaskIntoConstraints benar, maka batasan tambahan diterapkan untuk setiap tampilan yang diletakkan pada bingkai.  Rangkaian pembatasan ini dapat bervariasi dari satu jalankan ke menjalankan.  Hanya satu hal yang diketahui tentang set ini - bingkainya akan menjadi yang ditransmisikan. <br><br>  Kompatibilitas antara kode lama yang ditulis tanpa kendala dan kode baru yang ditulis dengan kendala sering kali dapat menderita karena penyalahgunaan properti ini.  Pembatasan ini tentu memiliki prioritas persyaratan, jadi jika kita tiba-tiba memaksakan batasan pada pandangan seperti itu, yang memiliki prioritas sangat tinggi, misalnya persyaratan, kita dapat secara tidak sengaja membuat sistem yang tidak konsisten yang tidak akan memiliki solusi. <br><br>  <strong>Penting untuk diketahui:</strong> <br><br><ul><li>  Jika kami membuat tampilan dari <strong>Interface Builder</strong> , maka nilai default untuk properti ini akan <strong>salah</strong> . </li><li>  Jika kita membuat tampilan langsung dari kode, maka itu akan <strong>benar</strong> . </li></ul><br>  Idenya sangat sederhana - kode lama di mana tampilan dibuat tidak tahu apa-apa tentang Tata Letak Otomatis, dan itu perlu untuk membuatnya sehingga jika tampilan digunakan di suatu tempat di tempat baru, maka itu akan berfungsi. <br><br><h2>  Kiat praktis <br></h2><br>  Akan ada tiga dewan di semua dan mulai dengan yang paling penting. <br><br><h3>  Optimasi <br></h3><br><blockquote>  Penting untuk melokalisasi masalah. <br></blockquote><br>  Apakah Anda pernah menghadapi masalah mengoptimalkan layar, yang ditata di Tata Letak Otomatis?  Kemungkinan besar tidak, lebih sering Anda menghadapi masalah mengoptimalkan tata letak sel di dalam tabel atau <strong>Tampilan Koleksi</strong> . <br><br>  Tata Letak Otomatis dioptimalkan cukup untuk membuat layar dan antarmuka apa pun, tetapi membuat 50 atau 100 sekaligus adalah masalah baginya.  Untuk melokalkan dan mengoptimalkannya, mari kita lihat eksperimen.  Angka-angka tersebut diambil dari sebuah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">artikel di</a> mana Kasuari pertama kali dijelaskan. <br><img src="https://habrastorage.org/webt/jl/cb/qo/jlcbqo-0y685wxkbkniflmjlwli.png"><br><br>  Tugasnya adalah ini: kami membuat rantai tampilan satu per satu, dan kami menghubungkan setiap rantai berikutnya dengan rantai sebelumnya.  Dengan demikian, urutan 1000 elemen dibangun.  Setelah mengukur berbagai operasi, waktu ditunjukkan dalam milidetik.  Nilai-nilainya cukup besar, karena Tata Letak Otomatis ditemukan di persimpangan tahun 80-an dan 90-an. <br><br>  Dengan mengumpulkan rantai seperti itu, Anda dapat bertindak sebagai berikut: <br><br><ul><li>  <strong>Tambahkan kendala satu per satu</strong> dan putuskan setiap waktu.  Ini akan memakan waktu 38 detik. </li><li>  Anda dapat <strong>menambahkan semua batasan sekaligus</strong> , dan hanya kemudian menyelesaikan sistem.  Solusi ini lebih efisien.  Menurut data lama, efisiensi meningkat sebesar 70%, tetapi dalam implementasi saat ini pada perangkat modern hanya akan ada 20%.  Tetapi penambahan pembatasan satu kali secara kualitatif akan selalu lebih efektif. </li><li>  Ketika seluruh rantai terpasang, Anda dapat <strong>menambahkan satu batasan lagi</strong> .  Seperti dapat dilihat dari tabel, operasi ini cukup murah. </li><li>  Hal yang paling menarik: <strong>jika kita tidak menambahkan batasan baru, tetapi mengubah beberapa konstanta di salah satu yang ada</strong> , ini adalah urutan besarnya lebih efektif daripada menghapus atau membuat batasan baru. </li></ul><br>  Dua poin pertama dapat digambarkan sebagai perhitungan utama antarmuka, dua yang terakhir - sebagai yang berikutnya. <br><br><h4>  Perhitungan antarmuka primer <br></h4><br>  Di sini Anda dapat menggunakan metode penambahan batasan massal untuk optimisasi: <br><br><ul><li>  <strong>NSLayoutConstraints.activate (_ :)</strong> - saat membuat tampilan, kumpulkan semua kendala secara berurutan ke dalam array, cache dan baru kemudian menambahkannya sekaligus. </li><li>  Atau buat sel di <strong>Interface Builder.</strong>  Dia akan melakukan segalanya untuk kita, dan melakukan optimasi tambahan, yang sering kali nyaman. </li></ul><br><h4>  Perhitungan antarmuka selanjutnya <br></h4><br>  Menambah atau memodifikasi kendala adalah operasi yang kompleks, jadi lebih baik <strong>untuk tidak mengubah set kendala, tetapi hanya mengubah konstanta</strong> pada kendala yang ada.     : <br><br><ul><li> <strong> UIView</strong> â€”     .   view   ,     Auto Layout.     ,    ,      view,     . </li><li> <strong>   </strong> <strong>â€” IntrinsicContentSize.</strong>  ,      ,     . </li><li> <strong>   </strong> .         , ,   . </li></ul><br>     ,    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">WWDC 2018S220 High Performance Auto Layout</a> .   â€” Apple         ,     . <br><br><h2>   <br></h2><br>      ,       constraints. <br><br><h3>    <br></h3><br>   required ,  â€”   ,       ,     .    . <br><br><blockquote>      ,    . <br></blockquote><br>     : <br><br><ul><li> <strong>  ,   </strong> .      (  loader) â€”     . </li><li> <strong>  ,   </strong> .     ,     . </li></ul><br><br><h3>   <br></h3><br>   ,          ,   . <br><br>   <strong>constraint   required,     </strong> .    , ,    ,       .    ,      . <br><br>   â€” <strong>  ,    </strong> .     ,        â€”     .   -    ,        ,      . Auto Layout      ,      . <br><br> <strong>     </strong> ,       .      .  ,       ,    ,   .        layout,  ,    ,      .        . <br><br><h3>   <br></h3><br> <strong> â€”   </strong> ,    Auto Layout,          ,     . <br><br>  ,  required,  ,    <strong>   </strong> .   : <br><br><ul><li>   ,     . </li><li>  ,   ,     . </li></ul><br>  ,       ,  <strong> ,     </strong> . <br><br>            ,      . ,     ,          ,    .  , <strong> â€”   </strong> .      . <br><br> <strong>   â€”    .</strong>      ,       ,     ,   â€”     ,     â€”   required      -. <br><br> <b> :</b> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Solving Linear Arithmetic Constraints for User Interface Applications</a> <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">The Cassowary Linear Constraint Solving Algorithm</a> <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Constraints as s Design Pattern</a> <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Auto Layout Guide by Apple</a> <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">WWDC 2018 Session 220 High Performance Auto Layout</a> <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="> UILabel   API Auto Layout â€”  </a> <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="> .  Medium</a> <br><br><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Omong-omong, kami telah menerima </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">laporan</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Anton di program </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AppsConf 2019</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Biarkan saya mengingatkan Anda bahwa kami telah memindahkan AppsConf dari musim gugur ke musim semi, dan konferensi paling berguna berikutnya untuk pengembang seluler akan diadakan pada 22 dan 23 April. </font><font style="vertical-align: inherit;">Sudah waktunya untuk memikirkan topik untuk presentasi dan </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">menyerahkan laporan</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , atau berdiskusi dengan pemimpin tentang pentingnya pergi ke konferensi dan memesan tiket.</font></font><br></blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id437584/">https://habr.com/ru/post/id437584/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id437574/index.html">Backend WhatsApp, Facebook Messenger, Instagram akan menyatukan dan menambahkan enkripsi ujung ke ujung</a></li>
<li><a href="../id437576/index.html">Konferensi DEFCON 17. Kegagalan saya. Bagian 1</a></li>
<li><a href="../id437578/index.html">Konferensi DEFCON 17. Kegagalan saya. Bagian 2</a></li>
<li><a href="../id437580/index.html">Bagaimana cara mengingat buku teks JavaScript dalam 5 hari, atau "Istana Memori" dalam kehidupan sehari-hari seorang programmer</a></li>
<li><a href="../id437582/index.html">Tinjauan umum tentang Vue.js 2.6</a></li>
<li><a href="../id437586/index.html">Kami membuat aplikasi suara menggunakan contoh Google Assistant</a></li>
<li><a href="../id437588/index.html">Apakah lebih menyenangkan untuk dikembangkan untuk ponsel daripada untuk web?</a></li>
<li><a href="../id437590/index.html">Nomor latensi pada iPhone</a></li>
<li><a href="../id437592/index.html">Arsitektur Lapisan Eksekusi Tugas Asinkron</a></li>
<li><a href="../id437594/index.html">Bagaimana saya menghilangkan penyebab kegagapan dan melewatkan bingkai di semua game, dan juga secara tidak sengaja menurunkan suhu hingga 15 derajat</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>