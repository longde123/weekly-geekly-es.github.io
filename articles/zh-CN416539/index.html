<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🧟 🌠 👩🏾‍🔧 DOM对象的15个鲜为人知的属性和方法 😧 👍🏾 🖱️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="在开发现代网站时，大量使用用于DOM的JavaScript功能。 脚本允许您显示和隐藏从中构建页面的元素，配置这些元素的属性。 从程序进行交互的DOM对象具有属性和方法。 根据该材料的作者所说，几乎所有的Web程序员都知道其中一些内容，我们今天出版的是其翻译版本。 但是他想在这里谈论的一些远不那么著...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>DOM对象的15个鲜为人知的属性和方法</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/416539/"> 在开发现代网站时，大量使用用于DOM的JavaScript功能。 脚本允许您显示和隐藏从中构建页面的元素，配置这些元素的属性。 从程序进行交互的DOM对象具有属性和方法。 根据该材料的作者所说，几乎所有的Web程序员都知道其中一些内容，我们今天出版的是其翻译版本。 但是他想在这里谈论的一些远不那么著名。 <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><img src="https://habrastorage.org/webt/lw/k4/ct/lwk4ctoknigawiym3hgeyacp5nu.jpeg"></a> <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">HTML和DOM</font> </h2><br> 首先，让我们谈谈HTML和DOM之间的区别。 例如，常规的<code>&lt;table&lt;</code>元素显然是HTML代码。 该元素可以在html文件中使用；它具有一组属性，这些属性确定在其帮助下创建的表的外观和行为。 严格来说， <code>&lt;table&gt;</code>标记本身与JavaScript无关。 文档中存在的HTML元素与JavaScript代码之间的关系由DOM（文档对象模型）提供。  DOM使与JavaScript代码中的HTML元素进行交互成为可能，就好像它们是对象一样。 <br><br> 所有HTML元素都有自己的“ DOM接口”，用于定义属性（它们通常与HTML元素的属性相关联）和方法。 例如， <code>&lt;table&gt;</code>元素具有一个称为<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">HTMLTableElement</a>的接口。 <br><br> 例如，可以使用以下构造获取到元素的链接： <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> searchBox = <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.getElementById(<span class="hljs-string"><span class="hljs-string">'search-box'</span></span>);</code> </pre> <br> 接收到元素的链接后，程序员可以访问此类元素具有的属性和方法。 例如，您可以使用某个文本字段的<code>value</code>属性，假设使用该文本字段的链接使用<code>searchBox.value</code>形式的结构存储在<code>searchBox</code>变量中。 您可以通过调用光标的<code>searchBox.focus()</code>方法将其放置在此文本字段中。 <br><br> 也许这是我们可以完成“关于DOM的简短课程”的地方，实际上，可以进入鲜为人知的HTML元素DOM接口的属性和方法。 <br><br> 如果您想立即阅读和试验，请打开浏览器开发人员工具。 特别是，为了获得指向某个页面元素的链接，可以在元素树中选择它，然后在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">控制台中</a>使用<code>$0</code>构造。 要将项目作为对象查看，请在控制台中键入<code>dir($0)</code> 。 顺便说一句，如果您偶然发现了一些新东西，请尝试使用控制台进行探索。 <br><br><h2>  <font color="#3AC1EF">第1种：表格方法</font> </h2><br> 适度的<code>&lt;table&gt;</code>元素（在网页布局开发中所使用的技术中仍居首位）具有相当多的非常好的方法，这些方法极大地简化了构建表的过程。 <br><br> 这里有一些。 <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> tableEl = <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.querySelector(<span class="hljs-string"><span class="hljs-string">'table'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> headerRow = tableEl.createTHead().insertRow(); headerRow.insertCell().textContent = <span class="hljs-string"><span class="hljs-string">'Make'</span></span>; headerRow.insertCell().textContent = <span class="hljs-string"><span class="hljs-string">'Model'</span></span>; headerRow.insertCell().textContent = <span class="hljs-string"><span class="hljs-string">'Color'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> newRow = tableEl.insertRow(); newRow.insertCell().textContent = <span class="hljs-string"><span class="hljs-string">'Yes'</span></span>; newRow.insertCell().textContent = <span class="hljs-string"><span class="hljs-string">'No'</span></span>; newRow.insertCell().textContent = <span class="hljs-string"><span class="hljs-string">'Thank you'</span></span>;</code> </pre> <br> 如您所见，这里我们不使用诸如<code>document.createElement()</code>类的命令。 如果直接在表上调用<code>.insertRow()</code>方法，它甚至还会提供<code>&lt;tbody&gt;</code>的附加内容。 这不是很好吗？ <br><br><h2>  <font color="#3AC1EF">＃2：scrollIntoView（）方法</font> </h2><br> 您可能知道，如果链接具有<code>#something</code>类的<code>#something</code> ，那么在加载页面后，浏览器将自动滚动到具有相应<code>ID</code>的元素？ 该方法很方便，但是如果在页面加载后呈现了我们感兴趣的元素，它将无法正常工作。 这是您自己重新创建此行为模式的方法： <br><br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">document</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.querySelector</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">document</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.location</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.hash</span></span>)<span class="hljs-selector-class"><span class="hljs-selector-class">.scrollIntoView</span></span>();</code> </pre> <br><h2>  <font color="#3AC1EF">第三名：隐藏财产</font> </h2><br> 在这里，我们考虑一个属性，但是最有可能在访问该属性时，将调用某个设置程序，这是一种方法。 无论如何，请记住，您是否曾经使用以下所示的设计来隐藏元素？ <br><br><pre> <code class="hljs swift">myElement.style.display = '<span class="hljs-keyword"><span class="hljs-keyword">none</span></span>'</code> </pre> <br> 如果您使用它，就不要再这样做了。 要隐藏元素，只需将<code>true</code>写入其<code>hidden</code>属性： <br><br><pre> <code class="hljs objectivec">myElement.hidden = <span class="hljs-literal"><span class="hljs-literal">true</span></span></code> </pre> <br><h2>  <font color="#3AC1EF">＃4：toggle（）方法</font> </h2><br> 实际上，这不是某种方法。 这是元素属性方法。 特别是，此方法允许您使用以下构造将类添加到元素并将其从元素中删除： <br><br><pre> <code class="hljs scala">myElement.classList.toggle(<span class="hljs-symbol"><span class="hljs-symbol">'some</span></span>-<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class">')</span></span></code> </pre> <br> 顺便说一句，如果您曾经使用<code>if</code>构造添加过类，请注意，您不必再执行此操作，而无需考虑此构造。 使用<code>toggle()</code>方法的第二个参数可以实现相同的机制。 如果这是一个表达式，其结果为<code>true</code> ，则传递给<code>toggle()</code>的类将添加到该元素。 <br><br><pre> <code class="hljs scala">el.classList.toggle(<span class="hljs-symbol"><span class="hljs-symbol">'some</span></span>-orange-<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class">', </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">theme</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">===</span></span></span><span class="hljs-class"> '</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">orange</span></span></span><span class="hljs-class">')</span></span>;</code> </pre> <br> 可能在这里，您可能对该设计的适当性有疑问。 毕竟，该方法的名称“ toggle”（考虑到该方法所执行的动作的本质已隐藏在其中）可以翻译为“ switch”，但没有提及“ switching”表示满足特定条件。 但是，尽管Internet Explorer的开发人员可能也认为它很奇怪，但上述设计仍以这种形式存在。 在实现<code>toggle()</code>未提供第二个参数。 因此，尽管上面已经说过，知道<code>toggle()</code>可以忘记<code>if</code>构造，但是不要忘记它。 <br><br><h2>  <font color="#3AC1EF">＃5：querySelector（）方法</font> </h2><br> 您肯定已经知道此方法的存在，但是有一种怀疑是，您中有17％的人不知道该方法可用于任何元素。 <br><br> 例如，构造<code>myElement.querySelector('.my-class')</code>仅选择具有<code>my-class</code>并且同时是<code>myElement</code>元素的后代的<code>myElement</code>元素。 <br><br><h2>  <font color="#3AC1EF">＃6：最接近（）方法</font> </h2><br> 所有支持父元素搜索的元素都具有此方法。 这类似于<code>querySelector()</code>的反向操作。 例如，使用此方法，您可以获得当前部分的标题： <br><br><pre> <code class="hljs cs">myElement.closest(<span class="hljs-string"><span class="hljs-string">'article'</span></span>).querySelector(<span class="hljs-string"><span class="hljs-string">'h1'</span></span>);</code> </pre> <br> 在此，在搜索过程中，首先检测到第一个父元素<code>&lt;article&gt;</code> ，然后检测到第一个父元素<code>&lt;h1&gt;</code> 。 <br><br><h2>  <font color="#3AC1EF">＃7：getBoundingClientRect（）方法</font> </h2><br>  <code>getBoundingClientRect()</code>方法返回一个装饰精美的小对象，其中包含有关调用此方法的元素的大小的信息。 <br><br><pre> <code class="hljs css">{ <span class="hljs-attribute"><span class="hljs-attribute">x</span></span>: <span class="hljs-number"><span class="hljs-number">604.875</span></span>, y: <span class="hljs-number"><span class="hljs-number">1312</span></span>, width: <span class="hljs-number"><span class="hljs-number">701.625</span></span>, height: <span class="hljs-number"><span class="hljs-number">31</span></span>, top: <span class="hljs-number"><span class="hljs-number">1312</span></span>, right: <span class="hljs-number"><span class="hljs-number">1306.5</span></span>, bottom: <span class="hljs-number"><span class="hljs-number">1343</span></span>, left: <span class="hljs-number"><span class="hljs-number">604.875</span></span> }</code> </pre> <br> 但是，使用此方法时必须特别注意两点： <br><br><ul><li> 调用此方法将导致页面重绘。 根据查看页面的设备以及页面的复杂程度，此操作可能需要几毫秒的时间。 如果您打算在某些重复的代码段中调用此方法，请考虑这一点，例如在执行动画时。 </li><li> 并非所有浏览器都支持此方法。 </li></ul><br><h2>  <font color="#3AC1EF">＃8：matches（）方法</font> </h2><br> 假设我们需要检查某个元素是否具有某个类。 <br><br> 显然，这是最困难的解决方法： <br><br><pre> <code class="hljs scala"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (myElement.className.indexOf(<span class="hljs-symbol"><span class="hljs-symbol">'some</span></span>-<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class">') </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">&gt;</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">-1</span></span></span><span class="hljs-class">) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//  -  }</span></span></code> </pre> <br> 这是另一种选择，它更好，但也远非理想： <br><br><pre> <code class="hljs scala"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (myElement.className.includes(<span class="hljs-symbol"><span class="hljs-symbol">'some</span></span>-<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class">')) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//  -  }</span></span></code> </pre> <br> 这是解决此问题的最佳方法： <br><br><pre> <code class="hljs swift"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (myElement.matches('.some-<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class">')) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//  -  }</span></span></code> </pre> <br><h2>  <font color="#3AC1EF">＃9：insertAdjacentElement（）方法</font> </h2><br> 此方法类似于<code>appendChild()</code> ，但是在将子元素添加到何处的过程中具有更多功能。 <br><br> 因此， <code>parentEl.insertAdjacentElement('beforeend', newEl)</code>命令类似于<code>parentEl.appendChild(newEl)</code> ，但是使用<code>insertAdjacentElement()</code>方法，您可以将<code>beforebegin</code> ， <code>afterbegin</code>和<code>afterend</code> ，指示需要放置的位置添加项目。 <br><br><h2>  <font color="#3AC1EF">第10条：contains（）方法</font> </h2><br> 您是否曾经想知道一个元素是否在另一个元素内部？ 我一直都需要。 例如，如果在处理鼠标单击事件时需要确定它是在模态窗口内还是在模态窗口外（这意味着可以将其关闭），则可以使用以下构造： <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> handleClick = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">e</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!modalEl.contains(e.target)) modalEl.hidden = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; };</code> </pre> <br> 此处， <code>modalEl</code>是到模式窗口的链接，而<code>e.target</code>是单击的任何元素。 有趣的是，当我使用这种技术时，即使我记得自己经常犯错误并尝试提前修复可能的错误，也永远都不会第一次就正确地编写所有内容。 <br><br><h2>  <font color="#3AC1EF">＃11：getAttribute（）方法</font> </h2><br> 也许可以将这种方法称为最无用的方法，但是在某些情况下，它肯定可以派上用场。 <br><br> 还记得我们之前说过的DOM对象的属性通常与HTML元素的属性相关联吗？ <br><br> 情况并非如此的情况之一由<code>href</code>属性表示，例如，例如： <code>&lt;a href="/animals/cat"&gt;Cat&lt;/a&gt;</code> 。 <br><br> 如您所料， <code>el.href</code>构造<code>el.href</code>不返回<code>/animals/cat</code> 。 这是因为<code>&lt;a&gt;</code>元素实现了<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">HTMLHyperlinkElementUtils</a>接口，该接口具有许多帮助程序属性，例如<code>protocol</code>和<code>hash</code> ，可以帮助您弄清链接的详细信息。 <br> 这些帮助程序属性之一是<code>href</code>属性，它提供了完整的URL，其中包括相对URL在属性中不包含的所有内容。 <br><br> 结果，为了准确获取<code>href</code>属性中编写的内容，您需要使用<code>el.getAttribute('href')</code>构造。 <br><br><h2>  <font color="#3AC1EF">第12条：&lt;dialog&gt;元素的三种方法</font> </h2><br> 相对较新的<code>&lt;dialog&gt;</code>元素具有两个有用的但很普通的方法，而一个可以简单地称为美妙的方法。 因此， <code>show()</code>和<code>close()</code>方法完全可以实现您对它们的期望，显示和隐藏窗口。 我们称它们有用，但很普通。 但是<code>showModal()</code>方法将在其他所有内容的顶部显示<code>&lt;dialog&gt;</code>元素，并将其显示在窗口的中央。 事实上，通常希望从模态窗口中获得这种行为。 使用此类元素时，无需考虑<code>z-index</code>属性，手动添加模糊的背景或侦听按下<code>Escape</code>键以关闭相应窗口的事件。 浏览器知道模态窗口应如何工作，并确保一切正常运行。 <br><br><h2>  <font color="#3AC1EF">＃13：forEach（）方法</font> </h2><br> 有时，当您获得到元素列表的链接时，可以使用<code>forEach()</code>方法<code>forEach()</code>这些元素。  <code>for()</code>循环是昨天。 假设我们需要在日志页面中列出所有<code>&lt;a&gt;</code>元素。 如果我们如下所示执行此操作，则会遇到错误消息： <br><br><pre> <code class="hljs javascript"><span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.getElementsByTagName(<span class="hljs-string"><span class="hljs-string">'a'</span></span>).forEach(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">el</span></span></span><span class="hljs-function"> =&gt;</span></span> {   <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(el.href); });</code> </pre> <br> 为了解决此问题，可以使用以下构造： <br><br><pre> <code class="hljs javascript"><span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.querySelectorAll(<span class="hljs-string"><span class="hljs-string">'a'</span></span>).forEach(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">el</span></span></span><span class="hljs-function"> =&gt;</span></span> {   <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(el.href); });</code> </pre> <br> 这里的要点是，诸如<code>getElementsByTagName()</code>之类的方法返回<code>HTMLCollection</code>类型的对象，而<code>querySelectorAll</code>对象。 通过<code>NodeList</code>对象的接口，我们可以访问<code>forEach()</code>方法（以及<code>keys()</code> ， <code>values()</code>和<code>entries()</code>方法）。 <br><br> 实际上，如果这样的方法仅返回普通数组，而没有为我们提供某些看上去有用的方法，而这些方法却不太像数组，那会更好。 但是，不要因此而烦恼，因为ECMA的聪明人为我们提供了一个很棒的方法<code>Array.from()</code> ，它使我们能够将所有看起来像数组的东西变成数组。 <br><br> 结果，您可以编写以下内容： <br><br><pre> <code class="hljs javascript"><span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>.from(<span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.getElementsByTagName(<span class="hljs-string"><span class="hljs-string">'a'</span></span>)).forEach(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">el</span></span></span><span class="hljs-function"> =&gt;</span></span> {   <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(el.href); });</code> </pre> <br> 这是一件好事。 通过将原来的数组转换成数组，我们有机会使用许多数组方法，例如<code>map()</code> ， <code>filter()</code>和<code>reduce()</code> 。 例如，在这里，如何在页面上形成外部链接数组： <br><br><pre> <code class="hljs javascript"><span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>.from(<span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.querySelectorAll(<span class="hljs-string"><span class="hljs-string">'a'</span></span>)) .map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">el</span></span></span><span class="hljs-function"> =&gt;</span></span> el.origin) .filter(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">origin</span></span></span><span class="hljs-function"> =&gt;</span></span> origin !== <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.origin) .filter(<span class="hljs-built_in"><span class="hljs-built_in">Boolean</span></span>);</code> </pre> <br> 顺便说一句，我真的很喜欢<code>.filter(Boolean)</code>构造，因为当我很久以前在代码中遇到它时，我几乎无法立即理解它的含义。 <br><br><h2>  <font color="#3AC1EF">第14号：使用表格</font> </h2><br> 您很可能会知道<code>&lt;form&gt;</code>元素具有一个<code>submit()</code>方法。 但是，您不太可能知道表单具有<code>reset()</code>方法，并且它们具有<code>reportValidity()</code>方法，该方法适用于使用验证表单元素的情况。 <br><br> 此外，在使用表单时，您可以使用它们的<code>elements</code>属性，该属性通过一点允许您使用其<code>name</code>属性访问表单元素。 例如， <code>myFormEl.elements.email</code>构造将返回属于以下形式的<code>&lt;input name="email" /&gt;</code>元素（“属于”不一定表示“成为后代”）。 <br><br> 这里应该注意， <code>elements</code>属性本身不返回普通元素的列表。 它返回控件列表（当然，该列表不是数组）。 <br><br> 这是一个例子。 如果表单上有三个单选按钮，并且它们都具有相同的名称（ <code>animal</code> ），则<code>formEl.elements.animal</code>构造将提供指向一组单选按钮（1个控件，3个HTML元素）的链接。 并且，如果您使用设计<code>formEl.elements.animal.value</code> ，那么它将提供用户选择的单选按钮的值。 <br><br> 如果您考虑一下，那么一切看起来都很奇怪，因此让我们处理前面的示例： <br><br><ul><li>  <code>formEl</code>是一个元素。 </li><li>  <code>elements</code>是一个类似于数组但不是的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">HTMLFormControlsCollection</a>对象。 它的元素不一定是HTML元素。 </li><li>  <code>animal</code>是一组多个单选按钮，由于它们都具有相同的<code>name</code>属性（因此存在一个<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">RadioNodeList</a>接口，该接口专门设计用于单选按钮），因此以一组形式出现。 </li><li>  <code>value</code>用于访问集合中活动单选按钮的<code>value</code>属性。 </li></ul><br><h2>  <font color="#3AC1EF">＃15：select（）方法</font> </h2><br> 也许在材料的最后，最好谈论一些绝对令人惊讶的方法，尽管这种方法可能对某人是一个启示。 因此， <code>.select()</code>方法使您可以在被调用的输入字段中选择文本。 <br><br><h2>  <font color="#3AC1EF">总结</font> </h2><br> 在本文中，我们讨论了可用于处理网页内容的鲜为人知的方法和属性。 我们希望您在这里为自己找到了一些新的东西，也许不仅是新的，而且是有用的。 <br><br>  <b>亲爱的读者们！</b> 您是否使用任何与尚不为人所知的网页内容进行程序交互的方式？ <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN416539/">https://habr.com/ru/post/zh-CN416539/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN416527/index.html">维珍银河已同意使用意大利太空港</a></li>
<li><a href="../zh-CN416531/index.html">可持续发展GAN培训</a></li>
<li><a href="../zh-CN416533/index.html">上周第322页来自前端世界的新鲜材料摘要（2018年7月2日至8日）</a></li>
<li><a href="../zh-CN416535/index.html">7月9日至15日在莫斯科举行的数字活动</a></li>
<li><a href="../zh-CN416537/index.html">Wireshark的工作坊</a></li>
<li><a href="../zh-CN416541/index.html">可再生能源常见问题解答，第2部分</a></li>
<li><a href="../zh-CN416543/index.html">PHP摘要134（2018年6月24日至7月8日）</a></li>
<li><a href="../zh-CN416545/index.html">切身体会：开发，拉取请求，提交，软件技能</a></li>
<li><a href="../zh-CN416547/index.html">Rostec离开Yota Devices，将向新华社订户提供具有两个屏幕的智能手机</a></li>
<li><a href="../zh-CN416549/index.html">救援微型潜艇正在测试中</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>