<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🍀 👡 🤾 Mengikuti Highload ++ Siberia 2019 - 8 Tugas Oracle 💅🏻 👨🏾‍🔬 🅱️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hai 

 Pada 24-25 Juni, konferensi Highload ++ Siberia 2019 diadakan di Novosibirsk. Orang-orang kami juga ada di laporan "Oracle Container Bases (CDB...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Mengikuti Highload ++ Siberia 2019 - 8 Tugas Oracle</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/sportmaster_lab/blog/459680/">  Hai <br><br>  Pada 24-25 Juni, konferensi Highload ++ Siberia 2019 diadakan di Novosibirsk. Orang-orang kami juga ada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">di laporan</a> "Oracle Container Bases (CDB / PDB) dan Penggunaan Praktisnya untuk Pengembangan Perangkat Lunak," kami akan memposting versi teks sedikit kemudian.  Itu keren, terima kasih <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" class="user_link">olegbunin</a> untuk pengorganisasian, serta semua orang yang datang. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/-7/k4/u1/-7k4u1btcjxquu515qeoyxnxigu.jpeg" width="350"></div><br>  Dalam posting ini, kami ingin berbagi dengan Anda tugas-tugas yang ada di stan kami sehingga Anda dapat menguji pengetahuan Anda di Oracle.  Di bawah tugas cut-8, jawab opsi dan penjelasan. <br><a name="habracut"></a><br><h3>  Berapa nilai maksimum dari urutan yang akan kita lihat sebagai hasil dari skrip berikut? </h3><br><pre><code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">sequence</span></span> s <span class="hljs-keyword"><span class="hljs-keyword">start</span></span> <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> s.currval, s.nextval, s.currval, s.nextval, s.currval <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> dual <span class="hljs-keyword"><span class="hljs-keyword">connect</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> <span class="hljs-keyword"><span class="hljs-keyword">level</span></span> &lt;= <span class="hljs-number"><span class="hljs-number">5</span></span>;</code> </pre> <br><ul><li>  1 </li><li>  5 </li><li>  10 </li><li>  25 </li><li>  Tidak, akan ada kesalahan </li></ul><br><div class="spoiler">  <b class="spoiler_title">Jawabannya</b> <div class="spoiler_text">  Menurut dokumentasi Oracle (dikutip dari 8.1.6): <br>  Dalam pernyataan SQL tunggal, Oracle akan menambah urutan hanya sekali per baris.  Jika pernyataan berisi lebih dari satu referensi ke NEXTVAL untuk suatu urutan, Oracle menambah urutan satu kali dan mengembalikan nilai yang sama untuk semua kemunculan NEXTVAL.  Jika pernyataan berisi referensi ke CURRVAL dan NEXTVAL, Oracle menambah urutan dan mengembalikan nilai yang sama untuk CURRVAL dan NEXTVAL terlepas dari urutan mereka dalam pernyataan. <br><br>  Dengan demikian, nilai <b>maksimum akan sesuai dengan jumlah baris, yaitu 5</b> . <br></div></div><br><h3>  Berapa banyak baris yang akan ada dalam tabel sebagai hasil dari skrip berikut? </h3><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> t(i <span class="hljs-built_in"><span class="hljs-built_in">integer</span></span> <span class="hljs-keyword"><span class="hljs-keyword">check</span></span> (i &lt; <span class="hljs-number"><span class="hljs-number">5</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">procedure</span></span> p(p_from <span class="hljs-built_in"><span class="hljs-built_in">integer</span></span>, p_to <span class="hljs-built_in"><span class="hljs-built_in">integer</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> p_from .. p_to <span class="hljs-keyword"><span class="hljs-keyword">loop</span></span> <span class="hljs-keyword"><span class="hljs-keyword">insert</span></span> <span class="hljs-keyword"><span class="hljs-keyword">into</span></span> t <span class="hljs-keyword"><span class="hljs-keyword">values</span></span> (i); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">loop</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; / exec p(1, 3); exec p(4, 6); exec p(7, 9);</code> </pre> <br><ul><li>  0 </li><li>  3 </li><li>  4 </li><li>  5 </li><li>  6 </li><li>  9 </li></ul><br><div class="spoiler">  <b class="spoiler_title">Jawabannya</b> <div class="spoiler_text">  Menurut dokumentasi Oracle (dikutip dari 11.2): <br><br>  Sebelum menjalankan pernyataan SQL apa pun, Oracle menandai savepoint implisit (tidak tersedia untuk Anda).  Kemudian, jika pernyataan gagal, Oracle mengembalikannya secara otomatis dan mengembalikan kode kesalahan yang berlaku ke SQLCODE di SQLCA.  Misalnya, jika pernyataan INSERT menyebabkan kesalahan dengan mencoba memasukkan nilai duplikat dalam indeks unik, pernyataan tersebut dibatalkan. <br><br>  Panggilan dari klien juga dianggap dan diproses sebagai satu pernyataan.  Dengan demikian, panggilan pertama ke HP berhasil diselesaikan dengan memasukkan tiga catatan;  panggilan kedua ke HP berakhir dengan kesalahan dan mengembalikan catatan keempat, yang berhasil saya masukkan;  panggilan ketiga gagal, <b>dan tiga entri muncul di tabel</b> . <br></div></div><br><h3>  Berapa banyak baris yang akan ada dalam tabel sebagai hasil dari skrip berikut? </h3><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> t(i <span class="hljs-built_in"><span class="hljs-built_in">integer</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">constraint</span></span> i_ch <span class="hljs-keyword"><span class="hljs-keyword">check</span></span> (i &lt; <span class="hljs-number"><span class="hljs-number">3</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">insert</span></span> <span class="hljs-keyword"><span class="hljs-keyword">into</span></span> t <span class="hljs-keyword"><span class="hljs-keyword">values</span></span> (<span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">insert</span></span> <span class="hljs-keyword"><span class="hljs-keyword">into</span></span> t <span class="hljs-keyword"><span class="hljs-keyword">values</span></span> (<span class="hljs-literal"><span class="hljs-literal">null</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">insert</span></span> <span class="hljs-keyword"><span class="hljs-keyword">into</span></span> t <span class="hljs-keyword"><span class="hljs-keyword">values</span></span> (<span class="hljs-number"><span class="hljs-number">2</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">insert</span></span> <span class="hljs-keyword"><span class="hljs-keyword">into</span></span> t <span class="hljs-keyword"><span class="hljs-keyword">values</span></span> (<span class="hljs-literal"><span class="hljs-literal">null</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">insert</span></span> <span class="hljs-keyword"><span class="hljs-keyword">into</span></span> t <span class="hljs-keyword"><span class="hljs-keyword">values</span></span> (<span class="hljs-number"><span class="hljs-number">3</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">insert</span></span> <span class="hljs-keyword"><span class="hljs-keyword">into</span></span> t <span class="hljs-keyword"><span class="hljs-keyword">values</span></span> (<span class="hljs-literal"><span class="hljs-literal">null</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">insert</span></span> <span class="hljs-keyword"><span class="hljs-keyword">into</span></span> t <span class="hljs-keyword"><span class="hljs-keyword">values</span></span> (<span class="hljs-number"><span class="hljs-number">4</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">insert</span></span> <span class="hljs-keyword"><span class="hljs-keyword">into</span></span> t <span class="hljs-keyword"><span class="hljs-keyword">values</span></span> (<span class="hljs-literal"><span class="hljs-literal">null</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">insert</span></span> <span class="hljs-keyword"><span class="hljs-keyword">into</span></span> t <span class="hljs-keyword"><span class="hljs-keyword">values</span></span> (<span class="hljs-number"><span class="hljs-number">5</span></span>); exception when others then dbms_output.put_line('Oops!'); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; /</code> </pre> <br><ul><li>  1 </li><li>  2 </li><li>  3 </li><li>  4 </li><li>  5 </li><li>  6 </li><li>  7 </li></ul><br><div class="spoiler">  <b class="spoiler_title">Jawabannya</b> <div class="spoiler_text">  Menurut dokumentasi Oracle (dikutip dari 11.2): <br><br>  Batasan pemeriksaan memungkinkan Anda menentukan kondisi yang harus dipenuhi setiap baris dalam tabel.  Untuk memenuhi batasan, setiap baris dalam tabel harus membuat kondisi BENAR atau tidak diketahui (karena nol).  Ketika Oracle mengevaluasi kondisi kendala pemeriksaan untuk baris tertentu, nama kolom apa pun dalam kondisi tersebut merujuk ke nilai kolom di baris itu. <br><br>  Dengan demikian, nilai nol akan lulus ujian, dan blok anonim akan berhasil dieksekusi sampai upaya untuk memasukkan nilai 3. Setelah ini, blok pemrosesan kesalahan akan membuang pengecualian, kemunduran tidak akan terjadi dan <b>tabel akan memiliki empat baris</b> dengan nilai 1, null, 2 dan nol lagi. <br></div></div><br><h3>  Pasangan nilai apa yang akan menempati jumlah ruang yang sama di blok? </h3><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> t ( a <span class="hljs-built_in"><span class="hljs-built_in">char</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-built_in"><span class="hljs-built_in">char</span></span>), b <span class="hljs-built_in"><span class="hljs-built_in">char</span></span>(<span class="hljs-number"><span class="hljs-number">10</span></span> <span class="hljs-built_in"><span class="hljs-built_in">char</span></span>), c <span class="hljs-built_in"><span class="hljs-built_in">char</span></span>(<span class="hljs-number"><span class="hljs-number">100</span></span> <span class="hljs-built_in"><span class="hljs-built_in">char</span></span>), i <span class="hljs-built_in"><span class="hljs-built_in">number</span></span>(<span class="hljs-number"><span class="hljs-number">4</span></span>), j <span class="hljs-built_in"><span class="hljs-built_in">number</span></span>(<span class="hljs-number"><span class="hljs-number">14</span></span>), k <span class="hljs-built_in"><span class="hljs-built_in">number</span></span>(<span class="hljs-number"><span class="hljs-number">24</span></span>), x varchar2(<span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-built_in"><span class="hljs-built_in">char</span></span>), y varchar2(<span class="hljs-number"><span class="hljs-number">10</span></span> <span class="hljs-built_in"><span class="hljs-built_in">char</span></span>), z varchar2(<span class="hljs-number"><span class="hljs-number">100</span></span> <span class="hljs-built_in"><span class="hljs-built_in">char</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">insert</span></span> <span class="hljs-keyword"><span class="hljs-keyword">into</span></span> t (a, b, i, j, x, y) <span class="hljs-keyword"><span class="hljs-keyword">values</span></span> (<span class="hljs-string"><span class="hljs-string">'Y'</span></span>, <span class="hljs-string"><span class="hljs-string">''</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>, <span class="hljs-string"><span class="hljs-string">''</span></span>, <span class="hljs-string"><span class="hljs-string">''</span></span>);</code> </pre><br><ul><li>  A dan X </li><li>  B dan Y </li><li>  C dan K </li><li>  C dan Z </li><li>  K dan Z </li><li>  I dan J </li><li>  J dan X </li><li>  Semua terdaftar </li></ul><br><div class="spoiler">  <b class="spoiler_title">Jawabannya</b> <div class="spoiler_text">  Berikut adalah kutipan dari dokumentasi (12.1.0.2) untuk menyimpan berbagai tipe data di Oracle. <br><br>  <b>Tipe data char</b> <br>  Tipe data CHAR menentukan string karakter tetap-panjang dalam set karakter basis data.  Anda menentukan karakter database yang ditetapkan ketika Anda membuat database Anda.  Oracle memastikan bahwa semua nilai yang disimpan dalam kolom CHAR memiliki panjang yang ditentukan oleh ukuran dalam semantik panjang yang dipilih.  Jika Anda memasukkan nilai yang lebih pendek dari panjang kolom, maka Oracle mengosongkan nilainya dengan panjang kolom. <br><br>  <b>Tipe Data VARCHAR2</b> <br>  Tipe data VARCHAR2 menentukan string karakter-panjang variabel dalam set karakter basis data.  Anda menentukan karakter database yang ditetapkan ketika Anda membuat database Anda.  Oracle menyimpan nilai karakter dalam kolom VARCHAR2 persis seperti yang Anda tentukan, tanpa bantalan kosong, asalkan nilainya tidak melebihi panjang kolom. <br><br>  <b>NUMBER Jenis Data</b> <br>  Tipe data NUMBER menyimpan nol serta bilangan tetap positif dan negatif dengan nilai absolut dari 1,0 x 10-130 hingga tetapi tidak termasuk 1,0 x 10126. Jika Anda menentukan ekspresi aritmatika yang nilainya memiliki nilai absolut lebih besar dari atau sama dengan 1,0 x 10126, lalu Oracle mengembalikan kesalahan.  Setiap nilai NUMBER membutuhkan 1 hingga 22 byte.  Dengan mempertimbangkan hal ini, ukuran kolom dalam byte untuk nilai data numerik tertentu NUMBER (p), di mana p adalah presisi dari nilai yang diberikan, dapat dihitung menggunakan rumus berikut: <i>ROUND ((panjang (p) + s) / 2)) +1</i> di mana s sama dengan nol jika angka positif, dan s sama dengan 1 jika angka negatif. <br><br>  Selain itu, kami mengambil kutipan dari dokumentasi tentang menyimpan nilai Null. <br><br>  Nol adalah tidak adanya nilai dalam kolom.  Nulls mengindikasikan data yang hilang, tidak diketahui, atau tidak dapat diterapkan.  Nulls disimpan dalam database jika berada di antara kolom dengan nilai data.  Dalam kasus ini, mereka membutuhkan 1 byte untuk menyimpan panjang kolom (nol).  Mengejar nol dalam satu baris tidak memerlukan penyimpanan karena header baris baru memberi sinyal bahwa kolom yang tersisa di baris sebelumnya adalah nol.  Misalnya, jika tiga kolom terakhir dari sebuah tabel adalah nol, maka tidak ada data yang disimpan untuk kolom ini. <br><br>  Berdasarkan data ini, kami membangun alasan.  Kami percaya bahwa basis data menggunakan pengodean AL32UTF8.  Dalam penyandian ini, huruf Rusia akan menempati 2 byte. <br><br>  1) A dan X, nilai bidang a 'Y' adalah 1 byte, nilai bidang x 'D' adalah 2 byte <br>  2) B dan Y, 'Vasya' dalam nilai b akan ditambah dengan spasi hingga 10 karakter dan akan menempati 14 byte, 'Vasya' dalam d - akan mengambil 8 byte. <br>  3) C dan K. Kedua bidang tersebut NULL, setelah itu ada bidang yang signifikan, sehingga menempati 1 byte. <br>  4) C dan Z. Kedua bidang NULL, tetapi bidang Z adalah yang terakhir dalam tabel, sehingga tidak memakan ruang (0 byte).  Field C membutuhkan 1 byte. <br>  5) K dan Z. Mirip dengan kasus sebelumnya.  Nilai dalam bidang K adalah 1 byte, dalam Z - 0. <br>  6) I dan J. Menurut dokumentasi, kedua nilai masing-masing akan mengambil 2 byte.  Kami mempertimbangkan panjang sesuai dengan rumus yang diambil dari dokumentasi: babak ((1 + 0) / 2) +1 = 1 + 1 = 2. <br>  7) J dan X. Nilai di bidang J akan mengambil 2 byte, nilai di bidang X akan mengambil 2 byte. <br><br>  <b>Secara total, opsi yang benar adalah: C dan K, I dan J, J dan X.</b> <br></div></div><br><br><h3>  Apa kira-kira faktor pengelompokan indeks T_I? </h3><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> t (i <span class="hljs-built_in"><span class="hljs-built_in">integer</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">insert</span></span> <span class="hljs-keyword"><span class="hljs-keyword">into</span></span> t <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-keyword"><span class="hljs-keyword">rownum</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> dual <span class="hljs-keyword"><span class="hljs-keyword">connect</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> <span class="hljs-keyword"><span class="hljs-keyword">level</span></span> &lt;= <span class="hljs-number"><span class="hljs-number">10000</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> t_i <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> t(i);</code> </pre><br><ul><li>  Sekitar lusinan </li><li>  Sekitar ratusan </li><li>  Dari urutan ribuan </li><li>  Dari urutan puluhan ribu </li></ul><br><div class="spoiler">  <b class="spoiler_title">Jawabannya</b> <div class="spoiler_text">  Menurut dokumentasi Oracle (dikutip dari 12.1): <br><br>  Untuk indeks B-tree, faktor pengelompokan indeks mengukur pengelompokan fisik baris dalam kaitannya dengan nilai indeks. <br><br>  Faktor pengelompokan indeks membantu pengoptimal memutuskan apakah pemindaian indeks atau pemindaian tabel penuh lebih efisien untuk kueri tertentu).  Faktor pengelompokan rendah menunjukkan pemindaian indeks yang efisien. <br><br>  Faktor pengelompokan yang dekat dengan jumlah blok dalam tabel menunjukkan bahwa baris secara fisik dipesan di blok tabel oleh kunci indeks.  Jika database melakukan pemindaian tabel penuh, maka database cenderung untuk mengambil baris ketika disimpan pada disk yang diurutkan berdasarkan kunci indeks.  Faktor pengelompokan yang dekat dengan jumlah baris menunjukkan bahwa baris tersebar secara acak di seluruh blok basis data terkait dengan kunci indeks.  Jika database melakukan pemindaian tabel penuh, maka database tidak akan mengambil baris dalam urutan apa pun dengan kunci indeks ini. <br><br>  Dalam kasus ini, data diurutkan secara ideal, sehingga faktor pengelompokan akan sama dengan atau dekat dengan jumlah blok yang ditempati dalam tabel.  Untuk ukuran blok standar 8 kilobyte, Anda dapat berharap bahwa sekitar seribu nilai angka sempit akan cocok dalam satu blok, sehingga jumlah blok, dan sebagai hasilnya faktor pengelompokan, akan berada di <b>urutan puluhan</b> . <br></div></div><br><h3>  Pada nilai N apa skrip berikut akan berhasil dieksekusi dalam database reguler dengan pengaturan standar? </h3><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> t ( a varchar2(N <span class="hljs-built_in"><span class="hljs-built_in">char</span></span>), b varchar2(N <span class="hljs-built_in"><span class="hljs-built_in">char</span></span>), c varchar2(N <span class="hljs-built_in"><span class="hljs-built_in">char</span></span>), d varchar2(N <span class="hljs-built_in"><span class="hljs-built_in">char</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> t_i <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> t (a, b, c, d);</code> </pre><br><ul><li>  100 </li><li>  200 </li><li>  400 </li><li>  800 </li><li>  1600 </li><li>  3200 </li><li>  6400 </li></ul><br><div class="spoiler">  <b class="spoiler_title">Jawabannya</b> <div class="spoiler_text">  Menurut dokumentasi Oracle (dikutip dari 11.2): <br><br>  Batas basis data logis <br><br><div class="scrollable-table"><table><thead><tr><td>  <strong>Barang</strong> </td><td>  <strong>Jenis batas</strong> </td><td>  <strong>Nilai batas</strong> </td></tr></thead><tbody><tr><td>  Indeks </td><td>  Ukuran total kolom yang diindeks </td><td>  75% dari ukuran blok basis data dikurangi beberapa overhead </td></tr></tbody></table></div><br>  Dengan demikian, ukuran total kolom yang diindeks tidak boleh melebihi 6Kb.  Lebih lanjut tergantung pada basis penyandian yang dipilih.  Untuk pengodean AL32UTF8, satu karakter dapat menempati maksimum 4 byte, jadi dalam skenario terburuk, 6 kilobyte akan muat sekitar 1.500 karakter.  Oleh karena itu, Oracle akan melarang pembuatan indeks pada N = 400 (ketika panjang kunci dalam kasus terburuk adalah 1600 karakter * 4 byte + panjang baris), sedangkan <b>pada N = 200 (atau kurang)</b> membuat indeks akan bekerja tanpa masalah. <br></div></div><br><h3>  Pernyataan INSERT dengan petunjuk LAMPIRAN dirancang untuk memuat data dalam mode langsung.  Apa yang terjadi jika diterapkan pada tabel tempat pemicunya hang? </h3><br><ul><li>  Data akan dimuat dalam mode langsung, pemicu akan berfungsi sebagaimana mestinya </li><li>  Data akan dimuat dalam mode langsung, tetapi pemicunya tidak akan dieksekusi </li><li>  Data akan dimuat dalam mode konvensional, pemicunya akan berfungsi sebagaimana mestinya </li><li>  Data akan dimuat dalam mode konvensional, tetapi pemicunya tidak akan dieksekusi </li><li>  Data tidak akan diunggah, kesalahan akan diperbaiki </li></ul><br><div class="spoiler">  <b class="spoiler_title">Jawabannya</b> <div class="spoiler_text">  Pada prinsipnya, ini lebih merupakan masalah logika.  Untuk menemukan jawaban yang tepat, saya akan menyarankan model penalaran berikut: <br><br><ol><li>  Penyisipan dalam mode langsung dilakukan dengan pembentukan langsung blok data, melewati mesin SQL, yang memastikan kecepatan tinggi.  Jadi, untuk memastikan eksekusi pelatuk sangat sulit, jika memungkinkan, dan tidak ada gunanya, karena hal itu akan secara dramatis memperlambat penyisipan. </li><li>  Kegagalan untuk memicu akan mengarah pada fakta bahwa, dengan data yang sama dalam tabel, keadaan basis data secara keseluruhan (dari tabel lain) akan tergantung pada mode mana data dimasukkan.  Ini jelas akan merusak integritas data dan tidak dapat diterapkan sebagai solusi dalam produksi. </li><li>  Ketidakmampuan untuk melakukan operasi yang diminta, secara umum, diperlakukan sebagai kesalahan.  Tetapi di sini harus diingat bahwa APPEND adalah petunjuk, dan logika umum petunjuk adalah bahwa mereka diperhitungkan jika mungkin, tetapi jika tidak, operator dieksekusi tanpa mempertimbangkan petunjuk tersebut. </li></ol><br>  Dengan demikian, jawaban yang diharapkan adalah bahwa <b>data akan dimuat dalam mode normal (SQL), pemicunya akan diaktifkan.</b> <br><br>  Menurut dokumentasi Oracle (dikutip dari 8.04): <br><br>  Pelanggaran pembatasan akan menyebabkan pernyataan dieksekusi secara serial, menggunakan jalur insert konvensional, tanpa peringatan atau pesan kesalahan.  Pengecualian adalah pembatasan pada pernyataan yang mengakses tabel yang sama lebih dari sekali dalam suatu transaksi, yang dapat menyebabkan pesan kesalahan. <br>  Misalnya, jika pemicu atau integritas referensial ada di atas meja, maka petunjuk APPEND akan diabaikan ketika Anda mencoba menggunakan INSERT muatan langsung (serial atau paralel), serta petunjuk atau klausa PARALLEL, jika ada. </div></div><br><h3>  Apa yang terjadi ketika menjalankan skrip berikut? </h3><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> t(i <span class="hljs-built_in"><span class="hljs-built_in">integer</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span> primary <span class="hljs-keyword"><span class="hljs-keyword">key</span></span>, j <span class="hljs-built_in"><span class="hljs-built_in">integer</span></span> <span class="hljs-keyword"><span class="hljs-keyword">references</span></span> t); <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">trigger</span></span> t_a_i <span class="hljs-keyword"><span class="hljs-keyword">after</span></span> <span class="hljs-keyword"><span class="hljs-keyword">insert</span></span> <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> t <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> <span class="hljs-keyword"><span class="hljs-keyword">each</span></span> <span class="hljs-keyword"><span class="hljs-keyword">row</span></span> <span class="hljs-keyword"><span class="hljs-keyword">declare</span></span> <span class="hljs-keyword"><span class="hljs-keyword">pragma</span></span> autonomous_transaction; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">insert</span></span> <span class="hljs-keyword"><span class="hljs-keyword">into</span></span> t <span class="hljs-keyword"><span class="hljs-keyword">values</span></span> (:new.i + <span class="hljs-number"><span class="hljs-number">1</span></span>, :new.i); <span class="hljs-keyword"><span class="hljs-keyword">commit</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; / <span class="hljs-keyword"><span class="hljs-keyword">insert</span></span> <span class="hljs-keyword"><span class="hljs-keyword">into</span></span> t <span class="hljs-keyword"><span class="hljs-keyword">values</span></span> (<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-literal"><span class="hljs-literal">null</span></span>);</code> </pre><br><ul><li>  Eksekusi yang sukses </li><li>  Kesalahan sintaksis gagal </li><li>  Kesalahan transaksi offline tidak valid </li><li>  Galat terkait dengan melebihi nesting panggilan maksimum </li><li>  Kesalahan Pelanggaran Kunci Asing </li><li>  Kunci Kesalahan </li></ul><br><div class="spoiler">  <b class="spoiler_title">Jawabannya</b> <div class="spoiler_text">  Tabel dan pemicu dibuat dengan benar dan operasi ini seharusnya tidak menimbulkan masalah.  Transaksi otonom dalam pelatuk juga diperbolehkan, jika tidak, tidak mungkin, misalnya, logging. <br><br>  Setelah memasukkan baris pertama, pemicu yang berhasil akan mengarah pada penyisipan dari baris kedua, sehubungan dengan mana pemicu akan bekerja lagi, masukkan baris ketiga, dan seterusnya sampai pernyataan jatuh karena melebihi bersarang maksimum panggilan.  Namun, titik halus lain dipicu.  Pada saat pemicu dieksekusi, komit belum dieksekusi untuk catatan yang dimasukkan pertama.  Oleh karena itu, pemicu yang bekerja dalam transaksi otonom mencoba menyisipkan baris dalam tabel yang merujuk oleh kunci asing ke catatan yang belum dilakukan.  Ini mengarah ke menunggu (transaksi otonom sedang menunggu komit utama untuk memahami apakah mungkin untuk memasukkan data) dan pada saat yang sama transaksi utama sedang menunggu komit otonom untuk terus bekerja setelah pemicu.  <b>Kebuntuan terjadi dan, sebagai akibatnya, transaksi otonom dipecat karena alasan yang terkait dengan kunci</b> . <br></div></div></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id459680/">https://habr.com/ru/post/id459680/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id459662/index.html">PVS-Studio ingin, tetapi tidak dapat menemukan bug di robots.txt</a></li>
<li><a href="../id459668/index.html">Cara mengenali teks dari foto: fitur baru kerangka Visi</a></li>
<li><a href="../id459670/index.html">Goto amsterdam</a></li>
<li><a href="../id459672/index.html">Garis bawahi dengan Python</a></li>
<li><a href="../id459674/index.html">Threat Intelligence Epic Saga</a></li>
<li><a href="../id459682/index.html">Kualitas data dalam penyimpanan</a></li>
<li><a href="../id459684/index.html">Peta Moskow Metro dan seluruh dunia untuk Android</a></li>
<li><a href="../id459688/index.html">Urbanisme di Tiongkok: Kurang Hipsters, Lebih Banyak Sains dan IT</a></li>
<li><a href="../id459692/index.html">Bagaimana kami menemukan modifikasi material yang bertentangan dengan prinsip kimia yang berlaku</a></li>
<li><a href="../id459694/index.html">Museum DataArt. Buka paket dan luncurkan Radio 86RK</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>