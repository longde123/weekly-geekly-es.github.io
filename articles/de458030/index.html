<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üí™üèΩ üóº üôÅ Funktionales JavaScript: F√ºnf M√∂glichkeiten, um das arithmetische Mittel von Array-Elementen und die .reduce () -Methode zu ermitteln üöØ üìΩÔ∏è üê§</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Array-Iterationsmethoden √§hneln dem ‚ÄûStarten von Drogen‚Äú (nat√ºrlich sind sie keine Drogen; und ich sage nicht, dass Drogen gut sind; sie sind nur eine...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Funktionales JavaScript: F√ºnf M√∂glichkeiten, um das arithmetische Mittel von Array-Elementen und die .reduce () -Methode zu ermitteln</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/458030/"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Array-Iterationsmethoden</a> √§hneln dem ‚ÄûStarten von Drogen‚Äú (nat√ºrlich sind sie keine Drogen; und ich sage nicht, dass Drogen gut sind; sie sind nur eine Redewendung).  Wegen ihnen "setzen" sich viele auf funktionale Programmierung.  Die Sache ist, dass sie unglaublich bequem sind.  Dar√ºber hinaus sind die meisten dieser Methoden sehr einfach zu verstehen.  Methoden wie <code>.map()</code> und <code>.filter()</code> akzeptieren nur ein <code>.filter()</code> und erm√∂glichen es Ihnen, einfache Probleme zu l√∂sen.  Es besteht jedoch das Gef√ºhl, dass die Methode <code>.reduce()</code> vielen Schwierigkeiten bereitet.  Es ist etwas schwieriger zu verstehen. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/webt/zd/ig/jp/zdigjpelbgmyf4qdprvkrxo5bu4.png"></a> <br><a name="habracut"></a><br>  Ich habe bereits dar√ºber geschrieben, warum ich denke, dass <code>.reduce()</code> viele Probleme verursacht.  Dies ist teilweise auf die Tatsache zur√ºckzuf√ºhren, dass viele Handb√ºcher die Verwendung von <code>.reduce()</code> nur beim Umgang mit Zahlen demonstrieren.  Daher habe ich dar√ºber geschrieben, wie viele Aufgaben, die keine arithmetischen Operationen implizieren, mit <code>.reduce()</code> gel√∂st werden <code>.reduce()</code> .  Aber was ist, wenn Sie unbedingt mit Zahlen arbeiten m√ºssen? <br><br>  Eine typische Verwendung von <code>.reduce()</code> sieht aus wie eine Berechnung des arithmetischen Mittels der Elemente eines Arrays.  Auf den ersten Blick scheint diese Aufgabe nichts Besonderes zu sein.  Aber sie ist nicht so einfach.  Tatsache ist, dass Sie vor der Berechnung des Durchschnitts die folgenden Indikatoren finden m√ºssen: <br><br><ol><li>  Die Gesamtanzahl der Array-Elementwerte. </li><li>  Die L√§nge des Arrays. </li></ol><br>  Das alles herauszufinden ist ziemlich einfach.  Auch die Berechnung von Durchschnittswerten f√ºr numerische Arrays ist keine schwierige Aufgabe.  Hier ist ein elementares Beispiel: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">average</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">nums</span></span></span><span class="hljs-function">) </span></span>{    <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> nums.reduce(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">a, b</span></span></span><span class="hljs-function">) =&gt;</span></span> (a + b)) / nums.length; }</code> </pre> <br>  Wie Sie sehen, gibt es hier keine besonderen Unverst√§ndnisse.  Die Aufgabe wird jedoch schwieriger, wenn Sie mit komplexeren Datenstrukturen arbeiten m√ºssen.  Was ist, wenn wir eine Reihe von Objekten haben?  Was ist, wenn einige Objekte aus diesem Array gefiltert werden m√ºssen?  Was tun, wenn Sie bestimmte numerische Werte aus Objekten extrahieren m√ºssen?  In dieser Situation ist die Berechnung des Durchschnittswerts f√ºr Array-Elemente bereits etwas komplizierter. <br><br>  Um dies zu bew√§ltigen, werden wir das Trainingsproblem l√∂sen (es basiert auf <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">dieser</a> Aufgabe mit FreeCodeCamp).  Wir werden es auf f√ºnf verschiedene Arten l√∂sen.  Jeder von ihnen hat seine eigenen Vor- und Nachteile.  Eine Analyse dieser f√ºnf L√∂sungsans√§tze zeigt, wie flexibel JavaScript sein kann.  Und ich hoffe, dass die Analyse von L√∂sungen Ihnen <code>.reduce()</code> zum Nachdenken dar√ºber gibt, wie Sie <code>.reduce()</code> in realen Projekten einsetzen k√∂nnen. <br><br><h2>  <font color="#3AC1EF">Aufgaben√ºbersicht</font> </h2><br>  Angenommen, wir haben eine Reihe von Objekten, die viktorianische Slang-Ausdr√ºcke beschreiben.  Sie m√ºssen die Ausdr√ºcke herausfiltern, die nicht in Google Books gefunden werden (die <code>found</code> Eigenschaft der entsprechenden Objekte ist <code>false</code> ), und eine durchschnittliche Bewertung f√ºr die Beliebtheit der Ausdr√ºcke ermitteln.  So k√∂nnten solche Daten aussehen ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">von hier √ºbernommen</a> ): <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> victorianSlang = [           term: <span class="hljs-string"><span class="hljs-string">'doing the bear'</span></span>,        <span class="hljs-attr"><span class="hljs-attr">found</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>,        <span class="hljs-attr"><span class="hljs-attr">popularity</span></span>: <span class="hljs-number"><span class="hljs-number">108</span></span>,    },           <span class="hljs-attr"><span class="hljs-attr">term</span></span>: <span class="hljs-string"><span class="hljs-string">'katterzem'</span></span>,        <span class="hljs-attr"><span class="hljs-attr">found</span></span>: <span class="hljs-literal"><span class="hljs-literal">false</span></span>,        <span class="hljs-attr"><span class="hljs-attr">popularity</span></span>: <span class="hljs-literal"><span class="hljs-literal">null</span></span>,    },           <span class="hljs-attr"><span class="hljs-attr">term</span></span>: <span class="hljs-string"><span class="hljs-string">'bone shaker'</span></span>,        <span class="hljs-attr"><span class="hljs-attr">found</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>,        <span class="hljs-attr"><span class="hljs-attr">popularity</span></span>: <span class="hljs-number"><span class="hljs-number">609</span></span>,    },           <span class="hljs-attr"><span class="hljs-attr">term</span></span>: <span class="hljs-string"><span class="hljs-string">'smothering a parrot'</span></span>,        <span class="hljs-attr"><span class="hljs-attr">found</span></span>: <span class="hljs-literal"><span class="hljs-literal">false</span></span>,        <span class="hljs-attr"><span class="hljs-attr">popularity</span></span>: <span class="hljs-literal"><span class="hljs-literal">null</span></span>,    },           <span class="hljs-attr"><span class="hljs-attr">term</span></span>: <span class="hljs-string"><span class="hljs-string">'damfino'</span></span>,        <span class="hljs-attr"><span class="hljs-attr">found</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>,        <span class="hljs-attr"><span class="hljs-attr">popularity</span></span>: <span class="hljs-number"><span class="hljs-number">232</span></span>,    },           <span class="hljs-attr"><span class="hljs-attr">term</span></span>: <span class="hljs-string"><span class="hljs-string">'rain napper'</span></span>,        <span class="hljs-attr"><span class="hljs-attr">found</span></span>: <span class="hljs-literal"><span class="hljs-literal">false</span></span>,        <span class="hljs-attr"><span class="hljs-attr">popularity</span></span>: <span class="hljs-literal"><span class="hljs-literal">null</span></span>,    },           <span class="hljs-attr"><span class="hljs-attr">term</span></span>: <span class="hljs-string"><span class="hljs-string">'donkey'</span></span>s breakfast<span class="hljs-string"><span class="hljs-string">',        found: true,        popularity: 787,    },           term: '</span></span>rational costume<span class="hljs-string"><span class="hljs-string">',        found: true,        popularity: 513,    },           term: '</span></span>mind the grease<span class="hljs-string"><span class="hljs-string">',        found: true,        popularity: 154,    }, ];</span></span></code> </pre> <br>  Betrachten Sie 5 M√∂glichkeiten, um den Durchschnittswert f√ºr die Bewertung der Beliebtheit von Ausdr√ºcken aus diesem Array zu ermitteln. <br><br><h2>  <font color="#3AC1EF">1. L√∂sen eines Problems ohne Verwendung von .reduce () (Imperativschleife)</font> </h2><br>  In unserem ersten Ansatz zur L√∂sung des Problems wird die Methode <code>.reduce()</code> nicht verwendet.  Wenn Sie noch nie auf Methoden zum Iterieren von Arrays gesto√üen sind, hoffe ich, dass das Parsen dieses Beispiels die Situation f√ºr Sie ein wenig klarer macht. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> popularitySum = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> itemsFound = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> len = victorianSlang.length; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> item = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; len; i++) {    item = victorianSlang[i];    <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (item.found) {        popularitySum = item.popularity + popularitySum;        itemsFound = itemsFound + <span class="hljs-number"><span class="hljs-number">1</span></span>;   } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> averagePopularity = popularitySum / itemsFound; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"Average popularity:"</span></span>, averagePopularity);</code> </pre> <br>  Wenn Sie mit JavaScript vertraut sind, werden Sie dieses Beispiel leicht verstehen.  Tats√§chlich passiert hier Folgendes: <br><br><ol><li>  Wir initialisieren die Variablen <code>itemsFound</code> und <code>itemsFound</code> .  Die erste Variable, <code>popularitySum</code> , speichert die Gesamtbewertung der Beliebtheit von Ausdr√ºcken.  Und die zweite Variable, <code>itemsFound</code> (das ist eine √úberraschung), speichert die Anzahl der gefundenen Ausdr√ºcke. </li><li>  Dann initialisieren wir die Konstante <code>len</code> und das variable <code>item</code> , die f√ºr uns beim Durchlaufen des Arrays n√ºtzlich sind. </li><li>  In einer <code>for</code> Schleife wird der Z√§hler <code>i</code> inkrementiert, bis sein Wert den Indexwert des letzten Elements des Arrays erreicht. </li><li>  Innerhalb der Schleife nehmen wir das Element des Arrays, das wir untersuchen m√∂chten.  Wir greifen auf das Element mit dem Konstruktor <code>victorianSlang[i]</code> . </li><li>  Dann finden wir heraus, ob dieser Ausdruck in der B√ºchersammlung gefunden wird. </li><li>  Wenn ein Ausdruck in B√ºchern vorkommt, nehmen wir den Wert seiner Beliebtheitsbewertung und addieren ihn zum Wert der Variablen <code>popularitySum</code> . </li><li>  Gleichzeitig erh√∂hen wir auch den Z√§hler der gefundenen Ausdr√ºcke - <code>itemsFound</code> . </li><li>  Und schlie√ülich finden wir den Durchschnitt, indem wir <code>popularitySum</code> durch <code>itemsFound</code> . </li></ol><br>  Also haben wir die Aufgabe gemeistert.  Vielleicht war unsere Entscheidung nicht besonders sch√∂n, aber sie macht ihren Job.  Die Verwendung von Methoden zum Durchlaufen von Arrays macht es ein wenig sauberer.  Werfen wir einen Blick darauf, ob es uns gelingt, diese Entscheidung zu ‚Äûbereinigen‚Äú. <br><br><h2>  <font color="#3AC1EF">2. Einfache L√∂sung Nr. 1: .filter (), .map () und Ermitteln der Menge mit .reduce ()</font> </h2><br>  Lassen Sie uns vor dem ersten Versuch, das Problem mit den Methoden von Arrays zu l√∂sen, es in kleine Teile zerlegen.  Folgendes m√ºssen wir n√§mlich tun: <br><br><ol><li>  W√§hlen Sie Objekte aus, die Ausdr√ºcke in der Google Books-Sammlung darstellen.  Hier k√∂nnen Sie die Methode <code>.filter()</code> verwenden. </li><li>  Extrahieren Sie aus den Objekten die Bewertung der Popularit√§t von Ausdr√ºcken.  Um diese Unteraufgabe zu l√∂sen, ist die Methode <code>.map()</code> geeignet. </li><li>  Berechnen Sie die Summe der Bewertungen.  Hier k√∂nnen wir auf die Hilfe unseres alten Freundes <code>.reduce()</code> . </li><li>  Und schlie√ülich finden Sie den Durchschnittswert der Sch√§tzungen. </li></ol><br>  So sieht es im Code aus: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//   // ---------------------------------------------------------------------------- function isFound(item) {    return item.found; }; function getPopularity(item) {    return item.popularity; } function addScores(runningTotal, popularity) {    return runningTotal + popularity; } //  // ---------------------------------------------------------------------------- //  ,      . const foundSlangTerms = victorianSlang.filter(isFound); //   ,   . const popularityScores = foundSlangTerms.map(getPopularity); //     .    ,    //   ,  reduce     ,  0. const scoresTotal = popularityScores.reduce(addScores, 0); //       . const averagePopularity = scoresTotal / popularityScores.length; console.log("Average popularity:", averagePopularity);</span></span></code> </pre> <br>  Schauen <code>addScore</code> sich die Funktion <code>addScore</code> und die Zeile an, in der <code>.reduce()</code> aufgerufen wird.  Beachten Sie, dass <code>addScore</code> zwei Parameter akzeptiert.  Das erste, <code>runningTotal</code> , wird als Batterie bezeichnet.  Es speichert die Summe der Werte.  Sein Wert √§ndert sich jedes Mal, wenn wir √ºber das Array iterieren und die <code>return</code> ausf√ºhren.  Der zweite Parameter, <code>popularity</code> , ist ein separates Element des Arrays, das wir verarbeiten.  Zu Beginn der <code>addScore</code> √ºber das Array wurde die <code>addScore</code> <code>return</code> in <code>addScore</code> nie ausgef√ºhrt.  Dies bedeutet, dass <code>runningTotal</code> noch nicht automatisch festgelegt wurde.  Daher <code>.reduce()</code> wir durch Aufrufen von <code>.reduce()</code> an diese Methode den Wert, der zu Beginn in <code>.reduce()</code> geschrieben werden muss.  Dies ist der zweite Parameter, der an <code>.reduce()</code> . <br><br>  Daher haben wir die Methoden zum Iterieren von Arrays angewendet, um das Problem zu l√∂sen.  Die neue Version der L√∂sung erwies sich als viel sauberer als die vorherige.  Mit anderen Worten, die Entscheidung erwies sich als aussagekr√§ftiger.  Wir teilen JavaScript nicht genau mit, wie die Schleife ausgef√ºhrt werden soll, sondern folgen nicht den Indizes der Elemente von Arrays.  Stattdessen deklarieren wir einfache Hilfsfunktionen von geringer Gr√∂√üe und kombinieren sie.  Die ganze harte Arbeit erledigen die Array-Methoden <code>.filter()</code> , <code>.map()</code> und <code>.reduce()</code> f√ºr uns.  Dieser Ansatz zur L√∂sung solcher Probleme ist aussagekr√§ftiger.  Diese Array-Methoden sind viel vollst√§ndiger als die Schleife. Sie geben Auskunft √ºber die im Code festgelegte Absicht. <br><br><h2>  <font color="#3AC1EF">3. Einfache L√∂sung Nr. 2: Verwenden mehrerer Batterien</font> </h2><br>  In der vorherigen Version der L√∂sung haben wir eine ganze Reihe von Zwischenvariablen erstellt.  Zum Beispiel <code>foundSlangTerms</code> und <code>popularityScores</code> .  In unserem Fall ist eine solche L√∂sung durchaus akzeptabel.  Was aber, wenn wir uns ein komplexeres Ziel f√ºr das Code-Design setzen?  Es w√§re sch√∂n, wenn wir das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">flie√üende Interface-</a> Design-Muster im Programm verwenden k√∂nnten.  Mit diesem Ansatz k√∂nnten wir die Aufrufe aller Funktionen verketten und auf Zwischenvariablen verzichten.  Hier erwartet uns jedoch ein Problem.  Beachten Sie, dass wir den Wert von <code>popularityScores.length</code> .  Wenn wir alles verketten wollen, brauchen wir eine andere Methode, um die Anzahl der Elemente im Array zu ermitteln.  Die Anzahl der Elemente im Array spielt die Rolle eines Divisors bei der Berechnung des Durchschnittswerts.  Mal sehen, ob wir den Ansatz zur L√∂sung des Problems so √§ndern k√∂nnen, dass alles durch Kombinieren von Methodenaufrufen in einer Kette erledigt werden kann.  Wir werden dies tun, indem wir zwei Werte verfolgen, wenn wir √ºber die Elemente des Arrays iterieren, dh mit der ‚ÄûDoppelbatterie‚Äú. <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//   // --------------------------------------------------------------------------------- function isFound(item) {    return item.found; }; function getPopularity(item) {    return item.popularity; } //    ,  return,   . function addScores({totalPopularity, itemCount}, popularity) {    return {        totalPopularity: totalPopularity + popularity,        itemCount:    itemCount + 1,    }; } //  // --------------------------------------------------------------------------------- const initialInfo  = {totalPopularity: 0, itemCount: 0}; const popularityInfo = victorianSlang.filter(isFound)    .map(getPopularity)    .reduce(addScores, initialInfo); //       . const {totalPopularity, itemCount} = popularityInfo; const averagePopularity = totalPopularity / itemCount; console.log("Average popularity:", averagePopularity);</span></span></code> </pre> <br>  Um mit zwei Werten zu arbeiten, haben wir hier das Objekt in der Reduzierungsfunktion verwendet.  Bei jedem Durchlauf durch das mit <code>addScrores</code> durchgef√ºhrte Array <code>addScrores</code> wir den Gesamtwert der Beliebtheitsbewertung und die Anzahl der Elemente.  Es ist wichtig zu beachten, dass diese beiden Werte als ein einzelnes Objekt dargestellt werden.  Mit diesem Ansatz k√∂nnen wir das System ‚Äûaustricksen‚Äú und zwei Entit√§ten innerhalb desselben R√ºckgabewerts speichern. <br><br>  Die Funktion <code>addScrores</code> als etwas komplizierter als die Funktion mit demselben Namen im vorherigen Beispiel.  Jetzt stellt sich jedoch heraus, dass wir eine einzelne Kette von Methodenaufrufen verwenden k√∂nnen, um alle Operationen mit dem Array auszuf√ºhren.  Als Ergebnis der Verarbeitung des Arrays erhalten wir das Objekt popularInfo, in dem alles gespeichert ist, was Sie zum Ermitteln des Durchschnitts ben√∂tigen.  Dies macht die Anrufkette ordentlich und einfach. <br><br>  Wenn Sie den Wunsch haben, diesen Code zu verbessern, k√∂nnen Sie damit experimentieren.  Zum Beispiel - Sie k√∂nnen es wiederholen, um viele Zwischenvariablen zu entfernen.  Sie k√∂nnen sogar versuchen, diesen Code in eine Zeile zu setzen. <br><br><h2>  <font color="#3AC1EF">4. Zusammensetzung von Funktionen ohne Punktnotation</font> </h2><br>  Wenn Sie mit funktionaler Programmierung noch nicht vertraut sind oder wenn Ihnen die funktionale Programmierung zu kompliziert erscheint, k√∂nnen Sie diesen Abschnitt √ºberspringen.  Das Parsen kommt Ihnen zugute, wenn Sie bereits mit <code>curry()</code> und <code>compose()</code> vertraut sind.  Wenn Sie sich mit diesem Thema befassen m√∂chten, werfen Sie einen Blick auf <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">dieses</a> Material zur funktionalen Programmierung in JavaScript und insbesondere auf den <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">dritten</a> Teil der Reihe, in der es enthalten ist. <br><br>  Wir sind Programmierer, die einen funktionalen Ansatz verfolgen.  Dies bedeutet, dass wir uns bem√ºhen, komplexe Funktionen aus anderen Funktionen aufzubauen - klein und einfach.  Bisher haben wir im Zuge der Pr√ºfung verschiedener Optionen zur L√∂sung des Problems die Anzahl der Zwischenvariablen reduziert.  Infolgedessen wurde der L√∂sungscode immer einfacher.  Aber was ist, wenn diese Idee auf die Spitze getrieben wird?  Was ist, wenn Sie versuchen, alle Zwischenvariablen loszuwerden?  Und sogar versuchen, von einigen Parametern wegzukommen? <br><br>  Sie k√∂nnen eine Funktion erstellen, um den Durchschnitt nur mit der Funktion <code>compose()</code> zu berechnen, ohne Variablen zu verwenden.  Wir nennen dies "Programmierung ohne feink√∂rnige Notation" oder "implizite Programmierung".  Um solche Programme zu schreiben, ben√∂tigen Sie viele Hilfsfunktionen. <br><br>  Manchmal schockiert ein solcher Code Menschen.  Dies liegt an der Tatsache, dass sich ein solcher Ansatz stark von dem allgemein akzeptierten unterscheidet.  Ich fand jedoch heraus, dass das Schreiben von Code im Stil der impliziten Programmierung eine der schnellsten Methoden ist, um die Essenz der funktionalen Programmierung zu verstehen.  Daher kann ich Ihnen raten, diese Technik in einem pers√∂nlichen Projekt auszuprobieren.  Aber ich m√∂chte sagen, dass Sie den Code, den andere Leute lesen m√ºssen, vielleicht nicht im Stil der impliziten Programmierung schreiben sollten. <br><br>  Zur√ºck zu unserer Aufgabe, ein System zur Berechnung von Durchschnittswerten zu konstruieren.  Um Platz zu sparen, werden wir hier auf die Verwendung von Pfeilfunktionen eingehen.  In der Regel ist es besser, benannte Funktionen zu verwenden.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Hier ist ein</a> guter Artikel zu diesem Thema.  Auf diese Weise erhalten Sie im Fehlerfall bessere Stack-Trace-Ergebnisse. <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//   // ---------------------------------------------------------------------------- const filter = p =&gt; a =&gt; a.filter(p); const map   = f =&gt; a =&gt; a.map(f); const prop  = k =&gt; x =&gt; x[k]; const reduce = r =&gt; i =&gt; a =&gt; a.reduce(r, i); const compose = (...fns) =&gt; (arg) =&gt; fns.reduceRight((arg, fn) =&gt; fn(arg), arg); //  -   "blackbird combinator". //     : https://jrsinclair.com/articles/2019/compose-js-functions-multiple-parameters/ const B1 = f =&gt; g =&gt; h =&gt; x =&gt; f(g(x))(h(x)); //  // ---------------------------------------------------------------------------- //   sum,    . const sum = reduce((a, i) =&gt; a + i)(0); //     . const length = a =&gt; a.length; //       . const div = a =&gt; b =&gt; a / b; //   compose()        . //    compose()     . const calcPopularity = compose(    B1(div)(sum)(length),    map(prop('popularity')),    filter(prop('found')), ); const averagePopularity = calcPopularity(victorianSlang); console.log("Average popularity:", averagePopularity);</span></span></code> </pre> <br>  Wenn Ihnen all dieser Code v√∂llig unsinnig erscheint, machen Sie sich dar√ºber keine Sorgen.  Ich habe es hier als intellektuelle √úbung aufgenommen, um Sie nicht zu ver√§rgern. <br><br>  In diesem Fall liegt die Hauptarbeit in der Funktion <code>compose()</code> .  Wenn Sie den Inhalt von unten nach oben lesen, stellt sich heraus, dass die Berechnungen damit beginnen, das Array nach der Eigenschaft der <code>found</code> Elemente zu filtern.  Dann rufen wir die <code>popularity</code> Eigenschaft mit <code>map()</code> .  Danach verwenden wir den sogenannten ‚Äû <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Amselkombinator</a> ‚Äú.  Diese Entit√§t wird als Funktion <code>B1</code> , mit der zwei Berechnungsdurchl√§ufe f√ºr einen Satz von Eingabedaten durchgef√ºhrt werden.  Schauen Sie sich zum besseren Verst√§ndnis die folgenden Beispiele an: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//   ,  , : const avg1 = B1(div)(sum)(length); const avg2 = arr =&gt; div(sum(arr))(length(arr)); const avg3 = arr =&gt; ( sum(arr) / length(arr) ); const avg4 = arr =&gt; arr.reduce((a, x) =&gt; a + x, 0) / arr.length;</span></span></code> </pre> <br>  Auch wenn Sie nichts mehr verstehen - machen Sie sich keine Sorgen.  Dies ist nur eine Demonstration, dass JavaScript auf sehr unterschiedliche Weise geschrieben werden kann.  Von diesen Merkmalen ist dies die Sch√∂nheit dieser Sprache. <br><br><h2>  <font color="#3AC1EF">5. L√∂sen Sie das Problem in einem Durchgang mit der Berechnung des kumulierten Durchschnittswerts</font> </h2><br>  Alle oben genannten Software-Konstrukte l√∂sen unser Problem (einschlie√ülich des Imperativzyklus) gut.  Diejenigen, die die <code>.reduce()</code> -Methode verwenden, haben etwas gemeinsam.  Sie basieren darauf, das Problem in kleine Fragmente zu zerlegen.  Diese Fragmente werden dann auf verschiedene Arten zusammengesetzt.  Wenn Sie diese L√∂sungen analysieren, stellen Sie m√∂glicherweise fest, dass wir das Array dreimal durchlaufen.  Es besteht das Gef√ºhl, dass es unwirksam ist.  Es w√§re sch√∂n, wenn es eine M√∂glichkeit g√§be, das Array zu verarbeiten und das Ergebnis in einem Durchgang zur√ºckzugeben.  Diese Methode existiert, f√ºr ihre Anwendung muss jedoch auf Mathematik zur√ºckgegriffen werden. <br><br>  Um den Durchschnittswert f√ºr Array-Elemente in einem Durchgang zu berechnen, ben√∂tigen wir eine neue Methode.  Sie m√ºssen einen Weg finden, um den Durchschnitt anhand des zuvor berechneten Durchschnitts und des neuen Werts zu berechnen.  Wir suchen diese Methode mit Algebra. <br><br>  Der Durchschnittswert von <code>n</code> Zahlen kann mit dieser Formel ermittelt werden: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ea8/922/a8a/ea8922a8ad59e55aa604bf01c72b55e4.png"></div><br>  Um die durchschnittlichen <code>n + 1</code> Zahlen herauszufinden, reicht dieselbe Formel aus, jedoch in einem anderen Eintrag: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/77c/ee8/a1f/77cee8a1fe717b88a55b2f2af6f222e2.png"></div><br>  Diese Formel ist dieselbe wie folgt: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/651/b3a/0ca/651b3a0caa501b140e23cbce68a96720.png"></div><br>  Und das Gleiche wie das: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f7b/e1b/da4/f7be1bda4b12343eee3dde51d80f95c0.png"></div><br>  Wenn Sie dies ein wenig konvertieren, erhalten Sie Folgendes: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/038/165/1b5/0381651b520c5136458129c1882a44af.png"></div><br>  Wenn Sie den Punkt in all dem nicht sehen, ist es in Ordnung.  Das Ergebnis all dieser Transformationen ist, dass wir mit Hilfe der letzten Formel den Durchschnittswert w√§hrend eines einzelnen Durchlaufs des Arrays berechnen k√∂nnen.  Dazu m√ºssen Sie den Wert des aktuellen Elements, den im vorherigen Schritt berechneten Durchschnittswert und die Anzahl der Elemente kennen.  Dar√ºber hinaus k√∂nnen die meisten Berechnungen in der Reduzierfunktion durchgef√ºhrt werden: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//      // ---------------------------------------------------------------------------- function averageScores({avg, n}, slangTermInfo) {    if (!slangTermInfo.found) {        return {avg, n};       return {        avg: (slangTermInfo.popularity + n * avg) / (n + 1),        n:  n + 1,    }; } //  // ---------------------------------------------------------------------------- //       . const initialVals    = {avg: 0, n: 0}; const averagePopularity = victorianSlang.reduce(averageScores, initialVals).avg; console.log("Average popularity:", averagePopularity);</span></span></code> </pre> <br>  Dank dieses Ansatzes kann der erforderliche Wert nur einmal unter Umgehung des Arrays gefunden werden.  Andere Ans√§tze verwenden einen Durchgang, um das Array zu filtern, einen anderen, um die erforderlichen Daten daraus zu extrahieren, und einen anderen, um die Summe der Werte der Elemente zu ermitteln.  Hier passt alles in einen Durchgang durch das Array. <br><br>  Bitte beachten Sie, dass dies die Berechnungen nicht unbedingt effizienter macht.  Bei diesem Ansatz m√ºssen mehr Berechnungen durchgef√ºhrt werden.  Wenn jeder neue Wert eintrifft, f√ºhren wir die Multiplikations- und Divisionsoperationen durch, um den aktuellen Durchschnittswert im aktuellen Zustand zu halten.  Bei anderen L√∂sungen f√ºr dieses Problem teilen wir eine Zahl nur einmal in eine andere - am Ende des Programms.  Dieser Ansatz ist jedoch in Bezug auf die Speichernutzung viel effizienter.  Zwischenarrays werden hier nicht verwendet, daher m√ºssen wir nur ein Objekt mit zwei Werten im Speicher speichern. <br><br>         .        .     ,     .   .  ,   ,      . <br><br><h2> <font color="#3AC1EF"> ?</font> </h2><br>              ?   ,     . ,    -  . , ,      ,       .         ,       .       ,           .          ,      ,       . <br><br> ,  -     ,           .       ,         ?   .      .  ‚Äî   . <br><br><h2> <font color="#3AC1EF"></font> </h2><br>         : <br><br><ol><li>   <code>.reduce()</code> . </li><li>    <code>.filter()</code>  <code>.map()</code> ,   ‚Äî  <code>.reduce()</code>       . </li><li>   ,      . </li><li>     . </li><li>         . </li></ol><br>  , -,     ?    ‚Äî  .      -  ‚Äî     ,          : <br><br><ol><li>    ,     .      ‚Äî   . </li><li>    ,    ,    ‚Äî     . </li><li> , ,        ‚Äî   ,     . </li></ol><br> <b> !</b>        JavaScript-? <br><br><div style="text-align:center;"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/getpro/habr/post_images/a09/9e4/5a8/a099e45a81c9dafd3a3673edd5ea415b.jpg"></a> </div></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de458030/">https://habr.com/ru/post/de458030/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de458014/index.html">FEDOR Robot - Training mit der neuen ISS-Crew und den ersten Weltraumaufgaben</a></li>
<li><a href="../de458018/index.html">Komponist vs npm: Multi-Modul-Entwicklung</a></li>
<li><a href="../de458020/index.html">Juli IT Events Digest</a></li>
<li><a href="../de458022/index.html">Fingerabdruck durch Bannerwerbung? Nun ist das √ºblich</a></li>
<li><a href="../de458026/index.html">Vergleich der Serialisierungsformate</a></li>
<li><a href="../de458040/index.html">Von Moskau nach Tomsk. Die Geschichte eines Zuges</a></li>
<li><a href="../de458042/index.html">Wie ich das maschinelle Lernen an der NSU organisiert habe</a></li>
<li><a href="../de458044/index.html">Informationssicherheit in der Provinz - Stagnation oder Entwicklung?</a></li>
<li><a href="../de458046/index.html">Gradle Spickzettel</a></li>
<li><a href="../de458048/index.html">Delegation als Manager-Tool</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>