<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>💪🏽 🗼 🙁 Funktionales JavaScript: Fünf Möglichkeiten, um das arithmetische Mittel von Array-Elementen und die .reduce () -Methode zu ermitteln 🚯 📽️ 🐤</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Array-Iterationsmethoden ähneln dem „Starten von Drogen“ (natürlich sind sie keine Drogen; und ich sage nicht, dass Drogen gut sind; sie sind nur eine...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Funktionales JavaScript: Fünf Möglichkeiten, um das arithmetische Mittel von Array-Elementen und die .reduce () -Methode zu ermitteln</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/458030/"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Array-Iterationsmethoden</a> ähneln dem „Starten von Drogen“ (natürlich sind sie keine Drogen; und ich sage nicht, dass Drogen gut sind; sie sind nur eine Redewendung).  Wegen ihnen "setzen" sich viele auf funktionale Programmierung.  Die Sache ist, dass sie unglaublich bequem sind.  Darüber hinaus sind die meisten dieser Methoden sehr einfach zu verstehen.  Methoden wie <code>.map()</code> und <code>.filter()</code> akzeptieren nur ein <code>.filter()</code> und ermöglichen es Ihnen, einfache Probleme zu lösen.  Es besteht jedoch das Gefühl, dass die Methode <code>.reduce()</code> vielen Schwierigkeiten bereitet.  Es ist etwas schwieriger zu verstehen. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/webt/zd/ig/jp/zdigjpelbgmyf4qdprvkrxo5bu4.png"></a> <br><a name="habracut"></a><br>  Ich habe bereits darüber geschrieben, warum ich denke, dass <code>.reduce()</code> viele Probleme verursacht.  Dies ist teilweise auf die Tatsache zurückzuführen, dass viele Handbücher die Verwendung von <code>.reduce()</code> nur beim Umgang mit Zahlen demonstrieren.  Daher habe ich darüber geschrieben, wie viele Aufgaben, die keine arithmetischen Operationen implizieren, mit <code>.reduce()</code> gelöst werden <code>.reduce()</code> .  Aber was ist, wenn Sie unbedingt mit Zahlen arbeiten müssen? <br><br>  Eine typische Verwendung von <code>.reduce()</code> sieht aus wie eine Berechnung des arithmetischen Mittels der Elemente eines Arrays.  Auf den ersten Blick scheint diese Aufgabe nichts Besonderes zu sein.  Aber sie ist nicht so einfach.  Tatsache ist, dass Sie vor der Berechnung des Durchschnitts die folgenden Indikatoren finden müssen: <br><br><ol><li>  Die Gesamtanzahl der Array-Elementwerte. </li><li>  Die Länge des Arrays. </li></ol><br>  Das alles herauszufinden ist ziemlich einfach.  Auch die Berechnung von Durchschnittswerten für numerische Arrays ist keine schwierige Aufgabe.  Hier ist ein elementares Beispiel: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">average</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">nums</span></span></span><span class="hljs-function">) </span></span>{    <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> nums.reduce(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">a, b</span></span></span><span class="hljs-function">) =&gt;</span></span> (a + b)) / nums.length; }</code> </pre> <br>  Wie Sie sehen, gibt es hier keine besonderen Unverständnisse.  Die Aufgabe wird jedoch schwieriger, wenn Sie mit komplexeren Datenstrukturen arbeiten müssen.  Was ist, wenn wir eine Reihe von Objekten haben?  Was ist, wenn einige Objekte aus diesem Array gefiltert werden müssen?  Was tun, wenn Sie bestimmte numerische Werte aus Objekten extrahieren müssen?  In dieser Situation ist die Berechnung des Durchschnittswerts für Array-Elemente bereits etwas komplizierter. <br><br>  Um dies zu bewältigen, werden wir das Trainingsproblem lösen (es basiert auf <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">dieser</a> Aufgabe mit FreeCodeCamp).  Wir werden es auf fünf verschiedene Arten lösen.  Jeder von ihnen hat seine eigenen Vor- und Nachteile.  Eine Analyse dieser fünf Lösungsansätze zeigt, wie flexibel JavaScript sein kann.  Und ich hoffe, dass die Analyse von Lösungen Ihnen <code>.reduce()</code> zum Nachdenken darüber gibt, wie Sie <code>.reduce()</code> in realen Projekten einsetzen können. <br><br><h2>  <font color="#3AC1EF">Aufgabenübersicht</font> </h2><br>  Angenommen, wir haben eine Reihe von Objekten, die viktorianische Slang-Ausdrücke beschreiben.  Sie müssen die Ausdrücke herausfiltern, die nicht in Google Books gefunden werden (die <code>found</code> Eigenschaft der entsprechenden Objekte ist <code>false</code> ), und eine durchschnittliche Bewertung für die Beliebtheit der Ausdrücke ermitteln.  So könnten solche Daten aussehen ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">von hier übernommen</a> ): <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> victorianSlang = [           term: <span class="hljs-string"><span class="hljs-string">'doing the bear'</span></span>,        <span class="hljs-attr"><span class="hljs-attr">found</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>,        <span class="hljs-attr"><span class="hljs-attr">popularity</span></span>: <span class="hljs-number"><span class="hljs-number">108</span></span>,    },           <span class="hljs-attr"><span class="hljs-attr">term</span></span>: <span class="hljs-string"><span class="hljs-string">'katterzem'</span></span>,        <span class="hljs-attr"><span class="hljs-attr">found</span></span>: <span class="hljs-literal"><span class="hljs-literal">false</span></span>,        <span class="hljs-attr"><span class="hljs-attr">popularity</span></span>: <span class="hljs-literal"><span class="hljs-literal">null</span></span>,    },           <span class="hljs-attr"><span class="hljs-attr">term</span></span>: <span class="hljs-string"><span class="hljs-string">'bone shaker'</span></span>,        <span class="hljs-attr"><span class="hljs-attr">found</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>,        <span class="hljs-attr"><span class="hljs-attr">popularity</span></span>: <span class="hljs-number"><span class="hljs-number">609</span></span>,    },           <span class="hljs-attr"><span class="hljs-attr">term</span></span>: <span class="hljs-string"><span class="hljs-string">'smothering a parrot'</span></span>,        <span class="hljs-attr"><span class="hljs-attr">found</span></span>: <span class="hljs-literal"><span class="hljs-literal">false</span></span>,        <span class="hljs-attr"><span class="hljs-attr">popularity</span></span>: <span class="hljs-literal"><span class="hljs-literal">null</span></span>,    },           <span class="hljs-attr"><span class="hljs-attr">term</span></span>: <span class="hljs-string"><span class="hljs-string">'damfino'</span></span>,        <span class="hljs-attr"><span class="hljs-attr">found</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>,        <span class="hljs-attr"><span class="hljs-attr">popularity</span></span>: <span class="hljs-number"><span class="hljs-number">232</span></span>,    },           <span class="hljs-attr"><span class="hljs-attr">term</span></span>: <span class="hljs-string"><span class="hljs-string">'rain napper'</span></span>,        <span class="hljs-attr"><span class="hljs-attr">found</span></span>: <span class="hljs-literal"><span class="hljs-literal">false</span></span>,        <span class="hljs-attr"><span class="hljs-attr">popularity</span></span>: <span class="hljs-literal"><span class="hljs-literal">null</span></span>,    },           <span class="hljs-attr"><span class="hljs-attr">term</span></span>: <span class="hljs-string"><span class="hljs-string">'donkey'</span></span>s breakfast<span class="hljs-string"><span class="hljs-string">',        found: true,        popularity: 787,    },           term: '</span></span>rational costume<span class="hljs-string"><span class="hljs-string">',        found: true,        popularity: 513,    },           term: '</span></span>mind the grease<span class="hljs-string"><span class="hljs-string">',        found: true,        popularity: 154,    }, ];</span></span></code> </pre> <br>  Betrachten Sie 5 Möglichkeiten, um den Durchschnittswert für die Bewertung der Beliebtheit von Ausdrücken aus diesem Array zu ermitteln. <br><br><h2>  <font color="#3AC1EF">1. Lösen eines Problems ohne Verwendung von .reduce () (Imperativschleife)</font> </h2><br>  In unserem ersten Ansatz zur Lösung des Problems wird die Methode <code>.reduce()</code> nicht verwendet.  Wenn Sie noch nie auf Methoden zum Iterieren von Arrays gestoßen sind, hoffe ich, dass das Parsen dieses Beispiels die Situation für Sie ein wenig klarer macht. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> popularitySum = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> itemsFound = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> len = victorianSlang.length; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> item = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; len; i++) {    item = victorianSlang[i];    <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (item.found) {        popularitySum = item.popularity + popularitySum;        itemsFound = itemsFound + <span class="hljs-number"><span class="hljs-number">1</span></span>;   } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> averagePopularity = popularitySum / itemsFound; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"Average popularity:"</span></span>, averagePopularity);</code> </pre> <br>  Wenn Sie mit JavaScript vertraut sind, werden Sie dieses Beispiel leicht verstehen.  Tatsächlich passiert hier Folgendes: <br><br><ol><li>  Wir initialisieren die Variablen <code>itemsFound</code> und <code>itemsFound</code> .  Die erste Variable, <code>popularitySum</code> , speichert die Gesamtbewertung der Beliebtheit von Ausdrücken.  Und die zweite Variable, <code>itemsFound</code> (das ist eine Überraschung), speichert die Anzahl der gefundenen Ausdrücke. </li><li>  Dann initialisieren wir die Konstante <code>len</code> und das variable <code>item</code> , die für uns beim Durchlaufen des Arrays nützlich sind. </li><li>  In einer <code>for</code> Schleife wird der Zähler <code>i</code> inkrementiert, bis sein Wert den Indexwert des letzten Elements des Arrays erreicht. </li><li>  Innerhalb der Schleife nehmen wir das Element des Arrays, das wir untersuchen möchten.  Wir greifen auf das Element mit dem Konstruktor <code>victorianSlang[i]</code> . </li><li>  Dann finden wir heraus, ob dieser Ausdruck in der Büchersammlung gefunden wird. </li><li>  Wenn ein Ausdruck in Büchern vorkommt, nehmen wir den Wert seiner Beliebtheitsbewertung und addieren ihn zum Wert der Variablen <code>popularitySum</code> . </li><li>  Gleichzeitig erhöhen wir auch den Zähler der gefundenen Ausdrücke - <code>itemsFound</code> . </li><li>  Und schließlich finden wir den Durchschnitt, indem wir <code>popularitySum</code> durch <code>itemsFound</code> . </li></ol><br>  Also haben wir die Aufgabe gemeistert.  Vielleicht war unsere Entscheidung nicht besonders schön, aber sie macht ihren Job.  Die Verwendung von Methoden zum Durchlaufen von Arrays macht es ein wenig sauberer.  Werfen wir einen Blick darauf, ob es uns gelingt, diese Entscheidung zu „bereinigen“. <br><br><h2>  <font color="#3AC1EF">2. Einfache Lösung Nr. 1: .filter (), .map () und Ermitteln der Menge mit .reduce ()</font> </h2><br>  Lassen Sie uns vor dem ersten Versuch, das Problem mit den Methoden von Arrays zu lösen, es in kleine Teile zerlegen.  Folgendes müssen wir nämlich tun: <br><br><ol><li>  Wählen Sie Objekte aus, die Ausdrücke in der Google Books-Sammlung darstellen.  Hier können Sie die Methode <code>.filter()</code> verwenden. </li><li>  Extrahieren Sie aus den Objekten die Bewertung der Popularität von Ausdrücken.  Um diese Unteraufgabe zu lösen, ist die Methode <code>.map()</code> geeignet. </li><li>  Berechnen Sie die Summe der Bewertungen.  Hier können wir auf die Hilfe unseres alten Freundes <code>.reduce()</code> . </li><li>  Und schließlich finden Sie den Durchschnittswert der Schätzungen. </li></ol><br>  So sieht es im Code aus: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//   // ---------------------------------------------------------------------------- function isFound(item) {    return item.found; }; function getPopularity(item) {    return item.popularity; } function addScores(runningTotal, popularity) {    return runningTotal + popularity; } //  // ---------------------------------------------------------------------------- //  ,      . const foundSlangTerms = victorianSlang.filter(isFound); //   ,   . const popularityScores = foundSlangTerms.map(getPopularity); //     .    ,    //   ,  reduce     ,  0. const scoresTotal = popularityScores.reduce(addScores, 0); //       . const averagePopularity = scoresTotal / popularityScores.length; console.log("Average popularity:", averagePopularity);</span></span></code> </pre> <br>  Schauen <code>addScore</code> sich die Funktion <code>addScore</code> und die Zeile an, in der <code>.reduce()</code> aufgerufen wird.  Beachten Sie, dass <code>addScore</code> zwei Parameter akzeptiert.  Das erste, <code>runningTotal</code> , wird als Batterie bezeichnet.  Es speichert die Summe der Werte.  Sein Wert ändert sich jedes Mal, wenn wir über das Array iterieren und die <code>return</code> ausführen.  Der zweite Parameter, <code>popularity</code> , ist ein separates Element des Arrays, das wir verarbeiten.  Zu Beginn der <code>addScore</code> über das Array wurde die <code>addScore</code> <code>return</code> in <code>addScore</code> nie ausgeführt.  Dies bedeutet, dass <code>runningTotal</code> noch nicht automatisch festgelegt wurde.  Daher <code>.reduce()</code> wir durch Aufrufen von <code>.reduce()</code> an diese Methode den Wert, der zu Beginn in <code>.reduce()</code> geschrieben werden muss.  Dies ist der zweite Parameter, der an <code>.reduce()</code> . <br><br>  Daher haben wir die Methoden zum Iterieren von Arrays angewendet, um das Problem zu lösen.  Die neue Version der Lösung erwies sich als viel sauberer als die vorherige.  Mit anderen Worten, die Entscheidung erwies sich als aussagekräftiger.  Wir teilen JavaScript nicht genau mit, wie die Schleife ausgeführt werden soll, sondern folgen nicht den Indizes der Elemente von Arrays.  Stattdessen deklarieren wir einfache Hilfsfunktionen von geringer Größe und kombinieren sie.  Die ganze harte Arbeit erledigen die Array-Methoden <code>.filter()</code> , <code>.map()</code> und <code>.reduce()</code> für uns.  Dieser Ansatz zur Lösung solcher Probleme ist aussagekräftiger.  Diese Array-Methoden sind viel vollständiger als die Schleife. Sie geben Auskunft über die im Code festgelegte Absicht. <br><br><h2>  <font color="#3AC1EF">3. Einfache Lösung Nr. 2: Verwenden mehrerer Batterien</font> </h2><br>  In der vorherigen Version der Lösung haben wir eine ganze Reihe von Zwischenvariablen erstellt.  Zum Beispiel <code>foundSlangTerms</code> und <code>popularityScores</code> .  In unserem Fall ist eine solche Lösung durchaus akzeptabel.  Was aber, wenn wir uns ein komplexeres Ziel für das Code-Design setzen?  Es wäre schön, wenn wir das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">fließende Interface-</a> Design-Muster im Programm verwenden könnten.  Mit diesem Ansatz könnten wir die Aufrufe aller Funktionen verketten und auf Zwischenvariablen verzichten.  Hier erwartet uns jedoch ein Problem.  Beachten Sie, dass wir den Wert von <code>popularityScores.length</code> .  Wenn wir alles verketten wollen, brauchen wir eine andere Methode, um die Anzahl der Elemente im Array zu ermitteln.  Die Anzahl der Elemente im Array spielt die Rolle eines Divisors bei der Berechnung des Durchschnittswerts.  Mal sehen, ob wir den Ansatz zur Lösung des Problems so ändern können, dass alles durch Kombinieren von Methodenaufrufen in einer Kette erledigt werden kann.  Wir werden dies tun, indem wir zwei Werte verfolgen, wenn wir über die Elemente des Arrays iterieren, dh mit der „Doppelbatterie“. <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//   // --------------------------------------------------------------------------------- function isFound(item) {    return item.found; }; function getPopularity(item) {    return item.popularity; } //    ,  return,   . function addScores({totalPopularity, itemCount}, popularity) {    return {        totalPopularity: totalPopularity + popularity,        itemCount:    itemCount + 1,    }; } //  // --------------------------------------------------------------------------------- const initialInfo  = {totalPopularity: 0, itemCount: 0}; const popularityInfo = victorianSlang.filter(isFound)    .map(getPopularity)    .reduce(addScores, initialInfo); //       . const {totalPopularity, itemCount} = popularityInfo; const averagePopularity = totalPopularity / itemCount; console.log("Average popularity:", averagePopularity);</span></span></code> </pre> <br>  Um mit zwei Werten zu arbeiten, haben wir hier das Objekt in der Reduzierungsfunktion verwendet.  Bei jedem Durchlauf durch das mit <code>addScrores</code> durchgeführte Array <code>addScrores</code> wir den Gesamtwert der Beliebtheitsbewertung und die Anzahl der Elemente.  Es ist wichtig zu beachten, dass diese beiden Werte als ein einzelnes Objekt dargestellt werden.  Mit diesem Ansatz können wir das System „austricksen“ und zwei Entitäten innerhalb desselben Rückgabewerts speichern. <br><br>  Die Funktion <code>addScrores</code> als etwas komplizierter als die Funktion mit demselben Namen im vorherigen Beispiel.  Jetzt stellt sich jedoch heraus, dass wir eine einzelne Kette von Methodenaufrufen verwenden können, um alle Operationen mit dem Array auszuführen.  Als Ergebnis der Verarbeitung des Arrays erhalten wir das Objekt popularInfo, in dem alles gespeichert ist, was Sie zum Ermitteln des Durchschnitts benötigen.  Dies macht die Anrufkette ordentlich und einfach. <br><br>  Wenn Sie den Wunsch haben, diesen Code zu verbessern, können Sie damit experimentieren.  Zum Beispiel - Sie können es wiederholen, um viele Zwischenvariablen zu entfernen.  Sie können sogar versuchen, diesen Code in eine Zeile zu setzen. <br><br><h2>  <font color="#3AC1EF">4. Zusammensetzung von Funktionen ohne Punktnotation</font> </h2><br>  Wenn Sie mit funktionaler Programmierung noch nicht vertraut sind oder wenn Ihnen die funktionale Programmierung zu kompliziert erscheint, können Sie diesen Abschnitt überspringen.  Das Parsen kommt Ihnen zugute, wenn Sie bereits mit <code>curry()</code> und <code>compose()</code> vertraut sind.  Wenn Sie sich mit diesem Thema befassen möchten, werfen Sie einen Blick auf <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">dieses</a> Material zur funktionalen Programmierung in JavaScript und insbesondere auf den <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">dritten</a> Teil der Reihe, in der es enthalten ist. <br><br>  Wir sind Programmierer, die einen funktionalen Ansatz verfolgen.  Dies bedeutet, dass wir uns bemühen, komplexe Funktionen aus anderen Funktionen aufzubauen - klein und einfach.  Bisher haben wir im Zuge der Prüfung verschiedener Optionen zur Lösung des Problems die Anzahl der Zwischenvariablen reduziert.  Infolgedessen wurde der Lösungscode immer einfacher.  Aber was ist, wenn diese Idee auf die Spitze getrieben wird?  Was ist, wenn Sie versuchen, alle Zwischenvariablen loszuwerden?  Und sogar versuchen, von einigen Parametern wegzukommen? <br><br>  Sie können eine Funktion erstellen, um den Durchschnitt nur mit der Funktion <code>compose()</code> zu berechnen, ohne Variablen zu verwenden.  Wir nennen dies "Programmierung ohne feinkörnige Notation" oder "implizite Programmierung".  Um solche Programme zu schreiben, benötigen Sie viele Hilfsfunktionen. <br><br>  Manchmal schockiert ein solcher Code Menschen.  Dies liegt an der Tatsache, dass sich ein solcher Ansatz stark von dem allgemein akzeptierten unterscheidet.  Ich fand jedoch heraus, dass das Schreiben von Code im Stil der impliziten Programmierung eine der schnellsten Methoden ist, um die Essenz der funktionalen Programmierung zu verstehen.  Daher kann ich Ihnen raten, diese Technik in einem persönlichen Projekt auszuprobieren.  Aber ich möchte sagen, dass Sie den Code, den andere Leute lesen müssen, vielleicht nicht im Stil der impliziten Programmierung schreiben sollten. <br><br>  Zurück zu unserer Aufgabe, ein System zur Berechnung von Durchschnittswerten zu konstruieren.  Um Platz zu sparen, werden wir hier auf die Verwendung von Pfeilfunktionen eingehen.  In der Regel ist es besser, benannte Funktionen zu verwenden.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Hier ist ein</a> guter Artikel zu diesem Thema.  Auf diese Weise erhalten Sie im Fehlerfall bessere Stack-Trace-Ergebnisse. <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//   // ---------------------------------------------------------------------------- const filter = p =&gt; a =&gt; a.filter(p); const map   = f =&gt; a =&gt; a.map(f); const prop  = k =&gt; x =&gt; x[k]; const reduce = r =&gt; i =&gt; a =&gt; a.reduce(r, i); const compose = (...fns) =&gt; (arg) =&gt; fns.reduceRight((arg, fn) =&gt; fn(arg), arg); //  -   "blackbird combinator". //     : https://jrsinclair.com/articles/2019/compose-js-functions-multiple-parameters/ const B1 = f =&gt; g =&gt; h =&gt; x =&gt; f(g(x))(h(x)); //  // ---------------------------------------------------------------------------- //   sum,    . const sum = reduce((a, i) =&gt; a + i)(0); //     . const length = a =&gt; a.length; //       . const div = a =&gt; b =&gt; a / b; //   compose()        . //    compose()     . const calcPopularity = compose(    B1(div)(sum)(length),    map(prop('popularity')),    filter(prop('found')), ); const averagePopularity = calcPopularity(victorianSlang); console.log("Average popularity:", averagePopularity);</span></span></code> </pre> <br>  Wenn Ihnen all dieser Code völlig unsinnig erscheint, machen Sie sich darüber keine Sorgen.  Ich habe es hier als intellektuelle Übung aufgenommen, um Sie nicht zu verärgern. <br><br>  In diesem Fall liegt die Hauptarbeit in der Funktion <code>compose()</code> .  Wenn Sie den Inhalt von unten nach oben lesen, stellt sich heraus, dass die Berechnungen damit beginnen, das Array nach der Eigenschaft der <code>found</code> Elemente zu filtern.  Dann rufen wir die <code>popularity</code> Eigenschaft mit <code>map()</code> .  Danach verwenden wir den sogenannten „ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Amselkombinator</a> “.  Diese Entität wird als Funktion <code>B1</code> , mit der zwei Berechnungsdurchläufe für einen Satz von Eingabedaten durchgeführt werden.  Schauen Sie sich zum besseren Verständnis die folgenden Beispiele an: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//   ,  , : const avg1 = B1(div)(sum)(length); const avg2 = arr =&gt; div(sum(arr))(length(arr)); const avg3 = arr =&gt; ( sum(arr) / length(arr) ); const avg4 = arr =&gt; arr.reduce((a, x) =&gt; a + x, 0) / arr.length;</span></span></code> </pre> <br>  Auch wenn Sie nichts mehr verstehen - machen Sie sich keine Sorgen.  Dies ist nur eine Demonstration, dass JavaScript auf sehr unterschiedliche Weise geschrieben werden kann.  Von diesen Merkmalen ist dies die Schönheit dieser Sprache. <br><br><h2>  <font color="#3AC1EF">5. Lösen Sie das Problem in einem Durchgang mit der Berechnung des kumulierten Durchschnittswerts</font> </h2><br>  Alle oben genannten Software-Konstrukte lösen unser Problem (einschließlich des Imperativzyklus) gut.  Diejenigen, die die <code>.reduce()</code> -Methode verwenden, haben etwas gemeinsam.  Sie basieren darauf, das Problem in kleine Fragmente zu zerlegen.  Diese Fragmente werden dann auf verschiedene Arten zusammengesetzt.  Wenn Sie diese Lösungen analysieren, stellen Sie möglicherweise fest, dass wir das Array dreimal durchlaufen.  Es besteht das Gefühl, dass es unwirksam ist.  Es wäre schön, wenn es eine Möglichkeit gäbe, das Array zu verarbeiten und das Ergebnis in einem Durchgang zurückzugeben.  Diese Methode existiert, für ihre Anwendung muss jedoch auf Mathematik zurückgegriffen werden. <br><br>  Um den Durchschnittswert für Array-Elemente in einem Durchgang zu berechnen, benötigen wir eine neue Methode.  Sie müssen einen Weg finden, um den Durchschnitt anhand des zuvor berechneten Durchschnitts und des neuen Werts zu berechnen.  Wir suchen diese Methode mit Algebra. <br><br>  Der Durchschnittswert von <code>n</code> Zahlen kann mit dieser Formel ermittelt werden: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ea8/922/a8a/ea8922a8ad59e55aa604bf01c72b55e4.png"></div><br>  Um die durchschnittlichen <code>n + 1</code> Zahlen herauszufinden, reicht dieselbe Formel aus, jedoch in einem anderen Eintrag: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/77c/ee8/a1f/77cee8a1fe717b88a55b2f2af6f222e2.png"></div><br>  Diese Formel ist dieselbe wie folgt: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/651/b3a/0ca/651b3a0caa501b140e23cbce68a96720.png"></div><br>  Und das Gleiche wie das: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f7b/e1b/da4/f7be1bda4b12343eee3dde51d80f95c0.png"></div><br>  Wenn Sie dies ein wenig konvertieren, erhalten Sie Folgendes: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/038/165/1b5/0381651b520c5136458129c1882a44af.png"></div><br>  Wenn Sie den Punkt in all dem nicht sehen, ist es in Ordnung.  Das Ergebnis all dieser Transformationen ist, dass wir mit Hilfe der letzten Formel den Durchschnittswert während eines einzelnen Durchlaufs des Arrays berechnen können.  Dazu müssen Sie den Wert des aktuellen Elements, den im vorherigen Schritt berechneten Durchschnittswert und die Anzahl der Elemente kennen.  Darüber hinaus können die meisten Berechnungen in der Reduzierfunktion durchgeführt werden: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//      // ---------------------------------------------------------------------------- function averageScores({avg, n}, slangTermInfo) {    if (!slangTermInfo.found) {        return {avg, n};       return {        avg: (slangTermInfo.popularity + n * avg) / (n + 1),        n:  n + 1,    }; } //  // ---------------------------------------------------------------------------- //       . const initialVals    = {avg: 0, n: 0}; const averagePopularity = victorianSlang.reduce(averageScores, initialVals).avg; console.log("Average popularity:", averagePopularity);</span></span></code> </pre> <br>  Dank dieses Ansatzes kann der erforderliche Wert nur einmal unter Umgehung des Arrays gefunden werden.  Andere Ansätze verwenden einen Durchgang, um das Array zu filtern, einen anderen, um die erforderlichen Daten daraus zu extrahieren, und einen anderen, um die Summe der Werte der Elemente zu ermitteln.  Hier passt alles in einen Durchgang durch das Array. <br><br>  Bitte beachten Sie, dass dies die Berechnungen nicht unbedingt effizienter macht.  Bei diesem Ansatz müssen mehr Berechnungen durchgeführt werden.  Wenn jeder neue Wert eintrifft, führen wir die Multiplikations- und Divisionsoperationen durch, um den aktuellen Durchschnittswert im aktuellen Zustand zu halten.  Bei anderen Lösungen für dieses Problem teilen wir eine Zahl nur einmal in eine andere - am Ende des Programms.  Dieser Ansatz ist jedoch in Bezug auf die Speichernutzung viel effizienter.  Zwischenarrays werden hier nicht verwendet, daher müssen wir nur ein Objekt mit zwei Werten im Speicher speichern. <br><br>         .        .     ,     .   .  ,   ,      . <br><br><h2> <font color="#3AC1EF"> ?</font> </h2><br>              ?   ,     . ,    -  . , ,      ,       .         ,       .       ,           .          ,      ,       . <br><br> ,  -     ,           .       ,         ?   .      .  —   . <br><br><h2> <font color="#3AC1EF"></font> </h2><br>         : <br><br><ol><li>   <code>.reduce()</code> . </li><li>    <code>.filter()</code>  <code>.map()</code> ,   —  <code>.reduce()</code>       . </li><li>   ,      . </li><li>     . </li><li>         . </li></ol><br>  , -,     ?    —  .      -  —     ,          : <br><br><ol><li>    ,     .      —   . </li><li>    ,    ,    —     . </li><li> , ,        —   ,     . </li></ol><br> <b> !</b>        JavaScript-? <br><br><div style="text-align:center;"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/getpro/habr/post_images/a09/9e4/5a8/a099e45a81c9dafd3a3673edd5ea415b.jpg"></a> </div></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de458030/">https://habr.com/ru/post/de458030/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de458014/index.html">FEDOR Robot - Training mit der neuen ISS-Crew und den ersten Weltraumaufgaben</a></li>
<li><a href="../de458018/index.html">Komponist vs npm: Multi-Modul-Entwicklung</a></li>
<li><a href="../de458020/index.html">Juli IT Events Digest</a></li>
<li><a href="../de458022/index.html">Fingerabdruck durch Bannerwerbung? Nun ist das üblich</a></li>
<li><a href="../de458026/index.html">Vergleich der Serialisierungsformate</a></li>
<li><a href="../de458040/index.html">Von Moskau nach Tomsk. Die Geschichte eines Zuges</a></li>
<li><a href="../de458042/index.html">Wie ich das maschinelle Lernen an der NSU organisiert habe</a></li>
<li><a href="../de458044/index.html">Informationssicherheit in der Provinz - Stagnation oder Entwicklung?</a></li>
<li><a href="../de458046/index.html">Gradle Spickzettel</a></li>
<li><a href="../de458048/index.html">Delegation als Manager-Tool</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>