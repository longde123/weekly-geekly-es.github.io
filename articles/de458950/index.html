<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üéÆ üè† üï¶ Analysieren von Async / Await in JavaScript mit Beispielen üîá üôÅ üöµ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Der Autor des Artikels analysiert Async / Await in JavaScript anhand von Beispielen. Im Allgemeinen ist Async / Await eine bequeme M√∂glichkeit, asynch...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Analysieren von Async / Await in JavaScript mit Beispielen</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/skillbox/blog/458950/"><img src="https://habrastorage.org/getpro/habr/post_images/2c8/f4a/252/2c8f4a252d33ee663665fd7df02b45ed.jpg"><br><br>  Der Autor des Artikels analysiert Async / Await in JavaScript anhand von Beispielen.  Im Allgemeinen ist Async / Await eine bequeme M√∂glichkeit, asynchronen Code zu schreiben.  Vor dieser Gelegenheit wurde ein √§hnlicher Code mit R√ºckrufen und Versprechungen geschrieben.  Der Autor des Originalartikels zeigt anhand verschiedener Beispiele die Vorteile von Async / Await auf. <br><a name="habracut"></a><br><blockquote>  <b>Wir erinnern Sie daran:</b> <i>F√ºr alle Leser von ‚ÄûHabr‚Äú - ein Rabatt von 10.000 Rubel bei der Anmeldung f√ºr einen Skillbox-Kurs mit dem Promo-Code ‚ÄûHabr‚Äú.</i> <br><br>  <b>Skillbox empfiehlt:</b> Der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Java Developer</a> Online Education-Kurs. </blockquote><br><h3>  R√ºckruf </h3><br>  R√ºckruf ist eine Funktion, deren Aufruf auf unbestimmte Zeit verz√∂gert wird.  Bisher wurden R√ºckrufe in den Teilen des Codes verwendet, in denen das Ergebnis nicht sofort abgerufen werden konnte. <br><br>  Hier ist ein Beispiel f√ºr das asynchrone Lesen einer Datei auf Node.js: <br><br><pre><code class="javascript hljs">fs.readFile(__filename, <span class="hljs-string"><span class="hljs-string">'utf-8'</span></span>, (err, data) =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (err) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> err; } <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(data); });</code> </pre> <br>  Probleme treten auf, wenn Sie mehrere asynchrone Vorg√§nge gleichzeitig ausf√ºhren m√ºssen.  Stellen wir uns dieses Szenario vor: Es wird eine Anfrage an die Arfat-Benutzerdatenbank gestellt. Sie m√ºssen das Feld profile_img_url lesen und ein Bild vom Server someserver.com herunterladen. <br>  Konvertieren Sie das Bild nach dem Herunterladen in ein anderes Format, z. B. von PNG nach JPEG.  Wenn die Konvertierung erfolgreich war, wird eine E-Mail an die E-Mail des Benutzers gesendet.  Au√üerdem werden Informationen zum Ereignis mit dem Datum in die Datei transformations.log eingegeben. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ad5/c3f/e3b/ad5c3fe3bf0f7a68a4d3444614c3133e.png"><br><br>  Es lohnt sich, im letzten Teil des Codes auf das Auferlegen von R√ºckrufen und eine gro√üe Anzahl}) zu achten.  Dies wird als Callback Hell oder Pyramid of Doom bezeichnet. <br><br>  Die Nachteile dieser Methode liegen auf der Hand: <br><br><ul><li>  Dieser Code ist schwer zu lesen. </li><li>  Es ist auch schwierig, mit Fehlern umzugehen, was h√§ufig zu einer Verschlechterung der Codequalit√§t f√ºhrt. </li></ul><br>  Um dieses Problem zu l√∂sen, wurden JavaScript Versprechen hinzugef√ºgt.  Mit ihnen k√∂nnen Sie die tiefe Verschachtelung von R√ºckrufen durch das Wort .then ersetzen. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/9e1/503/0ad/9e15030ad0dbb431a63d9f98ec228111.png"><br><br>  Der positive Punkt der Versprechen war, dass bei ihnen der Code viel besser gelesen wird, von oben nach unten und nicht von links nach rechts.  Versprechen haben aber auch ihre Probleme: <br><br><ul><li>  M√ºssen Sie eine gro√üe Menge von .then hinzuf√ºgen. </li><li>  Anstelle von try / catch wird .catch verwendet, um alle Fehler zu behandeln. </li><li>  Das Arbeiten mit mehreren Versprechungen innerhalb eines Zyklus ist bei weitem nicht immer bequem, in einigen F√§llen erschweren sie den Code. </li></ul><br>  Hier ist eine Aufgabe, die die Bedeutung des letzten Absatzes zeigt. <br><br>  Angenommen, es gibt eine for-Schleife, die eine Folge von Zahlen von 0 bis 10 mit einem zuf√§lligen Intervall (0 - n Sekunden) druckt.  Mithilfe von Versprechungen m√ºssen Sie diesen Zyklus so √§ndern, dass die Zahlen in der Reihenfolge von 0 bis 10 angezeigt werden. Wenn also die Nullausgabe 6 Sekunden und die Einheiten 2 Sekunden dauert, muss zuerst Null ausgegeben werden, und dann beginnt der Countdown f√ºr die Einheitenausgabe. <br><br>  Um dieses Problem zu l√∂sen, verwenden wir nat√ºrlich weder Async / Await noch .sort.  Ein Beispiel f√ºr eine L√∂sung ist am Ende. <br><br><h3>  Asynchrone Funktionen </h3><br>  Das Hinzuf√ºgen von asynchronen Funktionen zu ES2017 (ES8) hat die Arbeit mit Versprechungen vereinfacht.  Ich stelle fest, dass asynchrone Funktionen zus√§tzlich zu Versprechungen funktionieren.  Diese Funktionen repr√§sentieren keine qualitativ unterschiedlichen Konzepte.  Asynchrone Funktionen wurden als Alternative zu Code konzipiert, der Versprechen verwendet. <br><br>  Async / Await erm√∂glicht es, die Arbeit mit asynchronem Code synchron zu organisieren. <br><br>  Die Kenntnis von Versprechungen erleichtert somit das Verst√§ndnis der Prinzipien von Async / Await. <br><br>  <b>Syntax</b> <br><br>  In einer typischen Situation besteht es aus zwei Schl√ºsselw√∂rtern: asynchron und warten.  Das erste Wort macht die Funktion asynchron.  Diese Funktionen erm√∂glichen das Warten.  In jedem anderen Fall f√ºhrt die Verwendung dieser Funktion zu einem Fehler. <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// With function declaration async function myFn() { // await ... } // With arrow function const myFn = async () =&gt; { // await ... } function myFn() { // await fn(); (Syntax Error since no async) }</span></span></code> </pre><br>  Async wird ganz am Anfang der Funktionsdeklaration und bei der Pfeilfunktion zwischen dem Zeichen "=" und den Klammern eingef√ºgt. <br><br>  Diese Funktionen k√∂nnen als Methoden in ein Objekt eingef√ºgt oder in einer Klassendeklaration verwendet werden. <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// As an object's method const obj = { async getName() { return fetch('https://www.example.com'); } } // In a class class Obj { async getResource() { return fetch('https://www.example.com'); } }</span></span></code> </pre> <br>  NB!  Es ist zu beachten, dass Klassenkonstruktoren und Getter / Setter nicht asynchron sein k√∂nnen. <br><br>  <b>Semantik und Ausf√ºhrungsregeln</b> <br><br>  Async-Funktionen √§hneln im Wesentlichen Standard-JS-Funktionen, es gibt jedoch Ausnahmen. <br><br>  Asynchrone Funktionen geben also immer Versprechen zur√ºck: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fn</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">'hello'</span></span>; } fn().then(<span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log) <span class="hljs-comment"><span class="hljs-comment">// hello</span></span></code> </pre> <br>  Insbesondere gibt fn den String hallo zur√ºck.  Da dies eine asynchrone Funktion ist, wird der Zeichenfolgenwert mithilfe des Konstruktors in ein Versprechen eingeschlossen. <br><br>  Hier ist ein alternatives Design ohne Async: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fn</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>.resolve(<span class="hljs-string"><span class="hljs-string">'hello'</span></span>); } fn().then(<span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log); <span class="hljs-comment"><span class="hljs-comment">// hello</span></span></code> </pre> <br>  In diesem Fall erfolgt die R√ºckgabe des Versprechens "manuell".  Eine asynchrone Funktion h√ºllt sich immer in ein neues Versprechen. <br><br>  F√ºr den Fall, dass der R√ºckgabewert ein Grundelement ist, gibt die asynchrone Funktion einen Wert zur√ºck und verpackt ihn in ein Versprechen.  F√ºr den Fall, dass der R√ºckgabewert Gegenstand des Versprechens ist, wird seine L√∂sung im neuen Versprechen zur√ºckgegeben. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> p = <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>.resolve(<span class="hljs-string"><span class="hljs-string">'hello'</span></span>) p <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>; <span class="hljs-comment"><span class="hljs-comment">// true Promise.resolve(p) === p; // true</span></span></code> </pre><br>  Aber was passiert, wenn innerhalb der asynchronen Funktion ein Fehler auftritt? <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>(<span class="hljs-string"><span class="hljs-string">'bar'</span></span>); } foo().catch(<span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log);</code> </pre> <br>  Wenn es nicht verarbeitet wird, gibt foo () ein Versprechen mit einem Redject zur√ºck.  In dieser Situation gibt Promise.reject anstelle von Promise.resolve einen Fehler zur√ºck. <br><br>  Asynchrone Funktionen bei der Ausgabe geben immer Versprechen, unabh√§ngig davon, was zur√ºckgegeben wird. <br><br>  Asynchrone Funktionen werden bei jedem Warten angehalten. <br><br>  Warten wirkt sich auf Ausdr√ºcke aus.  Wenn der Ausdruck ein Versprechen ist, wird die asynchrone Funktion ausgesetzt, bis das Versprechen ausgef√ºhrt wird.  Falls der Ausdruck kein Versprechen ist, wird er √ºber Promise.resolve in ein Versprechen umgewandelt und dann beendet. <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// utility function to cause delay // and get random value const delayAndGetRandom = (ms) =&gt; { return new Promise(resolve =&gt; setTimeout( () =&gt; { const val = Math.trunc(Math.random() * 100); resolve(val); }, ms )); }; async function fn() { const a = await 9; const b = await delayAndGetRandom(1000); const c = await 5; await delayAndGetRandom(1000); return a + b * c; } // Execute fn fn().then(console.log);</span></span></code> </pre> <br>  Hier finden Sie eine Beschreibung der Funktionsweise der Funktion fn. <br><br><ul><li>  Nach dem Aufruf wird die erste Zeile von const a = await 9 konvertiert;  in const a = warte auf Promise.resolve (9); </li><li>  Nach der Verwendung von Await wird die Ausf√ºhrung der Funktion angehalten, bis sie ihren Wert erh√§lt (in der aktuellen Situation sind es 9). </li><li>  delayAndGetRandom (1000) unterbricht die Ausf√ºhrung der Funktion fn, bis sie sich selbst beendet (nach 1 Sekunde).  Dadurch wird die fn-Funktion tats√§chlich f√ºr 1 Sekunde gestoppt. </li><li>  delayAndGetRandom (1000) durch Aufl√∂sung gibt einen zuf√§lligen Wert zur√ºck, der dann der Variablen b zugewiesen wird. </li><li>  Nun, der Fall der Variablen c √§hnelt dem Fall der Variablen a.  Danach stoppt alles f√ºr eine Sekunde, aber jetzt gibt delayAndGetRandom (1000) nichts zur√ºck, da dies nicht erforderlich ist. </li><li>  Infolgedessen werden die Werte nach der Formel a + b * c berechnet.  Das Ergebnis wird mit Promise.resolve in ein Versprechen eingeschlossen und von der Funktion zur√ºckgegeben. </li></ul><br>  Diese Pausen √§hneln m√∂glicherweise Generatoren in ES6, es gibt jedoch <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Gr√ºnde daf√ºr</a> . <br><br><h3>  Wir l√∂sen das Problem </h3><br>  Nun schauen wir uns die L√∂sung f√ºr das oben erw√§hnte Problem an. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/40b/ec5/c45/40bec5c4564dfabbe1810db3d4a60c2d.png"><br><br>  Die Funktion finishMyTask verwendet Await, um auf die Ergebnisse von Vorg√§ngen wie queryDatabase, sendEmail, logTaskInFile und anderen zu warten.  Wenn wir diese Entscheidung mit dem Ort vergleichen, an dem die Versprechen verwendet wurden, werden die √Ñhnlichkeiten offensichtlich.  Trotzdem vereinfacht die Version mit Async / Await alle syntaktischen Schwierigkeiten erheblich.  In diesem Fall gibt es nicht viele R√ºckrufe und Ketten wie .then / .catch. <br><br>  Hier ist eine L√∂sung mit der Ausgabe von Zahlen, es gibt zwei M√∂glichkeiten. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> wait = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">i, ms</span></span></span><span class="hljs-function">) =&gt;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve</span></span></span><span class="hljs-function"> =&gt;</span></span> setTimeout(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> resolve(i), ms)); <span class="hljs-comment"><span class="hljs-comment">// Implementation One (Using for-loop) const printNumbers = () =&gt; new Promise((resolve) =&gt; { let pr = Promise.resolve(0); for (let i = 1; i &lt;= 10; i += 1) { pr = pr.then((val) =&gt; { console.log(val); return wait(i, Math.random() * 1000); }); } resolve(pr); }); // Implementation Two (Using Recursion) const printNumbersRecursive = () =&gt; { return Promise.resolve(0).then(function processNextPromise(i) { if (i === 10) { return undefined; } return wait(i, Math.random() * 1000).then((val) =&gt; { console.log(val); return processNextPromise(i + 1); }); }); };</span></span></code> </pre> <br>  Und hier ist eine L√∂sung mit asynchronen Funktionen. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">printNumbersUsingAsync</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">10</span></span>; i++) { <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> wait(i, <span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.random() * <span class="hljs-number"><span class="hljs-number">1000</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(i); } }</code> </pre> <br>  <b>Fehlerbehandlung</b> <br><br>  Unverarbeitete Fehler werden in abgelehnte Versprechen eingewickelt.  In asynchronen Funktionen k√∂nnen Sie jedoch das try / catch-Konstrukt verwenden, um eine synchrone Fehlerbehandlung durchzuf√ºhren. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">canRejectOrReturn</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// wait one second await new Promise(res =&gt; setTimeout(res, 1000)); // Reject with ~50% probability if (Math.random() &gt; 0.5) { throw new Error('Sorry, number too big.') } return 'perfect number'; }</span></span></code> </pre> <br>  canRejectOrReturn () ist eine asynchrone Funktion, die entweder erfolgreich ist (‚Äûperfekte Zahl‚Äú) oder mit einem Fehler fehlschl√§gt (‚ÄûEntschuldigung, Zahl zu gro√ü‚Äú). <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> canRejectOrReturn(); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (e) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">'error caught'</span></span>; } }</code> </pre> <br>  Da erwartet wird, dass canRejectOrReturn im obigen Beispiel ausgef√ºhrt wird, f√ºhrt seine eigene erfolglose Beendigung zur Ausf√ºhrung des catch-Blocks.  Infolgedessen endet die foo-Funktion entweder mit undefined (wenn im try-Block nichts zur√ºckgegeben wird) oder mit einem abgefangenen Fehler.  Infolgedessen schl√§gt diese Funktion nicht fehl, da try / catch die foo-Funktion selbst √ºbernimmt. <br><br>  Hier ist ein weiteres Beispiel: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> canRejectOrReturn(); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (e) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">'error caught'</span></span>; } }</code> </pre> <br>  Es ist zu beachten, dass im Beispiel von foo canRejectOrReturn zur√ºckgegeben wird.  Foo wird in diesem Fall entweder mit einer perfekten Zahl abgeschlossen oder es wird ein Fehlerfehler ("Entschuldigung, Nummer zu gro√ü") zur√ºckgegeben.  Der catch-Block wird niemals ausgef√ºhrt. <br><br>  Das Problem ist, dass foo das von canRejectOrReturn √ºbergebene Versprechen zur√ºckgibt.  Daher wird die L√∂sung f√ºr die Funktion foo zur L√∂sung f√ºr canRejectOrReturn.  In diesem Fall besteht der Code nur aus zwei Zeilen: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> promise = canRejectOrReturn(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> promise; }</code> </pre> <br>  Aber was passiert, wenn Sie warten und zusammen zur√ºckkehren: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> canRejectOrReturn(); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (e) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">'error caught'</span></span>; } }</code> </pre> <br>  Im obigen Code ist foo erfolgreich, wenn sowohl die perfekte Nummer als auch der Fehler abgefangen wurden.  Es wird keine Fehler geben.  Aber foo endet mit canRejectOrReturn und nicht mit undefined.  Stellen Sie dies sicher, indem Sie die Zeile return wait canRejectOrReturn () entfernen: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> value = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> canRejectOrReturn(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> value; } <span class="hljs-comment"><span class="hljs-comment">// ‚Ä¶</span></span></code> </pre> <br><h3>  H√§ufige Fehler und Fallstricke </h3><br>  In einigen F√§llen kann die Verwendung von Async / Await zu Fehlern f√ºhren. <br><br>  <b>Vergessen warten</b> <br><br>  Dies passiert ziemlich oft - vor dem Versprechen wird das Schl√ºsselwort await vergessen: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { canRejectOrReturn(); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (e) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">'caught'</span></span>; } }</code> </pre> <br>  Wie Sie sehen, gibt es im Code weder Warten noch Zur√ºck.  Daher wird foo immer mit einer undefinierten Verz√∂gerung von 1 Sekunde beendet.  Aber das Versprechen wird erf√ºllt.  Wenn es einen Fehler oder ein Redject gibt, wird UnhandledPromiseRejectionWarning aufgerufen. <br><br>  <b>Asynchrone Funktionen in R√ºckrufen</b> <br><br>  Asynchrone Funktionen werden h√§ufig in .map oder .filter als R√ºckrufe verwendet.  Ein Beispiel ist die Funktion fetchPublicReposCount (Benutzername), die die Anzahl der auf GitHub ge√∂ffneten Repositorys zur√ºckgibt.  Angenommen, es gibt drei Benutzer, deren Metriken wir ben√∂tigen.  Hier ist der Code f√ºr diese Aufgabe: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> url = <span class="hljs-string"><span class="hljs-string">'https://api.github.com/users'</span></span>; <span class="hljs-comment"><span class="hljs-comment">// Utility fn to fetch repo counts const fetchPublicReposCount = async (username) =&gt; { const response = await fetch(`${url}/${username}`); const json = await response.json(); return json['public_repos']; }</span></span></code> </pre> <br>  Wir brauchen Konten ArfatSalman, Octocat, Norvig.  F√ºhren Sie in diesem Fall Folgendes aus: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> users = [ <span class="hljs-string"><span class="hljs-string">'ArfatSalman'</span></span>, <span class="hljs-string"><span class="hljs-string">'octocat'</span></span>, <span class="hljs-string"><span class="hljs-string">'norvig'</span></span> ]; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> counts = users.map(<span class="hljs-keyword"><span class="hljs-keyword">async</span></span> username =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> count = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> fetchPublicReposCount(username); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> count; });</code> </pre> <br>  Sie sollten im .map-R√ºckruf auf Await achten.  Hier z√§hlt eine Reihe von Versprechungen. Nun, .map ist ein anonymer R√ºckruf f√ºr jeden angegebenen Benutzer. <br><br>  <b>√úberm√§√üig konsequente Nutzung von Warten</b> <br><br>  Nehmen Sie den folgenden Code als Beispiel: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fetchAllCounts</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">users</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> counts = []; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; users.length; i++) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> username = users[i]; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> count = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> fetchPublicReposCount(username); counts.push(count); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> counts; }</code> </pre> <br>  Hier wird die Repo-Nummer in die Z√§hlvariable eingef√ºgt, dann wird diese Nummer dem Z√§hlarray hinzugef√ºgt.  Das Problem mit dem Code besteht darin, dass sich alle nachfolgenden Benutzer im Standby-Modus befinden, bis die ersten Benutzerdaten vom Server eingehen.  Somit wird in einem einzigen Moment nur ein Benutzer verarbeitet. <br><br>  Wenn beispielsweise die Verarbeitung eines Benutzers etwa 300 ms dauert, ist dies f√ºr alle Benutzer bereits eine Sekunde. Die linear verbrachte Zeit h√§ngt von der Anzahl der Benutzer ab.  Da das Abrufen der Anzahl der Repos jedoch nicht voneinander abh√§ngt, k√∂nnen die Prozesse parallelisiert werden.  Dies erfordert die Arbeit mit .map und Promise.all: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fetchAllCounts</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">users</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> promises = users.map(<span class="hljs-keyword"><span class="hljs-keyword">async</span></span> username =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> count = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> fetchPublicReposCount(username); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> count; }); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>.all(promises); }</code> </pre> <br>  Promise.all am Eingang erh√§lt mit der R√ºckgabe des Versprechens eine Reihe von Versprechungen.  Der letzte nach Abschluss aller Versprechen im Array oder beim ersten Redject ist abgeschlossen.  Es kann vorkommen, dass nicht alle gleichzeitig gestartet werden. Um einen gleichzeitigen Start zu gew√§hrleisten, k√∂nnen Sie p-map verwenden. <br><br><h3>  Fazit </h3><br>  Asynchrone Funktionen werden f√ºr die Entwicklung immer wichtiger.  F√ºr die adaptive Verwendung von Async-Funktionen lohnt es sich, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow noopener noreferrer">Async-Iteratoren zu verwenden</a> .  Der JavaScript-Entwickler sollte sich damit auskennen. <br><br><blockquote>  <b>Skillbox empfiehlt:</b> <br><br><ul><li>  Praktikum <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">"Mobile Developer PRO"</a> . </li><li>  Angewandter Online-Kurs <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">"Data Analyst in Python"</a> . </li><li>  Zweij√§hriger Praktikumskurs <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">‚ÄûIch bin PRO Web Developer‚Äú</a> . </li></ul></blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de458950/">https://habr.com/ru/post/de458950/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de458936/index.html">"Es ist einfacher zu antworten als zu schweigen" - ein gro√ües Interview mit dem Vater des Transaktionsged√§chtnisses, Maurice Herlichi</a></li>
<li><a href="../de458938/index.html">C ++ 20 wird geb√ºndelt, C ++ 23 wird gestartet. Ergebnisse des Treffens in K√∂ln</a></li>
<li><a href="../de458940/index.html">Wie wir agile Tests implementiert haben</a></li>
<li><a href="../de458944/index.html">Die Einstellung eines Mitarbeiters beginnt mit ... Respekt. Wir werden den Ingenieur interviewen</a></li>
<li><a href="../de458948/index.html">Habr Weekly # 8 / Yandex Sorcerers, ein Buch √ºber Prince of Persia, YouTube gegen Hacker, den "Herz" -Laser des Pentagon</a></li>
<li><a href="../de458952/index.html">Optimieren der PostgreSQL-Einstellungen zur Optimierung der Leistung</a></li>
<li><a href="../de458954/index.html">Welche Arten der Erkennung sind bei der Video√ºberwachung n√ºtzlich? Mechanismen und Funktionen</a></li>
<li><a href="../de458956/index.html">Maschinelles Lernen vs. analytischer Ansatz</a></li>
<li><a href="../de458960/index.html">Unternehmensquest</a></li>
<li><a href="../de458962/index.html">Bild in Ton umwandeln - was k√∂nnen Sie h√∂ren?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>