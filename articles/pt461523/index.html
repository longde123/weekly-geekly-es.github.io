<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë®‚Äç‚ù§Ô∏è‚Äçüíã‚Äçüë® ü§ì ‚ÜòÔ∏è WAL no PostgreSQL: 4. Configura√ß√£o do log ü§î üêä üë®üèº‚ÄçüöÄ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Assim, nos familiarizamos com o dispositivo do cache de buffer e, usando seu exemplo, percebemos que quando o conte√∫do da RAM desaparece em caso de fa...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>WAL no PostgreSQL: 4. Configura√ß√£o do log</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/postgrespro/blog/461523/">  Assim, nos familiarizamos com o dispositivo do <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">cache de buffer</a> e, usando seu exemplo, percebemos que quando o conte√∫do da RAM desaparece em caso de falha, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">√©</a> necess√°rio um <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">log de pr√©-registro</a> para recupera√ß√£o.  O tamanho dos arquivos de log necess√°rios e o tempo de recupera√ß√£o s√£o limitados devido a um <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">ponto de verifica√ß√£o</a> executado periodicamente. <br><br>  Nos artigos anteriores, j√° examinamos um n√∫mero bastante grande de configura√ß√µes importantes relacionadas ao peri√≥dico, de uma maneira ou de outra.  Neste artigo (o √∫ltimo desta s√©rie), consideraremos os problemas de ajuste que ainda n√£o foram discutidos: n√≠veis de log e sua finalidade, bem como a confiabilidade e o desempenho do log. <br><br><h1>  N√≠veis de log </h1><br>  O objetivo principal do log de pr√©-registro √© fornecer a capacidade de recuperar-se de uma falha.  Por√©m, se voc√™ ainda precisar manter um di√°rio, ele poder√° ser adaptado para outras tarefas, adicionando uma certa quantidade de informa√ß√µes adicionais a ele.  Existem v√°rios n√≠veis de log.  Eles s√£o definidos pelo par√¢metro <em>wal_level</em> e s√£o organizados de modo que o log de cada pr√≥ximo n√≠vel inclua tudo o que cai no log do n√≠vel anterior, al√©m de outra coisa nova. <br><a name="habracut"></a><br><h2>  M√≠nimo </h2><br>  O n√≠vel m√≠nimo poss√≠vel √© definido pelo valor <em>wal_level</em> = minimal e garante apenas a recupera√ß√£o ap√≥s uma falha.  Para economizar espa√ßo, as opera√ß√µes relacionadas ao processamento de dados em massa (como CREATE TABLE AS SELECT ou CREATE INDEX) n√£o s√£o registradas.  Em vez disso, os dados necess√°rios s√£o gravados imediatamente no disco e um novo objeto √© adicionado ao diret√≥rio do sistema e fica vis√≠vel quando a transa√ß√£o √© confirmada.  Se ocorrer uma falha durante a opera√ß√£o, os dados j√° registrados permanecem invis√≠veis e n√£o violam a consist√™ncia.  Se a falha ocorrer ap√≥s a conclus√£o da opera√ß√£o, todo o necess√°rio j√° foi para o disco e n√£o precisar√° ser registrado. <br><br>  Vamos ver  Primeiro, defina o n√≠vel necess√°rio (para isso, voc√™ tamb√©m precisar√° alterar outro par√¢metro - <em>max_wal_senders</em> ). <br><br><pre><code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">ALTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SYSTEM</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> wal_level = minimal; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">ALTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SYSTEM</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> max_wal_senders = <span class="hljs-number"><span class="hljs-number">0</span></span>;</code> </pre> <br><pre> <code class="plaintext hljs">student$ sudo pg_ctlcluster 11 main restart</code> </pre><br>  Observe que alterar o n√≠vel requer uma reinicializa√ß√£o do servidor. <br><br>  Lembre-se da posi√ß√£o atual no log: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_current_wal_insert_lsn();</code> </pre><pre> <code class="plaintext hljs"> pg_current_wal_insert_lsn --------------------------- 0/353927BC (1 row)</code> </pre><br>  Agora vamos criar a tabela (CREATE TABLE AS SELECT) e escrever a posi√ß√£o no log novamente.  A quantidade de dados selecionados pela instru√ß√£o SELECT n√£o importa neste caso, portanto, nos limitaremos a uma linha. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> wallevel <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> n; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_current_wal_insert_lsn();</code> </pre><pre> <code class="plaintext hljs"> pg_current_wal_insert_lsn --------------------------- 0/353A7DFC (1 row)</code> </pre><br>  Com o familiar utilit√°rio pg_waldump, vejamos as entradas de log. <br><br><pre> <code class="plaintext hljs">postgres$ /usr/lib/postgresql/11/bin/pg_waldump -p /var/lib/postgresql/11/main/pg_wal -s 0/353927BC -e 0/353A7DFC</code> </pre><br>  Alguns detalhes, √© claro, podem diferir de lan√ßamento para lan√ßamento, mas, neste caso, foi o que aconteceu.  A entrada do gerenciador Heap2 refere-se √† limpeza; aqui est√° uma limpeza na p√°gina de uma das tabelas no cat√°logo do sistema (os objetos do sistema s√£o facilmente distinguidos a olho nu pelo n√∫mero ‚Äúcurto‚Äù em rel): <br><br><pre> <code class="plaintext hljs">rmgr: Heap2 len (rec/tot): 59/ 7587, tx: 0, lsn: 0/353927BC, prev 0/35392788, desc: CLEAN remxid 101126, blkref #0: rel 1663/16386/1247 blk 8 FPW</code> </pre><br>  Depois, h√° um registro sobre como obter o pr√≥ximo OID da tabela que vamos criar: <br><br><pre> <code class="plaintext hljs">rmgr: XLOG len (rec/tot): 30/ 30, tx: 0, lsn: 0/35394574, prev 0/353927BC, desc: NEXTOID 82295</code> </pre><br>  Agora, a cria√ß√£o real da tabela: <br><br><pre> <code class="plaintext hljs">rmgr: Storage len (rec/tot): 42/ 42, tx: 0, lsn: 0/35394594, prev 0/35394574, desc: CREATE base/16386/74103</code> </pre><br>  No entanto, a inser√ß√£o de dados em uma tabela n√£o √© registrada.  Existem in√∫meras entradas sobre a inser√ß√£o de linhas em diferentes tabelas e √≠ndices - este PostgreSQL registra a tabela criada no diret√≥rio do sistema (eu a dou de forma abreviada): <br><br><pre> <code class="plaintext hljs">rmgr: Heap len (rec/tot): 203/ 203, tx: 101127, lsn: 0/353945C0, prev 0/35394594, desc: INSERT off 71, blkref #0: rel 1663/16386/1247 blk 8 rmgr: Btree len (rec/tot): 53/ 685, tx: 101127, lsn: 0/3539468C, prev 0/353945C0, desc: INSERT_LEAF off 37, blkref #0: rel 1663/16386/2703 blk 2 FPW ... rmgr: Btree len (rec/tot): 53/ 2393, tx: 101127, lsn: 0/353A747C, prev 0/353A6788, desc: INSERT_LEAF off 10, blkref #0: rel 1664/0/1233 blk 1 FPW</code> </pre><br>  E, finalmente, a fixa√ß√£o da transa√ß√£o: <br><br><pre> <code class="plaintext hljs">rmgr: Transaction len (rec/tot): 34/ 34, tx: 101127, lsn: 0/353A7DD8, prev 0/353A747C, desc: COMMIT 2019-07-23 18:59:34.923124 MSK</code> </pre><br><h2>  R√©plica </h2><br>  Quando restauramos o sistema a partir do backup, come√ßamos a partir de algum estado do sistema de arquivos e, gradualmente, levamos os dados ao ponto de recupera√ß√£o, reproduzindo as entradas de di√°rio arquivadas.  O n√∫mero desses registros pode ser muito grande (por exemplo, v√°rios dias), ou seja, o per√≠odo de recupera√ß√£o cobrir√° n√£o um ponto de controle, mas muitos.  Portanto, √© claro que o n√≠vel m√≠nimo do log n√£o √© suficiente - se alguma opera√ß√£o n√£o for registrada, simplesmente n√£o saberemos que ela precisa ser repetida.  Para restaurar de um backup, <em>todas as</em> opera√ß√µes devem ser registradas. <br><br>  O mesmo se aplica √† replica√ß√£o - qualquer coisa que n√£o seja registrada n√£o ser√° transferida para a r√©plica e n√£o ser√° reproduzida.  Mas, se queremos executar solicita√ß√µes em uma r√©plica, ainda √© complicado. <br><br>  Primeiro, precisamos de informa√ß√µes sobre bloqueios exclusivos que ocorrem no servidor principal, pois eles podem entrar em conflito com solicita√ß√µes na r√©plica.  Esses bloqueios s√£o registrados e aplicados na r√©plica (em nome do processo de inicializa√ß√£o). <br><br>  Em segundo lugar, voc√™ precisa criar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">instant√¢neos de dados</a> e, para isso, como lembramos, s√£o necess√°rias informa√ß√µes sobre transa√ß√µes em andamento.  No caso de uma r√©plica, estamos falando n√£o apenas de transa√ß√µes locais, mas tamb√©m de transa√ß√µes no servidor principal.  A √∫nica maneira de transmitir essas informa√ß√µes √© grav√°-las periodicamente no log (isso acontece a cada 15 segundos). <br><br>  O n√≠vel do log, que garante a capacidade de recuperar de um backup e a possibilidade de replica√ß√£o f√≠sica, √© definido pelo valor wal_level = <em>replica</em> .  (Antes da vers√£o 9.6, havia dois n√≠veis separados de archive e hot_standby, mas eles eram combinados em um comum.) <br><br>  Come√ßando com o PostgreSQL 10, √© esse n√≠vel que √© definido por padr√£o (e antes disso era m√≠nimo).  Portanto, basta redefinir os par√¢metros para os valores padr√£o: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">ALTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SYSTEM</span></span> <span class="hljs-keyword"><span class="hljs-keyword">RESET</span></span> wal_level; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">ALTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SYSTEM</span></span> <span class="hljs-keyword"><span class="hljs-keyword">RESET</span></span> max_wal_senders;</code> </pre><br><pre> <code class="plaintext hljs">student$ sudo pg_ctlcluster 11 main restart</code> </pre><br>  Exclu√≠mos a tabela e repetimos exatamente a mesma sequ√™ncia de a√ß√µes da √∫ltima vez: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">DROP</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> wallevel; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_current_wal_insert_lsn();</code> </pre><pre> <code class="plaintext hljs"> pg_current_wal_insert_lsn --------------------------- 0/353AF21C (1 row)</code> </pre><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> wallevel <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> n; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_current_wal_insert_lsn();</code> </pre><pre> <code class="plaintext hljs"> pg_current_wal_insert_lsn --------------------------- 0/353BE51C (1 row)</code> </pre><br>  Agora verifique os lan√ßamentos no di√°rio. <br><br><pre> <code class="plaintext hljs">postgres$ /usr/lib/postgresql/11/bin/pg_waldump -p /var/lib/postgresql/11/main/pg_wal -s 0/353AF21C -e 0/353BE51C</code> </pre><br>  Limpando, obtendo OID, criando uma tabela e registrando-se no diret√≥rio do sistema - por enquanto, tudo est√° como estava: <br><br><pre> <code class="plaintext hljs">rmgr: Heap2 len (rec/tot): 58/ 58, tx: 0, lsn: 0/353AF21C, prev 0/353AF044, desc: CLEAN remxid 101128, blkref #0: rel 1663/16386/1247 blk 8 rmgr: XLOG len (rec/tot): 30/ 30, tx: 0, lsn: 0/353AF258, prev 0/353AF21C, desc: NEXTOID 82298 rmgr: Storage len (rec/tot): 42/ 42, tx: 0, lsn: 0/353AF278, prev 0/353AF258, desc: CREATE base/16386/74106 rmgr: Heap len (rec/tot): 203/ 203, tx: 101129, lsn: 0/353AF2A4, prev 0/353AF278, desc: INSERT off 73, blkref #0: rel 1663/16386/1247 blk 8 rmgr: Btree len (rec/tot): 53/ 717, tx: 101129, lsn: 0/353AF370, prev 0/353AF2A4, ‚Ä¶ rmgr: Btree len (rec/tot): 53/ 2413, tx: 101129, lsn: 0/353BD954, prev 0/353BCC44, desc: INSERT_LEAF off 10, blkref #0: rel 1664/0/1233 blk 1 FPW</code> </pre><br>  Mas algo novo.  O registro de um bloqueio exclusivo relacionado ao gerenciador de espera - neste caso, est√° bloqueando o n√∫mero da transa√ß√£o (por que √© necess√°rio, falaremos detalhadamente na pr√≥xima s√©rie de artigos): <br><br><pre> <code class="plaintext hljs">rmgr: Standby len (rec/tot): 42/ 42, tx: 101129, lsn: 0/353BE2D8, prev 0/353BD954, desc: LOCK xid 101129 db 16386 rel 74106</code> </pre><br>  E este √© um registro sobre a inser√ß√£o de linhas em nossa tabela (compare o n√∫mero do arquivo rel com o indicado acima no registro CREATE): <br><br><pre> <code class="plaintext hljs">rmgr: Heap len (rec/tot): 59/ 59, tx: 101129, lsn: 0/353BE304, prev 0/353BE2D8, desc: INSERT+INIT off 1, blkref #0: rel 1663/16386/74106 blk 0</code> </pre><br>  Confirmar registro: <br><br><pre> <code class="plaintext hljs">rmgr: Transaction len (rec/tot): 421/ 421, tx: 101129, lsn: 0/353BE340, prev 0/353BE304, desc: COMMIT 2019-07-23 18:59:37.870333 MSK; inval msgs: catcache 74 catcache 73 catcache 74 catcache 73 catcache 50 catcache 49 catcache 7 catcache 6 catcache 7 catcache 6 catcache 7 catcache 6 catcache 7 catcache 6 catcache 7 catcache 6 catcache 7 catcache 6 catcache 7 catcache 6 snapshot 2608 relcache 74106 snapshot 1214</code> </pre><br>  E outro registro, que ocorre periodicamente e n√£o est√° vinculado √† transa√ß√£o conclu√≠da, refere-se ao gerente em espera e relata as transa√ß√µes atualmente em andamento: <br><br><pre> <code class="plaintext hljs">rmgr: Standby len (rec/tot): 50/ 50, tx: 0, lsn: 0/353BE4E8, prev 0/353BE340, desc: RUNNING_XACTS nextXid 101130 latestCompletedXid 101129 oldestRunningXid 101130</code> </pre><br><h2>  Logical </h2><br>  Finalmente, o √∫ltimo n√≠vel √© definido pelo valor do par√¢metro <em>wal_level</em> = <em>logic</em> e fornece a possibilidade de decodifica√ß√£o l√≥gica e replica√ß√£o l√≥gica.  Ele deve estar ativado no servidor de publica√ß√£o. <br><br>  Do ponto de vista das entradas no di√°rio, esse n√≠vel √© praticamente diferente da r√©plica - s√£o adicionados registros relacionados √†s origens da replica√ß√£o e entradas l√≥gicas arbitr√°rias que podem ser adicionadas ao log do aplicativo.  Basicamente, a decodifica√ß√£o l√≥gica depende de informa√ß√µes sobre transa√ß√µes em andamento, pois √© necess√°rio criar uma captura instant√¢nea de dados para rastrear altera√ß√µes no cat√°logo do sistema. <br><br>  Agora, n√£o entraremos em detalhes da opera√ß√£o de backup e replica√ß√£o - este √© um t√≥pico importante para uma s√©rie separada de artigos. <br><br><h1>  Grave confiabilidade </h1><br>  √â claro que o mecanismo de registro no di√°rio deve ser confi√°vel e fornecer garantias da possibilidade de recupera√ß√£o em qualquer situa√ß√£o (obviamente n√£o relacionada a danos ao suporte de dados).  A confiabilidade √© influenciada por muitos fatores, dos quais consideraremos cache, corrup√ß√£o de dados e atomicidade das grava√ß√µes. <br><br><h2>  Armazenamento em cache </h2><br>  Existem v√°rios caches no caminho de dados para o armazenamento n√£o vol√°til (como uma unidade de disco r√≠gido). <br><br>  Quando um programa (qualquer, mas no nosso caso o PostgreSQL) solicita que o sistema operacional grave algo no disco, o sistema operacional transfere os dados para o cache na RAM.  A grava√ß√£o real ocorre de forma ass√≠ncrona, dependendo das configura√ß√µes do agendador de E / S do sistema operacional. <br><br>  Quando o sistema operacional decide gravar dados, eles caem no cache da unidade (disco r√≠gido).  A eletr√¥nica do inversor tamb√©m pode atrasar a grava√ß√£o, por exemplo, a coleta de dados em grupos que s√£o mais lucrativos para gravar ao mesmo tempo.  E se um controlador RAID for usado, outro n√≠vel de cache aparecer√° entre o SO e a unidade. <br><br>  Portanto, se voc√™ n√£o tomar medidas especiais, n√£o ser√° totalmente claro quando os dados ser√£o realmente armazenados com seguran√ßa.  Isso geralmente n√£o √© importante, mas h√° locais cr√≠ticos onde o PostgreSQL precisa ter certeza de que os dados sejam gravados com seguran√ßa.  Antes de tudo, trata-se de registro no di√°rio (se a entrada do di√°rio n√£o atingir o disco, ela desaparecer√° junto com o restante do conte√∫do da RAM) e um ponto de verifica√ß√£o (deve-se garantir que as p√°ginas sujas sejam realmente gravadas no disco).  Mas existem outras situa√ß√µes, por exemplo, a execu√ß√£o de opera√ß√µes n√£o registradas no di√°rio no n√≠vel m√≠nimo, etc. <br><br>  O sistema operacional fornece ferramentas que devem garantir a grava√ß√£o imediata dos dados na mem√≥ria n√£o vol√°til.  Existem v√°rias op√ß√µes, mas elas se resumem a duas principais: um comando de sincroniza√ß√£o √© dado ap√≥s a grava√ß√£o (fsync, fdatasync) ou ao abrir um arquivo (ou grav√°-lo), um sinalizador especial √© indicado para sincroniza√ß√£o ou mesmo grava√ß√£o direta, ignorando o cache do SO. <br><br>  Quanto ao log, o utilit√°rio pg_test_fsync permite escolher o m√©todo mais adequado para um sistema operacional espec√≠fico e um sistema de arquivos espec√≠fico, e ele √© instalado no par√¢metro de configura√ß√£o <em>wal_sync_method</em> .  Arquivos regulares s√£o sempre sincronizados usando o fsync. <br><br>  O ponto sutil √© que, ao escolher um m√©todo, as caracter√≠sticas do equipamento devem ser levadas em considera√ß√£o.  Por exemplo, se voc√™ usar um controlador suportado por uma bateria de reserva, n√£o h√° motivo para n√£o usar seu cache, pois a bateria salvar√° os dados no caso de uma falta de energia. <br><br><blockquote>  A documenta√ß√£o cont√©m <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">muitos detalhes</a> sobre este assunto. <br></blockquote><br>  De qualquer forma, a sincroniza√ß√£o √© cara e ocorre com mais freq√º√™ncia do que o absolutamente necess√°rio (retornaremos a esse problema um pouco mais baixo quando falarmos sobre desempenho). <br><br>  De um modo geral, a sincroniza√ß√£o pode ser desativada (o par√¢metro <em>fsync</em> √© respons√°vel por isso), mas, nesse caso, voc√™ deve esquecer a confiabilidade do armazenamento.  Ao desativar o <em>fsync</em> , voc√™ concorda que os dados podem ser irremediavelmente perdidos a qualquer momento.  Provavelmente, a √∫nica op√ß√£o razo√°vel para usar essa op√ß√£o √© aumentar temporariamente a produtividade, quando os dados podem ser facilmente restaurados de outra fonte (por exemplo, durante a migra√ß√£o inicial). <br><br><h2>  Corrup√ß√£o de dados </h2><br>  O equipamento √© imperfeito e os dados podem ser danificados na m√≠dia ao transmitir dados por cabos de interface, etc. Alguns desses erros s√£o processados ‚Äã‚Äãno n√≠vel do hardware, mas outros n√£o. <br><br>  Para detectar o problema a tempo, as entradas do di√°rio s√£o sempre fornecidas com somas de verifica√ß√£o. <br><br>  As p√°ginas de dados tamb√©m podem ser protegidas com somas de verifica√ß√£o.  Por enquanto, isso s√≥ pode ser feito quando o cluster √© inicializado, mas no PostgreSQL 12 ser√° poss√≠vel ativ√°-lo e desativ√°-lo usando o utilit√°rio pg_checksums (embora ainda n√£o esteja em andamento, mas apenas quando o servidor estiver parado). <br><br>  Em um ambiente de produ√ß√£o, as somas de verifica√ß√£o devem ser inclu√≠das, apesar da sobrecarga de seu c√°lculo e controle.  Isso reduz a probabilidade de uma falha n√£o ser detectada a tempo. <br><br><blockquote>  Reduz, mas n√£o elimina. <br>  Em primeiro lugar, as somas de verifica√ß√£o s√£o verificadas apenas ao acessar a p√°gina - portanto, os danos podem passar despercebidos at√© que entrem em todos os backups.  √â por isso que o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">pg_probackup</a> verifica somas de verifica√ß√£o de todas as p√°ginas do cluster durante o backup. <br>  Em segundo lugar, uma p√°gina cheia de zeros √© considerada correta - se o sistema de arquivos "anular" por engano, isso pode passar despercebido. <br>  Em terceiro lugar, as somas de verifica√ß√£o protegem apenas a camada principal dos arquivos de dados.  As camadas restantes e outros arquivos (por exemplo, status de transa√ß√£o XACT) n√£o s√£o protegidos por nada. <br>  Infelizmente. <br></blockquote><br>  Vamos ver como isso funciona.  Primeiro, verifique se as somas de verifica√ß√£o est√£o ativadas (lembre-se de que este n√£o √© o caso ao instalar um pacote em sistemas semelhantes ao Debian): <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SHOW</span></span> data_checksums;</code> </pre><pre> <code class="plaintext hljs"> data_checksums ---------------- on (1 row)</code> </pre><br>  O par√¢metro <em>data_checksums</em> √© somente leitura. <br><br>  Aqui est√° o arquivo em que nossa tabela est√° localizada: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_relation_filepath(<span class="hljs-string"><span class="hljs-string">'wallevel'</span></span>);</code> </pre><pre> <code class="plaintext hljs"> pg_relation_filepath ---------------------- base/16386/24890 (1 row)</code> </pre><br>  Pare o servidor e altere alguns bytes na p√°gina zero, por exemplo, exclua a √∫ltima entrada do log do cabe√ßalho LSN. <br><br><pre> <code class="plaintext hljs">student$ sudo pg_ctlcluster 11 main stop</code> </pre><br><pre> <code class="plaintext hljs">postgres$ dd if=/dev/zero of=/var/lib/postgresql/11/main/base/16386/24890 oflag=dsync conv=notrunc bs=1 count=8</code> </pre><pre> <code class="plaintext hljs">8+0 records in 8+0 records out 8 bytes copied, 0,0083022 s, 1,0 kB/s</code> </pre><br>  Em princ√≠pio, o servidor n√£o p√¥de ser parado.  Basta que a p√°gina tenha sido gravada em disco e for√ßada a sair do cache (caso contr√°rio, o servidor funcionar√° com a p√°gina a partir do cache).  Mas esse cen√°rio √© mais dif√≠cil de reproduzir. <br><br>  Agora, iniciamos o servidor e tentamos ler a tabela. <br><br><pre> <code class="plaintext hljs">student$ sudo pg_ctlcluster 11 main start</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> wallevel;</code> </pre><pre> <code class="plaintext hljs">WARNING: page verification failed, calculated checksum 23222 but expected 50884 ERROR: invalid page in block 0 of relation base/16386/24890</code> </pre><br>  Mas e se os dados n√£o puderem ser restaurados a partir do backup?  O par√¢metro <em>ignore_checksum_failure</em> permite que <em>voc√™</em> tente ler a tabela, naturalmente com o risco de obter dados distorcidos. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> ignore_checksum_failure = <span class="hljs-keyword"><span class="hljs-keyword">on</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> wallevel;</code> </pre><pre> <code class="plaintext hljs">WARNING: page verification failed, calculated checksum 23222 but expected 50884 n --- 1 (1 row)</code> </pre><br>  √â claro que, neste caso, tudo corre bem, porque confundimos apenas o t√≠tulo da p√°gina, e n√£o os dados em si. <br><br>  E mais uma coisa.  Quando as somas de verifica√ß√£o s√£o ativadas, bits de avisos s√£o gravados no log (n√≥s os <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">examinamos</a> anteriormente), pois uma altera√ß√£o em qualquer bit, mesmo que n√£o seja essencial, tamb√©m leva a uma altera√ß√£o na soma de verifica√ß√£o.  Quando as somas de verifica√ß√£o est√£o desativadas, o par√¢metro <em>wal_log_hints</em> √© respons√°vel por gravar bits de dica no <em>log</em> . <br><br>  As altera√ß√µes nos bits da dica de ferramenta s√£o sempre registradas como uma <em>imagem de p√°gina inteira</em> (FPI, imagem de p√°gina inteira), o que aumenta o tamanho do log na ordem.  Nesse caso, faz sentido habilitar a compacta√ß√£o de imagens completas usando o par√¢metro <em>wal_compression</em> (esse par√¢metro apareceu na vers√£o 9.5).  Abaixo, examinamos n√∫meros espec√≠ficos. <br><br><h2>  Registro de atomicidade </h2><br>  E, finalmente, h√° o problema de atomicidade do registro.  A p√°gina do banco de dados ocupa pelo menos 8 KB (pode ser 16 ou 32 KB) e, em um n√≠vel baixo, a grava√ß√£o ocorre em blocos geralmente menores (geralmente 512 bytes ou 4 KB).  Portanto, no caso de falta de energia, a p√°gina de dados pode ser parcialmente registrada.  √â claro que, durante a recupera√ß√£o, n√£o faz sentido aplicar lan√ßamentos cont√°beis comuns a essa p√°gina. <br><br>  Para prote√ß√£o, o PostgreSQL permite gravar no log a <em>imagem completa da p√°gina</em> quando ela √© alterada pela primeira vez ap√≥s o in√≠cio do ponto de verifica√ß√£o (a mesma imagem √© gravada quando os bits da dica de ferramenta s√£o alterados).  O par√¢metro <em>full_page_writes controla isso</em> e √© ativado por padr√£o. <br><br>  Se uma imagem da p√°gina √© encontrada durante a recupera√ß√£o em um log, ela √© gravada incondicionalmente (sem verifica√ß√£o de LSN) no disco: h√° mais confian√ßa nela, porque, como qualquer registro de log, ela √© protegida por uma soma de verifica√ß√£o.  E j√° s√£o aplicados lan√ßamentos regulares a essa imagem correta garantida. <br><br>  Embora o PostgreSQL exclua espa√ßo n√£o alocado da imagem da p√°gina inteira ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">examinamos</a> anteriormente a estrutura do bloco), o volume de lan√ßamentos gerados no di√°rio aumenta significativamente.  Como j√° mencionado, a situa√ß√£o pode ser melhorada compactando as imagens completas (par√¢metro <em>wal_compression</em> ). <br><br>  Para sentir de alguma forma a mudan√ßa no tamanho do log, realizaremos um experimento simples usando o utilit√°rio pgbench.  Vamos inicializar: <br><br><pre> <code class="plaintext hljs">student$ pgbench -i test</code> </pre><pre> <code class="plaintext hljs">dropping old tables... creating tables... generating data... 100000 of 100000 tuples (100%) done (elapsed 0.15 s, remaining 0.00 s) vacuuming... creating primary keys... done.</code> </pre><br>  A <em>op√ß√£o full_page_writes est√°</em> ativada: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SHOW</span></span> full_page_writes;</code> </pre><pre> <code class="plaintext hljs"> full_page_writes ------------------ on (1 row)</code> </pre><br>  Execute o ponto de interrup√ß√£o e execute imediatamente o teste por 30 segundos. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">CHECKPOINT</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_current_wal_insert_lsn();</code> </pre><pre> <code class="plaintext hljs"> pg_current_wal_insert_lsn --------------------------- 0/38E04A08 (1 row)</code> </pre><br><pre> <code class="plaintext hljs">student$ pgbench -T 30 test</code> </pre><pre> <code class="plaintext hljs">starting vacuum...end. transaction type: &lt;builtin: TPC-B (sort of)&gt; scaling factor: 1 query mode: simple number of clients: 1 number of threads: 1 duration: 30 s number of transactions actually processed: 26851 latency average = 1.117 ms tps = 895.006720 (including connections establishing) tps = 895.095229 (excluding connections establishing)</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_current_wal_insert_lsn();</code> </pre><pre> <code class="plaintext hljs"> pg_current_wal_insert_lsn --------------------------- 0/3A69C478 (1 row)</code> </pre><br>  Tamanho do registro: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_size_pretty(<span class="hljs-string"><span class="hljs-string">'0/3A69C478'</span></span>::pg_lsn - <span class="hljs-string"><span class="hljs-string">'0/38E04A08'</span></span>::pg_lsn);</code> </pre><pre> <code class="plaintext hljs"> pg_size_pretty ---------------- 25 MB (1 row)</code> </pre><br>  Agora desative o par√¢metro full_page_writes: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">ALTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SYSTEM</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> full_page_writes = <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_reload_conf();</code> </pre><br>  E repita o experimento. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">CHECKPOINT</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_current_wal_insert_lsn();</code> </pre><pre> <code class="plaintext hljs"> pg_current_wal_insert_lsn --------------------------- 0/3A69C530 (1 row)</code> </pre><br><pre> <code class="plaintext hljs">student$ pgbench -T 30 test</code> </pre><pre> <code class="plaintext hljs">starting vacuum...end. transaction type: &lt;builtin: TPC-B (sort of)&gt; scaling factor: 1 query mode: simple number of clients: 1 number of threads: 1 duration: 30 s number of transactions actually processed: 27234 latency average = 1.102 ms tps = 907.783080 (including connections establishing) tps = 907.895326 (excluding connections establishing)</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_current_wal_insert_lsn();</code> </pre><pre> <code class="plaintext hljs"> pg_current_wal_insert_lsn --------------------------- 0/3BE87658 (1 row)</code> </pre><br>  Tamanho do registro: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_size_pretty(<span class="hljs-string"><span class="hljs-string">'0/3BE87658'</span></span>::pg_lsn - <span class="hljs-string"><span class="hljs-string">'0/3A69C530'</span></span>::pg_lsn);</code> </pre><pre> <code class="plaintext hljs"> pg_size_pretty ---------------- 24 MB (1 row)</code> </pre><br>  Sim, o tamanho diminuiu, mas n√£o √© t√£o significativo quanto se poderia esperar. <br><br>  O motivo √© que o cluster √© inicializado com somas de verifica√ß√£o nas p√°ginas de dados e, portanto, voc√™ ainda precisa gravar imagens de p√°gina inteira no log ao alterar os bits da dica de ferramenta.  Esses dados (no nosso caso) comp√µem cerca de metade do volume total, o que pode ser visto observando as estat√≠sticas: <br><br><pre> <code class="plaintext hljs">postgres$ /usr/lib/postgresql/11/bin/pg_waldump --stats -p /var/lib/postgresql/11/main/pg_wal -s 0/3A69C530 -e 0/3BE87658</code> </pre><pre> <code class="plaintext hljs">Type N (%) Record size (%) FPI size (%) ---- - --- ----------- --- -------- --- XLOG 1721 ( 1,03) 84329 ( 0,77) 13916104 (100,00) Transaction 27235 ( 16,32) 926070 ( 8,46) 0 ( 0,00) Storage 1 ( 0,00) 42 ( 0,00) 0 ( 0,00) CLOG 1 ( 0,00) 30 ( 0,00) 0 ( 0,00) Standby 4 ( 0,00) 240 ( 0,00) 0 ( 0,00) Heap2 27522 ( 16,49) 1726352 ( 15,76) 0 ( 0,00) Heap 109691 ( 65,71) 8169121 ( 74,59) 0 ( 0,00) Btree 756 ( 0,45) 45380 ( 0,41) 0 ( 0,00) -------- -------- -------- Total 166931 10951564 [44,04%] 13916104 [55,96%]</code> </pre><br>  Para compactar, removi as zero linhas da tabela.  Preste aten√ß√£o √† linha total (Total) e compare o tamanho das imagens completas (tamanho do FPI) com o tamanho dos registros comuns (tamanho do registro). <br><br>  O par√¢metro <em>full_page_writes</em> pode ser desativado apenas se o sistema de arquivos e o hardware usados ‚Äã‚Äãpor eles mesmos garantirem a grava√ß√£o at√¥mica.  Mas, como podemos ver, n√£o h√° grandes raz√µes para isso (assumindo que as somas de verifica√ß√£o est√£o inclu√≠das). <br><br>  Agora vamos ver como a compacta√ß√£o ajuda. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">ALTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SYSTEM</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> full_page_writes = <span class="hljs-keyword"><span class="hljs-keyword">on</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">ALTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SYSTEM</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> wal_compression = <span class="hljs-keyword"><span class="hljs-keyword">on</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_reload_conf();</code> </pre><br>  Repita o mesmo experimento. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">CHECKPOINT</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_current_wal_insert_lsn();</code> </pre><pre> <code class="plaintext hljs"> pg_current_wal_insert_lsn --------------------------- 0/3BE87710 (1 row)</code> </pre><br><pre> <code class="plaintext hljs">student$ pgbench -T 30 test</code> </pre><pre> <code class="plaintext hljs">starting vacuum...end. transaction type: &lt;builtin: TPC-B (sort of)&gt; scaling factor: 1 query mode: simple number of clients: 1 number of threads: 1 duration: 30 s number of transactions actually processed: 26833 latency average = 1.118 ms tps = 894.405027 (including connections establishing) tps = 894.516845 (excluding connections establishing)</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_current_wal_insert_lsn();</code> </pre><pre> <code class="plaintext hljs"> pg_current_wal_insert_lsn --------------------------- 0/3CBD3EA8 (1 row)</code> </pre><br>  Tamanho do registro: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_size_pretty(<span class="hljs-string"><span class="hljs-string">'0/3CBD3EA8'</span></span>::pg_lsn - <span class="hljs-string"><span class="hljs-string">'0/3BE87710'</span></span>::pg_lsn);</code> </pre><pre> <code class="plaintext hljs"> pg_size_pretty ---------------- 13 MB (1 row)</code> </pre><br>  Conclus√£o: na presen√ßa de um grande n√∫mero de imagens de p√°gina inteira (devido a somas de verifica√ß√£o ou <em>full_page_writes</em> , ou seja, quase sempre), provavelmente faz sentido usar a compacta√ß√£o, apesar de carregar o processador. <br><br><h1>  Desempenho </h1><br>  Durante a opera√ß√£o normal do servidor, ocorre uma grava√ß√£o seq√ºencial cont√≠nua dos arquivos de log.  Como n√£o h√° acesso aleat√≥rio, os HDDs regulares tamb√©m lidam com esta tarefa.  Mas essa natureza da carga √© significativamente diferente de como os arquivos de dados s√£o acessados. <br><br>  Portanto, geralmente √© vantajoso colocar o log em um disco f√≠sico separado (ou matriz de discos) montado no sistema de arquivos do servidor.  Em vez do diret√≥rio $ PGDATA / pg_wal, voc√™ precisa criar um link simb√≥lico para o diret√≥rio correspondente. <br><br><blockquote>  Existem algumas situa√ß√µes em que os arquivos de log precisam n√£o apenas ser gravados, mas tamb√©m lidos.  O primeiro √© um caso compreens√≠vel de recupera√ß√£o ap√≥s uma falha.  O segundo √© menos trivial.  Isso ocorre se a replica√ß√£o de streaming for usada e a r√©plica n√£o conseguir receber entradas de di√°rio enquanto elas ainda estiverem nos buffers de RAM do servidor principal.  Ent√£o o processo do walsender precisa ler os dados necess√°rios do disco.  Falaremos sobre isso em mais detalhes quando chegarmos √† replica√ß√£o. <br></blockquote><br>  O registro ocorre em um dos dois modos: <br><br><ul><li>  s√≠ncrono - quando uma transa√ß√£o √© confirmada, a continua√ß√£o do trabalho √© imposs√≠vel at√© que todos os lan√ßamentos cont√°beis manuais sobre essa transa√ß√£o estejam no disco; </li><li>  ass√≠ncrono - a transa√ß√£o √© conclu√≠da imediatamente e o log √© gravado em segundo plano. </li></ul><br>  O modo s√≠ncrono √© determinado pelo par√¢metro <em>synchronous_commit</em> e √© ativado por padr√£o. <br><br>  Como a sincroniza√ß√£o est√° associada a E / S real (ou seja, lenta), √© ben√©fico execut√°-lo o m√≠nimo poss√≠vel.  Para fazer isso, o processo de manuten√ß√£o que conclui a transa√ß√£o e grava um log faz uma pequena pausa, determinada pelo par√¢metro <em>commit_delay</em> .       ,       <em>commit_siblings</em>  .     ,                 .    ,     ,  -    . <br><br>    <em>commit_siblings</em> = 5,  <em>commit_delay</em> = 0,      .  <em>commit_delay</em>     ,     OLTP-. <br><br>          LSN (  ,       ).     . <br><br>      ( D   ACID) ‚Äî   ,            .     ,       ( COMMIT      )    . <br><br>    ,  <em>synchronous_commit</em> = off ( local). <br><br>         wal writer,      (   <em>wal_writer_delay</em> = 200ms  ). <br><br>    ,  ,         WAL.  ,    , , ,     . (,    :  ,    ,         .) <br><br>       ,     (  )   ‚Äî    ? <br><br>     ,            ,      . <br><br>     ‚Äî     .   :       ,        3 √ó <em>wal_writer_delay</em>  (        ). <br><br>   ‚Äî    ‚Äî    . <br><br>  :      ( <em>fsync</em> = off),       .         , , ,       . <br><br>  <em>synchronous_commit</em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pode ser definido como parte de transa√ß√µes individuais. Isso permite aumentar a produtividade sacrificando a confiabilidade de apenas parte da transa√ß√£o. Digamos, as transa√ß√µes financeiras sempre precisam ser corrigidas de forma s√≠ncrona e as mensagens de bate-papo √†s vezes podem ser negligenciadas. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Na realidade, esses dois modos funcionam juntos. Mesmo com a confirma√ß√£o s√≠ncrona, os logs de transa√ß√£o longos ser√£o gravados de forma ass√≠ncrona para liberar os buffers do WAL. E se, ao redefinir uma p√°gina do cache do buffer, a entrada de di√°rio correspondente ainda n√£o estiver no disco, ela ser√° redefinida imediatamente no modo s√≠ncrono. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para ter uma id√©ia do que a confirma√ß√£o ass√≠ncrona fornece, tentamos repetir o teste pgbench nesse modo.</font></font><br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">ALTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SYSTEM</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> synchronous_commit = <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_reload_conf();</code> </pre><br><pre> <code class="plaintext hljs">student$ pgbench -T 30 test</code> </pre><pre> <code class="plaintext hljs">starting vacuum...end. transaction type: &lt;builtin: TPC-B (sort of)&gt; scaling factor: 1 query mode: simple number of clients: 1 number of threads: 1 duration: 30 s number of transactions actually processed: 45439 latency average = 0.660 ms tps = 1514.561710 (including connections establishing) tps = 1514.710558 (excluding connections establishing)</code> </pre><br>       900    (tps),   ‚Äî 1500. ,         ,  ,         . <br><br>         .  -    ,       .  Obrigado a todos! <br><br>         ,     . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt461523/">https://habr.com/ru/post/pt461523/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt461507/index.html">Por que decidimos lan√ßar o acelerador corporativo Gazprom Neft StartupDrive e quem j√° o aprovou</a></li>
<li><a href="../pt461509/index.html">Assistentes de viagem: uma sele√ß√£o de gadgets e acess√≥rios</a></li>
<li><a href="../pt461511/index.html">Gerenciamento de depend√™ncia do Python: uma compara√ß√£o de abordagens</a></li>
<li><a href="../pt461517/index.html">Melhores algoritmos de copiar e colar para C e C ++. Haiku OS Cookbook</a></li>
<li><a href="../pt461519/index.html">Melhores algoritmos de copiar e colar para C e C ++. Cole√ß√£o de receitas do sistema operacional Haiku</a></li>
<li><a href="../pt461525/index.html">Como eu fiz um controle deslizante realmente adapt√°vel (carrossel)</a></li>
<li><a href="../pt461527/index.html">Levita√ß√£o ac√∫stica DIY</a></li>
<li><a href="../pt461531/index.html">Tic Tac Toe, Parte 6: Bal√£o e Aipo / RabbitMQ</a></li>
<li><a href="../pt461533/index.html">Visualiza√ß√£o do sono do primeiro ano da crian√ßa nos padr√µes do cobertor</a></li>
<li><a href="../pt461535/index.html">C ++, FIX, Oracle e PL / SQL: o que um especialista em TI precisa saber para conseguir um emprego em finan√ßas + oportunidades reais de trabalho</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>