<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🎌 🔚 🌪️ CSS Paint API 📯 🤶🏽 👩🏿‍✈️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Laut dem Autor des Materials, dessen Übersetzung wir heute veröffentlichen, ist die CSS Paint API eine unglaublich interessante Technologie. Darüber h...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>CSS Paint API</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/417075/">  Laut dem Autor des Materials, dessen Übersetzung wir heute veröffentlichen, ist <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">die CSS Paint API</a> eine unglaublich interessante Technologie.  Darüber hinaus sprechen wir nicht nur über seine aktuellen Fähigkeiten, sondern auch über die Phänomene, die ihm präsentiert werden, und dass sein Erscheinungsbild den Beginn sehr bemerkenswerter Veränderungen in der CSS-Welt markiert.  Hier werden wir über die CSS Paint API und die Gründe für ihr Erscheinungsbild sprechen und darüber, wie man sie verwendet. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/webt/6c/1q/yu/6c1qyuo29pmcjmojwwou8qb034g.jpeg"></a> <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">Was ist die CSS Paint API?</font> </h2><br>  Die fragliche API ist nur ein kleiner Teil der neuen Spezifikationen, die im Rahmen des CSS Houdini-Projekts entwickelt werden.  Die kurze Beschreibung dieses Projekts beruht auf der Tatsache, dass Entwickler auf niedriger Ebene Zugriff auf interne CSS-Mechanismen erhalten. <br><br>  Mit der CSS Paint API können Sie die Funktion <code>paint()</code> in Situationen aufrufen <code>paint()</code> in denen unter normalen Bedingungen beispielsweise mit einem bestimmten Wert gearbeitet wird, der eine Art Bild beschreibt.  Ein häufiges Beispiel hierfür ist die Eigenschaft " <code>background-image</code> , mit der Sie bei der Arbeit die Funktion " <code>url()</code> können, um dem System einen Link zur Bilddatei zu übergeben: <br><br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">area</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">background-image</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">url</span></span>(<span class="hljs-string"><span class="hljs-string">'assets/myimage.jpg'</span></span>); }</code> </pre> <br>  Mit der CSS-Paint-API können Sie anstelle einer ähnlichen Funktion die Funktion <code>paint()</code> aufrufen und das von JavaScript beschriebene sogenannte Worklet übergeben.  Ein Vorklet kann als Code wahrgenommen werden, mit dem ein Entwickler fast alles programmgesteuert zeichnen kann, was er möchte.  Und da es sich um JavaScript handelt, kann das Bild dynamisch gestaltet werden.  Diese API ist der HTML5-Canvas-API an sich sehr ähnlich, und jetzt werden wir darüber sprechen, wie alles funktioniert. <br><br><h2>  <font color="#3AC1EF">CSS Paint API-Funktionen</font> </h2><br>  Wenn Sie jetzt das Gefühl haben, dass dies alles gut klingt, aber kompliziert aussieht und Sie der Meinung sind, dass Sie mit gewöhnlichen Bildern recht vertraut sind, denken Sie daran, dass gewöhnliche Bilder mit dem Aufkommen neuer Technologien nicht an Relevanz verlieren.  Es ist völlig normal, sie wie immer zu benutzen.  Die Tatsache, dass etwas Neues am Horizont aufgetaucht ist und wahrscheinlich vielversprechend ist, bedeutet nicht, dass jeder dieses Neue sofort nutzen muss, um alle bestehenden Probleme zu lösen.  Gewöhnliche Bilder sind jedoch statisch.  Die neue API überzeugt mit der Idee, dynamische Bilder zu erstellen. <br><br>  Lassen Sie uns über den <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">linearen Gradienten</a> der CSS-Funktion nachdenken.  Das Ding ist sehr mächtig.  Schauen Sie sich <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">das</a> zum Beispiel an.  Aber können Sie sich vorstellen, wie viel einfacher es wäre, den gleichen Effekt zu erzielen, der durch überlappende Ebenen entsteht, wenn Sie nicht viele Hintergrundbilder verwenden müssten?  Dies ist jedoch nicht der einzige Punkt.  Wenn Sie sich mit der CSS Paint-API befassen, können Sie verstehen, wie solche Bilder während der Programmausführung erstellt werden, und dies kann sehr nützlich sein (genau das planen wir hier). <br><br>  Was ist mit der CSS-Funktion mit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">konischem Gradienten</a> ?  Es kann gesagt werden, dass es von Browsern ohne Polyfill noch nicht unterstützt wird.  Mit der neuen API können Sie konische Verläufe erstellen und deren Parameter anpassen, die sich nicht besonders von den Angaben in der Spezifikation unterscheiden.  All dies bedeutet, dass Sie in der Praxis mithilfe der neuen API Ihre eigene native Polyfüllung erstellen können.  Und das ist einfach wunderbar. <br><br>  Denken Sie daran, dass all dies Teil einer größeren Gruppe von Funktionen ist, die als CSS Houdini bekannt sind.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">In</a> der Projektdokumentation heißt es dazu: „Das Ziel der CSS-TAG Houdini Task Force (CSS Houdini) besteht darin, gemeinsam Mechanismen zu entwickeln, die das Rätsel der Technologie lösen, Webseiten zu gestalten und ihre Layouts zu erstellen.“ <br><br>  Hört sich gut an, oder?  Tatsächlich sollen diese neuen Mechanismen es Entwicklern ermöglichen, die Funktionalität von CSS selbst zu erweitern und ihnen bessere Styling-Tools, browserübergreifende Unterstützung und die Möglichkeit zum Erstellen von Polyfills zu bieten. <br><br>  Der Standardisierungsprozess neuer Technologien kann einige Zeit dauern.  Zunächst wird ein Vorschlag für eine neue CSS-Funktion gemacht.  Als nächstes wird eine Spezifikation geschrieben, andere Prozesse treten auf.  Infolgedessen implementieren Browserhersteller neue Spezifikationen.  Und da Entwickler es oft nicht erwarten können, so schnell wie möglich mit der Verwendung neuer Funktionen zu beginnen, müssen sie berücksichtigen, dass alte Browser möglicherweise keine Innovationen unterstützen und dass einige Spezifikationen, wenn sie noch nicht vollständig implementiert sind, im Laufe der Zeit möglicherweise nicht vollständig implementiert werden Entwicklung, ernsthafte Veränderung.  Vielleicht gibt es nichts zu sagen über die typischen Nuancen der Implementierung verschiedener Technologien in verschiedenen Browsern.  Das Houdini-Projekt kann diese Probleme weitestgehend lösen, sodass wir die Browserfunktionalität selbst entwickeln, verwenden und ruhig darauf warten können, dass die Browserhersteller bestimmte Funktionen implementieren.  Hier einige Materialien zu diesem Thema.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Die erste ist</a> den Stärken von Houdini gewidmet, und die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">zweite</a> besteht darin, die Fähigkeiten dieses Projekts zu nutzen, um komplexe Animationen zu erstellen. <br><br><h2>  <font color="#3AC1EF">Unterstützung für CSS Paint API durch Browser</font> </h2><br>  Kann ich heute die CSS Paint API verwenden?  Wir können diese Frage positiv beantworten, obwohl zu beachten ist, dass bei weitem nicht alle Browser diese Technologie unterstützen.  Um <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Supportinformationen</a> für diese API zu erhalten, können Sie die Ressource <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">caniuse.com verwenden</a> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/55a/42a/4ea/55a42a4ea1ccc056652c9a7b463f8097.png"></div><br>  <i><font color="#999999">Unterstützung für die CSS Paint API durch verschiedene Browser (Juli 2018)</font></i> <br><br>  Wie Sie sehen, unterstützt diese API bisher nur Chrome.  Aber wie auch immer, lassen Sie uns darüber sprechen, wie man es benutzt.  Wir werden die Software-Konstrukte behandeln, die erforderlich sind, damit die neue API funktioniert.  Dies beinhaltet neue CSS-Funktionen und einige relativ neue JavaScript-Mechanismen.  Unser Beispiel wird in drei Schritte unterteilt. <br><br><h2>  <font color="#3AC1EF">Schritt 1: CSS</font> </h2><br>  Denken Sie daran, dass die Widgets zum Erstellen eines Bildes mit der CSS Paint-API die Fragmente des JS-Codes sind.  Daher müssen wir dem Worklet zunächst einen Namen geben und es in CSS aufrufen.  Nennen <code>awesomePattern</code> es <code>awesomePattern</code> .  Infolgedessen sieht das CSS folgendermaßen aus: <br><br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">section</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">background-image</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">url</span></span>(<span class="hljs-string"><span class="hljs-string">'fallback.png'</span></span>); <span class="hljs-attribute"><span class="hljs-attribute">background-image</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">paint</span></span>(awesomePattern); };</code> </pre> <br>  Die vorbereitenden Vorbereitungen sind abgeschlossen, aber bis der Rest unseres Beispiels fertig ist, wird dies alles nicht funktionieren. <br><br><h2>  <font color="#3AC1EF">Schritt 2: JavaScript</font> </h2><br>  Jetzt müssen wir das Worklet mit JS beschreiben.  Hier wird gezeigt, wie im Hauptskript ein anderes Skript geladen wird, das die von uns benötigten Funktionen implementiert. <br><br><pre> <code class="hljs cs">CSS.paintWorklet.addModule(<span class="hljs-string"><span class="hljs-string">'patternWorklet.js'</span></span>);</code> </pre> <br>  Auch in diesem Stadium passiert nichts, da das interessanteste in der Datei <code>patternWorklet.js</code> versteckt ist. <br><br>  In der Datei <code>patternWorklet.js</code> wir die Klasse des Vorklets registrieren: <br><br><pre> <code class="hljs lisp">registerPaint('awesomePattern', Shape)<span class="hljs-comment"><span class="hljs-comment">;</span></span></code> </pre> <br>  Hier rufen wir die Funktion <code>registerPaint()</code> und übergeben sie als Worklet, in diesem Fall <code>awesomePattern</code> .  Außerdem übergeben wir dieser Funktion einen Link zu der Klasse, die wir schreiben werden, in diesem Fall <code>Shape</code> .  Dieser Befehl muss nach der Deklaration der entsprechenden Klasse hinzugefügt werden.  Wenn Sie Klassen deklarieren und verwenden, können Sie sich nicht auf einen Mechanismus zum Auslösen von Funktionsdeklarationen verlassen.  Bevor Sie eine Klasse verwenden können, müssen Sie sie deklarieren. <br><br>  Als Nächstes verwenden wir die Syntax zum Deklarieren von ECMAScript 2015-Klassen und schreiben eine Klasse, die das Hintergrundbild zeichnet.  Da diese Klasse jetzt als Klasse der Arbeiterklasse registriert ist, können wir einige spezielle Mechanismen verwenden, die automatisch in ihr verfügbar sind. <br><br><pre> <code class="hljs haskell"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Shape</span></span></span><span class="hljs-class"> { paint(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ctx</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">geom</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">properties</span></span></span><span class="hljs-class">) {   ctx.strokeStyle = 'white';   ctx.lineWidth = 4;   ctx.beginPath();   ctx.arc( 200, 200, 50, 0, 2*</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Math</span></span></span><span class="hljs-class">.</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">PI</span></span></span><span class="hljs-class">);   ctx.stroke();   ctx.closePath(); } }</span></span></code> </pre> <br>  Der <code>paint()</code> Rückruf enthält die Parameter <code>ctx</code> , <code>geom</code> und <code>properties</code> .  Der Parameter <code>ctx</code> dem 2D-Rendering-Kontext, der vom <code>&lt;canvas&gt;</code> abgerufen werden kann.  Nun, es ist fast das gleiche.  Tatsache ist, dass Sie mit dem <code>&lt;canvas&gt;</code> Pixeldaten lesen können, die CSS Paint-API jedoch nicht.  Trotz der Unterschiede können wir mit <code>ctx</code> dieselben grafischen Ausgabemethoden verwenden, die bei der Arbeit mit dem <code>&lt;canvas&gt;</code> .  In diesem Beispiel zeichnen wir mit der Funktion <code>arc()</code> einen Kreis. <br><br>  Die ersten beiden an die Funktion <code>arc()</code> Werte sind die X- und Y-Koordinaten des Kreismittelpunkts in Pixel relativ zum Ursprung in der oberen linken Ecke des Elements.  Ich möchte jedoch, dass sich der Kreis in der Mitte des Elements befindet.  Um dieses Problem zu lösen, ist der <code>geom</code> Parameter für uns nützlich.  Es bietet Zugriff auf das <code>PaintSize</code> Objekt, das eine Beschreibung der Bildeinstellungen darstellt.  Insbesondere wenn wir uns darauf beziehen, können wir die Parameter für <code>width</code> und <code>height</code> lesen, und genau das benötigen wir, um den Kreis zu zentrieren. <br><br>  Als Ergebnis kommen wir zu diesem Code: <br><br><pre> <code class="hljs haskell"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Shape</span></span></span><span class="hljs-class"> { paint(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ctx</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">geom</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">properties</span></span></span><span class="hljs-class">) {     let x = geom.width/2;   let y = geom.height/2;   ctx.strokeStyle = 'white';   ctx.lineWidth = 4;   ctx.beginPath();   ctx.arc(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">x</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">y</span></span></span><span class="hljs-class">, 50, 0, 2*</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Math</span></span></span><span class="hljs-class">.</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">PI</span></span></span><span class="hljs-class">);   ctx.stroke();   ctx.closePath();   } } registerPaint('</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">awesomePattern'</span></span></span><span class="hljs-class">, </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Shape</span></span></span><span class="hljs-class">);</span></span></code> </pre> <br>  Siehe die Arbeitsversion des Beispiels auf <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">CodePen</a> .  Genau genommen gibt dieser Code dies aus. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0f2/18e/992/0f218e9927aa75625eb0ae0ae0ec8e4e.png"></div><br>  <i><font color="#999999">Kreis erstellt mit CSS Paint APIs</font></i> <br><br>  Das alles ist gut, aber unser Beispiel ist sehr einfach.  Lassen Sie uns anstelle des üblichen Kreises etwas Interessanteres zeichnen.  Zum Beispiel - so ein Sternchen - das Logo der Website css-tricks.com. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a1f/26e/5a7/a1f26e5a7d56b1d3d98717c890deabbf.png"></div><br>  <i><font color="#999999">Mit CSS Paint APIs erstelltes Sternchen</font></i> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Hier ist</a> ein CodePen-Projekt, mit dem Sie dies tun können. <br><br>  <code>drawStar()</code> Sie beim Betrachten des JS-Codes für dieses Projekt auf die <code>drawStar()</code> -Methode und die vielen Funktionen, die beim Arbeiten mit dem <code>&lt;canvas&gt;</code> . <br><br><h2>  <font color="#3AC1EF">Schritt 3: Benutzerdefinierte CSS-Eigenschaften</font> </h2><br>  Mit neuen Technologien können wir viel weiter gehen als nur Kreise und Sterne zu zeichnen.  Wir können uns die leistungsstarken Funktionen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">benutzerdefinierter CSS-Eigenschaften</a> (Variablen) ansehen.  Sie sind übrigens selbst sehr interessant.  In unserem Fall erweisen sie sich als besonders nützlich. <br><br>  Angenommen, wir möchten die Größe oder Farbe eines zuvor erstellten Logos ändern können.  Diese Parameter können in Form von benutzerdefinierten Eigenschaften in den CSS-Code eingefügt und dann über den dritten Parameter, der an den <code>paint()</code> Rückruf übergeben wird, im Programm verwendet werden.  Es geht um den <code>properties</code> . <br><br>  Wir fügen unserem CSS-Code die Eigenschaft <code>--star-scale</code> hinzu, mit der die <code>--star-scale</code> gesteuert werden soll, und die Eigenschaft <code>--star-color</code> , mit der die Änderung der Logo-Farbe direkt in CSS organisiert wird.  Folgendes haben wir: <br><br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">section</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">--star-scale</span></span>: <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">--star-color</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">hsla</span></span>(200, 50%, 50%, 1); <span class="hljs-attribute"><span class="hljs-attribute">background-image</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">paint</span></span>(awesomePattern) };</code> </pre> <br>  Nun zurück zur Klasse der Arbeitstücher.  Hier müssen wir mit den oben beschriebenen Benutzereigenschaften interagieren.  Dies erfolgt mit der <code>inputProperties</code> Methode, mit der wir auf alle CSS-Eigenschaften und ihre zugewiesenen Werte zugreifen können. <br><br><pre> <code class="hljs cs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">get</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">inputProperties</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [<span class="hljs-string"><span class="hljs-string">'--star-scale'</span></span>,<span class="hljs-string"><span class="hljs-string">'--star-color'</span></span>]; }</code> </pre> <br>  Jetzt können Sie mit ihnen in der <code>paint()</code> -Methode arbeiten: <br><br><pre> <code class="hljs lisp">const size = parseInt(<span class="hljs-name"><span class="hljs-name">properties</span></span>.get('--shape-size').toString())<span class="hljs-comment"><span class="hljs-comment">;</span></span></code> </pre> <br>  Natürlich können die erhaltenen Werte in dem Code verwendet werden, der für die Bilderzeugung verantwortlich ist.  Dies führt dazu, dass, wenn wir im CSS-Code den Wert der <code>--star-scale</code> oder <code>--start-color</code> , sich dies sofort auf das Aussehen des Bildes auswirkt. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7d2/7a0/676/7d27a06764d4888bcb66dc2a6d8d17b3.gif" alt="Bild"></div><br>  <i><font color="#999999">Der Einfluss benutzerdefinierter CSS-Eigenschaften auf das fertige Bild</font></i> <br><br>  Diese Funktionalität ist in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">demselben</a> CodePen-Projekt implementiert, das wir oben erwähnt haben. <br><br>  Übrigens ist zu beachten, dass bei Verwendung der neuen API alle üblichen CSS-Eigenschaften, die sich auf das Festlegen des Hintergrunds von Elementen beziehen, wie z. B. <code>background-size</code> und <code>background-repeat</code> , auf dieselbe Weise wie zuvor funktionieren.  Sie haben nicht an Relevanz verloren. <br><br><h2>  <font color="#3AC1EF">Zusammenfassung</font> </h2><br>  Die CSS Paint API ist eine sehr leistungsstarke Technologie, deren Funktionen nicht nur auf die Erstellung von Hintergrundbildern beschränkt sind. <br><br>  Stellen Sie sich vor, das Element sollte einen speziellen Rand haben, z. B. einen, der nicht vollständig sichtbar ist, oder einen doppelten.  Um solche Effekte zu erzielen, verwenden Sie normalerweise die Pseudoelemente <code>::before</code> oder <code>::after</code> oder einen speziell konfigurierten <code>box-shadow</code> .  Rahmen (und vieles mehr) können mithilfe der CSS Paint-API und der <code>border-image</code> Eigenschaft implementiert werden. <br><br>  Die CSS Paint-API vereint viele großartige Funktionen wie Widgets, ECMAScript 2015-Klassen und die Funktionen des <code>&lt;canvas&gt;</code> .  Darüber hinaus bietet es dem Entwickler eine JavaScript-basierte Bildverwaltungssoftware.  Mithilfe des Ereignismechanismus können Sie beispielsweise die Aktualisierung benutzerdefinierter Eigenschaften organisieren. <code>requestAnimationFrame</code> bedeutet, dass das Bild selbst wie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier ausgeführt wird</a> , wenn das <code>requestAnimationFrame</code> den Prozess der Aktualisierung von Eigenschaften in der Funktion <code>requestAnimationFrame</code> startet, mit der Sie jedes Mal eine Animation erstellen können, wenn der Benutzer auf die Schaltfläche klickt.  Darüber hinaus werden auch die Koordinaten des Mauszeigers beim Klicken berücksichtigt. <br><br>  Auf den ersten Blick mag dies alles etwas verwirrend erscheinen, aber werfen wir einen Blick auf einige andere Teile des Houdini-Projekts, mit denen wir uns möglicherweise treffen: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Mit der CSS-Layout-API</a> kann der Entwickler beispielsweise <code>display: layout('myCustomLayout')</code> .  Ein typisches Beispiel ist die Erstellung eigener Layouts im Mauerwerksstil. Der Anwendungsbereich dieser Funktion ist jedoch viel breiter. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Mit der CSS-API für Eigenschaften und Werte</a> können Sie benutzerdefinierte Eigenschaftstypen festlegen. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Die CSS Animation Worklet API überträgt</a> Animationsverarbeitungsvorgänge über den Hauptstrom hinaus, was zu perfekt reibungslosen Animationen führen sollte. </li></ul><br>  Infolgedessen können wir sagen, dass buchstäblich vor unseren Augen Technologien auftauchen, die Webentwicklern viele neue Möglichkeiten eröffnen.  Die Prozesse ihrer Standardisierung und Implementierung in Browsern sind nicht so schnell, aber sie werden möglicherweise enorme Auswirkungen auf alles haben, was mit dem Styling von Webseiten zu tun hat. <br><br>  <b>Liebe Leser!</b>  Welche Bereiche der CSS Paint API-Anwendung finden Sie am interessantesten? <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/webt/cp/zf/te/cpzfteyh2kzlthzniyap-5t1h6c.jpeg"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de417075/">https://habr.com/ru/post/de417075/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de417063/index.html">Neuronale Netze für die Kleinsten</a></li>
<li><a href="../de417065/index.html">Splunk-Anleitung oder wie und wo man Splunk lernt</a></li>
<li><a href="../de417069/index.html">Nochmals zu OpenSSL</a></li>
<li><a href="../de417071/index.html">Freitag PHP: Kostenlose Skillbox-Webinare</a></li>
<li><a href="../de417073/index.html">Uber Mobile Developer Day</a></li>
<li><a href="../de417079/index.html">Paketmanager für Kubernetes - Helm: Vergangenheit, Gegenwart, Zukunft</a></li>
<li><a href="../de417081/index.html">Norden, Wille, Hoffnung, Land ohne Grenzen oder wie Projekte unter schwierigen sibirischen Bedingungen durchgeführt werden</a></li>
<li><a href="../de417083/index.html">Hohe Lasten der WM 2018</a></li>
<li><a href="../de417085/index.html">Browser schalten den Sound in Ihrer WebRTC-Anwendung stumm. Hör auf was?</a></li>
<li><a href="../de417087/index.html">HPE Digitalize 2018: Event und Live-Stream</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>