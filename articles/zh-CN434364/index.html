<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🌖 👩🏿‍🤝‍👨🏼 🧑🏾 Hangfire队列支持 🌬️ 🎪 👸</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hangfire是.net（核心）的库，它允许根据“即发即弃”的原则异步执行某些代码。 此类代码的示例可以是发送电子邮件，视频处理，与另一个系统的同步等。 除了“一劳永逸”外，还支持延迟任务以及Cron格式的计划任务。 


 当前，有许多这样的库。 Hangfire的一些好处是： 


- 配置简...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Hangfire队列支持</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/434364/"><p>  Hangfire是.net（核心）的库，它允许根据“即发即弃”的原则异步执行某些代码。 此类代码的示例可以是发送电子邮件，视频处理，与另一个系统的同步等。 除了“一劳永逸”外，还支持延迟任务以及Cron格式的计划任务。 </p><br><p> 当前，有许多这样的库。  Hangfire的一些好处是： </p><br><ul><li> 配置简单，API方便 </li><li> 可靠度  Hangfire保证创建的任务至少执行一次 </li><li> 能够并行执行任务并具有出色的性能 </li><li> 可扩展性（我们将在下面使用它） </li><li> 相当完整且易于理解的文档 </li><li> 您可以在仪表板上查看有关任务的所有统计信息 </li></ul><br><p> 我不会赘述太多，因为有很多关于Hangfire及其使用方法的好文章。 在本文中，我将讨论如何使用多个队列（或任务池）的支持，如何修复标准的重试功能以及如何使每个队列具有单独的配置。 </p><a name="habracut"></a><br><h3 id="suschestvuyuschaya-podderzhka-psevdo-ocheredey"> 对（伪）队列的现有支持 </h3><br><p> 重要说明：在标题中，我使用了伪队列一词，因为Hangfire不能保证将以特定顺序执行任务。 即  “先进先出”的原则不适用，我们也不会依靠它。 此外，该库的作者建议使任务成为幂等，即 稳定地应对不可预见的多重执行。 此外，我将仅使用“队列”一词，因为  Hangfire使用术语“队列”。 </p><br><p>  Hangfire具有简单的队列支持。 尽管它不提供诸如RabbitMQ或Azure Service Bus之类的消息队列系统的灵活性，但它通常足以解决各种各样的任务。 </p><br><p> 每个任务都有“队列”属性，即应在其中执行的队列的名称。 默认情况下，除非另有说明，否则任务以名称“ default”发送到队列。 为了单独管理不同类型任务的执行，需要支持多个队列。 例如，我们可能希望视频处理任务落入“ video_queue”队列，然后将电子邮件发送到“ email_queue”队列。 因此，我们能够独立执行这两种类型的任务。 如果我们想将视频处理移至专用服务器，则可以通过将单独的Hangfire服务器作为控制台应用程序运行来轻松处理，以处理“ video_queue”队列。 </p><br><h3 id="pereydem-k-praktike"> 让我们继续练习 </h3><br><p> 在asp.net核心中设置Hangfire服务器的步骤如下： </p><br><pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Configure</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IApplicationBuilder app</span></span></span><span class="hljs-function">)</span></span> { app.UseHangfireServer(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BackgroundJobServerOptions { WorkerCount = <span class="hljs-number"><span class="hljs-number">2</span></span>, Queues = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span>[] { <span class="hljs-string"><span class="hljs-string">"email_queue"</span></span>, <span class="hljs-string"><span class="hljs-string">"video_queue"</span></span> } }); }</code> </pre> <br><h3 id="problema-1---zadachi-pri-povtore-popadayut-v-ochered-default"> 问题1-重播任务属于默认队列 </h3><br><p> 如上所述，Hangfire中有一个默认队列，称为“默认”。 如果某个任务排队，例如“ video_queue”失败，需要重试，那么它将再次发送到“默认”队列，而不是“ video_queue”，因此，我们的任务将根本不会执行我们想要的Hangfire服务器实例。 这种行为是我通过实验建立的，可能是Hangfire本身的错误。 </p><br><h4 id="job-filters"> 职位筛选 </h4><br><p>  Hangfire使我们能够借助所谓的过滤器（ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">作业过滤器</a> ）扩展功能，这些过滤<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">器</a>在原理上类似于ASP.NET MVC中的“动作”过滤器。 事实是，Hangfire的内部逻辑是作为状态机实现的。 这是一种引擎，它顺序地将池中的任务从一种状态转移到另一种状态（例如，创建-&gt;排队-&gt;处理-&gt;成功），并且过滤器使我们可以在状态每次发生变化时“拦截”正在执行的任务并对其进行操作。 筛选器实现为可应用于单个方法，类或全局的属性。 </p><br><h4 id="job-parameters"> 工作参数 </h4><br><p>  ElectStateContext对象作为参数传递给filter方法。 该对象包含有关当前任务的完整信息。 除其他外，它具有GetJobParameter &lt;&gt;（...）和SettJobParameter &lt;&gt;（...）方法。 作业参数使您可以将与任务相关的信息保存在数据库中。 在“作业参数”中存储了最初向其发送任务的队列的名称，仅出于某种原因，在下次重试期间将忽略此信息。 </p><br><h3 id="reshenie"> 解决方案 </h3><br><p> 因此，我们有一个错误结束的任务，应该在正确的队列中发送该任务以重新执行（与初次创建时分配给它的任务相同）。 重复执行完成但有错误的任务是从失败状态到排队状态的过渡。 要解决该问题，请创建一个过滤器，当任务进入“入队”状态时，它将检查任务最初发送到哪个队列中，并将“ QueueName”参数放入所需的值： </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">HangfireUseCorrectQueueFilter</span></span> : <span class="hljs-title"><span class="hljs-title">JobFilterAttribute</span></span>, <span class="hljs-title"><span class="hljs-title">IElectStateFilter</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnStateElection</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">ElectStateContext context</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (context.CandidateState <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> EnqueuedState enqueuedState) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> queueName = context.GetJobParameter&lt;<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>&gt;(<span class="hljs-string"><span class="hljs-string">"QueueName"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>.IsNullOrWhiteSpace(queueName)) { context.SetJobParameter(<span class="hljs-string"><span class="hljs-string">"QueueName"</span></span>, enqueuedState.Queue); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { enqueuedState.Queue = queueName; } } } }</code> </pre> <br><p> 为了将默认过滤器应用于所有任务（即全局），请将以下代码添加到我们的配置中： </p><br><pre> <code class="cs hljs">GlobalJobFilters.Filters.Add(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HangfireUseCorrectQueueFilter { Order = <span class="hljs-number"><span class="hljs-number">1</span></span> });</code> </pre> <br><p> 另一个小问题是，默认情况下，GlobalJobFilters集合包含AutomaticRetryAttribute类的实例。 这是一个标准过滤器，负责重新执行失败的任务。 他还将任务发送到“默认”队列，而忽略了原始队列。 为了让我们的自行车骑行，您需要从集合中删除此过滤器，并让我们的过滤器负责重复的任务。 结果，配置代码将如下所示： </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> defaultRetryFilter = GlobalJobFilters.Filters .FirstOrDefault(f =&gt; f.Instance <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> AutomaticRetryAttribute); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (defaultRetryFilter != <span class="hljs-literal"><span class="hljs-literal">null</span></span> &amp;&amp; defaultRetryFilter.Instance != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { GlobalJobFilters.Filters.Remove(defaultRetryFilter.Instance); } GlobalJobFilters.Filters.Add(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HangfireUseCorrectQueueFilter { Order = <span class="hljs-number"><span class="hljs-number">1</span></span> });</code> </pre> <br><p> 应该注意的是，AutomaticRetryAttribute实现了以下逻辑：自动增加尝试之间的间隔（间隔随着每次后续尝试而增加），并从GlobalJobFilters集合中删除AutomaticRetryAttribute，我们放弃了此功能（请参见<a href="">ScheduleAgainLater</a>方法的实现）。 </p><br><p> 因此，我们已经实现了可以在不同队列中执行任务的方法，这使我们能够独立管理其执行，包括在不同的计算机上处​​理不同的队列。 直到现在，我们才知道发生错误的情况下将重复执行任务多少次和间隔多少，因为我们从过滤器集合中删除了AutomaticRetryAttribute。 </p><br><h3 id="problema-2---individualnye-nastroyki-dlya-kazhdoy-ocheredi"> 问题2-每个队列的单独设置 </h3><br><p> 我们希望能够为每个队列分别配置间隔和重复次数，并且，如果对于某些队列，我们​​未明确指定值，则希望应用默认值。 为此，我们实现了另一个过滤器，并将其<code>HangfireRetryJobFilter</code> 。 </p><br><p> 理想情况下，配置代码应如下所示： </p><br><pre> <code class="cs hljs">GlobalJobFilters.Filters.Add(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HangfireRetryJobFilter { Order = <span class="hljs-number"><span class="hljs-number">2</span></span>, [<span class="hljs-string"><span class="hljs-string">"email_queue"</span></span>] = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HangfireQueueSettings { DelayInSeconds = <span class="hljs-number"><span class="hljs-number">120</span></span>, RetryAttempts = <span class="hljs-number"><span class="hljs-number">3</span></span> }, [<span class="hljs-string"><span class="hljs-string">"video_queue"</span></span>] = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HangfireQueueSettings { DelayInSeconds = <span class="hljs-number"><span class="hljs-number">60</span></span>, RetryAttempts = <span class="hljs-number"><span class="hljs-number">5</span></span> } });</code> </pre> <br><h3 id="reshenie-1"> 解决方案 </h3><br><p> 为此，请首先添加<code>HangfireQueueSettings</code>类，该类将用作我们设置的容器。 </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">sealed</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">HangfireQueueSettings</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> RetryAttempts { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> DelayInSeconds { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } }</code> </pre> <br><p> 然后，我们添加过滤器本身的实现，当错误后重复执行任务时，该实现将根据队列配置应用设置并监视重试次数： </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">HangfireRetryJobFilter</span></span> : <span class="hljs-title"><span class="hljs-title">JobFilterAttribute</span></span>, <span class="hljs-title"><span class="hljs-title">IElectStateFilter</span></span>, <span class="hljs-title"><span class="hljs-title">IApplyStateFilter</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> HangfireQueueSettings _defaultQueueSettings = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HangfireQueueSettings { RetryAttempts = <span class="hljs-number"><span class="hljs-number">3</span></span>, DelayInSeconds = <span class="hljs-number"><span class="hljs-number">10</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> IDictionary&lt;<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>, HangfireQueueSettings&gt; _settings = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Dictionary&lt;<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>, HangfireQueueSettings&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> HangfireQueueSettings <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>[<span class="hljs-keyword"><span class="hljs-keyword">string</span></span> queueName] { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _settings.TryGetValue(queueName, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> HangfireQueueSettings queueSettings) ? queueSettings : _defaultQueueSettings; } <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { _settings[queueName] = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnStateElection</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">ElectStateContext context</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!(context.CandidateState <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> FailedState failedState)) { <span class="hljs-comment"><span class="hljs-comment">// This filter accepts only failed job state. return; } var retryAttempt = context.GetJobParameter&lt;int&gt;("RetryCount") + 1; var queueName = context.GetJobParameter&lt;string&gt;("QueueName"); if (retryAttempt &lt;= this[queueName].RetryAttempts) { ScheduleAgainLater(context, retryAttempt, failedState, queueName); } else { TransitionToDeleted(context, failedState, queueName); } } public void OnStateApplied( ApplyStateContext context, IWriteOnlyTransaction transaction) { if (context.NewState is ScheduledState &amp;&amp; context.NewState.Reason != null &amp;&amp; context.NewState.Reason.StartsWith("Retry attempt")) { transaction.AddToSet("retries", context.BackgroundJob.Id); } } public void OnStateUnapplied( ApplyStateContext context, IWriteOnlyTransaction transaction) { if (context.OldStateName == ScheduledState.StateName) { transaction.RemoveFromSet("retries", context.BackgroundJob.Id); } } private void ScheduleAgainLater( ElectStateContext context, int retryAttempt, FailedState failedState, string queueName) { context.SetJobParameter("RetryCount", retryAttempt); var delay = TimeSpan.FromSeconds(this[queueName].DelayInSeconds); const int maxMessageLength = 50; var exceptionMessage = failedState.Exception.Message.Length &gt; maxMessageLength ? failedState.Exception.Message.Substring(0, maxMessageLength - 1) + "…" : failedState.Exception.Message; // If attempt number is less than max attempts, we should // schedule the job to run again later. var reason = $"Retry attempt {retryAttempt} of {this[queueName].RetryAttempts}: {exceptionMessage}"; context.CandidateState = delay == TimeSpan.Zero ? (IState)new EnqueuedState { Reason = reason } : new ScheduledState(delay) { Reason = reason }; } private void TransitionToDeleted( ElectStateContext context, FailedState failedState, string queueName) { context.CandidateState = new DeletedState { Reason = this[queueName].RetryAttempts &gt; 0 ? "Exceeded the maximum number of retry attempts." : "Retries were disabled for this job." }; } }</span></span></code> </pre> <br><blockquote> 代码注释：在实现<code>HangfireRetryJobFilter</code>类时，以<code>HangfireRetryJobFilter</code>的<code>AutomaticRetryAttribute</code>类为基础，因此某些方法的实现与该类的相应方法部分重合。 </blockquote><br><h3 id="problema-3---kak-otpravit-zadachu-na-vypolnenie-v-konkretnuyu-ochered"> 问题3-如何将任务发送到特定队列？ </h3><br><p> 我设法找到了两种将任务分配给队列的方法：已记录的和-否。 </p><br><p>  <strong>第一种方法</strong> -将相应的属性挂在方法上 </p><br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">Queue(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"video_queue"</span></span></span><span class="hljs-meta">)</span></span>] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SomeMethod</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { } BackgroundJob.Enqueue(() =&gt; SomeMethod());</code> </pre> <br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">http://docs.hangfire.io/en/latest/background-processing/configuring-queues.html</a> </p><br><p>  <strong>第二种方法</strong> （未记录）-使用<code>BackgroundJobClient</code>类 </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> client = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BackgroundJobClient(); client.Create(() =&gt; MyMethod(), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> EnqueuedState(<span class="hljs-string"><span class="hljs-string">"video_queue"</span></span>));</code> </pre> <br><p> 第二种方法的优点是，它不会在Hangfire中创建不必要的依赖关系，并允许您决定任务应在哪个过程中进行。 不幸的是，在官方文档中，我没有提到<code>BackgroundJobClient</code>类以及如何应用它。 我在解决方案中使用了第二种方法，因此已在实践中对其进行了测试。 </p><br><h3 id="zaklyuchenie"> 结论 </h3><br><p> 在本文中，我们在Hangfire中使用了多个队列的支持来分离不同类型任务的处理。 我们实现了重复执行失败任务的机制，并可能为每个队列进行单独配置，使用作业过滤器扩展了Hangfire的功能，并且还学习了如何将任务发送到所需队列以执行。 </p><br><p> 我希望本文对某人有用。 我很乐意发表评论。 </p><br><h3 id="poleznye-ssylki"> 有用的链接 </h3><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Hangfire文档</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Hangfire源代码</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Scott Hanselman-如何在ASP.NET中运行后台任务</a> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN434364/">https://habr.com/ru/post/zh-CN434364/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN434354/index.html">在Python中使用深度学习创建人脸识别模型</a></li>
<li><a href="../zh-CN434356/index.html">带有电子邮件的Python Stiller</a></li>
<li><a href="../zh-CN434358/index.html">导入替代操作系统。 我如何看待家用操作系统</a></li>
<li><a href="../zh-CN434360/index.html">讲解Java异步编程</a></li>
<li><a href="../zh-CN434362/index.html">没有预测2019</a></li>
<li><a href="../zh-CN434368/index.html">机器学习来查找代码中的错误：我如何在JetBrains Research实习</a></li>
<li><a href="../zh-CN434370/index.html">Phaser中的另一个影子征服者，或使用自行车</a></li>
<li><a href="../zh-CN434374/index.html">在Kubernetes中检查RBAC</a></li>
<li><a href="../zh-CN434380/index.html">依赖注入基础</a></li>
<li><a href="../zh-CN434382/index.html">将Alpine Linux移植到RISC-V</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>