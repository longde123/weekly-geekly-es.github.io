<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤳🏿 ⚱️ 👉🏼 Nuestro problema con las dependencias. 🍂 🛌🏾 🚬</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Durante décadas, la reutilización del software se ha discutido con más frecuencia de lo que realmente fue. Hoy la situación es la opuesta: los desarro...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Nuestro problema con las dependencias.</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/443620/"> Durante décadas, la reutilización del software se ha discutido con más frecuencia de lo que realmente fue.  Hoy la situación es la opuesta: los desarrolladores reutilizan los programas de otras personas todos los días en forma de dependencias de software, y el problema en sí sigue siendo casi inexplorado. <br><br>  Mi propia experiencia incluye una década de trabajo con <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">el repositorio interno de Google</a> , donde las dependencias se establecen como un concepto prioritario, así como el desarrollo de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">un sistema de dependencia para el lenguaje de programación Go</a> . <br><br>  Las dependencias conllevan serios riesgos que a menudo se pasan por alto.  La transición a la reutilización simple de las piezas de software más pequeñas se ha producido tan rápidamente que aún no hemos desarrollado las mejores prácticas para la selección y el uso efectivos de las dependencias.  Incluso para tomar decisiones cuando son apropiadas y cuando no.  El propósito de este artículo es evaluar los riesgos y estimular la búsqueda de soluciones en esta área. <br><a name="habracut"></a><br><h1>  ¿Qué es la adicción? </h1><br>  En el desarrollo moderno, la <i>dependencia</i> es un código adicional que se llama desde un programa.  Agregar una dependencia evita la repetición del trabajo ya realizado: diseño, escritura, prueba, depuración y soporte de una unidad de código específica.  Llamamos a esta unidad de código un <i>paquete</i> , aunque en algunos sistemas se usan otros términos, como una biblioteca o módulo, en lugar de un paquete. <br><br>  Aceptar dependencias externas es una práctica antigua: la mayoría de los programadores descargaron e instalaron la biblioteca necesaria, ya sea PCRE o zlib de C, Boost o Qt de C ++, JodaTime o Junit de Java.  Estos paquetes tienen código depurado de alta calidad que requiere una experiencia considerable para crear.  Si un programa necesita la funcionalidad de dicho paquete, es mucho más fácil descargarlo, instalarlo y actualizarlo manualmente que desarrollar esta funcionalidad desde cero.  Pero los grandes costos iniciales significan que la reutilización manual es costosa: los paquetes pequeños son más fáciles de escribir usted mismo. <br><br>  <i>Un administrador de dependencias</i> (a veces llamado administrador de paquetes) automatiza la descarga e instalación de paquetes de dependencias.  Debido a que los administradores de dependencias facilitan la descarga e instalación de paquetes individuales, reducir los costos fijos hace que los paquetes pequeños sean económicos de publicar y reutilizar. <br><br>  Por ejemplo, un administrador de dependencias de Node.js llamado NPM proporciona acceso a más de 750,000 paquetes.  Uno de ellos, <code>escape-string-regexp</code> , contiene una sola función que escapa a los operadores de expresiones regulares de los datos de entrada.  Toda la implementación: <br><br><pre> <code class="plaintext hljs">var matchOperatorsRe = /[|\\{}()[\]^$+*?.]/g; module.exports = function (str) { if (typeof str !== 'string') { throw new TypeError('Expected a string'); } return str.replace(matchOperatorsRe, '\\$&amp;'); };</code> </pre> <br>  Antes de que aparecieran los administradores de dependencias, era imposible imaginar la publicación de una biblioteca de ocho líneas: demasiados gastos generales y muy pocos beneficios.  Pero NPM redujo la sobrecarga a casi cero, con el resultado de que una funcionalidad casi trivial podría empaquetarse y reutilizarse.  A finales de enero de 2019, la dependencia <code>escape-string-regexp</code> se incorporó a casi mil paquetes de NPM, sin mencionar todos los paquetes que los desarrolladores escriben para su propio uso y no publican en el dominio público. <br><br>  Ahora los administradores de dependencia han aparecido para casi todos los lenguajes de programación.  Maven Central (Java), Nuget (.NET), Packagist (PHP), PyPI (Python) y RubyGems (Ruby): cada uno de ellos tiene más de 100,000 paquetes.  El advenimiento de la reutilización generalizada de paquetes pequeños es uno de los mayores cambios en el desarrollo de software en las últimas dos décadas.  Y si no somos más cuidadosos, esto conducirá a serios problemas. <br><br><h1>  ¿Qué podría salir mal? </h1><br>  En el contexto de esta discusión, un paquete es un código descargado de Internet.  Agregar una dependencia confía el trabajo de desarrollar este código (diseño, escritura, prueba, depuración y soporte) a otra persona en Internet a la que generalmente no conoce.  Con este código, expone su propio programa a los efectos de todos los bloqueos y defectos de la dependencia.  La ejecución de su software ahora <i>depende</i> literalmente del código de un extraño de Internet.  Para decirlo de esta manera, todo suena muy inseguro.  ¿Por qué alguien estaría de acuerdo con esto? <br><br>  Estamos de acuerdo, porque es fácil, porque todo parece funcionar, porque todos los demás también lo hacen, y lo más importante, porque parece ser una continuación natural de una práctica establecida de siglos de antigüedad.  Pero hay una diferencia importante que ignoramos. <br><br>  Hace décadas, la mayoría de los desarrolladores también confiaban en que otros escribieran programas de los que dependían, como sistemas operativos y compiladores.  Este software fue comprado de fuentes conocidas, a menudo con algún tipo de acuerdo de soporte.  Todavía hay espacio para <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">errores o destrucción total</a> .  Pero al menos sabíamos con quién estábamos tratando y, por regla general, podíamos usar medidas comerciales o legales de influencia. <br><br>  El fenómeno del software de código abierto, que se distribuye gratuitamente a través de Internet, ha suplantado en gran medida la antigua práctica de comprar software.  Cuando la reutilización aún era difícil, pocos proyectos introdujeron tales dependencias.  Aunque sus licencias generalmente renuncian a cualquier "garantía de valor comercial e idoneidad para un propósito particular", los proyectos construyeron una buena reputación.  Los usuarios han tenido muy en cuenta esta reputación al tomar sus decisiones.  En lugar de intervenciones comerciales y legales, vino el apoyo reputacional.  Muchos paquetes comunes de esa época todavía gozan de una buena reputación: por ejemplo, BLAS (publicado en 1979), Netlib (1987), libjpeg (1991), LAPACK (1992), HP STL (1994) y zlib (1995). <br><br>  Los administradores de lotes han reducido el modelo de reutilización de código a una simplicidad extrema: ahora los desarrolladores pueden compartir el código con precisión para funciones individuales en docenas de líneas.  Este es un gran logro técnico.  Hay innumerables paquetes disponibles, y un proyecto puede incluir una gran cantidad de ellos, pero los mecanismos de confianza de código comercial, legal o de reputación son cosa del pasado.  Confiamos en más código, aunque hay menos razones para confiar. <br><br>  El costo de hacer una mala adicción puede verse como la suma de todos los posibles malos resultados en una serie del precio de cada mal resultado multiplicado por su probabilidad (riesgo). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/91e/283/06e/91e28306eee279495e5a15cc2b672625.png"></div><br>  El precio de un mal resultado depende del contexto en el que se utiliza la dependencia.  En un extremo del espectro hay un proyecto de pasatiempo personal donde el precio de la mayoría de los malos resultados es cercano a cero: solo te diviertes, los errores no tienen un impacto real, excepto por un poco más de tiempo, y la depuración de ellos puede ser incluso divertida.  Por lo tanto, la probabilidad de riesgo es casi irrelevante: se multiplica por cero.  En el otro extremo del espectro está el software de producción, que debe ser compatible durante años.  Aquí, el costo de la dependencia puede ser muy alto: los servidores pueden caerse, los datos confidenciales pueden divulgarse, los clientes pueden sufrir, las empresas incluso pueden ir a la quiebra.  En producción, es mucho más importante evaluar y minimizar el riesgo de una falla grave. <br><br>  Independientemente del precio esperado, existen algunos enfoques para evaluar y reducir los riesgos de agregar dependencias.  Es probable que los administradores de paquetes se optimicen para reducir estos riesgos, mientras que hasta ahora se han centrado en reducir el costo de descarga e instalación. <br><br><h1>  Verificación de dependencia </h1><br>  No contrataría a un desarrollador del que nunca haya oído hablar y del que no sepa nada.  Primero, aprenderá algo sobre él: verifique los enlaces, realice una entrevista, etc.  Antes de depender del paquete que encontró en Internet, también es aconsejable aprender un poco sobre este paquete. <br><br>  Una comprobación básica puede dar una idea de la probabilidad de problemas al intentar usar este código.  Si se encuentran problemas menores durante la inspección, puede tomar medidas para eliminarlos.  Si el cheque revela problemas serios, puede ser mejor no usar el paquete: puede encontrar uno más adecuado, o tal vez necesite desarrollarlo usted mismo.  Recuerde que los paquetes de código abierto son publicados por los autores con la esperanza de que sean útiles, pero sin garantizar la usabilidad o el soporte.  En el caso de un fallo de producción, depende de usted depurarlo.  Como advirtió la primera <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Licencia Pública General de GNU</a> , “todo el riesgo asociado con la calidad y el rendimiento del programa recae en usted.  Si el programa resulta defectuoso, usted correrá con los costos de todo el mantenimiento, reparación o corrección necesarios ". <br><br>  A continuación, describimos algunas consideraciones para verificar el paquete y decidir si depender de él. <br><br><h3>  Diseño </h3><br>  ¿Está clara la documentación del paquete?  ¿La API tiene un diseño claro?  Si los autores pueden explicar bien la API y el diseño a una persona, esto aumenta la probabilidad de que también expliquen bien la implementación de la computadora en el código fuente.  Escribir código para una API clara y bien diseñada es más simple, más rápido y probablemente menos propenso a errores.  ¿Han documentado los autores lo que esperan del código del cliente para ser compatible con futuras actualizaciones?  (Los ejemplos incluyen documentos de compatibilidad de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">C ++</a> y <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Go</a> ). <br><br><h3>  Calidad del código </h3><br>  ¿Está bien escrito el código?  Lee algunos fragmentos.  ¿Los autores parecen ser cuidadosos, concienzudos y consistentes?  ¿Se parece al código que desea depurar?  Puede que tenga que hacer esto. <br><br>  Desarrolle sus propias formas sistemáticas para verificar la calidad del código.  Algo simple, como compilar en C o C ++ con advertencias importantes del compilador activadas (por ejemplo, <code>-Wall</code> ), puede dar una idea de qué tan en serio trabajaron los desarrolladores para evitar varios comportamientos indefinidos.  Los idiomas recientes, como Go, Rust y Swift, usan la palabra clave <code>unsafe</code> para denotar código que viola el sistema de tipos;  mira cuánto código inseguro hay.  También son útiles herramientas semánticas más avanzadas como <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Infer</a> o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">SpotBugs</a> .  Las linters son menos útiles: debe ignorar los consejos estándar sobre temas como el estilo de paréntesis y centrarse en cuestiones semánticas. <br><br>  No se olvide de los métodos de desarrollo con los que puede no estar familiarizado.  Por ejemplo, la biblioteca SQLite viene como un archivo único con 200,000 códigos y un encabezado de 11,000 líneas, como resultado de la fusión de múltiples archivos.  El tamaño de estos archivos levanta inmediatamente la bandera roja, pero una investigación más exhaustiva conducirá al código fuente real para el desarrollo: un árbol de archivos tradicional con más de cien archivos fuente C, pruebas y scripts de soporte.  Resulta que la distribución de un solo archivo se crea automáticamente a partir de las fuentes originales: esto es más fácil para los usuarios finales, especialmente aquellos que no tienen administradores de dependencias.  (El código compilado también funciona más rápido porque el compilador ve más opciones de optimización). <br><br><h3>  Prueba </h3><br>  ¿Hay alguna prueba en el código?  ¿Puedes controlarlos?  ¿Pasan?  Las pruebas establecen que la funcionalidad principal del código es correcta, y señalan que el desarrollador está tratando seriamente de mantenerlo.  Por ejemplo, el árbol de desarrollo SQLite contiene un conjunto de pruebas increíblemente detallado con más de 30,000 casos de prueba individuales.  Existe <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">documentación para desarrolladores que</a> explica la estrategia de prueba.  Por otro lado, si hay pocas o ninguna prueba, o si las pruebas fallan, esto es una señal de alerta seria: es probable que los cambios futuros en el paquete conduzcan a regresiones que podrían detectarse fácilmente.  Si insiste en las pruebas en su código (¿verdad?), Debe proporcionar pruebas para el código que pasa a otros. <br><br>  Suponiendo que existan pruebas, ejecute y pase, puede recopilar información adicional ejecutando herramientas para analizar la cobertura del código, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">detectar condiciones de carrera</a> , verificar la asignación de memoria y detectar pérdidas de memoria. <br><br><h3>  Depuración </h3><br>  Encuentra el rastreador de errores para este paquete.  ¿Hay muchos mensajes de error abiertos?  ¿Cuánto tiempo han estado abiertos?  ¿Cuántos errores se corrigieron?  ¿Hay algún error solucionado recientemente?  Si hay muchas preguntas abiertas sobre errores reales, especialmente no cerrados durante mucho tiempo, esta es una mala señal.  Por otro lado, si los errores son raros y se solucionan rápidamente, eso es genial. <br><br><h3>  Apoyo </h3><br>  Mira la historia de los commits.  ¿Cuánto tiempo se ha mantenido activamente el código?  ¿Se apoya activamente ahora?  Es probable que los paquetes que han sido respaldados activamente durante un largo período de tiempo sigan siendo compatibles.  ¿Cuántas personas están trabajando en el paquete?  Muchos paquetes son proyectos personales que los desarrolladores crean para el entretenimiento en su tiempo libre.  Otros son el resultado de miles de horas de trabajo para un grupo de desarrolladores pagados.  En general, los paquetes del segundo tipo generalmente corrigen los errores más rápidamente, introducen constantemente nuevas funciones y, en general, están mejor soportados. <br><br>  Por otro lado, algunos códigos son realmente "perfectos".  Por ejemplo, <code>escape-string-regexp</code> de NPM puede que nunca necesite cambiarse nuevamente. <br><br><h3>  Uso </h3><br>  ¿Cuántos paquetes dependen de este código?  Los administradores de paquetes a menudo dan tales estadísticas, o puede ver en Internet con qué frecuencia otros desarrolladores mencionan este paquete.  Un mayor número de usuarios significa al menos el hecho de que para muchos el código funciona bastante bien, y los errores en él se notarán más rápidamente.  El uso generalizado también es una garantía parcial de servicio continuo: si un paquete ampliamente utilizado pierde su mantenedor, es muy probable que un usuario interesado asuma su rol. <br><br>  Por ejemplo, las bibliotecas como PCRE, Boost o JUnit son increíblemente ampliamente utilizadas.  Esto hace que sea más probable, aunque ciertamente no garantiza, que los errores que pueda haber encontrado ya estén corregidos porque otros los encontraron antes que usted. <br><br><h3>  Seguridad </h3><br>  ¿Funcionará este paquete con entradas inseguras?  Si es así, ¿qué tan resistente es a los datos maliciosos?  ¿Tiene errores que se mencionan en la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">National Vulnerability Database (NVD)</a> ? <br><br>  Por ejemplo, cuando en 2006 Jeff Dean y yo comenzamos a trabajar en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Google Code Search</a> ( <code>grep</code> para bases de códigos públicos), la popular biblioteca de expresiones regulares PCRE parecía ser la opción obvia.  Sin embargo, en una conversación con el equipo de seguridad de Google, aprendimos que PCRE tiene una larga historia de problemas, como desbordamientos de búfer, especialmente en el analizador.  Nosotros mismos estábamos convencidos de esto buscando PCRE en NVD.  Este descubrimiento no nos llevó inmediatamente a abandonar PCRE, sino que nos hizo pensar más cuidadosamente sobre las pruebas y el aislamiento. <br><br><h3>  Licencia </h3><br>  ¿El código tiene la licencia correcta?  ¿Tiene siquiera una licencia?  ¿La licencia es aceptable para su proyecto o empresa?  Una parte sorprendente de los proyectos de GitHub no tiene una licencia clara.  Su proyecto o empresa puede imponer restricciones adicionales a las licencias de dependencia.  Por ejemplo, Google <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">prohíbe el</a> uso de código bajo licencias como AGPL (demasiado estricto) y tipo WTFPL (demasiado vago). <br><br><h3>  Dependencias </h3><br>  ¿Este paquete tiene sus propias dependencias?  Las deficiencias en las dependencias indirectas son tan perjudiciales como las desventajas en las dependencias directas.  Los administradores de paquetes pueden enumerar todas las dependencias transitivas de un paquete dado, y cada una de ellas idealmente debería verificarse como se describe en esta sección.  Un paquete con muchas dependencias requerirá mucho trabajo. <br><br>  Muchos desarrolladores nunca han mirado la lista completa de dependencias transitivas de su código y no saben de qué dependen.  Por ejemplo, en marzo de 2016, la comunidad de usuarios de NPM descubrió que muchos proyectos populares, incluidos Babel, Ember y React, dependen indirectamente de un pequeño paquete llamado <code>left-pad</code> de una función de 8 líneas.  Descubrieron esto cuando el autor de <code>left-pad</code> eliminó el paquete de NPM, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">rompiendo inadvertidamente la</a> mayoría de los ensamblados de los usuarios de Node.js.  Y el <code>left-pad</code> no <code>left-pad</code> excepcional en este sentido.  Por ejemplo, el 30% de los 750,000 paquetes en NPM dependen, al menos indirectamente, de <code>escape-string-regexp</code> .  Adaptando la observación de Leslie Lamport de los sistemas distribuidos, el administrador de paquetes crea fácilmente una situación en la que una falla del paquete, cuya existencia ni siquiera conocía, podría inutilizar su propio código. <br><br><h1>  Pruebas de adicción </h1><br>  El proceso de verificación debe incluir la ejecución de sus propias pruebas de paquetes.  Si el paquete pasó la prueba y usted decide hacer que su proyecto dependa de él, el siguiente paso debería ser escribir nuevas pruebas enfocadas específicamente en la funcionalidad de su aplicación.  Estas pruebas a menudo comienzan como programas cortos e independientes para garantizar que pueda comprender el paquete API y que haga lo que piensa (si no puede entender o no hace lo que necesita, ¡deténgase de inmediato!).  Entonces vale la pena el esfuerzo adicional para convertir estos programas en pruebas automatizadas que se ejecutarán con nuevas versiones del paquete.  Si encuentra un error y tiene una solución potencial, puede reiniciar fácilmente estas pruebas para un proyecto específico y asegurarse de que la solución no rompa nada más. <br><br>  Se debe prestar especial atención a las áreas problemáticas identificadas durante la revisión de línea de base.  Para la búsqueda de código, por experiencia previa, sabíamos que PCRE a veces tarda mucho tiempo en ejecutar ciertas expresiones regulares.  Nuestro plan inicial era crear grupos de hilos separados para expresiones regulares "simples" y "complejas".  Una de las primeras pruebas fue un punto de referencia que comparó <code>pcregrep</code> con varias otras implementaciones de <code>grep</code> .  Cuando descubrimos que <code>pcregrep</code> era 70 veces más lento que el <code>grep</code> más rápido para un caso de prueba básico, comenzamos a repensar nuestro plan para usar PCRE.  A pesar de que finalmente abandonamos por completo PCRE, esta prueba permanece en nuestra base de código hoy. <br><br><h1>  Abstracción de dependencia </h1><br>  La dependencia del paquete es una solución de la que puede optar en el futuro.  Quizás las actualizaciones llevarán el paquete en una nueva dirección.  Se pueden encontrar serios problemas de seguridad.  Quizás aparezca la mejor opción.  Por todas estas razones, vale la pena simplificar la migración del proyecto a una nueva dependencia. <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si se llama a un paquete desde muchos lugares en el código fuente del proyecto, deberá realizar cambios en todos estos lugares diferentes para cambiar a una nueva dependencia. Peor aún, si el paquete se presenta en la API de su propio proyecto, la migración a una nueva dependencia requerirá realizar cambios en todo el código que llama a su API, y esto puede estar fuera de su control. Para evitar tales costos, tiene sentido definir su propia interfaz junto con un envoltorio delgado que implementa esta interfaz utilizando una dependencia. Tenga en cuenta que el contenedor debe incluir solo lo que el proyecto necesita de la dependencia, y no todo lo que ofrece la dependencia. Idealmente, esto le permite reemplazar más tarde otra dependencia igualmente adecuada, cambiando solo el contenedor.La migración de las pruebas para que cada proyecto use la nueva interfaz verifica la implementación de la interfaz y los contenedores, y también simplifica la prueba de cualquier posible reemplazo para la dependencia.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para la búsqueda de código, hemos desarrollado una clase abstracta </font></font><code>Regexp</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">que define la interfaz de búsqueda de código necesaria desde cualquier motor de expresión regular. </font><font style="vertical-align: inherit;">Luego escribieron una envoltura delgada alrededor de PCRE que implementa esta interfaz. </font><font style="vertical-align: inherit;">Este método facilitó la prueba de bibliotecas alternativas y evitó la introducción accidental del conocimiento de los componentes internos de PCRE en el resto del árbol de origen. </font><font style="vertical-align: inherit;">Esto, a su vez, asegura que, si es necesario, será fácil cambiar a otra dependencia.</font></font><br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Aislamiento de dependencia </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">También puede ser apropiado aislar la dependencia en tiempo de ejecución para limitar el posible daño causado por errores en ella. Por ejemplo, Google Chrome permite a los usuarios agregar dependencias al navegador: código de extensión. Cuando Chrome se lanzó por primera vez en 2008, introdujo una función crítica (ahora estándar en todos los navegadores) para </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">aislar cada extensión en un entorno limitado que se</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ejecuta en un proceso separado del sistema operativo. Un posible exploit en una extensión mal escrita </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">no tenía acceso automático a toda la memoria del navegador.</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y no pudo hacer llamadas inapropiadas al sistema. Para la búsqueda de código, hasta que descartamos el PCRE por completo, el plan era aislar al menos el analizador PCRE en un entorno limitado similar. Hoy, otra opción sería un sandbox ligero basado en hipervisor, como </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">gVisor</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . El aislamiento de dependencia reduce los riesgos asociados de ejecutar este código.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Incluso con estos ejemplos y otras opciones listas para usar, aislar código sospechoso en tiempo de ejecución sigue siendo demasiado complicado y rara vez se realiza. El verdadero aislamiento requerirá un lenguaje completamente seguro para la memoria, sin chocar con un código sin tipo. Estos son complejos no solo en lenguajes completamente inseguros, como C y C ++, sino también en lenguajes que proporcionan restringir operaciones inseguras, como Java cuando JNI está activado, o como Go, Rust y Swift cuando habilita sus funciones inseguras. Incluso en un lenguaje seguro para la memoria como JavaScript, el código a menudo tiene acceso a mucho más de lo que necesita. En noviembre de 2018, resultó que la última versión del paquete npm </font></font><code>event-stream</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(una API de transmisión funcional para eventos JavaScript) </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">contiene código malicioso confuso</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">agregó hace dos meses y medio. </font><font style="vertical-align: inherit;">El código recopiló billeteras bitcoin de los usuarios de la aplicación móvil Copay, obtuvo acceso a recursos del sistema completamente ajenos al procesamiento de flujos de eventos. </font><font style="vertical-align: inherit;">Una de las muchas formas posibles de protegerse contra este tipo de problemas sería un mejor aislamiento de la dependencia.</font></font><br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Abandono de la adicción. </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si la adicción parece demasiado arriesgada y no puede aislarla, la mejor opción puede ser abandonarla por completo, o al menos excluir las partes más problemáticas. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Por ejemplo, cuando entendemos mejor los riesgos de PCRE, nuestro plan para Google Code Search cambió de "usar la biblioteca PCRE directamente" a "usar PCRE, pero poner el analizador en la caja de arena", luego en "escribir un nuevo analizador de expresiones regulares, pero guardar el motor PCRE", luego en "escriba un nuevo analizador y conéctelo a otro motor de código abierto más eficiente". Más tarde, Jeff Dean y yo reescribimos el motor también, por lo que no quedaban dependencias y descubrimos el resultado: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RE2</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si solo necesita una pequeña parte de la dependencia, la forma más fácil es hacer una copia de lo que necesita (por supuesto, mantener los derechos de autor relevantes y otros avisos legales). </font><font style="vertical-align: inherit;">Usted asume la responsabilidad de la corrección de errores, el mantenimiento, etc., pero también está completamente aislado de los riesgos mayores. </font><font style="vertical-align: inherit;">Hay un </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dicho</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> en la </font><font style="vertical-align: inherit;">comunidad de desarrolladores de Go </font><font style="vertical-align: inherit;">: "Un poco de copia es mejor que un poco de dependencia".</font></font><br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Actualización de dependencia </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Durante mucho tiempo, la sabiduría generalmente aceptada en el software fue: "Si funciona, no toque nada". La actualización conlleva el riesgo de introducir nuevos errores; sin recompensa: si no necesita una nueva función, ¿por qué arriesgarse? Este enfoque ignora dos aspectos. Primero, el costo de una actualización gradual. En el software, la complejidad de realizar cambios en el código no se escala linealmente: diez pequeños cambios son menos trabajosos y más fáciles que un gran cambio correspondiente. En segundo lugar, la dificultad de detectar errores ya corregidos. Especialmente en el contexto de seguridad, donde los errores conocidos se explotan activamente, todos los días sin actualizar aumentan los riesgos de que los atacantes puedan aprovechar los errores en el código anterior.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Por ejemplo, considere la historia de Equifax 2017, que los ejecutivos contaron en detalle en </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">testimonios ante el Congreso</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. El 7 de marzo, se descubrió una nueva vulnerabilidad en Apache Struts y se lanzó una versión parcheada. El 8 de marzo, Equifax recibió una notificación de US-CERT sobre la necesidad de actualizar cualquier uso de Apache Struts. Equifax lanzó un escaneo del código fuente y la red el 9 y 15 de marzo, respectivamente; ni una sola exploración encontró servidores web vulnerables abiertos en Internet. El 13 de mayo, los atacantes encontraron servidores que los expertos de Equifax no encontraron. Utilizaron la vulnerabilidad Apache Struts para piratear la red Equifax y robaron información personal y financiera detallada sobre 148 millones de personas en los próximos dos meses. Finalmente, el 29 de julio, Equifax notó un hack y lo anunció públicamente el 4 de septiembre. A fines de septiembre, el CEO de Equifax, así como el CIO y CSO, habían renunciado y se había iniciado una investigación en el Congreso.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La experiencia de Equifax lleva al hecho de que, aunque los administradores de paquetes conocen las versiones que usan durante la compilación, necesita otros mecanismos para rastrear esta información durante la implementación en producción. Para el lenguaje Go, estamos experimentando con la inclusión automática del manifiesto de manifiesto en cada binario para que los procesos de implementación puedan escanear los binarios en busca de dependencias que requieran actualización. Go también hace que esta información esté disponible en tiempo de ejecución, para que los servidores puedan acceder a las bases de datos de errores conocidos e informar de manera independiente al sistema de monitoreo cuando necesiten actualizarse.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Una actualización rápida es importante, pero actualizar significa agregar un nuevo código al proyecto, lo que debería significar actualizar la evaluación de riesgos del uso de la dependencia en función de la nueva versión. Como mínimo, desea ver las diferencias que muestran los cambios realizados desde la versión actual a las versiones actualizadas, o al menos leer las notas de la versión para identificar las áreas problemáticas más probables en el código actualizado. Si cambia mucho código, por lo que las diferencias son difíciles de entender, esta también es información que puede incluir al actualizar su evaluación de riesgos.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Además, debe volver a ejecutar las pruebas escritas específicamente para el proyecto para asegurarse de que el paquete actualizado sea al menos tan adecuado para el proyecto como la versión anterior. También tiene sentido volver a ejecutar sus propias pruebas de paquetes. Si el paquete tiene sus propias dependencias, es posible que la configuración del proyecto use otras versiones de estas dependencias (más antiguas o más nuevas) que las utilizadas por los autores del paquete. La ejecución de sus propias pruebas de paquetes le permite identificar rápidamente problemas específicos de la configuración. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nuevamente, las actualizaciones no tienen que ser completamente automáticas. Antes de implementar versiones actualizadas </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, asegúrese de que sean apropiadas para su entorno</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si el proceso de actualización implica volver a ejecutar las pruebas de integración y calificación ya escritas, en la mayoría de los casos la demora en la actualización es más riesgosa que una actualización rápida. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La ventana para actualizaciones críticas de seguridad es especialmente pequeña. </font><font style="vertical-align: inherit;">Después de que Equifax pirateó, los equipos forenses de seguridad encontraron evidencia de que los atacantes (posiblemente diferentes) explotaron con éxito la vulnerabilidad Apache Struts en los servidores afectados el 10 de marzo, solo tres días después de que se divulgara públicamente. </font><font style="vertical-align: inherit;">Pero solo lanzaron un equipo allí </font></font><code>whoami</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Cuida tus adicciones </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Incluso después de todo esto, el trabajo no está terminado. Es importante continuar monitoreando las dependencias y, en algunos casos, incluso abandonarlas. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Primero, asegúrese de seguir usando versiones específicas de paquetes. La mayoría de los administradores de paquetes ahora le permiten grabar fácil o incluso automáticamente el hash criptográfico del código fuente esperado para una versión dada del paquete, y luego verificar este hash cuando el paquete se descarga nuevamente a otra computadora o en un entorno de prueba. Esto garantiza que la compilación utilizará el mismo código fuente de dependencia que probó y probó. Dichos controles impidieron al atacante</font></font><code>event-stream</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, inyecta automáticamente código malicioso en la versión ya lanzada 3.3.5. En cambio, el atacante tuvo que crear una nueva versión 3.3.6 y esperar a que la gente se actualice (sin mirar cuidadosamente los cambios). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">También es importante monitorear la aparición de nuevas dependencias indirectas: las actualizaciones pueden introducir fácilmente nuevos paquetes, de los cuales ahora depende el éxito de su proyecto. También merecen su atención. En el caso, el </font></font><code>event-stream</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">código malicioso estaba oculto en otro paquete </font></font><code>flatMap-stream</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, que </font></font><code>event-stream</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">se agregó como una nueva dependencia </font><font style="vertical-align: inherit;">en la nueva versión </font><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Las dependencias progresivas también pueden afectar el tamaño del proyecto. Durante el desarrollo de </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Google Sawzall</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- Lenguaje de procesamiento de registros JIT: en diferentes momentos, los autores descubrieron que el binario del intérprete principal contiene no solo JIT Sawzall, sino también intérpretes PostScript, Python y JavaScript. Cada vez, el culpable resultó ser dependencias no utilizadas declaradas por alguna biblioteca de Sawzall, combinadas con el hecho de que el sistema de compilación de Google utilizó completamente la nueva dependencia. Es por eso que el compilador Go genera un error al importar un paquete no utilizado. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La actualización es el momento natural para revisar su decisión de utilizar una dependencia cambiante. También es importante revisar periódicamente cualquier adicción que </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">no</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">está cambiando ¿Parece plausible que no haya problemas de seguridad u otros errores que corregir? ¿Se abandona el proyecto? Tal vez es hora de planificar un reemplazo para esta dependencia. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">También es importante verificar dos veces el registro de seguridad de cada dependencia. Por ejemplo, Apache Struts reveló serias vulnerabilidades en la ejecución remota de código en 2016, 2017 y 2018. Incluso si tiene muchos servidores que lo inician y lo actualizan rápidamente, este historial sugiere si vale la pena usarlo.</font></font><br><br><h1>  Conclusión </h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La era de la reutilización del software finalmente ha llegado, y no quiero minimizar los beneficios: trajo una transformación extremadamente positiva para los desarrolladores. Sin embargo, aceptamos esta transformación sin considerar completamente las posibles consecuencias. Las razones anteriores para confiar en las dependencias pierden relevancia al mismo tiempo cuando tenemos más dependencias que nunca.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El análisis crítico de dependencias específicas que describí en este artículo representa una cantidad significativa de trabajo y sigue siendo la excepción más que la regla. Pero dudo que haya desarrolladores que realmente estén trabajando duro para hacer esto para cada posible nueva adicción. Solo hice parte de este trabajo para algunas de mis propias dependencias. Básicamente, toda la solución se reduce a lo siguiente: "veamos qué sucede". Con demasiada frecuencia, algo más parece demasiado esfuerzo. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pero los ataques de Copago y Equifax son advertencias claras de problemas reales en la forma en que usamos las dependencias de software hoy en día. No debemos ignorar las advertencias. Ofrezco tres recomendaciones generales.</font></font><br><br><ol><li> <i> </i> . ,    ,   ,   .    ,       . </li><li> <i>     </i> .        ,  ,   .    ,  ,                .   ,      ,      ,    . </li><li> <i>    </i> .         .               . ,            .   ,   ,     .  ,          ,             API.        . </li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hay muchos buenos programas. </font><font style="vertical-align: inherit;">Trabajemos juntos y descubramos cómo usarlo de manera segura.</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/443620/">https://habr.com/ru/post/443620/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../443608/index.html">Smart Home / Actualizaciones en Lazurite</a></li>
<li><a href="../443612/index.html">Usamos viejos discos duros malos</a></li>
<li><a href="../443614/index.html">YouTrack 2019.1: seleccione paneles ágiles, campos de tarjetas personalizables en paneles ágiles y más</a></li>
<li><a href="../443616/index.html">35% de rendimiento de stock en datos alternativos</a></li>
<li><a href="../443618/index.html">Emulador de computadora de los 80 en el navegador</a></li>
<li><a href="../443624/index.html">Digital Works y VMware: VDI está muerto, viva VDI</a></li>
<li><a href="../443626/index.html">Bienvenido a la Top 3D Expo 2019</a></li>
<li><a href="../443628/index.html">Funciones de Bessel en SymPy Symbolic Math Program</a></li>
<li><a href="../443630/index.html">Cómo implementar un lenguaje de programación en JavaScript. Parte 1: analizador</a></li>
<li><a href="../443636/index.html">Morse Key y Klopfer</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>