<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🗿 💜 👎🏿 Perpustakaan generator kode assembler untuk mikrokontroler AVR. Bagian 1 👨‍🚀 ✊🏾 👩🏽‍🤝‍👨🏼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Bagian 2. Memulai → 
 Perpustakaan Generator Kode Assembler untuk Mikrokontroler AVR 
 Bagian 1. Kenalan pertama 


 Selamat siang, Khabrovit sayang. ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Perpustakaan generator kode assembler untuk mikrokontroler AVR. Bagian 1</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/462409/"><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 2. Memulai →</a> </p><br><h1>  Perpustakaan Generator Kode Assembler untuk Mikrokontroler AVR </h1><br><h2>  Bagian 1. Kenalan pertama </h2><br><p>  Selamat siang, Khabrovit sayang.  Saya ingin menyampaikan kepada Anda proyek berikutnya (dari banyak sekali yang tersedia) untuk pemrograman mikrokontroler populer dari seri AVR. </p><br><p>  Adalah mungkin untuk menghabiskan banyak teks untuk menjelaskan mengapa ini diperlukan, tetapi sebaliknya, lihat saja contoh bagaimana hal itu berbeda dari solusi lain.  Dan semua penjelasan dan perbandingan dengan sistem pemrograman yang ada akan, sebagaimana diperlukan, dalam proses parsing contoh.  Perpustakaan saat ini sedang dalam proses penyelesaian, sehingga implementasi beberapa fungsi mungkin tidak terlihat optimal.  Juga, beberapa tugas yang ditugaskan untuk programmer dalam versi ini seharusnya lebih dioptimalkan atau diotomatisasi. </p><a name="habracut"></a><br><p>  Jadi mari kita mulai.  Saya ingin segera mengklarifikasi bahwa materi yang disajikan tidak boleh dianggap sebagai deskripsi yang lengkap, tetapi hanya sebagai demonstrasi dari beberapa fitur perpustakaan yang dikembangkan untuk membantu memahami betapa menariknya pendekatan ini bagi pembaca. </p><br><p>  Kami tidak akan menyimpang dari praktik yang berlaku dan mulai dengan contoh klasik, semacam "Halo dunia" untuk mikrokontroler.  Yaitu, kami mengedipkan LED yang terhubung ke salah satu kaki prosesor.  Mari kita buka VisualStudio dari Microsoft (rilis apa pun akan dilakukan) dan buat aplikasi konsol untuk C #.  Bagi mereka yang tidak tahu, Edisi Komunitas, cukup untuk bekerja, benar-benar gratis. </p><br><p>  Sebenarnya teks itu sendiri adalah sebagai berikut: </p><br><div class="spoiler">  <b class="spoiler_title">Contoh Kode Sumber 1</b> <div class="spoiler_text"><pre><code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> NanoRTOSLib; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System; <span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> <span class="hljs-title"><span class="hljs-title">ConsoleApp</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Program</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Main</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] args</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> m = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Mega328(); m.PortB[<span class="hljs-number"><span class="hljs-number">0</span></span>].Mode = ePinMode.OUT; m.PortB.Activate(); m.LOOP(m.TempL, (r, l) =&gt; m.GO(l), (r) =&gt; { m.PortB[<span class="hljs-number"><span class="hljs-number">0</span></span>].Toggle();}); Console.WriteLine(AVRASM.Text(m)); } } }</code> </pre> </div></div><br><p>  Tentu saja, agar semuanya berfungsi dan Anda membutuhkan perpustakaan yang saya wakili. <br>  Setelah mengkompilasi dan menjalankan program, pada output konsol kita akan melihat hasil berikut dari program ini. </p><br><div class="spoiler">  <b class="spoiler_title">Hasil Kompilasi Contoh 1</b> <div class="spoiler_text"><pre> <code class="dos hljs">#include “common.inc” RESET: ldi r16, high(RAMEND) out SPH,r16 ldi r16, low(RAMEND) out SPL,r16 outi DDRB,<span class="hljs-number"><span class="hljs-number">0</span></span>x1 L0000: <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> TempL,PORTB ldi TempH,<span class="hljs-number"><span class="hljs-number">1</span></span> eor TempL,TempH out PORTB,TempL xjmp L0000 .DSEG</code> </pre> </div></div><br><p>  Jika Anda menyalin hasilnya ke lingkungan apa pun yang tahu cara bekerja dengan assembler AVR dan menghubungkan <i>perpustakaan</i> makro <i>Common.inc</i> ( <i>perpustakaan</i> makro juga merupakan salah satu komponen sistem pemrograman yang disajikan dan bekerja bersama dengan <i>NanoRTOSLib</i> ), maka program ini dapat dikompilasi dan diperiksa pada emulator atau chip nyata dan pastikan semuanya bekerja. </p><br><p>  Pertimbangkan kode sumber program lebih terinci.  Pertama-tama, kami menetapkan variabel tipe kristal yang digunakan.  Selanjutnya, atur mode keluaran digital untuk bit nol port B kristal dan aktifkan port.  Baris berikutnya terlihat sedikit aneh, tetapi artinya cukup sederhana.  Di dalamnya, kita mengatakan bahwa kita ingin mengatur infinite loop, di mana kita mengubah nilai bit nol dari port B ke kebalikannya.  Baris terakhir dari program ini benar-benar memvisualisasikan hasil dari semua yang sebelumnya ditulis dalam bentuk kode assembler.  Semuanya sangat sederhana dan kompak.  Dan hasilnya praktis tidak berbeda dari apa yang bisa ditulis di assembler.  Hanya ada dua pertanyaan pada kode keluaran: yang pertama - mengapa menginisialisasi tumpukan jika kita masih tidak menggunakannya, dan <i>xjmp seperti</i> apa?  Jawaban untuk pertanyaan pertama dan sekaligus penjelasan mengapa assembler ditampilkan, daripada HEX yang sudah selesai, adalah sebagai berikut: hasil dalam bentuk assembler memungkinkan Anda untuk menganalisis dan mengoptimalkan program lebih lanjut, memungkinkan programmer untuk memilih dan memodifikasi fragmen kode yang tidak disukainya.  Dan inisialisasi tumpukan ditinggalkan setidaknya karena alasan-alasan itu tanpa menggunakan tumpukan Anda dapat datang dengan tidak banyak program.  Namun, jika Anda tidak menyukainya, jangan ragu untuk membersihkannya.  Output ke assembler untuk tujuan ini dimaksudkan.  Adapun <i>xjmp</i> , ini adalah contoh menggunakan makro untuk meningkatkan keterbacaan dari assembler output.  Secara khusus, <i>xjmp</i> adalah pengganti <i>jmp</i> dan <i>rjmp</i> dengan substitusi yang benar tergantung pada panjang transisi. </p><br><p>  Jika Anda mengisi program dengan sebuah chip, maka tentu saja kita tidak akan melihat berkedip dioda, terlepas dari kenyataan bahwa keadaan pin berubah.  Itu terjadi terlalu cepat untuk melihatnya melalui mata.  Oleh karena itu, kami mempertimbangkan program berikut, di mana kami terus berkedip dengan dioda, tetapi agar dapat dilihat.  Sebagai contoh, penundaan 0,5 detik cukup cocok: tidak terlalu cepat dan tidak terlalu lambat.  Dimungkinkan untuk membuat banyak loop bersarang dengan NOP untuk membentuk penundaan, tetapi kami akan melewatkan langkah ini karena tidak menambahkan apa pun pada deskripsi kapabilitas perpustakaan dan segera memanfaatkan peluang untuk menggunakan perangkat keras yang tersedia.  Kami mengubah aplikasi kami sebagai berikut. </p><br><div class="spoiler">  <b class="spoiler_title">Contoh Kode Sumber 2</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System; <span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> <span class="hljs-title"><span class="hljs-title">ConsoleApp</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Program</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Main</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] args</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> m = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Mega328(); m.PortB[<span class="hljs-number"><span class="hljs-number">0</span></span>].Mode = ePinMode.OUT; m.PortB.Activate(); m.WDT.Clock = eWDTClock.WDT500ms; m.WDT.OnTimeout = () =&gt; m.PortB[<span class="hljs-number"><span class="hljs-number">0</span></span>].Toggle(); m.WDT.Activate(); m.EnableInterrupt(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> loop = AVRASM.newLabel(); m.GO(loop); Console.WriteLine(AVRASM.Text(m)); } } }</code> </pre> </div></div><br><p>  Tentunya, program ini mirip dengan yang sebelumnya, jadi kami hanya akan mempertimbangkan apa yang telah berubah.  Pertama, dalam contoh ini, kami menggunakan WDT (pengawas waktu).  Untuk bekerja dengan penundaan besar yang tidak membutuhkan keakuratan ekstrem, ini adalah pilihan terbaik.  Yang diperlukan untuk menggunakannya adalah mengatur frekuensi yang diperlukan dengan mengatur pembagi melalui properti WDT.Clock dan menentukan tindakan yang harus dilakukan pada saat acara dipicu, dengan menetapkan kode melalui properti WDT.OnTimeout.  Karena kita perlu interupsi untuk berfungsi, mereka harus diaktifkan dengan perintah EnableInterrupt.  Namun siklus utama bisa diganti oleh boneka.  Di dalamnya, kami masih tidak berencana untuk melakukan apa pun.  Oleh karena itu, kami akan mendeklarasikan dan menetapkan label dan membuat transisi tanpa syarat untuk mengatur siklus kosong.  Jika Anda lebih suka LOOP - silakan.  Hasil ini tidak akan berubah. <br>  Nah, di final, mari kita lihat kode yang dihasilkan. </p><br><div class="spoiler">  <b class="spoiler_title">Hasil Kompilasi Contoh 2</b> <div class="spoiler_text"><pre> <code class="dos hljs">#include “common.inc” jmp RESET reti ; IRQ0 Handler nop reti ;IRQ1 Handler nop reti ;PC_INT0 Handler nop reti ;PC_INT1 Handler nop reti ;PC_INT2 Handler nop jmp WDT ;Watchdog Timer Handler RESET: ldi r16, high(RAMEND) out SPH,r16 ldi r16, low(RAMEND) out SPL,r16 outi DDRB,<span class="hljs-number"><span class="hljs-number">0</span></span>x1 ldi TempL, (<span class="hljs-number"><span class="hljs-number">1</span></span>&lt;&lt;WDCE) | (<span class="hljs-number"><span class="hljs-number">1</span></span>&lt;&lt;WDE) sts WDTCSR,TempL ldi TempL, <span class="hljs-number"><span class="hljs-number">0</span></span>x42 sts WDTCSR,TempL sei L0000: xjmp L0000 WDT: push r17 push r16 <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> r16,SREG push r16 <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> TempL,PORTB ldi TempH,<span class="hljs-number"><span class="hljs-number">1</span></span> eor TempL,TempH out PORTB,TempL pop r16 out SREG,r16 pop r16 pop r17 reti .DSEG</code> </pre> </div></div><br><p>  Mereka yang terbiasa dengan prosesor ini tidak diragukan lagi akan memiliki pertanyaan di mana beberapa vektor interupsi telah hilang.  Di sini kami menggunakan logika berikut - jika kode tidak digunakan - kode tidak diperlukan.  Oleh karena itu, tabel interupsi berakhir pada vektor yang terakhir digunakan. <br>  Terlepas dari kenyataan bahwa program mengatasi tugas dengan sempurna, yang paling pilih-pilih mungkin tidak menyukai kenyataan bahwa serangkaian kemungkinan penundaan terbatas, dan langkahnya terlalu kasar.  Oleh karena itu, kami akan mempertimbangkan cara lain, dan pada saat yang sama, kami akan melihat bagaimana kerja dengan pengatur waktu diatur di perpustakaan.  Dalam kristal Mega328, yang diambil sebagai sampel, ada sebanyak 3 di antaranya.  2 8-bit dan satu 16-bit.  Arsitek berusaha sangat keras untuk berinvestasi sebanyak mungkin fitur dalam timer ini, oleh karena itu pengaturan mereka cukup banyak. </p><br><p>  Pertama, kami menghitung penghitung mana yang harus digunakan untuk keterlambatan 0,5 detik.  Jika kita mengambil frekuensi jam kristal 16 MHz, bahkan dengan pembagi periferal maksimum tidak mungkin untuk tetap berada dalam penghitung 8-bit.  Oleh karena itu, kami tidak akan mempersulit dan menggunakan penghitung Timer1 16-bit yang hanya tersedia untuk kami. </p><br><p>  Sebagai hasilnya, program ini mengambil bentuk berikut: </p><br><div class="spoiler">  <b class="spoiler_title">Contoh Kode Sumber 3</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> NanoRTOSLib; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System; <span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> <span class="hljs-title"><span class="hljs-title">ConsoleApp</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Program</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Main</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] args</span></span></span><span class="hljs-function">)</span></span> {<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> m = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Mega328(); m.FCLK = <span class="hljs-number"><span class="hljs-number">16000000</span></span>; m.CKDIV8 = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> bit1 = m.PortB[<span class="hljs-number"><span class="hljs-number">0</span></span>]; bit1.Mode = ePinMode.OUT; m.PortB.Activate(); m.Timer1.Mode = eWaveFormMode.CTC_OCRA; m.Timer1.Clock = eTimerClockSource.CLK256; m.Timer1.OCRA = (<span class="hljs-keyword"><span class="hljs-keyword">ushort</span></span>)((<span class="hljs-number"><span class="hljs-number">0.5</span></span> * m.FCLK) / <span class="hljs-number"><span class="hljs-number">256</span></span>); m.Timer1.OnCompareA = () =&gt; bit1.Toggle(); m.Timer1.Activate(); m.EnableInterrupt(); m.LOOP(m.TempH, (r, l) =&gt; m.GO(l), (r) =&gt; { }); Console.WriteLine(AVRASM.Text(m)); } } }</code> </pre> </div></div><br><p>  Karena kami menggunakan generator utama sebagai sumber jam untuk penghitung waktu kami, untuk perhitungan penundaan yang benar, Anda harus menentukan frekuensi jam prosesor, pengaturan pembagi, dan sekering jam periferal.  Teks utama dari program ini adalah mengatur timer ke mode yang diinginkan.  Di sini, seorang musyawarah 256 dan tidak maksimal secara sengaja dipilih untuk pencatatan jam kerja, karena ketika Anda memilih pembagi 1024 untuk frekuensi jam yang diperlukan 500ms, yang ingin kami dapatkan, diperoleh angka pecahan. </p><br><p>  Kode assembler yang dihasilkan dari program kami akan terlihat seperti ini: </p><br><div class="spoiler">  <b class="spoiler_title">Hasil Kompilasi Contoh 3</b> <div class="spoiler_text"><pre> <code class="dos hljs">#include “common.inc” jmp RESET reti ; IRQ0 Handler nop reti ;IRQ1 Handler nop reti ;PC_INT0 Handler nop reti ;PC_INT1 Handler nop reti ;PC_INT2 Handler nop reti ;Watchdog Timer Handler nop reti ;Timer2 Compare A Handler nop reti ;Timer2 Compare B Handler nop reti ;Timer2 Overflow Handler nop reti ;Timer1 Capture Handler nop jmp TIM1_COMPA ;Timer1 Compare A Handler RESET: ldi r16, high(RAMEND) out SPH,r16 ldi r16, low(RAMEND) out SPL,r16 outi DDRB,<span class="hljs-number"><span class="hljs-number">0</span></span>x1 outiw OCR1A,<span class="hljs-number"><span class="hljs-number">0</span></span>x7A12 outi TCCR1A,<span class="hljs-number"><span class="hljs-number">0</span></span> outi TCCR1B,<span class="hljs-number"><span class="hljs-number">0</span></span>xC outi TCCR1C,<span class="hljs-number"><span class="hljs-number">0</span></span>x0 outi TIMSK1,<span class="hljs-number"><span class="hljs-number">0</span></span>x2 outi DDRB,<span class="hljs-number"><span class="hljs-number">0</span></span>x1 sei L0000: xjmp L0000 TIM1_COMPA: push r17 push r16 <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> r16,SREG push r16 <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> TempL,PORTB ldi TempH,<span class="hljs-number"><span class="hljs-number">1</span></span> eor TempL,TempH out PORTB,TempL pop r16 out SREG,r16 pop r16 pop r17 reti .DSEG</code> </pre> </div></div><br><p>  Tampaknya tidak ada lagi yang perlu dikomentari.  Kami menginisialisasi perangkat, mengkonfigurasi interupsi dan menikmati program. </p><br><p>  Bekerja melalui interupsi adalah cara termudah untuk membuat program untuk bekerja secara real time.  Sayangnya, beralih antara tugas paralel menggunakan hanya penangan interupsi untuk melakukan tugas ini tidak selalu mungkin.  Pembatasannya adalah larangan penanganan interupsi bersarang, yang mengarah pada fakta bahwa sampai prosesor keluar, prosesor tidak merespons semua gangguan lain, yang dapat menyebabkan hilangnya kejadian jika prosesor berjalan terlalu lama. </p><br><p>  Solusinya adalah dengan memisahkan kode registrasi acara dan pemrosesannya.  Inti pemrosesan multi-utas paralel dari perpustakaan diatur sedemikian rupa sehingga ketika suatu peristiwa terjadi, penangan interupsi hanya mendaftarkan peristiwa yang diberikan dan, jika perlu, melakukan operasi pengambilan data minimum yang diperlukan, dan semua pemrosesan dilakukan dalam aliran utama.  Kernel secara berurutan memeriksa keberadaan flag yang tidak diproses dan, jika ditemukan, melanjutkan ke tugas yang sesuai. </p><br><p>  Menggunakan pendekatan ini menyederhanakan desain sistem dengan beberapa tugas tidak sinkron, memungkinkan Anda untuk mempertimbangkan masing-masing secara terpisah, tanpa berfokus pada masalah peralihan sumber daya di antara tugas.  Sebagai contoh, perhatikan implementasi dua tugas independen, yang masing-masing mengalihkan outputnya dengan penundaan tertentu. </p><br><div class="spoiler">  <b class="spoiler_title">Contoh Kode Sumber 4</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> NanoRTOSLib; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System; <span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> <span class="hljs-title"><span class="hljs-title">ConsoleApp</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Program</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Main</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] args</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> m = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Mega328(); m.FCLK = <span class="hljs-number"><span class="hljs-number">16000000</span></span>; m.CKDIV8 = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; m.PortB.Direction(<span class="hljs-number"><span class="hljs-number">0x07</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> bit1 = m.PortB[<span class="hljs-number"><span class="hljs-number">1</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> bit2 = m.PortB[<span class="hljs-number"><span class="hljs-number">2</span></span>]; m.PortB.Activate(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> tasks = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Parallel(m, <span class="hljs-number"><span class="hljs-number">4</span></span>); tasks.Heap = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StaticHeap(tasks, <span class="hljs-number"><span class="hljs-number">64</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> t1 = tasks.CreateTask((tsk) =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> loop = AVRASM.NewLabel(); bit1.Toggle(); tsk.Delay(<span class="hljs-number"><span class="hljs-number">32</span></span>); tsk.TaskContinue(loop); },<span class="hljs-string"><span class="hljs-string">"Task1"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> t2 = tasks.CreateTask((tsk) =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> loop = AVRASM.NewLabel(); bit2.Toggle(); tsk.Delay(<span class="hljs-number"><span class="hljs-number">48</span></span>); tsk.TaskContinue(loop); }, <span class="hljs-string"><span class="hljs-string">"Task2"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> ca = tasks.ContinuousActivate(tasks.AlwaysOn, t1); tasks.ActivateNext(ca, tasks.AlwaysOn, t2); ca.Dispose(); m.EnableInterrupt(); tasks.Loop(); Console.WriteLine(AVRASM.Text(m)); } } }</code> </pre> </div></div><br><p>  Dalam tugas ini, kami mengkonfigurasi nol dan output pertama port B ke output dan mengubah nilai dari 0 ke 1 dan sebaliknya dengan periode 32 ms untuk nol dan 48 ms untuk output pertama.  Tugas terpisah bertanggung jawab untuk mengelola setiap port.  Hal pertama yang perlu diperhatikan adalah definisi instance Parallel.  Kelas ini adalah inti dari manajemen tugas.  Dalam konstruktornya, kami menentukan jumlah maksimum utas yang berjalan secara simultan.  Berikut ini adalah alokasi memori untuk menyimpan aliran data.  Kelas StaticHeap yang digunakan dalam contoh mengalokasikan sejumlah byte untuk setiap aliran.  Untuk mengatasi masalah kami, ini dapat diterima, dan penggunaan alokasi memori tetap dibandingkan dengan dinamis menyederhanakan algoritma dan membuat kode lebih kompak dan lebih cepat.  Lebih lanjut dalam kode, kami menguraikan serangkaian tugas yang dirancang untuk dijalankan di bawah kendali kernel.  Anda harus memperhatikan fungsi Tunda asinkron, yang kami gunakan untuk membentuk penundaan.  Keunikannya adalah ketika fungsi ini dipanggil, penundaan yang diperlukan diatur dalam pengaturan aliran, dan kontrol ditransfer ke kernel.  Setelah interval yang ditetapkan berlalu, kernel mengembalikan kontrol ke tugas dari perintah yang mengikuti perintah Delay.  Fitur lain dari tugas adalah pemrograman perilaku aliran tugas setelah selesai dalam perintah tugas terakhir.  Dalam kasus kami, kedua tugas dikonfigurasikan untuk dieksekusi dalam loop tak terbatas dengan kontrol kembali ke kernel pada akhir setiap siklus.  Jika perlu, menyelesaikan tugas dapat membebaskan utas atau meneruskannya untuk melakukan tugas lain. </p><br><p>  Alasan untuk memohon tugas adalah untuk mengaktifkan sinyal yang ditugaskan untuk aliran tugas.  Sinyal dapat diaktifkan baik secara terprogram dan perangkat keras dengan menyela dari perangkat periferal.  Panggilan tugas mengatur ulang sinyal.  Pengecualian adalah sinyal yang selalu ditentukan sebelumnya, yang selalu dalam keadaan aktif.  Hal ini memungkinkan untuk membuat tugas yang akan menerima kendali di setiap siklus pemungutan suara.  Fungsi LOOP diperlukan untuk menjalankan loop eksekusi utama.  Sayangnya, ukuran kode keluaran saat menggunakan Paralel sudah menjadi jauh lebih besar daripada contoh sebelumnya (sekitar 600 perintah) dan tidak dapat sepenuhnya dikutip dalam artikel. </p><br><p>  Dan untuk manis - sesuatu yang lebih seperti proyek langsung, yaitu termometer digital.  Semuanya selalu sederhana.  Sensor digital dengan antarmuka SPI, indikator 7-segmen 4-digit dan beberapa utas pemrosesan untuk menjaga semuanya tetap dingin.  Dalam satu, kami menggerakkan siklus untuk indikasi dinamis, di lain, peristiwa yang memicu siklus membaca suhu, di ketiga kami membaca nilai yang diterima dari sensor dan mengubahnya dari kode biner ke BCD dan kemudian menjadi kode segmen untuk buffer indikasi dinamis. </p><br><p>  Program itu sendiri adalah sebagai berikut. </p><br><div class="spoiler">  <b class="spoiler_title">Contoh Kode Sumber 5</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> NanoRTOSLib; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System; <span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> <span class="hljs-title"><span class="hljs-title">ConsoleApp</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Program</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Main</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] args</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> m = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Mega328(); m.FCLK = <span class="hljs-number"><span class="hljs-number">16000000</span></span>; m.CKDIV8 = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> led7s = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Led_7(); led7s.SegPort = m.PortC; led7s.Activate(); m.PortD.Direction(<span class="hljs-number"><span class="hljs-number">0xFF</span></span>); m.PortD.Activate(); m.PortB[<span class="hljs-number"><span class="hljs-number">0</span></span>].Mode = ePinMode.OUT; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> tc77 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> TC77(); tc77.CS = m.PortB[<span class="hljs-number"><span class="hljs-number">0</span></span>]; tc77.Port = m.SPI; m.Timer0.Clock = eTimerClockSource.CLK64; m.Timer0.Mode = eWaveFormMode.Normal; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> reader = m.DREG(<span class="hljs-string"><span class="hljs-string">"Temperature"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> bcdRes = m.DREG(<span class="hljs-string"><span class="hljs-string">"digits"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> tmp = m.BYTE(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> bcd = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BCD(reader, bcdRes); m.subroutines.Add(bcd); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> os = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Parallel(m, <span class="hljs-number"><span class="hljs-number">4</span></span>); os.Heap = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StaticHeap(os, <span class="hljs-number"><span class="hljs-number">64</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> tmrSig = os.AddSignal(m.Timer0.OVF_Handler); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> spiSig = os.AddSignal(m.SPI.Handler, () =&gt; { m.SPI.Read(m.TempL); m.TempL.MStore(tmp); }); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> actuator = os.CreateTask((tsk) =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> loop = AVRASM.NewLabel(); tc77.ReadTemperatureAsync(); tsk.Delay(<span class="hljs-number"><span class="hljs-number">16</span></span>); tsk.TaskContinue(loop); }, <span class="hljs-string"><span class="hljs-string">"actuator"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> treader = os.CreateTask((tsk) =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> loop = AVRASM.NewLabel(); tc77.ReadTemperatureCallback(os, reader, tmp); reader &gt;&gt;= <span class="hljs-number"><span class="hljs-number">7</span></span>; m.CALL(bcd); tsk.TaskContinue(loop); }, <span class="hljs-string"><span class="hljs-string">"reader"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> display = os.CreateTask((tsk) =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> loop = AVRASM.NewLabel(); m.PortD.Write(<span class="hljs-number"><span class="hljs-number">0xFE</span></span>); m.TempQL.Load(bcdRes.Low); m.TempQL &amp;= <span class="hljs-number"><span class="hljs-number">0x0F</span></span>; led7s.Show(m.TempQL); os.AWAIT(); m.PortD.Write(<span class="hljs-number"><span class="hljs-number">0xFD</span></span>); m.TempQL.Load(bcdRes.Low); m.TempQL &gt;&gt;= <span class="hljs-number"><span class="hljs-number">4</span></span>; led7s.Show(m.TempQL); os.AWAIT(); m.PortD.Write(<span class="hljs-number"><span class="hljs-number">0xFB</span></span>); m.TempQL.Load(bcdRes.High); m.TempQL &amp;= <span class="hljs-number"><span class="hljs-number">0x0F</span></span>; led7s.Show(m.TempQL); os.AWAIT(); m.PortD.Write(<span class="hljs-number"><span class="hljs-number">0xF7</span></span>); m.TempQL.Load(bcdRes.High); m.TempQL &gt;&gt;= <span class="hljs-number"><span class="hljs-number">4</span></span>; led7s.Show(m.TempQL); os.AWAIT(); tsk.TaskContinue(loop); }, <span class="hljs-string"><span class="hljs-string">"display"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> ct = os.ContinuousActivate(os.AlwaysOn, actuator); os.ActivateNext(ct, spiSig, treader); os.ActivateNext(ct, tmrSig, display); tc77.Activate(); m.Timer0.Activate(); m.EnableInterrupt(); os.Loop(); Console.WriteLine(AVRASM.Text(m)); } } }</code> </pre> </div></div><br><p>  Jelas bahwa ini bukan konsep kerja, tetapi hanya demo teknologi yang dirancang untuk menunjukkan kemampuan perpustakaan NanoRTOS.  Tetapi bagaimanapun juga, kurang dari 100 baris sumber dan kurang dari 1kb kode keluaran adalah hasil yang cukup baik untuk aplikasi yang bisa diterapkan. </p><br><p>  Dalam artikel-artikel berikut, saya berencana, jika berminat pada proyek ini, untuk membahas lebih rinci tentang prinsip-prinsip dan fitur pemrograman menggunakan perpustakaan ini. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id462409/">https://habr.com/ru/post/id462409/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id462397/index.html">Cara Menangkap Kucing dengan TLA +</a></li>
<li><a href="../id462399/index.html">Analisis statis akan meningkatkan basis kode proyek C ++ yang kompleks</a></li>
<li><a href="../id462401/index.html">Pengembang Dosa Mematikan</a></li>
<li><a href="../id462403/index.html">Pemilihan ukuran monitor: teori ukuran sudut, dasar pemikiran dan perbandingan</a></li>
<li><a href="../id462407/index.html">Intisari Desain Makanan Juli 2019</a></li>
<li><a href="../id462411/index.html">Pecahkan Sudoku dengan Algoritma X</a></li>
<li><a href="../id462415/index.html">Menyebarkan Symfony + Bereaksi aplikasi pada AWS melalui CI</a></li>
<li><a href="../id462417/index.html">Petisi Apple</a></li>
<li><a href="../id462421/index.html">Apollo Guidance Computer - arsitektur dan perangkat lunak sistem. Bagian 2</a></li>
<li><a href="../id462423/index.html">Manajemen Proyek</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>