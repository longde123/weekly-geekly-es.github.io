<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨‍👧‍👧 🤰🏾 👴🏽 Écrire du code Kotlin convivial pour Java 🙎🏽 🤸🏿 🤞🏼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="De l'extérieur, il pourrait sembler que Kotlin a simplifié le développement d'Android sans introduire de nouvelles difficultés du tout: le langage est...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Écrire du code Kotlin convivial pour Java</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/jugru/blog/417951/">  De l'extérieur, il pourrait sembler que Kotlin a simplifié le développement d'Android sans introduire de nouvelles difficultés du tout: le langage est compatible Java, donc même un grand projet Java peut être progressivement traduit en lui sans déranger personne, non?  Mais si vous regardez plus profondément, dans chaque boîte, il y a un double fond et dans la coiffeuse, il y a une porte secrète.  Les langages de programmation sont des projets trop complexes pour être combinés sans nuances délicates. <br><br>  Bien sûr, cela ne signifie pas "tout va mal et vous n'avez pas besoin d'utiliser Kotlin avec Java", mais cela signifie que vous devez connaître les nuances et les prendre en compte.  Lors de notre conférence <b>Mobius</b> , Sergei Ryabov <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">a</a> expliqué comment écrire du code sur Kotlin qui serait facilement accessible depuis Java.  Et le public a tellement aimé le reportage que nous avons non seulement décidé de publier une vidéo, mais aussi de faire une version texte pour Habr: <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/1L0q5VKx_-s" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><a name="habracut"></a><br>  J'écris Kotlin depuis plus de trois ans, maintenant seulement dessus, mais au début j'ai traîné Kotlin dans des projets Java existants.  Par conséquent, la question «comment lier Java et Kotlin ensemble» s'est posée assez souvent à ma manière. <br><br>  Souvent, lorsque vous ajoutez Kotlin à un projet, vous pouvez voir comment cela ... <br><br><pre><code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">compile</span></span> <span class="hljs-string"><span class="hljs-string">'rxbinding:xyx'</span></span> compile <span class="hljs-string"><span class="hljs-string">'rxbinding-appcompat-v7:xyx'</span></span> compile <span class="hljs-string"><span class="hljs-string">'rxbinding-design:xyx'</span></span> compile <span class="hljs-string"><span class="hljs-string">'autodispose:xyz'</span></span> compile <span class="hljs-string"><span class="hljs-string">'autodispose-android:xyz'</span></span> compile <span class="hljs-string"><span class="hljs-string">'autodispose-android-archcomponents:xyz'</span></span></code> </pre> <br>  ... se transforme en ceci: <br><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">compile</span></span> <span class="hljs-string"><span class="hljs-string">'rxbinding:xyx'</span></span> compile <span class="hljs-string"><span class="hljs-string">'rxbinding-kotlin:xyx'</span></span> compile <span class="hljs-string"><span class="hljs-string">'rxbinding-appcompat-v7:xyx'</span></span> compile <span class="hljs-string"><span class="hljs-string">'rxbinding-appcompat-v7-kotlin:xyx'</span></span> compile <span class="hljs-string"><span class="hljs-string">'rxbinding-design:xyx'</span></span> compile <span class="hljs-string"><span class="hljs-string">'rxbinding-design-kotlin:xyx'</span></span> compile <span class="hljs-string"><span class="hljs-string">'autodispose:xyz'</span></span> compile <span class="hljs-string"><span class="hljs-string">'autodispose-kotlin:xyz'</span></span> compile <span class="hljs-string"><span class="hljs-string">'autodispose-android:xyz'</span></span> compile <span class="hljs-string"><span class="hljs-string">'autodispose-android-kotlin:xyz'</span></span> compile <span class="hljs-string"><span class="hljs-string">'autodispose-android-archcomponents:xyz'</span></span> compile <span class="hljs-string"><span class="hljs-string">'autodispose-android-archcomponents-kotlin:xyz'</span></span></code> </pre><br>  Les spécificités des deux dernières années: les bibliothèques les plus populaires acquièrent des wrappers pour pouvoir les utiliser de manière plus idiomatique auprès de Kotlin. <br><br>  Si vous avez écrit dans Kotlin, alors vous savez qu'il existe des fonctions d'extension sympas, des fonctions en ligne, des expressions lambda qui sont disponibles à partir de Java 6. Et c'est cool, cela nous attire vers Kotlin, mais la question se pose.  L'interopérabilité avec Java est l'une des fonctionnalités les plus importantes et les plus publiées du langage.  Si vous prenez en compte toutes les fonctionnalités répertoriées, pourquoi ne pas simplement écrire des bibliothèques dans Kotlin?  Ils fonctionneront tous parfaitement avec Java, et vous n'aurez pas besoin de prendre en charge tous ces wrappers, tout le monde sera content et content. <br><br>  Mais, bien sûr, dans la pratique, tout n'est pas aussi rose que dans les brochures, il y a toujours un "petit attribut de police", il y a des arêtes vives à la jonction de Kotlin et Java, et aujourd'hui nous allons en parler un peu. <br><br><h2>  Arêtes vives </h2><br>  Commençons par les différences.  Par exemple, savez-vous que dans Kotlin il n'y a pas de mots-clés volatile, synchronisé, strictfp, transitoire?  Ils sont remplacés par des annotations du même nom situées dans le package kotlin.jvm.  Ainsi, la plupart de la conversation portera sur le contenu de ce package. <br><br>  Il y a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Timber</a> - une telle abstraction de bibliothèque sur les enregistreurs du célèbre <abbr title="Jake wharton">Zheka Vartanov</abbr> .  Il vous permet de l'utiliser partout dans votre application, et tout ce que vous souhaitez envoyer des journaux (à logcat, ou à votre serveur pour analyse, ou rapport de plantage, etc.) se transforme en plug-ins. <br><br>  Imaginons par exemple que nous voulons écrire une bibliothèque similaire, uniquement pour l'analytique.  Désengagez également. <br><br><pre> <code class="hljs kotlin"><span class="hljs-keyword"><span class="hljs-keyword">object</span></span> Analytics { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">send</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(event: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Event</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> {} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">addPlugins</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(plugs: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">List</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Plugin</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;)</span></span></span></span> {} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getPlugins</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>: List&lt;Plugin&gt; {} } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Plugin</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">init</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">send</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(event: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Event</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">close</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> } <span class="hljs-keyword"><span class="hljs-keyword">data</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Event</span></span></span></span>( <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> name: String, <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> context: Map&lt;String, Any&gt; = emptyMap() )</code> </pre><br>  Nous prenons le même modèle de construction, nous avons un point d'entrée - c'est Analytics.  Nous pouvons y envoyer des événements, ajouter des plugins et voir ce que nous y avons déjà ajouté. <br><br>  Le plugin est une interface de plugin qui résume une API analytique spécifique. <br><br>  Et, en fait, la classe Event contenant la clé et nos attributs que nous envoyons.  Ici, le rapport n'est pas sur la question de savoir s'il vaut la peine d'utiliser des singletones, alors ne reproduisons pas un holivar, mais nous verrons comment peigner tout cela. <br><br>  Maintenant un petit plongeon.  Voici un exemple d'utilisation de notre bibliothèque dans Kotlin: <br><br><pre> <code class="hljs kotlin"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">useAnalytics</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { Analytics.send(Event(<span class="hljs-string"><span class="hljs-string">"only_name_event"</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> props = mapOf( USER_ID to <span class="hljs-number"><span class="hljs-number">1235</span></span>, <span class="hljs-string"><span class="hljs-string">"my_custom_attr"</span></span> to <span class="hljs-literal"><span class="hljs-literal">true</span></span> ) Analytics.send(Event(<span class="hljs-string"><span class="hljs-string">"custom_event"</span></span>, props)) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> hasPlugins = Analytics.hasPlugins Analytics.addPlugin(EMPTY_PLUGIN) <span class="hljs-comment"><span class="hljs-comment">// dry-run Analytics.addPlugins(listOf(LoggerPlugin("ALog"), SegmentPlugin))) val plugins = Analytics.getPlugins() // ... }</span></span></code> </pre><br>  En principe, il semble comme prévu.  Un point d'entrée, les méthodes sont appelées à la statique.  Événement sans paramètres, événement avec attributs.  Nous vérifions pour voir si nous avons des plugins, poussons un plugin vide dedans afin de simplement faire une sorte de "dry run".  Ou ajoutez quelques autres plugins, affichez-les, etc.  En général, dans les cas d'utilisation standard, j'espère que tout est clair jusqu'à présent. <br><br>  Voyons maintenant ce qui se passe en Java lorsque nous faisons de même: <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">useAnalytics</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ Analytics.INSTANCE.send(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Event(<span class="hljs-string"><span class="hljs-string">"only_name_event"</span></span>, Collections.emptyMap())); <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Map&lt;String, Object&gt; props = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HashMap&lt;&gt;(); props.put(USER_ID, <span class="hljs-number"><span class="hljs-number">1235</span></span>); props.put(<span class="hljs-string"><span class="hljs-string">"my_custom_attr"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>); Analytics.INSTANCE.send(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Event(<span class="hljs-string"><span class="hljs-string">"custom_event"</span></span>, props)); <span class="hljs-keyword"><span class="hljs-keyword">boolean</span></span> hasPlugins = Analytics.INSTANCE.getHasPlugins(); Analytics.INSTANCE.addPlugin(Analytics.INSTANCE.getEMPTY_PLUGIN()); <span class="hljs-comment"><span class="hljs-comment">// dry-run final List&lt;EmptyPlugin&gt; pluginsToSet = Arrays.asList(new LoggerPlugin("ALog"), new SegmentPlugin()); // ... }</span></span></code> </pre><br>  L'agitation avec INSTANCE se précipite immédiatement dans mes yeux, ce qui est étiré, la présence de valeurs explicites pour le paramètre par défaut avec des attributs, des getters avec des noms stupides.  Puisque nous, en général, nous sommes réunis ici pour transformer cela en quelque chose de similaire au fichier précédent avec Kotlin, passons à chaque instant que nous n'aimons pas et essayons de l'adapter d'une manière ou d'une autre. <br><br>  Commençons par l'événement.  Nous supprimons le paramètre Colletions.emptyMap () de la deuxième ligne et une erreur de compilation apparaît.  Quelle en est la raison? <br><br><pre> <code class="hljs haskell"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> class </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Event</span></span></span><span class="hljs-class">( </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">val</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">name</span></span></span><span class="hljs-class">: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">String</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">val</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">context</span></span></span><span class="hljs-class">: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Map</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">String</span></span></span><span class="hljs-class">, </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Any</span></span></span><span class="hljs-class">&gt; = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">emptyMap</span></span></span><span class="hljs-class">() )</span></span></code> </pre><br>  Notre constructeur a un paramètre par défaut auquel nous transmettons la valeur.  Nous venons de Java à Kotlin, il est logique de supposer que la présence d'un paramètre par défaut génère deux constructeurs: un complet avec deux paramètres, et un partiel, pour lequel seul le nom peut être spécifié.  De toute évidence, le compilateur ne le pense pas.  Voyons pourquoi il pense que nous avons tort. <br><br>  Notre principal outil pour analyser tous les rebondissements de la façon dont Kotlin se transforme en un bytecode JVM - Kotlin Bytecode Viewer.  Dans Android Studio et IntelliJ IDEA, il se trouve dans le menu Tools - Kotlin - Show Kotlin Bytecode.  Vous pouvez simplement appuyer sur Cmd + Maj + A et taper Kotlin Bytecode dans la barre de recherche. <br><br><img src="https://habrastorage.org/webt/3d/9i/kg/3d9ikgrehu0zgr50qyftivtoahi.png"><br><br>  Ici, étonnamment, nous voyons un bytecode de ce que notre classe Kotlin est en train de devenir.  Je ne m'attends pas à ce que vous ayez une excellente connaissance du bytecode, et surtout, les développeurs IDE ne s'y attendent pas non plus.  Par conséquent, ils ont créé un bouton Décompiler. <br><br>  Après avoir cliqué dessus, nous voyons un code Java à peu près aussi bon: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Event</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@NotNull</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> String name; <span class="hljs-meta"><span class="hljs-meta">@NotNull</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Map context; <span class="hljs-meta"><span class="hljs-meta">@NotNull</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">final</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getName</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.name; } <span class="hljs-meta"><span class="hljs-meta">@NotNull</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">final</span></span></span><span class="hljs-function"> Map </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getContext</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.context; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Event</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@NotNull String name, @NotNull Map context)</span></span></span><span class="hljs-function"> </span></span>{ Intrinsics.checkParameterIsNotNull(name, <span class="hljs-string"><span class="hljs-string">"name"</span></span>); Intrinsics.checkParameterIsNotNull(context, <span class="hljs-string"><span class="hljs-string">"context"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>(); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.name = name; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.context = context; } <span class="hljs-comment"><span class="hljs-comment">// $FF: Synthetic method public Event(String var1, Map var2, int var3, DefaultConstructorMarker var4) { if ((var3 &amp; 2) != 0) { var2 = MapsKt.emptyMap(); } // ... }</span></span></code> </pre><br>  Nous voyons nos champs, getters, le constructeur attendu avec deux paramètres nom et contexte, tout se passe bien.  Et ci-dessous, nous voyons le deuxième constructeur, et le voici avec une signature inattendue: pas avec un paramètre, mais pour une raison quelconque avec quatre. <br><br>  Ici, vous pouvez être gêné, mais vous pouvez grimper un peu plus profondément et fouiller autour.  En commençant à comprendre, nous comprendrons que DefaultConstructorMarker est une classe privée de la bibliothèque standard de Kotlin, ajoutée ici afin qu'il n'y ait pas de conflits avec nos constructeurs écrits, car nous ne pouvons pas définir un paramètre de type DefaultConstructorMarker avec nos mains.  Et la chose intéressante à propos de int var3 est le masque de bits des valeurs par défaut que nous devons utiliser.  Dans ce cas, si le masque binaire correspond aux deux, nous savons que var2 n'est pas défini, nos attributs ne sont pas définis et nous utilisons la valeur par défaut. <br><br>  Comment pouvons-nous régler la situation?  Pour ce faire, il y a une annotation miraculeuse @JvmOverloads du package dont j'ai déjà parlé.  Nous devons l'accrocher au constructeur. <br><br><pre> <code class="hljs delphi">data <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> Event @JvmOverloads <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constructor</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( val </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">name</span></span></span></span><span class="hljs-function"><span class="hljs-params">: </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">String</span></span></span></span><span class="hljs-function"><span class="hljs-params">, val context: Map&lt;</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">String</span></span></span></span><span class="hljs-function"><span class="hljs-params">, Any&gt; = emptyMap()</span></span></span><span class="hljs-function"> )</span></span></code> </pre><br>  Et que va-t-elle faire?  Passons au même outil.  Maintenant, nous voyons notre constructeur complet, et le constructeur avec DefaultConstructorMarker, et, voilà, un constructeur avec un paramètre, qui est maintenant disponible à partir de Java: <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@JvmOverloads</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Event</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@NotNull String name)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.name, (Map)<span class="hljs-keyword"><span class="hljs-keyword">null</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, (DefaultConstructorMarker)<span class="hljs-keyword"><span class="hljs-keyword">null</span></span>); }</code> </pre><br>  Et, comme vous pouvez le voir, il délègue tout le travail avec des paramètres par défaut à notre constructeur avec des masques de bits.  Ainsi, nous ne produisons pas d'informations sur la valeur par défaut que nous devons y mettre, nous déléguons simplement tout dans un constructeur.  Sympa.  Nous vérifions ce que nous obtenons du côté Java: le compilateur est content et pas indigné. <br><br>  Voyons ce que nous n'aimons pas ensuite.  Nous n'aimons pas cette INSTANCE, qui dans IDEA est une callosité en violet.  Je n'aime pas la couleur violette :) <br><br><img src="https://habrastorage.org/webt/ys/rq/er/ysrqerlelunfipzn0xat3yek9da.png"><br><br>  Vérifions, à cause de ce qui se passe.  Regardons à nouveau le bytecode. <br><br>  Par exemple, nous mettons en évidence la fonction init et nous nous assurons que init est bien généré et non statique. <br><br><img src="https://habrastorage.org/webt/ek/5h/m2/ek5hm21brrzzf5yfu5mahq4x5eq.png"><br><br>  Autrement dit, quoi que l'on puisse dire, nous devons travailler avec une instance de cette classe et appeler ces méthodes dessus.  Mais nous pouvons forcer la génération de toutes ces méthodes à être statiques.  Il y a une merveilleuse annotation @JvmStatic pour cela.  Ajoutons-le aux fonctions init et send et vérifions ce que le compilateur en pense maintenant. <br><br>  Nous voyons que le mot-clé statique a été ajouté au public final init (), et nous nous sommes sauvés de travailler avec INSTANCE.  Nous allons vérifier cela dans le code Java. <br><br>  Le compilateur nous dit maintenant que nous invoquons la méthode statique à partir du contexte INSTANCE.  Cela peut être corrigé: appuyez sur Alt + Entrée, sélectionnez "Code de nettoyage", et le tour est joué, INSTANCE disparaît, tout ressemble à peu près à Kotlin: <br><br><pre> <code class="java hljs"> Analytics.send(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Event(<span class="hljs-string"><span class="hljs-string">"only_name_event"</span></span>));</code> </pre><br>  Nous avons maintenant un schéma pour travailler avec des méthodes statiques.  Ajoutez cette annotation partout où cela nous importe: <br><br><img src="https://habrastorage.org/webt/0o/m4/ky/0om4kydc_nj_fnmjd6jnfsfqfao.png"><br><br>  Et le commentaire: si les méthodes que nous avons sont évidemment les méthodes d'instance, alors, par exemple, avec des propriétés, tout n'est pas si évident.  Les champs eux-mêmes (par exemple les plugins) sont générés sous forme statique.  Mais les getters et setters fonctionnent comme des méthodes d'instance.  Par conséquent, pour les propriétés, vous devez également ajouter cette annotation pour rendre les setters et les getters statiques.  Par exemple, nous voyons la variable isInited, y ajoutons l'annotation @JvmStatic, et maintenant nous voyons dans Kotlin Bytecode Viewer que la méthode isInited () est devenue statique, tout va bien. <br><br>  Passons maintenant au code Java, «pour le nettoyage», et tout ressemble à Kotlin, à l'exception des points-virgules et du mot nouveau - eh bien, vous ne vous en débarrasserez pas. <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">useAnalytics</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ Analytics.send(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Event(<span class="hljs-string"><span class="hljs-string">"only_name_event"</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Map&lt;String, Object&gt; props = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HashMap&lt;&gt;(); props.put(USER_ID, <span class="hljs-number"><span class="hljs-number">1235</span></span>); props.put(<span class="hljs-string"><span class="hljs-string">"my_custom_attr"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>); Analytics.send(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Event(<span class="hljs-string"><span class="hljs-string">"custom_event"</span></span>, props)); <span class="hljs-keyword"><span class="hljs-keyword">boolean</span></span> hasPlugins = Analytics.getHasPlugins(); Analytics.addPlugin(Analytics.INSTANCE.getEMPTY_PLUGIN()); <span class="hljs-comment"><span class="hljs-comment">// dry-run // ... }</span></span></code> </pre><br>  Étape suivante: nous voyons ce getter getHasPlugins dumblement nommé avec deux préfixes à la fois.  Bien sûr, je ne suis pas un grand connaisseur de la langue anglaise, mais il me semble que quelque chose d'autre était impliqué ici.  Pourquoi cela se produit-il? <br><br>  Comme ils le savaient étroitement avec Kotlin, les noms de propriété des getters et setters sont générés selon les règles JavaBeans.  Cela signifie que les getters seront généralement avec des préfixes get, les setters avec des préfixes set.  Mais il y a une exception: si vous avez un champ booléen et que son nom a le préfixe is, le getter sera préfixé avec is.  Cela peut être vu dans l'exemple du champ isInited ci-dessus. <br><br>  Malheureusement, les champs booléens sont loin d'être toujours appelés via is.  isPlugins ne satisferait pas tout à fait ce que nous voulons montrer sémantiquement par son nom.  Comment on va? <br><br>  Et ce n'est pas difficile pour nous, pour cela il y a notre propre annotation (comme vous l'avez déjà compris, je vais souvent le répéter aujourd'hui).  L'annotation @JvmName vous permet de spécifier n'importe quel nom que nous voulons (naturellement pris en charge par Java).  Ajoutez-le: <br><br><pre> <code class="hljs kotlin"><span class="hljs-meta"><span class="hljs-meta">@JvmStatic</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> hasPlugins <span class="hljs-meta"><span class="hljs-meta">@JvmName(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"hasPlugin"</span></span></span><span class="hljs-meta">)</span></span> <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>() = plugins.isNotEmpty()</code> </pre><br>  Vérifions ce que nous avons obtenu en Java: la méthode getHasPlugins n'est plus là, mais hasPlugins est quelque chose en soi.  Cela a résolu notre problème, encore une fois, avec une annotation.  Maintenant, nous résolvons toutes les annotations! <br><br>  Comme vous pouvez le voir, nous plaçons ici l'annotation directement sur le getter.  Quelle en est la raison?  Avec le fait que sous la propriété, il y a beaucoup de tout, et on ne sait pas à quoi s'applique @JvmName.  Si vous transférez l'annotation à val hasPlugins lui-même, le compilateur ne comprendra pas à quoi l'appliquer. <br><br>  Cependant, Kotlin a également la possibilité de spécifier où les annotations sont utilisées directement.  Vous pouvez spécifier le getter cible, le fichier entier, le paramètre, le délégué, le champ, les propriétés, les fonctions d'extension du récepteur, le setter et le paramètre setter.  Dans notre cas, getter est intéressant.  Et si vous aimez cela, cela aura le même effet que lorsque nous avons suspendu l'annotation sur get: <br><br><pre> <code class="hljs kotlin"><span class="hljs-meta"><span class="hljs-meta">@get:JvmName</span></span>(<span class="hljs-string"><span class="hljs-string">"hasPlugins"</span></span>) <span class="hljs-meta"><span class="hljs-meta">@JvmStatic</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> hasPlugins <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>() = plugins.isNotEmpty()</code> </pre><br>  En conséquence, si vous n'avez pas de getter personnalisé, vous pouvez le joindre directement à votre propriété et tout ira bien. <br><br>  Le point suivant qui nous déroute un peu est "Analytics.INSTANCE.getEMPTY_PLUGIN ()".  Ici, la question n'est même plus en anglais, mais simplement: POURQUOI?  La réponse est à peu près la même, mais d'abord une petite introduction. <br><br>  Pour rendre un champ constant, vous avez deux façons.  Si vous définissez une constante en tant que type primitif ou en tant que chaîne, et également à l'intérieur de l'objet, vous pouvez utiliser le mot clé const, puis les getter-setters et autres ne seront pas générés.  Ce sera une constante ordinaire - statique finale privée - et elle sera insérée, c'est-à-dire une chose Java absolument ordinaire. <br><br>  Mais si vous voulez créer une constante à partir d'un objet différent de la chaîne, vous ne pourrez pas utiliser le mot const pour cela.  Ici, nous avons val EMPTY_PLUGIN = EmptyPlugin (), selon lui, ce terrible getter a évidemment été généré.  Nous pouvons renommer @JvmName avec une annotation, supprimer ce préfixe get, mais cela reste une méthode - avec des crochets.  Ainsi, les anciennes solutions ne fonctionneront pas, nous recherchons de nouvelles. <br><br>  Et voici pour cela l'annotation @JvmField, qui dit: "Je ne veux pas de getters ici, je ne veux pas de setters, faites-moi un champ."  Mettez-le devant val EMPTY_PLUGIN et vérifiez que tout est vrai. <br><br><img src="https://habrastorage.org/webt/7e/ei/0i/7eei0iwsgrd3pvkg_6lljoylhzm.png"><br><br>  Kotlin Bytecode Viewer affiche la pièce en surbrillance sur laquelle vous vous trouvez actuellement dans le fichier.  Nous sommes maintenant sur EMPTY_PLUGIN, et vous voyez qu'ici une sorte d'initialisation est écrite dans le constructeur.  Le fait est que le getter n'est plus là et que l'accès n'y est que pour l'enregistrement.  Et si vous cliquez sur décompiler, nous voyons que «final statique statique EmptyPlugin EMPTY_PLUGIN» est apparu, c'est exactement ce que nous avons réalisé.  Sympa.  Nous vérifions que tout plaît à tout le monde, en particulier au compilateur.  La chose la plus importante que vous devez apaiser est le compilateur. <br><br><h2>  Génériques </h2><br>  Prenons une pause dans le code et regardons les génériques.  C'est un sujet assez chaud.  Ou glissante, qui n'aime plus ça.  Java a ses propres complexités, mais Kotlin est différent.  Tout d'abord, nous nous préoccupons de la variation.  Qu'est ce que c'est <br><br>  La variabilité est un moyen de transférer des informations sur une hiérarchie de types des types de base aux dérivés, par exemple, aux conteneurs ou aux génériques.  Nous avons ici les classes Animal et Dog avec une connexion très évidente: Dog est un sous-type, Animal est un sous-type, la flèche vient du sous-type. <br><br><img src="https://habrastorage.org/webt/rz/-b/uz/rz-buzyeywt0xgwewjvauwmf0lc.png"><br><br>  Et quel lien leurs dérivés auront-ils?  Regardons quelques cas. <br><br>  Le premier est Iterator.  Pour déterminer ce qu'est un sous-type et ce qui est un sous-type, nous serons guidés par la règle de substitution Barbara Liskov.  Il peut être formulé comme suit: "le sous-type ne devrait pas exiger plus et ne pas fournir moins". <br><br>  Dans notre situation, la seule chose qu'Iterator fait est de nous donner des objets dactylographiés, par exemple, Animal.  Si nous acceptons Iterator quelque part, nous pouvons bien y mettre Iterator et obtenir Animal de la méthode next (), car le chien est aussi Animal.  Nous fournissons non pas moins, mais plus, car un chien est un sous-type. <br><br><img src="https://habrastorage.org/webt/bz/4e/ra/bz4eracdjm_ep_qnzk0mbkr5q7w.png"><br><br>  Je le répète: nous ne lisons que sur ce type, donc la relation entre le type et le sous-type est préservée ici.  Et ces types sont appelés covariants. <br><br>  Un autre cas: l'action.  Action est une fonction qui ne renvoie rien, prend un paramètre, et nous écrivons seulement à Action, c'est-à-dire qu'elle nous prend un chien ou un animal. <br><br><img src="https://habrastorage.org/webt/h5/hg/74/h5hg74k6id9rwtzfq1j2g1qsjyk.png"><br><br>  Ainsi, ici, nous ne fournissons plus, mais demandons, et nous ne devons plus exiger.  Cela signifie que notre dépendance évolue.  "Pas plus" nous avons Animal (Animal moins qu'un chien).  Et ces types sont appelés contravariants. <br><br>  Il y a un troisième cas - par exemple, ArrayList, à partir duquel nous lisons et écrivons.  Par conséquent, dans ce cas, nous violons l'une des règles, nous en demandons plus pour un dossier (un chien, pas un animal).  Ces types ne sont pas liés en aucune façon, et ils sont appelés invariants. <br><br><img src="https://habrastorage.org/webt/gj/5o/gp/gj5ogpkqy1ifvtmxghqszew7fgk.png"><br><br>  Ainsi, en Java, quand il a été conçu avant la version 1.5 (où les génériques sont apparus), par défaut, ils ont fait des tableaux covariants.  Cela signifie que vous pouvez affecter un tableau de chaînes au tableau d'objets, puis le transmettre quelque part à la méthode où le tableau d'objets est nécessaire, et essayer d'y pousser l'objet, bien qu'il s'agisse d'un tableau de chaînes.  Tout vous reviendra. <br><br>  Ayant appris d'une expérience amère que cela ne peut pas être fait, lors de la conception de génériques, ils ont décidé "nous rendrons les collections invariantes, nous ne ferons rien avec elles". <br><br>  Et à la fin, il s'avère que dans une chose aussi apparemment évidente, tout devrait être ok, mais en fait pas ok: <br><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// Java List&lt;Dog&gt; dogs = new ArrayList&lt;&gt;(); List&lt;Animal&gt; animals = dogs;</span></span></code> </pre><br>  Mais nous devons en quelque sorte déterminer ce que, après tout, nous pouvons: si nous ne lisons que cette feuille, pourquoi ne pas permettre de transférer la liste des chiens ici?  Par conséquent, il est possible de caractériser avec un caractère générique le type de variation que ce type aura: <br><br><pre> <code class="java hljs">List&lt;Dog&gt; dogs = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList&lt;&gt;(); List&lt;? extends Animal&gt; animals = dogs;</code> </pre><br>  Comme vous pouvez le voir, cette variation est indiquée sur le lieu d'utilisation, où nous affectons les chiens.  Par conséquent, cela s'appelle la variance du site d'utilisation. <br><br>  Quels sont les inconvénients de cela?  Le côté négatif est que vous devez spécifier ces caractères génériques effrayants partout où vous utilisez votre API, et tout cela est très fructueux dans le code.  Mais dans Kotlin pour une raison quelconque, une telle chose fonctionne hors de la boîte, et vous n'avez rien à spécifier: <br><br><pre> <code class="hljs scala"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> dogs: <span class="hljs-type"><span class="hljs-type">List</span></span>&lt;<span class="hljs-type"><span class="hljs-type">Dog</span></span>&gt; = <span class="hljs-type"><span class="hljs-type">ArrayList</span></span>() <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> animals: <span class="hljs-type"><span class="hljs-type">List</span></span>&lt;<span class="hljs-type"><span class="hljs-type">Animal</span></span>&gt; = dogs</code> </pre><br>  Quelle en est la raison?  Avec le fait que les draps sont réellement différents.  La liste en Java signifie l'écriture, tandis qu'en Kotlin, elle est en lecture seule, ce qui n'implique pas.  Par conséquent, en principe, nous pouvons immédiatement dire que nous ne faisons que lire d'ici, nous pouvons donc être covariants.  Et cela est défini précisément dans la déclaration de type avec le mot clé out remplaçant le caractère générique: <br><br><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">List</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">out E</span></span></span><span class="hljs-class">&gt; : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Collection</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">E</span></span></span><span class="hljs-class">&gt;</span></span></code> </pre><br>  C'est ce qu'on appelle la variance du site de déclaration.  Ainsi, nous avons tout indiqué en un seul endroit, et là où nous l'utilisons, nous ne touchons plus à ce sujet.  Et c'est nishtyak. <br><br><h2>  Retour au code </h2><br>  Revenons à nos profondeurs.  Ici, nous avons la méthode addPlugins, elle prend une liste: <br><br><pre> <code class="hljs kotlin"><span class="hljs-meta"><span class="hljs-meta">@JvmStatic</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">addPlugins</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(plugs: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">List</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Plugin</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;)</span></span></span></span> { plugs.forEach { addPlugin(it) } }    ,  , List&lt;EmptyPlugin&gt;, ,     : &lt;source lang=<span class="hljs-string"><span class="hljs-string">"java"</span></span>&gt; <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> List&lt;EmptyPlugin&gt; pluginsToSet = Arrays.asList(new LoggerPlugin(<span class="hljs-string"><span class="hljs-string">"Alog"</span></span>), new SegmentPlugin());</code> </pre><br>  Étant donné que List in Kotlin est covariant, nous pouvons facilement transmettre la liste des héritiers du plugin ici.  Tout fonctionnera, le compilateur ne s'en soucie pas.  Mais étant donné que nous avons une variance de site de déclaration où nous avons tout spécifié, nous ne pouvons pas contrôler la connexion avec Java au stade de l'utilisation.  Mais que se passe-t-il si nous voulons vraiment une feuille de plugin là-bas, nous ne voulons pas d'héritiers là-bas?  Il n'y a pas de modificateurs pour cela, mais quoi?  C'est vrai, il y a une annotation.  Et l'annotation s'appelle @JvmSuppressWildcards, c'est-à-dire que par défaut, nous pensons qu'il s'agit d'un type avec caractère générique, le type est covariant. <br><br><pre> <code class="hljs kotlin"><span class="hljs-meta"><span class="hljs-meta">@JvmStatic</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">addPlugins</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(plugs: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">List</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;@</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">JvmSuppressWildcards</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Plugin</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;)</span></span></span></span> { plugs.forEach { addPlugin(it) } }</code> </pre><br>  En parlant de SuppressWildcards, nous supprimons toutes ces questions, et notre signature change en fait.  Encore plus que cela, je vais vous montrer à quoi tout ressemble en bytecode: <br><br><img src="https://habrastorage.org/webt/rn/xp/ft/rnxpft1zqpioojczpiiyn1g3veo.png"><br><br>  Je vais supprimer l'annotation du code pour l'instant.  Voici notre méthode.  Vous savez probablement que l'effacement de type existe.  Et dans votre bytecode, il n'y a aucune information sur le type de questions qu'il y avait, eh bien, les génériques en général.  Mais le compilateur suit cela et le signe dans les commentaires du bytecode: et c'est le type avec la question. <br><br><img src="https://habrastorage.org/webt/u4/5e/mm/u45emmdne71zx9e9whz7uu8law0.png"><br><br>  Maintenant, nous insérons à nouveau l'annotation et voyons que c'est notre type sans remettre en question. <br><br><img src="https://habrastorage.org/webt/cu/if/wm/cuifwmem7zn636x3ky7n_41vuly.png"><br><br>  Maintenant, notre code précédent arrêtera de compiler précisément parce que nous avons coupé les caractères génériques.  Vous pouvez voir par vous-même. <br><br>  Nous avons fait des types covariants.  Maintenant, l'inverse est vrai. <br><br>  Nous pensons que List a une question.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Il est évident de supposer que lorsque cette feuille reviendra de getPlugins, ce sera aussi avec une question. Qu'est-ce que cela signifie? Cela signifie que nous ne pourrons pas y écrire, car le type est covariant et non contravariant. Jetons un coup d'œil à ce qui se passe en Java.</font></font><br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">final</span></span> List&lt;Plugin&gt; plugins = Analytics.getPlugins(); displayPlugins(plugins); Analytics.getPlugins().add(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> EmptyPlugin());</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Personne n'est scandalisé que dans la dernière ligne, nous écrivions quelque chose, ce qui signifie que quelqu'un ici a tort. Si nous regardons le bytecode, nous serons convaincus de l'exactitude de nos soupçons. Nous n'avons pas raccroché d'annotations, et le type pour une raison quelconque sans poser de question. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La surprise est basée sur cela. Kotlin se postule comme un langage pragmatique, donc quand tout cela a été conçu, des statistiques ont été collectées, car les caractères génériques sont généralement utilisés en Java. Il s'est avéré que l'entrée est le plus souvent autorisée la variance, c'est-à-dire rendre les types covariants. Eh bien, c'est utile partout où nous voulons qu'une liste puisse y mettre une feuille de n'importe quel héritier du plugin. Et ici, là où nous revenons, au contraire, nous voulons avoir des types purs: comme il y a une fiche Plugin, elle sera retournée.</font></font><br><br>       .    ,        ,      usecase,      - ,     . <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mais dans ce cas, nous voyons qu'une telle situation n'est pas pour nous, car nous ne voulons pas que quelque chose y soit enregistré. Et nous ne voulons pas non plus que cela soit possible à partir de Java. Dans Kotlin, ici List est un type en lecture seule, et nous ne pouvons rien écrire là-bas, mais le client de notre bibliothèque est venu de Java et a tout bourré là-dedans - qui voudrait? Par conséquent, nous allons forcer cette méthode à renvoyer une liste avec un caractère générique. Et nous pouvons expliquer clairement comment. En ajoutant l'annotation @JvmWildcard, nous disons: générez un type avec une question pour nous, tout est assez simple. Voyons maintenant ce qui se passe en Java à cet endroit. Java dit "que faites-vous?":</font></font><br><br><img src="https://habrastorage.org/webt/su/v_/1r/suv_1rnnuub7bsqlod-oglgra74.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ici, nous pouvons même lancer dans la liste correcte &lt;? </font><font style="vertical-align: inherit;">étend le plugin&gt;, mais elle dit toujours "que faites-vous?" </font><font style="vertical-align: inherit;">Et, en principe, cette situation nous convient jusqu'à présent. </font><font style="vertical-align: inherit;">Mais il y a un script kiddie qui dit: "J'ai vu la source, c'est une source ouverte, je sais qu'il y a une ArrayList, et je vais vous pirater." </font><font style="vertical-align: inherit;">Et tout fonctionnera, car il y a vraiment une ArrayList et il sait ce qui peut y être écrit.</font></font><br><br><pre> <code class="java hljs">((ArrayList&lt;Plugin&gt;) Analytics.getPlugins()).add(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> EmptyPlugin());</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Par conséquent, bien sûr, accrochez des annotations intéressantes, mais vous devez toujours utiliser la copie défensive, qui est connue depuis longtemps. </font><font style="vertical-align: inherit;">Soryan, nulle part sans lui, si vous voulez que les script kiddies ne vous dérangent pas.</font></font><br><br><pre> <code class="hljs kotlin"><span class="hljs-meta"><span class="hljs-meta">@JvmStatic</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getPlugins</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>: List&lt;<span class="hljs-meta"><span class="hljs-meta">@JvmWildcard</span></span> Plugin&gt; = plugin.toImmutableList()</code> </pre><br>  ,   @JvmSuppressWildcard     ,       ,    ,     ,     . <br><br>    ,     .    ,     : . <br><br>       Java.   ,    : <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">send</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@NotNull Event event)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> IOException</span></span></code> </pre><br>    : <br><br><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Plugin</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">init</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> <span class="hljs-comment"><span class="hljs-comment">/** </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@throws</span></span></span><span class="hljs-comment"> IOException if sending failed */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">send</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(event: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Event</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> <span class="hljs-comment"><span class="hljs-comment">// ... }</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">À Kotlin, il n'y a pas d'exception vérifiée. </font><font style="vertical-align: inherit;">Et nous disons dans la documentation: vous pouvez jeter ici. </font><font style="vertical-align: inherit;">Eh bien, nous jetons, jetons, jetons. </font><font style="vertical-align: inherit;">Mais Java n'aime pas pour une raison quelconque. </font><font style="vertical-align: inherit;">Dit: "mais Throws pour une raison quelconque n'est pas dans votre signature, monsieur": </font></font><br><br><img src="https://habrastorage.org/webt/g-/v8/go/g-v8gog8gwfa-on0anv0bkwktsk.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mais comment puis-je ajouter quelque chose ici, ici Kotlin? </font><font style="vertical-align: inherit;">Eh bien, vous connaissez la réponse ... </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Il y a une annotation @Throws qui fait exactement cela. </font><font style="vertical-align: inherit;">Il modifie la partie des lancers dans la signature de la méthode. </font><font style="vertical-align: inherit;">Nous disons que nous pouvons lancer une IOExeption ici:</font></font><br><br><pre> <code class="hljs kotlin"><span class="hljs-keyword"><span class="hljs-keyword">open</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">EmptyPlugin</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Plugin { @Throws</span></span></span></span>(IOException::<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class">) </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">override</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">fun</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">send</span></span></span></span>(event: Event) {} <span class="hljs-comment"><span class="hljs-comment">// ... }</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Et ajoutez cette chose en même temps à l'interface: </font></font><br><br><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Plugin</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">init</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> <span class="hljs-comment"><span class="hljs-comment">/** </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@throws</span></span></span><span class="hljs-comment"> IOException if sending failed */</span></span> <span class="hljs-meta"><span class="hljs-meta">@Throws(IOException::class)</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">send</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(event: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Event</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> <span class="hljs-comment"><span class="hljs-comment">// ... }</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Et maintenant quoi? </font><font style="vertical-align: inherit;">Maintenant, notre plugin, écrit en Java, où nous avons des informations sur l'exception, est satisfait de tout. </font><font style="vertical-align: inherit;">Tout fonctionne, compile. </font><font style="vertical-align: inherit;">En principe, c'est plus ou moins tout avec des annotations, mais il y a deux autres nuances sur la façon d'utiliser @JvmName. </font><font style="vertical-align: inherit;">Un intéressant. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous avons ajouté toutes ces annotations pour rendre Java magnifique. </font><font style="vertical-align: inherit;">Et ici ...</font></font><br><br><pre> <code class="hljs kotlin"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> util <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> List</span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">&lt;Int&gt;</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">printReversedSum</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { println(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.foldRight(<span class="hljs-number"><span class="hljs-number">0</span></span>) { it, acc -&gt; it + acc }) } <span class="hljs-meta"><span class="hljs-meta">@JvmName(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"printReversedConcatenation"</span></span></span><span class="hljs-meta">)</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> List</span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">&lt;String&gt;</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">printReversedSum</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { println(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.foldRight(StringBuilder()) { it, acc -&gt; acc.append(it) }) }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Supposons qu'en Java, nous ne nous soucions pas ici, supprimez l'annotation. Erreurs, l'EDI affiche maintenant une erreur dans les deux fonctions. Selon vous, quelle en est la raison? Oui, sans annotation, ils sont générés avec le même nom, mais ici il est écrit que l'un est sur la liste, l'autre sur la liste. À droite, tapez effacement. On peut même vérifier ce cas:</font></font><br><br><img src="https://habrastorage.org/webt/qk/oq/jr/qkoqjrub5xc4mdn-twq-s_jehl4.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vous savez déjà, si je comprends bien, que toutes les fonctions de niveau supérieur sont générées dans un contexte statique. </font><font style="vertical-align: inherit;">Et sans cette annotation, nous allons essayer de générer printReversedSum à partir de List, et en dessous d'un autre également à partir de List. </font><font style="vertical-align: inherit;">Parce que le compilateur Kotlin connaît les génériques, mais pas le bytecode Java. </font><font style="vertical-align: inherit;">Par conséquent, c'est le seul cas où les annotations du package kotlin.jvm sont nécessaires non pas pour que Java soit bon et pratique, mais pour que votre Kotlin compile. </font><font style="vertical-align: inherit;">Nous définissons un nouveau nom - une fois que nous travaillons avec des chaînes, puis nous utilisons la concaténation - et tout fonctionne bien, maintenant tout se compile. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Et le deuxième cas d'utilisation. </font><font style="vertical-align: inherit;">C'est lié à cela. </font><font style="vertical-align: inherit;">Nous avons une fonction d'extension inverse.</font></font><br><br><pre> <code class="hljs kotlin"><span class="hljs-keyword"><span class="hljs-keyword">inline</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> String.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">reverse</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> = StringBuilder(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>).reverse().toString() <span class="hljs-keyword"><span class="hljs-keyword">inline</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">&lt;</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-type"><span class="hljs-keyword">reified</span></span></span></span><span class="hljs-function"><span class="hljs-type"> T&gt;</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">reversedClassName</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> = T::<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">java</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">simpleName</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">reverse</span></span></span></span>() <span class="hljs-keyword"><span class="hljs-keyword">inline</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">&lt;T&gt;</span></span></span><span class="hljs-function"> Iterable</span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">&lt;T&gt;</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">forEachReversed</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(action: (</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">T</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Unit</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (element <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.reversed()) action(element) }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ce reverse compile dans une méthode de classe statique appelée ReverserKt. </font></font><br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">useUtils</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ System.out.println(ReverserKt.reverse(<span class="hljs-string"><span class="hljs-string">"Test"</span></span>)); SumsKt.printReversedSum(asList(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>)); SumsKt.printReversedConcatenation(asList(<span class="hljs-string"><span class="hljs-string">"1"</span></span>, <span class="hljs-string"><span class="hljs-string">"2"</span></span>, <span class="hljs-string"><span class="hljs-string">"3"</span></span>, <span class="hljs-string"><span class="hljs-string">"4"</span></span>, <span class="hljs-string"><span class="hljs-string">"5"</span></span>)); }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Je pense que ce n'est pas nouveau pour vous. La nuance est que les personnes utilisant notre bibliothèque en Java peuvent suspecter que quelque chose ne va pas. Nous avons divulgué les détails de la mise en œuvre de notre bibliothèque du côté de l'utilisateur et voulons couvrir nos traces. Comment pouvons-nous faire cela? Comme déjà clair, l'annotation @JvmName, dont je parle maintenant, mais il y a une mise en garde. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pour commencer, nous lui donnerons le nom que nous voulons, nous ne graverons pas, et il est important de dire que nous utilisons cette annotation sur le fichier, nous devons renommer le fichier.</font></font><br><br><pre> <code class="hljs ruby">@file<span class="hljs-symbol"><span class="hljs-symbol">:Suppress</span></span>(<span class="hljs-string"><span class="hljs-string">"NOTHING_TO_INLINE"</span></span>) @file<span class="hljs-symbol"><span class="hljs-symbol">:JvmName</span></span>(<span class="hljs-string"><span class="hljs-string">"ReverserUtils"</span></span>)</code> </pre><br>    Java   ReverserKt,   ,   ReverserUtils   .   « 2.1» —  ,       top-level     ,   . ,    ,    sums.kt   SumsKt,  ,       reversing    ReverserUtils.        @JvmName,  «ReverserUtils»,  ,  ,      ,  . <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bien que l'environnement ne vous avertisse pas à l'avance, lorsque vous essayez de compiler, ils nous diront que "vous voulez générer deux classes dans le même package avec le même nom, ata". </font><font style="vertical-align: inherit;">Que faut-il faire? </font><font style="vertical-align: inherit;">Ajoutez la dernière annotation @JvmMultifileClass dans ce package, qui indique que le contenu de plusieurs fichiers se transformera en une seule classe, c'est-à-dire qu'il n'y aura qu'une seule façade pour cela. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dans les deux cas, nous ajoutons "@file: JvmMultifileClass", et vous pouvez remplacer SumsKt par ReverserUtils, tout le monde est content - croyez-moi. </font><font style="vertical-align: inherit;">Avec des annotations faites! </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous avons parlé avec vous de ce package, de toutes les annotations. </font><font style="vertical-align: inherit;">En principe, il est déjà clair d'après leurs noms à quoi chacun est utilisé. </font><font style="vertical-align: inherit;">Il y a des cas délicats lorsque vous avez besoin, par exemple, @JvmName est même facile à utiliser dans Kotlin.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Spécifique à Kotlin </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mais ce n'est probablement pas tout ce que vous aimeriez savoir. Il est également important de noter comment travailler avec des choses spécifiques à Kotlin. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Par exemple, les fonctions en ligne. Ils sont en ligne dans Kotlin et, semble-t-il, seront-ils même accessibles depuis Java en bytecode? Il s'avère qu'ils le feront, tout ira bien et les méthodes sont réellement disponibles pour Java. Bien que si vous écrivez, par exemple, un projet Kotlin uniquement, cela n'affecte pas assez bien votre limite de nombre de dex. Parce qu'à Kotlin, ils ne sont pas nécessaires, mais en réalité ils seront en bytecode. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ensuite, notez les paramètres de type Reified. Ces paramètres sont spécifiques à Kotlin, ils ne sont disponibles que pour les fonctions en ligne et vous permettent d'inverser les hacks qui ne sont pas disponibles en Java avec réflexion. Comme il s'agit uniquement de Kotlin, il n'est disponible que pour Kotlin et, en Java, vous ne pouvez malheureusement pas utiliser de fonctions avec réifié.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">java.lang.Class. </font><font style="vertical-align: inherit;">Si nous voulons réfléchir un peu et que notre bibliothèque est également pour Java, elle doit être prise en charge. </font><font style="vertical-align: inherit;">Voyons un exemple. </font><font style="vertical-align: inherit;">Nous avons un tel «notre retrofit», rapidement écrit sur mon genou (je ne comprends pas ce que les gars ont écrit depuis si longtemps):</font></font><br><br><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Retrofit</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">private</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">constructor</span></span></span></span>( <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> baseUrl: String, <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> client: Client ) { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">&lt;T : Any&gt;</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">create</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(service: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Class</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">T</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;)</span></span></span></span>: T {...} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">&lt;T : Any&gt;</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">create</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(service: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">KClass</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">T</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;)</span></span></span></span>: T { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> create(service.java) } }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Il y a une méthode qui fonctionne avec la classe Java, il y a une méthode qui fonctionne avec Kotlin KClass, vous n'avez pas besoin de faire deux implémentations différentes, vous pouvez utiliser des propriétés d'extension qui obtiennent Class de KClass, KClass de Class (cela s'appelle Kotlin, en principe évidemment). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tout cela fonctionnera, mais c'est un peu non idiomatique. </font><font style="vertical-align: inherit;">Dans le code Kotlin, vous ne passez pas KClass, vous écrivez en utilisant des types réifiés, il est donc préférable de refaire la méthode comme ceci:</font></font><br><br><pre> <code class="hljs kotlin"><span class="hljs-keyword"><span class="hljs-keyword">inline</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">&lt;</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-type"><span class="hljs-keyword">reified</span></span></span></span><span class="hljs-function"><span class="hljs-type"> T : Any&gt;</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">create</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>: T { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> create(T::<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">java</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">java</span></span></span><span class="hljs-class">)</span></span></code> </pre><br>  .    Kotlin  ,    .  <i>val api = retrofit.create(Api::class)</i>   <i>val api = retrofit.create&lt;Api&gt;()</i> ,   ::class  .    Reified-,    -. <br><br> Unit.     Unit,      ,   void  Java,  .      .       ,       .  -   Scala,   Scala      ,   - ,       ,    ,    void. <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mais à Kotlin, ce n'est pas le cas. </font><font style="vertical-align: inherit;">Kotlin n'a que 22 interfaces qui acceptent un ensemble différent de paramètres et renvoient quelque chose. </font><font style="vertical-align: inherit;">Ainsi, le lambda qui retourne Unit retournera non nul, mais Unit. </font><font style="vertical-align: inherit;">Et cela impose ses limites. </font><font style="vertical-align: inherit;">À quoi ressemble le lambda qui retourne Unit? </font><font style="vertical-align: inherit;">Maintenant, regardez-la dans ce fragment de code. </font><font style="vertical-align: inherit;">Apprenez à vous connaître.</font></font><br><br><pre> <code class="hljs kotlin"><span class="hljs-keyword"><span class="hljs-keyword">inline</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">&lt;T&gt;</span></span></span><span class="hljs-function"> Iterable</span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">&lt;T&gt;</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">forEachReversed</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(action: (</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">T</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Unit</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (element <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.reversed()) action(element) }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Utilisation de Kotlin: tout va bien, nous utilisons même une référence de méthode, si nous le pouvons, et elle se lit parfaitement, nos yeux ne sont pas calleux. </font></font><br><br><pre> <code class="hljs kotlin"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">useMisc</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { listOf(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>).forEachReversed(::println) println(reversedClassName&lt;String&gt;()) }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Que se passe-t-il en Java? </font><font style="vertical-align: inherit;">En Java, le canoë suivant se produit:</font></font><br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">useMisc</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> List&lt;Integer&gt; list = asList(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>); ReverserUtils.forEachReversed(list, integer -&gt; { System.out.println(integer); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Unit.INSTANCE; });</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En raison du fait que nous devons retourner quelque chose ici. C'est comme un Vide avec une majuscule, on ne peut pas simplement prendre et marquer dessus. Nous ne pouvons pas utiliser la méthode de référence ici, qui retourne nulle, malheureusement. Et c'est probablement la première chose qui cogne vraiment les yeux après toutes nos manipulations avec des annotations. Malheureusement, vous devrez renvoyer l'instance d'unité d'ici. Vous pouvez annuler, de toute façon, personne n'en a besoin. Je veux dire, personne n'a besoin d'une valeur de retour. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Allons plus loin: Typealiases est aussi une chose assez spécifique, ce sont juste des alias ou des synonymes, ils ne sont disponibles que chez Kotlin, et en Java, malheureusement, vous utiliserez ce qui se trouve sous ces alias. Soit c'est une corbeille de génériques trois fois fermés, soit une sorte de classes imbriquées. Les programmeurs Java ont l'habitude de vivre avec cela.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Maintenant, pour la partie intéressante: la visibilité. Ou plutôt, une visibilité interne. Vous savez probablement que dans Kotlin il n'y a pas de paquet privé, si vous écrivez sans aucun modificateur, il sera public. Mais il y a interne. Interne est une chose tellement délicate que nous allons même l'examiner maintenant. Dans Retrofit, nous avons une méthode de validation interne.</font></font><br><br><pre> <code class="hljs kotlin"><span class="hljs-keyword"><span class="hljs-keyword">internal</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">validate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>: Retrofit { println(<span class="hljs-string"><span class="hljs-string">"!!!!!! internal fun validate() was called !!!!!!"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span> }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Il ne peut pas être appelé depuis Kotlin, et cela est compréhensible. </font><font style="vertical-align: inherit;">Que se passe-t-il avec Java? </font><font style="vertical-align: inherit;">Pouvons-nous appeler valider? </font><font style="vertical-align: inherit;">Ce n'est peut-être pas un secret pour vous que les transformations internes deviennent publiques. </font><font style="vertical-align: inherit;">Si vous ne me croyez pas, croyez la visionneuse de bytecode Kotlin. </font></font><br><br><img src="https://habrastorage.org/webt/cc/mr/ts/ccmrtst8oqwmbdvgn4onk8jlrus.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C'est vraiment public, mais avec une signature si terrible qui laisse entendre à une personne qu'il n'a probablement pas été entièrement conçu qu'un tel fluage rampe dans l'API publique. </font><font style="vertical-align: inherit;">Si quelqu'un a formaté 80 caractères, cette méthode peut même ne pas tenir sur une seule ligne. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En Java, nous avons maintenant ceci:</font></font><br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Api api = retrofit .validate$production_sources_for_module_library_main() .create(Api.class); api.sendMessage(<span class="hljs-string"><span class="hljs-string">"Hello from Java"</span></span>); }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Essayons de compiler ce cas. </font><font style="vertical-align: inherit;">Donc, au moins ça ne compilera pas, pas mal déjà. </font><font style="vertical-align: inherit;">Nous pourrions nous arrêter ici, mais laissez-moi vous expliquer cela. </font><font style="vertical-align: inherit;">Et si j'aime ça?</font></font><br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Api api = retrofit .validate$library() .create(Api.class); api.sendMessage(<span class="hljs-string"><span class="hljs-string">"Hello from Java"</span></span>); }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Compile ensuite. Et la question se pose: "Pourquoi?" Que puis-je dire ... MAGIQUE! </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Par conséquent, il est très important que si vous collez quelque chose de critique en interne, cela soit mauvais car cela fuira dans votre API publique. Et si le script kiddie est armé d'un Kotlin Bytecode Viewer, alors ce sera mauvais. N'utilisez rien de très important dans les méthodes à visibilité interne. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si vous voulez plus de joie, je recommande deux choses. Pour le rendre plus confortable pour travailler avec le bytecode et le lire, je recommande un rapport de Zhenya Vartanov, il y a une </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">vidéo gratuite</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , malgré le fait que cela provienne de l'événement SkillsMatter. Très cool. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Et une assez vieille </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">série</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">de trois articles de Christophe Bales sur les différentes fonctionnalités de Kotlin. </font><font style="vertical-align: inherit;">Tout est cool écrit là-bas, quelque chose n'a plus d'importance maintenant, mais en général c'est très intelligible. </font><font style="vertical-align: inherit;">Tout de même avec le visualiseur de bytecode Kotlin et tout ça.</font></font><br><br>  Je vous remercie! <br><br><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si vous avez aimé le rapport, faites attention: les 8 et 9 décembre, le nouveau </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mobius</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> se tiendra à Moscou </font><font style="vertical-align: inherit;">, et il y aura également beaucoup de choses intéressantes. </font><font style="vertical-align: inherit;">Des informations déjà connues sur le programme sont </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sur le site</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , et des billets peuvent y être achetés.</font></font><br></blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr417951/">https://habr.com/ru/post/fr417951/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr417941/index.html">Où l'eau dans la bouilloire disparaît-elle?</a></li>
<li><a href="../fr417943/index.html">Sans serveur et React 2: tour de passe-passe et aucune fraude</a></li>
<li><a href="../fr417945/index.html">De quels outils dispose la sonde solaire Parker</a></li>
<li><a href="../fr417947/index.html">Visualisation des données pour votre projet web</a></li>
<li><a href="../fr417949/index.html">Comment ai-je écrit la bibliothèque C ++ 11 standard ou pourquoi boost est si effrayant. Chapitre 4.2</a></li>
<li><a href="../fr417953/index.html">Tendances dans la conception de FPGA. La traduction</a></li>
<li><a href="../fr417955/index.html">Comment devenir concepteur d'interface. Compétences nécessaires et outils puissants dont on ne nous parle pas</a></li>
<li><a href="../fr417957/index.html">Webinaire ouvert Mécanismes de conteneurisation Linux</a></li>
<li><a href="../fr417959/index.html">10 conseils de conception d'interface</a></li>
<li><a href="../fr417963/index.html">Vent, criquet et date limite: comment nous avons construit la sous-station électrique</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>