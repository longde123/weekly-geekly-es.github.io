<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë®‚Äçüëß‚Äçüëß ü§∞üèæ üë¥üèΩ √âcrire du code Kotlin convivial pour Java üôéüèΩ ü§∏üèø ü§ûüèº</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="De l'ext√©rieur, il pourrait sembler que Kotlin a simplifi√© le d√©veloppement d'Android sans introduire de nouvelles difficult√©s du tout: le langage est...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>√âcrire du code Kotlin convivial pour Java</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/jugru/blog/417951/">  De l'ext√©rieur, il pourrait sembler que Kotlin a simplifi√© le d√©veloppement d'Android sans introduire de nouvelles difficult√©s du tout: le langage est compatible Java, donc m√™me un grand projet Java peut √™tre progressivement traduit en lui sans d√©ranger personne, non?  Mais si vous regardez plus profond√©ment, dans chaque bo√Æte, il y a un double fond et dans la coiffeuse, il y a une porte secr√®te.  Les langages de programmation sont des projets trop complexes pour √™tre combin√©s sans nuances d√©licates. <br><br>  Bien s√ªr, cela ne signifie pas "tout va mal et vous n'avez pas besoin d'utiliser Kotlin avec Java", mais cela signifie que vous devez conna√Ætre les nuances et les prendre en compte.  Lors de notre conf√©rence <b>Mobius</b> , Sergei Ryabov <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">a</a> expliqu√© comment √©crire du code sur Kotlin qui serait facilement accessible depuis Java.  Et le public a tellement aim√© le reportage que nous avons non seulement d√©cid√© de publier une vid√©o, mais aussi de faire une version texte pour Habr: <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/1L0q5VKx_-s" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><a name="habracut"></a><br>  J'√©cris Kotlin depuis plus de trois ans, maintenant seulement dessus, mais au d√©but j'ai tra√Æn√© Kotlin dans des projets Java existants.  Par cons√©quent, la question ¬´comment lier Java et Kotlin ensemble¬ª s'est pos√©e assez souvent √† ma mani√®re. <br><br>  Souvent, lorsque vous ajoutez Kotlin √† un projet, vous pouvez voir comment cela ... <br><br><pre><code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">compile</span></span> <span class="hljs-string"><span class="hljs-string">'rxbinding:xyx'</span></span> compile <span class="hljs-string"><span class="hljs-string">'rxbinding-appcompat-v7:xyx'</span></span> compile <span class="hljs-string"><span class="hljs-string">'rxbinding-design:xyx'</span></span> compile <span class="hljs-string"><span class="hljs-string">'autodispose:xyz'</span></span> compile <span class="hljs-string"><span class="hljs-string">'autodispose-android:xyz'</span></span> compile <span class="hljs-string"><span class="hljs-string">'autodispose-android-archcomponents:xyz'</span></span></code> </pre> <br>  ... se transforme en ceci: <br><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">compile</span></span> <span class="hljs-string"><span class="hljs-string">'rxbinding:xyx'</span></span> compile <span class="hljs-string"><span class="hljs-string">'rxbinding-kotlin:xyx'</span></span> compile <span class="hljs-string"><span class="hljs-string">'rxbinding-appcompat-v7:xyx'</span></span> compile <span class="hljs-string"><span class="hljs-string">'rxbinding-appcompat-v7-kotlin:xyx'</span></span> compile <span class="hljs-string"><span class="hljs-string">'rxbinding-design:xyx'</span></span> compile <span class="hljs-string"><span class="hljs-string">'rxbinding-design-kotlin:xyx'</span></span> compile <span class="hljs-string"><span class="hljs-string">'autodispose:xyz'</span></span> compile <span class="hljs-string"><span class="hljs-string">'autodispose-kotlin:xyz'</span></span> compile <span class="hljs-string"><span class="hljs-string">'autodispose-android:xyz'</span></span> compile <span class="hljs-string"><span class="hljs-string">'autodispose-android-kotlin:xyz'</span></span> compile <span class="hljs-string"><span class="hljs-string">'autodispose-android-archcomponents:xyz'</span></span> compile <span class="hljs-string"><span class="hljs-string">'autodispose-android-archcomponents-kotlin:xyz'</span></span></code> </pre><br>  Les sp√©cificit√©s des deux derni√®res ann√©es: les biblioth√®ques les plus populaires acqui√®rent des wrappers pour pouvoir les utiliser de mani√®re plus idiomatique aupr√®s de Kotlin. <br><br>  Si vous avez √©crit dans Kotlin, alors vous savez qu'il existe des fonctions d'extension sympas, des fonctions en ligne, des expressions lambda qui sont disponibles √† partir de Java 6. Et c'est cool, cela nous attire vers Kotlin, mais la question se pose.  L'interop√©rabilit√© avec Java est l'une des fonctionnalit√©s les plus importantes et les plus publi√©es du langage.  Si vous prenez en compte toutes les fonctionnalit√©s r√©pertori√©es, pourquoi ne pas simplement √©crire des biblioth√®ques dans Kotlin?  Ils fonctionneront tous parfaitement avec Java, et vous n'aurez pas besoin de prendre en charge tous ces wrappers, tout le monde sera content et content. <br><br>  Mais, bien s√ªr, dans la pratique, tout n'est pas aussi rose que dans les brochures, il y a toujours un "petit attribut de police", il y a des ar√™tes vives √† la jonction de Kotlin et Java, et aujourd'hui nous allons en parler un peu. <br><br><h2>  Ar√™tes vives </h2><br>  Commen√ßons par les diff√©rences.  Par exemple, savez-vous que dans Kotlin il n'y a pas de mots-cl√©s volatile, synchronis√©, strictfp, transitoire?  Ils sont remplac√©s par des annotations du m√™me nom situ√©es dans le package kotlin.jvm.  Ainsi, la plupart de la conversation portera sur le contenu de ce package. <br><br>  Il y a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Timber</a> - une telle abstraction de biblioth√®que sur les enregistreurs du c√©l√®bre <abbr title="Jake wharton">Zheka Vartanov</abbr> .  Il vous permet de l'utiliser partout dans votre application, et tout ce que vous souhaitez envoyer des journaux (√† logcat, ou √† votre serveur pour analyse, ou rapport de plantage, etc.) se transforme en plug-ins. <br><br>  Imaginons par exemple que nous voulons √©crire une biblioth√®que similaire, uniquement pour l'analytique.  D√©sengagez √©galement. <br><br><pre> <code class="hljs kotlin"><span class="hljs-keyword"><span class="hljs-keyword">object</span></span> Analytics { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">send</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(event: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Event</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> {} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">addPlugins</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(plugs: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">List</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Plugin</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;)</span></span></span></span> {} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getPlugins</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>: List&lt;Plugin&gt; {} } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Plugin</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">init</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">send</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(event: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Event</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">close</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> } <span class="hljs-keyword"><span class="hljs-keyword">data</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Event</span></span></span></span>( <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> name: String, <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> context: Map&lt;String, Any&gt; = emptyMap() )</code> </pre><br>  Nous prenons le m√™me mod√®le de construction, nous avons un point d'entr√©e - c'est Analytics.  Nous pouvons y envoyer des √©v√©nements, ajouter des plugins et voir ce que nous y avons d√©j√† ajout√©. <br><br>  Le plugin est une interface de plugin qui r√©sume une API analytique sp√©cifique. <br><br>  Et, en fait, la classe Event contenant la cl√© et nos attributs que nous envoyons.  Ici, le rapport n'est pas sur la question de savoir s'il vaut la peine d'utiliser des singletones, alors ne reproduisons pas un holivar, mais nous verrons comment peigner tout cela. <br><br>  Maintenant un petit plongeon.  Voici un exemple d'utilisation de notre biblioth√®que dans Kotlin: <br><br><pre> <code class="hljs kotlin"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">useAnalytics</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { Analytics.send(Event(<span class="hljs-string"><span class="hljs-string">"only_name_event"</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> props = mapOf( USER_ID to <span class="hljs-number"><span class="hljs-number">1235</span></span>, <span class="hljs-string"><span class="hljs-string">"my_custom_attr"</span></span> to <span class="hljs-literal"><span class="hljs-literal">true</span></span> ) Analytics.send(Event(<span class="hljs-string"><span class="hljs-string">"custom_event"</span></span>, props)) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> hasPlugins = Analytics.hasPlugins Analytics.addPlugin(EMPTY_PLUGIN) <span class="hljs-comment"><span class="hljs-comment">// dry-run Analytics.addPlugins(listOf(LoggerPlugin("ALog"), SegmentPlugin))) val plugins = Analytics.getPlugins() // ... }</span></span></code> </pre><br>  En principe, il semble comme pr√©vu.  Un point d'entr√©e, les m√©thodes sont appel√©es √† la statique.  √âv√©nement sans param√®tres, √©v√©nement avec attributs.  Nous v√©rifions pour voir si nous avons des plugins, poussons un plugin vide dedans afin de simplement faire une sorte de "dry run".  Ou ajoutez quelques autres plugins, affichez-les, etc.  En g√©n√©ral, dans les cas d'utilisation standard, j'esp√®re que tout est clair jusqu'√† pr√©sent. <br><br>  Voyons maintenant ce qui se passe en Java lorsque nous faisons de m√™me: <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">useAnalytics</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ Analytics.INSTANCE.send(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Event(<span class="hljs-string"><span class="hljs-string">"only_name_event"</span></span>, Collections.emptyMap())); <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Map&lt;String, Object&gt; props = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HashMap&lt;&gt;(); props.put(USER_ID, <span class="hljs-number"><span class="hljs-number">1235</span></span>); props.put(<span class="hljs-string"><span class="hljs-string">"my_custom_attr"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>); Analytics.INSTANCE.send(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Event(<span class="hljs-string"><span class="hljs-string">"custom_event"</span></span>, props)); <span class="hljs-keyword"><span class="hljs-keyword">boolean</span></span> hasPlugins = Analytics.INSTANCE.getHasPlugins(); Analytics.INSTANCE.addPlugin(Analytics.INSTANCE.getEMPTY_PLUGIN()); <span class="hljs-comment"><span class="hljs-comment">// dry-run final List&lt;EmptyPlugin&gt; pluginsToSet = Arrays.asList(new LoggerPlugin("ALog"), new SegmentPlugin()); // ... }</span></span></code> </pre><br>  L'agitation avec INSTANCE se pr√©cipite imm√©diatement dans mes yeux, ce qui est √©tir√©, la pr√©sence de valeurs explicites pour le param√®tre par d√©faut avec des attributs, des getters avec des noms stupides.  Puisque nous, en g√©n√©ral, nous sommes r√©unis ici pour transformer cela en quelque chose de similaire au fichier pr√©c√©dent avec Kotlin, passons √† chaque instant que nous n'aimons pas et essayons de l'adapter d'une mani√®re ou d'une autre. <br><br>  Commen√ßons par l'√©v√©nement.  Nous supprimons le param√®tre Colletions.emptyMap () de la deuxi√®me ligne et une erreur de compilation appara√Æt.  Quelle en est la raison? <br><br><pre> <code class="hljs haskell"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> class </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Event</span></span></span><span class="hljs-class">( </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">val</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">name</span></span></span><span class="hljs-class">: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">String</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">val</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">context</span></span></span><span class="hljs-class">: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Map</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">String</span></span></span><span class="hljs-class">, </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Any</span></span></span><span class="hljs-class">&gt; = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">emptyMap</span></span></span><span class="hljs-class">() )</span></span></code> </pre><br>  Notre constructeur a un param√®tre par d√©faut auquel nous transmettons la valeur.  Nous venons de Java √† Kotlin, il est logique de supposer que la pr√©sence d'un param√®tre par d√©faut g√©n√®re deux constructeurs: un complet avec deux param√®tres, et un partiel, pour lequel seul le nom peut √™tre sp√©cifi√©.  De toute √©vidence, le compilateur ne le pense pas.  Voyons pourquoi il pense que nous avons tort. <br><br>  Notre principal outil pour analyser tous les rebondissements de la fa√ßon dont Kotlin se transforme en un bytecode JVM - Kotlin Bytecode Viewer.  Dans Android Studio et IntelliJ IDEA, il se trouve dans le menu Tools - Kotlin - Show Kotlin Bytecode.  Vous pouvez simplement appuyer sur Cmd + Maj + A et taper Kotlin Bytecode dans la barre de recherche. <br><br><img src="https://habrastorage.org/webt/3d/9i/kg/3d9ikgrehu0zgr50qyftivtoahi.png"><br><br>  Ici, √©tonnamment, nous voyons un bytecode de ce que notre classe Kotlin est en train de devenir.  Je ne m'attends pas √† ce que vous ayez une excellente connaissance du bytecode, et surtout, les d√©veloppeurs IDE ne s'y attendent pas non plus.  Par cons√©quent, ils ont cr√©√© un bouton D√©compiler. <br><br>  Apr√®s avoir cliqu√© dessus, nous voyons un code Java √† peu pr√®s aussi bon: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Event</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@NotNull</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> String name; <span class="hljs-meta"><span class="hljs-meta">@NotNull</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Map context; <span class="hljs-meta"><span class="hljs-meta">@NotNull</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">final</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getName</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.name; } <span class="hljs-meta"><span class="hljs-meta">@NotNull</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">final</span></span></span><span class="hljs-function"> Map </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getContext</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.context; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Event</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@NotNull String name, @NotNull Map context)</span></span></span><span class="hljs-function"> </span></span>{ Intrinsics.checkParameterIsNotNull(name, <span class="hljs-string"><span class="hljs-string">"name"</span></span>); Intrinsics.checkParameterIsNotNull(context, <span class="hljs-string"><span class="hljs-string">"context"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>(); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.name = name; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.context = context; } <span class="hljs-comment"><span class="hljs-comment">// $FF: Synthetic method public Event(String var1, Map var2, int var3, DefaultConstructorMarker var4) { if ((var3 &amp; 2) != 0) { var2 = MapsKt.emptyMap(); } // ... }</span></span></code> </pre><br>  Nous voyons nos champs, getters, le constructeur attendu avec deux param√®tres nom et contexte, tout se passe bien.  Et ci-dessous, nous voyons le deuxi√®me constructeur, et le voici avec une signature inattendue: pas avec un param√®tre, mais pour une raison quelconque avec quatre. <br><br>  Ici, vous pouvez √™tre g√™n√©, mais vous pouvez grimper un peu plus profond√©ment et fouiller autour.  En commen√ßant √† comprendre, nous comprendrons que DefaultConstructorMarker est une classe priv√©e de la biblioth√®que standard de Kotlin, ajout√©e ici afin qu'il n'y ait pas de conflits avec nos constructeurs √©crits, car nous ne pouvons pas d√©finir un param√®tre de type DefaultConstructorMarker avec nos mains.  Et la chose int√©ressante √† propos de int var3 est le masque de bits des valeurs par d√©faut que nous devons utiliser.  Dans ce cas, si le masque binaire correspond aux deux, nous savons que var2 n'est pas d√©fini, nos attributs ne sont pas d√©finis et nous utilisons la valeur par d√©faut. <br><br>  Comment pouvons-nous r√©gler la situation?  Pour ce faire, il y a une annotation miraculeuse @JvmOverloads du package dont j'ai d√©j√† parl√©.  Nous devons l'accrocher au constructeur. <br><br><pre> <code class="hljs delphi">data <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> Event @JvmOverloads <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constructor</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( val </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">name</span></span></span></span><span class="hljs-function"><span class="hljs-params">: </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">String</span></span></span></span><span class="hljs-function"><span class="hljs-params">, val context: Map&lt;</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">String</span></span></span></span><span class="hljs-function"><span class="hljs-params">, Any&gt; = emptyMap()</span></span></span><span class="hljs-function"> )</span></span></code> </pre><br>  Et que va-t-elle faire?  Passons au m√™me outil.  Maintenant, nous voyons notre constructeur complet, et le constructeur avec DefaultConstructorMarker, et, voil√†, un constructeur avec un param√®tre, qui est maintenant disponible √† partir de Java: <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@JvmOverloads</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Event</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@NotNull String name)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.name, (Map)<span class="hljs-keyword"><span class="hljs-keyword">null</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, (DefaultConstructorMarker)<span class="hljs-keyword"><span class="hljs-keyword">null</span></span>); }</code> </pre><br>  Et, comme vous pouvez le voir, il d√©l√®gue tout le travail avec des param√®tres par d√©faut √† notre constructeur avec des masques de bits.  Ainsi, nous ne produisons pas d'informations sur la valeur par d√©faut que nous devons y mettre, nous d√©l√©guons simplement tout dans un constructeur.  Sympa.  Nous v√©rifions ce que nous obtenons du c√¥t√© Java: le compilateur est content et pas indign√©. <br><br>  Voyons ce que nous n'aimons pas ensuite.  Nous n'aimons pas cette INSTANCE, qui dans IDEA est une callosit√© en violet.  Je n'aime pas la couleur violette :) <br><br><img src="https://habrastorage.org/webt/ys/rq/er/ysrqerlelunfipzn0xat3yek9da.png"><br><br>  V√©rifions, √† cause de ce qui se passe.  Regardons √† nouveau le bytecode. <br><br>  Par exemple, nous mettons en √©vidence la fonction init et nous nous assurons que init est bien g√©n√©r√© et non statique. <br><br><img src="https://habrastorage.org/webt/ek/5h/m2/ek5hm21brrzzf5yfu5mahq4x5eq.png"><br><br>  Autrement dit, quoi que l'on puisse dire, nous devons travailler avec une instance de cette classe et appeler ces m√©thodes dessus.  Mais nous pouvons forcer la g√©n√©ration de toutes ces m√©thodes √† √™tre statiques.  Il y a une merveilleuse annotation @JvmStatic pour cela.  Ajoutons-le aux fonctions init et send et v√©rifions ce que le compilateur en pense maintenant. <br><br>  Nous voyons que le mot-cl√© statique a √©t√© ajout√© au public final init (), et nous nous sommes sauv√©s de travailler avec INSTANCE.  Nous allons v√©rifier cela dans le code Java. <br><br>  Le compilateur nous dit maintenant que nous invoquons la m√©thode statique √† partir du contexte INSTANCE.  Cela peut √™tre corrig√©: appuyez sur Alt + Entr√©e, s√©lectionnez "Code de nettoyage", et le tour est jou√©, INSTANCE dispara√Æt, tout ressemble √† peu pr√®s √† Kotlin: <br><br><pre> <code class="java hljs"> Analytics.send(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Event(<span class="hljs-string"><span class="hljs-string">"only_name_event"</span></span>));</code> </pre><br>  Nous avons maintenant un sch√©ma pour travailler avec des m√©thodes statiques.  Ajoutez cette annotation partout o√π cela nous importe: <br><br><img src="https://habrastorage.org/webt/0o/m4/ky/0om4kydc_nj_fnmjd6jnfsfqfao.png"><br><br>  Et le commentaire: si les m√©thodes que nous avons sont √©videmment les m√©thodes d'instance, alors, par exemple, avec des propri√©t√©s, tout n'est pas si √©vident.  Les champs eux-m√™mes (par exemple les plugins) sont g√©n√©r√©s sous forme statique.  Mais les getters et setters fonctionnent comme des m√©thodes d'instance.  Par cons√©quent, pour les propri√©t√©s, vous devez √©galement ajouter cette annotation pour rendre les setters et les getters statiques.  Par exemple, nous voyons la variable isInited, y ajoutons l'annotation @JvmStatic, et maintenant nous voyons dans Kotlin Bytecode Viewer que la m√©thode isInited () est devenue statique, tout va bien. <br><br>  Passons maintenant au code Java, ¬´pour le nettoyage¬ª, et tout ressemble √† Kotlin, √† l'exception des points-virgules et du mot nouveau - eh bien, vous ne vous en d√©barrasserez pas. <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">useAnalytics</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ Analytics.send(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Event(<span class="hljs-string"><span class="hljs-string">"only_name_event"</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Map&lt;String, Object&gt; props = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HashMap&lt;&gt;(); props.put(USER_ID, <span class="hljs-number"><span class="hljs-number">1235</span></span>); props.put(<span class="hljs-string"><span class="hljs-string">"my_custom_attr"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>); Analytics.send(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Event(<span class="hljs-string"><span class="hljs-string">"custom_event"</span></span>, props)); <span class="hljs-keyword"><span class="hljs-keyword">boolean</span></span> hasPlugins = Analytics.getHasPlugins(); Analytics.addPlugin(Analytics.INSTANCE.getEMPTY_PLUGIN()); <span class="hljs-comment"><span class="hljs-comment">// dry-run // ... }</span></span></code> </pre><br>  √âtape suivante: nous voyons ce getter getHasPlugins dumblement nomm√© avec deux pr√©fixes √† la fois.  Bien s√ªr, je ne suis pas un grand connaisseur de la langue anglaise, mais il me semble que quelque chose d'autre √©tait impliqu√© ici.  Pourquoi cela se produit-il? <br><br>  Comme ils le savaient √©troitement avec Kotlin, les noms de propri√©t√© des getters et setters sont g√©n√©r√©s selon les r√®gles JavaBeans.  Cela signifie que les getters seront g√©n√©ralement avec des pr√©fixes get, les setters avec des pr√©fixes set.  Mais il y a une exception: si vous avez un champ bool√©en et que son nom a le pr√©fixe is, le getter sera pr√©fix√© avec is.  Cela peut √™tre vu dans l'exemple du champ isInited ci-dessus. <br><br>  Malheureusement, les champs bool√©ens sont loin d'√™tre toujours appel√©s via is.  isPlugins ne satisferait pas tout √† fait ce que nous voulons montrer s√©mantiquement par son nom.  Comment on va? <br><br>  Et ce n'est pas difficile pour nous, pour cela il y a notre propre annotation (comme vous l'avez d√©j√† compris, je vais souvent le r√©p√©ter aujourd'hui).  L'annotation @JvmName vous permet de sp√©cifier n'importe quel nom que nous voulons (naturellement pris en charge par Java).  Ajoutez-le: <br><br><pre> <code class="hljs kotlin"><span class="hljs-meta"><span class="hljs-meta">@JvmStatic</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> hasPlugins <span class="hljs-meta"><span class="hljs-meta">@JvmName(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"hasPlugin"</span></span></span><span class="hljs-meta">)</span></span> <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>() = plugins.isNotEmpty()</code> </pre><br>  V√©rifions ce que nous avons obtenu en Java: la m√©thode getHasPlugins n'est plus l√†, mais hasPlugins est quelque chose en soi.  Cela a r√©solu notre probl√®me, encore une fois, avec une annotation.  Maintenant, nous r√©solvons toutes les annotations! <br><br>  Comme vous pouvez le voir, nous pla√ßons ici l'annotation directement sur le getter.  Quelle en est la raison?  Avec le fait que sous la propri√©t√©, il y a beaucoup de tout, et on ne sait pas √† quoi s'applique @JvmName.  Si vous transf√©rez l'annotation √† val hasPlugins lui-m√™me, le compilateur ne comprendra pas √† quoi l'appliquer. <br><br>  Cependant, Kotlin a √©galement la possibilit√© de sp√©cifier o√π les annotations sont utilis√©es directement.  Vous pouvez sp√©cifier le getter cible, le fichier entier, le param√®tre, le d√©l√©gu√©, le champ, les propri√©t√©s, les fonctions d'extension du r√©cepteur, le setter et le param√®tre setter.  Dans notre cas, getter est int√©ressant.  Et si vous aimez cela, cela aura le m√™me effet que lorsque nous avons suspendu l'annotation sur get: <br><br><pre> <code class="hljs kotlin"><span class="hljs-meta"><span class="hljs-meta">@get:JvmName</span></span>(<span class="hljs-string"><span class="hljs-string">"hasPlugins"</span></span>) <span class="hljs-meta"><span class="hljs-meta">@JvmStatic</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> hasPlugins <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>() = plugins.isNotEmpty()</code> </pre><br>  En cons√©quence, si vous n'avez pas de getter personnalis√©, vous pouvez le joindre directement √† votre propri√©t√© et tout ira bien. <br><br>  Le point suivant qui nous d√©route un peu est "Analytics.INSTANCE.getEMPTY_PLUGIN ()".  Ici, la question n'est m√™me plus en anglais, mais simplement: POURQUOI?  La r√©ponse est √† peu pr√®s la m√™me, mais d'abord une petite introduction. <br><br>  Pour rendre un champ constant, vous avez deux fa√ßons.  Si vous d√©finissez une constante en tant que type primitif ou en tant que cha√Æne, et √©galement √† l'int√©rieur de l'objet, vous pouvez utiliser le mot cl√© const, puis les getter-setters et autres ne seront pas g√©n√©r√©s.  Ce sera une constante ordinaire - statique finale priv√©e - et elle sera ins√©r√©e, c'est-√†-dire une chose Java absolument ordinaire. <br><br>  Mais si vous voulez cr√©er une constante √† partir d'un objet diff√©rent de la cha√Æne, vous ne pourrez pas utiliser le mot const pour cela.  Ici, nous avons val EMPTY_PLUGIN = EmptyPlugin (), selon lui, ce terrible getter a √©videmment √©t√© g√©n√©r√©.  Nous pouvons renommer @JvmName avec une annotation, supprimer ce pr√©fixe get, mais cela reste une m√©thode - avec des crochets.  Ainsi, les anciennes solutions ne fonctionneront pas, nous recherchons de nouvelles. <br><br>  Et voici pour cela l'annotation @JvmField, qui dit: "Je ne veux pas de getters ici, je ne veux pas de setters, faites-moi un champ."  Mettez-le devant val EMPTY_PLUGIN et v√©rifiez que tout est vrai. <br><br><img src="https://habrastorage.org/webt/7e/ei/0i/7eei0iwsgrd3pvkg_6lljoylhzm.png"><br><br>  Kotlin Bytecode Viewer affiche la pi√®ce en surbrillance sur laquelle vous vous trouvez actuellement dans le fichier.  Nous sommes maintenant sur EMPTY_PLUGIN, et vous voyez qu'ici une sorte d'initialisation est √©crite dans le constructeur.  Le fait est que le getter n'est plus l√† et que l'acc√®s n'y est que pour l'enregistrement.  Et si vous cliquez sur d√©compiler, nous voyons que ¬´final statique statique EmptyPlugin EMPTY_PLUGIN¬ª est apparu, c'est exactement ce que nous avons r√©alis√©.  Sympa.  Nous v√©rifions que tout pla√Æt √† tout le monde, en particulier au compilateur.  La chose la plus importante que vous devez apaiser est le compilateur. <br><br><h2>  G√©n√©riques </h2><br>  Prenons une pause dans le code et regardons les g√©n√©riques.  C'est un sujet assez chaud.  Ou glissante, qui n'aime plus √ßa.  Java a ses propres complexit√©s, mais Kotlin est diff√©rent.  Tout d'abord, nous nous pr√©occupons de la variation.  Qu'est ce que c'est <br><br>  La variabilit√© est un moyen de transf√©rer des informations sur une hi√©rarchie de types des types de base aux d√©riv√©s, par exemple, aux conteneurs ou aux g√©n√©riques.  Nous avons ici les classes Animal et Dog avec une connexion tr√®s √©vidente: Dog est un sous-type, Animal est un sous-type, la fl√®che vient du sous-type. <br><br><img src="https://habrastorage.org/webt/rz/-b/uz/rz-buzyeywt0xgwewjvauwmf0lc.png"><br><br>  Et quel lien leurs d√©riv√©s auront-ils?  Regardons quelques cas. <br><br>  Le premier est Iterator.  Pour d√©terminer ce qu'est un sous-type et ce qui est un sous-type, nous serons guid√©s par la r√®gle de substitution Barbara Liskov.  Il peut √™tre formul√© comme suit: "le sous-type ne devrait pas exiger plus et ne pas fournir moins". <br><br>  Dans notre situation, la seule chose qu'Iterator fait est de nous donner des objets dactylographi√©s, par exemple, Animal.  Si nous acceptons Iterator quelque part, nous pouvons bien y mettre Iterator et obtenir Animal de la m√©thode next (), car le chien est aussi Animal.  Nous fournissons non pas moins, mais plus, car un chien est un sous-type. <br><br><img src="https://habrastorage.org/webt/bz/4e/ra/bz4eracdjm_ep_qnzk0mbkr5q7w.png"><br><br>  Je le r√©p√®te: nous ne lisons que sur ce type, donc la relation entre le type et le sous-type est pr√©serv√©e ici.  Et ces types sont appel√©s covariants. <br><br>  Un autre cas: l'action.  Action est une fonction qui ne renvoie rien, prend un param√®tre, et nous √©crivons seulement √† Action, c'est-√†-dire qu'elle nous prend un chien ou un animal. <br><br><img src="https://habrastorage.org/webt/h5/hg/74/h5hg74k6id9rwtzfq1j2g1qsjyk.png"><br><br>  Ainsi, ici, nous ne fournissons plus, mais demandons, et nous ne devons plus exiger.  Cela signifie que notre d√©pendance √©volue.  "Pas plus" nous avons Animal (Animal moins qu'un chien).  Et ces types sont appel√©s contravariants. <br><br>  Il y a un troisi√®me cas - par exemple, ArrayList, √† partir duquel nous lisons et √©crivons.  Par cons√©quent, dans ce cas, nous violons l'une des r√®gles, nous en demandons plus pour un dossier (un chien, pas un animal).  Ces types ne sont pas li√©s en aucune fa√ßon, et ils sont appel√©s invariants. <br><br><img src="https://habrastorage.org/webt/gj/5o/gp/gj5ogpkqy1ifvtmxghqszew7fgk.png"><br><br>  Ainsi, en Java, quand il a √©t√© con√ßu avant la version 1.5 (o√π les g√©n√©riques sont apparus), par d√©faut, ils ont fait des tableaux covariants.  Cela signifie que vous pouvez affecter un tableau de cha√Ænes au tableau d'objets, puis le transmettre quelque part √† la m√©thode o√π le tableau d'objets est n√©cessaire, et essayer d'y pousser l'objet, bien qu'il s'agisse d'un tableau de cha√Ænes.  Tout vous reviendra. <br><br>  Ayant appris d'une exp√©rience am√®re que cela ne peut pas √™tre fait, lors de la conception de g√©n√©riques, ils ont d√©cid√© "nous rendrons les collections invariantes, nous ne ferons rien avec elles". <br><br>  Et √† la fin, il s'av√®re que dans une chose aussi apparemment √©vidente, tout devrait √™tre ok, mais en fait pas ok: <br><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// Java List&lt;Dog&gt; dogs = new ArrayList&lt;&gt;(); List&lt;Animal&gt; animals = dogs;</span></span></code> </pre><br>  Mais nous devons en quelque sorte d√©terminer ce que, apr√®s tout, nous pouvons: si nous ne lisons que cette feuille, pourquoi ne pas permettre de transf√©rer la liste des chiens ici?  Par cons√©quent, il est possible de caract√©riser avec un caract√®re g√©n√©rique le type de variation que ce type aura: <br><br><pre> <code class="java hljs">List&lt;Dog&gt; dogs = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList&lt;&gt;(); List&lt;? extends Animal&gt; animals = dogs;</code> </pre><br>  Comme vous pouvez le voir, cette variation est indiqu√©e sur le lieu d'utilisation, o√π nous affectons les chiens.  Par cons√©quent, cela s'appelle la variance du site d'utilisation. <br><br>  Quels sont les inconv√©nients de cela?  Le c√¥t√© n√©gatif est que vous devez sp√©cifier ces caract√®res g√©n√©riques effrayants partout o√π vous utilisez votre API, et tout cela est tr√®s fructueux dans le code.  Mais dans Kotlin pour une raison quelconque, une telle chose fonctionne hors de la bo√Æte, et vous n'avez rien √† sp√©cifier: <br><br><pre> <code class="hljs scala"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> dogs: <span class="hljs-type"><span class="hljs-type">List</span></span>&lt;<span class="hljs-type"><span class="hljs-type">Dog</span></span>&gt; = <span class="hljs-type"><span class="hljs-type">ArrayList</span></span>() <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> animals: <span class="hljs-type"><span class="hljs-type">List</span></span>&lt;<span class="hljs-type"><span class="hljs-type">Animal</span></span>&gt; = dogs</code> </pre><br>  Quelle en est la raison?  Avec le fait que les draps sont r√©ellement diff√©rents.  La liste en Java signifie l'√©criture, tandis qu'en Kotlin, elle est en lecture seule, ce qui n'implique pas.  Par cons√©quent, en principe, nous pouvons imm√©diatement dire que nous ne faisons que lire d'ici, nous pouvons donc √™tre covariants.  Et cela est d√©fini pr√©cis√©ment dans la d√©claration de type avec le mot cl√© out rempla√ßant le caract√®re g√©n√©rique: <br><br><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">List</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">out E</span></span></span><span class="hljs-class">&gt; : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Collection</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">E</span></span></span><span class="hljs-class">&gt;</span></span></code> </pre><br>  C'est ce qu'on appelle la variance du site de d√©claration.  Ainsi, nous avons tout indiqu√© en un seul endroit, et l√† o√π nous l'utilisons, nous ne touchons plus √† ce sujet.  Et c'est nishtyak. <br><br><h2>  Retour au code </h2><br>  Revenons √† nos profondeurs.  Ici, nous avons la m√©thode addPlugins, elle prend une liste: <br><br><pre> <code class="hljs kotlin"><span class="hljs-meta"><span class="hljs-meta">@JvmStatic</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">addPlugins</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(plugs: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">List</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Plugin</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;)</span></span></span></span> { plugs.forEach { addPlugin(it) } }    ,  , List&lt;EmptyPlugin&gt;, ,     : &lt;source lang=<span class="hljs-string"><span class="hljs-string">"java"</span></span>&gt; <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> List&lt;EmptyPlugin&gt; pluginsToSet = Arrays.asList(new LoggerPlugin(<span class="hljs-string"><span class="hljs-string">"Alog"</span></span>), new SegmentPlugin());</code> </pre><br>  √âtant donn√© que List in Kotlin est covariant, nous pouvons facilement transmettre la liste des h√©ritiers du plugin ici.  Tout fonctionnera, le compilateur ne s'en soucie pas.  Mais √©tant donn√© que nous avons une variance de site de d√©claration o√π nous avons tout sp√©cifi√©, nous ne pouvons pas contr√¥ler la connexion avec Java au stade de l'utilisation.  Mais que se passe-t-il si nous voulons vraiment une feuille de plugin l√†-bas, nous ne voulons pas d'h√©ritiers l√†-bas?  Il n'y a pas de modificateurs pour cela, mais quoi?  C'est vrai, il y a une annotation.  Et l'annotation s'appelle @JvmSuppressWildcards, c'est-√†-dire que par d√©faut, nous pensons qu'il s'agit d'un type avec caract√®re g√©n√©rique, le type est covariant. <br><br><pre> <code class="hljs kotlin"><span class="hljs-meta"><span class="hljs-meta">@JvmStatic</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">addPlugins</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(plugs: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">List</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;@</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">JvmSuppressWildcards</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Plugin</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;)</span></span></span></span> { plugs.forEach { addPlugin(it) } }</code> </pre><br>  En parlant de SuppressWildcards, nous supprimons toutes ces questions, et notre signature change en fait.  Encore plus que cela, je vais vous montrer √† quoi tout ressemble en bytecode: <br><br><img src="https://habrastorage.org/webt/rn/xp/ft/rnxpft1zqpioojczpiiyn1g3veo.png"><br><br>  Je vais supprimer l'annotation du code pour l'instant.  Voici notre m√©thode.  Vous savez probablement que l'effacement de type existe.  Et dans votre bytecode, il n'y a aucune information sur le type de questions qu'il y avait, eh bien, les g√©n√©riques en g√©n√©ral.  Mais le compilateur suit cela et le signe dans les commentaires du bytecode: et c'est le type avec la question. <br><br><img src="https://habrastorage.org/webt/u4/5e/mm/u45emmdne71zx9e9whz7uu8law0.png"><br><br>  Maintenant, nous ins√©rons √† nouveau l'annotation et voyons que c'est notre type sans remettre en question. <br><br><img src="https://habrastorage.org/webt/cu/if/wm/cuifwmem7zn636x3ky7n_41vuly.png"><br><br>  Maintenant, notre code pr√©c√©dent arr√™tera de compiler pr√©cis√©ment parce que nous avons coup√© les caract√®res g√©n√©riques.  Vous pouvez voir par vous-m√™me. <br><br>  Nous avons fait des types covariants.  Maintenant, l'inverse est vrai. <br><br>  Nous pensons que List a une question.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Il est √©vident de supposer que lorsque cette feuille reviendra de getPlugins, ce sera aussi avec une question. Qu'est-ce que cela signifie? Cela signifie que nous ne pourrons pas y √©crire, car le type est covariant et non contravariant. Jetons un coup d'≈ìil √† ce qui se passe en Java.</font></font><br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">final</span></span> List&lt;Plugin&gt; plugins = Analytics.getPlugins(); displayPlugins(plugins); Analytics.getPlugins().add(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> EmptyPlugin());</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Personne n'est scandalis√© que dans la derni√®re ligne, nous √©crivions quelque chose, ce qui signifie que quelqu'un ici a tort. Si nous regardons le bytecode, nous serons convaincus de l'exactitude de nos soup√ßons. Nous n'avons pas raccroch√© d'annotations, et le type pour une raison quelconque sans poser de question. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La surprise est bas√©e sur cela. Kotlin se postule comme un langage pragmatique, donc quand tout cela a √©t√© con√ßu, des statistiques ont √©t√© collect√©es, car les caract√®res g√©n√©riques sont g√©n√©ralement utilis√©s en Java. Il s'est av√©r√© que l'entr√©e est le plus souvent autoris√©e la variance, c'est-√†-dire rendre les types covariants. Eh bien, c'est utile partout o√π nous voulons qu'une liste puisse y mettre une feuille de n'importe quel h√©ritier du plugin. Et ici, l√† o√π nous revenons, au contraire, nous voulons avoir des types purs: comme il y a une fiche Plugin, elle sera retourn√©e.</font></font><br><br>       .    ,        ,      usecase,      - ,     . <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mais dans ce cas, nous voyons qu'une telle situation n'est pas pour nous, car nous ne voulons pas que quelque chose y soit enregistr√©. Et nous ne voulons pas non plus que cela soit possible √† partir de Java. Dans Kotlin, ici List est un type en lecture seule, et nous ne pouvons rien √©crire l√†-bas, mais le client de notre biblioth√®que est venu de Java et a tout bourr√© l√†-dedans - qui voudrait? Par cons√©quent, nous allons forcer cette m√©thode √† renvoyer une liste avec un caract√®re g√©n√©rique. Et nous pouvons expliquer clairement comment. En ajoutant l'annotation @JvmWildcard, nous disons: g√©n√©rez un type avec une question pour nous, tout est assez simple. Voyons maintenant ce qui se passe en Java √† cet endroit. Java dit "que faites-vous?":</font></font><br><br><img src="https://habrastorage.org/webt/su/v_/1r/suv_1rnnuub7bsqlod-oglgra74.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ici, nous pouvons m√™me lancer dans la liste correcte &lt;? </font><font style="vertical-align: inherit;">√©tend le plugin&gt;, mais elle dit toujours "que faites-vous?" </font><font style="vertical-align: inherit;">Et, en principe, cette situation nous convient jusqu'√† pr√©sent. </font><font style="vertical-align: inherit;">Mais il y a un script kiddie qui dit: "J'ai vu la source, c'est une source ouverte, je sais qu'il y a une ArrayList, et je vais vous pirater." </font><font style="vertical-align: inherit;">Et tout fonctionnera, car il y a vraiment une ArrayList et il sait ce qui peut y √™tre √©crit.</font></font><br><br><pre> <code class="java hljs">((ArrayList&lt;Plugin&gt;) Analytics.getPlugins()).add(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> EmptyPlugin());</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Par cons√©quent, bien s√ªr, accrochez des annotations int√©ressantes, mais vous devez toujours utiliser la copie d√©fensive, qui est connue depuis longtemps. </font><font style="vertical-align: inherit;">Soryan, nulle part sans lui, si vous voulez que les script kiddies ne vous d√©rangent pas.</font></font><br><br><pre> <code class="hljs kotlin"><span class="hljs-meta"><span class="hljs-meta">@JvmStatic</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getPlugins</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>: List&lt;<span class="hljs-meta"><span class="hljs-meta">@JvmWildcard</span></span> Plugin&gt; = plugin.toImmutableList()</code> </pre><br>  ,   @JvmSuppressWildcard     ,       ,    ,     ,     . <br><br>    ,     .    ,     : . <br><br>       Java.   ,    : <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">send</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@NotNull Event event)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> IOException</span></span></code> </pre><br>    : <br><br><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Plugin</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">init</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> <span class="hljs-comment"><span class="hljs-comment">/** </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@throws</span></span></span><span class="hljs-comment"> IOException if sending failed */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">send</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(event: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Event</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> <span class="hljs-comment"><span class="hljs-comment">// ... }</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√Ä Kotlin, il n'y a pas d'exception v√©rifi√©e. </font><font style="vertical-align: inherit;">Et nous disons dans la documentation: vous pouvez jeter ici. </font><font style="vertical-align: inherit;">Eh bien, nous jetons, jetons, jetons. </font><font style="vertical-align: inherit;">Mais Java n'aime pas pour une raison quelconque. </font><font style="vertical-align: inherit;">Dit: "mais Throws pour une raison quelconque n'est pas dans votre signature, monsieur": </font></font><br><br><img src="https://habrastorage.org/webt/g-/v8/go/g-v8gog8gwfa-on0anv0bkwktsk.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mais comment puis-je ajouter quelque chose ici, ici Kotlin? </font><font style="vertical-align: inherit;">Eh bien, vous connaissez la r√©ponse ... </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Il y a une annotation @Throws qui fait exactement cela. </font><font style="vertical-align: inherit;">Il modifie la partie des lancers dans la signature de la m√©thode. </font><font style="vertical-align: inherit;">Nous disons que nous pouvons lancer une IOExeption ici:</font></font><br><br><pre> <code class="hljs kotlin"><span class="hljs-keyword"><span class="hljs-keyword">open</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">EmptyPlugin</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Plugin { @Throws</span></span></span></span>(IOException::<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class">) </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">override</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">fun</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">send</span></span></span></span>(event: Event) {} <span class="hljs-comment"><span class="hljs-comment">// ... }</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Et ajoutez cette chose en m√™me temps √† l'interface: </font></font><br><br><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Plugin</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">init</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> <span class="hljs-comment"><span class="hljs-comment">/** </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@throws</span></span></span><span class="hljs-comment"> IOException if sending failed */</span></span> <span class="hljs-meta"><span class="hljs-meta">@Throws(IOException::class)</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">send</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(event: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Event</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> <span class="hljs-comment"><span class="hljs-comment">// ... }</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Et maintenant quoi? </font><font style="vertical-align: inherit;">Maintenant, notre plugin, √©crit en Java, o√π nous avons des informations sur l'exception, est satisfait de tout. </font><font style="vertical-align: inherit;">Tout fonctionne, compile. </font><font style="vertical-align: inherit;">En principe, c'est plus ou moins tout avec des annotations, mais il y a deux autres nuances sur la fa√ßon d'utiliser @JvmName. </font><font style="vertical-align: inherit;">Un int√©ressant. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous avons ajout√© toutes ces annotations pour rendre Java magnifique. </font><font style="vertical-align: inherit;">Et ici ...</font></font><br><br><pre> <code class="hljs kotlin"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> util <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> List</span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">&lt;Int&gt;</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">printReversedSum</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { println(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.foldRight(<span class="hljs-number"><span class="hljs-number">0</span></span>) { it, acc -&gt; it + acc }) } <span class="hljs-meta"><span class="hljs-meta">@JvmName(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"printReversedConcatenation"</span></span></span><span class="hljs-meta">)</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> List</span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">&lt;String&gt;</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">printReversedSum</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { println(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.foldRight(StringBuilder()) { it, acc -&gt; acc.append(it) }) }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Supposons qu'en Java, nous ne nous soucions pas ici, supprimez l'annotation. Erreurs, l'EDI affiche maintenant une erreur dans les deux fonctions. Selon vous, quelle en est la raison? Oui, sans annotation, ils sont g√©n√©r√©s avec le m√™me nom, mais ici il est √©crit que l'un est sur la liste, l'autre sur la liste. √Ä droite, tapez effacement. On peut m√™me v√©rifier ce cas:</font></font><br><br><img src="https://habrastorage.org/webt/qk/oq/jr/qkoqjrub5xc4mdn-twq-s_jehl4.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vous savez d√©j√†, si je comprends bien, que toutes les fonctions de niveau sup√©rieur sont g√©n√©r√©es dans un contexte statique. </font><font style="vertical-align: inherit;">Et sans cette annotation, nous allons essayer de g√©n√©rer printReversedSum √† partir de List, et en dessous d'un autre √©galement √† partir de List. </font><font style="vertical-align: inherit;">Parce que le compilateur Kotlin conna√Æt les g√©n√©riques, mais pas le bytecode Java. </font><font style="vertical-align: inherit;">Par cons√©quent, c'est le seul cas o√π les annotations du package kotlin.jvm sont n√©cessaires non pas pour que Java soit bon et pratique, mais pour que votre Kotlin compile. </font><font style="vertical-align: inherit;">Nous d√©finissons un nouveau nom - une fois que nous travaillons avec des cha√Ænes, puis nous utilisons la concat√©nation - et tout fonctionne bien, maintenant tout se compile. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Et le deuxi√®me cas d'utilisation. </font><font style="vertical-align: inherit;">C'est li√© √† cela. </font><font style="vertical-align: inherit;">Nous avons une fonction d'extension inverse.</font></font><br><br><pre> <code class="hljs kotlin"><span class="hljs-keyword"><span class="hljs-keyword">inline</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> String.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">reverse</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> = StringBuilder(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>).reverse().toString() <span class="hljs-keyword"><span class="hljs-keyword">inline</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">&lt;</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-type"><span class="hljs-keyword">reified</span></span></span></span><span class="hljs-function"><span class="hljs-type"> T&gt;</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">reversedClassName</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> = T::<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">java</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">simpleName</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">reverse</span></span></span></span>() <span class="hljs-keyword"><span class="hljs-keyword">inline</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">&lt;T&gt;</span></span></span><span class="hljs-function"> Iterable</span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">&lt;T&gt;</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">forEachReversed</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(action: (</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">T</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Unit</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (element <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.reversed()) action(element) }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ce reverse compile dans une m√©thode de classe statique appel√©e ReverserKt. </font></font><br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">useUtils</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ System.out.println(ReverserKt.reverse(<span class="hljs-string"><span class="hljs-string">"Test"</span></span>)); SumsKt.printReversedSum(asList(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>)); SumsKt.printReversedConcatenation(asList(<span class="hljs-string"><span class="hljs-string">"1"</span></span>, <span class="hljs-string"><span class="hljs-string">"2"</span></span>, <span class="hljs-string"><span class="hljs-string">"3"</span></span>, <span class="hljs-string"><span class="hljs-string">"4"</span></span>, <span class="hljs-string"><span class="hljs-string">"5"</span></span>)); }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Je pense que ce n'est pas nouveau pour vous. La nuance est que les personnes utilisant notre biblioth√®que en Java peuvent suspecter que quelque chose ne va pas. Nous avons divulgu√© les d√©tails de la mise en ≈ìuvre de notre biblioth√®que du c√¥t√© de l'utilisateur et voulons couvrir nos traces. Comment pouvons-nous faire cela? Comme d√©j√† clair, l'annotation @JvmName, dont je parle maintenant, mais il y a une mise en garde. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pour commencer, nous lui donnerons le nom que nous voulons, nous ne graverons pas, et il est important de dire que nous utilisons cette annotation sur le fichier, nous devons renommer le fichier.</font></font><br><br><pre> <code class="hljs ruby">@file<span class="hljs-symbol"><span class="hljs-symbol">:Suppress</span></span>(<span class="hljs-string"><span class="hljs-string">"NOTHING_TO_INLINE"</span></span>) @file<span class="hljs-symbol"><span class="hljs-symbol">:JvmName</span></span>(<span class="hljs-string"><span class="hljs-string">"ReverserUtils"</span></span>)</code> </pre><br>    Java   ReverserKt,   ,   ReverserUtils   .   ¬´ 2.1¬ª ‚Äî  ,       top-level     ,   . ,    ,    sums.kt   SumsKt,  ,       reversing    ReverserUtils.        @JvmName,  ¬´ReverserUtils¬ª,  ,  ,      ,  . <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bien que l'environnement ne vous avertisse pas √† l'avance, lorsque vous essayez de compiler, ils nous diront que "vous voulez g√©n√©rer deux classes dans le m√™me package avec le m√™me nom, ata". </font><font style="vertical-align: inherit;">Que faut-il faire? </font><font style="vertical-align: inherit;">Ajoutez la derni√®re annotation @JvmMultifileClass dans ce package, qui indique que le contenu de plusieurs fichiers se transformera en une seule classe, c'est-√†-dire qu'il n'y aura qu'une seule fa√ßade pour cela. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dans les deux cas, nous ajoutons "@file: JvmMultifileClass", et vous pouvez remplacer SumsKt par ReverserUtils, tout le monde est content - croyez-moi. </font><font style="vertical-align: inherit;">Avec des annotations faites! </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous avons parl√© avec vous de ce package, de toutes les annotations. </font><font style="vertical-align: inherit;">En principe, il est d√©j√† clair d'apr√®s leurs noms √† quoi chacun est utilis√©. </font><font style="vertical-align: inherit;">Il y a des cas d√©licats lorsque vous avez besoin, par exemple, @JvmName est m√™me facile √† utiliser dans Kotlin.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Sp√©cifique √† Kotlin </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mais ce n'est probablement pas tout ce que vous aimeriez savoir. Il est √©galement important de noter comment travailler avec des choses sp√©cifiques √† Kotlin. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Par exemple, les fonctions en ligne. Ils sont en ligne dans Kotlin et, semble-t-il, seront-ils m√™me accessibles depuis Java en bytecode? Il s'av√®re qu'ils le feront, tout ira bien et les m√©thodes sont r√©ellement disponibles pour Java. Bien que si vous √©crivez, par exemple, un projet Kotlin uniquement, cela n'affecte pas assez bien votre limite de nombre de dex. Parce qu'√† Kotlin, ils ne sont pas n√©cessaires, mais en r√©alit√© ils seront en bytecode. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ensuite, notez les param√®tres de type Reified. Ces param√®tres sont sp√©cifiques √† Kotlin, ils ne sont disponibles que pour les fonctions en ligne et vous permettent d'inverser les hacks qui ne sont pas disponibles en Java avec r√©flexion. Comme il s'agit uniquement de Kotlin, il n'est disponible que pour Kotlin et, en Java, vous ne pouvez malheureusement pas utiliser de fonctions avec r√©ifi√©.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">java.lang.Class. </font><font style="vertical-align: inherit;">Si nous voulons r√©fl√©chir un peu et que notre biblioth√®que est √©galement pour Java, elle doit √™tre prise en charge. </font><font style="vertical-align: inherit;">Voyons un exemple. </font><font style="vertical-align: inherit;">Nous avons un tel ¬´notre retrofit¬ª, rapidement √©crit sur mon genou (je ne comprends pas ce que les gars ont √©crit depuis si longtemps):</font></font><br><br><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Retrofit</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">private</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">constructor</span></span></span></span>( <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> baseUrl: String, <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> client: Client ) { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">&lt;T : Any&gt;</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">create</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(service: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Class</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">T</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;)</span></span></span></span>: T {...} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">&lt;T : Any&gt;</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">create</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(service: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">KClass</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">T</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;)</span></span></span></span>: T { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> create(service.java) } }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Il y a une m√©thode qui fonctionne avec la classe Java, il y a une m√©thode qui fonctionne avec Kotlin KClass, vous n'avez pas besoin de faire deux impl√©mentations diff√©rentes, vous pouvez utiliser des propri√©t√©s d'extension qui obtiennent Class de KClass, KClass de Class (cela s'appelle Kotlin, en principe √©videmment). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tout cela fonctionnera, mais c'est un peu non idiomatique. </font><font style="vertical-align: inherit;">Dans le code Kotlin, vous ne passez pas KClass, vous √©crivez en utilisant des types r√©ifi√©s, il est donc pr√©f√©rable de refaire la m√©thode comme ceci:</font></font><br><br><pre> <code class="hljs kotlin"><span class="hljs-keyword"><span class="hljs-keyword">inline</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">&lt;</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-type"><span class="hljs-keyword">reified</span></span></span></span><span class="hljs-function"><span class="hljs-type"> T : Any&gt;</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">create</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>: T { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> create(T::<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">java</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">java</span></span></span><span class="hljs-class">)</span></span></code> </pre><br>  .    Kotlin  ,    .  <i>val api = retrofit.create(Api::class)</i>   <i>val api = retrofit.create&lt;Api&gt;()</i> ,   ::class  .    Reified-,    -. <br><br> Unit.     Unit,      ,   void  Java,  .      .       ,       .  -   Scala,   Scala      ,   - ,       ,    ,    void. <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mais √† Kotlin, ce n'est pas le cas. </font><font style="vertical-align: inherit;">Kotlin n'a que 22 interfaces qui acceptent un ensemble diff√©rent de param√®tres et renvoient quelque chose. </font><font style="vertical-align: inherit;">Ainsi, le lambda qui retourne Unit retournera non nul, mais Unit. </font><font style="vertical-align: inherit;">Et cela impose ses limites. </font><font style="vertical-align: inherit;">√Ä quoi ressemble le lambda qui retourne Unit? </font><font style="vertical-align: inherit;">Maintenant, regardez-la dans ce fragment de code. </font><font style="vertical-align: inherit;">Apprenez √† vous conna√Ætre.</font></font><br><br><pre> <code class="hljs kotlin"><span class="hljs-keyword"><span class="hljs-keyword">inline</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">&lt;T&gt;</span></span></span><span class="hljs-function"> Iterable</span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">&lt;T&gt;</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">forEachReversed</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(action: (</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">T</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Unit</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (element <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.reversed()) action(element) }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Utilisation de Kotlin: tout va bien, nous utilisons m√™me une r√©f√©rence de m√©thode, si nous le pouvons, et elle se lit parfaitement, nos yeux ne sont pas calleux. </font></font><br><br><pre> <code class="hljs kotlin"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">useMisc</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { listOf(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>).forEachReversed(::println) println(reversedClassName&lt;String&gt;()) }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Que se passe-t-il en Java? </font><font style="vertical-align: inherit;">En Java, le cano√´ suivant se produit:</font></font><br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">useMisc</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> List&lt;Integer&gt; list = asList(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>); ReverserUtils.forEachReversed(list, integer -&gt; { System.out.println(integer); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Unit.INSTANCE; });</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En raison du fait que nous devons retourner quelque chose ici. C'est comme un Vide avec une majuscule, on ne peut pas simplement prendre et marquer dessus. Nous ne pouvons pas utiliser la m√©thode de r√©f√©rence ici, qui retourne nulle, malheureusement. Et c'est probablement la premi√®re chose qui cogne vraiment les yeux apr√®s toutes nos manipulations avec des annotations. Malheureusement, vous devrez renvoyer l'instance d'unit√© d'ici. Vous pouvez annuler, de toute fa√ßon, personne n'en a besoin. Je veux dire, personne n'a besoin d'une valeur de retour. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Allons plus loin: Typealiases est aussi une chose assez sp√©cifique, ce sont juste des alias ou des synonymes, ils ne sont disponibles que chez Kotlin, et en Java, malheureusement, vous utiliserez ce qui se trouve sous ces alias. Soit c'est une corbeille de g√©n√©riques trois fois ferm√©s, soit une sorte de classes imbriqu√©es. Les programmeurs Java ont l'habitude de vivre avec cela.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Maintenant, pour la partie int√©ressante: la visibilit√©. Ou plut√¥t, une visibilit√© interne. Vous savez probablement que dans Kotlin il n'y a pas de paquet priv√©, si vous √©crivez sans aucun modificateur, il sera public. Mais il y a interne. Interne est une chose tellement d√©licate que nous allons m√™me l'examiner maintenant. Dans Retrofit, nous avons une m√©thode de validation interne.</font></font><br><br><pre> <code class="hljs kotlin"><span class="hljs-keyword"><span class="hljs-keyword">internal</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">validate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>: Retrofit { println(<span class="hljs-string"><span class="hljs-string">"!!!!!! internal fun validate() was called !!!!!!"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span> }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Il ne peut pas √™tre appel√© depuis Kotlin, et cela est compr√©hensible. </font><font style="vertical-align: inherit;">Que se passe-t-il avec Java? </font><font style="vertical-align: inherit;">Pouvons-nous appeler valider? </font><font style="vertical-align: inherit;">Ce n'est peut-√™tre pas un secret pour vous que les transformations internes deviennent publiques. </font><font style="vertical-align: inherit;">Si vous ne me croyez pas, croyez la visionneuse de bytecode Kotlin. </font></font><br><br><img src="https://habrastorage.org/webt/cc/mr/ts/ccmrtst8oqwmbdvgn4onk8jlrus.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C'est vraiment public, mais avec une signature si terrible qui laisse entendre √† une personne qu'il n'a probablement pas √©t√© enti√®rement con√ßu qu'un tel fluage rampe dans l'API publique. </font><font style="vertical-align: inherit;">Si quelqu'un a format√© 80 caract√®res, cette m√©thode peut m√™me ne pas tenir sur une seule ligne. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En Java, nous avons maintenant ceci:</font></font><br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Api api = retrofit .validate$production_sources_for_module_library_main() .create(Api.class); api.sendMessage(<span class="hljs-string"><span class="hljs-string">"Hello from Java"</span></span>); }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Essayons de compiler ce cas. </font><font style="vertical-align: inherit;">Donc, au moins √ßa ne compilera pas, pas mal d√©j√†. </font><font style="vertical-align: inherit;">Nous pourrions nous arr√™ter ici, mais laissez-moi vous expliquer cela. </font><font style="vertical-align: inherit;">Et si j'aime √ßa?</font></font><br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Api api = retrofit .validate$library() .create(Api.class); api.sendMessage(<span class="hljs-string"><span class="hljs-string">"Hello from Java"</span></span>); }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Compile ensuite. Et la question se pose: "Pourquoi?" Que puis-je dire ... MAGIQUE! </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Par cons√©quent, il est tr√®s important que si vous collez quelque chose de critique en interne, cela soit mauvais car cela fuira dans votre API publique. Et si le script kiddie est arm√© d'un Kotlin Bytecode Viewer, alors ce sera mauvais. N'utilisez rien de tr√®s important dans les m√©thodes √† visibilit√© interne. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si vous voulez plus de joie, je recommande deux choses. Pour le rendre plus confortable pour travailler avec le bytecode et le lire, je recommande un rapport de Zhenya Vartanov, il y a une </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">vid√©o gratuite</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , malgr√© le fait que cela provienne de l'√©v√©nement SkillsMatter. Tr√®s cool. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Et une assez vieille </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">s√©rie</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">de trois articles de Christophe Bales sur les diff√©rentes fonctionnalit√©s de Kotlin. </font><font style="vertical-align: inherit;">Tout est cool √©crit l√†-bas, quelque chose n'a plus d'importance maintenant, mais en g√©n√©ral c'est tr√®s intelligible. </font><font style="vertical-align: inherit;">Tout de m√™me avec le visualiseur de bytecode Kotlin et tout √ßa.</font></font><br><br>  Je vous remercie! <br><br><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si vous avez aim√© le rapport, faites attention: les 8 et 9 d√©cembre, le nouveau </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mobius</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> se tiendra √† Moscou </font><font style="vertical-align: inherit;">, et il y aura √©galement beaucoup de choses int√©ressantes. </font><font style="vertical-align: inherit;">Des informations d√©j√† connues sur le programme sont </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sur le site</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , et des billets peuvent y √™tre achet√©s.</font></font><br></blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr417951/">https://habr.com/ru/post/fr417951/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr417941/index.html">O√π l'eau dans la bouilloire dispara√Æt-elle?</a></li>
<li><a href="../fr417943/index.html">Sans serveur et React 2: tour de passe-passe et aucune fraude</a></li>
<li><a href="../fr417945/index.html">De quels outils dispose la sonde solaire Parker</a></li>
<li><a href="../fr417947/index.html">Visualisation des donn√©es pour votre projet web</a></li>
<li><a href="../fr417949/index.html">Comment ai-je √©crit la biblioth√®que C ++ 11 standard ou pourquoi boost est si effrayant. Chapitre 4.2</a></li>
<li><a href="../fr417953/index.html">Tendances dans la conception de FPGA. La traduction</a></li>
<li><a href="../fr417955/index.html">Comment devenir concepteur d'interface. Comp√©tences n√©cessaires et outils puissants dont on ne nous parle pas</a></li>
<li><a href="../fr417957/index.html">Webinaire ouvert M√©canismes de conteneurisation Linux</a></li>
<li><a href="../fr417959/index.html">10 conseils de conception d'interface</a></li>
<li><a href="../fr417963/index.html">Vent, criquet et date limite: comment nous avons construit la sous-station √©lectrique</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>