<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üì¥ üñêüèª üßïüèø Coletor de Lixo Caseiro para OpenJDK ü§º üè§ ‚ÑπÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Esta √© uma tradu√ß√£o do artigo de Alexey Shipilev ‚ÄúFa√ßa voc√™ mesmo (OpenJDK) Garbage Collector‚Äù , publicado com o consentimento do autor. Relate quaisq...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Coletor de Lixo Caseiro para OpenJDK</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/jugru/blog/443250/"><blockquote>  Esta √© uma tradu√ß√£o do artigo de Alexey Shipilev <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">‚ÄúFa√ßa voc√™ mesmo (OpenJDK) Garbage Collector‚Äù</a> , publicado com o consentimento do autor.  Relate quaisquer erros de digita√ß√£o e outros erros no PM - vamos corrigi-los. </blockquote><p>  O processo de criar algo em tempo de execu√ß√£o √© um exerc√≠cio divertido.  Pelo menos a cria√ß√£o da primeira vers√£o!  Criar um subsistema de tempo de execu√ß√£o confi√°vel, de alto desempenho e com prote√ß√£o contra falhas, cujo comportamento possa ser convenientemente observado e depurado, √© uma tarefa muito, muito dif√≠cil. </p><br><p>  Criar um simples coletor de lixo √© enganosamente simples e agora quero fazer isso neste artigo.  Roman Kennke, no FOSDEM 2019, fez uma palestra e demonstra√ß√£o intitulada <a href="">"Writing a GC in 20 Minutes",</a> usando uma vers√£o anterior deste patch.  Apesar do fato de o c√≥digo implementado l√° demonstrar muito e ser amplamente comentado, √© necess√°rio uma boa descri√ß√£o de alto n√≠vel do que est√° acontecendo - foi assim que este artigo apareceu. </p><br><p>  Um entendimento b√°sico do trabalho dos coletores de lixo ajudar√° bastante a entender o que est√° escrito aqui.  O artigo usar√° detalhes e id√©ias em uma implementa√ß√£o espec√≠fica do HotSpot, mas n√£o haver√° curso introdut√≥rio sobre o design do GC aqui.  Pegue o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Manual</a> do <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">GC</a> e leia os primeiros cap√≠tulos sobre os princ√≠pios b√°sicos do GC, e ainda mais r√°pido iniciar√° <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">o artigo da Wikipedia</a> . </p><br><p><img src="https://habrastorage.org/webt/4v/1i/4y/4v1i4yrxpcef-vvvkknzfuhmt-w.jpeg"></p><a name="habracut"></a><br><h1 id="soderzhanie">  Conte√∫do </h1><br><div class="spoiler">  <b class="spoiler_title">Texto oculto</b> <div class="spoiler_text"><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">1. Em que consiste o GC</a> <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">1.1</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Epsilon gc</a> <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">1.1.1</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Aloca√ß√£o de mem√≥ria</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">1.1.2</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Barreiras</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">1.1.3</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Monitorando a conex√£o</a> </li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">1.2</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Rantime e GC</a> <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">1.2.1</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Elementos raiz</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">1.2.2</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Rastreamento de objetos</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">1.2.3</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Deslocamentos</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">1.2.4</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Dados do marcador</a> </li></ul></li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">2. Plano geral</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">3. Implementa√ß√£o do n√∫cleo do GC</a> <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">3.1</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Pr√≥logo</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">3.2</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Marca√ß√£o</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">3.3</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Calcular novos endere√ßos</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">3.4</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Corrigir ponteiros</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">3.5</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">N√≥s movemos objetos</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">3.6</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Ep√≠logo</a> </li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">4. Conecte o GC √† VM</a> <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">4.1</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Root Traversal</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">4.2</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Pontos seguros e parada do mundo</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">4.3</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Erros de aloca√ß√£o de mem√≥ria</a> </li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">5. Montagem</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">6. Teste</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">7. Desempenho</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">8. O que vem depois?</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">9. Conclus√µes</a> </li></ul></div></div><br><a name="1"></a><br><h1 id="1-iz-chego-sostoit-gc">  1. Em que consiste o GC </h1><br><p>  Agora que muitos GCs diferentes foram escritos, √© muito simples criar seus pr√≥prios elementos - muitos elementos j√° escritos podem ser (re) usados ‚Äã‚Äãpara mudar algumas das preocupa√ß√µes com os detalhes da implementa√ß√£o para c√≥digo comprovado e testado. </p><br><a name="11"></a><br><h2 id="11-epsilon-gc">  1.1  Epsilon gc </h2><br><p>  O OpenJDK 11 apresenta um novo JEP 318: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">"Epsilon: Um Coletor de Lixo No-Op (Experimental)"</a> .  Sua tarefa √© fornecer uma implementa√ß√£o m√≠nima para o caso em que a libera√ß√£o de mem√≥ria n√£o √© necess√°ria ou mesmo proibida.  O JEP discute com mais detalhes por que pode ser √∫til. </p><br><p>  Do ponto de vista da implementa√ß√£o, ‚Äúcoletor de lixo‚Äù √© um nome ruim, seria mais correto usar o termo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">‚Äúgerenciador de mem√≥ria autom√°tico‚Äù</a> , respons√°vel por alocar e liberar mem√≥ria.  O Epsilon GC implementa apenas "aloca√ß√£o" e n√£o lida com "libera√ß√£o".  Portanto, voc√™ pode usar o Epsilon GC e come√ßar a implementar os algoritmos de "libera√ß√£o" do zero. </p><br><a name="111"></a><br><h3 id="111-vydelenie-pamyati">  1.1.1  Aloca√ß√£o de mem√≥ria </h3><br><p>  A parte mais desenvolvida do Epsilon GC <a href="">√© respons√°vel pela aloca√ß√£o de mem√≥ria</a> .  Serve solicita√ß√µes externas para alocar mem√≥ria de tamanho arbitr√°rio e criar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">TLAB (Thread-Local Allocation Buffer) do</a> tamanho desejado.  A implementa√ß√£o em si est√° tentando n√£o estender muito o TLAB, pois n√£o haver√° mem√≥ria livre e ningu√©m retornar√° os bytes perdidos. </p><br><a name="112"></a><br><h3 id="112-barery">  1.1.2  Barreiras </h3><br><p>  Alguns coletores de lixo requerem intera√ß√£o com o aplicativo para manter os invariantes do GC, for√ßando o tempo de execu√ß√£o e o aplicativo a criar as chamadas <em>barreiras</em> ao tentar acessar o heap.  Isso √© verdade para todos os colecionadores multithread, assim como para <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">muitos colecionadores com gera√ß√µes</a> e parando o mundo. </p><br><p>  O Epsilon n√£o requer barreiras, mas o tempo de execu√ß√£o e o compilador ainda querem <em>saber</em> que as barreiras n√£o fazem nada.  Lidar com isso todas as vezes em qualquer lugar pode ser cansativo.  Felizmente, come√ßando com o OpenJDK 11, existe um novo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">JEP-304: "Interface de Coleta de Lixo"</a> , que torna muito, muito mais f√°cil inserir barreiras.  Em particular, a <a href="">barreira definida no Epsilon est√° vazia</a> e todo o trabalho trivial - salvar, carregar, CAS, c√≥pia em matriz - pode ser delegado √†s implementa√ß√µes de barreiras triviais de uma superclasse existente.  Se voc√™ estiver criando um GC que tamb√©m n√£o precise de barreiras, basta reutilizar o c√≥digo do Epsilon. </p><br><a name="113"></a><br><h3 id="113-podklyuchenie-k-monitoringu">  1.1.3  Monitorando a conex√£o </h3><br><p>  A √∫ltima parte tediosa da implementa√ß√£o do GC s√£o os ganchos de v√°rios mecanismos de monitoramento dentro da JVM: compartimentos MX, comandos de diagn√≥stico etc. devem funcionar.  Epsilon <a href="">j√° fez</a> tudo isso por voc√™. </p><br><a name="12"></a><br><h2 id="12-rantaym-i-gc">  1.2  Rantime e GC </h2><br><a name="121"></a><br><h3 id="121-kornevye-elementy">  1.2.1  Elementos raiz </h3><br><p>  O coletor de lixo, no caso geral, precisa saber o que exatamente no tempo de execu√ß√£o Java tem refer√™ncias de heap.  Esses elementos raiz, chamados <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">ra√≠zes de GC</a> , podem ser slots em pilhas de fluxo e vari√°veis ‚Äã‚Äãlocais (incluindo aquelas encontradas no c√≥digo compilado por JIT!), Classes nativas e carregadores de classes, refer√™ncias em JNI e assim por diante.  As tentativas de identificar esses elementos podem ser muito complexas e tediosas.  Mas no Hotspot, todos eles s√£o rastreados usando os subsistemas de VM apropriados, para que voc√™ possa simplesmente aprender como as implementa√ß√µes de GC existentes funcionam com eles.  Mais adiante no texto, veremos isso. </p><br><a name="122"></a><br><h3 id="122-obhod-obektov">  1.2.2  Rastreamento de objetos </h3><br><p> O coletor de lixo deve ignorar os links de sa√≠da nos objetos Java.  Essa opera√ß√£o √© encontrada em todos os lugares, portanto, as partes comuns do tempo de execu√ß√£o fornecem solu√ß√µes prontas; voc√™ n√£o precisa escrever nada.  Abaixo, haver√° uma se√ß√£o com uma implementa√ß√£o espec√≠fica e voc√™ poder√° encontrar, por exemplo, as chamadas <code>obj‚Üíoop_iterate</code> . </p><br><a name="123"></a><br><h3 id="123-peremescheniya">  1.2.3  Deslocamentos </h3><br><p>  O coletor de lixo em movimento precisa anotar os novos endere√ßos dos objetos movidos em algum lugar.  Existem v√°rios lugares onde voc√™ pode gravar esses <em>dados de encaminhamento</em> . </p><br><ol><li>  Voc√™ pode reutilizar a <a href="">‚Äúpalavra marcador‚Äù no pr√≥prio objeto</a> (Serial, Paralelo, etc.).  Depois que o mundo para, todos os acessos ao objeto s√£o controlados e √© garantido que nenhum encadeamento Java possa ver os dados tempor√°rios que decidimos inserir na palavra do marcador.  Voc√™ pode reutiliz√°-lo para armazenar dados de encaminhamento. </li><li>  Voc√™ pode manter uma tabela de movimento nativa separada ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">ZGC</a> , C4 e outras).  Isso isola completamente o GC do tempo de execu√ß√£o e do restante do aplicativo, pois apenas o GC sabe da exist√™ncia dessa tabela.  Montadores competitivos geralmente usam exatamente esse esquema - eles n√£o querem sofrer com um monte de problemas desnecess√°rios. </li><li>  Voc√™ pode adicionar outra palavra ao objeto ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Shenandoah</a> e outros).  Essa combina√ß√£o das duas abordagens anteriores n√£o apenas permite que o tempo de execu√ß√£o e o aplicativo funcionem com cabe√ßalhos existentes sem problemas, mas tamb√©m salva os dados de encaminhamento. </li></ol><br><a name="124"></a><br><h3 id="124-markernye-dannye">  1.2.4  Dados do marcador </h3><br><p>  O coletor de lixo precisa gravar <em>dados de marca√ß√£o em</em> algum lugar.  E, novamente, existem v√°rias maneiras de salv√°-los: </p><br><ol><li>  Voc√™ pode reutilizar a palavra do marcador no pr√≥prio objeto (Serial, Paralelo etc.).  Novamente, no modo de parada mundial, voc√™ pode usar os bits na palavra do marcador para codificar o fato de um r√≥tulo.  Al√©m disso, se voc√™ precisar percorrer todos os objetos vivos, percorreremos o heap, objeto ap√≥s objeto - isso √© poss√≠vel devido ao fato de que o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">heap √© analis√°vel</a> . </li><li>  Voc√™ pode manter uma estrutura separada para armazenar dados de marca√ß√£o (G1, Shenandoah, etc.).  Isso geralmente √© feito usando um <a href="">bitmap separado</a> , que mapeia todos os N bytes do heap para 1 bit do cart√£o.  Geralmente, os objetos Java s√£o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">alinhados por 8 bytes</a> ; portanto, o cart√£o mapeia a cada 64 bits do heap para 1 bit do cart√£o, ocupando 1/64 do tamanho do heap na mem√≥ria nativa.  Essas despesas gerais compensam bem ao varrer o heap quanto √† presen√ßa de objetos vivos, especialmente os esparsos: ignorar o mapa geralmente √© muito mais r√°pido do que ignorar o heap que est√° sendo classificado objeto por objeto. </li><li>  Codifique os r√≥tulos nos pr√≥prios links (ZGC, C4 e outros).  Isso requer coordena√ß√£o com o aplicativo, ent√£o voc√™ precisa cortar todos esses r√≥tulos dos links ou executar outros truques para manter a corre√ß√£o.  Em outras palavras, precisamos de barreiras ou de algum trabalho adicional do GC. </li></ol><br><a name="2"></a><br><h1 id="2-obschiy-plan">  2. Plano geral </h1><br><p>  Provavelmente, o mais f√°cil de implementar sobre o Epsilon √© o Mark-Compact, no estilo LISP2.  A id√©ia b√°sica deste GC √© descrita <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">na Wikipedia</a> e <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">no Manual do GC</a> (cap√≠tulo 3.2).  Um esbo√ßo do algoritmo estar√° na se√ß√£o com a implementa√ß√£o abaixo, mas eu recomendo fortemente a leitura de um pouco da Wikipedia ou do Manual do GC para entender o que vamos fazer. </p><br><p>  O algoritmo em quest√£o √© o GC de <em>deslocamento</em> : os objetos em movimento movem-se em uma matriz at√© o in√≠cio do heap.  Tem seus pr√≥s e contras: </p><br><ul><li>  Ele mant√©m a ordem das aloca√ß√µes de mem√≥ria.  Isso √© muito bom para controlar o layout na mem√≥ria, se for importante para voc√™ (controlar malucos, √© a sua vez!).  A desvantagem √© que voc√™ n√£o obter√° <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">a localidade autom√°tica do link</a> dessa maneira. </li><li>  Sua complexidade √© O (N) do n√∫mero de objetos.  No entanto, a linearidade tem um pre√ßo: √© necess√°rio que o GC ignore um monte de 4 vezes para cada ciclo de constru√ß√£o. </li><li>  N√£o requer mem√≥ria livre na pilha!  N√£o h√° necessidade de reservar mem√≥ria no heap para evacuar objetos ativos, para que voc√™ possa trabalhar com um heap que excede em 99. (9)%.  Se adotarmos outras id√©ias de colecionadores simples, por exemplo, um limpador com um semi-espa√ßo (limpador de semi-espa√ßo), teremos que reescrever ligeiramente a apresenta√ß√£o da pilha e reservar um pouco de espa√ßo para evacua√ß√£o, mas isso est√° al√©m do escopo deste exerc√≠cio. </li><li>  Se voc√™ trabalhar um pouco sobre o problema, poder√° obter zero consumo de mem√≥ria e tempo durante os per√≠odos em que o GC estiver inativo.  Inicia em uma mem√≥ria em um estado arbitr√°rio e para, compactando-a significativamente.  Isso se encaixa muito bem com o funcionamento do Epsilon: ele continua destacando logo ap√≥s o √∫ltimo objeto.  Isso tamb√©m √© um sinal de menos: alguns objetos mortos no in√≠cio da pilha levam a um grande n√∫mero de movimentos. </li><li>  Ele simplesmente n√£o requer novas barreiras, voc√™ pode reutilizar o <code>EpsilonBarrierSet</code> como est√°. </li></ul><br><p>  Por uma quest√£o de simplicidade, a implementa√ß√£o do GC usar√° um ponto final do mundo (stop-the-world, STW), n√£o ter√° gera√ß√µes ou multithreading.  Nesse caso, faz sentido usar um bitmap para armazenar marcas e reutilizar a palavra do marcador para armazenar dados de movimento. </p><br><a name="3"></a><br><h1 id="3-realizaciya-yadra-gc">  3. Implementa√ß√£o do n√∫cleo do GC </h1><br><p>  Ler e entender <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">toda a implementa√ß√£o</a> pode ser muito complicado para uma pessoa ignorante.  Nesta se√ß√£o, entenderemos passo a passo. </p><br><a name="31"></a><br><h2 id="31-prolog">  3.1  Pr√≥logo </h2><br><p>  O coletor de lixo geralmente precisa fazer algumas coisas para se preparar para a coleta.  Leia os coment√°rios, eles devem falar por si: </p><br><pre> <code class="cpp hljs">{ GCTraceTime(Info, gc) time(<span class="hljs-string"><span class="hljs-string">"Step 0: Prologue"</span></span>, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>); <span class="hljs-comment"><span class="hljs-comment">//      .      //   :   ,   ,  // ¬´¬ª   ,      //   ,     . if (!os::commit_memory((char*)_bitmap_region.start(), _bitmap_region.byte_size(), false)) { log_warning(gc)("Could not commit native memory for marking bitmap, GC failed"); return; } //        ,  , //       TLAB-. ensure_parsability(true); //      ,    GC. CodeCache::gc_prologue(); BiasedLocking::preserve_marks(); //        . //       . DerivedPointerTable::clear(); }</span></span></code> </pre> <br><p>  Como usamos um bitmap para rastrear a acessibilidade dos objetos, precisamos limp√°-lo antes do uso.  Ou no nosso caso, como pretendemos nunca solicitar recursos antes de iniciar o ciclo do GC, teremos que <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">comprometer o bitmap na mem√≥ria com</a> anteced√™ncia.  Isso fornece v√°rias vantagens interessantes, pelo menos no Linux, onde a maior parte do bitmap aponta para a p√°gina zero, especialmente para pilhas esparsas. </p><br><p>  Os threads devem liberar seus TLABs e solicitar ao GC novos ap√≥s a conclus√£o da compila√ß√£o. </p><br><blockquote>  N√£o confunda TLAB e <code>java.lang.ThreadLocal</code> .  Do ponto de vista do GC, ThreadLocal s√£o objetos comuns e n√£o ser√£o compilados pelo GC, a menos que seja especificamente exigido de outra forma no c√≥digo Java. </blockquote><p>  Algumas partes do tempo de execu√ß√£o, especialmente aquelas que mant√™m links para o heap Java, ser√£o interrompidas durante a coleta de lixo, portanto, voc√™ deve avis√°-las especificamente de que o GC come√ßar√° a funcionar em breve.  Isso permitir√° que os respectivos subsistemas preparem e salvem parte de seu estado antes que o GC fa√ßa a sua jogada. </p><br><a name="32"></a><br><h2 id="32-markirovka">  3.2  Marca√ß√£o </h2><br><p>  Marcar para interromper o modo mundial se torna bastante simples quando quase tudo j√° foi feito por n√≥s.  A rotulagem √© bastante padr√£o e, provavelmente, em muitas implementa√ß√µes, o GC √© o primeiro passo. </p><br><pre> <code class="cpp hljs">{ GCTraceTime(Info, gc) time(<span class="hljs-string"><span class="hljs-string">"Step 1: Mark"</span></span>, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>); <span class="hljs-comment"><span class="hljs-comment">//    ,     .  //   ,  ,    //      . EpsilonMarkStack stack; EpsilonScanOopClosure cl(&amp;stack, &amp;_bitmap); //      . process_roots(&amp;cl); stat_reachable_roots = stack.size(); //    ,    . //    ,   , //      . while (!stack.is_empty()) { oop obj = stack.pop(); obj-&gt;oop_iterate(&amp;cl); stat_reachable_heap++; } //       . DerivedPointerTable::set_active(false); }</span></span></code> </pre> <br><p>  Isso funciona exatamente da mesma forma que em qualquer outro gr√°fico: voc√™ inicia a travessia com o conjunto inicial de v√©rtices alcan√ß√°veis, segue as arestas de sa√≠da e grava todos os v√©rtices visitados.  A travessia continua at√© que todos os picos n√£o visitados terminem.  No GC, "v√©rtices" s√£o objetos e "arestas" s√£o links entre eles. </p><br><p>  Tecnicamente, poder√≠amos simplesmente recursivamente examinar o gr√°fico de objetos, mas essa √© uma m√° id√©ia para gr√°ficos arbitr√°rios que podem ter di√¢metros muito grandes.  Imagine uma lista vinculada de um bilh√£o de picos!  Portanto, para limitar a profundidade da recurs√£o, usamos uma pilha de marca√ß√£o que registra os objetos detectados. </p><br><p>  O conjunto inicial de objetos alcan√ß√°veis ‚Äã‚Äã√© a raiz do GC.  Agora, n√£o pense no que <code>process_roots</code> , mais sobre isso mais tarde.  Por enquanto, digamos que ele ignora todos os links acess√≠veis do lado da VM. </p><br><p>  Um bitmap com marcas serve como uma ferramenta para registrar a <em>frente de onda de marca√ß√£o</em> (muitos objetos j√° visitados) e, no final - como um reposit√≥rio do resultado desejado, um conjunto de todos os objetos alcan√ß√°veis.  O trabalho real ocorre no <code>EpsilonScanOopClosure</code> , √© aplicado a todos os objetos interessantes e iterado em todos os links do objeto selecionado. </p><br><blockquote>  Olha, Java sabia como <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">fechar (fechamento)</a> antes de ficar na moda! </blockquote><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">EpsilonScanOopClosure</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> BasicOopIterateClosure { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: EpsilonMarkStack* <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> _stack; MarkBitMap* <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> _bitmap; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">void</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">do_oop_work</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">* </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">p</span></span></span><span class="hljs-class">) {</span></span> <span class="hljs-comment"><span class="hljs-comment">// p -     ,   oop,   //      ,  : T o = RawAccess&lt;&gt;::oop_load(p); if (!CompressedOops::is_null(o)) { oop obj = CompressedOops::decode_not_null(o); //  . ,   .  , //        . //    +, //       . if (!_bitmap-&gt;is_marked(obj)) { _bitmap-&gt;mark((HeapWord*)obj); _stack-&gt;push(obj); } } } };</span></span></code> </pre> <br><p>  Ap√≥s concluir esta etapa, <code>_bitmap</code> cont√©m bits indicando a localiza√ß√£o dos objetos <code>_bitmap</code> .  Gra√ßas a isso, √© poss√≠vel ignorar todos os objetos vivos, por exemplo: </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//           . //   ,    ( )  ,  //       1/64  . void EpsilonHeap::walk_bitmap(ObjectClosure* cl) { HeapWord* limit = _space-&gt;top(); HeapWord* addr = _bitmap.get_next_marked_addr(_space-&gt;bottom(), limit); while (addr &lt; limit) { oop obj = oop(addr); assert(_bitmap.is_marked(obj), "sanity"); cl-&gt;do_object(obj); addr += 1; if (addr &lt; limit) { addr = _bitmap.get_next_marked_addr(addr, limit); } } }</span></span></code> </pre> <br><a name="33"></a><br><h2 id="33-vychislyaem-novye-adresa">  3.3  Calcular novos endere√ßos </h2><br><p>  Este tamb√©m √© um passo bastante simples e implementa exatamente o que o algoritmo diz. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/ab3/406/5e6/ab34065e6397d39413057358b45247a3.jpg"></p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//    forwarding data (,    ) //   .        . //          . PreservedMarks preserved_marks; //     GC. HeapWord* new_top; { GCTraceTime(Info, gc) time("Step 2: Calculate new locations", NULL); //    ,        //    . ,  - . EpsilonCalcNewLocationObjectClosure cl(_space-&gt;bottom(), &amp;preserved_marks); walk_bitmap(&amp;cl); //         . //       ,    //      ,      "" //  . new_top = cl.compact_point(); stat_preserved_marks = preserved_marks.size(); }</span></span></code> </pre> <br><p>  A √∫nica coisa que chama sua aten√ß√£o √© que decidimos armazenar novos endere√ßos na palavra de marca√ß√£o dos objetos Java, e essa palavra j√° pode ser ocupada por algo importante, por exemplo, informa√ß√µes sobre bloqueios.  Felizmente, essas palavras de marca√ß√£o n√£o triviais s√£o bastante raras e podemos simplesmente armazen√°-las separadamente, se necess√°rio: √© para isso que o <code>PreservedMarks</code> usado. </p><br><p>  O trabalho algor√≠tmico real √© realizado por <code>EpsilonCalcNewLocationObjectClosure</code> : </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">EpsilonCalcNewLocationObjectClosure</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> ObjectClosure { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: HeapWord* _compact_point; PreservedMarks* <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> _preserved_marks; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: EpsilonCalcNewLocationObjectClosure(HeapWord* start, PreservedMarks* pm) : _compact_point(start), _preserved_marks(pm) {} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">do_object</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(oop obj)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//    :    . //        (      , //    ),      , //     . if ((HeapWord*)obj != _compact_point) { markOop mark = obj-&gt;mark_raw(); if (mark-&gt;must_be_preserved(obj)) { _preserved_marks-&gt;push(obj, mark); } obj-&gt;forward_to(oop(_compact_point)); } _compact_point += obj-&gt;size(); } HeapWord* compact_point() { return _compact_point; } };</span></span></code> </pre> <br><p>  <code>forward_to</code> √© a parte mais importante porque armazena o "endere√ßo de movimenta√ß√£o" na palavra do marcador do objeto.  Isso ser√° necess√°rio nas pr√≥ximas etapas. </p><br><a name="34"></a><br><h2 id="34-ispravlyaem-ukazateli">  3.4  Corrigir ponteiros </h2><br><p>  Agora voc√™ precisa passar pelo heap novamente e reescrever todos os links com seus novos endere√ßos, de acordo com o seguinte algoritmo: </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/25f/c82/1dc/25fc821dc95d2f9d50fe40653eb845ff.jpg"></p><br><pre> <code class="cpp hljs">{ GCTraceTime(Info, gc) time(<span class="hljs-string"><span class="hljs-string">"Step 3: Adjust pointers"</span></span>, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>); <span class="hljs-comment"><span class="hljs-comment">//     _   _,     // ¬´ ¬ª.      forwarding data, //    .      . EpsilonAdjustPointersObjectClosure cl; walk_bitmap(&amp;cl); //     ,      VM,  //     :      . EpsilonAdjustPointersOopClosure cli; process_roots(&amp;cli); //   ,      , //     . preserved_marks.adjust_during_full_gc(); }</span></span></code> </pre> <br><p>  Existem dois tipos de refer√™ncias a objetos deslocados: sa√≠da de objetos no pr√≥prio heap ou das ra√≠zes do GC.  Voc√™ precisa atualizar as duas classes de links.  Alguns r√≥tulos salvos tamb√©m armazenam refer√™ncias a objetos, portanto, √© necess√°rio solicitar a atualiza√ß√£o.  <code>PreservedMarks</code> sabe como fazer isso porque espera "encaminhar dados" no mesmo local em que os salvamos, na palavra de marca√ß√£o do objeto. </p><br><p>  Os fechamentos s√£o divididos em dois tipos: alguns pegam objetos e ignoram seu conte√∫do, outros atualizam esses endere√ßos.  Aqui voc√™ pode fazer uma pequena otimiza√ß√£o de desempenho: se o objeto n√£o se mover, voc√™ poder√° salvar alguns registros em um monte: </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">EpsilonAdjustPointersOopClosure</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> BasicOopIterateClosure { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">void</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">do_oop_work</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">* </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">p</span></span></span><span class="hljs-class">) {</span></span> <span class="hljs-comment"><span class="hljs-comment">// p -     ,   oop. //        ,  : T o = RawAccess&lt;&gt;::oop_load(p); if (!CompressedOops::is_null(o)) { oop obj = CompressedOops::decode_not_null(o); //         . //  ,    . if (obj-&gt;is_forwarded()) { oop fwd = obj-&gt;forwardee(); assert(fwd != NULL, "just checking"); RawAccess&lt;&gt;::oop_store(p, fwd); } } } }; class EpsilonAdjustPointersObjectClosure : public ObjectClosure { private: EpsilonAdjustPointersOopClosure _cl; public: void do_object(oop obj) { //    ,    : obj-&gt;oop_iterate(&amp;_cl); } };</span></span></code> </pre> <br><p>  Depois de concluir esta etapa, basicamente quebramos a pilha: os links apontam para os endere√ßos "errados" nos quais os objetos ainda n√£o est√£o.  Vamos consertar! </p><br><a name="35"></a><br><h2 id="35-dvigaem-obekty">  3.5  N√≥s movemos objetos </h2><br><p>  Hora de mover objetos para novos endere√ßos, de acordo com o algoritmo: </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/01c/5b8/db8/01c5b8db85781c82b89bbed730c8aecc.jpg"></p><br><p>  <code>EpsilonMoveObjectsObjectClosure</code> ao redor dos mont√µes novamente e aplique o fechamento <code>EpsilonMoveObjectsObjectClosure</code> a todos os objetos vivos: </p><br><pre> <code class="cpp hljs">{ GCTraceTime(Info, gc) time(<span class="hljs-string"><span class="hljs-string">"Step 4: Move objects"</span></span>, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>); <span class="hljs-comment"><span class="hljs-comment">//       . //          . EpsilonMoveObjectsObjectClosure cl; walk_bitmap(&amp;cl); stat_moved = cl.moved(); //         ,   // ¬´¬ª      . _space-&gt;set_top(new_top); }</span></span></code> </pre> <br><p>  Imediatamente depois disso, voc√™ pode arrastar a pilha da pilha do ponto de compacta√ß√£o, possibilitando alocar mem√≥ria diretamente desse local, imediatamente ap√≥s o t√©rmino do ciclo de coleta de lixo. </p><br><p>  Observe que na montagem de deslocamento podemos sobrescrever o conte√∫do dos objetos existentes, mas como a digitaliza√ß√£o segue na mesma dire√ß√£o, os objetos substitu√≠dos j√° s√£o copiados para o local certo. </p><br><blockquote>  Os locais antigos e novos da mesma instala√ß√£o podem se cruzar.  Por exemplo, se voc√™ mudar um objeto de 100 bytes por 8 bytes.  O procedimento de c√≥pia deve resolver por si pr√≥prio e o conte√∫do que se cruza deve ser copiado corretamente, preste aten√ß√£o a <code>Copy::aligned_*conjoint*_words</code> . </blockquote><p>  O fechamento em si simplesmente mover√° os objetos movidos para os novos endere√ßos: </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">EpsilonMoveObjectsObjectClosure</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> ObjectClosure { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">do_object</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(oop obj)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//     ,  .   - , //   -  mark word, //      forwarding data. if (obj-&gt;is_forwarded()) { oop fwd = obj-&gt;forwardee(); assert(fwd != NULL, "just checking"); Copy::aligned_conjoint_words((HeapWord*)obj, (HeapWord*)fwd, obj-&gt;size()); fwd-&gt;init_mark_raw(); } } };</span></span></code> </pre> <br><a name="36"></a><br><h2 id="36-epilog">  3.6  Ep√≠logo </h2><br><p>  A coleta de lixo est√° conclu√≠da, a pilha √© novamente quase consistente, os √∫ltimos retoques finais s√£o deixados: </p><br><pre> <code class="cpp hljs">{ GCTraceTime(Info, gc) time(<span class="hljs-string"><span class="hljs-string">"Step 5: Epilogue"</span></span>, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>); <span class="hljs-comment"><span class="hljs-comment">//    . preserved_marks.restore(); //   ,    . DerivedPointerTable::update_pointers(); BiasedLocking::restore_marks(); CodeCache::gc_epilogue(); JvmtiExport::gc_epilogue(); //     . if (!os::uncommit_memory((char*)_bitmap_region.start(), _bitmap_region.byte_size())) { log_warning(gc)("Could not uncommit native memory for marking bitmap"); } //    ,  . //        . if (EpsilonUncommit) { _virtual_space.shrink_by((_space-&gt;end() - new_top) * HeapWordSize); _space-&gt;set_end((HeapWord*)_virtual_space.high()); } }</span></span></code> </pre> <br><p>  Informamos ao restante do tempo de execu√ß√£o que eles devem iniciar os procedimentos p√≥s-montagem.  Restauramos as palavras especiais marcadas que salvamos anteriormente.  Beijo de despedida para o nosso cart√£o marcador - n√£o √© mais necess√°rio. </p><br><p>  E, se voc√™ realmente quiser, pode reduzir a mem√≥ria para aloca√ß√£o para um novo tamanho, retornando a mem√≥ria ao sistema operacional! </p><br><a name="4"></a><br><h1 id="4-podklyuchaem-gc-k-vm">  4. Conecte o GC √† VM </h1><br><a name="41"></a><br><h2 id="41-obhod-kornevyh-elementov">  4.1  Root Traversal </h2><br><p>  Lembre-se de que voc√™ precisa ignorar links especiais e acess√≠veis da VM?  Voc√™ pode solicitar a cada subsistema VM especial para ignorar os links ocultos de outros objetos Java.  Uma lista exaustiva de tais elementos raiz no Hotspot atual se parece com isso: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> EpsilonHeap::do_roots(OopClosure* cl) { <span class="hljs-comment"><span class="hljs-comment">//   ,        1 . StrongRootsScope scope(1); //         . CLDToOopClosure clds(cl, ClassLoaderData::_claim_none); MarkingCodeBlobClosure blobs(cl, CodeBlobToOopClosure::FixRelocations); //      . //        . { MutexLockerEx lock(CodeCache_lock, Mutex::_no_safepoint_check_flag); CodeCache::blobs_do(&amp;blobs); } { MutexLockerEx lock(ClassLoaderDataGraph_lock); ClassLoaderDataGraph::cld_do(&amp;clds); } Universe::oops_do(cl); Management::oops_do(cl); JvmtiExport::oops_do(cl); JNIHandles::oops_do(cl); WeakProcessor::oops_do(cl); ObjectSynchronizer::oops_do(cl); SystemDictionary::oops_do(cl); Threads::possibly_parallel_oops_do(false, cl, &amp;blobs); }</span></span></code> </pre> <br><p>  ,        .    GC    . </p><br><a name="42"></a><br><h2 id="42-seyfpointy-i-ostanovka-mira"> 4.2.     </h2><br><p>   GC     ,   VM      .  Hotspot     <code>VM_Operation</code> ,     GC    VM-  : </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// VM_operation,      class VM_EpsilonCollect: public VM_Operation { private: const GCCause::Cause _cause; EpsilonHeap* const _heap; static size_t _last_used; public: VM_EpsilonCollect(GCCause::Cause cause) : VM_Operation(), _cause(cause), _heap(EpsilonHeap::heap()) {}; VM_Operation::VMOp_Type type() const { return VMOp_EpsilonCollect; } const char* name() const { return "Epsilon Collection"; } virtual bool doit_prologue() { //     ,     . //         GC, //          . //   ,         //  .     , //       1%, ,  , //     . Heap_lock-&gt;lock(); size_t used = _heap-&gt;used(); size_t capacity = _heap-&gt;capacity(); size_t allocated = used &gt; _last_used ? used - _last_used : 0; if (_cause != GCCause::_allocation_failure || allocated &gt; capacity / 100) { return true; } else { Heap_lock-&gt;unlock(); return false; } } virtual void doit() { _heap-&gt;entry_collect(_cause); } virtual void doit_epilogue() { _last_used = _heap-&gt;used(); Heap_lock-&gt;unlock(); } }; size_t VM_EpsilonCollect::_last_used = 0; void EpsilonHeap::vmentry_collect(GCCause::Cause cause) { VM_EpsilonCollect vmop(cause); VMThread::execute(&amp;vmop); }</span></span></code> </pre> <br><p>       ,       GC ‚Äî    ,     . </p><br><a name="43"></a><br><h2 id="43-oshibki-vydeleniya-pamyati">  4.3    </h2><br><p> ,     GC  ,   ,  GC    ,     .   ,      <code>allocate_work</code>     ,   GC     : </p><br><pre> <code class="cpp hljs">HeapWord* EpsilonHeap::allocate_or_collect_work(<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> size) { HeapWord* res = allocate_work(size); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (res == <span class="hljs-literal"><span class="hljs-literal">NULL</span></span> &amp;&amp; EpsilonSlidingGC) { vmentry_collect(GCCause::_allocation_failure); res = allocate_work(size); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> res; }</code> </pre> <br><p>   ! </p><br><a name="5"></a><br><h1 id="5-sborka"> 5.  </h1><br><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="> </a>        OpenJDK. </p><br><pre> <code class="bash hljs">$ hg <span class="hljs-built_in"><span class="hljs-built_in">clone</span></span> https://hg.openjdk.java.net/jdk/jdk/ jdk-jdk $ <span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> jdk-jdk $ curl https://shipilev.net/jvm/diy-gc/webrev/jdk-jdk-epsilon.changeset | patch -p1</code> </pre> <br><p>     OpenJDK  : </p><br><pre> <code class="bash hljs">$ ./configure --with-debug-level=fastdebug $ make images</code> </pre> <br><p>    : </p><br><pre> <code class="bash hljs">$ build/linux-x86_64-server-fastdebug/images/jdk/bin/java -XX:+UnlockExperimentalVMOptions -XX:+UseEpsilonGC -XX:+EpsilonSlidingGC -version openjdk version <span class="hljs-string"><span class="hljs-string">"13-internal"</span></span> 2019-09-17 OpenJDK Runtime Environment (build 13-internal+0-adhoc.shade.jdk-jdk-epsilon) OpenJDK 64-Bit Server VM (build 13-internal+0-adhoc.shade.jdk-jdk-epsilon, mixed mode, sharing</code> </pre> <br><a name="6"></a><br><h1 id="6-testirovanie"> 6.  </h1><br><p>  ,    GC  ?    : </p><br><ol><li> .  .   Hotspot    ,   JVM   <em>fastdebug</em>        ,        GC. </li><li>  .        ,          . ,        ( )   ,          . </li><li>  Testes.    ,  ,   ,   .     -   ,        . </li></ol><br><p> ,    ,       : </p><br><pre> <code class="plaintext hljs">$ CONF=linux-x86_64-server-fastdebug make images run-test TEST=gc/epsilon/ Building targets 'images run-test' in configuration 'linux-x86_64-server-fastdebug' Test selection 'gc/epsilon/', will run: * jtreg:test/hotspot/jtreg/gc/epsilon Running test 'jtreg:test/hotspot/jtreg/gc/epsilon' Passed: gc/epsilon/TestAlwaysPretouch.java Passed: gc/epsilon/TestAlignment.java Passed: gc/epsilon/TestElasticTLAB.java Passed: gc/epsilon/TestEpsilonEnabled.java Passed: gc/epsilon/TestHelloWorld.java Passed: gc/epsilon/TestLogTrace.java Passed: gc/epsilon/TestDieDefault.java Passed: gc/epsilon/TestDieWithOnError.java Passed: gc/epsilon/TestMemoryPools.java Passed: gc/epsilon/TestMaxTLAB.java Passed: gc/epsilon/TestPrintHeapSteps.java Passed: gc/epsilon/TestArraycopyCheckcast.java Passed: gc/epsilon/TestClasses.java Passed: gc/epsilon/TestUpdateCountersSteps.java Passed: gc/epsilon/TestDieWithHeapDump.java Passed: gc/epsilon/TestByteArrays.java Passed: gc/epsilon/TestManyThreads.java Passed: gc/epsilon/TestRefArrays.java Passed: gc/epsilon/TestObjects.java Passed: gc/epsilon/TestElasticTLABDecay.java Passed: gc/epsilon/TestSlidingGC.java Test results: passed: 21 TEST SUCCESS</code> </pre> <br><p> ?       <em>fastdebug</em>    .  ?    - . </p><br><a name="7"></a><br><h1 id="7-proizvoditelnost"> 7.  </h1><br><p> -  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">spring-petclinic</a> ,  Apache Bench     GC!        ,  ,     GC . </p><br><p>    : <code>-Xlog:gc -XX:+UnlockExperimentalVMOptions -XX:+UseEpsilonGC -XX:+EpsilonSlidingGC</code> : </p><br><p> : </p><br><pre> <code class="plaintext hljs">Heap: 20480M reserved, 20480M (100.00%) committed, 19497M (95.20%) used GC(2) Step 0: Prologue 2.085ms GC(2) Step 1: Mark 51.005ms GC(2) Step 2: Calculate new locations 71.207ms GC(2) Step 3: Adjust pointers 49.671ms GC(2) Step 4: Move objects 22.839ms GC(2) Step 5: Epilogue 1.008ms GC(2) GC Stats: 70561 (8.63%) reachable from roots, 746676 (91.37%) reachable from heap, 91055 (11.14%) moved, 2237 (0.27%) markwords preserved GC(2) Heap: 20480M reserved, 20480M (100.00%) committed, 37056K (0.18%) used GC(2) Lisp2-style Mark-Compact (Allocation Failure) 20479M-&gt;36M(20480M) 197.940ms</code> </pre> <br><p> 200 ?        GC!   ,         .   ,          ,   :         (      ‚Äî  ,    ).       - (                ). </p><br><p>  , GC          . ,   <code>-Xlog:gc -XX:+UseSerialGC</code> ‚Äî  ,  ,  : </p><br><pre> <code class="plaintext hljs">GC(46) Pause Young (Allocation Failure) 575M-&gt;39M(1943M) 2.603ms GC(47) Pause Young (Allocation Failure) 575M-&gt;39M(1943M) 2.606ms GC(48) Pause Young (Allocation Failure) 575M-&gt;39M(1943M) 2.747ms GC(49) Pause Young (Allocation Failure) 575M-&gt;39M(1943M) 2.578ms</code> </pre> <br><p> , 2 .  ,        ,   GC   .      <code>-Xlog:gc -XX:+UseSerialGC</code> ,       ,      : </p><br><pre> <code class="plaintext hljs">GC(3) Pause Full (Allocation Failure) 16385M-&gt;34M(18432M) 1969.694ms GC(4) Pause Full (Allocation Failure) 16385M-&gt;34M(18432M) 2261.405ms GC(5) Pause Full (Allocation Failure) 16385M-&gt;34M(18432M) 2327.577ms GC(6) Pause Full (Allocation Failure) 16385M-&gt;34M(18432M) 2328.976ms</code> </pre> <br><p>     ,    .    . </p><br><a name="8"></a><br><h1 id="8-chto-dalshe"> 8.  ? </h1><br><p>     .       ,    GC  OpenJDK ‚Äî  ,    ,          . </p><br><p>   : </p><br><ol><li><p>    .     ,   // .      .     ,       ,    ¬´ ¬ª       ,        ,   . <br></p><blockquote>    GC, <code>java.lang.ref.Reference.referent</code> ‚Äî     Java-,  ,   ,     -  .       <code>FinalReference</code> ,    . </blockquote>         <code>ReferenceProcessor</code>     /  /     . <br></li><li><p>        VM.              VM,   ,   ,       .       <em></em>  <em></em>  .  ,    <em></em>  ,  ,     -  <em></em>   ,    . </p><br></li><li><p>  .      ‚Äî    ,    GC,          .  ,    ,      ,       . <br></p><blockquote>    mark-compact GC   Full GC fallbacks  Shenandoah (  OpenJDK 8)  G1 (  OpenJDK 10,    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">JEP 307: ¬´Parallel Full GC for G1¬ª</a> ). </blockquote><br></li><li><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">  </a> .  ,        ¬´¬ª     ,     , ,  -     .           .   ,          . </p><br></li><li><p>        .     ,  ,     ,           .   ,     ¬´¬ª ‚Äî    ¬´¬ª        ¬´¬ª ,      . </p><br></li><li><p>  -   GC Handbook     . </p><br></li></ol><br><a name="9"></a><br><h1 id="9-vyvody"> 9.  </h1><br><p>       ?   GC ‚Äî  , ,  ,        GC. </p><br><p>         ,    -  GC   . ,     ,            GC (, Serial GC  Parallel GC),         . </p><br><blockquote>  Minuto de publicidade.  , 5-6  2019,  JPoint ‚Äî    Java-.           ‚Äî OpenJDK, GraalVM, Kotlin  .        <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">  </a> . </blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt443250/">https://habr.com/ru/post/pt443250/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt443238/index.html">Como n√£o se transformar em uma lib√©lula se voc√™ tem muitos bancos de dados diferentes</a></li>
<li><a href="../pt443240/index.html">Entendendo o Q-learning, o problema ‚ÄúAndar sobre uma pedra‚Äù</a></li>
<li><a href="../pt443242/index.html">Quarkus √© um Java subat√¥mico supers√¥nico. Uma breve vis√£o geral da estrutura</a></li>
<li><a href="../pt443244/index.html">Tarefas de revis√£o. Beanpoisk_1</a></li>
<li><a href="../pt443246/index.html">Como reinventamos o Askozia IP PBX depois que o projeto foi vendido e fechado pelo desenvolvedor</a></li>
<li><a href="../pt443252/index.html">Bots de formiga modulares com mem√≥ria</a></li>
<li><a href="../pt443254/index.html">Triton √© o v√≠rus mais mortal</a></li>
<li><a href="../pt443256/index.html">PowerShell, despejo da minha experi√™ncia</a></li>
<li><a href="../pt443258/index.html">Gotify - um projeto de c√≥digo aberto para entrega de notifica√ß√µes e envio de mensagens ao servidor</a></li>
<li><a href="../pt443260/index.html">Migrar para Zimbra sem arriscar neg√≥cios com um dom√≠nio comum</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>