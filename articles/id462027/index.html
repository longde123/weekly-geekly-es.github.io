<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏼‍💻 👩‍🚀 ☀️ Bagaimana Dark Menyebarkan Kode 50ms 🌼 💃 🛀🏾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Semakin cepat proses pengembangan, semakin cepat perusahaan teknologi berkembang. 


 Sayangnya, aplikasi modern bekerja melawan kita - sistem kita ha...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Bagaimana Dark Menyebarkan Kode 50ms</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/southbridge/blog/462027/"><p><img src="https://habrastorage.org/webt/o4/lk/bi/o4lkbi449pbpjqw84e0wt-tywlq.png"></p><br><p>  Semakin cepat proses pengembangan, semakin cepat perusahaan teknologi berkembang. </p><br><p>  Sayangnya, aplikasi modern bekerja melawan kita - sistem kita harus diperbarui secara real time dan pada saat yang sama tidak mengganggu siapa pun dan tidak mengarah ke downtime dan interupsi.  Penempatan dalam sistem seperti itu menjadi tugas yang sulit dan membutuhkan jaringan pengiriman kontinu yang kompleks bahkan dalam tim kecil. </p><br><p>  Pipa-pipa ini biasanya memiliki aplikasi yang sempit, bekerja lambat dan tidak dapat diandalkan.  Pengembang pertama-tama harus membuatnya secara manual, dan kemudian mengelolanya, dan perusahaan sering kali mempekerjakan seluruh tim DevOps untuk ini. </p><br><p>  Kecepatan pengembangan tergantung pada kecepatan pipa-pipa ini.  Untuk tim-tim terbaik, penempatan membutuhkan waktu 5-10 menit, tetapi biasanya itu membutuhkan waktu lebih lama, dan untuk satu penempatan dibutuhkan beberapa jam. </p><a name="habracut"></a><br><p>  Dalam Gelap, dibutuhkan 50 ms.  <em>Lima puluh</em>  <em>Milidetik</em>  Dark adalah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">solusi lengkap dengan bahasa pemrograman, editor dan infrastruktur yang</a> dirancang khusus untuk pengiriman terus-menerus, dan semua aspek Dark, termasuk bahasa itu sendiri, dibangun dengan tampilan penyebaran instan yang aman. </p><br><h3 id="pochemu-konveyery-nepreryvnoy-postavki-takie-medlennye">  Mengapa konveyor kontinu sangat lambat? </h3><br><p> Katakanlah kita memiliki aplikasi web Python dan kita telah membuat pipa pengiriman kontinu yang indah dan modern.  Untuk pengembang yang sibuk dengan proyek ini setiap hari, menggunakan satu perubahan kecil akan terlihat seperti ini: </p><br><h3 id="vnesenie-izmeneniy">  Membuat perubahan </h3><br><ul><li>  Membuat cabang baru di git </li><li>  Membuat Perubahan Di Balik Sakelar Fungsi </li><li>  Pengujian unit untuk memverifikasi perubahan dengan dan tanpa sakelar fungsi </li></ul><br><h3 id="pul-rekvest">  Permintaan kolam renang </h3><br><ul><li>  Berkomit berkomitmen </li><li>  Posting perubahan ke repositori jarak jauh di github </li><li>  Permintaan kolam renang </li><li>  CI dibangun secara otomatis di latar belakang </li><li>  Ulasan kode </li><li>  Beberapa ulasan lagi, jika perlu </li><li>  Gabungkan perubahan dengan git wizard. </li></ul><br><h3 id="ci-vypolnyaetsya-na-mastere">  CI berjalan pada wizard </h3><br><ul><li>  Mengatur dependensi frontend melalui npm </li><li>  Membangun dan mengoptimalkan sumber daya HTML + CSS + JS </li><li>  Jalankan di ujung depan unit dan tes fungsi </li><li>  Instal dependensi Python dari PyPI </li><li>  Jalankan di backend unit dan tes fungsional </li><li>  Pengujian integrasi di kedua ujungnya </li><li>  Kirim sumber daya frontend ke CDN </li><li>  Membangun wadah untuk program Python </li><li>  Mengirim wadah ke registri </li><li>  Manifes pembaruan Kubernetes </li></ul><br><h3 id="zamena-starogo-koda-novym">  Mengganti kode lama dengan yang baru </h3><br><ul><li>  Kubernetes meluncurkan banyak contoh wadah baru </li><li>  Kubernetes sedang menunggu mesin virtual mulai beroperasi </li><li>  Kubernetes menambahkan instance ke penyeimbang beban HTTP </li><li>  Kubernet menunggu contoh lama berhenti digunakan </li><li>  Kubernetes menghentikan instance lama </li><li>  Kubernetes mengulangi operasi ini hingga instance baru menggantikan semua yang lama </li></ul><br><h3 id="vklyuchenie-novogo-pereklyuchatelya-funkcii">  Nyalakan sakelar fungsi baru </h3><br><ul><li>  Kode baru hanya disertakan untuk saya sendiri, untuk memastikan semuanya baik-baik saja </li><li>  Kode baru disertakan untuk 10% pengguna, metrik operasional dan bisnis dilacak </li><li>  Kode baru disertakan untuk 50% pengguna, metrik operasional dan bisnis dilacak </li><li>  Kode baru disertakan untuk 100% pengguna, metrik operasional dan bisnis dilacak </li><li>  Akhirnya, Anda mengulangi seluruh prosedur untuk menghapus kode lama dan beralih </li></ul><br><p>  Prosesnya tergantung pada alat, bahasa, dan penggunaan arsitektur berorientasi layanan, tetapi secara umum, terlihat seperti ini.  Saya tidak menyebutkan penyebaran migrasi database karena ini membutuhkan perencanaan yang cermat, tetapi di bawah ini saya akan menjelaskan bagaimana Dark menangani hal ini. </p><br><p>  Ada banyak komponen di sini, dan banyak dari mereka dapat dengan mudah memperlambat, crash, menyebabkan persaingan sementara atau menjatuhkan sistem kerja. </p><br><p>  Dan karena pipa-pipa ini hampir selalu dibuat untuk acara khusus, sulit untuk mengandalkannya.  Banyak orang memiliki hari-hari ketika kode tidak dapat digunakan, karena ada masalah di Dockerfile, salah satu dari puluhan layanan macet atau spesialis yang tepat berlibur. </p><br><p>  Lebih buruk lagi, banyak dari langkah-langkah ini tidak melakukan apa pun.  Kami membutuhkannya sebelum ketika kami menggunakan kode segera untuk pengguna, tetapi sekarang kami memiliki saklar untuk kode baru, dan proses ini dibagi.  Akibatnya, langkah di mana kode digunakan (yang lama digantikan oleh yang baru) kini menjadi risiko tambahan. </p><br><p>  Tentu saja, ini adalah pipa yang sangat bijaksana.  Tim yang menciptakannya membutuhkan waktu dan uang untuk menyebar dengan cepat.  Biasanya penyebaran pipa jauh lebih lambat dan lebih tidak dapat diandalkan. </p><br><h3 id="realizaciya-nepreryvnoy-postavki-v-dark">  Menerapkan Pengiriman Berkelanjutan dalam Gelap </h3><br><p>  Pengiriman berkelanjutan sangat penting untuk Gelap sehingga kami menetapkan waktu tepat waktu dalam waktu kurang dari sedetik.  Kami melewati semua langkah pipa untuk menghapus semua yang tidak perlu, dan membawa sisanya ke pikiran.  Inilah cara kami menghapus langkah-langkahnya. </p><br><blockquote>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Jessie Frazelle</a> menciptakan kata baru deployless di konferensi Future of Software Development di Reykjavik </blockquote><p>  Kami segera memutuskan bahwa Dark akan didasarkan pada konsep "deployless" (terima kasih kepada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Jesse Frazel</a> untuk neologisme).  Deployless berarti bahwa kode apa pun langsung disebarkan dan siap digunakan dalam produksi.  Tentu saja, kami tidak akan melewatkan kode yang salah atau tidak lengkap (saya akan menjelaskan prinsip-prinsip keselamatan di bawah). </p><br><p>  Di demo Dark, kami sering ditanya bagaimana kami berhasil mempercepat penyebaran.  Pertanyaan aneh.  Orang-orang mungkin berpikir bahwa kita telah menemukan semacam teknologi supertech yang membandingkan kode, mengkompilasinya, mengemasnya ke dalam wadah, meluncurkan mesin virtual, meluncurkan sebuah wadah pada yang dingin dan semua hal semacam itu - dan semua ini dalam 50 ms.  Ini hampir tidak mungkin.  Tetapi kami telah menciptakan mesin penyebaran khusus, yang tidak membutuhkan semua ini. </p><br><p>  Dark meluncurkan penerjemah di awan.  Misalkan Anda menulis kode dalam fungsi atau penangan untuk HTTP atau acara.  Kami mengirim diff ke pohon sintaksis abstrak (implementasi kode yang digunakan secara internal oleh editor dan server kami) ke server kami, dan kemudian jalankan kode ini ketika permintaan diterima.  Jadi penyebarannya terlihat seperti catatan sederhana dalam database - instan dan elementer.  Penyebaran sangat cepat karena termasuk minimum. </p><br><p>  Di masa depan, kami berencana untuk membuat kompiler infrastruktur dari Dark, yang akan membuat dan menjalankan infrastruktur yang ideal untuk kinerja tinggi dan keandalan aplikasi.  Penempatan instan, tentu saja, tidak ke mana-mana. </p><br><h2 id="bezopasnoe-razvertyvanie">  Penempatan yang aman </h2><br><h3 id="strukturirovannyy-redaktor">  Editor Terstruktur </h3><br><p>  Kode dalam Gelap ditulis dalam editor Gelap.  Editor terstruktur tidak membuat kesalahan sintaksis.  Faktanya, Dark bahkan tidak memiliki analisa.  Saat Anda mengetik, kami bekerja secara langsung dengan Pohon Sintaksis Abstrak (AST) seperti <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Paredit</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Sketsa-n-Sketsa</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Tahu</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Pangkas,</a> dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">MPS</a> . </p><br><p>  Setiap kode yang tidak lengkap dalam Dark memiliki semantik eksekusi yang valid, seperti halnya <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">lubang yang diketik di Hazel</a> .  Misalnya, jika Anda mengubah panggilan fungsi, kami menyimpan fungsi yang lama hingga yang baru dapat digunakan. </p><br><p>  Setiap program di Dark memiliki artinya sendiri, sehingga kode yang tidak lengkap tidak mengganggu pekerjaan yang sudah selesai. </p><br><h3 id="rezhimy-redaktirovaniya">  Mode pengeditan </h3><br><p>  Anda menulis kode dalam Gelap dalam dua kasus.  Pertama: Anda menulis kode baru dan satu-satunya pengguna.  Misalnya, itu ada di REPL, dan pengguna lain tidak akan pernah mendapatkan akses ke sana, atau itu adalah rute HTTP baru yang tidak Anda rujuk ke mana pun.  Anda dapat bekerja di sini tanpa tindakan pencegahan, dan sekarang Anda hampir bekerja di lingkungan pengembangan. </p><br><p>  Situasi kedua: kode sudah digunakan.  Jika lalu lintas melewati kode (fungsi, penangan acara, database, tipe), harus diperhatikan.  Untuk melakukan ini, kami memblokir semua kode yang digunakan dan memerlukan penggunaan alat yang lebih terstruktur untuk mengeditnya.  Saya akan berbicara tentang alat struktural di bawah ini: sakelar fungsi untuk HTTP dan pengendali acara, platform migrasi yang kuat untuk basis data, dan metode kontrol versi baru untuk fungsi dan tipe. </p><br><h3 id="pereklyuchateli-funkciy">  Sakelar fungsi </h3><br><p>  Salah satu cara <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">untuk menghilangkan kompleksitas ekstra</a> dalam Dark adalah dengan memperbaiki beberapa masalah dengan satu solusi.  Sakelar fungsi melakukan banyak tugas berbeda: mengganti lingkungan pengembangan lokal, cabang git, menyebarkan kode, dan, tentu saja, pelepasan kode baru yang lambat dan terkontrol secara tradisional. </p><br><p>  Penciptaan dan penyebaran saklar fungsi dilakukan di editor kami dalam satu operasi.  Ini menciptakan ruang kosong untuk kode baru dan menyediakan kontrol akses untuk kode lama dan baru, serta tombol dan perintah untuk transisi bertahap ke kode baru atau pengecualiannya. </p><br><p>  Sakelar fungsi dibuat dalam bahasa Gelap, dan bahkan sakelar tidak lengkap menjalankan tugasnya - jika kondisi di sakelar tidak terpenuhi, kode lama yang diblokir akan dieksekusi. </p><br><h3 id="sreda-razrabotki">  Lingkungan pengembangan </h3><br><p>  Sakelar fungsi menggantikan lingkungan pengembangan lokal.  Hari ini, sulit bagi tim untuk memastikan bahwa semua orang menggunakan versi alat dan pustaka yang sama (pembuat kode, linter, manajer paket, kompiler, preprosesor, alat pengujian, dll.) Dengan Dark, Anda tidak perlu menginstal dependensi secara lokal, mengontrol instalasi Docker lokal, atau mengambil langkah-langkah lain untuk memastikan setidaknya persamaan kesamaan antara lingkungan pengembangan dan produksi.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Mengingat bahwa kesetaraan seperti itu masih mustahil</a> , kami bahkan tidak akan berpura-pura bahwa kami berjuang untuk itu. </p><br><p>  Alih-alih menciptakan lingkungan lokal yang dikloning, sakelar dalam Gelap membuat kotak pasir baru dalam produksi yang menggantikan lingkungan pengembangan.  Di masa depan, kami juga berencana untuk membuat kotak pasir untuk bagian lain dari aplikasi (misalnya, klon basis data instan), meskipun untuk saat ini sepertinya tidak begitu penting. </p><br><h3 id="vetki-i-razvertyvaniya">  Cabang dan Penempatan </h3><br><p>  Sekarang ada beberapa cara untuk memasukkan kode baru ke dalam sistem: cabang git, fase penyebaran, dan sakelar fungsi.  Mereka memecahkan satu masalah di berbagai bagian alur kerja: git - pada tahap sebelum penyebaran, penempatan - pada saat transisi dari kode lama ke kode baru, dan fungsi beralih - untuk pelepasan terkontrol kode baru. </p><br><p>  Cara yang paling efektif adalah sakelar fungsi (pada saat yang sama termudah untuk dipahami dan digunakan).  Dengan mereka, Anda dapat sepenuhnya meninggalkan dua metode lainnya.  Sangat berguna untuk menghapus penyebaran - jika kita menggunakan sakelar fungsi untuk memasukkan kode, langkah memindahkan server ke kode baru hanya menciptakan risiko yang tidak perlu. </p><br><p>  Git sulit digunakan, terutama untuk pemula, dan itu benar-benar membatasi, tetapi memiliki cabang yang nyaman.  Kami telah merapikan banyak kekurangan git.  Dark diedit secara real time dan memberikan kemampuan untuk bekerja bersama dalam gaya Google Documents, sehingga Anda tidak harus mengirim kode dan Anda dapat lebih jarang melakukan relokasi dan penggabungan. </p><br><p>  Sakelar fitur mendukung penyebaran aman.  Bersama dengan penerapan instan, mereka memungkinkan Anda untuk dengan cepat menguji konsep dalam fragmen kecil dengan risiko rendah, alih-alih menerapkan satu perubahan besar yang dapat menurunkan sistem. </p><br><h3 id="versionirovanie">  Versi </h3><br><p>  Untuk mengubah fungsi dan jenis, kami menggunakan versi.  Jika Anda ingin mengubah suatu fungsi, Dark membuat versi baru dari fungsi ini.  Kemudian Anda dapat menjalankan versi ini menggunakan sakelar di HTTP atau pengendali event.  (Jika ini adalah fungsi yang jauh di dalam grafik panggilan, versi baru dari setiap fungsi dibuat di sepanjang jalan. Mungkin sepertinya terlalu banyak, tetapi fungsi tidak mengganggu jika Anda tidak menggunakannya, sehingga Anda bahkan tidak akan menyadarinya.) </p><br><p>  Untuk alasan yang sama, kami adalah jenis versi.  Kami berbicara tentang sistem tipe kami secara rinci <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">di posting sebelumnya</a> . </p><br><p>  Dengan mengversi fungsi dan tipe, Anda dapat membuat perubahan pada aplikasi secara bertahap.  Anda dapat memverifikasi bahwa masing-masing pawang bekerja dengan versi baru, Anda tidak perlu segera melakukan semua perubahan pada aplikasi (tetapi kami memiliki alat untuk melakukan ini dengan cepat jika Anda mau). </p><br><p>  Ini jauh lebih aman daripada sepenuhnya menerapkan semuanya sekaligus, seperti sekarang. </p><br><h3 id="novye-versii-paketov-i-standartnaya-biblioteka">  Versi paket baru dan perpustakaan standar </h3><br><p>  Ketika Anda memperbarui paket dalam Dark, kami tidak segera mengganti penggunaan setiap fungsi atau ketik di seluruh basis kode.  Ini tidak aman.  Kode terus menggunakan versi yang sama yang digunakannya, dan Anda memperbarui penggunaan fungsi dan tipe ke versi baru untuk setiap kasus menggunakan saklar. </p><br><p> <a href=""><img src="https://habrastorage.org/webt/rh/t3/4w/rht34wyibolrgracbz88tnqqhg0.png"></a> <br>  <em>Tangkapan layar bagian dari proses otomatis dalam Dark yang menampilkan dua versi fungsi Dict :: get.</em>  <em>Dict :: get_v0 mengembalikan tipe Any (yang kami tolak), dan Dict :: get_v1 kembali ketik Opsi.</em> </p><br><p>  Kami sering menyediakan fitur baru di perpustakaan standar dan mengecualikan versi yang lebih lama.  Pengguna dengan versi lama dalam kode akan mempertahankan akses ke sana, tetapi pengguna baru tidak akan bisa mendapatkannya.  Kami akan menyediakan alat untuk mentransfer pengguna dari versi lama ke yang baru dalam 1 langkah, dan sekali lagi menggunakan sakelar fungsi. </p><br><p>  Dark juga memberikan peluang unik: begitu kami mengeksekusi kode kerja Anda, kami dapat menguji sendiri versi baru, membandingkan output untuk permintaan baru dan lama untuk memberi tahu Anda tentang perubahan tersebut.  Akibatnya, pembaruan paket, yang sering dilakukan secara membabi buta (atau membutuhkan pengujian keamanan yang ketat), menimbulkan risiko yang jauh lebih sedikit dan dapat terjadi secara otomatis. </p><br><h3 id="novye-versii-dark">  Versi Gelap Baru </h3><br><p>  Transisi dari Python 2 ke Python 3 telah berlangsung lebih dari satu dekade dan masih menjadi masalah.  Setelah kami membuat Gelap untuk pengiriman berkelanjutan, perubahan bahasa ini perlu dipertimbangkan. </p><br><p>  Saat kami membuat perubahan kecil pada bahasa, kami membuat versi baru Dark.  Kode lama tetap di versi lama Dark, dan kode baru digunakan di versi baru.  Untuk beralih ke versi Dark yang baru, Anda dapat menggunakan sakelar atau versi fungsi. </p><br><p>  Ini sangat berguna mengingat Gelap telah muncul baru-baru ini.  Banyak perubahan pada bahasa atau perpustakaan mungkin gagal.  Versi bertahap bahasa memungkinkan kita membuat pembaruan kecil, yaitu, kita tidak bisa terburu-buru dan menunda banyak keputusan tentang bahasa sampai kita memiliki lebih banyak pengguna, dan karenanya lebih banyak informasi. </p><br><h3 id="migracii-baz-dannyh">  Migrasi basis data </h3><br><p>  Ada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">rumus standar</a> untuk migrasi basis data yang aman: </p><br><ul><li>  Tulis ulang kode untuk mendukung format baru dan lama </li><li>  Konversi semua data ke format baru </li><li>  Hapus akses data lama </li></ul><br><p>  Akibatnya, migrasi basis data tertunda dan membutuhkan banyak sumber daya.  Dan kami mengumpulkan skema yang sudah ketinggalan zaman, karena bahkan tugas sederhana, seperti memperbaiki nama tabel atau kolom, tidak sepadan dengan usaha. </p><br><p>  Dark memiliki platform migrasi basis data yang efektif yang (kami harap) akan menyederhanakan prosesnya sehingga Anda tidak akan lagi takut padanya.  Semua data menyimpan dalam Dark (pasangan nilai kunci atau tabel hash persisten) bertipe.  Untuk memigrasi gudang data, Anda cukup menetapkannya sebagai tipe baru dan fungsi rollback dan rollback untuk mengonversi nilai di antara kedua jenis. </p><br><p>  Akses ke gudang data dalam Dark melalui nama variabel berversi.  Misalnya, penyimpanan data Pengguna pada awalnya akan disebut Users-v0.  Ketika versi baru dengan tipe berbeda dibuat, namanya berubah menjadi Users-v1.  Jika data disimpan melalui Users-v0, dan Anda mengaksesnya melalui Users-v1, fungsi roll-over diterapkan.  Jika data disimpan melalui Users-v1, dan Anda mengaksesnya melalui Users-v0, fungsi rollback digunakan. </p><br><p> <a href=""><img src="https://habrastorage.org/webt/ui/sl/wd/uislwdrfrvact0d1ts5icnk-4ka.png"></a> <br>  <em>Layar migrasi basis data dengan nama bidang untuk basis data lama, ekspresi rollback dan rollback, dan instruksi untuk mengaktifkan migrasi.</em> </p><br><p>  Gunakan sakelar fungsi untuk merutekan panggilan ke Users-v0 ke Users-v1.  Anda dapat melakukan ini satu penangan HTTP sekaligus untuk mengurangi risiko, dan sakelar juga bekerja untuk pengguna individu sehingga Anda dapat memverifikasi bahwa semuanya berfungsi seperti yang diharapkan.  Ketika Users-v0 tidak tersisa, Dark mengubah semua data yang tersisa di latar belakang dari format lama ke yang baru.  Anda bahkan tidak akan menyadarinya. </p><br><h3 id="testirovanie">  Pengujian </h3><br><p>  Gelap adalah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">bahasa pemrograman fungsional dengan pengetikan statis</a> dan nilai yang tidak dapat diubah, oleh karena itu, permukaan pengujiannya secara signifikan lebih kecil dibandingkan dengan bahasa berorientasi objek dengan pengetikan dinamis.  Tetapi Anda masih perlu menguji. <br>  Dalam Gelap, editor secara otomatis menjalankan tes unit di latar belakang untuk kode yang dapat diedit dan secara default menjalankan tes ini untuk semua sakelar fungsi.  Di masa mendatang, kami ingin menggunakan tipe statis untuk secara otomatis menghapus kode untuk menemukan bug. </p><br><p>  Selain itu, Dark menjalankan infrastruktur Anda dalam produksi, dan ini membuka kemungkinan baru.  Kami secara otomatis menyimpan permintaan HTTP di infrastruktur Gelap (untuk saat ini kami menyimpan semua permintaan, tetapi kemudian kami ingin beralih ke pengambilan).  Kami menguji kode baru pada mereka dan melakukan tes unit, dan jika Anda mau, Anda dapat dengan mudah mengkonversi pertanyaan menarik menjadi tes unit. </p><br><h3 id="ot-chego-my-izbavilis">  Apa yang kita singkirkan </h3><br><p>  Karena kami tidak memiliki penyebaran, tetapi ada sakelar fungsi, sekitar 60% dari pipa penempatan tetap ke laut.  Kami tidak memerlukan permintaan git cabang atau kumpulan, membangun sumber daya backend dan wadah, mengirim sumber daya dan kontainer untuk registrasi atau langkah-langkah penyebaran di Kubernetes. </p><br><p> <a href=""><img src="https://habrastorage.org/webt/gc/9e/g-/gc9eg-szouq0dtrxxr8jd6c6dyo.jpeg"></a> <br>  <em>Perbandingan pipa pengiriman kontinu standar (kiri) dan pasokan berkelanjutan Dark (kanan).</em>  <em>Dalam Gelap, pengiriman terdiri dari 6 langkah dan satu siklus, sedangkan versi tradisional mencakup 35 langkah dan 3 siklus.</em> </p><br><p>  Dalam Gelap, hanya ada 6 langkah dan 1 siklus dalam penyebaran (langkah yang diulang beberapa kali), sedangkan pipa pasokan kontinu modern terdiri dari 35 langkah dan 3 siklus.  Dalam Gelap, tes berjalan secara otomatis, dan Anda bahkan tidak melihatnya;  dependensi diinstal secara otomatis;  apapun yang berhubungan dengan git atau github tidak lagi dibutuhkan;  Tidak perlu mengumpulkan, menguji, dan mengirim wadah Docker;  Penempatan Kubernetes tidak lagi diperlukan. </p><br><p>  Bahkan langkah-langkah yang tersisa dalam Gelap menjadi lebih mudah.  Karena sakelar fungsi dapat dikontrol dalam satu tindakan, Anda tidak harus melewati seluruh pipa penempatan untuk kedua kalinya untuk menghapus kode lama. </p><br><p>  Kami menyederhanakan pengiriman kode sebanyak mungkin, mengurangi waktu dan risiko pengiriman berkelanjutan.  Kami juga sangat menyederhanakan pembaruan paket, migrasi basis data, pengujian, kontrol versi, instalasi dependensi, kesetaraan antara lingkungan pengembangan dan produksi, dan peningkatan versi bahasa yang cepat dan aman. </p><br><p>  Saya menjawab pertanyaan tentang ini di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">HackerNews</a> . </p><br><p>  Untuk mempelajari lebih lanjut tentang perangkat Gelap, baca <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">artikel Gelap</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ikuti kami di Twitter</a> (atau <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">saya</a> ), atau <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">mendaftar untuk versi beta dan menerima pemberitahuan dari posting berikut</a> .  Jika Anda datang ke StrangeLoop pada bulan September, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">datanglah ke peluncuran kami</a> . </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id462027/">https://habr.com/ru/post/id462027/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id462013/index.html">Docker storage (docker root) histori masalah migrasi</a></li>
<li><a href="../id462015/index.html">Alam semesta pelaporan SAP</a></li>
<li><a href="../id462021/index.html">Bagaimana cara berhenti melakukan hal yang sama</a></li>
<li><a href="../id462023/index.html">Cascadeur: Masa Depan Animasi Game</a></li>
<li><a href="../id462025/index.html">Model data jaringan relasional</a></li>
<li><a href="../id462029/index.html">19 fitur berguna dari file .htaccess</a></li>
<li><a href="../id462031/index.html">Seperti jika Anda membaca log!: Luncurkan Hotspot 2.0 di jaringan Wi-Fi di metro</a></li>
<li><a href="../id462033/index.html">Perjamuan Terakhir Para Pengembang</a></li>
<li><a href="../id462035/index.html">Python Vs R - Ilmu Data</a></li>
<li><a href="../id462041/index.html">Pendekatan Segmentasi Seluler - Terjemahan</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>