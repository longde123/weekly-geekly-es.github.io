<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👸🏼 👍🏾 📺 Ankündigung der F # 4.6-Vorschau 👫 🚶🏿 🥗</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Wir freuen uns, Ihnen mitteilen zu können, dass Visual Studio 2019 eine neue Version von F # liefert, wenn es veröffentlicht wird: F # 4.6! 


 F # 4....">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Ankündigung der F # 4.6-Vorschau</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/microsoft/blog/437666/"><img align="left" width="200" src="https://habrastorage.org/webt/zh/zi/wx/zhziwxp-1d-vh9pn0kioaevu0kg.png"><p>  Wir freuen uns, Ihnen mitteilen zu können, dass Visual Studio 2019 eine neue Version von F # liefert, wenn es veröffentlicht wird: F # 4.6! </p><br><p>  F # 4.6 ist ein kleineres Update der F # -Sprache, was es zu einer „echten“ Punktveröffentlichung macht.  Wie bei früheren Versionen von F # wurde F # 4.6 vollständig über einen offenen RFC-Prozess (Requests for Comments) entwickelt.  Die F # Community hat in Diskussionen zu dieser Version der Sprache sehr detailliertes Feedback gegeben.  Sie können alle RFCs, die dieser Version entsprechen, hier anzeigen: </p><br><ul><li>  <a href="">F # 4.6 RFCs</a> </li><li>  <a href="">FSharp.Core 4.6.0 RFCs</a> </li></ul><br><p>  In diesem Beitrag werden die Funktionen und die ersten Schritte beschrieben. </p><a name="habracut"></a><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Original im Blog</a> <br><br><h2>  Fangen Sie an </h2><br><p>  Installieren Sie zunächst entweder: </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Das .NET SDK 2.1.6xx oder 2.2.6xx Vorschau des .NET SDK</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Visual Studio 2019 Vorschau 2</a> </li></ul><br><p>  Aktualisieren Sie als Nächstes Ihre FSharp.Core-Abhängigkeit auf FSharp.Core 4.6 (oder höher).  Wenn Sie Visual Studio verwenden, können Sie dies mit der NuGet Package Management-Benutzeroberfläche tun.  Wenn Sie Visual Studio nicht verwenden oder Projektdateien von Hand bearbeiten möchten, fügen Sie dies der Projektdatei hinzu: </p><br><pre><code class="cpp hljs">&lt;ItemGroup&gt; &lt;PackageReference Update=<span class="hljs-string"><span class="hljs-string">"FSharp.Core"</span></span> Version=<span class="hljs-string"><span class="hljs-string">"4.6.0"</span></span> /&gt; &lt;/ItemGroup&gt;</code> </pre> <br><p>  Sobald Sie die erforderlichen Bits installiert haben, können Sie F # 4.6 mit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Visual Studio</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Visual Studio für Mac</a> oder <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Visual Studio Code mit Ionide verwenden</a> . </p><br><h2>  Anonyme Aufzeichnungen </h2><br><p>  Abgesehen von verschiedenen Fehlerkorrekturen ist die einzige Sprachänderung in F # 4.6 die Einführung <a href="">anonymer Datensatztypen</a> . </p><br><h3>  Grundlegende Verwendung </h3><br><p>  Nur aus F # -Perspektive sind anonyme Datensätze F # -Datensatztypen, die keine expliziten Namen haben und in einer Ad-hoc-Fasion deklariert werden können.  Obwohl es unwahrscheinlich ist, dass sie die Art und Weise, wie Sie F # -Code schreiben, grundlegend ändern, füllen sie viele kleinere Lücken, auf die F # -Programmierer im Laufe der Zeit gestoßen sind, und können für prägnante Datenmanipulationen verwendet werden, die zuvor nicht möglich waren. </p><br><p>  Sie sind recht einfach zu bedienen.  Hier erfahren Sie beispielsweise, wie Sie mit einer Funktion interagieren können, die einen anonymen Datensatz erstellt: </p><br><pre> <code class="cpp hljs">open System let circleStats radius = let d = radius * <span class="hljs-number"><span class="hljs-number">2.0</span></span> let a = Math.PI * (radius ** <span class="hljs-number"><span class="hljs-number">2.0</span></span>) let c = <span class="hljs-number"><span class="hljs-number">2.0</span></span> * Math.PI * radius {| Diameter=d; Area=a; Circumference=c |} let r = <span class="hljs-number"><span class="hljs-number">2.0</span></span> let stats = circleStats r printfn <span class="hljs-string"><span class="hljs-string">"Circle with radius: %f has diameter %f, area %f, and circumference %f"</span></span> r stats.Diameter stats.Area stats.Circumference</code> </pre> <br><p>  Sie können jedoch nicht nur für grundlegende Datencontainer verwendet werden.  Im Folgenden wird das vorherige Beispiel um eine typsicherere Druckfunktion erweitert: </p><br><pre> <code class="cpp hljs">let circleStats radius = let d = radius * <span class="hljs-number"><span class="hljs-number">2.0</span></span> let a = Math.PI * (radius ** <span class="hljs-number"><span class="hljs-number">2.0</span></span>) let c = <span class="hljs-number"><span class="hljs-number">2.0</span></span> * Math.PI * radius {| Diameter=d; Area=a; Circumference=c |} let printCircleStats r (stats: {| Area: <span class="hljs-keyword"><span class="hljs-keyword">float</span></span>; Circumference: <span class="hljs-keyword"><span class="hljs-keyword">float</span></span>; Diameter: <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> |}) = printfn <span class="hljs-string"><span class="hljs-string">"Circle with radius: %f has diameter %f, area %f, and circumference %f"</span></span> r stats.Diameter stats.Area stats.Circumference let r = <span class="hljs-number"><span class="hljs-number">2.0</span></span> let stats = circleStats r printCircleStats r stats</code> </pre> <br><p>  Wenn Sie versuchen, "printCircleStats" mit einem anonymen Datensatz aufzurufen, der dieselben zugrunde liegenden Datentypen, aber unterschiedliche Bezeichnungen aufweist, kann Folgendes nicht kompiliert werden: </p><br><pre> <code class="cpp hljs">printCircleStats r {| Diameter=<span class="hljs-number"><span class="hljs-number">2.0</span></span>; Area=<span class="hljs-number"><span class="hljs-number">4.0</span></span>; MyCircumference=<span class="hljs-number"><span class="hljs-number">12.566371</span></span> |} <span class="hljs-comment"><span class="hljs-comment">// Two anonymous record types have mismatched sets of field names '["Area"; "Circumference"; "Diameter"]' and '["Area"; "Diameter"; "MyCircumference"]'</span></span></code> </pre> <br><p>  Genau so funktionieren F # -Datensatztypen, außer dass alles ad-hoc und nicht im Voraus deklariert wurde.  Dies hat je nach Ihrer speziellen Situation Vor- und Nachteile. Wir empfehlen daher, anonyme Datensätze mit Bedacht zu verwenden, anstatt alle Ihre vorherigen F # -Datensatzdeklarationen zu ersetzen. </p><br><h3>  Strukturieren Sie anonyme Datensätze </h3><br><p>  Anonyme Datensätze können auch Strukturen sein, indem das Schlüsselwort <em>struct verwendet wird</em> : </p><br><pre> <code class="cpp hljs">open System let circleStats radius = let d = radius * <span class="hljs-number"><span class="hljs-number">2.0</span></span> let a = Math.PI * (radius ** <span class="hljs-number"><span class="hljs-number">2.0</span></span>) let c = <span class="hljs-number"><span class="hljs-number">2.0</span></span> * Math.PI * radius <span class="hljs-comment"><span class="hljs-comment">// Note that the keyword comes before the '{| |}' brace pair struct {| Area=a; Circumference=c; Diameter=d |} // the 'struct' keyword also comes before the '{| |}' brace pair when declaring the parameter type let printCircleStats r (stats: struct {| Area: float; Circumference: float; Diameter: float |}) = printfn "Circle with radius: %f has diameter %f, area %f, and circumference %f" r stats.Diameter stats.Area stats.Circumference let r = 2.0 let stats = circleStats r printfn "Circle with radius: %f has diameter %f, area %f, and circumference %f" r stats.Diameter stats.Area stats.Circumference</span></span></code> </pre> <br><p>  Sie können eine Funktion aufrufen, die einen anonymen Strukturdatensatz verwendet. Dies kann explizit folgendermaßen erfolgen: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">let printCircleStats </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">r</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(stats: struct {| Area: </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params">; Circumference: </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params">; Diameter: </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> |})</span></span></span><span class="hljs-function"> </span></span>= printfn <span class="hljs-string"><span class="hljs-string">"Circle with radius: %f has diameter %f, area %f, and circumference %f"</span></span> r stats.Diameter stats.Area stats.Circumference printCircleStats r <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> {</span></span>| Area=<span class="hljs-number"><span class="hljs-number">4.0</span></span>; Circumference=<span class="hljs-number"><span class="hljs-number">12.6</span></span>; Diameter=<span class="hljs-number"><span class="hljs-number">12.6</span></span> |}</code> </pre> <br><p>  Oder Sie können "Strukturinferenz" verwenden, um die "Struktur" an der Aufrufstelle zu entfernen: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">let printCircleStats </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">r</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(stats: struct {| Area: </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params">; Circumference: </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params">; Diameter: </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> |})</span></span></span><span class="hljs-function"> </span></span>= printfn <span class="hljs-string"><span class="hljs-string">"Circle with radius: %f has diameter %f, area %f, and circumference %f"</span></span> r stats.Diameter stats.Area stats.Circumference printCircleStats r {| Area=<span class="hljs-number"><span class="hljs-number">4.0</span></span>; Circumference=<span class="hljs-number"><span class="hljs-number">12.6</span></span>; Diameter=<span class="hljs-number"><span class="hljs-number">12.6</span></span> |}</code> </pre> <br><p>  Dadurch wird die Instanz des anonymen Datensatzes, den Sie erstellt haben, so behandelt, als wäre es eine Struktur. </p><br><p>  Beachten Sie, dass das Gegenteil nicht der Fall ist: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">let printCircleStats </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">r</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(stats: {| Area: </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params">; Circumference: </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params">; Diameter: </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> |})</span></span></span><span class="hljs-function"> </span></span>= printfn <span class="hljs-string"><span class="hljs-string">"Circle with radius: %f has diameter %f, area %f, and circumference %f"</span></span> r stats.Diameter stats.Area stats.Circumference <span class="hljs-comment"><span class="hljs-comment">// This will fail to compile for hopefully obvious reasons! printCircleStats r struct {| Area=4.0; Circumference=12.6; Diameter=12.6 |}</span></span></code> </pre> <br><p>  Es ist derzeit nicht möglich, anonyme Datensatztypen für <em>IsByRefLike</em> oder <em>IsReadOnly</em> zu definieren.  Es gibt einen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Sprachvorschlag</a> , der diese Verbesserung vorschlägt, der jedoch aufgrund von Kuriositäten in der Syntax noch diskutiert wird. </p><br><h3>  Die Dinge weiter bringen </h3><br><p>  Anonyme Datensätze können in einem breiteren Satz fortgeschrittener Kontexte verwendet werden. </p><br><h4>  Anonyme Datensätze sind serialisierbar </h4><br><p>  Sie können anonyme Datensätze serialisieren und deserialisieren: </p><br><pre> <code class="cpp hljs">open Newtonsoft.Json let phillip = {| name=<span class="hljs-string"><span class="hljs-string">"Phillip"</span></span>; age=<span class="hljs-number"><span class="hljs-number">28</span></span> |} let str = JsonConvert.SerializeObject(phillip) printfn <span class="hljs-string"><span class="hljs-string">"%s"</span></span> str let phillip' = JsonConvert.DeserializeObject&lt;{|name: <span class="hljs-built_in"><span class="hljs-built_in">string</span></span>; age: <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>|}&gt;(str) printfn <span class="hljs-string"><span class="hljs-string">"Name: %s Age: %d"</span></span> phillip<span class="hljs-string"><span class="hljs-string">'.name phillip'</span></span>.age</code> </pre> <br><p>  Dies gibt aus, was Sie erwarten könnten: </p><br><pre> <code class="cpp hljs">{<span class="hljs-string"><span class="hljs-string">"age"</span></span>:<span class="hljs-number"><span class="hljs-number">28</span></span>,<span class="hljs-string"><span class="hljs-string">"name"</span></span>:<span class="hljs-string"><span class="hljs-string">"Phillip"</span></span>} Name: Phillip Age: <span class="hljs-number"><span class="hljs-number">28</span></span></code> </pre> <br><p>  Hier ist eine Beispielbibliothek, die auch in einem anderen Projekt aufgerufen wird: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> AnonyRecdOne open Newtonsoft.Json <span class="hljs-keyword"><span class="hljs-keyword">module</span></span> AR = let serialize () = let phillip = {| name=<span class="hljs-string"><span class="hljs-string">"Phillip"</span></span>; age=<span class="hljs-number"><span class="hljs-number">28</span></span> |} JsonConvert.SerializeObject(phillip)</code> </pre> <br><pre> <code class="cpp hljs">open AnonyRecdOne open Newtonsoft.Json [&lt;EntryPoint&gt;] let main _ = let str = AR.serialize () let phillip = JsonConvert.DeserializeObject&lt;{|name: <span class="hljs-built_in"><span class="hljs-built_in">string</span></span>; age: <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>|}&gt;(str) printfn <span class="hljs-string"><span class="hljs-string">"Name: %s Age: %d"</span></span> phillip.name phillip.age</code> </pre> <br><p>  Dies kann Szenarien wie Lightweight-Daten, die über ein Netzwerk in einem System aus Microservices übertragen werden, vereinfachen. </p><br><h4>  Anonyme Datensätze können mit anderen Typdefinitionen kombiniert werden </h4><br><p>  Möglicherweise befindet sich in Ihrer Domäne ein baumartiges Datenmodell, z. B. das folgende Beispiel: </p><br><pre> <code class="cpp hljs">type FullName = { FirstName: <span class="hljs-built_in"><span class="hljs-built_in">string</span></span>; LastName: <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> } type Employee = | Engineer of FullName | Manager of name: FullName * reports: Employee <span class="hljs-built_in"><span class="hljs-built_in">list</span></span> | Executive of name: FullName * reports: Employee <span class="hljs-built_in"><span class="hljs-built_in">list</span></span> * assistant: Employee</code> </pre> <br><p>  Es ist typisch, Fälle als Tupel mit benannten Vereinigungsfeldern zu modellieren. Wenn die Daten jedoch komplizierter werden, können Sie jeden Fall mit Datensätzen extrahieren: </p><br><pre> <code class="cpp hljs">type FullName = { FirstName: <span class="hljs-built_in"><span class="hljs-built_in">string</span></span>; LastName: <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> } type Employee = | Engineer of FullName | Manager of Manager | Executive of Executive <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> Manager = { Name: FullName; Reports: Employee <span class="hljs-built_in"><span class="hljs-built_in">list</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> Executive = { Name: FullName; Reports: Employee <span class="hljs-built_in"><span class="hljs-built_in">list</span></span>; Assistant: Employee }</code> </pre> <br><p>  Diese rekursive Definition kann jetzt mit anonymen Datensätzen gekürzt werden, wenn sie zu Ihrer Codebasis passt: </p><br><pre> <code class="cpp hljs">type FullName = { FirstName: <span class="hljs-built_in"><span class="hljs-built_in">string</span></span>; LastName: <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> } type Employee = | Engineer of FullName | Manager of {| Name: FullName; Reports: Employee <span class="hljs-built_in"><span class="hljs-built_in">list</span></span> |} | Executive of {| Name: FullName; Reports: Employee <span class="hljs-built_in"><span class="hljs-built_in">list</span></span>; Assistant: Employee |}</code> </pre> <br><p>  Wie bei den vorherigen Beispielen sollte diese Technik mit Bedacht und gegebenenfalls auf Ihr Szenario angewendet werden. </p><br><h4>  Anonyme Datensätze vereinfachen die Verwendung von LINQ in F # </h4><br><p>  F # -Programmierer bevorzugen normalerweise die Verwendung der Kombinatoren List, Array und Sequence, wenn sie mit Daten arbeiten. Manchmal kann es jedoch hilfreich sein, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">LINQ</a> zu verwenden.  Dies war traditionell etwas schmerzhaft, da LINQ anonyme C # -Typen verwendet. </p><br><p>  Bei anonymen Datensätzen können Sie LINQ-Methoden genauso verwenden wie bei C # und anonymen Typen: </p><br><pre> <code class="cpp hljs">open System.Linq let names = [ <span class="hljs-string"><span class="hljs-string">"Ana"</span></span>; <span class="hljs-string"><span class="hljs-string">"Felipe"</span></span>; <span class="hljs-string"><span class="hljs-string">"Emillia"</span></span>] let nameGrouping = names.Select(fun n -&gt; {| Name=n; FirstLetter=n.[<span class="hljs-number"><span class="hljs-number">0</span></span>] |}) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> ng in nameGrouping <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> printfn <span class="hljs-string"><span class="hljs-string">"%s has first letter %c"</span></span> ng.Name ng.FirstLetter</code> </pre> <br><p>  Dies druckt: </p><br><pre> <code class="cpp hljs">Ana has first letter A Felipe has first letter F Emillia has first letter E</code> </pre> <br><h4>  Anonyme Datensätze erleichtern die Arbeit mit Entity Framework und anderen ORMs </h4><br><p>  F # -Programmierer, die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">F # -Abfrageausdrücke verwenden,</a> um mit einer Datenbank zu interagieren, sollten bei anonymen Datensätzen geringfügige Verbesserungen der Lebensqualität feststellen. </p><br><p>  Beispielsweise können Sie es gewohnt sein, Tupel zu verwenden, um Daten mit einer `select` -Klausel zu gruppieren: </p><br><pre> <code class="cpp hljs">let q = query { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> row in db.Status <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> select (row.StatusID, row.Name) }</code> </pre> <br><p>  Dies führt jedoch zu Spalten mit Namen wie <em>Item1</em> und <em>Item2</em> , die nicht ideal sind.  Vor anonymen Datensätzen müssten Sie einen Datensatztyp deklarieren und diesen verwenden.  Jetzt müssen Sie das nicht mehr tun: </p><br><pre> <code class="cpp hljs">let q = query { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> row in db.Status <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> select {| StatusID = row.StatusID; Name = row.Name |} }</code> </pre> <br><p>  Der Datensatztyp muss nicht im Voraus angegeben werden!  Dadurch werden Abfrageausdrücke viel stärker an der tatsächlichen SQL ausgerichtet, die sie modellieren. </p><br><p>  Mit anonymen Datensätzen müssen Sie außerdem vermeiden, <em>AnonymousObject-</em> Typen in erweiterten Abfragen erstellen zu müssen, um eine Ad-hoc-Gruppierung von Daten für die Zwecke der Abfrage zu erstellen. </p><br><h4>  Anonyme Datensätze vereinfachen die Verwendung von benutzerdefiniertem Routing in ASP.NET Core </h4><br><p>  Möglicherweise verwenden Sie ASP.NET Core bereits mit F #, sind jedoch beim Definieren benutzerdefinierter Routen möglicherweise auf Schwierigkeiten gestoßen.  Wie bei den vorherigen Beispielen könnte dies immer noch durch Definieren eines Datensatztyps im Voraus erfolgen, dies wurde jedoch von F # -Entwicklern häufig als unnötig angesehen.  Jetzt können Sie es inline tun: </p><br><pre> <code class="cpp hljs">app.UseMvc(fun routes -&gt; routes.MapRoute(<span class="hljs-string"><span class="hljs-string">"blog"</span></span>,<span class="hljs-string"><span class="hljs-string">"blog/{*article}"</span></span>, defaults={| controller=<span class="hljs-string"><span class="hljs-string">"Blog"</span></span>; action=<span class="hljs-string"><span class="hljs-string">"Article"</span></span> |}) |&gt; ignore ) |&gt; ignore</code> </pre> <br><p>  Es ist immer noch nicht ideal, da F # bei Rückgabetypen streng ist (im Gegensatz zu C #, wo Sie Dinge, die einen Wert zurückgeben, nicht explizit ignorieren müssen).  Auf diese Weise können Sie jedoch zuvor definierte Datensatzdefinitionen entfernen, die nur dazu dienten, Daten an die ASP.NET-Middleware-Pipeline zu senden. </p><br><h4>  Kopieren und aktualisieren Sie Ausdrücke mit anonymen Datensätzen </h4><br><p>  Wie bei Datensatztypen können Sie die Syntax zum Kopieren und Aktualisieren mit anonymen Datensätzen verwenden: </p><br><pre> <code class="cpp hljs">let data = {| X = <span class="hljs-number"><span class="hljs-number">1</span></span>; Y = <span class="hljs-number"><span class="hljs-number">2</span></span> |} let expandedData = {| data with Z = <span class="hljs-number"><span class="hljs-number">3</span></span> |} <span class="hljs-comment"><span class="hljs-comment">// Gives {| X=1; Y=2; Z=3 |} let stringifiedY = {| expandedData with Y="Hello!" |} // Gives {| X=1; Y="Hello!"; Z=3 |}</span></span></code> </pre> <br><p>  Der ursprüngliche Ausdruck kann auch ein Datensatztyp sein: </p><br><pre> <code class="cpp hljs">type R = { X: <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> } let data = { X=<span class="hljs-number"><span class="hljs-number">1</span></span> } let data' = {| data with Y = <span class="hljs-number"><span class="hljs-number">2</span></span> |} <span class="hljs-comment"><span class="hljs-comment">// Gives {| X=1; Y=2 |}</span></span></code> </pre> <br><p>  Sie können auch Daten in und aus Referenz- und Struktur-anonymen Datensätzen kopieren: </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Copy data from a reference record into a struct anonymous record type R1 = { X: int } let r1 = { X=1 } let data1 = struct {| r1 with Y=1 |} // Copy data from a struct record into a reference anonymous record [&lt;Struct&gt;] type R2 = { X: int } let r2 = { X=1 } let data2 = {| r1 with Y=1 |}</span></span></code> </pre> <br><p>  Die Verwendung von Kopier- und Aktualisierungsausdrücken bietet anonymen Datensätzen ein hohes Maß an Flexibilität bei der Arbeit mit Daten in F #. </p><br><h4>  Gleichheit und Musterübereinstimmung </h4><br><p>  Anonyme Datensätze sind strukturell gleichwertig und vergleichbar: </p><br><pre> <code class="cpp hljs">{| a = <span class="hljs-number"><span class="hljs-number">1</span></span>+<span class="hljs-number"><span class="hljs-number">1</span></span> |} = {| a = <span class="hljs-number"><span class="hljs-number">2</span></span> |} <span class="hljs-comment"><span class="hljs-comment">// true {| a = 1+1 |} &gt; {| a = 1 |} // true</span></span></code> </pre> <br><p>  Die verglichenen Typen müssen jedoch dieselbe „Form“ haben: </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// error FS0001: Two anonymous record types have mismatched sets of field names '["a"]' and '["a"; "b"]' {| a = 1+1 |} = {| a = 2; b = 1|}</span></span></code> </pre> <br><p>  Obwohl Sie anonyme Datensätze gleichsetzen und vergleichen können, können Sie keine Musterübereinstimmung darüber durchführen.  Dies hat zwei Gründe: </p><br><ul><li>  Im Gegensatz zu Datensatztypen muss ein Muster jedes Feld eines anonymen Datensatzes berücksichtigen.  Dies liegt daran, dass anonyme Datensätze keine strukturelle Untertypisierung unterstützen - es handelt sich um nominelle Typen. </li><li>  Es gibt keine Möglichkeit, zusätzliche Muster in einem Musterübereinstimmungsausdruck zu haben, da jedes einzelne Muster einen anderen anonymen Datensatztyp implizieren würde. </li><li>  Die Anforderung, jedes Feld in einem anonymen Datensatz zu berücksichtigen, würde ein Muster ausführlicher machen als die Verwendung der Punktnotation. </li></ul><br><p>  Stattdessen wird "dot" -Syntax verwendet, um Werte aus einem anonymen Datensatz zu extrahieren.  Dies ist immer höchstens so ausführlich, als ob ein Mustervergleich verwendet würde, und in der Praxis ist es wahrscheinlich weniger ausführlich, da nicht immer jeder Wert aus einem anonymen Datensatz extrahiert wird.  So arbeiten Sie mit einem vorherigen Beispiel, in dem anonyme Datensätze Teil einer diskriminierten Vereinigung sind: </p><br><pre> <code class="cpp hljs">type Employee = | Engineer of FullName | Manager of {| Name: FullName; Reports: Employee <span class="hljs-built_in"><span class="hljs-built_in">list</span></span> |} | Executive of {| Name: FullName; Reports: Employee <span class="hljs-built_in"><span class="hljs-built_in">list</span></span>; Assistant: Employee |} let getFirstName e = match e with | Engineer fullName -&gt; fullName.FirstName | Manager m -&gt; m.Name.FirstName | Executive ex -&gt; ex.Name.FirstName</code> </pre> <br><p>  Derzeit gibt es einen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">offenen Vorschlag</a> , den Mustervergleich für anonyme Datensätze in den begrenzten Kontexten zuzulassen, in denen sie tatsächlich aktiviert werden könnten.  Wenn Sie einen vorgeschlagenen Anwendungsfall haben, verwenden Sie dieses Problem, um ihn zu diskutieren! </p><br><h2>  FSharp.Core Ergänzungen </h2><br><p>  Es wäre keine weitere F # -Veröffentlichung ohne Ergänzungen der F # -Kernbibliothek! </p><br><h3>  ValueOption-Erweiterung </h3><br><p>  Der in F # 4.5 eingeführte <em>ValueOption-</em> Typ enthält jetzt einige weitere Extras: </p><br><ul><li>  Das <em>DebuggerDisplay-</em> Attribut zur Unterstützung beim Debuggen </li><li>  <em>IsNone-</em> , <em>IsSome-</em> , <em>None-</em> , <em>Some-</em> , <em>op_Implicit-</em> und <em>ToString-</em> Mitglieder </li></ul><br><p>  Dies gibt ihm "Parität" mit dem Optionstyp. </p><br><p>  Zusätzlich gibt es jetzt ein <em>ValueOption-</em> Modul, das dieselben Funktionen enthält wie das Option-Modul: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">module</span></span> ValueOption = [&lt;CompiledName(<span class="hljs-string"><span class="hljs-string">"IsSome"</span></span>)&gt;] val <span class="hljs-keyword"><span class="hljs-keyword">inline</span></span> isSome: voption:<span class="hljs-string"><span class="hljs-string">'T voption -&gt; bool [&lt;CompiledName("IsNone")&gt;] val inline isNone: voption:'</span></span>T voption -&gt; <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> [&lt;CompiledName(<span class="hljs-string"><span class="hljs-string">"DefaultValue"</span></span>)&gt;] val defaultValue: value:<span class="hljs-string"><span class="hljs-string">'T -&gt; voption:'</span></span>T voption -&gt; <span class="hljs-string"><span class="hljs-string">'T [&lt;CompiledName("DefaultWith")&gt;] val defaultWith: defThunk:(unit -&gt; '</span></span>T) -&gt; voption:<span class="hljs-string"><span class="hljs-string">'T voption -&gt; '</span></span>T [&lt;CompiledName(<span class="hljs-string"><span class="hljs-string">"OrElse"</span></span>)&gt;] val orElse: ifNone:<span class="hljs-string"><span class="hljs-string">'T voption -&gt; voption:'</span></span>T voption -&gt; <span class="hljs-string"><span class="hljs-string">'T voption [&lt;CompiledName("OrElseWith")&gt;] val orElseWith: ifNoneThunk:(unit -&gt; '</span></span>T voption) -&gt; voption:<span class="hljs-string"><span class="hljs-string">'T voption -&gt; '</span></span>T voption [&lt;CompiledName(<span class="hljs-string"><span class="hljs-string">"GetValue"</span></span>)&gt;] val get: voption:<span class="hljs-string"><span class="hljs-string">'T voption -&gt; '</span></span>T [&lt;CompiledName(<span class="hljs-string"><span class="hljs-string">"Count"</span></span>)&gt;] val count: voption:<span class="hljs-string"><span class="hljs-string">'T voption -&gt; int [&lt;CompiledName("Fold")&gt;] val fold&lt;'</span></span>T,<span class="hljs-string"><span class="hljs-string">'State&gt; : folder:('</span></span>State -&gt; <span class="hljs-string"><span class="hljs-string">'T -&gt; '</span></span>State) -&gt; state:<span class="hljs-string"><span class="hljs-string">'State -&gt; voption:'</span></span>T voption -&gt; <span class="hljs-string"><span class="hljs-string">'State [&lt;CompiledName("FoldBack")&gt;] val foldBack&lt;'</span></span>T,<span class="hljs-string"><span class="hljs-string">'State&gt; : folder:('</span></span>T -&gt; <span class="hljs-string"><span class="hljs-string">'State -&gt; '</span></span>State) -&gt; voption:<span class="hljs-string"><span class="hljs-string">'T voption -&gt; state:'</span></span>State -&gt; <span class="hljs-string"><span class="hljs-string">'State [&lt;CompiledName("Exists")&gt;] val exists: predicate:('</span></span>T -&gt; <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>) -&gt; voption:<span class="hljs-string"><span class="hljs-string">'T voption -&gt; bool [&lt;CompiledName("ForAll")&gt;] val forall: predicate:('</span></span>T -&gt; <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>) -&gt; voption:<span class="hljs-string"><span class="hljs-string">'T voption -&gt; bool [&lt;CompiledName("Contains")&gt;] val inline contains: value:'</span></span>T -&gt; voption:<span class="hljs-string"><span class="hljs-string">'T voption -&gt; bool when '</span></span>T : equality [&lt;CompiledName(<span class="hljs-string"><span class="hljs-string">"Iterate"</span></span>)&gt;] val iter: action:(<span class="hljs-string"><span class="hljs-string">'T -&gt; unit) -&gt; voption:'</span></span>T voption -&gt; unit [&lt;CompiledName(<span class="hljs-string"><span class="hljs-string">"Map"</span></span>)&gt;] val <span class="hljs-built_in"><span class="hljs-built_in">map</span></span>: mapping:(<span class="hljs-string"><span class="hljs-string">'T -&gt; '</span></span>U) -&gt; voption:<span class="hljs-string"><span class="hljs-string">'T voption -&gt; '</span></span>U voption [&lt;CompiledName(<span class="hljs-string"><span class="hljs-string">"Map2"</span></span>)&gt;] val map2: mapping:(<span class="hljs-string"><span class="hljs-string">'T1 -&gt; '</span></span>T2 -&gt; <span class="hljs-string"><span class="hljs-string">'U) -&gt; voption1: '</span></span>T1 voption -&gt; voption2: <span class="hljs-string"><span class="hljs-string">'T2 voption -&gt; '</span></span>U voption [&lt;CompiledName(<span class="hljs-string"><span class="hljs-string">"Map3"</span></span>)&gt;] val map3: mapping:(<span class="hljs-string"><span class="hljs-string">'T1 -&gt; '</span></span>T2 -&gt; <span class="hljs-string"><span class="hljs-string">'T3 -&gt; '</span></span>U) -&gt; <span class="hljs-string"><span class="hljs-string">'T1 voption -&gt; '</span></span>T2 voption -&gt; <span class="hljs-string"><span class="hljs-string">'T3 voption -&gt; '</span></span>U voption [&lt;CompiledName(<span class="hljs-string"><span class="hljs-string">"Bind"</span></span>)&gt;] val bind: binder:(<span class="hljs-string"><span class="hljs-string">'T -&gt; '</span></span>U voption) -&gt; voption:<span class="hljs-string"><span class="hljs-string">'T voption -&gt; '</span></span>U voption [&lt;CompiledName(<span class="hljs-string"><span class="hljs-string">"Flatten"</span></span>)&gt;] val flatten: voption:<span class="hljs-string"><span class="hljs-string">'T voption voption -&gt; '</span></span>T voption [&lt;CompiledName(<span class="hljs-string"><span class="hljs-string">"Filter"</span></span>)&gt;] val filter: predicate:(<span class="hljs-string"><span class="hljs-string">'T -&gt; bool) -&gt; voption:'</span></span>T voption -&gt; <span class="hljs-string"><span class="hljs-string">'T voption [&lt;CompiledName("ToArray")&gt;] val toArray: voption:'</span></span>T voption -&gt; <span class="hljs-string"><span class="hljs-string">'T[] [&lt;CompiledName("ToList")&gt;] val toList: voption:'</span></span>T voption -&gt; <span class="hljs-string"><span class="hljs-string">'T list [&lt;CompiledName("ToNullable")&gt;] val toNullable: voption:'</span></span>T voption -&gt; Nullable&lt;<span class="hljs-string"><span class="hljs-string">'T&gt; [&lt;CompiledName("OfNullable")&gt;] val ofNullable: value:Nullable&lt;'</span></span>T&gt; -&gt; <span class="hljs-string"><span class="hljs-string">'T voption [&lt;CompiledName("OfObj")&gt;] val ofObj: value: '</span></span>T -&gt; <span class="hljs-string"><span class="hljs-string">'T voption when '</span></span>T : null [&lt;CompiledName(<span class="hljs-string"><span class="hljs-string">"ToObj"</span></span>)&gt;] val toObj: value: <span class="hljs-string"><span class="hljs-string">'T voption -&gt; '</span></span>T when <span class="hljs-string"><span class="hljs-string">'T : null</span></span></code> </pre> <br><p>  Dies sollte alle Bedenken zerstreuen, dass "ValueOption" das seltsame Geschwister von "Option" ist, das nicht die gleiche Funktionalität erhält. </p><br><h3>  tryExactlyOne für List, Array und Seq </h3><br><p>  Diese feine Funktion wurde von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Grzegorz Dziadkiewicz beigesteuert</a> .  So funktioniert es: </p><br><pre> <code class="cpp hljs">List.tryExactlyOne [] <span class="hljs-comment"><span class="hljs-comment">// None List.tryExactlyOne [1] // Some 1 List.tryExactlyOne [1; 2] // None Array.tryExactlyOne null // ArgumentNullException Array.tryExactlyOne [||] // None Array.tryExactlyOne [|1|] // Some 1 Array.tryExactlyOne [|1; 2|] // None Seq.tryExactlyOne null // ArgumentNullException Seq.tryExactlyOne (Seq.ofList []) // None Seq.tryExactlyOne (Seq.ofList [1]) // Some 1 Seq.tryExactlyOne (Seq.ofList [1; 2]) // None</span></span></code> </pre> <br><h2>  Einpacken </h2><br><p>  Obwohl die Gesamtliste der Funktionen in F # 4.6 nicht riesig ist, gehen sie dennoch ziemlich tief!  Wir empfehlen Ihnen, F # 4.6 auszuprobieren und uns Feedback zu geben, damit wir die Dinge vor der vollständigen Veröffentlichung optimieren können.  Wie immer danke ich der F # Community für ihre Beiträge - sowohl in der Code- als auch in der Designdiskussion - die uns helfen, die F # -Sprache weiter voranzutreiben. </p><br><p>  Prost und viel Spaß beim Hacken! </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de437666/">https://habr.com/ru/post/de437666/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de437654/index.html">Preiswerte und kostengünstige 3D-Fotopolymerdrucker</a></li>
<li><a href="../de437656/index.html">Elefant in einem Porzellanladen: 3D-Drucker mit einem riesigen Druckfeld</a></li>
<li><a href="../de437658/index.html">Anleitung: Thymeleaf + Spring. Teil 3</a></li>
<li><a href="../de437660/index.html">Aktualisierung des Lebenszeitprofils in Visual Studio 2019 Vorschau 2</a></li>
<li><a href="../de437664/index.html">Zusammengesetzte Rückgewinnung</a></li>
<li><a href="../de437670/index.html">MSVC-Backend-Updates in Visual Studio 2019 Vorschau 2: Neue Optimierungen, OpenMP- und Build-Durchsatzverbesserungen</a></li>
<li><a href="../de437672/index.html">cyberd: Berechnung des Wissens aus web3</a></li>
<li><a href="../de437674/index.html">3D-Objekterkennungsmethoden für unbemannte Fahrzeuge. Yandex-Bericht</a></li>
<li><a href="../de437676/index.html">Universitäten und Corporate Accelerators als Hebel für den Start eines B2B-Startups in den USA</a></li>
<li><a href="../de437680/index.html">Meine DIY-Sammlung auf Youtube</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>