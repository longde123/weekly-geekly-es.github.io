<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🎶 👺 ➗ 如何使用C ++ 17，元组和一些幻想使CortexM上的4个LED闪烁 ☯️ 🧓🏿 🚶</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="大家身体健康！ 

 在大学里教学生开发用于微控制器的嵌入式软件时，我使用C ++，有时我会给对各种任务特别感兴趣的学生找出有特殊头痛的天才学生。 

 再一次，此类学生的任务是使用C ++ 17语言和标准C ++库使4个LED闪烁，而无需连接其他库，例如CMSIS及其带有寄存器结构描述的头文件，等...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>如何使用C ++ 17，元组和一些幻想使CortexM上的4个LED闪烁</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/457246/">大家身体健康！ <br><br> 在大学里教学生开发用于微控制器的嵌入式软件时，我使用C ++，有时我会给对各种任务特别感兴趣的学生找出有特殊头痛的天才学生。 <br><br> 再一次，此类学生的任务是使用C ++ 17语言和标准C ++库使4个LED闪烁，而无需连接其他库，例如CMSIS及其带有寄存器结构描述的头文件，等等。 ROM中的内存将是最小的大小和最少的RAM。 编译器优化不应高于中级。  IAR编译器8.40.1。 <br> 获胜者<s>前往Canary，</s>获得5分考试。 <br><br> 我自己之前也没有解决过这个问题，因此，我将告诉您学生如何解决该问题以及发生了什么事。 我立即警告您，此类代码不太可能在实际应用中使用，这就是为什么我将出版物发布在“异常编程”部分中的原因，尽管谁知道。 <br><a name="habracut"></a><br><h3> 任务条件 </h3><br> 端口GPIOA.5，GPIOC.5，GPIOC.8，GPIOC.9上有4个LED。 他们需要眨眼。 为了比较，我们使用了用C编写的代码： <br><br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">delay</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">1000000</span></span>; ++i){ } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(;;) { GPIOA-&gt;ODR ^= (<span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; <span class="hljs-number"><span class="hljs-number">5</span></span>); GPIOC-&gt;ODR ^= (<span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; <span class="hljs-number"><span class="hljs-number">5</span></span>); GPIOC-&gt;ODR ^= (<span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; <span class="hljs-number"><span class="hljs-number">8</span></span>); GPIOC-&gt;ODR ^= (<span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; <span class="hljs-number"><span class="hljs-number">9</span></span>); delay(); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> ; }</code> </pre> <br> 这里的<code>delay()</code>函数纯粹是形式上的，有规律的循环，无法对其进行优化。 <br> 假定端口已经配置为输出，并且已对其应用时钟。 <br> 我还要立即说，bitbanging并不是用来使代码可移植的。 <br><br> 中等优化时，此代码在堆栈上占用8个字节，在ROM中占用256个字节 <br><blockquote>  255个字节的只读代码存储器 <br>  1字节的只读数据存储器 <br>  8字节的读写数据存储器 </blockquote><br> 由于部分内存位于中断向量表之下，调用IAR函数以初始化浮点块，各种调试函数和__low_level_init函数（端口本身已在其中配置）的事实，因此为255个字节。 <br><br> 因此，完整的要求是： <br><br><ul><li>  main（）函数应包含尽可能少的代码 </li><li> 您不能使用宏 </li><li>  IAR 8.40.1编译器支持C ++ 17 </li><li>  CMSIS头文件，例如“ #include” stm32f411xe.h“ </li><li> 您可以将__forceinline指令用于内联函数 </li><li> 中等编译器优化 </li></ul><br><h3> 学生决定 </h3><br> 总的来说，有几种解决方案，我只会展示一种……这不是最佳方案，但我很喜欢。 <br><br> 由于无法使用标题，因此学生要做的第一件事是<code>Gpio</code>类，该类应在其地址处存储指向端口寄存器的链接。 为此，他们使用结构叠加层，很可能是从这里得到的想法： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">结构叠加层</a> ： <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Gpio</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: __<span class="hljs-function"><span class="hljs-function">forceinline </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Toggle</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint8_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> bitNum)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">volatile</span></span></span><span class="hljs-function"> </span></span>{ Odr ^= bitNum ; } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">volatile</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> Moder; <span class="hljs-keyword"><span class="hljs-keyword">volatile</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> Otyper; <span class="hljs-keyword"><span class="hljs-keyword">volatile</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> Ospeedr; <span class="hljs-keyword"><span class="hljs-keyword">volatile</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> Pupdr; <span class="hljs-keyword"><span class="hljs-keyword">volatile</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> Idr; <span class="hljs-keyword"><span class="hljs-keyword">volatile</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> Odr; <span class="hljs-comment"><span class="hljs-comment">//    static_assert(sizeof(Gpio) == sizeof(std::uint32_t) * 6); } ;</span></span></code> </pre> <br> 如您所见，他们立即识别了<code>Gpio</code>类，该类具有应位于相应寄存器的地址处的属性，以及一种通过分支数来切换状态的方法： <br> 然后，我们确定了<code>GpioPin</code>的结构， <code>GpioPin</code>包含指向<code>Gpio</code>的指针和支脚的编号： <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">GpioPin</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">volatile</span></span> Gpio* port ; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> pinNum ; } ;</code> </pre> <br> 然后，他们在端口的特定分支上制作了一个LED阵列，并通过调用每个LED的<code>Toggle()</code>方法来检查该LED： <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> GpioPin leds[] = {{<span class="hljs-keyword"><span class="hljs-keyword">reinterpret_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">volatile</span></span> Gpio*&gt;(GpioaBaseAddr), <span class="hljs-number"><span class="hljs-number">5</span></span>}, {<span class="hljs-keyword"><span class="hljs-keyword">reinterpret_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">volatile</span></span> Gpio*&gt;(GpiocBaseAddr), <span class="hljs-number"><span class="hljs-number">5</span></span>}, {<span class="hljs-keyword"><span class="hljs-keyword">reinterpret_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">volatile</span></span> Gpio*&gt;(GpiocBaseAddr), <span class="hljs-number"><span class="hljs-number">9</span></span>}, {<span class="hljs-keyword"><span class="hljs-keyword">reinterpret_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">volatile</span></span> Gpio*&gt;(GpiocBaseAddr), <span class="hljs-number"><span class="hljs-number">9</span></span>} } ; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">LedsDriver</span></span></span><span class="hljs-class"> {</span></span> __<span class="hljs-function"><span class="hljs-function">forceinline </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ToggelAll</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span>&amp; it: leds) { it.port-&gt;Toggle(it.pinNum); } } } ;</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">好吧，实际上是整个代码：</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> GpioaBaseAddr = <span class="hljs-number"><span class="hljs-number">0x4002'0000</span></span> ; <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> GpiocBaseAddr = <span class="hljs-number"><span class="hljs-number">0x4002'0800</span></span> ; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Gpio</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: __<span class="hljs-function"><span class="hljs-function">forceinline </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Toggle</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint8_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> bitNum)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">volatile</span></span></span><span class="hljs-function"> </span></span>{ Odr ^= bitNum ; } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">volatile</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> Moder; <span class="hljs-keyword"><span class="hljs-keyword">volatile</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> Otyper; <span class="hljs-keyword"><span class="hljs-keyword">volatile</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> Ospeedr; <span class="hljs-keyword"><span class="hljs-keyword">volatile</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> Pupdr; <span class="hljs-keyword"><span class="hljs-keyword">volatile</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> Idr; <span class="hljs-keyword"><span class="hljs-keyword">volatile</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> Odr; } ; <span class="hljs-comment"><span class="hljs-comment">//    static_assert(sizeof(Gpio) == sizeof(std::uint32_t) * 6); struct GpioPin { volatile Gpio* port ; std::uint32_t pinNum ; } ; const GpioPin leds[] = {{reinterpret_cast&lt;volatile Gpio*&gt;(GpioaBaseAddr), 5}, {reinterpret_cast&lt;volatile Gpio*&gt;(GpiocBaseAddr), 5}, {reinterpret_cast&lt;volatile Gpio*&gt;(GpiocBaseAddr), 9}, {reinterpret_cast&lt;volatile Gpio*&gt;(GpiocBaseAddr), 9} } ; struct LedsDriver { __forceinline static inline void ToggelAll() { for (auto&amp; it: leds) { it.port-&gt;Toggle(it.pinNum); } } } ; int main() { for(;;) { LedsContainer::ToggleAll() ; delay(); } return 0 ; }</span></span></code> </pre> <br></div></div><br> 有关媒介优化的代码统计信息： <br><blockquote>  275个字节的只读代码存储器 <br>  1字节的只读数据存储器 <br>  8字节的读写数据存储器 </blockquote><br> 一个很好的解决方案，但是需要很多内存:) <br><br><h3> 我的决定 </h3><br> 当然，我决定不寻找简单的方法，而是严肃地采取行动:)。 <br>  LED位于不同的端口和不同的支脚上。 您需要做的第一件事是制作<code>Port</code>类，但是要摆脱占用RAM的指针和变量，您需要使用静态方法。 端口类可能如下所示： <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> addr&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Port</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-comment"><span class="hljs-comment">//  -  };</span></span></code> </pre> <br> 作为模板参数，它将具有端口地址。 例如，在<code>"#include "stm32f411xe.h"</code> ，对于端口A，它定义为GPIOA_BASE。但是我们不允许使用这些头文件，因此我们只需要设置自己的常量即可。因此，可以像这样使用该类： <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> GpioaBaseAddr = <span class="hljs-number"><span class="hljs-number">0x4002'0000</span></span> ; <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> GpiocBaseAddr = <span class="hljs-number"><span class="hljs-number">0x4002'0800</span></span> ; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> PortA = Port&lt;GpioaBaseAddr&gt; ; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> PortC = Port&lt;GpiocBaseAddr&gt; ;</code> </pre><br> 要闪烁，您需要Toggle方法（const std :: uint8_t位），该方法将使用异或运算来切换所需的位。 该方法必须是静态的，将其添加到类中： <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> addr&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Port</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-comment"><span class="hljs-comment">//   __forceinline,        __forceinline inline static void Toggle(const std::uint8_t bitNum) { *reinterpret_cast&lt;std::uint32_t*&gt;(addr+20) ^= (1 &lt;&lt; bitNum) ; //addr + 20  ODR  } };</span></span></code> </pre> <br> 优秀的<code>Port&lt;&gt;</code>是，它可以切换腿的状态。  LED位于特定的腿上，因此逻辑上要创建一个<code>Pin</code>类，该类将以<code>Port&lt;&gt;</code>和分支编号作为模板参数。 由于<code>Port&lt;&gt;</code>类型是模板，即 对于不同的端口，我们只能传输通用类型T。 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> pinNum&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Pin</span></span></span><span class="hljs-class"> {</span></span> __<span class="hljs-function"><span class="hljs-function">forceinline </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Toggle</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ T::Toggle(pinNum) ; } } ;</code> </pre> <br> 尽管假定我们只应传递<code>Port&lt;&gt;</code>类型，但是我们不能传递任何具有<code>Toggle()</code>方法的<code>T</code>类型废话，这将是无效的。 为了防止这种情况的发生，我们将使<code>Port&lt;&gt;</code>继承自<code>PortBase</code>基类，并在模板中将验证传递的类型确实基于<code>PortBase</code> 。 我们得到以下内容： <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> OdrAddrShift = <span class="hljs-number"><span class="hljs-number">20U</span></span>; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PortBase</span></span></span><span class="hljs-class"> {</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> addr&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Port</span></span></span><span class="hljs-class">:</span></span> PortBase { __<span class="hljs-function"><span class="hljs-function">forceinline </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Toggle</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint8_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> bit)</span></span></span><span class="hljs-function"> </span></span>{ *<span class="hljs-keyword"><span class="hljs-keyword">reinterpret_cast</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span>*&gt;(addr ) ^= (<span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; bit) ; } }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> pinNum, <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">typename</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">std</span></span></span><span class="hljs-class">:</span></span>:<span class="hljs-keyword"><span class="hljs-keyword">enable_if_t</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::is_base_of&lt;PortBase, T&gt;::value&gt;&gt; <span class="hljs-comment"><span class="hljs-comment">//   struct Pin { __forceinline inline static void Toggle() { T::Toggle(pinNum) ; } } ;</span></span></code> </pre> <br> 现在，仅当我们的类具有基类<code>PortBase</code>实例化模板。 <br> 从理论上讲，您已经可以使用这些类，让我们看看没有优化会发生什么： <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> PortA = Port&lt;GpioaBaseAddr&gt; ; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> PortC = Port&lt;GpiocBaseAddr&gt; ; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Led1 = Pin&lt;PortA, <span class="hljs-number"><span class="hljs-number">5</span></span>&gt; ; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Led2 = Pin&lt;PortC, <span class="hljs-number"><span class="hljs-number">5</span></span>&gt; ; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Led3 = Pin&lt;PortC, <span class="hljs-number"><span class="hljs-number">8</span></span>&gt; ; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Led4 = Pin&lt;PortC, <span class="hljs-number"><span class="hljs-number">9</span></span>&gt; ; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(;;) { Led1::Toggle(); Led2::Toggle(); Led3::Toggle(); Led4::Toggle(); delay(); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> ; }</code> </pre> <br><blockquote>  271个字节的只读代码存储器 <br>  1字节的只读数据存储器 <br>  24字节的读写数据存储器 </blockquote><br>  RAM中额外的16个字节和ROM中16个字节从何而来。 它们来自以下事实：我们将bit参数传递给Port类的Toggle函数（const std :: uint8_t位），并且编译器在输入main函数时会在该参数通过的堆栈上保存4个其他寄存器，然后使用它们寄存器中存储了每个引脚的脚编号的值，并在离开主电源时从堆栈中恢复了这些寄存器。 而且，尽管从本质上讲这是某种完全没用的工作，但是由于这些函数是内置的，所以编译器的行为完全符合该标准。 <br> 您可以通过以下方法消除此问题：通常删除端口类，将端口地址作为<code>Pin</code>类的模板参数传递，并在<code>Toggle()</code>方法内部，计算ODR寄存器的地址： <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> OdrAddrShift = <span class="hljs-number"><span class="hljs-number">20U</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> addr, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> pinNum, <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Pin</span></span></span><span class="hljs-class"> {</span></span> __<span class="hljs-function"><span class="hljs-function">forceinline </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Toggle</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ *<span class="hljs-keyword"><span class="hljs-keyword">reinterpret_cast</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span>*&gt;(addr + OdrAddrShift ) ^= (<span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; bit) ; } } ; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Led1 = Pin&lt;GpioaBaseAddr, <span class="hljs-number"><span class="hljs-number">5</span></span>&gt; ;</code> </pre> <br> 但是，这看起来不是很好，并且用户友好。 因此，我们希望编译器通过一些优化来消除这种不必要的寄存器保存。 <br><br> 我们对Medium进行优化，然后看到结果： <br><blockquote>  251个字节的只读代码存储器 <br>  1字节的只读数据存储器 <br>  8字节的读写数据存储器 </blockquote><br> 哇哇...少了4个字节 <div class="spoiler">  <b class="spoiler_title">代号</b> <div class="spoiler_text"><blockquote>  255个字节的只读代码存储器 <br>  1字节的只读数据存储器 <br>  8字节的读写数据存储器 </blockquote><br></div></div><br> 怎么会这样 让我们看一下调试器中的C ++代码（左）和C代码（右）的汇编器： <br><br><img src="https://habrastorage.org/webt/vh/ym/d9/vhymd9hbcko9luonsasg-xz7w7e.png" alt="图片"><br><br> 可以看出，首先，编译器内置了所有功能，现在根本没有调用，其次，它优化了寄存器的使用。 可以看出，在使用C代码的情况下，编译器使用R1或R2寄存器存储端口地址，并在每次切换该位时执行其他操作（将地址保存在R1或R2中的寄存器中）。 在第二种情况下，它仅使用R1寄存器，并且由于最后3个调用总是从端口C进行的，因此不再需要在寄存器中保存相同的端口C地址。 结果，节省了2个团队和4个字节。 <br><br> 这是现代编译器的奇迹：)好吧，好吧。 原则上，可以停在那里，但让我们继续前进。 我认为不可能优化其他任何东西，尽管可能不正确，如果您有想法，请在评论中写下。 但是有了main（）中的大量代码，您就可以工作。 <br><br> 现在，我希望所有的LED都位于容器中的某个位置，您可以调用该方法，切换所有内容...像这样： <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(;;) { LedsContainer::ToggleAll() ; delay(); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> ; }</code> </pre> <br> 我们不会愚蠢地将4个LED的开关插入到LedsContainer :: ToggleAll函数中，因为这并不有趣：)。 我们希望将LED放入容器中，然后对它们进行遍历并在每个LED上调用Toggle（）方法。 <br><br>  <i>学生使用数组存储指向LED的指针。</i> 但是我有不同的类型，例如： <code>Pin&lt;PortA, 5&gt;</code> ， <code>Pin&lt;PortC, 5&gt;</code> ，并且我无法在数组中存储指向不同类型的指针。 您可以为所有Pin做一个虚拟的基础班，但是随后会出现一个虚拟功能表，我不会成功赢得学生。 <br><br> 因此，我们将使用元组。 它允许您存储不同类型的对象。 这种情况将如下所示： <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">LedsContainer</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> records = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::make_tuple ( Pin&lt;PortA, <span class="hljs-number"><span class="hljs-number">5</span></span>&gt;{}, Pin&lt;PortC, <span class="hljs-number"><span class="hljs-number">5</span></span>&gt;{}, Pin&lt;PortC, <span class="hljs-number"><span class="hljs-number">8</span></span>&gt;{}, Pin&lt;PortC, <span class="hljs-number"><span class="hljs-number">9</span></span>&gt;{} ) ; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> tRecordsTuple = <span class="hljs-keyword"><span class="hljs-keyword">decltype</span></span>(records) ; }</code> </pre> <br> 有一个很棒的容器，它存储所有LED。 现在向其中添加<code>ToggleAll()</code>方法： <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">LedsContainer</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: __<span class="hljs-function"><span class="hljs-function">forceinline </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ToggleAll</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//        } private: constexpr static auto records = std::make_tuple ( Pin&lt;PortA, 5&gt;{}, Pin&lt;PortC, 5&gt;{}, Pin&lt;PortC, 8&gt;{}, Pin&lt;PortC, 9&gt;{} ) ; using tRecordsTuple = decltype(records) ; }</span></span></code> </pre> <br> 您不能只遍历元组的元素，因为元组元素只能在编译阶段接收。 要访问元组的元素，有一个模板get方法。 好吧 如果我们这样编写<code>std::get&lt;0&gt;(records).Toggle()</code> ，则如果<code>std::get&lt;1&gt;(records).Toggle()</code> ，则对类<code>Pin&lt;PortA, 5&gt;</code>的对象调用<code>Toggle()</code>方法。然后为类<code>Pin&lt;Port, 5&gt;</code>的对象调用<code>Toggle()</code>方法，依此类推... <br><br> 您可以<s>擦拭学生的鼻子</s> ，只需写下： <br><br><pre> <code class="cpp hljs"> __<span class="hljs-function"><span class="hljs-function">forceinline </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ToggleAll</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::get&lt;<span class="hljs-number"><span class="hljs-number">0</span></span>&gt;(records).Toggle(); <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::get&lt;<span class="hljs-number"><span class="hljs-number">1</span></span>&gt;(records).Toggle(); <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::get&lt;<span class="hljs-number"><span class="hljs-number">2</span></span>&gt;(records).Toggle(); <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::get&lt;<span class="hljs-number"><span class="hljs-number">3</span></span>&gt;(records).Toggle(); }</code> </pre> <br> 但是我们不想让支持该代码并允许他做更多工作的程序员费劲，例如在出现另一个LED的情况下，花掉他公司的资源。 您将不得不在元组和此方法的两个位置添加代码-这样做不好，并且公司所有者不会非常满意。 因此，我们使用辅助方法绕过元组： <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">LedsContainer</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">friend</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: __<span class="hljs-function"><span class="hljs-function">forceinline </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ToggleAll</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//    3,2,1,0    ,     visit(std::make_index_sequence&lt;std::tuple_size&lt;tRecordsTuple&gt;::value&gt;()); } private: __forceinline template&lt;std::size_t... index&gt; static inline void visit(std::index_sequence&lt;index...&gt;) { Pass((std::get&lt;index&gt;(records).Toggle(), true)...); //    get&lt;3&gt;(records).Toggle(), get&lt;2&gt;(records).Toggle(), get&lt;1&gt;(records).Toggle(), get&lt;0&gt;(records).Toggle() } __forceinline template&lt;typename... Args&gt; static void inline Pass(Args... ) {//      } constexpr static auto records = std::make_tuple ( Pin&lt;PortA, 5&gt;{}, Pin&lt;PortC, 5&gt;{}, Pin&lt;PortC, 8&gt;{}, Pin&lt;PortC, 9&gt;{} ) ; using tRecordsTuple = decltype(records) ; }</span></span></code> </pre> <br> 它看起来很吓人，但我在文章开头警告说<s>shizany</s>方法不是很普通... <br><br> 在编译阶段，以上所有这些魔术实际上执行以下操作： <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//  LedsContainer::ToggleAll() ; //   4 : Pin&lt;Port, 9&gt;().Toggle() ; Pin&lt;Port, 8&gt;().Toggle() ; Pin&lt;PortC, 5&gt;().Toggle() ; Pin&lt;PortA, 5&gt;().Toggle() ; //     Toggle() inline,   : *reinterpret_cast&lt;std::uint32_t*&gt;(0x40020814 ) ^= (1 &lt;&lt; 9) ; *reinterpret_cast&lt;std::uint32_t*&gt;(0x40020814 ) ^= (1 &lt;&lt; 8) ; *reinterpret_cast&lt;std::uint32_t*&gt;(0x40020814 ) ^= (1 &lt;&lt; 5) ; *reinterpret_cast&lt;std::uint32_t*&gt;(0x40020014 ) ^= (1 &lt;&lt; 5) ;</span></span></code> </pre> <br> 继续编译并检查代码大小，无需优化： <br><br><div class="spoiler">  <b class="spoiler_title">编译的代码</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;cstddef&gt; #include &lt;tuple&gt; #include &lt;utility&gt; #include &lt;cstdint&gt; #include &lt;type_traits&gt; //#include "stm32f411xe.h" #define __forceinline _Pragma("inline=forced") constexpr std::uint32_t GpioaBaseAddr = 0x4002'0000 ; constexpr std::uint32_t GpiocBaseAddr = 0x4002'0800 ; constexpr std::uint32_t OdrAddrShift = 20U; struct PortBase { }; template &lt;std::uint32_t addr&gt; struct Port: PortBase { __forceinline inline static void Toggle(const std::uint8_t bit) { *reinterpret_cast&lt;std::uint32_t*&gt;(addr + OdrAddrShift) ^= (1 &lt;&lt; bit) ; } }; template &lt;typename T, std::uint8_t pinNum, class = typename std::enable_if_t&lt;std::is_base_of&lt;PortBase, T&gt;::value&gt;&gt; struct Pin { __forceinline inline static void Toggle() { T::Toggle(pinNum) ; } } ; using PortA = Port&lt;GpioaBaseAddr&gt; ; using PortC = Port&lt;GpiocBaseAddr&gt; ; //using Led1 = Pin&lt;PortA, 5&gt; ; //using Led2 = Pin&lt;PortC, 5&gt; ; //using Led3 = Pin&lt;PortC, 8&gt; ; //using Led4 = Pin&lt;PortC, 9&gt; ; class LedsContainer { friend int main() ; public: __forceinline static inline void ToggleAll() { //    3,2,1,0    ,     visit(std::make_index_sequence&lt;std::tuple_size&lt;tRecordsTuple&gt;::value&gt;()); } private: __forceinline template&lt;std::size_t... index&gt; static inline void visit(std::index_sequence&lt;index...&gt;) { Pass((std::get&lt;index&gt;(records).Toggle(), true)...); } __forceinline template&lt;typename... Args&gt; static void inline Pass(Args... ) { } constexpr static auto records = std::make_tuple ( Pin&lt;PortA, 5&gt;{}, Pin&lt;PortC, 5&gt;{}, Pin&lt;PortC, 8&gt;{}, Pin&lt;PortC, 9&gt;{} ) ; using tRecordsTuple = decltype(records) ; } ; void delay() { for (int i = 0; i &lt; 1000000; ++i){ } } int main() { for(;;) { LedsContainer::ToggleAll() ; //GPIOA-&gt;ODR ^= 1 &lt;&lt; 5; //GPIOC-&gt;ODR ^= 1 &lt;&lt; 5; //GPIOC-&gt;ODR ^= 1 &lt;&lt; 8; //GPIOC-&gt;ODR ^= 1 &lt;&lt; 9; delay(); } return 0 ; }</span></span></span></span></code> </pre> <br></div></div><br><div class="spoiler">  <b class="spoiler_title">组装证明，按计划包装：</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/0e/aa/un/0eaaunh1qwmg73s1p-3ev4zcpws.png" alt="图片"><br></div></div><br> 我们看到内存过大，多了18个字节。 问题是相同的，再加上12个字节。 我不知道它们的来源...也许有人会解释。 <br><blockquote>  283字节的只读代码存储器 <br>  1字节的只读数据存储器 <br>  24字节的读写数据存储器 </blockquote><br> 现在，在“媒介优化”和“瞧瞧”上也有同样的事情……我们在额头上获得的代码与C ++实现完全相同，而在C代码方面则更为优化。 <br><blockquote>  251个字节的只读代码存储器 <br>  1字节的只读数据存储器 <br>  8字节的读写数据存储器 </blockquote><br><div class="spoiler">  <b class="spoiler_title">组装工</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/y4/7w/l9/y47wl95frzmeyb2brdekbnvqvr8.png" alt="图片"><br></div></div><br> 如您所见，我赢了， <s>去了加那利群岛</s> ，很高兴在车里雅宾斯克休息:)，但是学生们也很棒，他们顺利通过了考试！ <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">谁在乎，代码在这里</a> <br><br> 好的，我在哪里可以使用它，例如，我们在EEPROM存储器中有参数，并描述了这些参数的类（读取，写入，初始化为初始值）。 该类是模板，例如<code>Param&lt;float&lt;&gt;&gt;</code>和<code>Param&lt;int&lt;&gt;&gt;</code> ，例如，您需要将所有参数重置为默认值。 由于类型不同，在这里可以将它们全部放入一个元组中，并在每个参数上调用<code>SetToDefault()</code>方法。 的确，如果有100个这样的参数，则ROM将吃很多，但RAM不会受到影响。 <br><br>  PS我必须承认，在最大程度地优化之后，此代码的大小与C和我的解决方案中的代码相同。 程序员改善代码的所有努力都归结为同一汇编代码。 <br><br>  P.S1谢谢<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" class="user_link">0xd34df00d</a>的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" class="user_link">良好</a>建议。 您可以使用<code>std::apply()</code>简化对元组的拆包。  <code>ToggleAll()</code>的功能代码然后简化为： <br><br><pre> <code class="cpp hljs"> __<span class="hljs-function"><span class="hljs-function">forceinline </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ToggleAll</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::apply([](<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span>... args) { (args.Toggle(), ...); }, records); }</code> </pre> <br> 不幸的是，在IAR中，当前版本尚未实现std :: apply，但它也可以正常工作，请参阅<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">std :: apply的实现</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN457246/">https://habr.com/ru/post/zh-CN457246/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN457224/index.html">Android中竞争的现代方法：Kotlin的Corotins</a></li>
<li><a href="../zh-CN457232/index.html">机器人“大黄蜂”-国际空间站内的首次试飞</a></li>
<li><a href="../zh-CN457234/index.html">产品认知偏差</a></li>
<li><a href="../zh-CN457236/index.html">IT公司如何努力销售音乐</a></li>
<li><a href="../zh-CN457240/index.html">本周新闻：神经网络和拍照图像，Yandex股份的增长，华为需要10亿美元的专利</a></li>
<li><a href="../zh-CN457248/index.html">车床的JavaScript编程</a></li>
<li><a href="../zh-CN457250/index.html">Vue.js的黑暗日子</a></li>
<li><a href="../zh-CN457254/index.html">303号移动开发人员的有趣材料摘要（6月17日至23日）</a></li>
<li><a href="../zh-CN457256/index.html">互联网历史记录：ARPANET-软件包</a></li>
<li><a href="../zh-CN457258/index.html">海盗湾有15年了，无法杀死</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>