<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üö£üèΩ üòã üßúüèª Escalamiento extremo en Alibaba JDK üìù üï∫üèø üÜö</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Muchos sospechan de la posibilidad de bifurcar y escribir algo por su cuenta. A menudo el precio es demasiado alto. Es especialmente extra√±o escuchar ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Escalamiento extremo en Alibaba JDK</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/jugru/blog/436266/"><p>  Muchos sospechan de la posibilidad de bifurcar y escribir algo por su cuenta.  A menudo el precio es demasiado alto.  Es especialmente extra√±o escuchar acerca de sus propios JDK, que supuestamente se encuentran en todas las empresas bastante grandes.  ¬øQu√© demonios est√°n furiosos con la grasa?  Este art√≠culo ser√° una historia detallada sobre la compa√±√≠a, que todo esto trae beneficios comerciales reales y que hizo un trabajo terrible, porque ellos: </p><br><ul><li>  Desarroll√≥ una m√°quina Java virtual multiinquilino; </li><li>  Se les ocurri√≥ un mecanismo para la operaci√≥n de objetos que no llevan sobrecarga a la recolecci√≥n de basura; </li><li>  Hicieron algo como la contraparte ReadyNow de Azul Zing; </li><li>  Ba√±aron sus propias corutinas con rendimientos y continuaciones (e incluso est√°n listas para compartir su experiencia con Loom, sobre la que <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">escrib√≠ en oto√±o</a> ); </li><li>  Se atornillaron a todos estos milagros su propio subsistema de diagn√≥stico. </li></ul><br><p> Como siempre, el video, el descifrado de texto completo y las diapositivas lo esperan debajo del corte.  ¬°Bienvenido al infierno de una de las √°reas m√°s dif√≠ciles de adaptaci√≥n de proyectos de c√≥digo abierto! </p><br><p><img src="https://habrastorage.org/webt/dk/gg/wt/dkggwtykndi-ewrxf_6ajxec7ts.png"></p><br><p>  <strong>Doctor, ¬øde d√≥nde sacas esas fotos?</strong>  O'Reilly Covers Corner: el fondo de KDPV es proporcionado por Joshua Newton y representa la Danza Sagrada <em>Sangyang Jaran</em> en Ubud, Indonesia.  Este es un espect√°culo cl√°sico balin√©s compuesto de danza de fuego y trance.  Un hombre con tacones desnudos se mueve alrededor de una hoguera, criado en c√°scaras de coco, empujando cosas con los pies y bailando en estado de trance bajo la influencia de un esp√≠ritu de caballo.  Ilustraci√≥n perfecta para tu propio JDK, ¬øverdad? </p><a name="habracut"></a><br><iframe width="560" height="315" src="https://www.youtube.com/embed/94eTZsNYYBE" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Diapositivas y una descripci√≥n del informe</a> (no las necesita, este habratopike tiene todo lo que necesita). </p><br><hr><br><p>  Hola, mi nombre es Sanhong Lee, trabajo en Alibaba y me gustar√≠a hablar sobre los cambios que hicimos en OpenJDK para las necesidades de nuestro negocio.  La publicaci√≥n consta de tres partes.  En el primero hablar√© sobre c√≥mo se usa Java en Alibaba.  La segunda parte, en mi opini√≥n, es la m√°s importante: en ella discutiremos c√≥mo configuramos OpenJDK para las necesidades de nuestro negocio.  La tercera parte tratar√° sobre las herramientas que creamos para el diagn√≥stico. </p><br><p>  Pero antes de pasar a la primera parte, me gustar√≠a contarles brevemente sobre nuestra empresa. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/2e2/20c/776/2e220c776112b1cf5e66b102559a39a5.jpg"></p><br><p>  El diagrama muestra la estructura interna de Alibaba.  Se compone de varias empresas cuya especializaci√≥n principal es la organizaci√≥n del mercado electr√≥nico y la provisi√≥n de plataformas financieras y log√≠sticas.  Creo que la mayor√≠a de la gente en Rusia est√° familiarizada con AliExpress.  Alibaba tiene un equipo dedicado de programadores que desarrollan y dan soporte a toda la pila distribuida, brindando servicio a clientes de Aliexpress en todo el mundo. </p><br><p>  Para tener una idea de la escala del trabajo de Alibaba, veamos qu√© sucede en China <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">el D√≠a de los Solteros</a> .  Se celebra todos los a√±os el 11 de noviembre, y en este d√≠a la gente compra especialmente muchos productos a trav√©s de Alibaba.  Por lo que s√©, de las vacaciones en todo el mundo, esta es la mayor cantidad de compras. <br></p><p><img src="https://habrastorage.org/getpro/habr/post_images/e31/55e/b62/e3155eb62e307c57535b1479351f41ad.jpg"></p><br><p>  En la imagen de arriba, ve un diagrama que muestra la carga en nuestro sistema de soporte.  La l√≠nea roja muestra el trabajo de nuestro servicio de pedidos y muestra el n√∫mero m√°ximo de transacciones por segundo, el a√±o pasado ascendi√≥ a 325 mil.  La l√≠nea azul se refiere al servicio de pago, y ella tiene esta cifra de 256 mil.  Me gustar√≠a hablar sobre c√≥mo optimizar la pila que sirve tantas transacciones. </p><br><p>  Analicemos las principales tecnolog√≠as que funcionan en Alibaba con Java.  En primer lugar, debo decir que tenemos una serie de aplicaciones de c√≥digo abierto como base.  Para el procesamiento de big data utilizamos HBase Hadoop.  Como contenedor utilizamos Tomcat y OSGi.  Java se utiliza en una escala colosal: millones de instancias de JVM se implementan en nuestro centro de datos.  Tambi√©n debo decir que nuestra arquitectura est√° orientada a servicios, es decir, creamos muchos servicios que se comunican entre s√≠ mediante llamadas RPC.  Finalmente, nuestra arquitectura es heterog√©nea.  Para mejorar el rendimiento, muchos algoritmos se escriben utilizando bibliotecas C y C ++, por lo que se comunican con Java mediante llamadas JNI. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/f99/614/041/f99614041cb58edab73a43dea38fdda9.jpg"></p><br><p>  La historia de nuestro trabajo con OpenJDK comenz√≥ en 2011, durante OpenJDK 6. Hay tres razones importantes por las que elegimos OpenJDK.  Primero, podemos cambiar directamente su c√≥digo de acuerdo con las necesidades del negocio.  En segundo lugar, cuando surgen problemas urgentes, podemos resolverlos por nuestra cuenta m√°s r√°pido que esperar el lanzamiento oficial.  Esto es vital para nuestro negocio.  En tercer lugar, nuestros desarrolladores de Java utilizan nuestras propias herramientas para la depuraci√≥n y el diagn√≥stico r√°pidos y de alta calidad. </p><br><p>  Antes de pasar a cuestiones t√©cnicas, quiero enumerar las principales dificultades que tenemos que superar.  En primer lugar, hemos lanzado una gran cantidad de instancias de JVM; en esta situaci√≥n, la cuesti√≥n de reducir los costos de hardware es un problema grave.  En segundo lugar, ya he dicho que atendemos una gran cantidad de transacciones.  Gracias al recolector de basura, Java nos promete "memoria infinita".  Adem√°s, gana en rendimiento a bajo nivel gracias al compilador JIT.  Pero esto tambi√©n tiene un lado negativo: un tiempo m√°s largo para detener el mundo para la recolecci√≥n de basura.  Adem√°s, Java necesita ciclos de CPU adicionales para compilar m√©todos Java.  Esto significa que los compiladores compiten por los ciclos de CPU.  Ambos problemas empeoran a medida que la aplicaci√≥n se vuelve m√°s compleja. </p><br><p>  La tercera dificultad es que tenemos muchas aplicaciones en ejecuci√≥n.  Creo que todos aqu√≠ est√°n familiarizados con las herramientas que vienen con OpenJDK, como JConsole o VisualVM.  El problema es que no nos dan la informaci√≥n exacta que necesitamos para configurar.  Adem√°s, cuando usamos estas herramientas (por ejemplo, JConsole o VisualVM) en producci√≥n, una baja sobrecarga no es solo un deseo, sino un requisito necesario.  Tuve que escribir mis propias herramientas de diagn√≥stico. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/ec5/da9/bcb/ec5da9bcb1620f073d5aed05aaba76aa.jpg"></p><br><p>  La imagen describe los cambios que realizamos en OpenJDK.  Echemos un vistazo a c√≥mo superamos las dificultades de las que habl√© anteriormente. </p><br><h1>  JVM multiempresa </h1><br><p>  Una soluci√≥n que llamamos JVM multiinquilino.  Le permite ejecutar de forma segura m√∫ltiples aplicaciones web en un contenedor.  Otra soluci√≥n se llama GCIH (GC Invisible Heap).  Este es un mecanismo que le proporciona objetos Java completos que no requieren el costo de la recolecci√≥n de basura.  Adem√°s, para reducir los costos de los contextos de subprocesos, implementamos corutinas en nuestra plataforma Java.  Adem√°s, escribimos un mecanismo llamado JWarmup: su funci√≥n es muy similar a ReadyNow.  Douglas Hawkins parece haberlo mencionado <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">en su informe</a> .  Finalmente, desarrollamos nuestra propia herramienta de creaci√≥n de perfiles, ZProfiler. </p><br><p>  Echemos un vistazo m√°s de cerca a c√≥mo implementamos la tenencia m√∫ltiple basada en OpenJDK. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/133/d4b/f5f/133d4bf5f82bfa3f7a7df9abb0e59afa.jpg"></p><br><p>  Eche un vistazo a la imagen de arriba: creo que la mayor√≠a de ustedes est√° familiarizada con este patr√≥n.  Compare el enfoque tradicional con el multiinquilino.  Si su aplicaci√≥n se ejecuta con Apache Tomcat, tambi√©n puede ejecutar varias instancias en el mismo contenedor.  Pero Tomcat no proporciona un consumo estable de recursos para cada uno de ellos.  Digamos, si una de las aplicaciones en ejecuci√≥n necesita m√°s tiempo de CPU que la otra, ¬øc√≥mo va a controlar la asignaci√≥n de tiempo de CPU?  ¬øC√≥mo asegurar que esta aplicaci√≥n no afecte el trabajo de otros?  Fue principalmente esta pregunta la que nos hizo recurrir a la tecnolog√≠a multiempresa. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/e7f/77e/add/e7f77eadd29a6dbe8ea8ffc0cc1ec8ae.jpg"></p><br><p>  La imagen muestra esquem√°ticamente c√≥mo lo implementamos.  Creamos varios contenedores para inquilinos dentro de la JVM.  Cada uno de estos contenedores proporciona un control confiable del consumo de recursos para cada m√≥dulo Java.  Se pueden implementar m√∫ltiples m√≥dulos en un contenedor.  Cada m√≥dulo se puede asociar con un hilo o un grupo de hilos en tiempo de ejecuci√≥n. </p><br><p>  Echemos un vistazo a c√≥mo se ve la API del contenedor de inquilinos.  Tenemos una clase de configuraci√≥n de inquilinos que almacena informaci√≥n sobre el consumo de recursos.  A continuaci√≥n, hay una clase del contenedor en s√≠. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/f3c/95e/27d/f3c95e27dbc40c2bb216b70f7521b270.jpg"></p><br><p>  En el fragmento de c√≥digo presentado, creamos un inquilino y luego indicamos cu√°nto tiempo se le proporciona la CPU y la memoria.  El primer indicador es un n√∫mero entero, lo que significa la parte del tiempo de CPU disponible para el inquilino, en este caso indicamos 512. Utilizamos un enfoque muy similar en el caso de cgroups, me detendr√© en esto con m√°s detalle.  La segunda m√©trica es el tama√±o de almacenamiento din√°mico m√°ximo que pueden usar los inquilinos. </p><br><p> Considere c√≥mo un inquilino interact√∫a con un hilo.  La clase <code>TenantContainer</code> proporciona el m√©todo <code>.run()</code> , y cuando un hilo lo ingresa, se une autom√°ticamente al inquilino, y cuando lo abandona, se produce el procedimiento inverso.  Entonces todo el c√≥digo se ejecuta dentro del m√©todo <code>.run()</code> .  Adem√°s, cualquier subproceso creado dentro del m√©todo <code>.run()</code> se adjunta al inquilino del subproceso principal. </p><br><p>  Llegamos a una pregunta muy importante: ¬øc√≥mo se gestiona la CPU en una JVM multiinquilino?  Nuestra soluci√≥n acaba de implementarse en la plataforma Linux x64.  Existe un mecanismo de grupo de control, cgroups.  Le permite seleccionar un proceso en un grupo separado y luego indicar su modo de consumo de recursos para cada grupo.  Intentemos transferir este enfoque al contexto de la JVM Hotspot.  En Hotstpot, los hilos de Java se organizan como hilos nativos. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/fbb/093/2d4/fbb0932d4d1dbc6ef982c17dcac8bebb.jpg"></p><br><p>  Esto se muestra en el diagrama anterior: cada hilo de Java est√° en una correspondencia uno a uno con el hilo nativo.  En nuestro ejemplo, tenemos un contenedor <code>TenantA</code> , en el que hay dos hilos nativos.  Para poder controlar la distribuci√≥n del tiempo de CPU, colocamos ambos hilos nativos en un grupo de control.  Debido a esto, podemos regular el consumo de recursos, confiando √∫nicamente en la funcionalidad de [grupos de control] ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="></a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">https://en.wikipedia.org/wiki/Cgroups</a> ). </p><br><p>  Echemos un vistazo a un ejemplo m√°s detallado. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/6ac/6c8/6bc/6ac6c86bc668c785c1dd92ee13547e2a.jpg"></p><br><p>  Los grupos de control en Linux se asignan a un directorio.  En nuestro ejemplo, creamos el directorio <code>/t0</code> para el inquilino 0. Este directorio contiene el directorio <code>/t0/tasks</code> , todos los hilos para <code>t0</code> se <code>t0</code> aqu√≠.  Otro archivo importante es <code>/t0/cpu.shares</code> .  Indica cu√°nto tiempo se le dar√° la CPU a este inquilino.  Toda esta estructura se hereda de los grupos de control: simplemente garantizamos una correspondencia directa entre el hilo de Java, el hilo nativo y el grupo de control. </p><br><p>  Otra cuesti√≥n importante se relaciona con la gesti√≥n de un grupo de cada inquilino. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/b3a/570/b4e/b3a570b4ece66bcabd3bfa9d5071e553.jpg"></p><br><p>  En la imagen puede ver un diagrama de c√≥mo se implementa.  Nuestro enfoque se basa en el G1GC.  En la parte inferior de la imagen, G1GC divide el mont√≥n en secciones del mismo tama√±o.  En base a ellos, creamos Contextos de asignaci√≥n de inquilinos, TAC, con los cuales el inquilino administra su secci√≥n de mont√≥n.  A trav√©s de TAC, limitamos el tama√±o de la porci√≥n del mont√≥n disponible para el inquilino.  Aqu√≠, se aplica el principio, seg√∫n el cual cada secci√≥n del mont√≥n contiene objetos de un solo inquilino.  Para implementarlo, necesit√°bamos hacer cambios en el proceso de copiar un objeto durante la recolecci√≥n de basura: era necesario asegurarse de que el objeto se copiara en la secci√≥n correcta del mont√≥n. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/ae8/195/7c8/ae81957c8027d99056a66648472f9674.jpg"></p><br><p>  Esquem√°ticamente, este proceso se representa en el diagrama anterior.  Como dije, nuestra implementaci√≥n se basa en G1GC.  G1GC es un recolector de basura de copia, por lo que durante la recolecci√≥n de basura debemos asegurarnos de que el objeto se copie en la secci√≥n correcta del mont√≥n.  En la diapositiva, todos los objetos creados por <code>Tenant-1</code> deben copiarse en su parte del mont√≥n, de forma similar a <code>Tenant-2</code> . </p><br><p>  Hay otras consideraciones que surgen cuando los inquilinos est√°n aislados unos de otros.  Aqu√≠ debo decir sobre TLAB (Thread Local Allocation Buffer), un mecanismo para la asignaci√≥n r√°pida de memoria.  El espacio TLAB depende de la secci√≥n del mont√≥n.  Como dije, diferentes inquilinos tienen diferentes grupos de secciones de mont√≥n. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/0c9/0b4/1e7/0c90b41e753761f3a2e294ccef6e6591.jpg"></p><br><p>  Los detalles de trabajar con TLAB se muestran en la diapositiva: cuando el subproceso cambia de <code>Tenant 1</code> a <code>Tenant 2</code> , debemos asegurarnos de que se use la secci√≥n de mont√≥n correcta para el espacio TLAB.  Esto se puede lograr de dos maneras.  La primera forma es cuando el <code>Thread A</code> cambia del <code>Tenant 1</code> al <code>Tenant 2</code> , simplemente nos deshacemos del anterior y creamos uno nuevo en el <code>Tenant 2</code> .  Este m√©todo es relativamente f√°cil de implementar, pero desperdicia espacio en TLAB, lo que no es deseable.  La segunda forma es m√°s complicada: hacer que TLAB conozca a los inquilinos.  Esto significa que tendremos varios b√∫feres TLAB para un hilo.  Cuando el <code>Thread A</code> cambia del <code>Tenant 1</code> al <code>Tenant 2</code> , debemos cambiar el b√∫fer y usar el que se cre√≥ en el <code>Tenant 2</code> . </p><br><p>  Otro mecanismo que debe decirse en relaci√≥n con la delimitaci√≥n de los inquilinos es IHOP (Porcentaje de ocupaci√≥n de subprocesos iniciadores).  Inicialmente, IHOP se calcul√≥ sobre la base de todo el mont√≥n, pero en el caso de un mecanismo de m√∫ltiples inquilinos, se debe calcular sobre la base de solo una secci√≥n del mont√≥n. </p><br><p>  Echemos un vistazo m√°s de cerca a lo que es GCIH (GC Invisible Heap).  Este mecanismo crea una secci√≥n en el mont√≥n, oculta al recolector de basura y, en consecuencia, no se ve afectada por la recolecci√≥n de basura.  Este sitio es administrado por el inquilino de GCIH. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/00a/fc1/843/00afc1843cc320ee600a80892f0c4940.jpg"></p><br><p>  Es importante decir aqu√≠ que proporcionamos una API p√∫blica a nuestros desarrolladores de Java.  Un ejemplo de trabajar con √©l se puede ver en la pantalla.  Permite usar el m√©todo <code>moveIn()</code> para mover objetos de un mont√≥n regular a una parte del mont√≥n GCIH.  Su ventaja es que a√∫n puede interactuar con estos objetos como con los objetos normales de Java, son muy similares en estructura.  Pero al mismo tiempo no requieren el costo de la recolecci√≥n de basura.  La conclusi√≥n, en mi opini√≥n, es que si desea acelerar la recolecci√≥n de basura, debe personalizar el comportamiento del recolector de basura de acuerdo con las necesidades de su aplicaci√≥n. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/af0/c7d/bb3/af0c7dbb3eca6dd45ecc10f52247e369.jpg"></p><br><p>  La imagen muestra un esquema GCIH de alto nivel.  A la derecha hay un mont√≥n de Java normal, a la izquierda est√° el espacio asignado para GCIH.  Los enlaces de un mont√≥n regular a objetos en GCIH son v√°lidos, pero los enlaces de GCIH a un mont√≥n regular no lo son.  Para entender por qu√© es as√≠, considere un ejemplo.  Tenemos el objeto "A" en GCIH, que contiene una referencia al objeto "B" en un mont√≥n normal.  El problema es que el objeto B puede ser movido por el recolector de basura.  Como ya dije, no hacemos actualizaciones en GCIH, por lo que despu√©s de que el recolector de basura funciona, el objeto "A" puede contener una referencia no v√°lida al objeto "B".  Este problema se puede resolver utilizando la barrera previa a la escritura; se discutieron en un informe anterior.  Como ejemplo, supongamos que alguien necesita guardar un enlace de un mont√≥n de Java normal a GCIH antes de que el guardado que asumimos resultar√≠a en una excepci√≥n de predicci√≥n con un indicador de que se viol√≥ la regla. </p><br><p>  Para una aplicaci√≥n espec√≠fica, se utiliza una JVM multiinquilino en nuestra Plataforma de personalizaci√≥n de Taobao, abreviado TPP.  Este es un sistema de recomendaci√≥n para nuestra aplicaci√≥n de compras electr√≥nicas.  TPP puede implementar varios microservicios en un contenedor, y con la ayuda de la JVM multiinquilino controlamos la memoria y el tiempo de CPU proporcionado a cada microservicio. </p><br><p>  En cuanto a GCIH, se usa en nuestro otro sistema, la Plataforma UM.  Esta es una aplicaci√≥n de descuento en l√≠nea.  El propietario de esta aplicaci√≥n utiliza GCIH para almacenar en cach√© previamente los datos de GCIH en la m√°quina local, para no acceder a los objetos en el servidor de cach√© remoto o la base de datos remota.  Como resultado, facilitamos la carga en la red y realizamos menos serializaci√≥n y deserializaci√≥n. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/36d/707/20c/36d70720cd2b4465b4b32b01467fbe51.jpg"></p><br><p>  La imagen muestra un diagrama en el que el color azul muestra la carga cuando se usa un JDK convencional y el rojo - GCIH.  Como puede ver, estamos reduciendo la utilizaci√≥n de la CPU en m√°s del 18%. </p><br><p>  Hasta donde yo s√©, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">BellSoft</a> resolvi√≥ un problema similar, y su soluci√≥n fue similar a GCIH, pero utilizaron un enfoque diferente para reducir los costos de serializaci√≥n y deserializaci√≥n. </p><br><h1>  Corutinas en Java </h1><br><p>  Volvamos a Alibaba y veamos c√≥mo se pueden implementar las rutinas en Java.  Pero primero, hablemos sobre los or√≠genes, sobre por qu√© necesitamos hacer esto.  En Java, siempre fue muy f√°cil escribir aplicaciones de subprocesos m√∫ltiples.  Pero el problema con la creaci√≥n de tales aplicaciones es que, como dije, en Hotspot los hilos de Java ya est√°n implementados como hilos nativos.  Por lo tanto, cuando hay muchos hilos en su aplicaci√≥n, los costos de cambiar el contexto del hilo se vuelven muy altos. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/2c5/b79/4f1/2c5b794f12c5cfcc82fa893a82c7a92e.jpg"></p><br><p>  Considere un ejemplo en el que tendremos 4 hilos de E / S y 200 hilos con la l√≥gica de su aplicaci√≥n.  La tabla en la pantalla muestra los resultados de iniciar esta demostraci√≥n simple: puede ver cu√°nto tiempo tarda la CPU en cambiar los contextos.  La soluci√≥n a este problema puede ser la implementaci√≥n de corutina en Java. </p><br><p>  Para proporcionarlo, necesit√°bamos dos cosas.  Primero, Alibaba JDK necesitaba agregar soporte de continuaci√≥n.  Este trabajo se bas√≥ en el parche JKU, nos detendremos en √©l con m√°s detalle.  En segundo lugar, agregamos un programador de modo de usuario que ser√° responsable de la continuaci√≥n del hilo.  En tercer lugar, hay muchas aplicaciones en Alibaba.  Por lo tanto, nuestra soluci√≥n es muy importante para nuestros desarrolladores de Java, y fue necesario que sea absolutamente transparente para ellos.  Y esto significa que en nuestra aplicaci√≥n comercial no deber√≠a haber pr√°cticamente cambios en el c√≥digo.  Llamamos a nuestra soluci√≥n Wisp.  Nuestra implementaci√≥n de corutinas en Java se usa ampliamente en Alibaba, por lo que puede considerarse comprobado que funciona en Java.  Llegar a conocerlo con m√°s detalle. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/5af/7af/0c2/5af7af0c2075b299ef7152bd8cff94fe.jpg"></p><br><p>  Comencemos con el ejemplo, cuyo c√≥digo se presenta anteriormente: esta es una aplicaci√≥n Java completamente normal.  Primero, se crea un grupo de subprocesos.  Luego se crea otra tarea Runnable que acepta el socket.  Despu√©s de eso, se realiza la lectura de la secuencia.  A continuaci√≥n, creamos otra tarea Runnable, con la que nos conectamos al servidor y, finalmente, escribimos datos en la transmisi√≥n.  Como puede ver, todo parece bastante est√°ndar.  Si ejecuta el c√≥digo en un JDK normal, cada una de estas tareas Ejecutables se ejecutar√° en un hilo separado.  Pero en nuestra decisi√≥n, la mec√°nica ser√° completamente diferente. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/a06/f12/716/a06f12716380d6e3447ac9de3784c37c.jpg"></p><br><p>  Como puede ver en el volcado del hilo que se muestra en la diapositiva, creamos dos corutinas en un hilo, y no dos hilos.  Ahora necesita hacer que esta soluci√≥n funcione.  Lo principal aqu√≠ es hacer que la generaci√≥n de eventos fondee en todos los puntos de bloqueo posibles.  En nuestro ejemplo, estos puntos ser√°n <code>serverSocket.accept()</code> , <code>is.read(buf)</code> , una conexi√≥n de socket y <code>os.write(buf)</code> .  Gracias a los eventos de rendimiento en estos puntos, podremos transferir el control de una corutina a otra dentro del mismo hilo.  En resumen, nuestro enfoque es que logramos un rendimiento asincr√≥nico usando la rutina, pero nuestros programadores pueden escribir c√≥digo en un estilo sincr√≥nico, ya que dicho c√≥digo es mucho m√°s simple y f√°cil de mantener y depurar. </p><br><p>  Veamos exactamente c√≥mo proporcionamos soporte de continuaci√≥n en Alibaba JDK.  Como dije, este trabajo se basa en un proyecto de m√°quina virtual multiling√ºe creado por la comunidad, es de dominio p√∫blico.  Utilizamos este parche en Alibaba JDK y solucionamos algunos errores que ocurr√≠an en nuestro entorno de producci√≥n. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/5e3/580/3bd/5e35803bda5ad8ae70b35f3fd5fd4771.jpg"></p><br><p>  Como puede ver en el diagrama, aqu√≠ en un hilo puede haber varias corutinas, y para cada una se crea una pila separada.  Adem√°s, el parche del que habl√© nos proporciona la API m√°s importante aqu√≠: yieldTo, con la ayuda de la cual el control se transfiere de una rutina a otra. </p><br><p>  Pasemos a c√≥mo implementamos el programador de modo de usuario para la rutina.  Usamos un selector, y con √©l registramos varios canales.  Cuando ocurre cualquier evento de E / S (lectura de socket, escritura de socket, conexi√≥n de socket o aceptaci√≥n de socket), se escribe como una clave para el selector.  Por lo tanto, al final de este evento, recibimos una alerta del selector.  Por lo tanto, usamos un selector para planificar corutinas en caso de un bloqueo de E / S.  Considere un ejemplo de c√≥mo funcionar√° esto. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/a32/45d/f81/a3245df8176dc1c23d810413ff1f1031.jpg"></p><br><p>  En la imagen vemos el socket y la llamada s√≠ncrona <code>client.read(buffer)</code> .  En la parte inferior de la diapositiva, se escribe un c√≥digo que se ejecutar√° dentro de esta llamada.  Primero, verifica si es posible leer desde el canal o no.  Si es as√≠, entonces devolvemos el resultado.  Lo m√°s interesante sucede si no se puede leer.  Luego registramos el evento de lectura en nuestro planificador con selector.  Esto hace posible planificar la ejecuci√≥n de cualquier otra rutina.  Echa un vistazo a c√≥mo sucede esto.  Tenemos un hilo en el que se crea un planificador.  El hilo y nuestra rutina est√°n en correspondencia uno a uno entre s√≠.  Sheduler nos permite gestionar las rutinas de este hilo.  ¬øQu√© sucede si se bloquea la E / S?  Cuando ocurren eventos de E / S, el programador recibe una alerta y, en esta situaci√≥n, depende completamente del selector.  Despu√©s de tal evento, el planificador tiene la oportunidad de planificar la pr√≥xima rutina disponible. </p><br><p>  Resumamos la descripci√≥n general de nuestro programador, al que llamamos WispEngine.  Para cada uno de nuestros hilos, asignamos un WispEngine separado.  Cuando ocurre un bloqueo de rutina, registramos ciertos eventos (lectura / escritura de socket, etc.) usando WispEngine.  Algunos eventos est√°n relacionados con el estacionamiento de subprocesos, por ejemplo, si llama a <code>thread.sleep()</code> con un retraso de 100 milisegundos.  En este caso, se generar√° un evento de estacionamiento de subprocesos para usted, que luego se registrar√° en el selector.  Otra cuesti√≥n importante es cuando el programador designa la siguiente rutina disponible.  Hay dos condiciones principales.  La primera es cuando se generan ciertos eventos, como eventos de E / S o eventos de tiempo de espera.  Aqu√≠ todo es bastante simple: suponga que realiza una llamada a <code>thread.sleep()</code> con un retraso de 200 milisegundos.  Cuando caducan, el planificador tiene la oportunidad de ejecutar la siguiente rutina disponible.  O aqu√≠ podemos hablar sobre algunos eventos de desempaque que se generan, por ejemplo, llamando a <code>object.notify()</code> u <code>object.notifyAll()</code> La segunda condici√≥n es cuando el usuario env√≠a nuevas solicitudes, y creamos una rutina para atender estas solicitudes, y luego el programador asigna su implementaci√≥n </p><br><p>  Aqu√≠ tambi√©n debe decir sobre el servicio que creamos, WispThreadExecutor. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/5a5/ddc/881/5a5ddc88194e0794593506627f420915.jpg"></p><br><p>  En la pantalla se presenta un c√≥digo de ejemplo, y vemos que se trata de un ExecutorService normal, creado de la misma manera.  Los <code>.execute()</code> y <code>submit()</code> est√°n disponibles para las tareas Runnable, pero el problema es que todas las tareas Runnable que pasan por el m√©todo <code>submit()</code> se ejecutar√°n en corutin, y no en el hilo.  Esta soluci√≥n es completamente transparente para aquellos que implementar√°n nuestra aplicaci√≥n, podr√°n usar nuestra API para las rutinas. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/2b5/e03/041/2b5e03041077b86eb3b4438a5d286813.jpg"></p><br><p>  Llegu√© a la √∫ltima parte dif√≠cil de la publicaci√≥n: c√≥mo resolver el problema de la sincronizaci√≥n en las rutinas.  Esta es una pregunta compleja, as√≠ que ve√°mosla con un ejemplo simplificado.  Aqu√≠ tenemos la corutina A ( <code>test::foo</code> ) y la corutina <code></code> ( <code>test::bar</code> ).  Primero, asignamos la ejecuci√≥n de <code>test:foo</code> a la corutina <code></code>  Corutin <code></code> llama a <code>wait()</code> .  Si no se hace nada, la llamada a <code>wait()</code> bloquear√° el hilo actual.  Como se puede ver en este volcado del subproceso, se producir√° un punto muerto y no podremos programar la ejecuci√≥n de la siguiente corutina. </p><br><p>  ¬øC√≥mo resolver este problema?  Hotspot proporciona tres tipos de cerraduras.  El primero es el bloqueo r√°pido.  Aqu√≠, el propietario del bloqueo est√° determinado por la direcci√≥n en la pila.  Como dije, cada una de nuestras corutinas tiene una pila separada.  Por lo tanto, en el caso de bloqueo r√°pido, no necesitamos hacer ning√∫n trabajo adicional.  No hay soporte similar para el bloqueo sesgado en nuestro sistema.  Lo probamos en nuestra producci√≥n y result√≥ que, en ausencia de un bloqueo sesgado, el rendimiento no disminuye.  Para nosotros es bastante adecuado. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/1a9/051/bd1/1a9051bd163c97d904d6a4bd13afb188.jpg"></p><br><p>  Hablemos de un caso m√°s complicado: bloqueo inflado.  Veamos nuevamente el ejemplo que cit√© anteriormente.  Tenemos Corutin <code></code> ( <code>.foo()</code> ) y Corutin <code>B</code> ( <code>.bar()</code> ).  Primero, asignamos la ejecuci√≥n de la rutina <code></code> y la iniciamos.  Luego llama a <code>Object.wait</code> , despu√©s de lo cual <code>Object.wait</code> en la lista de espera.  Despu√©s de eso, damos un paso muy importante: generamos el evento <code>yieldTo</code> , que transfiere el control al hilo principal.  A continuaci√≥n, comenzamos Corutin <code>B</code>  Llama a <code>Object.notify</code> y se <code>unpark</code> eventos de no <code>unpark</code> correspondientes.  Eventualmente despertar√°n la corutina <code></code>  Una vez completada la ejecuci√≥n de <code>bar()</code> , ser√° posible transferir el control a la rutina <code></code>  Por lo tanto, el punto muerto que mencion√© anteriormente est√° completamente superado. </p><br><p>  Discutamos el rendimiento ahora.  Usamos corutinas en una de nuestras aplicaciones en l√≠nea de Carros.  Sobre esta base, podemos comparar el trabajo de la corutina con el trabajo de un JDK normal. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/022/52c/c95/02252cc950a2ad902d2feb29f4129249.jpg"></p><br><p>  Como puede ver, nos permiten reducir el consumo de tiempo del procesador en casi un 10%.  Entiendo que la mayor√≠a de ustedes probablemente no tengan la capacidad de realizar directamente cambios tan complejos en el c√≥digo JDK.  Pero la conclusi√≥n principal aqu√≠, en mi opini√≥n, es que si las p√©rdidas de rendimiento cuestan dinero y la cantidad resultante es lo suficientemente grande, puede intentar mejorar el rendimiento utilizando la biblioteca de rutina. </p><br><h1>  Jarmarm </h1><br><p>  Pasemos a nuestra otra herramienta: JWarmup.  Es muy similar a otra herramienta, ReadyNow.  Como sabemos, en Java hay un problema de calentamiento: el compilador en esta etapa requiere ciclos de CPU adicionales.  Esto nos caus√≥ problemas, por ejemplo, se produjo un error TimeOut.  Al escalar, estos problemas solo empeoran, y en nuestro caso estamos hablando de una aplicaci√≥n muy compleja: m√°s de 20 mil clases y m√°s de 50 mil m√©todos. </p><br><p>  Antes de comenzar a usar JWarmup, los propietarios de nuestra aplicaci√≥n usaban datos simulados para calentar.  En estos datos, el compilador JIT precompilado antes de recibir las solicitudes.  Pero los datos simulados son diferentes de los reales; por lo tanto, no son representativos para el compilador.  En algunos casos, se produjo una desoptimizaci√≥n inesperada, el rendimiento sufri√≥.  La soluci√≥n a este problema fue JWarmup.  Tiene dos etapas principales de trabajo: grabaci√≥n y compilaci√≥n.  Alibaba tiene dos tipos de entornos, beta y producci√≥n.  Ambos reciben solicitudes reales de los usuarios, despu√©s de lo cual se implementa la misma versi√≥n de la aplicaci√≥n en estos dos entornos.  En el entorno beta, solo se recopilan datos de creaci√≥n de perfiles, sobre la base de los cuales se realiza una compilaci√≥n preliminar en la producci√≥n. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/5e4/aec/01c/5e4aec01c9cece135daff42490463627.jpg"></p><br><p>  Veamos con m√°s detalle qu√© tipo de informaci√≥n recopilamos.  Necesitamos escribir exactamente qu√© clases se inicializan, qu√© m√©todos se compilan, luego estos datos se env√≠an al registro en el disco duro, que es accesible para el compilador.  El momento m√°s dif√≠cil es la inicializaci√≥n de las clases.       .     ‚Äî   <code>Bar</code>     <code>Foo.test()</code> ,    <code>foo.count</code> .        ,      . </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/3f9/1fa/cfe/3f91facfe6c55e70cad3bebe147d17ff.jpg"></p><br><p>      JWarmup    (tiered compilation),     .     ,    ‚Äî  CPU.     JWarmup    ,      CPU,   JDK.  ,       ,           JDK. ,             ,     . </p><br><p>       JWarmup.     ,     , ,  groovy-,    Java-,  .     .  ,     ,  ¬´null check elimination¬ª.         . ,    JWarmup    ,       JWarmup,   . </p><br><h1>   </h1><br><p>      ,     Alibaba. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/ef5/7c9/4b0/ef57c94b07c6f3335e44d9b7baa360b9.jpg"></p><br><p>    .    JVM ‚Äî  ,    ,     .       Java-, metaspace,  VM (     VM)     JIT-.        OpenJDK. -,          ,       . -,        .   HotMethodProfiling,   ,       CPU.  ,      ,    <em>Honest Profiler</em> ,     ,      ,     HotMethodProfiling.    MethodTracing.           ,    ,     .  ,       metaspace   .          Java-,        .   metaspace  ,    .       Java. </p><br><p> ,      ,   ZProfiler. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/201/324/1fc/2013241fca408ec2cea997d466327a33.jpg"></p><br><p>       .      JVMTi,     JVM (  ).  ,    ZProfiler   Apache Tomcat.      -.    ZProfiler     JVM. ,  ZProfiler  -UI,     . ZProfiler    . -,      UI        JVM. -, ZProfiler  post-mortem . ,        OutOfMemoryError,       ,         JVM   ZProfiler,       .    ,    , , Eclipse MAT. </p><br><p>  .         .   JVM, GCIH,   Alibaba JDK,   JWarmup ‚Äî ,    ReadyNow   Zing JVM. ,    ZProfiler.      ,         ,      OpenJDK.      ,  ,    JWarmup  OpenJDK.  ,      OpenJDK   Loom,     Java.     ,   . </p><br><blockquote>  . ,     ,     JPoint  2018 .    2019 ,   JPoint   , 5-6 .      ,   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="> </a>     Rafael Winterhalter  Sebastian Daschner.     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="> </a> .        ,   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">   YouTube</a> .   JPoint! </blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es436266/">https://habr.com/ru/post/es436266/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es436254/index.html">Un bot para Starcraft en Rust, C o cualquier otro idioma</a></li>
<li><a href="../es436256/index.html">Conseguir un trabajo en Alemania ser√° m√°s f√°cil</a></li>
<li><a href="../es436260/index.html">Errores y dificultades de las startups al patentar su IP</a></li>
<li><a href="../es436262/index.html">* La actualizaci√≥n de Ethereum "Constantinopla" se pospuso debido a una vulnerabilidad potencial encontrada en el √∫ltimo momento</a></li>
<li><a href="../es436264/index.html">Mono-repositorios: por favor no (parte 2)</a></li>
<li><a href="../es436268/index.html">Recopilamos un mazo completo</a></li>
<li><a href="../es436270/index.html">El 35% de la audiencia de Runet no usa una computadora para Internet</a></li>
<li><a href="../es436272/index.html">Programaci√≥n visual para Sonoff Basic</a></li>
<li><a href="../es436274/index.html">Se est√° creando una aplicaci√≥n m√≥vil para el registro de accidentes en Rusia</a></li>
<li><a href="../es436276/index.html">Visualizaci√≥n tridimensional en simuladores de material rodante basados ‚Äã‚Äãen el motor OpenSceneGraph</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>