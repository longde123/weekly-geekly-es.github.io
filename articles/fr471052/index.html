<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë®‚Äçüé§ üìâ ‚úãüèΩ Puis-je Haz? Frapp√© par la programmation de type g√©n√©rique ü§º üàöÔ∏è üëßüèΩ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Salut, Habr. 


 La derni√®re fois, nous avons d√©crit Has pattern, d√©crit les probl√®mes qu'il r√©sout et √©crit quelques exemples sp√©cifiques: 


 instan...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Puis-je Haz? Frapp√© par la programmation de type g√©n√©rique</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/471052/"><p>  Salut, Habr. </p><br><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">La derni√®re fois,</a> nous avons d√©crit <code>Has</code> pattern, d√©crit les probl√®mes qu'il r√©sout et √©crit quelques exemples sp√©cifiques: </p><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">instance</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">HasDbConfig</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">AppConfig</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">where</span></span></span></span> getDbConfig = dbConfig <span class="hljs-keyword"><span class="hljs-keyword">instance</span></span> <span class="hljs-type"><span class="hljs-type">HasWebServerConfig</span></span> <span class="hljs-type"><span class="hljs-type">AppConfig</span></span> <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> getWebServerConfig = webServerConfig <span class="hljs-keyword"><span class="hljs-keyword">instance</span></span> <span class="hljs-type"><span class="hljs-type">HasCronConfig</span></span> <span class="hljs-type"><span class="hljs-type">AppConfig</span></span> <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> getCronConfig = cronConfig</code> </pre> <br><p>  √áa a l'air bien.  Quelles difficult√©s peuvent survenir ici? </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/821/f4f/397/821f4f397a69ccd020b677098f5ecaf7.jpg" alt="image"></p><br><p>  Eh bien, r√©fl√©chissons aux autres instances dont nous pourrions avoir besoin.  Tout d'abord, les types concrets avec une configuration en eux-m√™mes sont de bons candidats pour l'impl√©mentation (triviale) de ces classes de types, ce qui nous donne trois autres instances o√π chaque m√©thode est impl√©ment√©e via <code>id</code> , par exemple </p><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">instance</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">HasDbConfig</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">DbConfig</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">where</span></span></span></span> getDbConfig = id</code> </pre> <br><p>  Ils nous permettent d'√©crire facilement des tests individuels ou des utilitaires d'assistance qui sont ind√©pendants de l'ensemble d' <code>AppConfig</code> . </p><br><p>  C'est d√©j√† ennuyeux, mais cela continue.  Il est facile d'imaginer que certains tests d'int√©gration v√©rifient l'interaction d'une paire de modules, et nous ne voulons toujours pas d√©pendre de la configuration de l'application enti√®re, nous devons donc maintenant √©crire six instances (deux par type), chacune √©tant r√©duite √† <code>fst</code> ou <code>snd</code> .  Par exemple, pour <code>DbConfig</code> : </p><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">instance</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">HasDbConfig</span></span></span><span class="hljs-class"> (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">DbConfig</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">b</span></span></span><span class="hljs-class">) </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">where</span></span></span></span> getDbConfig = fst <span class="hljs-keyword"><span class="hljs-keyword">instance</span></span> <span class="hljs-type"><span class="hljs-type">HasDbConfig</span></span> (a, <span class="hljs-type"><span class="hljs-type">DbConfig</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> getDbConfig = snd</code> </pre> <br><p>  Horreur  On esp√®re que nous n'aurons jamais besoin de tester le fonctionnement de trois modules en m√™me temps - sinon vous devrez √©crire neuf instances ennuyeuses.  En tout cas, personnellement, je suis d√©j√† tr√®s mal √† l'aise, et je pr√©f√®re passer plusieurs heures √† automatiser cette affaire plut√¥t que quelques minutes pour √©crire une douzaine de lignes de code suppl√©mentaires. </p><br><p>  Si vous √™tes int√©ress√© par la fa√ßon de r√©soudre ce probl√®me de mani√®re g√©n√©rale, en outre, ce sont des types d√©pendants et comment tout cela finira par ressembler √† un chat Haskell - Welkom. </p><a name="habracut"></a><br><h1 id="obobschaem-has-klass">  R√©sumer la classe <code>Has</code> </h1><br><p>  Tout d'abord, notez que nous avons diff√©rentes classes pour diff√©rents environnements.  Cela peut interf√©rer avec la cr√©ation d'une solution universelle, nous pla√ßons donc l'environnement dans un param√®tre distinct: </p><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Has</span></span></span><span class="hljs-class"> part record </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">where</span></span></span></span> extract :: record -&gt; part</code> </pre> <br><p>  Nous pouvons dire que <code>Has part record</code> signifie qu'une valeur de type <code>part</code> peut √™tre extraite de la valeur de l' <code>record</code> de type.  En ces termes, notre bon vieux <code>HasDbConfig</code> devient <code>Has DbConfig</code> , et de m√™me pour les autres classes de types que nous avons √©crites plus t√¥t.  Cela s'av√®re presque un changement purement syntaxique, et, par exemple, le type de l'une des fonctions de notre post pr√©c√©dent </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">doSmthWithDbAndCron</span></span> :: (<span class="hljs-type"><span class="hljs-type">MonadReader</span></span> rm, <span class="hljs-type"><span class="hljs-type">HasDbConfig</span></span> r, <span class="hljs-type"><span class="hljs-type">HasCronConfig</span></span> r) =&gt; ...</code> </pre> <br><p>  dans </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">doSmthWithDbAndCron</span></span> :: (<span class="hljs-type"><span class="hljs-type">MonadReader</span></span> rm, <span class="hljs-type"><span class="hljs-type">Has</span></span> <span class="hljs-type"><span class="hljs-type">DbConfig</span></span> r, <span class="hljs-type"><span class="hljs-type">Has</span></span> <span class="hljs-type"><span class="hljs-type">CronConfig</span></span> r) =&gt; ...</code> </pre> <br><p>  Le seul changement est un couple d'espaces aux bons endroits. </p><br><p>  De plus, nous n'avons pas beaucoup perdu dans l'inf√©rence de type: un temporisateur peut toujours produire la valeur de retour d' <code>extract</code> n√©cessaire dans le contexte environnant dans la grande majorit√© des cas rencontr√©s en pratique. </p><br><p>  Maintenant que nous ne nous soucions plus du type d'environnement sp√©cifique, voyons quels enregistrements peuvent impl√©menter la classe d' <code>Has part record</code> pour la <code>part</code> fixe.  Cette t√¢che a une bonne structure inductive: </p><br><ol><li>  Chaque type a lui-m√™me: <code>Has record record</code> est impl√©ment√© de mani√®re triviale ( <code>extract = id</code> ). </li><li>  Si l' <code>record</code> est un produit des types <code>rec1</code> et <code>rec2</code> , alors <code>Has part record</code> est impl√©ment√© si et seulement si <code>Has part rec1</code> ou <code>Has part rec2</code> . </li><li>  Si <code>record</code> est la somme des types <code>rec1</code> et <code>rec2</code> , alors la <code>Has part record</code> est impl√©ment√©e si et seulement si la <code>Has part rec1</code> et la <code>Has part rec2</code> .  Bien que la pr√©valence pratique de ce cas dans ce contexte ne soit pas √©vidente, elle m√©rite tout de m√™me d'√™tre mentionn√©e pour √™tre compl√®te. </li></ol><br><p>  Il semble donc que nous ayons formul√© une esquisse d'un algorithme pour d√©terminer automatiquement si un <code>Has part record</code> est impl√©ment√© pour les donn√©es de <code>part</code> et d' <code>record</code> ! </p><br><p>  Heureusement, un tel raisonnement inductif sur les types s'int√®gre tr√®s bien au m√©canisme Haskell <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Generics</a> .  En bref et simplifiant, Generics est l'une des m√©thodes de m√©taprogrammation g√©n√©ralis√©e dans le Haskell, r√©sultant de l'observation que chaque type est soit un type de somme, un type de produit ou un type de base √† construction unique avec un champ. </p><br><p>  Je n'√©crirai pas <em>un autre</em> tutoriel sur les g√©n√©riques, alors passez simplement au code. </p><br><h1 id="pervaya-popytka">  Premi√®re tentative </h1><br><p>  Nous utiliserons la m√©thode classique d'impl√©mentation <code>Generic</code> de nos <code>Has</code> travers la classe auxiliaire <code>GHas</code> : </p><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">GHas</span></span></span><span class="hljs-class"> part grecord </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">where</span></span></span></span> gextract :: grecord p -&gt; part</code> </pre> <br><p>  Ici <code>grecord</code> est une repr√©sentation <code>Generic</code> de notre type d' <code>record</code> . </p><br><p>  <code>GHas</code> impl√©mentations de <code>GHas</code> suivent la structure inductive que nous avons not√©e ci-dessus: </p><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">instance</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">GHas</span></span></span><span class="hljs-class"> record (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">K1</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">i</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">record</span></span></span><span class="hljs-class">) </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">where</span></span></span></span> gextract (<span class="hljs-type"><span class="hljs-type">K1</span></span> x) = x <span class="hljs-keyword"><span class="hljs-keyword">instance</span></span> <span class="hljs-type"><span class="hljs-type">GHas</span></span> part record =&gt; <span class="hljs-type"><span class="hljs-type">GHas</span></span> part (<span class="hljs-type"><span class="hljs-type">M1</span></span> it record) <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> gextract (<span class="hljs-type"><span class="hljs-type">M1</span></span> x) = gextract x <span class="hljs-keyword"><span class="hljs-keyword">instance</span></span> <span class="hljs-type"><span class="hljs-type">GHas</span></span> part l =&gt; <span class="hljs-type"><span class="hljs-type">GHas</span></span> part (l :*: r) <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> gextract (l :*: _) = gextract l <span class="hljs-keyword"><span class="hljs-keyword">instance</span></span> <span class="hljs-type"><span class="hljs-type">GHas</span></span> part r =&gt; <span class="hljs-type"><span class="hljs-type">GHas</span></span> part (l :*: r) <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> gextract (_ :*: r) = gextract r</code> </pre> <br><ol><li>  <code>K1</code> correspond au cas de base. </li><li>  <code>M1</code> - M√©tadonn√©es g√©n√©riques sp√©cifiques dont nous n'avons pas besoin dans notre t√¢che, nous les ignorons donc simplement et les parcourons. </li><li>  La premi√®re instance pour le type de produit <code>l :*: r</code> correspond au cas o√π la partie "gauche" du produit a la valeur de type dont nous avons besoin (√©ventuellement, r√©cursivement). </li><li>  De m√™me, la deuxi√®me instance pour le type de produit <code>l :*: r</code> correspond au cas o√π la partie "droite" du produit a la valeur souhait√©e de la <code>part</code> type (naturellement, aussi, √©ventuellement, r√©cursivement). </li></ol><br><p>  Nous ne prenons en charge que les types de produits ici.  Mon impression subjective est que les montants ne sont pas si souvent utilis√©s dans des contextes pour <code>MonadReader</code> et des classes similaires, ils peuvent donc √™tre n√©glig√©s pour simplifier la prise en compte. </p><br><p>  En outre, il est utile de noter que chaque <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-1-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>n</mi></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.395ex" height="1.455ex" viewBox="0 -520.7 600.5 626.5" role="img" focusable="false" style="vertical-align: -0.246ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/471052/&amp;usg=ALkJrhh4exHzBg0c6PpRlhgWOQmliS4Xaw#MJMATHI-6E" x="0" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>n</mi></math></span></span><script type="math/tex" id="MathJax-Element-1"> n </script>  -le type-produit <code>(a1, ..., an)</code> peut √™tre repr√©sent√© comme une composition <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-2-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>n</mi><mo>&amp;#x2212;</mo><mn>1</mn></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="5.398ex" height="2.057ex" viewBox="0 -728.2 2323.9 885.9" role="img" focusable="false" style="vertical-align: -0.366ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/471052/&amp;usg=ALkJrhh4exHzBg0c6PpRlhgWOQmliS4Xaw#MJMATHI-6E" x="0" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/471052/&amp;usg=ALkJrhh4exHzBg0c6PpRlhgWOQmliS4Xaw#MJMAIN-2212" x="822" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/471052/&amp;usg=ALkJrhh4exHzBg0c6PpRlhgWOQmliS4Xaw#MJMAIN-31" x="1823" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>n</mi><mo>‚àí</mo><mn>1</mn></math></span></span><script type="math/tex" id="MathJax-Element-2"> n-1 </script>  paires <code>(a1, (a2, (a3, (..., an))))</code> , donc je me permets d'associer des types de produits √† des paires. </p><br><p>  Avec nos <code>GHas</code> , vous pouvez √©crire une impl√©mentation par d√©faut pour <code>Has</code> qui utilise des g√©n√©riques: </p><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Has</span></span></span><span class="hljs-class"> part record </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">where</span></span></span></span> extract :: record -&gt; part <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> extract :: <span class="hljs-type"><span class="hljs-type">Generic</span></span> record =&gt; record -&gt; part extract = gextract . from</code> </pre> <br><p>  C'est fait. </p><br><p>  Ou pas? </p><br><h1 id="problema">  Le probl√®me </h1><br><p>  Si nous essayons de compiler ce code, nous verrons qu'il ne taypechaetsya m√™me sans aucune tentative d'utiliser cette impl√©mentation par d√©faut, en signalant quelques instances qui se chevauchent l√†-bas.  Pire, ces instances sont les m√™mes √† certains √©gards.  Il semble qu'il soit temps de comprendre comment fonctionne le m√©canisme de r√©solution des instances dans Haskell. </p><br><p>  Puissions-nous avoir </p><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">instance</span></span></span><span class="hljs-class"> context =&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Foo</span></span></span><span class="hljs-class"> barPattern bazPattern </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">where</span></span></span></span> ...</code> </pre> <br><p>  (Soit dit en passant, cette chose apr√®s <code>=&gt;</code> est appel√©e t√™te d'instance.) </p><br><p>  Il semble naturel de lire ceci comme </p><br><blockquote>  Laissez-nous choisir une instance pour <code>Foo bar baz</code> .  <em>Si le</em> <code>context</code> satisfait, vous pouvez s√©lectionner cette instance √† condition que <code>bar</code> et <code>baz</code> correspondent √† <code>barPattern</code> et <code>bazPattern</code> . </blockquote><p>  Cependant, c'est une mauvaise interpr√©tation, et juste le contraire: </p><br><blockquote>  Laissez-nous choisir une instance pour <code>Foo bar baz</code> .  <em>Si</em> <code>bar</code> et <code>baz</code> correspondent √† <code>barPattern</code> et <code>bazPattern</code> , nous s√©lectionnons cette instance et ajoutons du <code>context</code> √† la liste des constantes qui doivent √™tre r√©solues. </blockquote><p>  Maintenant, il est √©vident quel est le probl√®me.  Examinons de plus pr√®s la paire d'instances suivante: </p><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">instance</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">GHas</span></span></span><span class="hljs-class"> part l =&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">GHas</span></span></span><span class="hljs-class"> part (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">l</span></span></span><span class="hljs-class"> :*: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">r</span></span></span><span class="hljs-class">) </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">where</span></span></span></span> gextract (l :*: _) = gextract l <span class="hljs-keyword"><span class="hljs-keyword">instance</span></span> <span class="hljs-type"><span class="hljs-type">GHas</span></span> part r =&gt; <span class="hljs-type"><span class="hljs-type">GHas</span></span> part (l :*: r) <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> gextract (_ :*: r) = gextract r</code> </pre> <br><p>  Ils ont les m√™mes t√™tes d'instance, donc pas √©tonnant qu'ils se croisent!  De plus, aucun d'eux n'est plus sp√©cifique que l'autre. </p><br><p>  De plus, il n'y a aucun moyen d'affiner d'une mani√®re ou d'une autre ces instances afin qu'elles cessent de se chevaucher.  Eh bien, en plus d'ajouter plus de param√®tres <code>GHas</code> . </p><br><h1 id="vyrazitelnye-tipy-speshat-na-pomosch">  Les types expressifs se pr√©cipitent √† la rescousse! </h1><br><p>  La solution au probl√®me consiste √† pr√©-calculer le ¬´chemin¬ª vers la valeur qui nous int√©resse et √† utiliser ce chemin afin de guider le choix des instances. </p><br><p>  Puisque nous avons accept√© de ne pas prendre en charge les types de somme, un chemin est au sens litt√©ral une s√©quence de virages √† gauche ou √† droite dans les types de produits (c'est-√†-dire, les choix du premier ou du deuxi√®me composant d'une paire), se terminant par un grand pointeur ¬´ICI¬ª, d√®s que nous trouvons le type souhait√© .  Nous √©crivons ceci: </p><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Path</span></span></span><span class="hljs-class"> = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">L</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Path</span></span></span><span class="hljs-class"> | </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">R</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Path</span></span></span><span class="hljs-class"> | </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Here</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">deriving</span></span></span><span class="hljs-class"> (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Show</span></span></span><span class="hljs-class">)</span></span></code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Par exemple</b> <div class="spoiler_text"><p>  Consid√©rez les types suivants: </p><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">DbConfig</span></span></span><span class="hljs-class"> = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">DbConfig</span></span></span><span class="hljs-class"> { </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">dbAddress</span></span></span><span class="hljs-class"> :: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">DbAddress</span></span></span><span class="hljs-class"> , </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">dbUsername</span></span></span><span class="hljs-class"> :: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Username</span></span></span><span class="hljs-class"> , </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">dbPassword</span></span></span><span class="hljs-class"> :: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Password</span></span></span><span class="hljs-class"> } </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">AppConfig</span></span></span><span class="hljs-class"> = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">AppConfig</span></span></span><span class="hljs-class"> { </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">dbConfig</span></span></span><span class="hljs-class"> :: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">DbConfig</span></span></span><span class="hljs-class"> , </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">webServerConfig</span></span></span><span class="hljs-class"> :: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">WebServerConfig</span></span></span><span class="hljs-class"> , </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">cronConfig</span></span></span><span class="hljs-class"> :: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">CronConfig</span></span></span><span class="hljs-class"> }</span></span></code> </pre> <br><p>  Quels sont quelques exemples de chemins depuis <code>AppConfig</code> ? </p><br><ol><li>  Pour <code>DbConfig</code> ‚ü∂ <code>L Here</code> . </li><li>  Vers WebServerConfig ‚ü∂ <code>R (L Here)</code> . </li><li>  Vers <code>CronConfig</code> ‚ü∂ <code>R (R Here)</code> . </li><li>  √Ä <code>DbAddress</code> ‚ü∂ <code>L (L Here)</code> . </li></ol></div></div><br><p>  Quel pourrait √™tre le r√©sultat d'une recherche d'une valeur du type souhait√©?  Deux options sont √©videntes: nous pouvons le trouver ou ne pas le trouver.  Mais en fait, tout est un peu plus compliqu√©: on peut trouver plus d'une valeur de ce type.  Apparemment, le comportement le plus sens√© dans ce cas controvers√© serait √©galement un message d'erreur.  Tout choix d'une valeur particuli√®re aura un certain caract√®re al√©atoire. </p><br><p>  En effet, consid√©rons notre exemple de service Web standard.  Si quelqu'un veut obtenir une valeur de type <code>(Host, Port)</code> , doit-il s'agir de l'adresse du serveur de base de donn√©es ou de l'adresse du serveur Web?  Il vaut mieux ne pas le risquer. </p><br><p>  Dans tous les cas, exprimons cela en code: </p><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">MaybePath</span></span></span><span class="hljs-class"> = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">NotFound</span></span></span><span class="hljs-class"> | </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Conflict</span></span></span><span class="hljs-class"> | </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Found</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Path</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">deriving</span></span></span><span class="hljs-class"> (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Show</span></span></span><span class="hljs-class">)</span></span></code> </pre> <br><p>  Nous s√©parons <code>NotFound</code> et <code>Conflict</code> , car le traitement de ces cas est fondamentalement diff√©rent: si nous obtenons <code>NotFound</code> dans l'une des branches de notre type de produit, il ne sera pas difficile de trouver la valeur souhait√©e dans une autre branche, tandis que <code>Conflict</code> dans n'importe quelle branche signifie imm√©diatement complet un √©chec. </p><br><p>  Nous consid√©rons maintenant un cas particulier de types de produits (que, comme nous l'avons convenu, nous consid√©rons comme des paires).  Comment y trouver la valeur du type souhait√©?  Vous pouvez ex√©cuter une recherche r√©cursivement dans chaque composant d'une paire, obtenir les r√©sultats <code>p1</code> et <code>p2</code> respectivement, puis les combiner d'une mani√®re ou d'une autre. </p><br><p>  √âtant donn√© que nous parlons du choix des instances de classes temporelles qui se produisent lors de la compilation, nous avons en fait besoin de calculs de compilation, qui sont exprim√©s dans le Haskell par le biais de calculs sur les types (m√™me si les types sont repr√©sent√©s par des termes soulev√©s dans l'univers √† l'aide de <code>DataKinds</code> ).  En cons√©quence, une telle fonction sur les types est repr√©sent√©e comme une famille de types: </p><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">family</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Combine</span></span></span><span class="hljs-class"> p1 p2 where </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Combine</span></span></span><span class="hljs-class"> ('</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Found</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">path</span></span></span><span class="hljs-class">) '</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">NotFound</span></span></span><span class="hljs-class"> = '</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Found</span></span></span><span class="hljs-class"> ('</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">L</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">path</span></span></span><span class="hljs-class">) </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Combine</span></span></span><span class="hljs-class"> '</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">NotFound</span></span></span><span class="hljs-class"> ('</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Found</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">path</span></span></span><span class="hljs-class">) = '</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Found</span></span></span><span class="hljs-class"> ('</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">R</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">path</span></span></span><span class="hljs-class">) </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Combine</span></span></span><span class="hljs-class"> '</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">NotFound</span></span></span><span class="hljs-class"> '</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">NotFound</span></span></span><span class="hljs-class"> = '</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">NotFound</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Combine</span></span></span><span class="hljs-class"> _ _ = '</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Conflict</span></span></span></span></code> </pre> <br><p>  Cette fonction repr√©sente plusieurs cas: </p><br><ol><li>  Si l'une des recherches r√©cursives r√©ussit et que l'autre <code>NotFound</code> √† <code>NotFound</code> , nous prenons le chemin de la recherche r√©ussie et ajoutons le virage dans la bonne direction. </li><li>  Si les deux recherches r√©cursives se terminent avec <code>NotFound</code> , alors bien <code>NotFound</code> , la recherche enti√®re se termine avec <code>NotFound</code> . </li><li>  Dans tous les autres cas, nous obtenons <code>Conflict</code> . </li></ol><br><p>  Nous allons maintenant √©crire une fonction au niveau de la pointe qui prend la <code>part</code> √† trouver, et une repr√©sentation <code>Generic</code> du type dans lequel trouver la <code>part</code> , et recherche: </p><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">family</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Search</span></span></span><span class="hljs-class"> part (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">grecord</span></span></span><span class="hljs-class"> :: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">k</span></span></span><span class="hljs-class"> -&gt; *) :: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">MaybePath</span></span></span><span class="hljs-class"> where </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Search</span></span></span><span class="hljs-class"> part (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">K1</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">_</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">part</span></span></span><span class="hljs-class">) = '</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Found</span></span></span><span class="hljs-class"> '</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Here</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Search</span></span></span><span class="hljs-class"> part (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">K1</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">_</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">other</span></span></span><span class="hljs-class">) = '</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">NotFound</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Search</span></span></span><span class="hljs-class"> part (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">M1</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">_</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">_</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">x</span></span></span><span class="hljs-class">) = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Search</span></span></span><span class="hljs-class"> part x </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Search</span></span></span><span class="hljs-class"> part (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">l</span></span></span><span class="hljs-class"> :*: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">r</span></span></span><span class="hljs-class">) = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Combine</span></span></span><span class="hljs-class"> (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Search</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">part</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">l</span></span></span><span class="hljs-class">) (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Search</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">part</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">r</span></span></span><span class="hljs-class">) </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Search</span></span></span><span class="hljs-class"> _ _ = '</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">NotFound</span></span></span></span></code> </pre> <br><p>  Notez que nous avons obtenu quelque chose de tr√®s similaire dans notre sens √† notre pr√©c√©dente tentative avec <code>GHas</code> .  C'est √† pr√©voir, car nous reproduisons en fait l'algorithme que nous avons essay√© d'exprimer √† travers les timeclasses. </p><br><p>  <code>GHas</code> , il ne nous reste plus qu'√† ajouter un param√®tre suppl√©mentaire √† cette classe, qui est responsable du chemin trouv√© pr√©c√©demment, et qui servira √† s√©lectionner des instances sp√©cifiques: </p><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">GHas</span></span></span><span class="hljs-class"> (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">path</span></span></span><span class="hljs-class"> :: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Path</span></span></span><span class="hljs-class">) part grecord </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">where</span></span></span></span> gextract :: <span class="hljs-type"><span class="hljs-type">Proxy</span></span> path -&gt; grecord p -&gt; part</code> </pre> <br><p>  Nous avons √©galement ajout√© un argument suppl√©mentaire pour <code>gextract</code> afin que le compilateur puisse s√©lectionner l'instance correcte pour le chemin donn√© (qui doit √™tre mentionn√© dans la signature de fonction pour cela). </p><br><p>  Maintenant, √©crire des instances est assez simple: </p><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">instance</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">GHas</span></span></span><span class="hljs-class"> '</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Here</span></span></span><span class="hljs-class"> record (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">K1</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">i</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">record</span></span></span><span class="hljs-class">) </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">where</span></span></span></span> gextract _ (<span class="hljs-type"><span class="hljs-type">K1</span></span> x) = x <span class="hljs-keyword"><span class="hljs-keyword">instance</span></span> <span class="hljs-type"><span class="hljs-type">GHas</span></span> path part record =&gt; <span class="hljs-type"><span class="hljs-type">GHas</span></span> path part (<span class="hljs-type"><span class="hljs-type">M1</span></span> it record) <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> gextract proxy (<span class="hljs-type"><span class="hljs-type">M1</span></span> x) = gextract proxy x <span class="hljs-keyword"><span class="hljs-keyword">instance</span></span> <span class="hljs-type"><span class="hljs-type">GHas</span></span> path part l =&gt; <span class="hljs-type"><span class="hljs-type">GHas</span></span> ('<span class="hljs-type"><span class="hljs-type">L</span></span> path) part (l :*: r) <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> gextract _ (l :*: _) = gextract (<span class="hljs-type"><span class="hljs-type">Proxy</span></span> :: <span class="hljs-type"><span class="hljs-type">Proxy</span></span> path) l <span class="hljs-keyword"><span class="hljs-keyword">instance</span></span> <span class="hljs-type"><span class="hljs-type">GHas</span></span> path part r =&gt; <span class="hljs-type"><span class="hljs-type">GHas</span></span> ('<span class="hljs-type"><span class="hljs-type">R</span></span> path) part (l :*: r) <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> gextract _ (_ :*: r) = gextract (<span class="hljs-type"><span class="hljs-type">Proxy</span></span> :: <span class="hljs-type"><span class="hljs-type">Proxy</span></span> path) r</code> </pre> <br><p>  En effet, nous s√©lectionnons simplement l'instance souhait√©e en fonction du chemin dans le <code>path</code> que nous avons calcul√© pr√©c√©demment. </p><br><p>  Comment √©crire maintenant notre impl√©mentation <code>default</code> de la fonction <code>extract :: record -&gt; part</code> dans la classe <code>Has</code> ?  Nous avons plusieurs conditions: </p><br><ol><li>  <code>record</code> doit impl√©menter <code>Generic</code> pour que le m√©canisme g√©n√©rique puisse √™tre appliqu√©, nous obtenons donc un <code>Generic record</code> . </li><li>  La fonction de <code>Search</code> doit trouver une <code>part</code> dans l' <code>record</code> (ou plut√¥t, dans la repr√©sentation <code>Generic</code> de l' <code>record</code> , qui est exprim√©e comme <code>Rep record</code> ).  Dans le code, cela semble un peu plus inhabituel: <code>Search part (Rep record) ~ 'Found path</code> .  Cet enregistrement signifie la restriction que le r√©sultat de la <code>Search part (Rep record)</code> doit √™tre √©gal au <code>'Found path</code> pour un certain <code>path</code> (qui, en fait, nous int√©resse). </li><li>  Nous devrions √™tre en mesure d'utiliser <code>GHas</code> avec <code>part</code> , la repr√©sentation g√©n√©rique de l' <code>record</code> et du <code>path</code> de la derni√®re √©tape, qui se transforme en une <code>GHas path part (Rep record)</code> . </li></ol><br><p>  Nous rencontrerons les deux derni√®res constantes plusieurs fois, il est donc utile de les mettre dans un synonyme de const distinct: </p><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">SuccessfulSearch</span></span></span><span class="hljs-class"> part record path = (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Search</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">part</span></span></span><span class="hljs-class"> (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Rep</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">record</span></span></span><span class="hljs-class">) ~ '</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Found</span></span></span><span class="hljs-class"> path, </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">GHas</span></span></span><span class="hljs-class"> path part (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Rep</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">record</span></span></span><span class="hljs-class">))</span></span></code> </pre> <br><p>  √âtant donn√© ce synonyme, nous obtenons </p><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Has</span></span></span><span class="hljs-class"> part record </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">where</span></span></span></span> extract :: record -&gt; part <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> extract :: forall path. (<span class="hljs-type"><span class="hljs-type">Generic</span></span> <span class="hljs-title"><span class="hljs-title">record</span></span>, <span class="hljs-type"><span class="hljs-type">SuccessfulSearch</span></span> <span class="hljs-title"><span class="hljs-title">part</span></span> <span class="hljs-title"><span class="hljs-title">record</span></span> <span class="hljs-title"><span class="hljs-title">path</span></span>) =&gt; record -&gt; part extract = gextract (<span class="hljs-type"><span class="hljs-type">Proxy</span></span> :: <span class="hljs-type"><span class="hljs-type">Proxy</span></span> <span class="hljs-title"><span class="hljs-title">path</span></span>) . from</code> </pre> <br><p>  Maintenant tout! </p><br><h1 id="ispolzovanie-obobschyonnogo-has">  Utilisation de Generic <code>Has</code> </h1><br><p>  Pour voir tout cela en action, nous allons √©crire quelques exemples g√©n√©raux pour les nuls: </p><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">instance</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">SuccessfulSearch</span></span></span><span class="hljs-class"> a (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a0</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a1</span></span></span><span class="hljs-class">) path =&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Has</span></span></span><span class="hljs-class"> a (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a0</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a1</span></span></span><span class="hljs-class">) </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">instance</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">SuccessfulSearch</span></span></span><span class="hljs-class"> a (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a0</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a1</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a2</span></span></span><span class="hljs-class">) path =&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Has</span></span></span><span class="hljs-class"> a (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a0</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a1</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a2</span></span></span><span class="hljs-class">) </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">instance</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">SuccessfulSearch</span></span></span><span class="hljs-class"> a (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a0</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a1</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a2</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a3</span></span></span><span class="hljs-class">) path =&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Has</span></span></span><span class="hljs-class"> a (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a0</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a1</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a2</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a3</span></span></span><span class="hljs-class">)</span></span></code> </pre> <br><p>  Ici, <code>SuccessfulSearch a (a0, ..., an) path</code> est responsable du fait que <code>a</code> se produit parmi <code>a0, ..., an</code> exactement une fois. </p><br><p>  Puissions-nous maintenant avoir notre bon vieux </p><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">AppConfig</span></span></span><span class="hljs-class"> = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">AppConfig</span></span></span><span class="hljs-class"> { </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">dbConfig</span></span></span><span class="hljs-class"> :: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">DbConfig</span></span></span><span class="hljs-class"> , </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">webServerConfig</span></span></span><span class="hljs-class"> :: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">WebServerConfig</span></span></span><span class="hljs-class"> , </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">cronConfig</span></span></span><span class="hljs-class"> :: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">CronConfig</span></span></span><span class="hljs-class"> }</span></span></code> </pre> <br><p>  et nous voulons sortir <code>Has DbConfig</code> , <code>Has WebServerConfig</code> et <code>Has CronConfig</code> .  Il suffit d'inclure les <code>DeriveAnyClass</code> <code>DeriveGeneric</code> et <code>DeriveAnyClass</code> et d'ajouter la d√©claration de <code>deriving</code> correcte: </p><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">AppConfig</span></span></span><span class="hljs-class"> = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">AppConfig</span></span></span><span class="hljs-class"> { </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">dbConfig</span></span></span><span class="hljs-class"> :: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">DbConfig</span></span></span><span class="hljs-class"> , </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">webServerConfig</span></span></span><span class="hljs-class"> :: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">WebServerConfig</span></span></span><span class="hljs-class"> , </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">cronConfig</span></span></span><span class="hljs-class"> :: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">CronConfig</span></span></span><span class="hljs-class"> } </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">deriving</span></span></span><span class="hljs-class"> (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Generic</span></span></span><span class="hljs-class">, </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Has</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">DbConfig</span></span></span><span class="hljs-class">, </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Has</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">WebServerConfig</span></span></span><span class="hljs-class">, </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Has</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">CronConfig</span></span></span><span class="hljs-class">)</span></span></code> </pre> <br><p>  Nous avons la chance (ou nous avons √©t√© assez perspicaces) d'organiser les arguments pour <code>Has</code> afin que le nom du type imbriqu√© vienne en premier, afin que nous puissions compter sur le m√©canisme <code>DeriveAnyClass</code> pour minimiser le gribouillage. </p><br><h2 id="bezopasnost-prevyshe-vsego">  La s√©curit√© passe avant tout </h2><br><p>  Et si nous n‚Äôavons aucun type? </p><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">AppConfig</span></span></span><span class="hljs-class"> = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">AppConfig</span></span></span><span class="hljs-class"> { </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">dbConfig</span></span></span><span class="hljs-class"> :: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">DbConfig</span></span></span><span class="hljs-class"> , </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">webServerConfig</span></span></span><span class="hljs-class"> :: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">WebServerConfig</span></span></span><span class="hljs-class"> } </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">deriving</span></span></span><span class="hljs-class"> (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Generic</span></span></span><span class="hljs-class">, </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Has</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">CronConfig</span></span></span><span class="hljs-class">)</span></span></code> </pre> <br><p>  Non, nous obtenons une erreur juste au point de d√©finition du type: </p><br><pre> <code class="plaintext hljs">Spec.hs:35:24: error: ‚Ä¢ Couldn't match type ''NotFound' with ''Found path0' arising from the 'deriving' clause of a data type declaration ‚Ä¢ When deriving the instance for (Has CronConfig AppConfig) | 35 | } deriving (Generic, Has CronConfig) | ^^^^^^^^^^^^^^</code> </pre> <br><p>  Ce n'est pas le message d'erreur le plus convivial, mais m√™me √† partir de celui-ci, vous pouvez toujours comprendre quel est le probl√®me: la fr√©quence impaire <code>NotFound</code> fr√©quence impaire <code>CronConfig</code> . </p><br><p>  Et si nous avons plusieurs champs du m√™me type? </p><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">AppConfig</span></span></span><span class="hljs-class"> = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">AppConfig</span></span></span><span class="hljs-class"> { </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">prodDbConfig</span></span></span><span class="hljs-class"> :: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">DbConfig</span></span></span><span class="hljs-class"> , </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">qaDbConfig</span></span></span><span class="hljs-class"> :: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">DbConfig</span></span></span><span class="hljs-class"> , </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">webServerConfig</span></span></span><span class="hljs-class"> :: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">WebServerConfig</span></span></span><span class="hljs-class"> , </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">cronConfig</span></span></span><span class="hljs-class"> :: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">CronConfig</span></span></span><span class="hljs-class"> } </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">deriving</span></span></span><span class="hljs-class"> (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Generic</span></span></span><span class="hljs-class">, </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Has</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">DbConfig</span></span></span><span class="hljs-class">)</span></span></code> </pre> <br><p>  Non, comme pr√©vu: </p><br><pre> <code class="plaintext hljs">Spec.hs:37:24: error: ‚Ä¢ Couldn't match type ''Conflict' with ''Found path0' arising from the 'deriving' clause of a data type declaration ‚Ä¢ When deriving the instance for (Has DbConfig AppConfig) | 37 | } deriving (Generic, Has DbConfig) | ^^^^^^^^^^^^</code> </pre> <br><p>  Tout semble vraiment bien. </p><br><h1 id="podytozhivaya">  Pour r√©sumer </h1><br><p>  Nous allons donc essayer de formuler bri√®vement la m√©thode propos√©e. </p><br><p>  Supposons que nous ayons une sorte de typklass, et que nous voulons afficher automatiquement ses instances selon certaines r√®gles r√©cursives.  Ensuite, nous pouvons √©viter les ambigu√Øt√©s (et exprimer g√©n√©ralement ces r√®gles si elles ne sont pas triviales et ne correspondent pas au m√©canisme standard de r√©solution des instances) comme suit: </p><br><ol><li>  Nous codons des r√®gles r√©cursives sous la forme d'un type de donn√©es inductif <code>T</code> </li><li>  Nous allons √©crire une fonction sur les types (sous forme de famille de types) pour le calcul pr√©liminaire de la valeur <code>v</code> ce type <code>T</code> (ou, en termes de Haskell, le type <code>v</code> type <code>T</code> - o√π sont mes types d√©pendants), qui d√©crit la s√©quence sp√©cifique d'√©tapes qui doivent √™tre prises. </li><li>  Utilisez ce <code>v</code> comme argument suppl√©mentaire √† l'aide <code>Generic</code> pour d√©terminer la s√©quence sp√©cifique d'instances qui correspondent d√©sormais aux valeurs de <code>v</code> . </li></ol><br><p>  Eh bien, c'est tout! </p><br><p>  Dans les articles suivants, nous examinerons quelques extensions √©l√©gantes (ainsi que des limitations √©l√©gantes) de cette approche. </p><br><p>  Oh, et oui.  Il est int√©ressant de suivre la s√©quence de nos g√©n√©ralisations. </p><br><ol><li>  Commenc√© avec <code>Env -&gt; Foo</code> . </li><li>  Pas assez g√©n√©ral, enveloppez-vous dans la monade <code>Reader Env</code> . </li><li>  Pas assez g√©n√©ral, r√©√©crivez avec le <code>MonadReader Env m</code> . </li><li>  Pas assez g√©n√©ral, r√©√©crivez <code>MonadReader rm, HasEnv r</code> . </li><li>  Pas assez g√©n√©ral, √©crivons <code>MonadReader rm, Has Env r</code> et ajoutons des g√©n√©riques pour que le compilateur fasse tout. </li><li>  Maintenant la norme. </li></ol></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr471052/">https://habr.com/ru/post/fr471052/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr471042/index.html">R√©solution de probl√®mes avec pwnable.kr 25 - otp. Limite de taille de fichier Linux</a></li>
<li><a href="../fr471044/index.html">Sass MediaScreen - D√©finition des p√©riph√©riques CSS</a></li>
<li><a href="../fr471046/index.html">Avalonia √©l√©gant</a></li>
<li><a href="../fr471048/index.html">React + Mobx: √† quoi √ßa sert?</a></li>
<li><a href="../fr471050/index.html">D Financement du Fonds de d√©veloppement linguistique: nouvelles plateformes et nouvelles subventions ...</a></li>
<li><a href="../fr471054/index.html">Longrid sur le r√©alisme de la menace quantique pour les crypto-monnaies et les probl√®mes de la "proph√©tie 2027"</a></li>
<li><a href="../fr471062/index.html">Comment apprendre √† Alice √† g√©rer votre maison intelligente. Rapport Yandex</a></li>
<li><a href="../fr471066/index.html">√Ä quoi ressemble l'archive zip et que pouvons-nous faire √† ce sujet</a></li>
<li><a href="../fr471070/index.html">Quelle langue de serveur choisir ... pour un d√©veloppeur mobile</a></li>
<li><a href="../fr471072/index.html">Combien de grammes en t√©l√©gramme?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>