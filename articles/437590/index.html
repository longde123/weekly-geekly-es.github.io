<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë®üèΩ‚Äçüíº üì∑ ü§≤üèΩ N√∫meros de latencia en iPhone üë©üèæ‚Äç‚öïÔ∏è ‚ôÄÔ∏è üèæ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="N√∫meros de latencia que todo programador debe saber : una tabla de "demoras que todo programador debe saber". Contiene los valores promedio de tiempo ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>N√∫meros de latencia en iPhone</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/oleg-bunin/blog/437590/">  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">N√∫meros de latencia que todo programador debe saber</a> : una tabla de "demoras que todo programador debe saber".  Contiene los valores promedio de tiempo para realizar operaciones inform√°ticas b√°sicas en 2012.  Hay varias vistas alternativas para esta tabla, y aqu√≠ est√° una de ellas. <br><br><img src="https://habrastorage.org/webt/oa/i4/ho/oai4hogxseqehs_ciso1lz9q_io.png"><br>  <i><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Enlace</a> al origen del esquema</i> <br><br>  ¬øPero cu√°l es el beneficio para los desarrolladores m√≥viles de esta informaci√≥n en 2019?  Parece que no, pero <b>Dmitry Kurkin</b> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" class="user_link">SClown</a> ) del equipo Yandex.Navigator pens√≥: "¬øC√≥mo ser√≠a la mesa para un iPhone moderno?"  Lo que surgi√≥ de esto, en una versi√≥n de texto revisada del informe de Dmitry en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">AppsConf</a> . <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/cyzo48f0exw" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><h2>  ¬øPara qu√© es esto? </h2><br>  ¬øPor qu√© los programadores deben saber estos n√∫meros?  ¬øY son relevantes para los desarrolladores m√≥viles?  Hay dos tareas principales que se pueden resolver con la ayuda de estos n√∫meros. <br><a name="habracut"></a><br><h3>  Comprender la escala de tiempo de una computadora </h3> <br>  Tome una situaci√≥n simple: una conversaci√≥n telef√≥nica.  Podemos decir f√°cilmente cu√°ndo este proceso es r√°pido y cu√°ndo es largo: un par de segundos es muy r√°pido, unos minutos es una conversaci√≥n promedio y una hora o m√°s es muy largo.  Con la carga de p√°ginas, es similar: en menos de un segundo, r√°pidamente, unos segundos, soportable, y un minuto es un desastre, el usuario puede no esperar la descarga. <br><br>  Pero, ¬øqu√© pasa con operaciones como agregar un n√∫mero a una matriz, la "inserci√≥n r√°pida" de la que a veces a la gente le gusta hablar en las entrevistas?  ¬øCu√°nto cuesta en un tel√©fono inteligente?  ¬øNanosegundos, microsegundos o milisegundos?  He conocido a pocas personas que podr√≠an decir que 1 milisegundo es mucho tiempo, pero en nuestro caso es as√≠. <br><br><h3>  La relaci√≥n de la velocidad de varios componentes de la computadora </h3><br>  El tiempo de ejecuci√≥n de las operaciones en varios dispositivos puede variar decenas o cientos de veces.  Por ejemplo, el tiempo de acceso a la memoria principal es 100 veces diferente al acceso al cach√© L1.  Esta es una gran diferencia, pero no infinita.  Si tenemos un significado espec√≠fico para esto, entonces, al optimizar nuestras aplicaciones, podemos evaluar si habr√° una ganancia de tiempo o no. <br><br><img src="https://habrastorage.org/webt/km/q5/ze/kmq5zekztqx_yhwcoyrjomhjcy4.png"><br><br><h2>  "N√∫meros de latencia" en la vida real </h2><br>  Cuando vi estos n√∫meros, me interes√≥ la diferencia entre el acceso a la memoria cach√© y la memoria.  Si pongo cuidadosamente mis datos en 64 Kbytes, que no es tan peque√±o, entonces mi c√≥digo funcionar√° 100 veces m√°s r√°pido: ¬°es r√°pido, todo volar√°! <br><br><img src="https://habrastorage.org/webt/-p/oh/fh/-pohfhloth8e4c-8sl2i5jdmbi4.png"><br><br>  Inmediatamente quise comprobarlo todo, mostr√°rselo a mis colegas y aplicarlo siempre que sea posible.  Decid√≠ comenzar con la herramienta est√°ndar que ofrece Apple: XCTest con measureBlock.  La prueba se organiz√≥ de la siguiente manera: asign√≥ una matriz, la llen√≥ de n√∫meros, su XOR'il y repiti√≥ el algoritmo 10 veces, seguro.  Despu√©s de eso, mir√© cu√°nto tiempo lleva un elemento. <br><br><table><tbody><tr><td>  <b>Tamp√≥n</b> </td><td>  <b>Tiempo total</b> </td><td>  <b>Tiempo para la cirug√≠a</b> </td></tr><tr><td>  50 kb </td><td>  1,5 ms </td><td>  30 ns </td></tr><tr><td>  500 kb </td><td>  12 ms </td><td>  24 ns </td></tr><tr><td>  5000 kb </td><td>  85 ms </td><td>  17 ns </td></tr></tbody></table><br>  El tama√±o del b√∫fer aument√≥ 100 veces, y el tiempo para la operaci√≥n no solo no aument√≥ 100 veces, sino que disminuy√≥ casi 2 veces.  <i>Se√±ores, oficiales, ¬ønos traicionaron?</i> <br><br>  Despu√©s de tal resultado, surgieron grandes dudas en m√≠ de que estos n√∫meros se pueden ver en la vida real.  Puede que no sea posible que una aplicaci√≥n regular detecte esta diferencia.  O tal vez en la plataforma m√≥vil todo es diferente. <br><br>  Comenc√© a buscar una manera de ver la diferencia en el rendimiento entre cach√©s y memoria principal.  Durante la b√∫squeda, me encontr√© con un art√≠culo en el que el autor se quejaba de que ten√≠a un punto de referencia en su Mac y iPhone y no mostraba estos retrasos.  Tom√© esta herramienta y obtuve el resultado, al igual que en una farmacia.  El tiempo de acceso a la memoria aument√≥ claramente cuando el tama√±o del b√∫fer excedi√≥ el tama√±o de la cach√© correspondiente. <br><br><img src="https://habrastorage.org/webt/he/_q/k8/he_qk85tbetz4emjxbp5znbqidc.png"><br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">LMbench</a> me ayud√≥ a obtener estos resultados.  Este es un punto de referencia creado por Larry McVoy, uno de los desarrolladores del kernel de Linux, que le permite medir el tiempo de acceso a la memoria, el costo de cambiar los hilos y las operaciones del sistema de archivos, e incluso el tiempo que toman las operaciones del procesador principal: suma, resta, etc. De acuerdo con este punto de referencia Texas Instruments present√≥ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">datos de</a> medici√≥n <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">interesantes</a> para sus procesadores.  LMBench est√° escrito en C, por lo que no fue dif√≠cil ejecutarlo en iOS. <br><br><h2>  Costos de memoria </h2><br>  Armado con una herramienta tan maravillosa, decid√≠ hacer mediciones similares, pero para un dispositivo m√≥vil real, para el iPhone.  Las mediciones principales se realizaron en el 5S, y luego obtuve los resultados cuando otros dispositivos cayeron en mis manos.  Por lo tanto, si el dispositivo no se especifica, entonces es 5S. <br><br><h3>  Acceso a la memoria </h3><br>  Para esta prueba, se utiliza una matriz especial, que se llena con elementos que se refieren entre s√≠.  Cada uno de los elementos es un puntero a otro elemento.  La matriz no est√° atravesada por √≠ndice, sino por transiciones de un nodo a otro.  Estos elementos est√°n dispersos en la matriz para que, al acceder a un nuevo elemento, con la mayor frecuencia posible no est√© en la memoria cach√©, sino que se descargue de la RAM.  Esta disposici√≥n interfiere con los cach√©s tanto como sea posible. <br><br>  Ya has visto el resultado preliminar.  En el caso de la cach√© L1, es inferior a 10 nanosegundos, para L2 es un par de decenas de nanosegundos, y en el caso de la memoria principal, el tiempo aumenta a cientos de nanosegundos. <br><br><img src="https://habrastorage.org/webt/6u/dk/f0/6udkf0ihlo3lgfqhntfkzp3vshm.png"><br><br><h3>  Leer y escribir velocidad </h3><br>  Se miden tres operaciones principales: <br><br><ul><li>  lectura ( <em>p [i] +</em> ): leemos los elementos y los sumamos a la cantidad total; </li><li>  record ( <em>p [i] = 1</em> ): se escribe un n√∫mero constante en cada elemento; </li><li>  lectura y escritura ( <em>p [i] = p [i] * 2</em> ): sacamos el elemento, lo cambiamos y escribimos el nuevo valor. </li></ul><br>  Cuando se trabaja con el b√∫fer, se usan 2 enfoques: en el primer caso, solo se usa cada cuarto elemento, y en el segundo, todos los elementos son secuencialmente. <br><br><img src="https://habrastorage.org/webt/yr/ke/ia/yrkeiaf0vzc47trw7wc_hypse-s.png"><br><br>  La velocidad m√°s alta se obtiene con un tama√±o de b√∫fer peque√±o, y luego hay pasos claros, de acuerdo con los tama√±os de los cach√©s L1 y L2.  Lo m√°s interesante es que cuando los datos se leen secuencialmente, no se produce una reducci√≥n de la velocidad.  Pero en el caso de los pases, los pasos claros son visibles. <br><br><img src="https://habrastorage.org/webt/2t/-d/_6/2t-d_68-oyjigkraj2mpirwjzfw.png"><br><br>  Durante la lectura secuencial, el sistema operativo logra cargar los datos necesarios en la memoria cach√©, por lo que para cualquier tama√±o de b√∫fer no necesito acceder a la memoria: todos los datos necesarios se obtienen de la memoria cach√©.  Esto explica por qu√© no vi la diferencia horaria en mi prueba b√°sica. <br><br>  Los resultados de las mediciones de las operaciones de lectura y escritura mostraron que en una aplicaci√≥n normal es bastante dif√≠cil obtener la aceleraci√≥n estimada de 100 veces.  Por un lado, el sistema en s√≠ almacena en cach√© los datos bastante bien, e incluso con matrices grandes es muy probable que encontremos datos en el cach√©.  Y, por otro lado, trabajar con varias variables puede requerir f√°cilmente acceso a la memoria y la p√©rdida de cientos de nanosegundos ganados. <br><br><table><tbody><tr><td></td><td>  <b>L1</b> </td><td>  <b>L2</b> </td><td>  <b>Memoria</b> </td></tr><tr><td>  N√∫meros de latencia </td><td>  1 ns </td><td>  7 ns </td><td>  100 ns </td></tr><tr><td>  iPhone 5s </td><td>  7 ns </td><td>  30 ns </td><td>  240 ns </td></tr><tr><td>  iPhone 6s Plus </td><td>  5 ns </td><td>  12 ns </td><td>  200 ns </td></tr><tr><td>  iPhone X </td><td>  2 ns </td><td>  12 ns </td><td>  146 ns </td></tr></tbody></table><br><h2>  Costes de subprocesos </h2><br>  A continuaci√≥n, quer√≠a obtener datos similares para trabajar con subprocesos para <strong>comprender el costo del uso de subprocesos m√∫ltiples</strong> : cu√°nto cuesta crear un subproceso y cambiar de un subproceso a otro.  Para nosotros, estas son operaciones frecuentes, y quiero entender la p√©rdida. <br><br><h3>  Instrumentos  Sistema de seguimiento </h3><br>  System Trace ayuda mucho a rastrear el trabajo de los hilos en la aplicaci√≥n.  Esta herramienta se describi√≥ con cierto detalle en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">WWDC 2016</a> .  La herramienta ayuda a ver las transiciones por condiciones de flujo y presenta datos en flujos en tres categor√≠as principales: llamadas al sistema, trabajo con memoria y condiciones de flujo. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/hs/gx/kq/hsgxkqsh5khfclg4gncfbksihya.png" width="500"></div><br><br><ol><li>  <strong>Sistema de llamadas</strong>  Se presentan en forma de "salchichas" rojas.  Cuando los se√±ala, puede ver el nombre del m√©todo del sistema y la duraci√≥n de la ejecuci√≥n.  A menudo, en aplicaciones de aplicaciones, tal llamada al sistema no ocurre directamente: usamos algo, que a su vez ya llama al m√©todo del sistema.  No debe confiar en el hecho de que aqu√≠ los m√©todos de su c√≥digo ser√°n visibles. </li><li>  <strong>Operaciones de memoria</strong> .  Se presentan en forma de "salchichas" azules.  Esto incluye operaciones como asignaci√≥n de memoria, liberaci√≥n, puesta a cero, etc. </li><li>  <strong>El estado de la corriente</strong> .  Color azul: se est√° ejecutando un subproceso, algunos procesadores est√°n ejecutando c√≥digo de este subproceso.  Gris: el subproceso est√° bloqueado por alg√∫n motivo y no puede continuar la ejecuci√≥n.  Rojo: el hilo est√° listo para funcionar, pero en este momento no hay un n√∫cleo libre para ejecutar su c√≥digo.  Color naranja: el flujo se interrumpe para trabajos de mayor prioridad. </li><li> <strong>Puntos de interes</strong> .  Estas son etiquetas especiales que se pueden organizar por c√≥digo llamando a <code>kdebug_signpost</code> .  Las etiquetas pueden ser simples (un lugar espec√≠fico en el c√≥digo) o como un rango (para resaltar todo el procedimiento).  Usando tales etiquetas, es mucho m√°s f√°cil correlacionar microsegundos y llamadas del sistema con su aplicaci√≥n. </li></ol><br><h3>  Costos de creaci√≥n de flujo </h3><br>  La primera prueba es la <strong>ejecuci√≥n de una tarea en un nuevo hilo</strong> .  Creamos un hilo con un determinado procedimiento y esperamos a que complete su trabajo.  Comparando el tiempo total con el tiempo del procedimiento en s√≠, obtenemos la p√©rdida total para comenzar el procedimiento en un nuevo hilo. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/m3/ln/wa/m3lnwaf0zdjx7b7suyujhp9eywu.png" width="600"></div><br><br>  En System Trace puede ver claramente c√≥mo sucede todo: <br><br><img src="https://habrastorage.org/webt/wh/ta/qd/whtaqdwmfal7dyi4d-fs_22oir0.png"><br><br><ol><li>  Crear secuencia </li><li>  El nuevo hilo en el que se ejecuta nuestro procedimiento.  La zona roja al principio dice que el hilo fue creado, pero durante alg√∫n tiempo no se pudo ejecutar, ya que no hab√≠a n√∫cleo libre. </li><li>  La finalizaci√≥n de la secuencia.  Curiosamente, el procedimiento de finalizaci√≥n de subproceso en s√≠ es incluso m√°s grande que su creaci√≥n.  Aunque parece que eliminar siempre es m√°s r√°pido. </li><li>  Esperando la finalizaci√≥n del procedimiento, que estaba en el esquema original, y termina despu√©s de que finaliza la secuencia, durante un tiempo el m√©todo se da cuenta de esto y, despu√©s de eso, informa.  Este tiempo es un poco m√°s largo que la finalizaci√≥n de la transmisi√≥n. </li></ol><br>  Como resultado, crear una transmisi√≥n requiere costos bastante significativos: iPhone 5S - 230 microsegundos, 6S - 50 microsegundos.  <b>La finalizaci√≥n de la transmisi√≥n lleva casi 2 veces m√°s tiempo que la creaci√≥n</b> , la uni√≥n tambi√©n lleva un tiempo tangible.  Cuando trabajamos con memoria, obtuvimos cientos de nanosegundos, que es 100 veces menos que decenas de microsegundos. <br><br><table><tbody><tr><td></td><td>  <b>gastos generales</b> </td><td>  <b>crear</b> </td><td>  <b>fin</b> </td><td>  <b>unirse</b> </td></tr><tr><td>  iPhone 5s </td><td>  230 Œºs </td><td>  40 Œºs </td><td>  70 Œºs </td><td>  30 Œºs </td></tr><tr><td>  iPhone 6s Plus </td><td>  50 Œºs </td><td>  12 Œºs </td><td>  20 Œºs </td><td>  7 Œºs </td></tr></tbody></table><br><h3>  Tiempo de cambio de sem√°foro </h3><br>  La siguiente prueba son <strong>mediciones del trabajo del sem√°foro</strong> .  Tenemos 2 hilos pre-creados, y para cada uno de ellos hay un sem√°foro.  Las corrientes se√±alan alternativamente el sem√°foro del vecino y esperan el suyo.  Transmiti√©ndose se√±ales entre s√≠, las transmisiones juegan ping-pong, se reviven entre s√≠.  Esta iteraci√≥n doble proporciona un tiempo de cambio de sem√°foro doble. <br><br><img src="https://habrastorage.org/webt/nf/de/iq/nfdeiqezf1edyugn_lkccjocndy.png"><br><br>  En System Trace, todo se ve similar: <br><br><ol><li>  Se da una se√±al para el sem√°foro de la segunda secuencia.  Se puede ver que esta operaci√≥n es muy corta. </li><li>  El segundo hilo est√° desbloqueado, la espera en su sem√°foro termina. </li><li>  Se da una se√±al para el sem√°foro de la primera secuencia. </li><li>  El primer hilo se desbloquea, la espera en su sem√°foro termina. </li></ol><br><img src="https://habrastorage.org/webt/0e/jn/mb/0ejnmb3dxvozsz-h0zaijdl_3xm.png"><br><br>  El tiempo de cambio fue de 10 microsegundos.  La diferencia con la creaci√≥n de un subproceso por 50 veces es exactamente la raz√≥n por la cual se crean grupos de subprocesos, y no un nuevo subproceso para cada procedimiento. <br><br><h3>  P√©rdidas en el cambio de contexto del hilo del sistema </h3><br>  En las dos pruebas anteriores, la transferencia de control entre subprocesos estaba completamente controlada: entendimos claramente d√≥nde y d√≥nde deber√≠a ocurrir la transici√≥n.  Sin embargo, a menudo sucede que el sistema mismo cambia de un hilo a otro.  Cuando ejecutamos m√°s tareas en paralelo que los n√∫cleos en el dispositivo, el sistema operativo debe poder cambiarse para proporcionar a todos tiempo de procesador. <br><br>  En esta prueba, quer√≠a medir la p√©rdida de iniciar demasiados hilos.  Para hacer esto, se crea un grupo de 16 subprocesos, cada uno de los cuales espera un sem√°foro, y, tan pronto como recibe una se√±al, realiza un cierto procedimiento y env√≠a la se√±al al sem√°foro.  El subproceso principal inicia todo el grupo, dando 16 se√±ales, y luego espera 16 se√±ales en respuesta. <br><br><img src="https://habrastorage.org/webt/fv/ki/an/fvkiang1lid-dgw6bmddnudyjro.png"><br><br>  En System Trace puede ver que los bloques est√°n dispersos al azar, algunos de ellos son mucho m√°s largos que el resto.  Si la conmutaci√≥n m√∫ltiple conduce a un aumento en el tiempo de ejecuci√≥n de la operaci√≥n, entonces el tiempo promedio de ejecuci√≥n deber√≠a aumentar como resultado. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ar/0b/r6/ar0br6h-8hm8qwmlyokuots92au.png" width="500"></div><br>  <b>Sin embargo, con un aumento en el n√∫mero de subprocesos, el tiempo de operaci√≥n promedio no aumenta.</b> <br><br>  En teor√≠a, el tiempo promedio debe mantenerse siempre que la carga corresponda a la potencia de procesamiento.  Es decir, el n√∫mero de tareas corresponde al n√∫mero de n√∫cleos. <br><br><img src="https://habrastorage.org/webt/9r/8l/-p/9r8l-p83_ad6ibrit6ee2d67cwa.png"><br><br>  Si ejecuta muchas tareas en paralelo, el sistema operativo, al cambiar de una tarea a otra, introducir√° demoras adicionales.  Esto deber√≠a reflejarse en el resultado. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/fe/0x/ko/fe0xko9wqlkfu5nt4n0fonqcrfs.png"></div><br>  En la pr√°ctica, no solo nuestra aplicaci√≥n funciona en el dispositivo, sino que tambi√©n tiene muchos procesos paralelos y del sistema.  Incluso el √∫nico hilo en nuestra aplicaci√≥n se ver√° afectado por el cambio, lo que conduce a interrupciones y demoras.  Por lo tanto, en todas las situaciones hay demoras y no hay diferencia entre construir tareas en serie o ejecutarlas en paralelo. <br><br><img src="https://habrastorage.org/webt/by/io/c4/byioc4ax6qgcuwxpkmjhpfyaaeg.png"><br><br>  A continuaci√≥n se muestra nuestra tabla de n√∫meros de latencia con datos sobre flujos y sem√°foros. <br><br><table><tbody><tr><td></td><td>  <b>L1</b> </td><td>  <b>L2</b> </td><td>  <b>Memoria</b> </td><td>  <b>Sem√°foro</b> </td></tr><tr><td>  N√∫meros de latencia </td><td>  1 ns </td><td>  7 ns </td><td>  100 ns </td><td>  25 ns </td></tr><tr><td>  iPhone 5s </td><td>  7 ns </td><td>  30 ns </td><td>  240 ns </td><td>  8 Œºs </td></tr><tr><td>  iPhone 6s Plus </td><td>  5 ns </td><td>  12 ns </td><td>  200 ns </td><td>  5 Œºs </td></tr><tr><td>  iPhone X </td><td>  2 ns </td><td>  12 ns </td><td>  146 ns </td><td>  3,2 Œºs </td></tr></tbody></table><br><h2>  Costos de archivo </h2><br>  Ya tenemos memoria y subprocesos; para completar, solo necesitamos operaciones del sistema de archivos. <br><br><h3>  Leer archivo </h3><br>  La primera prueba es <strong>la velocidad de lectura</strong> : cu√°nto cuesta leer un archivo.  La prueba consta de dos partes.  En el primero, <strong>medimos la velocidad de lectura</strong> teniendo en cuenta la apertura, lectura y cierre del archivo.  En el segundo, <strong>suponemos que el archivo est√° constantemente abierto</strong> : nos posicionamos en alg√∫n lugar y leemos todo lo que queremos. <br><br>  Los resultados se ven correctamente desde dos puntos de vista.  <strong>Cuando el archivo es peque√±o</strong> , hay un tiempo m√≠nimo para leer los datos del archivo.  Hasta un kilobyte son 5.3 microsegundos, no importa: 1 byte, 2 o 1 KB, para todos los 5.3 Œºs.  Por lo tanto, puede hablar de velocidad solo en el caso de archivos grandes, cuando el tiempo fijo ya puede ser descuidado.  La operaci√≥n para abrir y cerrar el archivo tarda aproximadamente el mismo tiempo para cualquier tama√±o de archivo, en el caso de 5S, aproximadamente 50 microsegundos. <br><br><img src="https://habrastorage.org/webt/zv/na/-2/zvna-2en_axstzffeo9iru-bpuo.png"><br><br>  Para la velocidad de lectura, se obtienen tales gr√°ficos. <br><br><img src="https://habrastorage.org/webt/h4/2g/ri/h42griw_vpjjlfgkpxdbty3c8yw.png"><br><br>  Para iPhone X y un archivo de 1 MB, la velocidad puede alcanzar los 20 MB / s.  Curiosamente, leer un archivo de 1 MB es m√°s eficiente.  Con tama√±os de archivo grandes, los tama√±os de cach√© parecen verse afectados.  Es por eso que la velocidad baja a√∫n m√°s y se iguala en la regi√≥n de 10 Mb. <br><br><h3>  Crea y elimina archivos </h3><br>  La prueba consiste en el paso de <strong>crear un archivo y escribir datos</strong> , y <strong>eliminar los</strong> archivos creados.  El resultado es paso a paso: en tama√±os peque√±os, el tiempo es estable: alrededor de 7 Œºs y sigue creciendo.  La escala es logar√≠tmica. <br><br><img src="https://habrastorage.org/webt/da/xn/sp/daxnspzyy0raugagyluwnkwjqhs.png"><br><br>  Me sorprendi√≥ que el tiempo que lleva eliminar un archivo grande es proporcional al tiempo que llev√≥ crear, ya que supuse que eliminar es una operaci√≥n r√°pida.  Resulta que no, para iPhone, eliminar a tiempo es comparable a crear un archivo.  La tabla resumen se ve as√≠. <br><br><table><tbody><tr><td></td><td>  <b>L1</b> </td><td>  <b>L2</b> </td><td>  <b>Memoria</b> </td><td>  <b>Sem√°foro</b> </td><td>  <b>Disco</b> </td></tr><tr><td>  N√∫meros de latencia </td><td>  1 ns </td><td>  7 ns </td><td>  100 ns </td><td>  25 ns </td><td>  150 Œºs </td></tr><tr><td>  iPhone 5s </td><td>  7 ns </td><td>  30 ns </td><td>  240 ns </td><td>  8 Œºs </td><td>  5 Œºs </td></tr><tr><td>  iPhone 6s Plus </td><td>  5 ns </td><td>  12 ns </td><td>  200 ns </td><td>  5 Œºs </td><td>  4 Œºs </td></tr><tr><td>  iPhone X </td><td>  2 ns </td><td>  12 ns </td><td>  146 ns </td><td>  3,2 Œºs </td><td>  1.3 Œºs </td></tr></tbody></table><br><h2>  Conclusi√≥n </h2><br>  En base a estas mediciones, ahora tenemos una idea de cu√°nto tiempo requieren las operaciones b√°sicas de iOS: acceder a la memoria es de nanosegundos, trabajar con archivos es de microsegundos, crear una secuencia de decenas de microsegundos, y el cambio es de solo unos pocos microsegundos. <br><br>  Para obtener un bloqueo f√≠sicamente notable en la aplicaci√≥n, el tiempo de ejecuci√≥n del procedimiento debe superar los 15 milisegundos (el tiempo que lleva actualizar la pantalla a 60 fps).  Esto es casi mil veces mayor que la mayor√≠a de las medidas tomadas en el art√≠culo.  En tal escala, un milisegundo es bastante, y un segundo ya es "para siempre". <br><br>  Las pruebas mostraron que, a pesar de la gran diferencia en el tiempo de acceso a la memoria y las memorias cach√©, el uso directo de esta relaci√≥n es bastante dif√≠cil.  Antes de compilar todos sus datos en L1, debe asegurarse de que en su caso realmente dar√° un resultado. <br><br>  Seg√∫n las pruebas de operaciones con subprocesos, pudimos asegurarnos de que crear y destruir subprocesos requiere una cantidad considerable de tiempo, pero realizar una gran cantidad de operaciones paralelas no conlleva costos adicionales. <br><br>  Bueno, en conclusi√≥n, me gustar√≠a recordarle la regla m√°s importante cuando trabaje en el rendimiento: ¬° <b>primero mediciones y solo luego optimizaci√≥n</b> ! <br><br>  Perfil del orador Dmitry Kurkin en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">GitHub</a> . <br><br><blockquote>  La conversi√≥n y transformaci√≥n de los informes de AppsConf 2018 en art√≠culos va en paralelo con la <b>preparaci√≥n de la nueva conferencia de</b> 2019.  Hasta el momento, solo hay 7 temas en la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">lista de informes aceptados</a> , pero esta lista se ampliar√° todo el tiempo para que tenga lugar una conferencia genial para desarrolladores m√≥viles del <b>22 al 23 de abril</b> . <br><br>  Siga las publicaciones, suscr√≠base al <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">canal de YouTube</a> y al <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">bolet√≠n informativo</a> y esta vez volar√° r√°pidamente. <br></blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/437590/">https://habr.com/ru/post/437590/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../437580/index.html">C√≥mo recordar un libro de texto de JavaScript en 5 d√≠as, o el "Palacio de la Memoria" en la vida cotidiana de un programador</a></li>
<li><a href="../437582/index.html">Descripci√≥n general de Vue.js 2.6</a></li>
<li><a href="../437584/index.html">Los fundamentos matem√°ticos del dise√±o autom√°tico</a></li>
<li><a href="../437586/index.html">Creamos una aplicaci√≥n de voz usando el ejemplo del Asistente de Google</a></li>
<li><a href="../437588/index.html">¬øEs m√°s divertido desarrollar para tel√©fonos m√≥viles que para la web?</a></li>
<li><a href="../437592/index.html">Arquitectura asincr√≥nica de la capa de ejecuci√≥n de tareas</a></li>
<li><a href="../437594/index.html">C√≥mo erradicaba la causa de la tartamudez y el salto de cuadro en todos los juegos, y tambi√©n bajaba accidentalmente la temperatura en 15 grados</a></li>
<li><a href="../437596/index.html">OTRS: autenticaci√≥n, autorizaci√≥n y sincronizaci√≥n LDAP (FreeIPA, AD)</a></li>
<li><a href="../437598/index.html">C√≥mo guardar el sistema de juego desde la PC dom√©stica mediante la virtualizaci√≥n</a></li>
<li><a href="../437600/index.html">opencv4arts: dibuja mi ciudad, Vincent</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>