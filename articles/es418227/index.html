<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🙃 🎡 🐇 Curso MIT "Seguridad de sistemas informáticos". Lección 7: El sandbox del cliente nativo, parte 3 🙋 ✊🏽 🙋🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Instituto de Tecnología de Massachusetts. Conferencia Curso # 6.858. "Seguridad de los sistemas informáticos". Nikolai Zeldovich, James Mickens. Año 2...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Curso MIT "Seguridad de sistemas informáticos". Lección 7: El sandbox del cliente nativo, parte 3</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ua-hosting/blog/418227/"><h3>  Instituto de Tecnología de Massachusetts.  Conferencia Curso # 6.858.  "Seguridad de los sistemas informáticos".  Nikolai Zeldovich, James Mickens.  Año 2014 </h3><br>  Computer Systems Security es un curso sobre el desarrollo e implementación de sistemas informáticos seguros.  Las conferencias cubren modelos de amenazas, ataques que comprometen la seguridad y técnicas de seguridad basadas en trabajos científicos recientes.  Los temas incluyen seguridad del sistema operativo (SO), características, gestión del flujo de información, seguridad del idioma, protocolos de red, seguridad de hardware y seguridad de aplicaciones web. <br><br>  Lección 1: "Introducción: modelos de amenaza" <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Parte 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Parte 2</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Parte 3</a> <br>  Lección 2: "Control de ataques de hackers" <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Parte 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Parte 2</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Parte 3</a> <br>  Lección 3: “Desbordamientos del búfer: exploits y protección” <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Parte 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Parte 2</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Parte 3</a> <br>  Lección 4: “Separación de privilegios” <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Parte 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Parte 2</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Parte 3</a> <br>  Lección 5: “¿De dónde vienen los sistemas de seguridad?” <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Parte 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Parte 2</a> <br>  Lección 6: “Oportunidades” <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Parte 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Parte 2</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Parte 3</a> <br>  Lección 7: “Sandbox de cliente nativo” <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Parte 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Parte 2</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Parte 3</a> <a name="habracut"></a><br><br>  Hay una advertencia en la regla <b>C4</b> .  No puede "saltar" al final de un programa.  Lo último que puede saltar es la última instrucción.  Entonces esta regla garantiza que cuando el programa se ejecute en el proceso "motor", no habrá discrepancias. <br><br>  La regla <b>C5</b> dice que no puede haber instrucciones de más de 32 bytes.  Consideramos una cierta versión de esta regla cuando hablamos de la multiplicidad de tamaños de instrucciones a 32 bytes, de lo contrario, puede saltar al medio de la instrucción y crear un problema con la llamada al sistema, que puede "ocultarse" allí. <br><br>  La regla <b>C6</b> establece que todas las instrucciones disponibles se pueden desmontar desde el principio.  Por lo tanto, esto garantiza que veamos cada instrucción y podemos verificar todas las instrucciones que se ejecutan cuando se ejecuta el programa. <br><br>  La regla <b>C7</b> establece que todos los saltos directos son correctos.  Por ejemplo, salta directamente a esa parte de la instrucción donde se indica el objetivo, y aunque no es un múltiplo de 32, sigue siendo la instrucción correcta a la que se aplica el desmontaje de izquierda a derecha. <br><br><img src="https://habrastorage.org/webt/1-/3i/vl/1-3ivlo26n7llpnkbkvzgzm-tci.jpeg"><br><br>  <b>Audiencia:</b> ¿cuál es la diferencia entre <b>C5</b> y <b>C3</b> ? <br><br>  <b>Profesor:</b> Creo que <b>C5</b> dice que si tengo una instrucción de varios bytes, no puede cruzar los bordes de las direcciones adyacentes.  Supongamos que tengo una secuencia de instrucciones, y hay una dirección 32 y una dirección 64. Entonces, una instrucción no puede cruzar el límite múltiple de 32 bytes, es decir, no debe comenzar con una dirección menor que 64 y terminar con una dirección mayor que 64. <br><br><img src="https://habrastorage.org/webt/di/oc/l5/diocl5ztxk3kmc1ol0mmm_badik.jpeg"><br><br>  Esto es lo que dice la regla <b>C5</b> .  Porque de lo contrario, habiendo dado un salto de multiplicidad 32, puede entrar en medio de otra instrucción, donde no se sabe lo que está sucediendo. <br><br>  Y la regla <b>C3</b> es un análogo de esta prohibición en el lado del salto.  Establece que cada vez que saltas, la longitud de tu salto debe ser un múltiplo de 32. <br><br>  <b>C5</b> también afirma que cualquier cosa en el rango de direcciones que sea múltiplo de 32 es una instrucción segura. <br><br>  Después de leer la lista de estas reglas, tuve un sentimiento mixto, ya que no podía evaluar si estas reglas son suficientes, es decir, la lista es mínima o completa. <br>  Entonces, pensemos en la tarea que tienes que completar.  Creo que, de hecho, hay un error en el funcionamiento del <b>Native Client</b> al ejecutar algunas instrucciones complicadas en el sandbox.  Creo que no tenían la codificación de longitud correcta, lo que podría conducir a algo malo, pero no recuerdo exactamente cuál fue el error. <br><br>  Supongamos que un validador sandbox obtiene incorrectamente la longitud de algún tipo de instrucción.  ¿Qué mal puede pasar en este caso?  ¿Cómo usarías este deslizamiento? <br><br>  <b>Público:</b> por ejemplo, puede ocultar la llamada al sistema o la declaración de devolución <b>ret</b> . <br><br>  <b>Profesor:</b> si.  Supongamos que hay una versión elegante de la declaración <b>AND</b> que anotó.  Es posible que el validador se haya equivocado y haya considerado que su longitud es de 6 bytes con la longitud real de 5 bytes. <br><br><img src="https://habrastorage.org/webt/2z/ak/mg/2zakmgsficxcsi5tqkqnb-r_tj4.jpeg"><br><br>  Que va a pasar  El validador considera que la longitud de esta instrucción es de 6 bytes y tiene otra instrucción válida detrás.  Pero el procesador, al iniciar el código, usa la longitud real de la instrucción, es decir, 5 bytes.  Como resultado, tenemos un byte libre al final de la instrucción <b>AND</b> , donde podríamos insertar una llamada al sistema y usarla para nuestro beneficio.  Y si insertamos un byte de <b>CD</b> aquí, será como el comienzo de otra instrucción.  A continuación, colocaremos algo en el próximo intervalo de 6 bytes, y se verá como una instrucción que comienza con el byte <b>CD</b> , aunque de hecho es parte de la instrucción <b>AND</b> .  Después de eso, podemos hacer una llamada al sistema y "escapar" de la caja de arena. <br><br>  Por lo tanto, el validador de <b>Native Client</b> debe sincronizar sus acciones con las acciones de la <b>CPU</b> , es decir, "adivinar" exactamente cómo interpretará el procesador cada instrucción.  Y esto debería estar en todos los niveles de la caja de arena, que es bastante difícil de implementar. <br><br>  De hecho, hay otros errores interesantes en <b>Native Client</b> .  Uno de ellos es la limpieza incorrecta del entorno del procesador al saltar al <b>tiempo de ejecución del servicio de confianza</b> .  Creo que hablaremos de esto en un segundo.  Pero <b>Trusted Service Runtime</b> básicamente funcionará con el mismo conjunto de registros de <b>CPU</b> diseñados para ejecutar módulos no confiables.  Entonces, si el procesador se olvida de borrar algo o reiniciar, el tiempo de ejecución puede ser engañado al considerar el módulo poco confiable como una aplicación confiable y hacer algo que no debería haber hecho o que no era la intención de los desarrolladores. <br><br>  Entonces, ¿dónde estamos ahora?  Por el momento, entendemos cómo desarmar todas las instrucciones y cómo evitar la ejecución de instrucciones prohibidas.  Ahora veamos cómo almacenamos memoria y enlaces para código y datos dentro del módulo <b>Native Client</b> . <br><br>  Por razones de rendimiento, los chicos de <b>Native Client</b> están comenzando a usar el soporte de hardware para asegurarse de que almacenar memoria y enlaces en realidad no genere mucha sobrecarga.  Pero antes de considerar el soporte de hardware que usan, quiero escuchar sugerencias, ¿cómo podría hacer lo mismo sin el soporte de hardware?  ¿Podemos proporcionar acceso a todos los procesos de memoria dentro de los límites establecidos por la máquina anteriormente? <br><br>  <b>Público:</b> puede instrumentar instrucciones para borrar todos los bits altos. <br><br><img src="https://habrastorage.org/webt/h1/b7/yg/h1b7ygdlwrvvs7y7ywxitmabec8.jpeg"><br><br>  <b>Profesor:</b> sí, es cierto.  De hecho, vemos que tenemos esta instrucción <b>AND</b> aquí, y cada vez que, por ejemplo, saltamos a algún lado, borra los bits bajos.  Pero si queremos mantener todo el código posible que se ejecuta dentro de los 256 MB bajos, simplemente podemos reemplazar el primer atributo <b>f</b> con <b>0</b> y obtener <b>$ 0x0fffffe0 en</b> lugar de <b>$ 0xffffffe0</b> .  Esto borra los bits bajos y establece un límite superior de 256 MB. <br><br>  Por lo tanto, esto hace exactamente lo que ofrece, asegurándose de que cada vez que salte, se encuentre dentro de los 256 MB.  Y el hecho de que estamos haciendo el desmontaje también hace posible verificar que todos los saltos directos estén al alcance. <br><br>  La razón por la que no hacen esto por su código es que en la plataforma <b>x86</b> puede codificar <b>AND de</b> manera muy efectiva, donde todos los bits superiores son 1. Esto se convierte en la existencia de una instrucción de 3 bytes para <b>AND</b> y una instrucción de 2 bytes. para el salto  Por lo tanto, tenemos un gasto adicional de 3 bytes.  Pero si necesita un bit alto sin unidad, como este <b>0 en</b> lugar de <b>f</b> , entonces de repente tiene una instrucción de 5 bytes.  Por lo tanto, creo que en este caso están preocupados por los gastos generales. <br><br>  <b>Público:</b> ¿Hay algún problema con la existencia de algunas instrucciones que incrementan la versión que está intentando obtener?  Es decir, ¿puede decir que su instrucción puede tener un sesgo constante o algo así? <br><br>  <b>Profesor:</b> eso creo.  Probablemente prohibirá las instrucciones que saltan a alguna fórmula de dirección compleja y solo admitirá instrucciones que salten directamente a este valor, y este valor siempre obtiene <b>AND</b> . <br><br>  <b>Público:</b> es más necesario para acceder a la memoria que ... <br><br>  <b>Profesor:</b> sí, porque es solo código.  Y para acceder a la memoria en la plataforma <b>x86</b> , hay muchas formas extrañas de acceder a una ubicación de memoria específica.  Por lo general, primero debe calcular la ubicación de la memoria, luego agregar un <b>AND</b> adicional <b>,</b> y solo luego acceder.  Creo que esta es la verdadera razón de su preocupación por la disminución del rendimiento debido al uso de este kit de herramientas. <br><br>  En la plataforma <b>x86</b> , o al menos en la plataforma de 32 bits descrita en el artículo, usan soporte de hardware en lugar de restringir el código y los datos de dirección que hacen referencia a módulos no confiables. <br><br>  Veamos cómo se ve antes de descubrir cómo usar el módulo <b>NaCl</b> en una caja de arena.  Este hardware se llama segmentación.  Surgió incluso antes de que la plataforma <b>x86</b> obtuviera un archivo de intercambio.  En la plataforma <b>x86</b> , existe una tabla de hardware compatible durante el proceso.  Lo llamamos la tabla de descriptores de segmento.  Es un grupo de segmentos numerados del 0 al final de una tabla de cualquier tamaño.  Esto es algo así como un descriptor de archivo en <b>Unix</b> , excepto que cada entrada consta de 2 valores: la base <b>base</b> y la <b>longitud de la</b> longitud. <br><br>  Esta tabla nos dice que tenemos un par de segmentos, y cada vez que nos referimos a un segmento específico, esto en cierto sentido significa que estamos hablando de una pieza de memoria que comienza en la dirección <b>base</b> de la <b>base</b> y continúa a lo largo de la <b>longitud</b> . <br><br><img src="https://habrastorage.org/webt/bc/5z/ly/bc5zlyp2hzg0aa6nn9nfsbbzwoe.jpeg"><br><br>  Esto nos ayuda a mantener los límites de la memoria en la plataforma <b>x86</b> , porque cada instrucción, al acceder a la memoria, se refiere a un segmento específico en esta tabla. <br><br>  Por ejemplo, cuando ejecutamos <b>mov (% eax), (% ebx)</b> , es decir, movemos el valor de la memoria de un puntero almacenado en el registro <b>EAX</b> a otro puntero almacenado en el registro <b>EBX</b> , el programa sabe cuáles son las direcciones inicial y final en vista de, y guardará el valor en la segunda dirección. <br><br>  Pero en realidad, en la plataforma <b>x86</b> , cuando hablamos de memoria, hay una cosa implícita llamada descriptor de segmento, similar a un descriptor de archivo en <b>Unix</b> .  Esto es solo un índice en la tabla de descriptores y, a menos que se indique lo contrario, cada código de operación contiene un segmento predeterminado. <br><br>  Por lo tanto, cuando ejecuta <b>mov (% eax)</b> , se refiere a <b>% ds</b> , o al registro de segmento de datos, que es un registro especial en su procesador.  Si no recuerdo mal, es un entero de 16 bits que apunta a esta tabla de descriptores. <br><br>  Y lo mismo ocurre con <b>(% ebx)</b> : se refiere al mismo selector de segmento <b>% ds</b> .  De hecho, en <b>x86</b> tenemos un grupo de 6 selectores de código: <b>CS, DS, ES, FS, GS</b> y <b>SS</b> .  El <b>selector de llamadas CS se</b> usa implícitamente para recibir instrucciones.  Entonces, si su puntero de instrucción apunta a algo, entonces se refiere al que seleccionó el selector de segmento <b>CS</b> . <br><br><img src="https://habrastorage.org/webt/li/vq/nz/livqnzyn6jk6muyb93siboedkik.jpeg"><br><br>  La mayoría de las referencias de datos usan implícitamente <b>DS</b> o <b>ES</b> , <b>FS</b> y <b>GS</b> indican algunas cosas especiales, y <b>SS</b> siempre se usa para operaciones de pila.  Y si haces <b>push &amp; pop</b> , entonces implícitamente provienen de este selector de segmento.  Esta es una mecánica bastante arcaica, pero resulta ser extremadamente útil en este caso particular. <br><br>  Si obtiene acceso a alguna dirección, por ejemplo, en el selector <b>% ds: addr</b> , el hardware lo redirigirá a la operación con la tabla <b>adrr + T [% ds] .base</b> .  Esto significa que tomará la dirección de longitud del módulo de la misma tabla.  Por lo tanto, cada vez que accede a la memoria, tiene una base de datos de selectores de segmento en forma de entradas de tabla de descriptores, y toma la dirección que especifique y la coincide con la longitud del segmento correspondiente. <br><br>  <b>Público:</b> entonces, ¿por qué no se usa, por ejemplo, para proteger el búfer? <br><br>  <b>Profesor:</b> sí, ¡esa es una buena pregunta!  ¿Podríamos usar esto para protegernos contra desbordamientos del búfer?  Por ejemplo, para cada búfer que tenemos, puede colocar la base del búfer aquí, y allí el tamaño del búfer. <br><br>  <b>Público:</b> ¿qué sucede si no necesita ponerlo en una tabla antes de escribirlo?  No necesitas estar allí constantemente. <br><br>  <b>Profesor:</b> si.  Por lo tanto, creo que la razón por la que este enfoque no se usa a menudo para proteger contra desbordamientos del búfer es porque el número de entradas en esta tabla no puede exceder 2 en el grado 16, porque los descriptores tienen 16 bits de largo, pero en realidad de hecho, se usan algunos bits más para otras cosas.  De hecho, solo puede colocar 2 en el 13er poder de los registros en esta tabla.  Por lo tanto, si tiene en su código una matriz de datos mayor que 2 <sup>13</sup> , puede producirse un desbordamiento de esta tabla. <br><br>  Además, sería extraño que el compilador administre directamente esta tabla, porque generalmente se manipula mediante llamadas al sistema.  No puede escribir directamente en esta tabla, primero debe hacer una llamada del sistema al sistema operativo, después de lo cual el sistema operativo colocará el registro en esta tabla.  Por lo tanto, creo que la mayoría de los compiladores simplemente no querrán lidiar con un sistema de gestión de memoria intermedia tan complejo. <br><br><img src="https://habrastorage.org/webt/rp/sa/hb/rpsahbydh4eumva5z7st5cfuc2a.jpeg"><br><br>  Por cierto, <b>Multex</b> utiliza este enfoque: tiene 2 <sup>18</sup> registros para varios segmentos y 2 <sup>18</sup> registros para posibles compensaciones.  Y cada fragmento de biblioteca común o fragmento de memoria son segmentos separados.  Todos se verifican para el rango y, por lo tanto, no se pueden usar a un nivel variable. <br><br>  <b>Público:</b> presumiblemente, la necesidad constante de usar el núcleo ralentizará el proceso. <br><br>  <b>Profesor:</b> sí, es cierto.  Entonces tendremos gastos generales debido al hecho de que cuando se crea repentinamente un nuevo búfer en la pila, necesitamos hacer una llamada al sistema para agregarlo. <br><br>  Entonces, ¿cuántos de estos elementos realmente usan el mecanismo de segmentación?  Puedes adivinar cómo funciona.  Creo que, por defecto, todos estos segmentos en <b>x86</b> tienen una base igual a 0, y la longitud es de 2 a 32. Por lo tanto, puede acceder a todo el rango de memoria que desee.  Por lo tanto, para <b>NaCl,</b> codifican la base 0 y establecen la longitud en 256 megabytes.  Luego señalan todos los registros de selectores de 6 segmentos en este registro para el área de 256 MB.  Por lo tanto, cada vez que el equipo accede a la memoria, la modifica con un desplazamiento de 256 MB.  Por lo tanto, la capacidad de cambiar el módulo estará limitada a 256 MB. <br><br>  Creo que ahora comprende cómo se admite este hardware y cómo funciona, por lo que podría terminar usando estos selectores de segmento. <br>  Entonces, ¿qué puede salir mal si solo implementamos este plan?  ¿Podemos saltar fuera del selector de segmento en un módulo no confiable?  Creo que una cosa con la que hay que tener cuidado es que estos registros son como registros regulares, y puede mover valores dentro y fuera de ellos.  Por lo tanto, debe asegurarse de que el módulo no confiable no distorsione estos registros de selector de segmento.  Porque en algún lugar de la tabla de descriptores puede haber un registro, que también es el descriptor de segmento de origen para un proceso que tiene una base de 0 y una longitud de hasta 2 <sup>32</sup> . <br><br><img src="https://habrastorage.org/webt/vg/k-/sv/vgk-svh5b3xlsnke_meuehgaira.jpeg"><br><br>  Entonces, si un módulo poco confiable pudo cambiar <b>CS</b> , <b>DS</b> o <b>ES</b> , o cualquiera de estos selectores para que comiencen a apuntar a este sistema operativo original, que cubre todo su espacio de direcciones, entonces puede hacer un enlace de memoria a este segmento y " salta de la caja de arena. <br><br>  Por lo tanto, <b>Native Client</b> tuvo que agregar algunas instrucciones más a esta lista prohibida.  Creo que prohíben todas las instrucciones como <b>mov% ds, es,</b> etc.  Por lo tanto, una vez en el entorno limitado, no puede cambiar el segmento al que se refieren algunas cosas que se refieren a él.  En la plataforma <b>x86, las</b> instrucciones para cambiar la tabla del descriptor de segmento son privilegiadas, pero se cambian los <b>ds, es,</b> etc.  La tabla es completamente sin privilegios. <br><br>  <b>Público: ¿</b> puede inicializar la tabla para que la longitud cero se coloque en todas las ranuras no utilizadas? <br><br>  <b>Profesor:</b> si.  Puede establecer la longitud de la tabla para algo donde no hay ranuras no utilizadas.  Resulta que realmente necesita esta ranura adicional que contiene 0 y 2 <sup>32</sup> , porque el entorno de <b>tiempo de ejecución confiable</b> debe comenzar en este segmento y obtener acceso a todo el rango de memoria.  Por lo tanto, esta entrada es necesaria para que funcione el entorno de <b>ejecución</b> confiable. <br><br>  Audiencia: ¿qué se necesita para cambiar la longitud de la salida de la tabla? <br>  Profesor: debes tener privilegios de root.  <b>Linux en</b> realidad tiene un sistema llamado <b>modify_ldt ()</b> para la tabla de descriptores locales, que permite que cualquier proceso modifique su propia tabla, es decir, en realidad hay una tabla para cada proceso.  Pero en la plataforma <b>x86</b> esto es más complicado, hay una tabla global y una tabla local.  Se puede cambiar una tabla local para un proceso específico. <br><br>  Ahora intentemos descubrir cómo saltamos y saltamos del proceso de ejecución de <b>Native Client</b> o salimos de la caja de arena.  ¿Qué significa saltar de nosotros? <br><br><img src="https://habrastorage.org/webt/8t/lb/yj/8tlbyjy5erf0s-x7stz29ca1qae.jpeg"><br><br>  Por lo tanto, necesitamos ejecutar este código confiable, y este código confiable "vive" en algún lugar por encima del límite de 256 MB.  Para saltar allí, tendremos que deshacer todas las protecciones que <b>Native Client ha</b> instalado.  Básicamente se reducen a cambiar estos seis selectores.  Creo que nuestro validador no aplicará las mismas reglas para las cosas ubicadas por encima del límite de 256 MB, por lo que esto es bastante simple. <br><br>  Pero luego tenemos que saltar de alguna manera al <b>tiempo de ejecución confiable</b> y reinstalar los selectores de segmento a los valores correctos para este segmento gigante, cubriendo el espacio de direcciones de todo el proceso; este rango es de 0 a 2 <sup>32</sup> .  Llamaron a tales mecanismos existentes en los trampolines " <b>trampolín</b> " y <b>trampolines</b> "trampolín" de <b>Native Client</b> .  Viven en un módulo bajo de 64k.  Lo mejor es que estos "trampolines" y "saltos" son piezas de código que se encuentran en los 64k inferiores del espacio de proceso.  Esto significa que este módulo poco confiable puede saltar allí, porque es una dirección de código válida que está dentro de los límites de 32 bits y dentro de 256 MB.  Entonces puedes saltar a este trampolín. <br><br>    <b>Native Client</b>    «» - .  ,  <b>Native Client</b>       «»,   trampoline      <b>trusted runtime</b> .         ,    <b>DS, CS</b>   ,       . <br><br>  ,        ,   -  <b>malo</b>   ,    «»,  «»  32-  . <br><br> ,     4096 + 32        ,     .   , ,   <b>mov %ds, 7</b> ,       <b>ds</b> ,   7         0  2 <sup>32</sup> .    <b>CS</b>       <b>trusted service runtime</b> ,     256 . <br><br><img src="https://habrastorage.org/webt/cr/fx/xj/crfxxjwdpg1tcflmflesmj_8obq.jpeg"><br><br>  ,     ,     ,         <b>trusted service runtime</b> ,    .            ,   .      DS ,   ,      ,     ,    -       . <br><br> ,        ? ,          «»? ,    ? <br><br> <b>:</b>    64. <br><br> <b>:</b> , ,          .         malo,       64,     32 .        ,       ,  ,     . <br><br>   ,        32-  ,       .  , ,        32 ,     32-    ,    .       «»    <b>trusted runtime</b>   32  . <br><br><img src="https://habrastorage.org/webt/hq/zy/tj/hqzytj99szvgxayslg6aqmwlmrk.jpeg"><br><br>      .     ,     ,     <b>DS, CS</b>   .    ,       256-  ,    <b>trusted runtime</b> ,      .                 . <br><br>         «»,      <b>trusted runtime</b>   256     <b>Native Client</b> . «»   <b>DS</b> , ,  <b>mov %ds, 7</b> ,        ,  <b>trusted runtime</b>    .     .     ,        «»,       - . <br><br>      <b>halt</b>    32-   «».        «»,   .      <b>trusted service runtime</b>      ,   1    . <br><br><img src="https://habrastorage.org/webt/50/am/cy/50amcyeulmago9zmrdvmjrsipvg.jpeg"><br><br>       <b>trusted service runtime</b> ,     ,        . <br><br> <b>:</b>   «»    ? <br><br> <b>:</b> «»     0  256   .        64-     ,    ,       «»,    - -.     <b>Native Client</b>       . <br><br> <b>:</b>          ? <br><br> <b>:</b> ,         ?  ,      «»?   ? <br><br> <b>:</b>    ,   ? <br><br> <b>:</b>  ,            -  <b>%eax</b> ,  <b>trusted runtime</b> : «,      »!      <b>EAX</b> ,    <b>mov</b> ,  «»      <b>EAX</b> ,        <b>trusted runtime</b> .   ,       «»? <br><br> <b>:</b> ,        ,         .   … <br><br> <b>:</b> ,   ,       —  ,       ,            0  2 <sup>32</sup> .   .         «»,                256 . <br><br>  ,      «»,          .  , «»    ,    .    ,   «»   . <br><br> <b>:</b>    «»   256 ? <br><br> <b>:</b>  ,      .    ,       <b>CS</b>         -  .     «»,       <b>halt</b> ,   mov,    <b>CS</b> ,        ,       256 . <br><br>  ,         ,    «».  ,       <b>DS</b> ,  ,  <b>CS</b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y saltar a alguna parte. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Probablemente, si lo intentó, podría encontrar una secuencia de instrucciones </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">x86</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> que podría hacer esto fuera de los límites del espacio de direcciones del módulo </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Native Client</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Entonces, nos vemos la próxima semana y hablamos sobre seguridad web.</font></font><br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/I0Psvvky-44" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La versión completa del curso está disponible </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">aquí</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gracias por quedarte con nosotros.</font></font> ¿Te gustan nuestros artículos?  ¿Quieres ver más materiales interesantes?  <b>Apóyenos</b> haciendo un pedido o recomendándolo a sus amigos, un <b>descuento del 30% para los usuarios de Habr en un análogo único de servidores de nivel de entrada que inventamos para usted:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">toda la verdad sobre VPS (KVM) E5-2650 v4 (6 núcleos) 10GB DDR4 240GB SSD 1Gbps de $ 20 o cómo dividir el servidor?</a>  (las opciones están disponibles con RAID1 y RAID10, hasta 24 núcleos y hasta 40GB DDR4). <br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">VPS (KVM) E5-2650 v4 (6 núcleos) 10GB DDR4 240GB SSD 1Gbps hasta diciembre de forma gratuita</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> al pagar por un período de seis meses, puede ordenar </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">aquí</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br>  <b>Dell R730xd 2 veces más barato?</b>  ¡Solo tenemos <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">2 x Intel Dodeca-Core Xeon E5-2650v4 128GB DDR4 6x480GB SSD 1Gbps 100 TV desde $ 249</a> en los Países Bajos y los Estados Unidos!</b>  Lea sobre <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Cómo construir un edificio de infraestructura.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">clase utilizando servidores Dell R730xd E5-2650 v4 que cuestan 9,000 euros por un centavo?</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es418227/">https://habr.com/ru/post/es418227/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es418217/index.html">Curso MIT "Seguridad de sistemas informáticos". Lección 6: "Oportunidades", parte 1</a></li>
<li><a href="../es418219/index.html">Curso MIT "Seguridad de sistemas informáticos". Lección 6: Oportunidades, Parte 2</a></li>
<li><a href="../es418221/index.html">Curso MIT "Seguridad de sistemas informáticos". Lección 6: "Oportunidades", parte 3</a></li>
<li><a href="../es418223/index.html">Curso MIT "Seguridad de sistemas informáticos". Lección 7: El sandbox del cliente nativo, parte 1</a></li>
<li><a href="../es418225/index.html">Curso MIT "Seguridad de sistemas informáticos". Lección 7: Sandbox de Native Client Parte 2</a></li>
<li><a href="../es418229/index.html">Curso MIT "Seguridad de sistemas informáticos". Lección 8: Modelo de seguridad de red, parte 1</a></li>
<li><a href="../es418233/index.html">BMW mnemotecnia para encontrar valores límite</a></li>
<li><a href="../es418235/index.html">Saga orquestada o cómo construir transacciones comerciales en servicios con la base de datos por patrón de servicio</a></li>
<li><a href="../es418237/index.html">Desarrollo de aplicaciones multiinquilino en la plataforma SAP Cloud en Neo, Parte 2: Autorización y autenticación</a></li>
<li><a href="../es418239/index.html">48 megapíxeles para teléfono inteligente</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>