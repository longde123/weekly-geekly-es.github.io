<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🚅 📇 🛌🏽 Cómo funciona JS: árboles de sintaxis abstracta, análisis y su optimización 👌🏼 🐊 🚪</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="[Recomendar lectura] Las otras 19 partes del ciclo  Parte 1: Descripción general del motor, mecanismos de tiempo de ejecución, pila de llamadas 
 Part...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Cómo funciona JS: árboles de sintaxis abstracta, análisis y su optimización</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/415269/"><div class="spoiler">  <b class="spoiler_title">[Recomendar lectura] Las otras 19 partes del ciclo</b> <div class="spoiler_text">  Parte 1: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Descripción general del motor, mecanismos de tiempo de ejecución, pila de llamadas</a> <br>  Parte 2: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Acerca de los componentes internos V8 y la optimización del código</a> <br>  Parte 3: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">administrar la memoria, cuatro tipos de pérdidas de memoria y tratar con ellas</a> <br>  Parte 4: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Bucle de eventos, asíncrono y cinco formas de mejorar su código con asíncrono / espera</a> <br>  Parte 5: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">WebSocket y HTTP / 2 + SSE.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Que elegir</a> <br>  Parte 6: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Características y alcance de WebAssembly</a> <br>  Parte 7: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Trabajadores web y cinco escenarios de uso</a> <br>  Parte 8: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Trabajadores de servicio</a> <br>  Parte 9: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">notificaciones push web</a> <br>  Parte 10: realizar un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">seguimiento de los cambios en el DOM con MutationObserver</a> <br>  Parte 11: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">motores de representación de páginas web y consejos para optimizar su rendimiento</a> <br>  Parte 12: El <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">subsistema de red de los navegadores, optimizando su rendimiento y seguridad.</a> <br>  Parte 12: El <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">subsistema de red de los navegadores, optimizando su rendimiento y seguridad.</a> <br>  Parte 13: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Animación con CSS y JavaScript.</a> <br>  Parte 14: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Cómo funciona JS: árboles de sintaxis abstracta, análisis y su optimización</a> <br>  Parte 15: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Cómo funciona JS: clases y herencia, transpilación en Babel y TypeScript</a> <br>  Parte 16: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Cómo funciona JS: almacenamiento</a> <br>  Parte 17: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Cómo funciona JS: tecnología Shadow DOM y componentes web</a> <br>  Parte 18: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Cómo funciona JS: Mecanismos de comunicación WebRTC y P2P</a> <br>  Parte 19: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Cómo funciona JS: Elementos personalizados</a> </div></div><br>  Todos sabemos que el código JavaScript para proyectos web puede crecer a un tamaño enorme.  Y cuanto más grande sea el código, más tiempo lo cargará el navegador.  Pero el problema aquí no es solo en el momento de la transmisión de datos a través de la red.  Después de que se carga el programa, aún debe analizarse, compilarse en bytecode y finalmente ejecutarse.  Hoy traemos a su atención una traducción de la parte 14 de la serie de ecosistemas de JavaScript.  Es decir, hablaremos sobre el análisis del código JS, cómo se construyen los árboles de sintaxis abstracta y cómo un programador puede influir en estos procesos, logrando un aumento en la velocidad de sus aplicaciones. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><img src="https://habrastorage.org/getpro/habr/post_images/68b/b2c/231/68bb2c231dd5b82bd35e97ceb36becef.jpg" alt="imagen"></a> <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">¿Cómo son los lenguajes de programación?</font> </h2><br>  Antes de hablar sobre árboles de sintaxis abstracta, analicemos cómo funcionan los lenguajes de programación.  Independientemente del idioma que use, siempre debe usar ciertos programas que toman el código fuente y lo convierten en algo que contiene comandos específicos para las máquinas.  Tanto los intérpretes como los compiladores actúan como tales programas.  No importa si escribe en un lenguaje interpretado (JavaScript, Python, Ruby) o compilado (C #, Java, Rust), su código, que es texto sin formato, siempre pasará por la etapa de análisis, es decir, convertir texto sin formato en una estructura de datos llamado un árbol de sintaxis abstracta (AST). <br><br>  Los árboles de sintaxis abstracta no solo proporcionan una representación estructurada del código fuente, sino que también juegan un papel crucial en el análisis semántico, durante el cual el compilador verifica la corrección de las construcciones de software y el uso correcto de sus elementos.  Después de formar el AST y realizar comprobaciones, esta estructura se utiliza para generar bytecode o código de máquina. <br><br><h2>  <font color="#3AC1EF">Usar árboles de sintaxis abstracta</font> </h2><br>  Los árboles de sintaxis abstracta se utilizan no solo en intérpretes y compiladores.  Ellos, en el mundo de las computadoras, son útiles en muchas otras áreas.  Una de las aplicaciones más comunes es el análisis de código estático.  Los analizadores estáticos no ejecutan el código que se les pasa.  Sin embargo, a pesar de esto, necesitan comprender la estructura de los programas. <br><br>  Suponga que desea desarrollar una herramienta que encuentre estructuras frecuentes en su código.  Los informes de dicha herramienta ayudarán a refactorizar y reducirán la duplicación de código.  Esto se puede hacer utilizando la comparación de cadenas habitual, pero este enfoque será muy primitivo, sus capacidades serán limitadas.  De hecho, si desea crear una herramienta similar, no necesita escribir su propio analizador para JavaScript.  Hay muchas implementaciones de código abierto de dichos programas que son totalmente compatibles con la especificación ECMAScript.  Por ejemplo, Esprima y Bellota.  También hay herramientas que pueden ayudar a trabajar con lo que generan los analizadores, a saber, trabajar con árboles de sintaxis abstracta. <br><br>  Los árboles de sintaxis abstracta, además, son ampliamente utilizados en el desarrollo de transpiladores.  Supongamos que decide desarrollar un transpiler que convierta el código Python en código JavaScript.  Un proyecto similar puede basarse en la idea de que se utiliza un transpilador para crear un árbol de sintaxis abstracta basado en el código Python, que, a su vez, se convierte en código JavaScript.  Probablemente aquí te preguntarás cómo es esto posible.  La cuestión es que los árboles de sintaxis abstracta son solo una forma alternativa de representar código en algún lenguaje de programación.  Antes de que el código se convierta a AST, parece un texto normal, cuando se escribe, que sigue ciertas reglas que forman el lenguaje.  Después de analizar, este código se convierte en una estructura de árbol que contiene la misma información que el código fuente del programa.  Como resultado, es posible llevar a cabo no solo la transición del código fuente a AST, sino también la transformación inversa, convirtiendo el árbol de sintaxis abstracta en una representación de texto del código del programa. <br><br><h2>  <font color="#3AC1EF">Analizando JavaScript</font> </h2><br>  Hablemos de cómo se construyen los árboles de sintaxis abstracta.  Como ejemplo, considere una función simple de JavaScript: <br><br><pre><code class="hljs actionscript"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x)</span></span></span><span class="hljs-function"> </span></span>{    <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (x &gt; <span class="hljs-number"><span class="hljs-number">10</span></span>) {        <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> a = <span class="hljs-number"><span class="hljs-number">2</span></span>;        <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a * x;    }    <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x + <span class="hljs-number"><span class="hljs-number">10</span></span>; }</code> </pre> <br>  El analizador creará un árbol de sintaxis abstracta, que se representa esquemáticamente en la siguiente figura. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/631/4f0/bc1/6314f0bc14439c74d13d0aa21f2e63c7.png"></div><br>  <i><font color="#999999">Árbol de sintaxis abstracta</font></i> <br><br>  Tenga en cuenta que esta es una representación simplificada de los resultados del analizador.  Un verdadero árbol de sintaxis abstracta parece mucho más complicado.  En este caso, nuestro objetivo principal es tener una idea de en qué se convierte, en primer lugar, el código fuente antes de que se ejecute.  Si está interesado en ver cómo se ve un árbol de sintaxis abstracta real, use el sitio web <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">AST Explorer</a> .  Para generar un AST para un cierto fragmento de código JS, es suficiente colocarlo en el campo correspondiente en la página. <br><br>  Quizás aquí tenga una pregunta sobre por qué el programador necesita saber cómo funciona el analizador JS.  Al final, analizar y ejecutar código es una tarea del navegador.  En cierto modo, tienes razón.  La siguiente figura muestra el tiempo requerido para que algunos proyectos web conocidos realicen varios pasos en el proceso de ejecución del código JS. <br><br>  Eche un vistazo más de cerca a este dibujo, tal vez verá algo interesante allí. <br><br><div style="text-align:center;"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><img src="https://habrastorage.org/getpro/habr/post_images/5c5/448/f14/5c5448f14dc1ec31ed7b2e89bb5a48a4.png"></a> </div><br>  <i><font color="#999999">Tiempo dedicado a ejecutar código JS</font></i> <br><br>  ¿Ves?  Si no, mira de nuevo.  En realidad, estamos hablando del hecho de que, en promedio, los navegadores pasan del 15 al 20% del tiempo analizando el código JS.  Y estos no son algunos datos condicionales.  Aquí hay información estadística sobre el trabajo de proyectos web reales que usan JavaScript de una forma u otra.  Quizás la cifra del 15% no te parezca tan grande, pero créeme, esto es mucho.  Una aplicación típica de una página carga aproximadamente 0.4 MB de código JavaScript, y el navegador necesita aproximadamente 370 ms para analizar este código.  De nuevo, puedes decir que no hay nada de qué preocuparse.  Y sí, eso solo no es mucho.  Sin embargo, no olvide que este es solo el tiempo que lleva analizar el código y convertirlo en un AST.  Esto no incluye el tiempo que lleva ejecutar el código o el tiempo que lleva resolver otras tareas que acompañan a la carga de la página, por ejemplo, las tareas de procesamiento de HTML y CSS y el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">procesamiento de la página</a> .  Además, solo estamos hablando de navegadores de escritorio.  En el caso de los sistemas móviles es aún peor.  En particular, el tiempo de análisis para el mismo código en dispositivos móviles puede ser de 2 a 5 veces más largo que en el escritorio.  Echa un vistazo a la siguiente figura. <br><br><div style="text-align:center;"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><img src="https://habrastorage.org/getpro/habr/post_images/8ba/4e0/530/8ba4e0530a7420a96458b00963587380.jpg"></a> </div><br>  <i><font color="#999999">Tiempo de análisis de 1 MB de código JS en varios dispositivos</font></i> <br><br>  Este es el tiempo requerido para analizar 1 MB de código JS en varios dispositivos móviles y de escritorio. <br><br>  Además, las aplicaciones web se vuelven cada vez más complejas y cada vez se transfieren más tareas al lado del cliente.  Todo esto tiene como objetivo mejorar la experiencia del usuario al trabajar con sitios web, con el fin de acercar estos sentimientos a los que los usuarios experimentan al interactuar con las aplicaciones tradicionales.  Es fácil determinar cuánto afecta esto a los proyectos web.  Para hacer esto, solo abra las herramientas de desarrollador en el navegador, vaya a un sitio moderno y vea cuánto tiempo se dedica a analizar el código, compilar y todo lo demás que sucede en el navegador al preparar la página para el trabajo. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/469/77c/26b/46977c26b690fe60b485f732f43afba8.jpg"></div><br>  <i><font color="#999999">Análisis de sitios web utilizando herramientas de desarrollador en un navegador</font></i> <br><br>  Desafortunadamente, los navegadores móviles no tienen tales herramientas.  Sin embargo, esto no significa que no se puedan analizar las versiones móviles de los sitios.  Aquí herramientas como <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">DeviceTiming</a> vendrán en nuestra ayuda.  Con DeviceTiming, puede medir el tiempo que lleva analizar y ejecutar scripts en entornos administrados.  Esto funciona debido a la colocación de scripts locales en el entorno formado por el código auxiliar, lo que lleva al hecho de que cada vez que la página se carga desde varios dispositivos, tenemos la oportunidad de medir localmente el tiempo de análisis y ejecución del código. <br><br><h2>  <font color="#3AC1EF">Optimización de análisis y motores JS</font> </h2><br>  Los motores JS hacen muchas cosas útiles para evitar trabajos innecesarios y optimizar los procesos de procesamiento de código.  Aquí hay algunos ejemplos. <br><br>  El motor V8 admite secuencias de comandos de transmisión y almacenamiento en caché de código.  En este caso, la transmisión se entiende como el hecho de que el sistema se dedica a analizar scripts cargados de forma asíncrona y scripts, cuya ejecución se retrasa, en un hilo separado, comenzando a hacerlo desde el momento en que el código comienza a cargarse.  Esto lleva al hecho de que el análisis termina casi simultáneamente con la finalización de la carga de la secuencia de comandos, lo que da una reducción del 10% en el tiempo requerido para preparar las páginas para el trabajo. <br><br>  El código JavaScript generalmente se compila en bytecode cada vez que se visita una página.  Sin embargo, este código de bytes se pierde después de que el usuario navega a otra página.  Esto se debe al hecho de que el código compilado depende en gran medida del estado y el contexto del sistema en el momento de la compilación.  Para mejorar la situación, Chrome 42 introdujo soporte para el almacenamiento en caché de bytecode.  Gracias a esta innovación, el código compilado se almacena localmente, como resultado, cuando el usuario regresa a la página que ya ha sido visitada, no hay necesidad de descargar, analizar y compilar scripts para prepararlo para el trabajo.  Esto ahorra a Chrome aproximadamente el 40% del tiempo de análisis y compilación.  Además, en el caso de los dispositivos móviles, esto lleva a ahorrar batería. <br><br>  El motor <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Carakan</a> , que se utilizó en el navegador Opera y ha sido reemplazado por V8 durante mucho tiempo, podría reutilizar los resultados de la compilación de scripts ya procesados.  No era necesario que estas secuencias de comandos se conectaran a la misma página o incluso se cargaran desde el mismo dominio.  Esta técnica de almacenamiento en caché, de hecho, es muy efectiva y le permite abandonar por completo el paso de compilación.  Ella se basa en escenarios de comportamiento de usuario típicos, en cómo las personas trabajan con recursos web.  Es decir, cuando el usuario sigue una determinada secuencia de acciones, mientras trabaja con una aplicación web, se carga el mismo código. <br><br>  El intérprete <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">SpiderMonkey</a> utilizado por FireFox no almacena todo en una fila.  Es compatible con un sistema de monitoreo que cuenta el número de llamadas a un script en particular.  En función de estos indicadores, se determinan las secciones del código que necesitan optimización, es decir, aquellas que tienen la carga máxima. <br><br>  Por supuesto, algunos desarrolladores de navegadores pueden decidir que sus productos no necesitan almacenamiento en caché.  Entonces, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Masei Stachovyak</a> , un desarrollador líder del navegador Safari, dice que Safari no está involucrado en el almacenamiento en caché del <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">código de bytes</a> compilado.  Se consideró la posibilidad de almacenamiento en caché, pero aún no se ha implementado, ya que la generación de código toma menos del 2% del tiempo total de ejecución del programa. <br><br>  Estas optimizaciones no afectan directamente el análisis del código fuente en JS.  En el curso de su aplicación, se hace todo lo posible para, en ciertos casos, omitir completamente este paso.  No importa cuán rápido sea el análisis, todavía lleva algún tiempo, y la ausencia total de análisis es quizás el ejemplo de optimización perfecta. <br><br><h2>  <font color="#3AC1EF">Reduce el tiempo de preparación de aplicaciones web</font> </h2><br>  Como descubrimos anteriormente, sería bueno minimizar la necesidad de analizar scripts, pero no puede deshacerse de él por completo, así que hablemos sobre cómo reducir el tiempo que lleva preparar las aplicaciones web para el trabajo.  De hecho, se puede hacer mucho por esto.  Por ejemplo, puede minimizar la cantidad de código JS incluido en la aplicación.  Un código pequeño que prepara una página para el trabajo puede analizarse más rápido, y lo más probable es que tarde menos tiempo en ejecutarse que un código que sea más voluminoso. <br><br>  Para reducir la cantidad de código, puede organizar la carga en la página solo lo que realmente necesita, y no una gran pieza de código, que incluye absolutamente todo lo que se necesita para el proyecto web en su conjunto.  Entonces, por ejemplo, el patrón <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">PRPL</a> promueve tal enfoque para cargar código.  Como alternativa, puede verificar las dependencias y ver si hay algo redundante en ellas, de modo que solo conduzca a un crecimiento injustificado de la base de código.  De hecho, aquí tocamos un gran tema digno de un material separado.  De vuelta al análisis. <br><br>  Por lo tanto, el propósito de este material es discutir técnicas que permitan a un desarrollador web ayudar a un analizador a hacer su trabajo más rápido.  Tales técnicas existen.  Los analizadores JS modernos utilizan algoritmos heurísticos para determinar si será necesario ejecutar un determinado fragmento de código lo antes posible o si será necesario ejecutarlo más tarde.  En base a estas predicciones, el analizador analiza completamente el fragmento de código utilizando el algoritmo de análisis ansioso o utiliza el algoritmo de análisis diferido.  Con un análisis completo, comprende las funciones que necesita compilar lo antes posible.  Durante este proceso, se resuelven tres tareas principales: crear un AST, crear una jerarquía de áreas de visibilidad y encontrar errores de sintaxis.  El análisis diferido, por otro lado, se usa solo para funciones que aún no necesitan compilarse.  Esto no crea un AST y no busca errores.  Con este enfoque, solo se crea una jerarquía de áreas de visibilidad, lo que ahorra aproximadamente la mitad del tiempo en comparación con las funciones de procesamiento que deben ejecutarse lo antes posible. <br><br>  De hecho, el concepto no es nuevo.  Incluso los navegadores obsoletos como IE9 son compatibles con estos enfoques de optimización, aunque, por supuesto, los sistemas modernos han avanzado mucho. <br><br>  Examinemos un ejemplo que ilustra el funcionamiento de estos mecanismos.  Supongamos que tenemos el siguiente código JS: <br><br><pre> <code class="hljs powershell"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> {   <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bar</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x)</span></span></span></span> {       <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x + <span class="hljs-number"><span class="hljs-number">10</span></span>;   }   <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">baz</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x, y)</span></span></span></span> {       <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x + y;   }   console.log(baz(<span class="hljs-number"><span class="hljs-number">100</span></span>, <span class="hljs-number"><span class="hljs-number">200</span></span>)); }</code> </pre> <br>  Como en el ejemplo anterior, el código cae en el analizador, que realiza su análisis y forma el AST.  Como resultado, el analizador representa un código que consta de las siguientes partes principales (no prestaremos atención a la función <code>foo</code> ): <br><br><ul><li>  Declarar una función de <code>bar</code> que toma un argumento ( <code>x</code> ).  Esta función tiene un comando de retorno, devuelve el resultado de agregar <code>x</code> y 10. </li><li>  Declarando una función <code>baz</code> que toma dos argumentos ( <code>x</code> e <code>y</code> ).  Ella también tiene un comando de retorno, devuelve el resultado de sumar <code>x</code> e <code>y</code> . </li><li>  Hacer una llamada a la función <code>baz</code> con dos argumentos: 100 y 200. </li><li>  Realizar una llamada a la función <code>console.log</code> con un argumento, que es el valor devuelto por la función llamada anteriormente. </li></ul><br>  Así es como se ve. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6df/ba5/f7b/6dfba5f7b7e40d5067424ada6a1c9855.png"></div><br>  <i><font color="#999999">El resultado de analizar el código de muestra sin aplicar la optimización</font></i> <br><br>  Hablemos de lo que está pasando aquí.  El analizador ve la declaración de la función de <code>bar</code> , la declaración de la función <code>baz</code> , la llamada a la función <code>baz</code> y la llamada a la función <code>console.log</code> .  Obviamente, al analizar este fragmento de código, el analizador encontrará una tarea cuya ejecución no afectará los resultados de este programa.  Se trata de analizar la <code>bar</code> funciones.  ¿Por qué el análisis de esta función no es práctico?  La cuestión es que la función de <code>bar</code> , al menos en el fragmento de código presentado, nunca se llama.  Este ejemplo simple puede parecer exagerado, pero muchas aplicaciones reales tienen una gran cantidad de funciones que nunca se llaman. <br><br>  En tal situación, en lugar de analizar la función de <code>bar</code> , simplemente podemos registrar que se declara, pero que no se usa en ninguna parte.  Al mismo tiempo, el análisis real de esta función se realiza cuando es necesario, justo antes de su ejecución.  Naturalmente, cuando se realiza un análisis lento, debe detectar el cuerpo de la función y hacer un registro de su declaración, pero aquí es donde termina el trabajo.  Para tal función, no es necesario formar un árbol de sintaxis abstracta, ya que el sistema no tiene información de que esta función esté planeada para realizarse.  Además, la memoria de almacenamiento dinámico no está asignada, lo que generalmente requiere considerables recursos del sistema.  En pocas palabras, la negativa a analizar funciones innecesarias conduce a un aumento significativo en el rendimiento del código. <br><br>  Como resultado, en el ejemplo anterior, el analizador real formará una estructura similar al siguiente esquema. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3bb/202/a4d/3bb202a4de7b21c31cff3648403096ac.png"></div><br>  <i><font color="#999999">Resultado del análisis del código de ejemplo con optimización</font></i> <br><br>  Tenga en cuenta que el analizador hizo una nota sobre la declaración de la <code>bar</code> funciones, pero no se ocupó de su análisis posterior.  El sistema no hizo ningún esfuerzo por analizar el código de función.  En este caso, el cuerpo de la función era un comando para devolver el resultado de cálculos simples.  Sin embargo, en la mayoría de las aplicaciones del mundo real, el código de función puede ser mucho más largo y complejo, y contiene muchos comandos de retorno, condiciones, bucles, comandos de declaración de variables y funciones anidadas.  Analizar todo esto, siempre que tales funciones nunca se llamen, es una pérdida de tiempo. <br><br>  No hay nada complicado en el concepto descrito anteriormente, pero su implementación práctica no es una tarea fácil.  Aquí examinamos un ejemplo muy simple y, de hecho, al decidir si un determinado fragmento de código tendrá demanda en un programa, es necesario analizar funciones, bucles, operadores condicionales y objetos.  En general, podemos decir que el analizador necesita procesar y analizar absolutamente todo lo que está en el programa. <br><br>  Aquí, por ejemplo, hay un patrón muy común para implementar módulos en JavaScript: <br><br><pre> <code class="hljs actionscript"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> myModule = (<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{   <span class="hljs-comment"><span class="hljs-comment">//      //    })();</span></span></code> </pre> <br>  La mayoría de los analizadores JS modernos reconocen este patrón; para ellos es una señal de que el código ubicado dentro del módulo debe analizarse completamente. <br><br>  Pero, ¿qué pasaría si los analizadores sintácticos siempre usaran el análisis lento?  Esto, desafortunadamente, no es una buena idea.  El hecho es que con este enfoque, si es necesario ejecutar algún código lo antes posible, encontraremos una desaceleración en el sistema.  El analizador realizará una pasada de análisis diferido, después de lo cual comenzará a analizar inmediatamente lo que debe hacerse lo antes posible.  Esto conducirá a una desaceleración de aproximadamente el 50% en comparación con el enfoque cuando el analizador comienza inmediatamente a analizar completamente el código más importante. <br><br><h2>  <font color="#3AC1EF">Optimización de código, teniendo en cuenta las características de su análisis.</font> </h2><br>  Ahora que hemos descubierto un poco sobre lo que está sucediendo dentro de los analizadores, es hora de pensar qué se puede hacer para ayudarlos.  Podemos escribir código para que el análisis de funciones se realice en el momento que lo necesitemos.  Hay un patrón que la mayoría de los analizadores entienden.  Se expresa en el hecho de que las funciones están entre corchetes.  Tal diseño casi siempre le dice al analizador que la función necesita ser desmontada inmediatamente.  Si el analizador detecta un paréntesis de apertura, inmediatamente después de lo cual sigue la declaración de la función, comenzará inmediatamente a analizar la función.  Podemos ayudar al analizador aplicando esta técnica al describir las funciones que deben realizarse lo antes posible. <br><br>  Supongamos que tenemos una función <code>foo</code> : <br><br><pre> <code class="hljs powershell"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x)</span></span></span></span> {   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x * <span class="hljs-number"><span class="hljs-number">10</span></span>; }</code> </pre> <br>  Dado que no hay una indicación explícita en este fragmento de código de que esta función está programada para ejecutarse de inmediato, el navegador solo realizará su análisis diferido.  Sin embargo, estamos seguros de que necesitaremos esta función muy pronto, por lo que podemos recurrir al próximo truco. <br><br>  Primero, guarde la función en una variable: <br><br><pre> <code class="hljs actionscript"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> foo = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x)</span></span></span><span class="hljs-function"> </span></span>{   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x * <span class="hljs-number"><span class="hljs-number">10</span></span>; };</code> </pre> <br>  Tenga en cuenta que dejamos el nombre de la función inicial entre la palabra clave de la <code>function</code> y el paréntesis de apertura.  No se puede decir que esto sea absolutamente necesario, pero se recomienda hacer exactamente eso, porque si se lanza una excepción cuando la función se está ejecutando, puede ver el nombre de la función en los datos de seguimiento de la pila, no <code>&lt;anonymous&gt;</code> . <br><br>  Después del cambio anterior, el analizador continuará utilizando el análisis lento.  Para cambiar esto, un pequeño detalle es suficiente.  La función debe estar entre corchetes: <br><br><pre> <code class="hljs actionscript"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> foo = (<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x)</span></span></span><span class="hljs-function"> </span></span>{   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x * <span class="hljs-number"><span class="hljs-number">10</span></span>; });</code> </pre> <br>  Ahora, cuando el analizador encuentre un paréntesis de apertura frente a la palabra clave de la <code>function</code> , comenzará a analizar esta función de inmediato. <br><br>  Puede que no sea fácil realizar tales optimizaciones manualmente, porque para esto necesita saber en qué casos el analizador realizará un análisis lento y en qué casos el completo.  Además, para hacer esto, debe dedicar tiempo a decidir si una función en particular debe estar lista para trabajar lo más rápido posible o no. <br><br>  Los programadores, por supuesto, no querrán asumir todo este trabajo adicional.  Además, lo cual no es menos importante que todo lo que ya se ha dicho, el código procesado de esta manera será más difícil de leer y comprender.  En esta situación, los paquetes de software especiales como Optimize.js están listos para ayudarnos.  Su objetivo principal es optimizar el tiempo de arranque inicial para el código fuente JS.  Realizan análisis de código estático y lo modifican para que las funciones que deban ejecutarse lo antes posible estén entre corchetes, lo que lleva al hecho de que el navegador las analiza de inmediato y las prepara para su ejecución. <br><br>  Entonces, supongamos que programamos, sin pensar realmente en nada, y tenemos el siguiente fragmento de código: <br><br><pre> <code class="hljs matlab">(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> {   </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">console</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">log</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">('Hello, World!')</span></span></span><span class="hljs-function">; })</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">;</span></span></code> </pre> <br>  Parece bastante normal, funciona como se esperaba, se ejecuta rápidamente, ya que el analizador encuentra el paréntesis de apertura frente a la palabra clave de <code>function</code> .  Hasta ahora todo bien. ,       ,     ,    : <br><br><pre> <code class="hljs matlab">!<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">{</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">console</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">log</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">('Hello, World!')</span></span></span><span class="hljs-function">}</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">;</span></span></code> </pre> <br>     ,    ,   .   ,   -        . <br><br>   ,      ,      .  ,     , ,         .  ,  ,    ,        .     ,        ,    .         Optimize.js.       Optimize.js,    : <br><br><pre> <code class="hljs matlab">!(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">{</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">console</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">log</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">('Hello, World!')</span></span></span><span class="hljs-function">})</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">;</span></span></code> </pre> <br>      ,   .    ,   .       ,   ,         ,   —     . <br><br><h2> <font color="#3AC1EF"> </font> </h2><br>  ,  JS-   — ,    .        ?   ,           ,  , ,          .   ,    ,  ,    ,    JS-      ,          .  ,    ,       ,   -,        .       -  .       ,   ,    .          ,     , , ,              .  , JS-     ,  ,   V8     ,   ,     .                 . <br><br><h2> <font color="#3AC1EF">  </font> </h2><br>   ,       -: <br><br><ul><li>   .    . </li><li>       ,       . </li><li> ,   ,   ,  JS-.          ,     ,   . </li><li>       DeviceTiming  ,      . </li><li>    Optimize.js  ,      ,         . </li></ul><br><h2>  <font color="#3AC1EF">Resumen</font> </h2><br>    ,    ,     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">SessionStack</a> ,      ,    -,       .     ,         .     —       . ,     —    ,      -,  ,       ,       . <br><br>  <b>Estimados lectores!</b>     -        JavaScript-? <br><br><div style="text-align:center;"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es415269/">https://habr.com/ru/post/es415269/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es415257/index.html">8 formas de mejorar la visualización de datos</a></li>
<li><a href="../es415259/index.html">select / poll / epoll: diferencia práctica</a></li>
<li><a href="../es415261/index.html">Artista VFX en desarrollo de juegos: características, carrera, desarrollo</a></li>
<li><a href="../es415263/index.html">Cómo agregamos entradas al mapa y redujimos el tamaño de las bases en un 10%</a></li>
<li><a href="../es415265/index.html">Buscando un sucesor del KL-7: RACE y AROFLEX</a></li>
<li><a href="../es415271/index.html">Cómo los gráficos de Gantt simplifican la gestión de proyectos</a></li>
<li><a href="../es415273/index.html">Aprender los conceptos básicos de la programación.</a></li>
<li><a href="../es415275/index.html">El libro "C # 7 y .NET Core. Desarrollo multiplataforma para profesionales. 3a edición</a></li>
<li><a href="../es415277/index.html">Qué hay de nuevo en ARKit 2.0</a></li>
<li><a href="../es415279/index.html">¿Por qué clavar clavos con un microscopio si tienes Alpine Linux?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>