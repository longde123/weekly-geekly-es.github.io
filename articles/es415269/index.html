<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üöÖ üìá üõåüèΩ C√≥mo funciona JS: √°rboles de sintaxis abstracta, an√°lisis y su optimizaci√≥n üëåüèº üêä üö™</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="[Recomendar lectura] Las otras 19 partes del ciclo  Parte 1: Descripci√≥n general del motor, mecanismos de tiempo de ejecuci√≥n, pila de llamadas 
 Part...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>C√≥mo funciona JS: √°rboles de sintaxis abstracta, an√°lisis y su optimizaci√≥n</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/415269/"><div class="spoiler">  <b class="spoiler_title">[Recomendar lectura] Las otras 19 partes del ciclo</b> <div class="spoiler_text">  Parte 1: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Descripci√≥n general del motor, mecanismos de tiempo de ejecuci√≥n, pila de llamadas</a> <br>  Parte 2: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Acerca de los componentes internos V8 y la optimizaci√≥n del c√≥digo</a> <br>  Parte 3: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">administrar la memoria, cuatro tipos de p√©rdidas de memoria y tratar con ellas</a> <br>  Parte 4: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Bucle de eventos, as√≠ncrono y cinco formas de mejorar su c√≥digo con as√≠ncrono / espera</a> <br>  Parte 5: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">WebSocket y HTTP / 2 + SSE.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Que elegir</a> <br>  Parte 6: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Caracter√≠sticas y alcance de WebAssembly</a> <br>  Parte 7: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Trabajadores web y cinco escenarios de uso</a> <br>  Parte 8: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Trabajadores de servicio</a> <br>  Parte 9: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">notificaciones push web</a> <br>  Parte 10: realizar un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">seguimiento de los cambios en el DOM con MutationObserver</a> <br>  Parte 11: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">motores de representaci√≥n de p√°ginas web y consejos para optimizar su rendimiento</a> <br>  Parte 12: El <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">subsistema de red de los navegadores, optimizando su rendimiento y seguridad.</a> <br>  Parte 12: El <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">subsistema de red de los navegadores, optimizando su rendimiento y seguridad.</a> <br>  Parte 13: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Animaci√≥n con CSS y JavaScript.</a> <br>  Parte 14: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">C√≥mo funciona JS: √°rboles de sintaxis abstracta, an√°lisis y su optimizaci√≥n</a> <br>  Parte 15: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">C√≥mo funciona JS: clases y herencia, transpilaci√≥n en Babel y TypeScript</a> <br>  Parte 16: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">C√≥mo funciona JS: almacenamiento</a> <br>  Parte 17: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">C√≥mo funciona JS: tecnolog√≠a Shadow DOM y componentes web</a> <br>  Parte 18: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">C√≥mo funciona JS: Mecanismos de comunicaci√≥n WebRTC y P2P</a> <br>  Parte 19: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">C√≥mo funciona JS: Elementos personalizados</a> </div></div><br>  Todos sabemos que el c√≥digo JavaScript para proyectos web puede crecer a un tama√±o enorme.  Y cuanto m√°s grande sea el c√≥digo, m√°s tiempo lo cargar√° el navegador.  Pero el problema aqu√≠ no es solo en el momento de la transmisi√≥n de datos a trav√©s de la red.  Despu√©s de que se carga el programa, a√∫n debe analizarse, compilarse en bytecode y finalmente ejecutarse.  Hoy traemos a su atenci√≥n una traducci√≥n de la parte 14 de la serie de ecosistemas de JavaScript.  Es decir, hablaremos sobre el an√°lisis del c√≥digo JS, c√≥mo se construyen los √°rboles de sintaxis abstracta y c√≥mo un programador puede influir en estos procesos, logrando un aumento en la velocidad de sus aplicaciones. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><img src="https://habrastorage.org/getpro/habr/post_images/68b/b2c/231/68bb2c231dd5b82bd35e97ceb36becef.jpg" alt="imagen"></a> <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">¬øC√≥mo son los lenguajes de programaci√≥n?</font> </h2><br>  Antes de hablar sobre √°rboles de sintaxis abstracta, analicemos c√≥mo funcionan los lenguajes de programaci√≥n.  Independientemente del idioma que use, siempre debe usar ciertos programas que toman el c√≥digo fuente y lo convierten en algo que contiene comandos espec√≠ficos para las m√°quinas.  Tanto los int√©rpretes como los compiladores act√∫an como tales programas.  No importa si escribe en un lenguaje interpretado (JavaScript, Python, Ruby) o compilado (C #, Java, Rust), su c√≥digo, que es texto sin formato, siempre pasar√° por la etapa de an√°lisis, es decir, convertir texto sin formato en una estructura de datos llamado un √°rbol de sintaxis abstracta (AST). <br><br>  Los √°rboles de sintaxis abstracta no solo proporcionan una representaci√≥n estructurada del c√≥digo fuente, sino que tambi√©n juegan un papel crucial en el an√°lisis sem√°ntico, durante el cual el compilador verifica la correcci√≥n de las construcciones de software y el uso correcto de sus elementos.  Despu√©s de formar el AST y realizar comprobaciones, esta estructura se utiliza para generar bytecode o c√≥digo de m√°quina. <br><br><h2>  <font color="#3AC1EF">Usar √°rboles de sintaxis abstracta</font> </h2><br>  Los √°rboles de sintaxis abstracta se utilizan no solo en int√©rpretes y compiladores.  Ellos, en el mundo de las computadoras, son √∫tiles en muchas otras √°reas.  Una de las aplicaciones m√°s comunes es el an√°lisis de c√≥digo est√°tico.  Los analizadores est√°ticos no ejecutan el c√≥digo que se les pasa.  Sin embargo, a pesar de esto, necesitan comprender la estructura de los programas. <br><br>  Suponga que desea desarrollar una herramienta que encuentre estructuras frecuentes en su c√≥digo.  Los informes de dicha herramienta ayudar√°n a refactorizar y reducir√°n la duplicaci√≥n de c√≥digo.  Esto se puede hacer utilizando la comparaci√≥n de cadenas habitual, pero este enfoque ser√° muy primitivo, sus capacidades ser√°n limitadas.  De hecho, si desea crear una herramienta similar, no necesita escribir su propio analizador para JavaScript.  Hay muchas implementaciones de c√≥digo abierto de dichos programas que son totalmente compatibles con la especificaci√≥n ECMAScript.  Por ejemplo, Esprima y Bellota.  Tambi√©n hay herramientas que pueden ayudar a trabajar con lo que generan los analizadores, a saber, trabajar con √°rboles de sintaxis abstracta. <br><br>  Los √°rboles de sintaxis abstracta, adem√°s, son ampliamente utilizados en el desarrollo de transpiladores.  Supongamos que decide desarrollar un transpiler que convierta el c√≥digo Python en c√≥digo JavaScript.  Un proyecto similar puede basarse en la idea de que se utiliza un transpilador para crear un √°rbol de sintaxis abstracta basado en el c√≥digo Python, que, a su vez, se convierte en c√≥digo JavaScript.  Probablemente aqu√≠ te preguntar√°s c√≥mo es esto posible.  La cuesti√≥n es que los √°rboles de sintaxis abstracta son solo una forma alternativa de representar c√≥digo en alg√∫n lenguaje de programaci√≥n.  Antes de que el c√≥digo se convierta a AST, parece un texto normal, cuando se escribe, que sigue ciertas reglas que forman el lenguaje.  Despu√©s de analizar, este c√≥digo se convierte en una estructura de √°rbol que contiene la misma informaci√≥n que el c√≥digo fuente del programa.  Como resultado, es posible llevar a cabo no solo la transici√≥n del c√≥digo fuente a AST, sino tambi√©n la transformaci√≥n inversa, convirtiendo el √°rbol de sintaxis abstracta en una representaci√≥n de texto del c√≥digo del programa. <br><br><h2>  <font color="#3AC1EF">Analizando JavaScript</font> </h2><br>  Hablemos de c√≥mo se construyen los √°rboles de sintaxis abstracta.  Como ejemplo, considere una funci√≥n simple de JavaScript: <br><br><pre><code class="hljs actionscript"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x)</span></span></span><span class="hljs-function"> </span></span>{    <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (x &gt; <span class="hljs-number"><span class="hljs-number">10</span></span>) {        <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> a = <span class="hljs-number"><span class="hljs-number">2</span></span>;        <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a * x;    }    <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x + <span class="hljs-number"><span class="hljs-number">10</span></span>; }</code> </pre> <br>  El analizador crear√° un √°rbol de sintaxis abstracta, que se representa esquem√°ticamente en la siguiente figura. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/631/4f0/bc1/6314f0bc14439c74d13d0aa21f2e63c7.png"></div><br>  <i><font color="#999999">√Årbol de sintaxis abstracta</font></i> <br><br>  Tenga en cuenta que esta es una representaci√≥n simplificada de los resultados del analizador.  Un verdadero √°rbol de sintaxis abstracta parece mucho m√°s complicado.  En este caso, nuestro objetivo principal es tener una idea de en qu√© se convierte, en primer lugar, el c√≥digo fuente antes de que se ejecute.  Si est√° interesado en ver c√≥mo se ve un √°rbol de sintaxis abstracta real, use el sitio web <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">AST Explorer</a> .  Para generar un AST para un cierto fragmento de c√≥digo JS, es suficiente colocarlo en el campo correspondiente en la p√°gina. <br><br>  Quiz√°s aqu√≠ tenga una pregunta sobre por qu√© el programador necesita saber c√≥mo funciona el analizador JS.  Al final, analizar y ejecutar c√≥digo es una tarea del navegador.  En cierto modo, tienes raz√≥n.  La siguiente figura muestra el tiempo requerido para que algunos proyectos web conocidos realicen varios pasos en el proceso de ejecuci√≥n del c√≥digo JS. <br><br>  Eche un vistazo m√°s de cerca a este dibujo, tal vez ver√° algo interesante all√≠. <br><br><div style="text-align:center;"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><img src="https://habrastorage.org/getpro/habr/post_images/5c5/448/f14/5c5448f14dc1ec31ed7b2e89bb5a48a4.png"></a> </div><br>  <i><font color="#999999">Tiempo dedicado a ejecutar c√≥digo JS</font></i> <br><br>  ¬øVes?  Si no, mira de nuevo.  En realidad, estamos hablando del hecho de que, en promedio, los navegadores pasan del 15 al 20% del tiempo analizando el c√≥digo JS.  Y estos no son algunos datos condicionales.  Aqu√≠ hay informaci√≥n estad√≠stica sobre el trabajo de proyectos web reales que usan JavaScript de una forma u otra.  Quiz√°s la cifra del 15% no te parezca tan grande, pero cr√©eme, esto es mucho.  Una aplicaci√≥n t√≠pica de una p√°gina carga aproximadamente 0.4 MB de c√≥digo JavaScript, y el navegador necesita aproximadamente 370 ms para analizar este c√≥digo.  De nuevo, puedes decir que no hay nada de qu√© preocuparse.  Y s√≠, eso solo no es mucho.  Sin embargo, no olvide que este es solo el tiempo que lleva analizar el c√≥digo y convertirlo en un AST.  Esto no incluye el tiempo que lleva ejecutar el c√≥digo o el tiempo que lleva resolver otras tareas que acompa√±an a la carga de la p√°gina, por ejemplo, las tareas de procesamiento de HTML y CSS y el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">procesamiento de la p√°gina</a> .  Adem√°s, solo estamos hablando de navegadores de escritorio.  En el caso de los sistemas m√≥viles es a√∫n peor.  En particular, el tiempo de an√°lisis para el mismo c√≥digo en dispositivos m√≥viles puede ser de 2 a 5 veces m√°s largo que en el escritorio.  Echa un vistazo a la siguiente figura. <br><br><div style="text-align:center;"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><img src="https://habrastorage.org/getpro/habr/post_images/8ba/4e0/530/8ba4e0530a7420a96458b00963587380.jpg"></a> </div><br>  <i><font color="#999999">Tiempo de an√°lisis de 1 MB de c√≥digo JS en varios dispositivos</font></i> <br><br>  Este es el tiempo requerido para analizar 1 MB de c√≥digo JS en varios dispositivos m√≥viles y de escritorio. <br><br>  Adem√°s, las aplicaciones web se vuelven cada vez m√°s complejas y cada vez se transfieren m√°s tareas al lado del cliente.  Todo esto tiene como objetivo mejorar la experiencia del usuario al trabajar con sitios web, con el fin de acercar estos sentimientos a los que los usuarios experimentan al interactuar con las aplicaciones tradicionales.  Es f√°cil determinar cu√°nto afecta esto a los proyectos web.  Para hacer esto, solo abra las herramientas de desarrollador en el navegador, vaya a un sitio moderno y vea cu√°nto tiempo se dedica a analizar el c√≥digo, compilar y todo lo dem√°s que sucede en el navegador al preparar la p√°gina para el trabajo. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/469/77c/26b/46977c26b690fe60b485f732f43afba8.jpg"></div><br>  <i><font color="#999999">An√°lisis de sitios web utilizando herramientas de desarrollador en un navegador</font></i> <br><br>  Desafortunadamente, los navegadores m√≥viles no tienen tales herramientas.  Sin embargo, esto no significa que no se puedan analizar las versiones m√≥viles de los sitios.  Aqu√≠ herramientas como <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">DeviceTiming</a> vendr√°n en nuestra ayuda.  Con DeviceTiming, puede medir el tiempo que lleva analizar y ejecutar scripts en entornos administrados.  Esto funciona debido a la colocaci√≥n de scripts locales en el entorno formado por el c√≥digo auxiliar, lo que lleva al hecho de que cada vez que la p√°gina se carga desde varios dispositivos, tenemos la oportunidad de medir localmente el tiempo de an√°lisis y ejecuci√≥n del c√≥digo. <br><br><h2>  <font color="#3AC1EF">Optimizaci√≥n de an√°lisis y motores JS</font> </h2><br>  Los motores JS hacen muchas cosas √∫tiles para evitar trabajos innecesarios y optimizar los procesos de procesamiento de c√≥digo.  Aqu√≠ hay algunos ejemplos. <br><br>  El motor V8 admite secuencias de comandos de transmisi√≥n y almacenamiento en cach√© de c√≥digo.  En este caso, la transmisi√≥n se entiende como el hecho de que el sistema se dedica a analizar scripts cargados de forma as√≠ncrona y scripts, cuya ejecuci√≥n se retrasa, en un hilo separado, comenzando a hacerlo desde el momento en que el c√≥digo comienza a cargarse.  Esto lleva al hecho de que el an√°lisis termina casi simult√°neamente con la finalizaci√≥n de la carga de la secuencia de comandos, lo que da una reducci√≥n del 10% en el tiempo requerido para preparar las p√°ginas para el trabajo. <br><br>  El c√≥digo JavaScript generalmente se compila en bytecode cada vez que se visita una p√°gina.  Sin embargo, este c√≥digo de bytes se pierde despu√©s de que el usuario navega a otra p√°gina.  Esto se debe al hecho de que el c√≥digo compilado depende en gran medida del estado y el contexto del sistema en el momento de la compilaci√≥n.  Para mejorar la situaci√≥n, Chrome 42 introdujo soporte para el almacenamiento en cach√© de bytecode.  Gracias a esta innovaci√≥n, el c√≥digo compilado se almacena localmente, como resultado, cuando el usuario regresa a la p√°gina que ya ha sido visitada, no hay necesidad de descargar, analizar y compilar scripts para prepararlo para el trabajo.  Esto ahorra a Chrome aproximadamente el 40% del tiempo de an√°lisis y compilaci√≥n.  Adem√°s, en el caso de los dispositivos m√≥viles, esto lleva a ahorrar bater√≠a. <br><br>  El motor <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Carakan</a> , que se utiliz√≥ en el navegador Opera y ha sido reemplazado por V8 durante mucho tiempo, podr√≠a reutilizar los resultados de la compilaci√≥n de scripts ya procesados.  No era necesario que estas secuencias de comandos se conectaran a la misma p√°gina o incluso se cargaran desde el mismo dominio.  Esta t√©cnica de almacenamiento en cach√©, de hecho, es muy efectiva y le permite abandonar por completo el paso de compilaci√≥n.  Ella se basa en escenarios de comportamiento de usuario t√≠picos, en c√≥mo las personas trabajan con recursos web.  Es decir, cuando el usuario sigue una determinada secuencia de acciones, mientras trabaja con una aplicaci√≥n web, se carga el mismo c√≥digo. <br><br>  El int√©rprete <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">SpiderMonkey</a> utilizado por FireFox no almacena todo en una fila.  Es compatible con un sistema de monitoreo que cuenta el n√∫mero de llamadas a un script en particular.  En funci√≥n de estos indicadores, se determinan las secciones del c√≥digo que necesitan optimizaci√≥n, es decir, aquellas que tienen la carga m√°xima. <br><br>  Por supuesto, algunos desarrolladores de navegadores pueden decidir que sus productos no necesitan almacenamiento en cach√©.  Entonces, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Masei Stachovyak</a> , un desarrollador l√≠der del navegador Safari, dice que Safari no est√° involucrado en el almacenamiento en cach√© del <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">c√≥digo de bytes</a> compilado.  Se consider√≥ la posibilidad de almacenamiento en cach√©, pero a√∫n no se ha implementado, ya que la generaci√≥n de c√≥digo toma menos del 2% del tiempo total de ejecuci√≥n del programa. <br><br>  Estas optimizaciones no afectan directamente el an√°lisis del c√≥digo fuente en JS.  En el curso de su aplicaci√≥n, se hace todo lo posible para, en ciertos casos, omitir completamente este paso.  No importa cu√°n r√°pido sea el an√°lisis, todav√≠a lleva alg√∫n tiempo, y la ausencia total de an√°lisis es quiz√°s el ejemplo de optimizaci√≥n perfecta. <br><br><h2>  <font color="#3AC1EF">Reduce el tiempo de preparaci√≥n de aplicaciones web</font> </h2><br>  Como descubrimos anteriormente, ser√≠a bueno minimizar la necesidad de analizar scripts, pero no puede deshacerse de √©l por completo, as√≠ que hablemos sobre c√≥mo reducir el tiempo que lleva preparar las aplicaciones web para el trabajo.  De hecho, se puede hacer mucho por esto.  Por ejemplo, puede minimizar la cantidad de c√≥digo JS incluido en la aplicaci√≥n.  Un c√≥digo peque√±o que prepara una p√°gina para el trabajo puede analizarse m√°s r√°pido, y lo m√°s probable es que tarde menos tiempo en ejecutarse que un c√≥digo que sea m√°s voluminoso. <br><br>  Para reducir la cantidad de c√≥digo, puede organizar la carga en la p√°gina solo lo que realmente necesita, y no una gran pieza de c√≥digo, que incluye absolutamente todo lo que se necesita para el proyecto web en su conjunto.  Entonces, por ejemplo, el patr√≥n <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">PRPL</a> promueve tal enfoque para cargar c√≥digo.  Como alternativa, puede verificar las dependencias y ver si hay algo redundante en ellas, de modo que solo conduzca a un crecimiento injustificado de la base de c√≥digo.  De hecho, aqu√≠ tocamos un gran tema digno de un material separado.  De vuelta al an√°lisis. <br><br>  Por lo tanto, el prop√≥sito de este material es discutir t√©cnicas que permitan a un desarrollador web ayudar a un analizador a hacer su trabajo m√°s r√°pido.  Tales t√©cnicas existen.  Los analizadores JS modernos utilizan algoritmos heur√≠sticos para determinar si ser√° necesario ejecutar un determinado fragmento de c√≥digo lo antes posible o si ser√° necesario ejecutarlo m√°s tarde.  En base a estas predicciones, el analizador analiza completamente el fragmento de c√≥digo utilizando el algoritmo de an√°lisis ansioso o utiliza el algoritmo de an√°lisis diferido.  Con un an√°lisis completo, comprende las funciones que necesita compilar lo antes posible.  Durante este proceso, se resuelven tres tareas principales: crear un AST, crear una jerarqu√≠a de √°reas de visibilidad y encontrar errores de sintaxis.  El an√°lisis diferido, por otro lado, se usa solo para funciones que a√∫n no necesitan compilarse.  Esto no crea un AST y no busca errores.  Con este enfoque, solo se crea una jerarqu√≠a de √°reas de visibilidad, lo que ahorra aproximadamente la mitad del tiempo en comparaci√≥n con las funciones de procesamiento que deben ejecutarse lo antes posible. <br><br>  De hecho, el concepto no es nuevo.  Incluso los navegadores obsoletos como IE9 son compatibles con estos enfoques de optimizaci√≥n, aunque, por supuesto, los sistemas modernos han avanzado mucho. <br><br>  Examinemos un ejemplo que ilustra el funcionamiento de estos mecanismos.  Supongamos que tenemos el siguiente c√≥digo JS: <br><br><pre> <code class="hljs powershell"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> {   <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bar</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x)</span></span></span></span> {       <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x + <span class="hljs-number"><span class="hljs-number">10</span></span>;   }   <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">baz</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x, y)</span></span></span></span> {       <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x + y;   }   console.log(baz(<span class="hljs-number"><span class="hljs-number">100</span></span>, <span class="hljs-number"><span class="hljs-number">200</span></span>)); }</code> </pre> <br>  Como en el ejemplo anterior, el c√≥digo cae en el analizador, que realiza su an√°lisis y forma el AST.  Como resultado, el analizador representa un c√≥digo que consta de las siguientes partes principales (no prestaremos atenci√≥n a la funci√≥n <code>foo</code> ): <br><br><ul><li>  Declarar una funci√≥n de <code>bar</code> que toma un argumento ( <code>x</code> ).  Esta funci√≥n tiene un comando de retorno, devuelve el resultado de agregar <code>x</code> y 10. </li><li>  Declarando una funci√≥n <code>baz</code> que toma dos argumentos ( <code>x</code> e <code>y</code> ).  Ella tambi√©n tiene un comando de retorno, devuelve el resultado de sumar <code>x</code> e <code>y</code> . </li><li>  Hacer una llamada a la funci√≥n <code>baz</code> con dos argumentos: 100 y 200. </li><li>  Realizar una llamada a la funci√≥n <code>console.log</code> con un argumento, que es el valor devuelto por la funci√≥n llamada anteriormente. </li></ul><br>  As√≠ es como se ve. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6df/ba5/f7b/6dfba5f7b7e40d5067424ada6a1c9855.png"></div><br>  <i><font color="#999999">El resultado de analizar el c√≥digo de muestra sin aplicar la optimizaci√≥n</font></i> <br><br>  Hablemos de lo que est√° pasando aqu√≠.  El analizador ve la declaraci√≥n de la funci√≥n de <code>bar</code> , la declaraci√≥n de la funci√≥n <code>baz</code> , la llamada a la funci√≥n <code>baz</code> y la llamada a la funci√≥n <code>console.log</code> .  Obviamente, al analizar este fragmento de c√≥digo, el analizador encontrar√° una tarea cuya ejecuci√≥n no afectar√° los resultados de este programa.  Se trata de analizar la <code>bar</code> funciones.  ¬øPor qu√© el an√°lisis de esta funci√≥n no es pr√°ctico?  La cuesti√≥n es que la funci√≥n de <code>bar</code> , al menos en el fragmento de c√≥digo presentado, nunca se llama.  Este ejemplo simple puede parecer exagerado, pero muchas aplicaciones reales tienen una gran cantidad de funciones que nunca se llaman. <br><br>  En tal situaci√≥n, en lugar de analizar la funci√≥n de <code>bar</code> , simplemente podemos registrar que se declara, pero que no se usa en ninguna parte.  Al mismo tiempo, el an√°lisis real de esta funci√≥n se realiza cuando es necesario, justo antes de su ejecuci√≥n.  Naturalmente, cuando se realiza un an√°lisis lento, debe detectar el cuerpo de la funci√≥n y hacer un registro de su declaraci√≥n, pero aqu√≠ es donde termina el trabajo.  Para tal funci√≥n, no es necesario formar un √°rbol de sintaxis abstracta, ya que el sistema no tiene informaci√≥n de que esta funci√≥n est√© planeada para realizarse.  Adem√°s, la memoria de almacenamiento din√°mico no est√° asignada, lo que generalmente requiere considerables recursos del sistema.  En pocas palabras, la negativa a analizar funciones innecesarias conduce a un aumento significativo en el rendimiento del c√≥digo. <br><br>  Como resultado, en el ejemplo anterior, el analizador real formar√° una estructura similar al siguiente esquema. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3bb/202/a4d/3bb202a4de7b21c31cff3648403096ac.png"></div><br>  <i><font color="#999999">Resultado del an√°lisis del c√≥digo de ejemplo con optimizaci√≥n</font></i> <br><br>  Tenga en cuenta que el analizador hizo una nota sobre la declaraci√≥n de la <code>bar</code> funciones, pero no se ocup√≥ de su an√°lisis posterior.  El sistema no hizo ning√∫n esfuerzo por analizar el c√≥digo de funci√≥n.  En este caso, el cuerpo de la funci√≥n era un comando para devolver el resultado de c√°lculos simples.  Sin embargo, en la mayor√≠a de las aplicaciones del mundo real, el c√≥digo de funci√≥n puede ser mucho m√°s largo y complejo, y contiene muchos comandos de retorno, condiciones, bucles, comandos de declaraci√≥n de variables y funciones anidadas.  Analizar todo esto, siempre que tales funciones nunca se llamen, es una p√©rdida de tiempo. <br><br>  No hay nada complicado en el concepto descrito anteriormente, pero su implementaci√≥n pr√°ctica no es una tarea f√°cil.  Aqu√≠ examinamos un ejemplo muy simple y, de hecho, al decidir si un determinado fragmento de c√≥digo tendr√° demanda en un programa, es necesario analizar funciones, bucles, operadores condicionales y objetos.  En general, podemos decir que el analizador necesita procesar y analizar absolutamente todo lo que est√° en el programa. <br><br>  Aqu√≠, por ejemplo, hay un patr√≥n muy com√∫n para implementar m√≥dulos en JavaScript: <br><br><pre> <code class="hljs actionscript"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> myModule = (<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{   <span class="hljs-comment"><span class="hljs-comment">//      //    })();</span></span></code> </pre> <br>  La mayor√≠a de los analizadores JS modernos reconocen este patr√≥n; para ellos es una se√±al de que el c√≥digo ubicado dentro del m√≥dulo debe analizarse completamente. <br><br>  Pero, ¬øqu√© pasar√≠a si los analizadores sint√°cticos siempre usaran el an√°lisis lento?  Esto, desafortunadamente, no es una buena idea.  El hecho es que con este enfoque, si es necesario ejecutar alg√∫n c√≥digo lo antes posible, encontraremos una desaceleraci√≥n en el sistema.  El analizador realizar√° una pasada de an√°lisis diferido, despu√©s de lo cual comenzar√° a analizar inmediatamente lo que debe hacerse lo antes posible.  Esto conducir√° a una desaceleraci√≥n de aproximadamente el 50% en comparaci√≥n con el enfoque cuando el analizador comienza inmediatamente a analizar completamente el c√≥digo m√°s importante. <br><br><h2>  <font color="#3AC1EF">Optimizaci√≥n de c√≥digo, teniendo en cuenta las caracter√≠sticas de su an√°lisis.</font> </h2><br>  Ahora que hemos descubierto un poco sobre lo que est√° sucediendo dentro de los analizadores, es hora de pensar qu√© se puede hacer para ayudarlos.  Podemos escribir c√≥digo para que el an√°lisis de funciones se realice en el momento que lo necesitemos.  Hay un patr√≥n que la mayor√≠a de los analizadores entienden.  Se expresa en el hecho de que las funciones est√°n entre corchetes.  Tal dise√±o casi siempre le dice al analizador que la funci√≥n necesita ser desmontada inmediatamente.  Si el analizador detecta un par√©ntesis de apertura, inmediatamente despu√©s de lo cual sigue la declaraci√≥n de la funci√≥n, comenzar√° inmediatamente a analizar la funci√≥n.  Podemos ayudar al analizador aplicando esta t√©cnica al describir las funciones que deben realizarse lo antes posible. <br><br>  Supongamos que tenemos una funci√≥n <code>foo</code> : <br><br><pre> <code class="hljs powershell"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x)</span></span></span></span> {   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x * <span class="hljs-number"><span class="hljs-number">10</span></span>; }</code> </pre> <br>  Dado que no hay una indicaci√≥n expl√≠cita en este fragmento de c√≥digo de que esta funci√≥n est√° programada para ejecutarse de inmediato, el navegador solo realizar√° su an√°lisis diferido.  Sin embargo, estamos seguros de que necesitaremos esta funci√≥n muy pronto, por lo que podemos recurrir al pr√≥ximo truco. <br><br>  Primero, guarde la funci√≥n en una variable: <br><br><pre> <code class="hljs actionscript"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> foo = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x)</span></span></span><span class="hljs-function"> </span></span>{   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x * <span class="hljs-number"><span class="hljs-number">10</span></span>; };</code> </pre> <br>  Tenga en cuenta que dejamos el nombre de la funci√≥n inicial entre la palabra clave de la <code>function</code> y el par√©ntesis de apertura.  No se puede decir que esto sea absolutamente necesario, pero se recomienda hacer exactamente eso, porque si se lanza una excepci√≥n cuando la funci√≥n se est√° ejecutando, puede ver el nombre de la funci√≥n en los datos de seguimiento de la pila, no <code>&lt;anonymous&gt;</code> . <br><br>  Despu√©s del cambio anterior, el analizador continuar√° utilizando el an√°lisis lento.  Para cambiar esto, un peque√±o detalle es suficiente.  La funci√≥n debe estar entre corchetes: <br><br><pre> <code class="hljs actionscript"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> foo = (<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x)</span></span></span><span class="hljs-function"> </span></span>{   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x * <span class="hljs-number"><span class="hljs-number">10</span></span>; });</code> </pre> <br>  Ahora, cuando el analizador encuentre un par√©ntesis de apertura frente a la palabra clave de la <code>function</code> , comenzar√° a analizar esta funci√≥n de inmediato. <br><br>  Puede que no sea f√°cil realizar tales optimizaciones manualmente, porque para esto necesita saber en qu√© casos el analizador realizar√° un an√°lisis lento y en qu√© casos el completo.  Adem√°s, para hacer esto, debe dedicar tiempo a decidir si una funci√≥n en particular debe estar lista para trabajar lo m√°s r√°pido posible o no. <br><br>  Los programadores, por supuesto, no querr√°n asumir todo este trabajo adicional.  Adem√°s, lo cual no es menos importante que todo lo que ya se ha dicho, el c√≥digo procesado de esta manera ser√° m√°s dif√≠cil de leer y comprender.  En esta situaci√≥n, los paquetes de software especiales como Optimize.js est√°n listos para ayudarnos.  Su objetivo principal es optimizar el tiempo de arranque inicial para el c√≥digo fuente JS.  Realizan an√°lisis de c√≥digo est√°tico y lo modifican para que las funciones que deban ejecutarse lo antes posible est√©n entre corchetes, lo que lleva al hecho de que el navegador las analiza de inmediato y las prepara para su ejecuci√≥n. <br><br>  Entonces, supongamos que programamos, sin pensar realmente en nada, y tenemos el siguiente fragmento de c√≥digo: <br><br><pre> <code class="hljs matlab">(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> {   </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">console</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">log</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">('Hello, World!')</span></span></span><span class="hljs-function">; })</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">;</span></span></code> </pre> <br>  Parece bastante normal, funciona como se esperaba, se ejecuta r√°pidamente, ya que el analizador encuentra el par√©ntesis de apertura frente a la palabra clave de <code>function</code> .  Hasta ahora todo bien. ,       ,     ,    : <br><br><pre> <code class="hljs matlab">!<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">{</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">console</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">log</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">('Hello, World!')</span></span></span><span class="hljs-function">}</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">;</span></span></code> </pre> <br>     ,    ,   .   ,   -        . <br><br>   ,      ,      .  ,     , ,         .  ,  ,    ,        .     ,        ,    .         Optimize.js.       Optimize.js,    : <br><br><pre> <code class="hljs matlab">!(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">{</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">console</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">log</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">('Hello, World!')</span></span></span><span class="hljs-function">})</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">;</span></span></code> </pre> <br>      ,   .    ,   .       ,   ,         ,   ‚Äî     . <br><br><h2> <font color="#3AC1EF"> </font> </h2><br>  ,  JS-   ‚Äî ,    .        ?   ,           ,  , ,          .   ,    ,  ,    ,    JS-      ,          .  ,    ,       ,   -,        .       -  .       ,   ,    .          ,     , , ,              .  , JS-     ,  ,   V8     ,   ,     .                 . <br><br><h2> <font color="#3AC1EF">  </font> </h2><br>   ,       -: <br><br><ul><li>   .    . </li><li>       ,       . </li><li> ,   ,   ,  JS-.          ,     ,   . </li><li>       DeviceTiming  ,      . </li><li>    Optimize.js  ,      ,         . </li></ul><br><h2>  <font color="#3AC1EF">Resumen</font> </h2><br>    ,    ,     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">SessionStack</a> ,      ,    -,       .     ,         .     ‚Äî       . ,     ‚Äî    ,      -,  ,       ,       . <br><br>  <b>Estimados lectores!</b>     -        JavaScript-? <br><br><div style="text-align:center;"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es415269/">https://habr.com/ru/post/es415269/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es415257/index.html">8 formas de mejorar la visualizaci√≥n de datos</a></li>
<li><a href="../es415259/index.html">select / poll / epoll: diferencia pr√°ctica</a></li>
<li><a href="../es415261/index.html">Artista VFX en desarrollo de juegos: caracter√≠sticas, carrera, desarrollo</a></li>
<li><a href="../es415263/index.html">C√≥mo agregamos entradas al mapa y redujimos el tama√±o de las bases en un 10%</a></li>
<li><a href="../es415265/index.html">Buscando un sucesor del KL-7: RACE y AROFLEX</a></li>
<li><a href="../es415271/index.html">C√≥mo los gr√°ficos de Gantt simplifican la gesti√≥n de proyectos</a></li>
<li><a href="../es415273/index.html">Aprender los conceptos b√°sicos de la programaci√≥n.</a></li>
<li><a href="../es415275/index.html">El libro "C # 7 y .NET Core. Desarrollo multiplataforma para profesionales. 3a edici√≥n</a></li>
<li><a href="../es415277/index.html">Qu√© hay de nuevo en ARKit 2.0</a></li>
<li><a href="../es415279/index.html">¬øPor qu√© clavar clavos con un microscopio si tienes Alpine Linux?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>