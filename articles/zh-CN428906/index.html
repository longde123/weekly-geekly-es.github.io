<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🕖 🈁 👩🏾‍🎤 在拼图脚本上创建拼图游戏 🤛🏾 👂🏿 ⚔️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Puzzle Script是用于为HTML5创建拼图的简约游戏引擎，它具有开放源代码。 可以在此处找到现成游戏的示例。 

 第1部分。我们在Puzzle Script上创建了第一个游戏。 
 Puzzle Script是一个免费的在线程序，用于创建益智游戏。 她以创造像我的Nodus之类的难题而闻...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>在拼图脚本上创建拼图游戏</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/428906/">  Puzzle Script是用于为HTML5创建拼图的简约游戏引擎，它具有开放源代码。 可以在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">此处</a>找到现成游戏的示例。 <br><br><h2> 第1部分。我们在Puzzle Script上创建了第一个游戏。 </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Puzzle Script</a>是一个免费的在线程序，用于创建益智游戏。 她以创造像我<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">的Nodus之</a>类的难题而闻名。 在这一部分中，我们将创建一个游戏，研究了Puzzle Script的基本功能，接下来，我们将开始编程。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/29c/ad5/268/29cad52687d6dac4be118a343acdd4c6.gif"></div><br> 转到引擎<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">网站</a> 。 单击“ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">制作游戏”</a>以打开“ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">拼图脚本”编辑器</a> 。 <br><a name="habracut"></a><br><h2> 下载范例 </h2><br> 首先，让我们看几个例子。 在屏幕顶部，打开“加载示例”列表，然后选择第一个示例“基本”。 现在点击“运行”。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5b6/67f/473/5b667f473e13438840c8447d71753f44.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9b4/391/ed3/9b4391ed35f1fecb29379cc35f968a5c.png"></div><br> 出现游戏画面。 在其窗口内单击，然后按键盘上的Enter。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a75/9be/690/a759be690ae818a3c878adb44fe90d29.png"></div><br> 尝试玩游戏。 您的目标是将橙色框推到黑色目标正方形。 当每个目标上都有一个框时，将通过级别。 您可以按Z取消移动，或按R重新启动级别。 <br><br><h2> 制作第一个游戏 </h2><br> 现在，我们将创建几个级别。 我将与您一起创造一个，并建议其他人提出自己的想法。 单击顶部菜单中的“关卡编辑器”。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/664/331/1c5/6643311c5e2c10fb4fac5766c21bf5be.png"></div><br> 如果您没有看到关卡编辑器屏幕，则单击“运行”并启动游戏。 进入关卡后，再次单击“关卡编辑器”按钮。 这样您就可以编辑自己的水平。 <br><br><h2> 创建一个新的关卡 </h2><br> 最上方是游戏对象。 左键单击时，将绘制选定的对象。 右键单击将绘制一个“背景”对象。 左键单击地图边缘会增加其大小，右键单击会减小其大小。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/aa8/8a6/2c8/aa88a62c8f10af011f8ac761b6e7d8a6.gif"></div><br> 要通过一个级别，您需要在每个目标上放一个方框，因此在每个级别上都应该有一个最低要求： <br><br><ul><li>  1盒 </li><li>  1球 </li><li>  1名球员 </li></ul><br> 右键单击将所有内容变成草。 然后，在级的边缘上单击鼠标左键以使其变大，最后绘制一个类似于下图所示的级。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/62a/fbb/f7f/62afbbf7f15b7a8368740e55afe4e04a.png"></div><br><h2> 将其添加到级别列表。 </h2><br> 完成创建关卡后，我们将其添加到关卡列表中。 在关卡编辑器中，单击游戏对象列表旁边的白色字母S以保存创建的关卡。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3de/c4d/298/3dec4d298ec1ea3c2d15e3fb1383341e.png"></div><br> 级别编辑器下方应显示一条有关成功编译的信息，并包含一些有趣的字符，如下所示。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9d6/810/3f3/9d68103f3d96a705e188940bea4767a1.png"></div><br> 这些有趣的字符表示我们刚刚创建的级别。 每个字符代表一个单独的对象。 在屏幕左侧，向下找到“传奇”。 图例提供了每个字符的说明： <br><br><blockquote>  <strong>。</strong>  <strong>=背景</strong> <br>  <strong>＃=墙</strong> <br>  <strong>P =玩家</strong> <br>  <strong>* =板条箱</strong> <br>  <strong>@ =板条箱和目标</strong> <br>  <strong>O =目标</strong> </blockquote><br> 屏幕左侧的所有内容都是游戏代码，分为不同的部分，例如OBJECTS或LEGEND。 转到LEVELS。 在这里，我们看到了示例中使用的级别。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a07/c51/530/a07c515308c753e5ea4aad72c60b35a2.png"></div><br> 要添加新级别，请在级别部分的底部创建一个新的空行。 然后复制为我们的关卡生成的字符并将其粘贴到此处。 所有级别已添加。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b79/9ab/86b/b799ab86b79fb78def34aa27d274855c.png"></div><br> 我们将对其进行测试。 创建新关卡后，您需要再次按屏幕顶部的“运行”按钮，以新关卡重新启动游戏。 有时这不起作用，然后您需要单击“重建”按钮，然后再次单击“运行”。 <br><br><h2> 保存和加载游戏 </h2><br> 尝试创建更多新的关卡。 准备好保存游戏后，转到代码开头，输入您自己的姓名，作者的姓名和主页，然后单击“保存”按钮。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a3f/0b9/27e/a3f0b927e1711b3bbf0c607ffcb019b2.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a0b/362/ebb/a0b362ebbfd305a44fc5f78b3b16bb02.png"></div><br> 数量有限的保存存储在计算机的“加载”菜单中。 但是，屏幕顶部有一个“共享”按钮。 当您单击它时，将生成带有两个Web链接的消息。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/335/876/037/335876037ebb3769c118a309f90619f4.png"></div><br> 链接之一是您的项目的源代码。 第二个是指向您可以与朋友分享的游戏可玩版本的链接。 我建议定期创建一个到源代码的新链接，并将其保存在某些文本文档中，以便您拥有该项目的永久存储版本。 <br><br><h2> 游戏导出 </h2><br> 您也可以将游戏导出为html5文件，然后将其上传到<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">itch.io</a> ， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Kongregate</a>或<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Newgrounds</a>等游戏门户。 只需单击“导出”，然后将下载的html文件上传到游戏门户。 <br><br> 我们的示例项目可以在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">这里</a>找到。 <br><br><h2> 第2部分。Puzzle脚本入门 </h2><br> 在这一部分中，我们将学习如何在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Puzzle Script中</a>开始编程。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/29c/ad5/268/29cad52687d6dac4be118a343acdd4c6.gif"></div><br><h2> 代号 </h2><br> 打开一个<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">示例项目</a> 。 程序代码在屏幕的左侧，分为以下部分：对象，图例，声音等。 在“规则”部分中，设置了对象交互的规则。 进去吧 应该只有一行代码： <br><br><blockquote><code><strong>[ &gt; Player | Crate ] -&gt; [ &gt; Player | &gt; Crate ]</strong></code> </blockquote> <br> 这条线表示，如果玩家靠近箱子并朝他的方向移动，则游戏将移动玩家并推动箱子。 为了解释它是如何工作的，您需要了解拼图脚本代码遵循以下结构： <br><br><blockquote> <code><strong>[  ] -&gt; [  ]</strong></code> </blockquote> <br> 这意味着： <br><br><blockquote> <code><strong>[     ] -&gt;  [   ]</strong></code> </blockquote> <br>  Puzzle Script检查箭头左侧的条件，例如，玩家的对象是否在盒子对象旁边。 如果条件为真，那么我们可以做一些事情，例如，推箱子。 <br><br><h2> 条件示例 </h2><br> 这是条件的示例： <br><br><blockquote> <code><strong>[ object1 | object2 ]</strong></code> </blockquote> <br> 此事件检查object1是否在object2旁边。 您可以通过放置<code><strong> | </strong></code>检查两个对象是否彼此相邻<code><strong> | </strong></code> 通过按Shift + \输入的<code><strong> | </strong></code> 。 条件总是括在<code><strong> [ ] </strong></code> 。 <br><br><blockquote> <code><strong>[ crate | crate ]</strong></code> </blockquote> <br> 上面的代码检查两个框是否彼此相邻。 <br><br><blockquote> <code><strong>[ crate | crate | crate ]</strong></code> </blockquote> <br> 此条件检查附近是否有三个盒子。 <br><br><blockquote> <code><strong>[ crate target ]</strong></code> </blockquote> <br> 此条件检查该框是否在目标的顶部，因为<code><strong> | </strong></code> 两个对象之间<code><strong> | </strong></code> 。 如果对象位于碰撞的不同层中，则它们可以彼此重叠，我们将在本教程的以下部分中介绍这些对象。 <br><br><h2> 我们保持平等 </h2><br> 规则必须平衡。 条件检查和其后的事件都应以相同的方式描述。 我将说明这意味着什么。 <br><br><blockquote> <code><strong>[ player | crate ] -&gt; [ player | ]</strong></code> </blockquote> <br> 如果玩家在盒子旁边，那么这行代码会破坏盒子。 您不能写： <br><br><blockquote> <code><strong>[ player | crate ] -&gt; [ player ]</strong></code> </blockquote> <br> 因为左侧条件检查两个单独的网格空间中是否存在相邻对象，但是该事件仅描述了玩家占用的一个网格空间。 拼图脚本需要知道如何处理其检查的空间。 销毁盒子的正确代码应报告以下内容： <br><br><blockquote> <code><strong>[   |    ] -&gt;  [     |   ]</strong></code> </blockquote> <br><blockquote> <code><strong>[ player | crate ] -&gt; [ player | ]</strong></code> </blockquote> <br> 也就是说，即使代码中的空白也很重要。 但是，以下条目有效： <br><br><blockquote> <code><strong>[ player target ] -&gt; [ player ]</strong></code> </blockquote> <br> 由于在这种情况下，我们仅讨论一个网格空间，所以该事件描述了相同的网格空间。 <br><br><h2> 如何移动盒子 </h2><br> 让我们回到原始代码行。 <br><br><blockquote> <code><strong>[ &gt; Player | Crate ] -&gt; [ &gt; Player | &gt; Crate ]</strong></code> </blockquote> <br> 换句话说： <br><br><blockquote> <code><strong>[      |      ] -&gt;  [   |   ]</strong></code> </blockquote> <br>  《箭头》强调运动。 <br><br> 有时我们需要写注释以记住代码的作用。 拼图脚本会忽略注释-它们仅用于用户。 要发表评论，您需要将文本放在方括号中。 我们在规则中写了一条注释，描述了它的作用： <br><br><blockquote> <code><strong>(  ) <br> [ &gt; Player | Crate ] -&gt; [ &gt; Player | &gt; Crate ]</strong></code> </blockquote> <br> 现在，在“推送代码”框中，输入以下内容： <br><br><blockquote> <code><strong>(  ) <br> [ &lt; Player | Crate ] -&gt; [ &lt; Player | &lt; Crate ]</strong></code> </blockquote> <br> 倒箭头表示如果玩家离开箱子，他将拉箱子。 单击“运行”以测试此操作。 您应该能够推和拖箱子。 在编程中，即使在一个字母中有错字，计算机也可能无法理解该代码，因此请消除所有错误。 更改代码时，再次单击“运行”以下载更改。 如果游戏无法正常运行，请尝试单击“重建”以清除程序的内存，然后单击“运行”。 <br><br> 有时有必要停用一行代码。 只需将其变成注释以保存将来。 让我们注释一下推动盒子的代码，以便播放器只能携带盒子： <br><br><blockquote> <code><strong>(  ) <br> ([ &gt; Player | Crate ] -&gt; [ &gt; Player | &gt; Crate ]) <br> (  ) <br> [ &lt; Player | Crate ] -&gt; [ &lt; Player | &lt; Crate ]</strong></code> </blockquote> <br> 如果可行，请注释掉拉出框的代码，然后尝试以下操作： <br><br><blockquote> <code><strong>[ &lt; Player | Crate ] -&gt; [ &lt; Player | &gt; Crate ]</strong></code> </blockquote> <br> 如果播放器远离盒子，播放器和盒子将朝相反的方向移动。 箭头确定对象向哪个方向移动或将向哪个方向移动。 现在将其注释掉，然后尝试以下操作： <br><br><blockquote> <code><strong>[ &gt; Player | Crate ] -&gt; [ Player | &gt; Crate ]</strong></code> </blockquote> <br> 盒子移动了，但是播放器仍然留在原地。 尝试^和v（字母v），以查看对象如何移动。 <br><br><h2> 失误 </h2><br> 让我们故意写错规则，看看会发生什么。 输入以下行： <br><br><blockquote> <code><strong>[ &lt; Player | Crate ] -&gt; [ &lt; Player ]</strong></code> </blockquote> <br> 尝试运行该程序。 您应该看到以下消息： <br><br><blockquote>  <strong>第81行：通常，左侧要匹配的每个模式都必须在右侧具有相等长度（单元数）的相应模式。</strong> </blockquote><br> 通常，Puzzle Script可以很好地描述错误。 但是，有时拼图脚本本身就是错误的。 在这种情况下，您需要亲自检查代码并找出错误所在。 <br><br><h2> 更多实验 </h2><br> 尝试尝试并自己编写规则。 这里有一些例子。 <br><br><blockquote> <code><strong>[ &gt; Player | … | Crate ] -&gt; [ &gt; Player | … | &gt; Crate ]</strong></code> </blockquote> <br> 在上面的示例中，如果玩家在关卡的同一行上的任意位置，则他们将按下该框，然后玩家将移至该框。 <br><br><blockquote> <code><strong>[ &gt; Player | Crate ] -&gt; [ Crate | Player ]</strong></code> </blockquote> <br> 此代码交换播放器和盒子。 <br><br><blockquote> <code><strong>[ &gt; Player | Crate ] -&gt; [ Player | Target ]</strong></code> </blockquote> <br> 在此代码中，如果玩家靠近盒子并朝盒子移动，则玩家将停止移动，但盒子会变成目标。  Puzzle Script最好的事情是易于创建新事物和进行实验的可能性。 <br><br><h2> 第3部分。创建对象 </h2><br> 拼图脚本上游戏中的所有图形片段均指示对象。 要在Puzzle Script上创建游戏，您必须创建自己的对象。 在这一部分中，我将告诉您如何创建它们并将它们添加到我的代码中。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a75/9be/690/a759be690ae818a3c878adb44fe90d29.png"></div><br><h2> 一般资讯 </h2><br> 打开一个<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">示例项目</a> 。 创建对象的过程包括以下步骤： <br><br><ul><li> 在对象列表中创建它 </li><li> 向图例添加项目 </li><li> 向图层添加碰撞 </li></ul><br> 完成所有这些步骤后，就可以开始使用该对象了。 <br><br><h2> 对象创建 </h2><br> 已经存在几个对象。 每个游戏必须有一个背景对象。 所有对象均由5 x 5像素的网格创建，并至少具有一种颜色。 背景对象如下所示。 <br><br><blockquote> <code><strong>Background</strong> <br> <strong>LIGHTGREEN GREEN</strong> <br> <strong>11111 <br> 01111 <br> 11101 <br> 11111 <br> 10111</strong></code> </blockquote> <br> 数字表示图像中的像素。 每个数字对应其颜色。 第一种颜色的数字为0，第二种颜色的数字为1，依此类推，最多9种。最多可以有10种颜色。 在我们的例子中，每个1为像素以浅绿色（Light Green）着色，为0-以绿色（Green）着色。 结果看起来像这样： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1d9/f68/1dd/1d9f681dd516763462a8541954a320a4.png"></div><br> 始终按以下方式创建对象： <br><br><ul><li> 职称 </li><li> 色彩 </li><li> 图片 </li></ul><br> 名称始终在第一行。 颜色始终位于第二行，图像采用接下来的5行，每行5个字符，形成5 x 5的网格，或者您可以执行以下操作： <br><br><blockquote> <code><strong>Background</strong> <br> <strong>LIGHTGREEN</strong></code> </blockquote> <br> 此代码将创建一个称为“背景”的对象，该对象将是一个5 x 5像素的浅绿色网格。 如果您不描述图像网格，那么我们会得到一个纯色块，这有时会很有用。 <br><br><h2> 给对象命名 </h2><br> 可以随意调用对象，但是名称不能以符号开头，并且必须是一个不带空格的单词。 给对象指定清晰的名称，但不要太过分。  PlayerStill是个好名字，PlayerThatIsStandingStill太长且太冗长。 <br><br><h2> 色彩 </h2><br> 您必须声明要用于对象的颜色，并用空格分隔它们。 拼图脚本具有预定义的颜色： <br><br><ul><li> 黑色的 </li><li> 白色 </li><li> 灰色的 </li><li> 深灰色 </li><li> 浅灰色 </li><li> 灰色的 </li><li> 深灰色 </li><li> 浅灰色 </li><li> 红色的 </li><li> 暗红色 </li><li> 淡红色 </li><li> 棕褐色 </li><li> 黑褐色 </li><li> 浅褐色 </li><li> 橙色 </li><li> 黄色的 </li><li> 绿色的 </li><li> 深绿色 </li><li> 浅绿色 </li><li> 蓝色的 </li><li> 浅蓝色 </li><li> 深蓝色 </li><li> 紫色的 </li><li> 粉红色 </li><li> 透明的 </li></ul><br> 您还可以将颜色设置为十六进制，这为我们提供了更广泛的颜色范围。 您可以使用诸如此类的网站来选择十六进制颜色。 选择所需的颜色，然后在图像上方重写颜色代码。 十六进制颜色代码按以下方式用拼图脚本编写： <br><br><blockquote> <code><strong></strong> <br> <strong>#51A2BD #ff0000 #ffffff</strong></code> </blockquote> <br> 颜色代码始终以＃字符开头。 <br><br><h2> 向图例添加对象 </h2><br> 创建对象后，需要将其添加到图例中。 图例如下所示： <br><br><blockquote> <code><strong>. = Background</strong> <br> <strong># = Wall</strong> <br> <strong>P = Player</strong> <br> <strong>* = Crate</strong> <br> <strong>@ = Crate and Target</strong> <br> <strong>O = Target</strong></code> </blockquote> <br> 每个符号代表一个关卡中的一个对象。 也就是说，当我们看到这样的字符网格时： <br><br><blockquote> <code><strong>#p.*.##</strong> <br> <strong>#.**.##</strong> <br> <strong>#..#..#</strong> <br> <strong>##....#</strong> <br> <strong>##...o#</strong> <br> <strong>#######</strong></code> </blockquote> <br> 它实际上描述了我们的水平： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c0c/066/14b/c0c06614b8f1653a46ce44e47ad9288f.png"></div><br> 必须为每个创建的对象分配一个字母，符号或数字，以指定该对象在级别上。 像这样： <br><br><blockquote> <code><strong>P = player</strong></code> </blockquote> <br><h2> 在图例中对对象进行分组 </h2><br> 我们还可以在图例中创建对象组。 例如，如果我们有几个彩色框，那么我们可以这样做： <br><br><blockquote> <code><strong>O = OrangeCrate</strong> <br> <strong>B = BlueCrate</strong> <br> <strong>G = GreenCrate</strong></code> </blockquote> <br> 这将使我们能够使用编辑器级别的框。 但是要创建代码，您可以将它们组合在Legend中，如下所示： <br><br><blockquote> <code><strong>Crates = OrangeCrate or GreenCrate or BlueCrate</strong></code> </blockquote> <br> 所有这些看起来像这样： <br><br><blockquote> <code><strong>=======</strong> <br> <strong>LEGEND</strong> <br> <strong>=======</strong> <br> <strong>O = OrangeCrate</strong> <br> <strong>B = BlueCrate</strong> <br> <strong>G = GreenCrate</strong> <br> <br> <strong>Crates = OrangeCrate or GreenCrate or BlueCrate</strong></code> </blockquote> <br> 为什么这样 因为那样，而不是创建这样的规则： <br><br><blockquote> <code><strong>[ &gt; Player | OrangeCrate ] -&gt; [ &gt; Player | &gt; OrangeCrate ]</strong> <br> <strong>[ &gt; Player | BlueCrate] -&gt; [ &gt; Player | &gt; BlueCrate ]</strong> <br> <strong>[ &gt; Player | GreenCrate] -&gt; [ &gt; Player | &gt; GreenCrate]</strong></code> </blockquote> <br> 您可以简单地写： <br><br><blockquote> <code><strong>[ &gt; Player | Crates ] -&gt; [ &gt; Player | &gt; Crates ]</strong></code> </blockquote> <br> 此代码将适用于整个对象组。 <br><br> 此外，在“ <strong>碰撞层”</strong>部分中，您可以引用组所在的层，而不必输入每个单独的对象。 <br><br><h2> 碰撞层 </h2><br> 默认情况下，碰撞层部分如下： <br><br><blockquote> <code><strong>Background</strong> <br> <strong>Target</strong> <br> <strong>Player, Wall, Crate</strong></code> </blockquote> <br> 每行选择其自己图层中的对象。 对象层的顺序确定哪些对象将位于其他对象之上。 顶行中的对象将在最底层，下一行将在其上方的层，依此类推。 背景应始终位于最顶层，位于最底层。 一层中的对象不能彼此重叠。 也就是说，这不能是： <br><br><blockquote> <code><strong>[ player wall ] -&gt; [ player wall ]</strong></code> </blockquote> <br> 您可以使不同层中的对象相互交互。 例如，您可以编写： <br><br><blockquote> <code><strong>[ &gt; Player | Target ] -&gt; [ &gt; Player | &gt; Target ]</strong></code> </blockquote> <br><h2> 实验 </h2><br> 创建一些新对象。 创建只能推入的盒子类型。 创建另一个只能拖动的框。 创建一个框，当您触摸它时会消失。 继续进行实验，您将更好地记住所有步骤。 <br><br><h2> 第4部分。胜利条件 </h2><br> 每个人都喜欢赢。 我们作为玩家，想赢。 在这一部分中，我们将学习如何对赢得比赛的条件进行编程。 <br><br><h2> 胜利条件 </h2><br> 下载<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">示例项目，</a>然后转到“赢得条件”代码部分。 您应该看到以下内容： <br><br><blockquote> <code><strong>All Target on Crate</strong></code> </blockquote> <br> 如果每个目标上都有一个方框，则赢得比赛。 如果您有3个框和2个进球，那么您只需在目标上设置2个框即可获胜。 如果交换： <br><br><blockquote> <code><strong>All crate on target</strong></code> </blockquote> <br> 那么每个盒子都必须对准目标。 <br><br> 可能存在一个或多个条件。 在多种情况下，必须全部满足。 例如，我们可能具有以下内容： <br><br><blockquote> <code><strong>All Target on Crate</strong> <br> <strong>All Target2 on Crate2</strong></code> </blockquote> <br> 如果级别具有target和target2，则分别为crate和crate2。 如果在某个级别上没有满足某个胜利条件所需的对象之一，例如，没有target2，则自动满足此条件。 <br><br><h2> 不同类型的胜利条件 </h2><br> 有几种不同类型的胜利条件。 <br><br><blockquote> <code><strong>No Object</strong></code> </blockquote> <br> 在这种情况下，当没有一个这样的目标时，胜利就来了。 <br><br><blockquote> <code><strong>Some Object</strong></code> </blockquote> <br> 当关卡上至少有一个指定类型的对象时，您将获胜。 <br><br><blockquote> <code><strong>Some Object1 on Object2</strong></code> </blockquote> <br>  Object1的至少一个对象必须在Object2上。 <br><br><blockquote> <code><strong>No Object1 On Object2</strong></code> </blockquote> <br> 此条件与“ <code><strong>All Target on Crate</strong></code>的<code><strong>All Target on Crate</strong></code> ”相反。 在这种情况下，我们需要所有这些对象彼此分开，而不是彼此重叠。 您也可以将不同的胜利条件相互结合。 <br><br><h2> 实验 </h2><br> 我们将尝试不同的胜利条件。 如果所有箱子都未对准目标，则尝试创建一个赢球的游戏。 或制作一个游戏，其中您需要销毁某种类型的所有盒子，但还有其他推动盒子的方式。 <br><br> 我完成的示例项目可以在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">这里</a>查看。 <br><br><h2> 第5部分。后期命令 </h2><br>  PuzzleScript有一个非常有用的命令，称为“ late”。 游戏中事件起源的顺序很重要，有时您需要稍后执行的代码才能获得所需的结果。 在这一部分中，我将讨论使用<strong>late</strong>命令。 <br><br><h2> 我们为什么需要它 </h2><br> 打开<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">一个示例项目</a> ，然后将以下代码粘贴到游戏中并运行它： <br><br><blockquote> <code><strong>[ player | target ] -&gt; [ player | ]</strong></code> </blockquote> <br> 可以预料，只要玩家站在球门旁，球门就会被破坏，但这不会发生。 相反，目标在玩家旁边站立<strong><em>后</em></strong>消失在路线中。 因此，尝试另一个代码： <br><br><blockquote> <code><strong>late [ player | target ] -&gt; [ player | ]</strong></code> </blockquote> <br> 只要您站在目标旁边，目标就会消失。 发生这种情况是因为指定为<strong>延迟的</strong>所有事情都在所有其余代码执行完之后发生。 有时这是必要的。 <br><br><h2> 事件顺序 </h2><br> 这是拼图脚本中的代码一步一步执行的方式。 <br><br><ol><li> 拼图脚本发现玩家想要移动 </li><li> 只要有可能，规则就会从上至下读取并执行。 </li><li> 玩家尽可能移动 </li><li> 逾期规则适用 </li></ol><br> 计算机从代码的第一行开始，然后逐行读取。 检查每个条件。 因此，当您尝试四处移动时，Puzzle Script会读取所有规则并检查条件是否成立，如果满足，则执行某些操作。 例如，第一行可能是这样的： <br><br><blockquote> <code><strong>[ player | spikeTrap ] -&gt; [ | spikeTrap ]</strong></code> </blockquote> <br> 如果玩家没有站在筹码陷阱旁边，则代码将继续执行。 这意味着编写代码行的顺序很重要。 在某些情况下，您可以使用late命令，您将在实践中随着时间的推移学习该命令。 <br><br><h2> 后期使用方法 </h2><br> 以我的经验，最好在检查对象是否彼此重叠或相邻时使用late命令，但是还有其他情况。 如果您检查一个对象是否在另一个对象上，那么除非下一个命令使用，否则该事件将直到下一轮才注册： <br><br><blockquote> <code><strong>[ player spikeTrap ] -&gt; [ spikeTrap ]</strong></code> </blockquote> <br> 在上述情况下，直到进入陷阱后的下一回合，玩家才会被带木桩的陷阱杀死。 要使玩家立即死亡，只需添加late命令， <br><br><blockquote> <code><strong>late [ player spikeTrap ] -&gt; [ spikeTrap ]</strong></code> </blockquote> <br> 要在角色死亡时重新启动整个关卡，您可以执行以下操作： <br><br><blockquote> <code><strong>late [ player spikeTrap ] -&gt; restart</strong></code> </blockquote> <br> 当玩家落入木桩陷阱时，关卡将重新开始。 <br><br> 您可以在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">此处</a>看到完成的项目示例。 <br><br><h2> 第6部分。处理声音效果。 </h2><br> 我们在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Puzzle Script</a>上做了一个很棒的游戏，但是现在我们需要为其添加声音。 怎么做？ 现在我告诉你！ <br><br><h2> 声音产生 </h2><br> 打开一个<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">示例项目</a> 。 给它添加声音。 在游戏屏幕下，您可以看到带有白色符号的黑色正方形。 它们用于产生声音。 每个角色都会产生独特的声音类型，并且叉号会删除所创建的声音。 尝试单击正方形，然后听声音。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b96/a21/bb2/b96a21bb2a86c3cb300a8840cc601162.png"></div><br> 黄色数字是唯一的代码，需要复制并粘贴到需要声音的代码中。 <br><br><h2> 如何使用声音 </h2><br> 找到正确的声音后，必须将其插入游戏代码的“ <strong>声音”</strong>部分。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/243/881/847/243881847507555bc9bb470dd89c0a23.png"></div><br> 声音可以通过多种方式使用。 最简单的方法是创建一个新的声音效果（sfx）。 它们必须编号。 我们创建一个新的sfx，在插入数字声音ID时为其分配一个从0到10的数字。 在“声音”列表中，创建一个名为sfx0的新sfx并将其分配给生成的声音： <br><br><blockquote> <code><strong>sfx0</strong> <strong>36301705</strong></code> </blockquote> <br> 要使用声音，您需要在事件之后将其插入规则中。 让我们将新创建的sfx0附加到盒子销毁事件（该事件已经存在于项目示例中）： <br><br><blockquote> <code><strong>(The player destroys a crate)</strong> <br> <strong>[ &gt; Player | CrateVanish ] -&gt; [ Player | ] sfx0</strong></code> </blockquote> <br> 还可以声明声音以进行某些事件的回放，例如： <br><br><blockquote> <code><strong>Crate MOVE 36772507</strong></code> </blockquote> <br> 在这种情况下，移动板条箱时会播放声音。 生成用于拖放CratePull对象的新声音效果，并在移动CratePull时使其播放： <br><br><blockquote> <code><strong>CratePull MOVE 12735307</strong></code> </blockquote> <br> 事件的声音仅应在“声音”部分中声明：它们无需在规则中提及。 <br><br><h2> 声音再现方法列表 </h2><br> 以下是可以使用的各种事件声音的列表，摘自Puzzle Script <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="noopener">文档</a> 。 <br><br>  <strong>对象动作541566-</strong>在移动过程<strong>中将</strong>对象暴露于动作时播放。 <br><br>  <strong>创建对象641667-</strong>创建特定对象时播放。 <br><br>  <strong>EndGame 5416789-</strong>游戏结束时播放。 <br><br>  <strong>EndLevel 6417822-关卡</strong>完成后播放。 <br><br>  <strong>对象CantMove 781673-</strong>当对象尝试在任何方向上移动失败时播放。 <br><br>  <strong>播放器CantMove Down Left Left 464674-</strong>当对象尝试向下或向左移动失败时播放。 <br><br>  <strong>CloseMessage 344456-</strong>当播放器关闭消息框时播放。 <br><br>  <strong>销毁对象187975-销毁</strong>对象时播放。 <br><br>  <strong>对象移动264567-</strong>当对象成功向任意方向移动时播放。 <br><br>  <strong>对象向左下移动765432-</strong>在对象成功向下或向左移动时播放。 <br><br>  <strong>水平移动对象345367-</strong>当对象成功水平移动时播放。 您也可以使用垂直。 <br><br>  <strong>重新启动7865435-</strong>当玩家按下重新启动按钮R时播放。 <br><br>  <strong>SFX0 765743-</strong>可以是从SFX0到SFX10的任何东西。 这些是可以根据规则执行的特殊声音事件。 <br><br>  <strong>ShowMessage 478483-</strong>显示消息时播放。 <br><br>  <strong>StartGame 234626-</strong>在新游戏开始时播放。 <br><br>  <strong>起始级别765436-</strong>在每个级别的开始播放。 <br><br>  <strong>TitleScreen 876543-</strong>加载屏幕保护程序后播放。 <br><br>  <strong>撤消436234-</strong>当玩家按下取消键（Z）时播放。 <br><br> 您可以指定<b>移动</b>和<b>不能</b>移动的方向，以便在朝不同方向移动时会再现不同的声音。 <br><br> 该项目的完成示例在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="noopener">此处</a> 。 <br><br><h2> 第7部分。播放音乐 </h2><br> 我们学习了如何在Puzzle Script上创建游戏，但是向其中添加音乐不是很好吗？ 有可能，现在我将告诉您如何做。 <br><br><blockquote>  <strong>注意：</strong>目前，Puzzle Script中的此功能似乎已损坏，因此继续下一部分。 </blockquote><br><h2> 怎么办 </h2><br> 打开<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">项目空白</a> 。 音乐在Puzzle Script中的工作方式如下：您可以将来自YouTube的单个视频的链接插入游戏中，PuzzleScript将自动播放该视频的所有声音。 打开Youtube并选择任何视频，或使用以下方法： <br><br>  <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">youtube.com/watch?v= <font color="green">CKAc3nYEatw</font></a></strong> <br><br> 要播放视频中的音乐，我们需要获取唯一的视频ID。 上面一行的绿色部分是唯一的ID。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/080/815/064/08081506423f3c795d47f0f242e82ed7.png"></div><br> 在项目开始时在作者的主页下方，添加youtube标签，然后在其后添加唯一的视频ID，例如，如下所示： <br><br>  <strong>youtube CKAc3nYEatw</strong> <br><br> 为确保其正常运行，请单击“共享”，然后单击游戏链接（而非源代码链接）。 在编辑器中进行测试期间，无法播放拼图脚本音乐。 如果您想让游戏带有音乐，则需要将其作为视频上传到Youtube上，并在项目中插入一个唯一的ID。 每个项目只能有一个YouTube视频。 <br><br><h2> 项目实例 </h2><br> 在<strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="noopener">此处</a></strong>可以找到示例拼图脚本项目。 <br><br><h2> 第8部分。如何使用Action命令 </h2><br> 我们已经知道如何移动，推动和拖动块，但是如果我们需要通过按某个键（例如<strong>空格）</strong>来做某事怎么办？ <br><br>  PuzzleScript中的输入可能性非常有限，主要是箭头键，Z可以取消，R可以重新启动，我们无法更改它们。<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">但是引擎为我们提供了一个额外的</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">操作</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">键</font><font style="vertical-align: inherit;">-按下</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">空格键</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">或</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">X</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">键</font><font style="vertical-align: inherit;">。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">与</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">行动</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">小组合作时</font><font style="vertical-align: inherit;">遵循上述格式。</font><font style="vertical-align: inherit;">我们使用了基本的PuzzleScript代码格式：</font></font><br><br><blockquote> <code><b>[  ] -&gt; [  ]</b></code> </blockquote> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如果条件为真，则我们执行事件。</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">操作</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">命令的</font><font style="vertical-align: inherit;">使用方式相同，但是有其自己的规则。</font><font style="vertical-align: inherit;">看起来像这样：</font></font><br><br><blockquote> <code><b>[ Action   ] -&gt; [  ]</b></code> </blockquote> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 这是使用Action命令的示例： </font></font><br><br><blockquote> <code>[ <strong>Action</strong> <em>Player</em> ] -&gt; [ <em>Crate</em> ]</code> </blockquote> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">首先，</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">行动</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">永远是条件的第一句话。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">其次，如果我们想影响游戏中的某个对象，那么我们需要在条件和事件中都提及该对象（如果我们提及另一个对象，程序将删除原始对象，并用新对象替换它，如果您不指定该对象，则他将退休）。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">最后，</font><font style="vertical-align: inherit;">仅应在</font><b><font style="vertical-align: inherit;">条件中</font></b><font style="vertical-align: inherit;">使用</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">动作</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">一词</font><font style="vertical-align: inherit;">，但有时在条件和事件中都值得使用它。我将在下面讨论。</font><font style="vertical-align: inherit;">检查游戏项目中上面显示的代码。您可以</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;">从此示例</font></a><font style="vertical-align: inherit;">开始</font><font style="vertical-align: inherit;">。您会看到按</font><strong><font style="vertical-align: inherit;">空格键</font></strong><font style="vertical-align: inherit;">或</font><strong><font style="vertical-align: inherit;">X时，</font></strong><font style="vertical-align: inherit;">播放器将变成一个盒子。</font></font><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"></font><br><br><font style="vertical-align: inherit;"></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"></font><strong><font style="vertical-align: inherit;"></font></strong><font style="vertical-align: inherit;"></font><strong><font style="vertical-align: inherit;"></font></strong><font style="vertical-align: inherit;"></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">条件显示为[ </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如果按下Action键，</font></font></strong> <em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">并且在该级别上有一个Player对象</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ]-&gt;然后[ </font><em><font style="vertical-align: inherit;">用一个框</font></em></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">替换</font></font></em> <em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">该玩家对象]</font></font></em> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">现在，让我们在项目示例中尝试以下代码：</font></font><br><br><blockquote> <code>[ <strong>Action</strong> Player | Crate ] -&gt; [ Player | &gt; Crate ]</code> </blockquote> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5ef/8d5/17e/5ef8d517e36f7dd7c14eaac6c51686a4.gif"></div><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如上图所示，确保四周都被框包围。</font><font style="vertical-align: inherit;">您会注意到一个动作一次只影响一个盒子。</font><font style="vertical-align: inherit;">我不清楚原因到底是什么，但是如果您想使用</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Action</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">命令影响</font><font style="vertical-align: inherit;">多个对象，则需要在条件和事件中都指定它。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">将代码替换为更新的版本：</font></font><br><br><blockquote> <code>[ <strong>Action</strong> Player | Crate ] -&gt; [ <strong>Action</strong> Player | &gt; Crate ]</code> </blockquote> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/404/87b/a4a/40487ba4ad627d53061ae5c57e97b09f.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">现在我们可以一次推所有箱子。</font><font style="vertical-align: inherit;">如果需要将操作应用于多个对象，则将</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">“操作”</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">放入条件和事件中。</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 第9部分。检查多个条件 </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 让我们学习检查几种情况，例如炸弹和可破坏块的存在。 </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f7f/004/a1e/f7f004a1ef6661dffbc879351b82513d.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">打开一个</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">示例项目</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">现在向其中添加以下代码：</font></font><br><br><blockquote> <code><strong>late [Player Switch][DoorClosed] -&gt; [Player Switch][DoorOpen]</strong></code> </blockquote> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 代码遵循以下格式： </font></font><br><br><blockquote> <code><strong>[  1 ] [  2 ] -&gt; [  1 ] [  2 ]</strong></code> </blockquote> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如果条件1为真，条件2为真，则执行步骤1和步骤2，在本例中，在条件1下，检查播放器是否处于Switch状态。</font><font style="vertical-align: inherit;">如果是，则检查条件2，即是否处于关门水平？</font><font style="vertical-align: inherit;">如果条件为真，则DoorClosed对象将变成DoorOpen对象，从而打开门。</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/110/88a/fdf/11088afdfd4ff8dedd37d4da01ae7566.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">假设我们需要在英雄离开开关时将门关闭，因为我们希望玩家将盒子推到开关上才能打开门。</font><font style="vertical-align: inherit;">您可以这样写：</font></font><br><br><blockquote> <code><strong>late [Player | Switch][DoorOpen] -&gt; [Player | Switch][DoorClosed]</strong></code> </blockquote> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如果玩家站在开关旁边，并且在某个水平位置上有一扇打开的门，则我们将门关闭。</font><font style="vertical-align: inherit;">最后，如果将盒子推到开关上，我们需要使门保持打开状态：</font></font><br><br><blockquote> <code><strong>late [Crate Switch][DoorClosed] -&gt; [Crate Switch][DoorOpen]</strong></code> </blockquote> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">现在，当抽屉在开关上时，门将保持打开状态。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">您可以在</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">此处</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">看到完成的项目示例</font><font style="vertical-align: inherit;">。</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 第10部分。创建断点 </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">也许您对玩解谜脚本有一个好主意，但它需要控制点（检查点），以便玩家在死亡时恢复过来。</font><font style="vertical-align: inherit;">怎么做？</font><font style="vertical-align: inherit;">非常简单，现在我将解释如何。</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5da/7b5/6bd/5da7b56bd4c1a55d0c9f8e1f49d7a7f5.gif"></div><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 创建断点 </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">打开一个</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">示例项目</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">现在我们需要编程一个断点。</font><font style="vertical-align: inherit;">只需一行代码即可满足此要求：</font></font><br><br><blockquote> <code><strong>late [ Player FlagRed ] -&gt; CHECKPOINT</strong></code> </blockquote> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">FlagRed是一个检查点。</font><font style="vertical-align: inherit;">当播放器位于标志上方时，此代码将创建一个检查点（CHECKPOINT）。</font><font style="vertical-align: inherit;">如果不使用较晚，则检查点功能将不起作用。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">测试游戏。</font><font style="vertical-align: inherit;">越过控制点，然后再走一点，然后按R键。您将需要从控制点开始。</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 多个控制点 </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如果有多个控制点，则游戏将使用玩家最后激活的控制点。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">为了避免重新激活已经使用的控制点，您需要将其更改为另一个对象。</font><font style="vertical-align: inherit;">为此，请在代码的“对象”部分的红色标记下创建一个白色副本。</font></font><br><br><blockquote> <code><b>FlagWhite <br> White Orange <br> .1… <br> .00.. <br> .000. <br> .1… <br> .1…</b></code> </blockquote> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 现在，在图例中重写此行： </font></font><br><br><blockquote> <code><strong>Flag = FlagRed or FlagWhite</strong></code> </blockquote> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们可以创建一组对象。</font><font style="vertical-align: inherit;">在这种情况下，Flag将为FlagRed或FlagWhite。</font><font style="vertical-align: inherit;">虽然为分组对象中的至少一个对象分配了一个符号（我们为FlagRed分配了符号F），但是我们不需要将符号分配给该组的其他对象，并且您只能在代码中访问它们，而不能在关卡编辑器中访问它们。</font><font style="vertical-align: inherit;">然后，您可以将碰撞层分配给组，我们已经完成了。</font><font style="vertical-align: inherit;">对一组对象（例如，标志）的访问是指整个组。</font></font>因此： <br><br><blockquote> <code><strong>[ &gt; Player | Flag ] -&gt; [ &gt; Player | ]</strong></code> </blockquote> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 此代码将同时影响红色和白色标志。 </font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 更改标志对象 </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 以下是将FlagRed更改为FlagWhite的方法： </font></font><br><br><blockquote> <code><strong>late [ Player FlagRed ] -&gt; [ Player FlagWhite ]</strong></code> </blockquote> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如果在回合结束时玩家处于红旗上，那么我们将其变为白色。</font><font style="vertical-align: inherit;">但是，</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">创建断点</font><em><font style="vertical-align: inherit;">之后</font></em><font style="vertical-align: inherit;">，您需要更改标志图形</font><font style="vertical-align: inherit;">，因为代码是从上到下读取的。</font><font style="vertical-align: inherit;">测试程序。</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 更改第二个标志 </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">项目中有两个标志。</font><font style="vertical-align: inherit;">让我们确保当第二个标志被激活时，旧的白色标志变成黑色，以便不能再次使用。</font><font style="vertical-align: inherit;">我们编写以下内容：</font></font><br><br><blockquote> <code><strong>late [ Player FlagRed ][ FlagWhite] -&gt; [ Player FlagRed ][FlagBlack]</strong></code> </blockquote> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">代码说：如果玩家在红旗上，并且游戏中某处有白旗，则需要将白旗设为黑色。</font><font style="vertical-align: inherit;">由于代码是从上到下读取的，因此我们需要按以下顺序进行：</font></font><br><br><blockquote> <code><b>late [ Player FlagRed ] -&gt; CHECKPOINT <br> late [ Player FlagRed ][ FlagWhite] -&gt; [ Player FlagRed ][FlagBlack] <br> late [ Player FlagRed ] -&gt; [ Player FlagWhite ]</b></code> </blockquote> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如果您不明白为什么代码应该按此顺序排列，请尝试更改行的顺序并测试程序。</font><font style="vertical-align: inherit;">为了解决您自己的问题，您需要学习退后一步并思考代码的作用。</font><font style="vertical-align: inherit;">但是，我会给您一个提示-在您玩游戏时，以下错误示例中的最后一行代码中的红色标记在哪里？</font></font><br><br><blockquote> <code><b>[ &gt; Player | Crate ] -&gt; [ &gt; Player | &gt; Crate ] <br> [ &gt; Crate | Flag ] -&gt; [ Crate | Flag ] <br> late [ Player FlagRed ] -&gt; CHECKPOINT <br> late [ Player FlagRed ] -&gt; [ Player FlagWhite ] <br> late [ Player FlagRed ][ FlagWhite] -&gt; [ Player FlagRed ][FlagBlack]</b></code> </blockquote> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">此处</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">查看完成的示例项目</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">此外，我刚刚向您展示了最简单的动画制作方法。</font><font style="vertical-align: inherit;">在下一部分中，我将讨论创建更复杂的动画，例如爆炸。</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 第11部分。动画 </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">有两种方法可以在PuzzleScript中创建动画。</font><font style="vertical-align: inherit;">其中之一使用实时，但是在这一部分中，我不会谈论它。</font><font style="vertical-align: inherit;">另一个用于快速的一次性动画，例如爆炸或角色从垂直梯子下降。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">打开一个</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">示例项目</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">我们将创建炸弹和一系列爆炸镜头，然后对其进行动画处理。</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 对象动画 </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">对于2D动画，您需要从一个状态移到另一状态的多个对象绘图，例如正在运行的Mario的子画面。</font><font style="vertical-align: inherit;">它包含4帧动画。</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/698/425/1f5/6984251f5df56233fa238db05ad4febf.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 为了模拟动画的一帧到另一帧的过渡，我们将在PuzzleScript中创建几个对象，这些对象将成为动画的帧，然后使用代码在它们之间进行切换。 </font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 炸弹 </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 创建一个炸弹对象。 </font></font><br><br><blockquote> <code><b>Bomb <br> black yellow grey <br> ..1.. <br> ..1.. <br> .000. <br> 00020 <br> .000.</b></code> </blockquote> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">请记住将其添加到图层和图例中。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">为了动画化爆炸，我们需要将动画的每个帧创建为一个单独的对象，然后在代码中在它们之间进行切换。</font><font style="vertical-align: inherit;">让我们创建爆炸对象。</font></font><br><br><blockquote> <code><b>Explosion1 <br> black yellow grey red <br> ..1.. <br> ..1.. <br> .000. <br> 00320 <br> .000. <br> <br> Explosion2 <br> black yellow grey red <br> ..1.. <br> ..1.. <br> .333. <br> 03330 <br> .333. <br> <br> Explosion3 <br> black yellow grey red <br> ..1.. <br> .333. <br> 33333 <br> 33333 <br> .333. <br> <br> Explosion4 <br> black yellow grey red <br> .333. <br> 33333 <br> 33333 <br> 33333 <br> .333. <br> <br> Explosion5 <br> black yellow grey red <br> .333. <br> 33333 <br> 33.33 <br> 33333 <br> .333. <br> <br> Explosion6 <br> black yellow grey red <br> .333. <br> 3...3 <br> 3...3 <br> 3...3 <br> .333. <br> <br> Explosion7 <br> black yellow grey red <br> ..... <br> ..... <br> ..... <br> ..... <br> .....</b></code> </blockquote> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">它将正确编号对象，以便知道我们需要动画的哪一帧。</font><font style="vertical-align: inherit;">将它们添加到图层和图例后，我们可以添加几行代码。</font></font><br><br><blockquote> <code><b>[Explosion7] -&gt; [] <br> [Explosion6] -&gt; [Explosion7] <br> [Explosion5] -&gt; [Explosion6] <br> [Explosion4] -&gt; [Explosion5] <br> [Explosion3] -&gt; [Explosion4] <br> [Explosion2] -&gt; [Explosion3] <br> [Explosion1] -&gt; [Explosion2] <br> [Bomb] -&gt; [Explosion1]</b></code> </blockquote> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">尝试添加此代码，然后在关卡上放置炸弹并开始游戏。</font><font style="vertical-align: inherit;">您会注意到，炸弹动画每次移动都会改变一帧。</font><font style="vertical-align: inherit;">在对象之间切换，我们创建动画。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">动画之间的切换顺序至关重要。</font><font style="vertical-align: inherit;">最后一帧应位于顶部，第一帧应位于底部。</font><font style="vertical-align: inherit;">不要忘了代码是从上到下阅读的。</font><font style="vertical-align: inherit;">如果动画的帧顺序不同，那么我们将永远看不到这些变化。</font><font style="vertical-align: inherit;">我们只会看到最后一帧，在我们的情况下，炸弹只会消失。</font><font style="vertical-align: inherit;">即使在您看到图形之前，它将在一帧中更改为第一帧，然后更改为第二帧，依此类推。</font><font style="vertical-align: inherit;">通过将最后一帧放置在开始处，我们将在每一个转弯处看到下一个变化。</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 再次使用 </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">为了使所有东西都在一起动画，我们</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">再次</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">需要一个团队</font><font style="vertical-align: inherit;">。</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">再次</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">表示在读取所有代码之后，PuzzleScript将暂停，然后通过再次运行所有命令</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">再次</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">读取代码</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">它可用于重力，在冰上滑动，在我们的情况下可用于动画。</font><font style="vertical-align: inherit;">所需要做的就是重写代码，如下所示：</font></font><br><br><blockquote> <code><b>[Explosion7] -&gt; [] <br> [Explosion6] -&gt; [Explosion7] again <br> [Explosion5] -&gt; [Explosion6] again <br> [Explosion4] -&gt; [Explosion5] again <br> [Explosion3] -&gt; [Explosion4] again <br> [Explosion2] -&gt; [Explosion3] again <br> [Explosion1] -&gt; [Explosion2] again <br> [Bomb] -&gt; [Explosion1] again</b></code> </blockquote> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">测试游戏。</font><font style="vertical-align: inherit;">您将看到整个炸弹动画立即播放。</font><font style="vertical-align: inherit;">如果您认为速度太慢或太快，则可以更改速度。</font><font style="vertical-align: inherit;">在程序文本的开头，在</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">主页</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">下方，</font><font style="vertical-align: inherit;">编写以下代码：</font></font><br><br><blockquote> <code><b>again_interval 0.1</b></code> </blockquote> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">这是PuzzleScript称为</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">prelude的一部分</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">在这里，在其余代码之前，您可以设置其他规则来确定游戏的行为。</font><font style="vertical-align: inherit;">现在，动画应播放得更快。</font><font style="vertical-align: inherit;">尝试在again_interval之后更改数字，并检查其是否已更改。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">您可以在</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">此处</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">看到完成的项目示例</font><font style="vertical-align: inherit;">。</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 第十二部分。重力 </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">通常，PuzzleScript用于创建自上而下的游戏，但实际上，尽管使用了有限的PuzzleScript规则，但您仍可以逐步模拟侧滚动器的某些元素，即它们仍将是逐步的。</font><font style="vertical-align: inherit;">在这一部分中，我将告诉您如何实现重力。</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 项目实例 </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">打开一个</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">示例项目</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">我创建了一个简单的关卡，它有一个播放器，一个壁架上的盒子和一个下门。</font><font style="vertical-align: inherit;">我们要确保当玩家从壁架上推箱子时，他会掉到地上。</font><font style="vertical-align: inherit;">我们还希望玩家离开边缘时掉到地上。</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 秋季第一阶段 </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 这是我们将使用的代码的第一部分： </font></font><br><br><blockquote> <code><b>down [ Player | no Object ] -&gt; [ | Player ] <br> down [ Crate | no Object no Player ] -&gt; [ | Crate ]</b></code> </blockquote> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">尝试从边缘推动盒子。您会注意到，移动后，盒子悬挂在空中，但是又移动了，它掉到了地上。这里发生了一些事情。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">首先，让我们谈谈</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">down</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">关键字</font><font style="vertical-align: inherit;">。通过添加</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">down</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，我们将规则限制为仅在向下方向上适用。这就是盒子向下移动的原因。如果更换</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">下来</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">右侧</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，你会看到盒子卡在右侧壁，在与反重力游戏。尝试这样做。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">接下来，我们将做一些不寻常的事情。我们不检查玩家是否在特定对象（例如框）旁边，而是检查玩家是否在广义</font><strong><font style="vertical-align: inherit;">对象</font></strong><font style="vertical-align: inherit;">旁边</font></font><strong><font style="vertical-align: inherit;"></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">如果查看示例代码中的图例，您将看到我们已将对象定义为一组对象，也就是说，每次使用</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">对象</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">一词时</font><strong><font style="vertical-align: inherit;">，</font></strong><font style="vertical-align: inherit;">我们都意味着一组对象。</font><font style="vertical-align: inherit;">也就是说，我们检查播放器下面是否有这些对象。</font><font style="vertical-align: inherit;">如果不是，我们命令玩家占据这个空白区域，并由于</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">向下</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的单词“ </font><strong><font style="vertical-align: inherit;">down”，</font></strong><font style="vertical-align: inherit;">留出前一个空间</font><font style="vertical-align: inherit;">。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">但是，您还可以注意到，与壁架碰撞后，盒子才掉下来，直到下一个动作，它立即到达地面。</font><font style="vertical-align: inherit;">要消除这种延迟的崩溃，可以使用late关键字：</font></font><br><br><blockquote> <code><b>late down [ Player | no Object ] -&gt; [ | Player ] <br> late down [ Crate | no Object no Player ] -&gt; [ | Crate ]</b></code> </blockquote> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 但是如何使其逐渐逐帧下降呢？ </font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 秋季第二阶段 </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">现在我们使用</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">random</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">关键字</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">我们将代码重写如下：</font></font><br><br><blockquote> <code><b>random down [ Player | no Object ] -&gt; [ | Player ] <br> random down [ Crate | no Object no Player ] -&gt; [ | Crate ]</b></code> </blockquote> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">运行代码。</font><font style="vertical-align: inherit;">它的工作原理与先前的代码非常相似，但有一个重要的区别。</font><font style="vertical-align: inherit;">盒子在空中冻结，但是玩家每次移动时，它都会掉落一个单元格。</font><font style="vertical-align: inherit;">这是由于单词</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">random</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">所致</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">严格来说，</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">random是</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">用来创建具有随机元素的游戏的，但是在这里它派上了用场。</font><font style="vertical-align: inherit;">它强制每转执行一次相应的代码行。</font><font style="vertical-align: inherit;">PuzzleScript尽可能一次地执行每个规则，然后玩家才能看到图形变化。</font><font style="vertical-align: inherit;">这就是为什么盒子立即掉到地上的原因。</font><font style="vertical-align: inherit;">但是，当使用</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">随机</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">一词时</font><strong><font style="vertical-align: inherit;">，</font></strong><font style="vertical-align: inherit;">我们一次只能允许它落入一个单元格。</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 秋季第3阶段 </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">现在，我们将</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">再次</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">添加关键字</font><font style="vertical-align: inherit;">：</font></font><br><br><blockquote> <code><b>random down [ Player | no Object ] -&gt; [ | Player ] again <br> random down [ Crate | no Object no Player ] -&gt; [ | Crate ] again</b></code> </blockquote> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">启动游戏。</font><font style="vertical-align: inherit;">一切都</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">近乎</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">完美。</font><font style="vertical-align: inherit;">盒子在空中冻结了一段时间，但是如果再次移动，它会逐渐掉落到地面上。</font><font style="vertical-align: inherit;">从本质上讲，</font><font style="vertical-align: inherit;">我们已经很熟悉关键字</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">了</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，这意味着在转弯结束时，PuzzleScript会再次读取代码并尝试以</font><font style="vertical-align: inherit;">单独的方式</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">再次</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">执行所有命令</font><font style="vertical-align: inherit;">，然后暂停并随后重复执行多次。</font><font style="vertical-align: inherit;">这里重要的是他</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">再次</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在转弯之间停顿</font><font style="vertical-align: inherit;">，这使我们能够看到盒子掉落。</font></font><br><br><h2> 最后阶段 </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和最后的接触。</font><font style="vertical-align: inherit;">为了使盒子从边缘被推下后立即掉落到地面，我们需要在刚刚编写的代码之上添加另一行代码：</font></font><br><br><blockquote> <code><b>[moving Player] -&gt; [moving Player] again <br> random down [ Player | no Object ] -&gt; [ | Player ] again <br> random down [ Crate | no Object no Player ] -&gt; [ | Crate ] again</b></code> </blockquote> <br><font style="vertical-align: inherit;"><strong><font style="vertical-align: inherit;">播放器</font></strong><font style="vertical-align: inherit;">前面方括号[]中使用</font><font style="vertical-align: inherit;">的</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">移动</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">关键字</font><font style="vertical-align: inherit;">表示我们正在检查播放器是否在移动。</font><font style="vertical-align: inherit;">这意味着如果一名球员移动了，那么我们命令他继续移动并</font><strong><font style="vertical-align: inherit;">再次</font></strong><font style="vertical-align: inherit;">运营该团队</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">然后，立即</font><strong><font style="vertical-align: inherit;">再次</font></strong><font style="vertical-align: inherit;">使用该关键字的所有内容都</font><strong><font style="vertical-align: inherit;">将起作用</font></strong><font style="vertical-align: inherit;">；</font><font style="vertical-align: inherit;">在我们的案例中，这是盒子倒下的动画。</font><font style="vertical-align: inherit;">您可以在</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;">此处</font></a><font style="vertical-align: inherit;">看到完成的项目示例</font><font style="vertical-align: inherit;">。</font></font><strong><font style="vertical-align: inherit;"></font></strong><font style="vertical-align: inherit;"></font><strong><font style="vertical-align: inherit;"></font></strong><font style="vertical-align: inherit;"></font><strong><font style="vertical-align: inherit;"></font></strong><font style="vertical-align: inherit;"></font><br><br><font style="vertical-align: inherit;"></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 第13部分。检查行驶方向 </font></font></h2><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 方向指示 </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">有时，您只需要检查一个方向。</font><font style="vertical-align: inherit;">例如，您需要制作只能水平推动的块，或者创建只能向左走的鸭子。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">尽管如此，我们可以指示事件仅在某些方向发生。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">打开PuzzleScript，基于</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Basic</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">示例创建一个游戏，</font><font style="vertical-align: inherit;">并</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">使用</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">以下代码</font><font style="vertical-align: inherit;">将其替换为</font><strong><font style="vertical-align: inherit;">Rules</font></strong><font style="vertical-align: inherit;">：</font></font><br><br><blockquote> <code><b>[ <strong>Left</strong> <em>Player</em> ] -&gt; [ <em>Crate</em> ]</b></code> </blockquote> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">启动游戏，看看会发生什么。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如果您尝试向左走，播放器将变成一个盒子。</font><font style="vertical-align: inherit;">这是定向工作原理的一个很好的例子。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们已经习惯了我解释PuzzleScript代码的格式：</font></font><br><br><blockquote> <code><b>[  ] -&gt; [  ]</b></code> </blockquote> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如果事件为true，则事件发生。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">但是现在，当我们需要检查路线时，他将遵循新规则：</font></font><br><br><blockquote> <code>[ <strong>Movement</strong> <strong>Direction</strong> <em>Object Affected</em> ] -&gt; [ <em>New State of Object</em> ]</code> </blockquote> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 那是我们之前的代码： </font></font><br><br><blockquote> <code>[ <strong>Left</strong> <em>Player</em> ] -&gt; [ <em>Crate</em> ]</code> </blockquote> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">检查玩家是否向左移动（</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Left</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）。</font><font style="vertical-align: inherit;">如果是这样，那么我们将播放器替换为box对象。</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 目的地类型 </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 您可以从以下类型的目的地中进行选择： </font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 上 </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 往下 </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 向左 </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 对啊 </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 水平（检查是否水平移动） </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 垂直（检查是否有垂直移动） </font></font></li></ul><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 第14部分。创建自定义动作 </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">由于某些原因，游戏可能需要自定义动作。</font><font style="vertical-align: inherit;">鸭子只能向左走，盒子只能水平推，依此类推。</font><font style="vertical-align: inherit;">这很容易做到。</font><font style="vertical-align: inherit;">让我们再看一下基本的PuzzleScript代码格式：</font></font><br><br><blockquote> <code><b>[  ] -&gt; [  ]</b></code> </blockquote> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如果条件为真，则发生事件。</font><font style="vertical-align: inherit;">要创建自定义移动，您需要执行以下操作：</font></font><br><br><blockquote> <code>[ <em>Condition</em> ] -&gt; [ <b>Movement Direction</b> <em>Object To Move</em> ]</code> </blockquote> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 示例如下所示： </font></font><br><br><blockquote> <code>[ Player | Crate ] -&gt; [ Player | <strong>Left</strong> Crate ]</code> </blockquote> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">下载</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PuzzleScript</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，打开</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Basic</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">示例</font><font style="vertical-align: inherit;">，粘贴此代码，看看会发生什么。</font><font style="vertical-align: inherit;">转到没有墙壁的盒子。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">您会看到，当玩家靠近盒子时，盒子被推到左侧。</font><font style="vertical-align: inherit;">但是，由于</font><font style="vertical-align: inherit;">没有</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Late</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">关键字</font><font style="vertical-align: inherit;">，因此</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">您迈出第一步</font><strong><font style="vertical-align: inherit;">之后</font></strong><font style="vertical-align: inherit;">的过程中会发生这种情况</font><font style="vertical-align: inherit;">。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">事件中</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">指定</font><font style="vertical-align: inherit;">对象时，除了对象之外</font><strong><font style="vertical-align: inherit;">，</font></strong><font style="vertical-align: inherit;">还可以</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">移动</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">对象的</font><strong><font style="vertical-align: inherit;">方向</font></strong><font style="vertical-align: inherit;">，例如</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Left</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，PuzzleScript会尝试沿指定方向移动对象。</font><font style="vertical-align: inherit;">这就是为什么盒子而不是播放器向左移动的原因- </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">左边</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">是</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Crate</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">旁边</font><font style="vertical-align: inherit;">。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 还记得上一部分的这段代码吗？ </font></font><br><br><blockquote> <code>[ <strong></strong> <strong></strong> <em></em> ] -&gt; [ <em>  </em> ]</code> </blockquote> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如果</font><font style="vertical-align: inherit;">在对象旁边</font><font style="vertical-align: inherit;">的</font><strong><font style="vertical-align: inherit;">状态</font></strong><font style="vertical-align: inherit;">下</font><font style="vertical-align: inherit;">指示</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">移动方向</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，则它将检查该对象是否沿该方向移动。</font><font style="vertical-align: inherit;">这是一个重要的区别。</font><font style="vertical-align: inherit;">您可以这样重写它：</font></font><strong><font style="vertical-align: inherit;"></font></strong><font style="vertical-align: inherit;"></font><br><br><blockquote> <code><b>[   ] -&gt; [   ]</b></code> </blockquote> <br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 允许的自定义移动 </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 可以使用以下任何一个单词来创建自定义动作： </font></font><br><br><ul><li> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">上</font></font></strong> </li><li> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">往下</font></font></strong> </li><li> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">向左</font></font></strong> </li><li> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">对啊</font></font></strong> </li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">您不能使用</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Horizo​​ntal</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">或</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vertical</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，因为PuzzleScript无法理解您要沿哪个方向移动对象，或者要这样做，将需要很多解决方法。</font><font style="vertical-align: inherit;">有必要指出一个具体的方向。</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 第15部分。检查对象旁边的单元格 </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 有时有必要检查对象旁边的内容。 </font></font>这很容易做到。<font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 让我们再看一下PuzzleScript代码格式： </font></font><br><br><blockquote> <code><b>[  ] -&gt; [  ]</b></code> </blockquote> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 那就是 </font></font><br><br><blockquote> <code><b>[   ] -&gt;    [    ]</b></code> </blockquote> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">要检查对象的侧面，我们需要添加一个元素。</font><font style="vertical-align: inherit;">格式如下：</font></font><br><br><blockquote> <code><strong> </strong> [ <em> object1</em> <em>|</em> <em>object2 </em> ] -&gt; [ <em>object1 | object2</em> ]</code> </blockquote> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在出现条件之前，我们检查要在对象的哪一侧执行检查。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在条件内部，我们假设至少需要两个单元。</font><font style="vertical-align: inherit;">实际上，一个单元就是在同一空间中而不是彼此相邻的任何对象。</font></font><br><br><blockquote> <code><b>[    ] <br> <br> [    |    |    ]</b></code> </blockquote> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">第一个单元格是我们要检查其侧面的对象。</font><font style="vertical-align: inherit;">第二个单元格是我们正在检查其状态的对象。</font><font style="vertical-align: inherit;">请尝试以下示例：</font></font><br><br><blockquote> <code><strong>Left</strong> [ Player | Crate ] -&gt; [ Player | ]</code> </blockquote> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 如果框在播放器左侧的正方形中，则上面显示的代码将删除框。 </font></font><br><br><blockquote> <code><strong>Left</strong> [ Crate | Crate ] -&gt; [ Player | Crate ]</code> </blockquote> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">此代码检查该框是否在另一个框的左侧。</font><font style="vertical-align: inherit;">如果是这样，则选中其侧面的框将成为玩家的新对象。</font></font><br><br><blockquote> <code><strong>Left</strong> [ Crate | Crate ] -&gt; [ Crate | Player ]</code> </blockquote> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 上面的代码中有相同的复选框，但是左侧的框成为玩家的对象。 </font></font><br><br><blockquote> <code><strong>Left</strong> [ Crate | Crate | Crate ] -&gt; [ Crate | Player | Crate ]</code> </blockquote> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">此代码也使用类似的模式。</font><font style="vertical-align: inherit;">如果3个框在水平方向上彼此相邻，则紧靠选中框左侧的框将成为玩家。</font></font><br><br><blockquote> <code><strong>Left</strong> [ Crate | Crate | Crate ] -&gt; [ Crate | Crate | Player ]</code> </blockquote> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如果3个框在水平方向上彼此相邻，则最左边的框成为播放器。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如果您测试了每个示例，您将开始理解这种模式。</font><font style="vertical-align: inherit;">第一个单元格是我们检查以查看下一个对象的对象。</font><font style="vertical-align: inherit;">从最接近到最远的以下单元格是我们要检查的对象。</font></font><br><br><h2> 关键词 </h2><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 向上-检查对象 </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 下-检查对象下 </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 左-检查对象的左侧 </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 右-检查对象的右边 </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 水平-检查对象的左侧和右侧 </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 垂直-检查对象上方和下方 </font></font></li></ul><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1ee/808/fa7/1ee808fa784b811c3f0059e2b2f164d4.gif" alt="图片"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/311/2f6/315/3112f6315ed1ea7a2c1608c3145a95e4.gif" alt="图片"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5bf/c36/630/5bfc366301e0b8b630920693146bd279.gif" alt="图片"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1e7/bcc/0b2/1e7bcc0b2b5f6f61aa9f59ea30561f4f.gif" alt="图片"></div></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN428906/">https://habr.com/ru/post/zh-CN428906/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN428896/index.html">无尽审查神经网络</a></li>
<li><a href="../zh-CN428898/index.html">C ++编程中的问题</a></li>
<li><a href="../zh-CN428900/index.html">轮式机器人开始向美国和英国居民运送货物</a></li>
<li><a href="../zh-CN428902/index.html">NFC无线标签</a></li>
<li><a href="../zh-CN428904/index.html">金融科技文摘：中央银行机器人，以太坊2.0，通过Rosfinmonitoring进行的加密货币控制和金融科技趋势</a></li>
<li><a href="../zh-CN428908/index.html">寒霜朋克：拆解机制</a></li>
<li><a href="../zh-CN428910/index.html">轻型电话II-尊重您时间的电话</a></li>
<li><a href="../zh-CN428912/index.html">如何在Windows的React Native上部署应用程序开发环境</a></li>
<li><a href="../zh-CN428914/index.html">莫斯科阿帕奇点燃聚会＃5</a></li>
<li><a href="../zh-CN428918/index.html">英特尔至强E级</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>