<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üé† üßï üà∫ DevCore: bagian perangkat lunak dari proyek DevBoy üôãüèª ü§ü üíª</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Halo teman-teman! 

 Nikolay bersama Anda lagi, dalam artikel terakhir " DevBoy - bagaimana saya membuat proyek perangkat sumber terbuka dan meluncurk...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>DevCore: bagian perangkat lunak dari proyek DevBoy</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/424309/">  <b>Halo teman-teman!</b> <br><br>  Nikolay bersama Anda lagi, dalam artikel terakhir " <i><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">DevBoy - bagaimana saya membuat proyek perangkat sumber terbuka dan meluncurkan proyek di Kickstarter</a></i> ", penekanannya lebih pada penampilan dan perangkat keras, hari ini kita akan berbicara tentang bagaimana hal ini dilakukan " <i>di dalam</i> " dan menganalisis bagian perangkat lunak. <br><br><img src="https://habrastorage.org/webt/6r/n4/u8/6rn4u8jvzpd-c9_oykzqia4l8fk.jpeg"><br><br>  Siapa yang peduli - saya minta kucing. <br><a name="habracut"></a><br>  Seperti disebutkan sebelumnya, proyek ini didasarkan pada mikrokontroler <b>STM32F415RG</b> dari STMicroelectronics pada inti ARM Cortex-M4.  Ada beberapa IDE berbeda untuk mengembangkan mikrokontroler untuk mikrokontroler ini, namun, untuk proyek open source Anda memerlukan setidaknya IDE gratis, dan lebih disukai Open Source.  Selain itu, IDE harus tetap didukung di <b>STM32CubeMX</b> .  Pada saat saya mulai mengerjakan proyek ini, hanya ada satu IDE yang memenuhi semua persyaratan ini - <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">System Workbench for STM32</a></b> . <br><br><img src="https://habrastorage.org/webt/v7/pz/vi/v7pzviufspf40flvruysuro_ex0.png">  <i>Saat ini, ada Atollic TrueStudio, yang menjadi gratis setelah STMicroelectronics membelinya.</i> <i><br></i> <br>  Program selanjutnya yang digunakan adalah <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">STM32CubeMX</a></b> .  Program ini adalah utilitas untuk mengkonfigurasi periferal mikrokontroler menggunakan antarmuka grafis. <br><img src="https://habrastorage.org/webt/i4/ym/3u/i4ym3unkrgskza2fmumqmmfzs1o.png"><br>  Hasilnya adalah kode yang mencakup <b>H</b> ardware <b>A</b> bstraction <b>L</b> ayer (HAL).  Banyak programmer tidak benar-benar menyukai " <i>kreasi</i> " ini, ini bukan tanpa bug, tetapi, bagaimanapun, ia sangat menyederhanakan pengembangan dan meningkatkan portabilitas program antara mikrokontroler yang berbeda dari STMicroelectronics. <br><br>  Selain itu, selama konfigurasi, Anda dapat menentukan penggunaan beberapa perangkat lunak sumber terbuka pihak ketiga seperti <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">FreeRTOS</a></b> , <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">FatFS,</a></b> dan beberapa lainnya. <br><br>  <b>Kami telah</b> menyelesaikan deskripsi perangkat lunak yang digunakan, sekarang mari kita beralih ke bagian yang paling menarik - <b>DevCore</b> .  Nama berasal dari " <i>Pengembangan Inti</i> ", mari kita mulai. <br><br>  Pertama-tama, itu adalah <b>C ++ RTOS Wrapper</b> ( <i>FreeRTOS dalam hal ini</i> ).  Vrapper diperlukan karena dua alasan: <br><br><ul><li>  Jauh lebih baik untuk membuat objek, dan kemudian memanggil mutex. Ambil () misalnya, daripada membuat pegangan, panggil fungsi buat, dan kemudian meneruskan pegangan ini ke semua fungsi mutex </li><li>  Jika perlu mengganti RTOS, cukup untuk mengganti pembungkus, dan tidak semua panggilan ke fungsi RTOS dari kode. </li></ul><br>  Tidak masuk akal untuk membawa kode pembungkus ke sini, siapa yang peduli - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">kita melihat GitHub</a> , dan kita melanjutkan. <br><br>  Bagian selanjutnya adalah <b>Kerangka Aplikasi</b> .  Ini adalah kelas dasar untuk semua tugas.  Karena ini hanya dua file yang relatif kecil, masuk akal untuk mendaftarkannya sepenuhnya: <br><br><div class="spoiler">  <b class="spoiler_title">Header</b> <div class="spoiler_text"><pre><code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//****************************************************************************** // @file AppTask.h // @author Nicolai Shlapunov // // @details DevCore: Application Task Base Class, header // // @section LICENSE // // Software License Agreement (Modified BSD License) // // Copyright (c) 2016, Devtronic &amp; Nicolai Shlapunov // All rights reserved. // // Redistribution and use in source and binary forms, with or without // modification, are permitted provided that the following conditions are met: // // 1. Redistributions of source code must retain the above copyright // notice, this list of conditions and the following disclaimer. // 2. Redistributions in binary form must reproduce the above copyright // notice, this list of conditions and the following disclaimer in the // documentation and/or other materials provided with the distribution. // 3. Neither the name of the Devtronic nor the names of its contributors // may be used to endorse or promote products derived from this software // without specific prior written permission. // 4. Redistribution and use of this software other than as permitted under // this license is void and will automatically terminate your rights under // this license. // // THIS SOFTWARE IS PROVIDED BY DEVTRONIC ''AS IS'' AND ANY EXPRESS OR IMPLIED // WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF // MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. // IN NO EVENT SHALL DEVTRONIC BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, // SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED // TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR // PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY // LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING // NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS // SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. // // @section SUPPORT // // Devtronic invests time and resources providing this open source code, // please support Devtronic and open-source hardware/software by // donations and/or purchasing products from Devtronic. // //****************************************************************************** #ifndef AppTask_h #define AppTask_h // ***************************************************************************** // *** Includes ************************************************************ // ***************************************************************************** #include "DevCfg.h" // ***************************************************************************** // * AppTask class. This class is wrapper for call C++ function from class. **** // ***************************************************************************** class AppTask { public: // ************************************************************************* // *** Init Task ******************************************************* // ************************************************************************* virtual void InitTask(void) {CreateTask();} protected: // ************************************************************************* // *** Constructor ***************************************************** // ************************************************************************* AppTask(uint16_t stk_size, uint8_t task_prio, const char name[], uint16_t queue_len = 0U, uint16_t queue_msg_size = 0U, void* task_msg_p = nullptr, uint32_t task_interval_ms = 0U) : ctrl_queue((queue_len + 2U), sizeof(CtrlQueueMsg)), task_queue(queue_len, queue_msg_size), task_msg_ptr(task_msg_p), timer(task_interval_ms, RtosTimer::REPEATING, TimerCallback, (void*)this), stack_size(stk_size), task_priority(task_prio), task_name(name) {}; // ************************************************************************* // *** Virtual destructor - prevent warning **************************** // ************************************************************************* virtual ~AppTask() {}; // ************************************************************************* // *** Create task function ******************************************** // ************************************************************************* // * This function creates new task in FreeRTOS, provide pointer to function // * and pointer to class as parameter. When TaskFunctionCallback() called // * from FreeRTOS, it use pointer to class from parameter to call virtual // * functions. void CreateTask(); // ************************************************************************* // *** Setup function ************************************************** // ************************************************************************* // * * virtual function - some tasks may not have Setup() actions virtual Result Setup() {return Result::RESULT_OK;} // ************************************************************************* // *** IntervalTimerExpired function *********************************** // ************************************************************************* // * Empty virtual function - some tasks may not have TimerExpired() actions virtual Result TimerExpired() {return Result::RESULT_OK;} // ************************************************************************* // *** ProcessMessage function ***************************************** // ************************************************************************* // * Empty virtual function - some tasks may not have ProcessMessage() actions virtual Result ProcessMessage() {return Result::RESULT_OK;} // ************************************************************************* // *** Loop function *************************************************** // ************************************************************************* // * Empty virtual function - some tasks may not have Loop() actions virtual Result Loop() {return Result::RESULT_OK;} // ************************************************************************* // *** SendTaskMessage function **************************************** // ************************************************************************* Result SendTaskMessage(const void* task_msg, bool is_priority = false); private: // Task control queue message types enum CtrlQueueMsgType { CTRL_TIMER_MSG, CTRL_TASK_QUEUE_MSG }; // Task control queue message struct struct CtrlQueueMsg { CtrlQueueMsgType type; }; // Task control queue RtosQueue ctrl_queue; // Task queue RtosQueue task_queue; // Pointer to receive message buffer void* task_msg_ptr; // Timer object RtosTimer timer; // Task stack size uint16_t stack_size; // Task priority uint8_t task_priority; // Pointer to the task name const char* task_name; // ************************************************************************* // *** IntLoop function ************************************************ // ************************************************************************* Result IntLoop(); // ************************************************************************* // *** TaskFunctionCallback ******************************************** // ************************************************************************* static void TaskFunctionCallback(void* ptr); // ************************************************************************* // *** IntervalTimerCallback function ********************************** // ************************************************************************* static void TimerCallback(void* ptr); // ************************************************************************* // *** SendControlMessage function ************************************* // ************************************************************************* Result SendControlMessage(const CtrlQueueMsg&amp; ctrl_msg, bool is_priority = false); // ************************************************************************* // *** Change counter ************************************************** // ************************************************************************* static void ChangeCnt(bool is_up); // ************************************************************************* // *** Private constructor and assign operator - prevent copying ******* // ************************************************************************* AppTask(); AppTask(const AppTask&amp;); AppTask&amp; operator=(const AppTask&amp;); }; #endif</span></span></code> </pre> </div></div><div class="spoiler">  <b class="spoiler_title">Kode</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//****************************************************************************** // @file AppTask.cpp // @author Nicolai Shlapunov // // @details DevCore: Application Task Base Class, implementation // // @copyright Copyright (c) 2016, Devtronic &amp; Nicolai Shlapunov // All rights reserved. // // @section SUPPORT // // Devtronic invests time and resources providing this open source code, // please support Devtronic and open-source hardware/software by // donations and/or purchasing products from Devtronic. // //****************************************************************************** // ***************************************************************************** // *** Includes ************************************************************ // ***************************************************************************** #include "AppTask.h" #include "RtosMutex.h" // ***************************************************************************** // *** Static variables **************************************************** // ***************************************************************************** static RtosMutex startup_mutex; static uint32_t startup_cnt = 0U; // ***************************************************************************** // *** Create task function ************************************************ // ***************************************************************************** void AppTask::CreateTask() { Result result = Result::RESULT_OK; // If interval timer period isn't zero or task queue present if((timer.GetTimerPeriod() != 0U) || (task_queue.GetQueueLen() != 0U)) { // Set Control Queue name ctrl_queue.SetName(task_name, "Ctrl"); // Create control queue result = ctrl_queue.Create(); } // If task queue present if(task_queue.GetQueueLen() != 0U) { // Set Task Queue name task_queue.SetName(task_name, "Task"); // Create task queue result |= task_queue.Create(); } // If interval timer period isn't zero if(timer.GetTimerPeriod() != 0U) { // Create timer result |= timer.Create(); } // Create task: function - TaskFunctionCallback(), parameter - pointer to "this" result |= Rtos::TaskCreate(TaskFunctionCallback, task_name, stack_size, this, task_priority); // Check result if(result.IsBad()) { // </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">TODO:</span></span></span><span class="hljs-comment"> implement error handling Break(); } } // ***************************************************************************** // *** SendTaskMessage function ******************************************** // ***************************************************************************** Result AppTask::SendTaskMessage(const void* task_msg, bool is_priority) { Result result = Result::RESULT_OK; // Send task message to front or back of task queue if(is_priority == true) { result = task_queue.SendToFront(task_msg); } else { result = task_queue.SendToBack(task_msg); } // If successful - send message to the control queue if(result.IsGood()) { CtrlQueueMsg ctrl_msg; ctrl_msg.type = CTRL_TASK_QUEUE_MSG; result = SendControlMessage(ctrl_msg, is_priority); } return result; } // ***************************************************************************** // *** IntLoop function **************************************************** // ***************************************************************************** Result AppTask::IntLoop() { Result result = Result::RESULT_OK; while(result.IsGood()) { // Buffer for control message CtrlQueueMsg ctrl_msg; // Read on the control queue result = ctrl_queue.Receive(&amp;ctrl_msg, timer.GetTimerPeriod() * 2U); // If successful if(result.IsGood()) { // Check message type switch(ctrl_msg.type) { case CTRL_TIMER_MSG: result = TimerExpired(); break; case CTRL_TASK_QUEUE_MSG: { // Non blocking read from the task queue result = task_queue.Receive(task_msg_ptr, 0U); // If successful if(result.IsGood()) { // Process it! result = ProcessMessage(); } break; } default: result = Result::ERR_INVALID_ITEM; break; } } } return result; } // ***************************************************************************** // *** TaskFunctionCallback ************************************************ // ***************************************************************************** void AppTask::TaskFunctionCallback(void* ptr) { Result result = Result::ERR_NULL_PTR; if(ptr != nullptr) { // Set good result result = Result::RESULT_OK; // Get reference to the task object AppTask&amp; app_task = *(static_cast&lt;AppTask*&gt;(ptr)); // Increment counter before call Setup() ChangeCnt(true); // Call virtual Setup() function from AppTask class app_task.Setup(); // Decrement counter after call Setup() ChangeCnt(false); // Pause for give other tasks run Setup() RtosTick::DelayTicks(1U); // Pause while other tasks run Setup() before executing any Loop() while(startup_cnt) RtosTick::DelayTicks(1U); // If no timer or queue - just call Loop() function if((app_task.timer.GetTimerPeriod() == 0U) &amp;&amp; (app_task.task_queue.GetQueueLen() == 0U)) { // Call virtual Loop() function from AppTask class while(app_task.Loop() == Result::RESULT_OK); } else { // Start task timer if needed if(app_task.timer.GetTimerPeriod() != 0U) { result = app_task.timer.Start(); } // Check result if(result.IsGood()) { // Call internal AppTask function result = app_task.IntLoop(); } // Stop task timer if needed if(app_task.timer.GetTimerPeriod() != 0U) { result |= app_task.timer.Stop(); } } } // Check result if(result.IsBad()) { // </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">TODO:</span></span></span><span class="hljs-comment"> implement error handling Break(); } // Delete task after exit Rtos::TaskDelete(); } // ***************************************************************************** // *** TimerCallback function ********************************************** // ***************************************************************************** void AppTask::TimerCallback(void* ptr) { Result result = Result::ERR_NULL_PTR; if(ptr != nullptr) { // Get reference to the task object AppTask&amp; task = *((AppTask*)ptr); // Create control timer message CtrlQueueMsg timer_msg; timer_msg.type = CTRL_TIMER_MSG; // Send message to the control queue result = task.SendControlMessage(timer_msg); } // Check result if(result.IsBad()) { // </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">TODO:</span></span></span><span class="hljs-comment"> implement error handling Break(); } } // ***************************************************************************** // *** SendControlMessage function ***************************************** // ***************************************************************************** Result AppTask::SendControlMessage(const CtrlQueueMsg&amp; ctrl_msg, bool is_priority) { Result result; if(is_priority == true) { result = ctrl_queue.SendToFront(&amp;ctrl_msg); } else { result = ctrl_queue.SendToBack(&amp;ctrl_msg); } return result; } // ***************************************************************************** // *** Change counter ****************************************************** // ***************************************************************************** void AppTask::ChangeCnt(bool is_up) { // Take semaphore before change counter startup_mutex.Lock(); // Check direction if(is_up == true) { // Increment counter startup_cnt++; } else { // Decrement counter startup_cnt--; } // Give semaphore after changes startup_mutex.Release(); }</span></span></code> </pre></div></div><br>  Kelas yang diwariskan dapat menimpa 4 fungsi virtual: <br><br><ul><li>  <b>Setup ()</b> adalah fungsi yang dipanggil sebelum memulai tugas.  Kelengkapan kode dijamin dalam semua fungsi ini dari semua tugas sebelum pelaksanaan siklus utama. </li><li>  <b>Loop ()</b> - siklus tugas utama, di mana tugas itu sendiri mengatur apa yang diinginkan.  Tidak dapat digunakan bersamaan dengan dua fungsi berikut. </li><li>  <b>TimerExpired ()</b> - fungsi yang disebut secara berkala dengan interval yang diberikan.  Nyaman untuk menerapkan polling sensor misalnya. </li><li>  <b>ProcessMessage ()</b> - berfungsi untuk memproses pesan dari tugas lain. </li></ul><br>  Dua fungsi pertama mengimplementasikan " <i>Arduino-Style</i> " untuk tugas. <br><br>  Dua berikutnya menerapkan sistem " <i>acara</i> " menyederhanakan interaksi tugas.  Dengan pendekatan ini, tugas mengimplementasikan antarmuka eksternal dalam bentuk fungsi yang mengirim data kirim ke tugas melalui kotak surat internal.  Dengan pendekatan ini, pengguna yang menggunakan antarmuka ini tidak perlu khawatir dalam konteks apa tindakan dilakukan.  Benar, ini hanya mungkin untuk setter atau tim.  Untuk getter, yang terbaik adalah menggunakan mutex dan menyalin data untuk mencegah penangkapan mutex untuk waktu yang lama. <br><br>  Pendekatan ini terlihat ketika saya sedang mengembangkan perangkat lunak untuk peralatan medis.  Mikrokontroler memiliki satu <i>anjing penjaga,</i> dan dalam hal banyak tugas, Anda perlu melacak semuanya.  Untuk ini, ada tugas terpisah yang melayani anjing penjaga dan menerima pesan dari tugas lain yang dikirim dari fungsi TimerExpired ().  Jika selama periode waktu tugas * n tidak ada pesan, tugas mati, kami <s>mematikan lampu dan</s> mengambil tindakan untuk mematikan semua kelenjar yang mempengaruhi pasien. <br><br>  Semua tugas adalah tunggal, Anda tidak dapat membuatnya secara langsung, tetapi Anda bisa mendapatkan tautan ke tugas tersebut.  Untuk melakukan ini, setiap tugas mengimplementasikan metode <b>GetInstance ()</b> statis: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// ***************************************************************************** // *** Get Instance ******************************************************** // ***************************************************************************** Application&amp; Application::GetInstance(void) { static Application application; return application; }</span></span></code> </pre> <br>  Juga termasuk tugas-tugas untuk <b>output audio</b> , untuk <b>modul input</b> dan untuk <b>pemeliharaan layar.</b> <br><br>  Tugas <b>output suara</b> cukup sederhana - ia menerima serangkaian frekuensi dan durasi dan secara berkala mengubah pengaturan timer untuk menghasilkan pulsa persegi panjang dari frekuensi tertentu. <br><br><div class="spoiler">  <b class="spoiler_title">Header</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//****************************************************************************** // @file SoundDrv.h // @author Nicolai Shlapunov // // @details DevCore: Sound Driver Class, header // // @section LICENSE // // Software License Agreement (Modified BSD License) // // Copyright (c) 2016, Devtronic &amp; Nicolai Shlapunov // All rights reserved. // // Redistribution and use in source and binary forms, with or without // modification, are permitted provided that the following conditions are met: // // 1. Redistributions of source code must retain the above copyright // notice, this list of conditions and the following disclaimer. // 2. Redistributions in binary form must reproduce the above copyright // notice, this list of conditions and the following disclaimer in the // documentation and/or other materials provided with the distribution. // 3. Neither the name of the Devtronic nor the names of its contributors // may be used to endorse or promote products derived from this software // without specific prior written permission. // 4. Redistribution and use of this software other than as permitted under // this license is void and will automatically terminate your rights under // this license. // // THIS SOFTWARE IS PROVIDED BY DEVTRONIC ''AS IS'' AND ANY EXPRESS OR IMPLIED // WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF // MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. // IN NO EVENT SHALL DEVTRONIC BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, // SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED // TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR // PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY // LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING // NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS // SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. // // @section SUPPORT // // Devtronic invests time and resources providing this open source code, // please support Devtronic and open-source hardware/software by // donations and/or purchasing products from Devtronic. // //****************************************************************************** #ifndef SoundDrv_h #define SoundDrv_h // ***************************************************************************** // *** Includes ************************************************************ // ***************************************************************************** #include "DevCfg.h" #include "AppTask.h" #include "RtosMutex.h" #include "RtosSemaphore.h" // ***************************************************************************** // *** Sound Driver Class. This class implement work with sound. *********** // ***************************************************************************** class SoundDrv : public AppTask { public: // ************************************************************************* // *** Get Instance **************************************************** // ************************************************************************* // * This class is singleton. For use this class you must call GetInstance() // * to receive reference to Sound Driver class static SoundDrv&amp; GetInstance(void); // ************************************************************************* // *** Init Sound Driver Task ****************************************** // ************************************************************************* virtual void InitTask(TIM_HandleTypeDef *htm); // ************************************************************************* // *** Sound Driver Setup ********************************************** // ************************************************************************* virtual Result Setup(); // ************************************************************************* // *** Sound Driver Loop *********************************************** // ************************************************************************* virtual Result Loop(); // ************************************************************************* // *** Beep function *************************************************** // ************************************************************************* void Beep(uint16_t freq, uint16_t del, bool pause_after_play = false); // ************************************************************************* // *** Play sound function ********************************************* // ************************************************************************* void PlaySound(const uint16_t* melody, uint16_t size, uint16_t temp_ms = 100U, bool rep = false); // ************************************************************************* // *** Stop sound function ********************************************* // ************************************************************************* void StopSound(void); // ************************************************************************* // *** Mute sound function ********************************************* // ************************************************************************* void Mute(bool mute_flag); // ************************************************************************* // *** Is sound played function **************************************** // ************************************************************************* bool IsSoundPlayed(void); private: // Timer handle TIM_HandleTypeDef* htim = SOUND_HTIM; // Timer channel uint32_t channel = SOUND_CHANNEL; // Ticks variable uint32_t last_wake_ticks = 0U; // Pointer to table contains melody const uint16_t* sound_table = nullptr; // Size of table uint16_t sound_table_size = 0U; // Current position uint16_t sound_table_position = 0U; // Current frequency delay uint16_t current_delay = 0U; // Time for one frequency in ms uint32_t delay_ms = 100U; // Repeat flag bool repeat = false; // Mute flag bool mute = false; // Mutex to synchronize when playing melody frames RtosMutex melody_mutex; // Semaphore for start play sound RtosSemaphore sound_update; // ************************************************************************* // *** Process Button Input function *********************************** // ************************************************************************* void Tone(uint16_t freq); // ************************************************************************* // ** Private constructor. Only GetInstance() allow to access this class. ** // ************************************************************************* SoundDrv() : AppTask(SOUND_DRV_TASK_STACK_SIZE, SOUND_DRV_TASK_PRIORITY, "SoundDrv") {}; }; #endif</span></span></code> </pre> <br></div></div><br>  Tugas servis <b>modul air</b> juga cukup sederhana.  Dari titik-titik menarik, modul secara otomatis terdeteksi: pertama, menggunakan ADC, kami mengukur voltase, jika berada dalam kisaran 25% hingga 75% dari tegangan suplai, joystick analog dimasukkan, jika tidak tombol atau encoder.  Jika ini bukan joystick, periksa baris keempat modul I / O: jika berada pada level tinggi, ini adalah tombol ( <i>semua tombol ditarik ke daya dan, ketika tombol ditekan, ditutup ke tanah</i> ), jika rendah, ini adalah encoder ( <i>tombol kecil "ditarik ke atas" ke tanah dan ketika ditekan menutup ke daya</i> ). <br><br><div class="spoiler">  <b class="spoiler_title">Header</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//****************************************************************************** // @file InputDrv.h // @author Nicolai Shlapunov // // @details DevCore: Input Driver Class, header // // @section LICENSE // // Software License Agreement (Modified BSD License) // // Copyright (c) 2016, Devtronic &amp; Nicolai Shlapunov // All rights reserved. // // Redistribution and use in source and binary forms, with or without // modification, are permitted provided that the following conditions are met: // // 1. Redistributions of source code must retain the above copyright // notice, this list of conditions and the following disclaimer. // 2. Redistributions in binary form must reproduce the above copyright // notice, this list of conditions and the following disclaimer in the // documentation and/or other materials provided with the distribution. // 3. Neither the name of the Devtronic nor the names of its contributors // may be used to endorse or promote products derived from this software // without specific prior written permission. // 4. Redistribution and use of this software other than as permitted under // this license is void and will automatically terminate your rights under // this license. // // THIS SOFTWARE IS PROVIDED BY DEVTRONIC ''AS IS'' AND ANY EXPRESS OR IMPLIED // WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF // MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. // IN NO EVENT SHALL DEVTRONIC BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, // SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED // TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR // PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY // LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING // NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS // SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. // // @section SUPPORT // // Devtronic invests time and resources providing this open source code, // please support Devtronic and open-source hardware/software by // donations and/or purchasing products from Devtronic. // //****************************************************************************** #ifndef InputDrv_h #define InputDrv_h // ***************************************************************************** // *** Includes ************************************************************ // ***************************************************************************** #include "DevCfg.h" #include "AppTask.h" // ***************************************************************************** // * Input Driver Class. This class implement work with user input elements like // * buttons and encoders. class InputDrv : public AppTask { public: // ************************************************************************* // *** Enum with all buttons ******************************************* // ************************************************************************* typedef enum { EXT_LEFT, // Left ext port EXT_RIGHT, // Right ext port EXT_MAX // Ext port count } PortType; // ************************************************************************* // *** Enum with all devices types ************************************* // ************************************************************************* typedef enum { EXT_DEV_NONE, // No device EXT_DEV_BTN, // Buttons(cross) EXT_DEV_ENC, // Encoder EXT_DEV_JOY, // Joystick EXT_DEV_MAX // Device types count } ExtDeviceType; // ************************************************************************* // *** Enum with all buttons ******************************************* // ************************************************************************* typedef enum { BTN_UP, // Up button BTN_LEFT, // Left button BTN_DOWN, // Down button BTN_RIGHT, // Right button BTN_MAX // Buttons count } ButtonType; // ************************************************************************* // *** Enum with all encoder buttons *********************************** // ************************************************************************* typedef enum { ENC_BTN_ENT, // Press on the knob ENC_BTN_BACK, // Small button ENC_BTN_MAX // Buttons count } EncButtonType; // ************************************************************************* // *** Get Instance **************************************************** // ************************************************************************* // * This class is singleton. For use this class you must call GetInstance() // * to receive reference to Input Driver class static InputDrv&amp; GetInstance(void); // ************************************************************************* // *** Init Input Driver Task ****************************************** // ************************************************************************* // * This function initialize Input Driver class. If htim provided, this // * timer will be used instead FreeRTOS task. virtual void InitTask(TIM_HandleTypeDef* htm, ADC_HandleTypeDef* had); // ************************************************************************* // *** Input Driver Setup ********************************************** // ************************************************************************* virtual Result Setup(); // ************************************************************************* // *** Input Driver Loop *********************************************** // ************************************************************************* // * If FreeRTOS task used, this function just call ProcessInput() with 1 ms // * period. If FreeRTOS tick is 1 ms - this task must have highest priority virtual Result Loop(); // ************************************************************************* // *** Process Input function ****************************************** // ************************************************************************* // * Main class function - must call periodically for process user input. // * If timer used, this function must be called from interrupt handler. void ProcessInput(void); // ************************************************************************* // *** Process Encoders Input function ********************************* // ************************************************************************* void ProcessEncodersInput(void); // ************************************************************************* // *** Get device type ************************************************* // ************************************************************************* ExtDeviceType GetDeviceType(PortType port); // ************************************************************************* // *** Get button state ************************************************ // ************************************************************************* // Return button state: true - pressed, false - unpressed bool GetButtonState(PortType port, ButtonType button); // ************************************************************************* // *** Get button state ************************************************ // ************************************************************************* // Return button state change flag: true - changed, false - not changed bool GetButtonState(PortType port, ButtonType button, bool&amp; btn_state); // ************************************************************************* // *** Get encoder counts from last call ******************************* // ************************************************************************* // * Return state of encoder. Class counts encoder clicks and stored inside. // * This function substract from current encoder counter last_enc_val and // * return it to user. Before return last_enc_val will be assigned to // * current encoder counter. int32_t GetEncoderState(PortType port, int32_t&amp; last_enc_val); // ************************************************************************* // *** Get button state ************************************************ // ************************************************************************* // Return button state: true - pressed, false - unpressed bool GetEncoderButtonState(PortType port, EncButtonType button); // ************************************************************************* // *** Get encoder button state **************************************** // ************************************************************************* // Return button state: true - pressed, false - unpressed bool GetEncoderButtonState(PortType port, EncButtonType button, bool&amp; btn_state); // ************************************************************************* // *** Get joystick counts from last call ****************************** // ************************************************************************* void GetJoystickState(PortType port, int32_t&amp; x, int32_t&amp; y); // ************************************************************************* // *** SetJoystickCalibrationConsts ************************************ // ************************************************************************* // * Set calibration constants. Must be call for calibration joystick. void SetJoystickCalibrationConsts(PortType port, int32_t x_mid, int32_t x_kmin, int32_t x_kmax, int32_t y_mid, int32_t y_kmin, int32_t y_kmax); // ************************************************************************* // *** Get joystick button state *************************************** // ************************************************************************* // Return button state: true - pressed, false - unpressed bool GetJoystickButtonState(PortType port); // ************************************************************************* // *** Get joystick button state *************************************** // ************************************************************************* // Return button state: true - pressed, false - unpressed bool GetJoystickButtonState(PortType port, bool&amp; btn_state); private: // How many cycles button must change state before state will be changed in // result returned by GetButtonState() function. For reduce debouncing const static uint32_t BUTTON_READ_DELAY = 4U; // Coefficient for calibration const static int32_t COEF = 100; // ADC max value - 12 bit const static int32_t ADC_MAX_VAL = 0xFFF; // Joystich threshold const static int32_t JOY_THRESHOLD = 1000; // Ticks variable uint32_t last_wake_ticks = 0U; // ************************************************************************* // *** Structure to describe button ************************************ // ************************************************************************* typedef struct { bool btn_state; // Button state returned by GetButtonState() function bool btn_state_tmp; // Temporary button state for reduce debouncing uint8_t btn_state_cnt; // Counter for reduce debouncing GPIO_TypeDef* button_port;// Button port uint16_t button_pin; // Button pin GPIO_PinState pin_state; // High/low on input treated as pressed } ButtonProfile; // ************************************************************************* // *** Structure to describe encoder *********************************** // ************************************************************************* typedef struct { // Encoder rotation int32_t enc_cnt; // Encoder counter uint8_t enc_state; // Current state of encder clock &amp; data pins GPIO_TypeDef* enc_clk_port; // Encoder clock port uint16_t enc_clk_pin; // Encoder clock pin GPIO_TypeDef* enc_data_port;// Encoder data port uint16_t enc_data_pin; // Encoder data pin } EncoderProfile; // ************************************************************************* // *** Structure to describe joysticks ********************************* // ************************************************************************* typedef struct { int32_t x_ch_val; // Joystick X axis value uint32_t x_channel; // Joystick X axis ADC channel GPIO_TypeDef* x_port; // Joystick X axis port uint16_t x_pin; // Joystick X axis pin int32_t bx; // Joystick X offset int32_t kxmin; // Joystick X coefficient int32_t kxmax; // Joystick X coefficient bool x_inverted; // Joystick X inverted flag int32_t y_ch_val; // Joystick Y axis value uint32_t y_channel; // Joystick Y axis ADC channel GPIO_TypeDef* y_port; // Joystick Y axis port uint16_t y_pin; // Joystick Y axis pin int32_t by; // Joystick Y offset int32_t kymin; // Joystick Y coefficient int32_t kymax; // Joystick Y coefficient bool y_inverted; // Joystick Y inverted flag } JoystickProfile; // ************************************************************************* // *** Structure to describe encoders ********************************** // ************************************************************************* typedef struct { EncoderProfile enc; ButtonProfile btn[ENC_BTN_MAX]; } DevEncoders; // ************************************************************************* // *** Structure to describe encoders ********************************** // ************************************************************************* typedef struct { JoystickProfile joy; ButtonProfile btn; } DevJoysticks; // ************************************************************************* // *** Structure to describe buttons *********************************** // ************************************************************************* typedef struct { ButtonProfile button[BTN_MAX]; } DevButtons; // *** Array describes types of connected devices *********************** ExtDeviceType devices[EXT_MAX]; // *** Structures array for describe buttons inputs ********************* DevButtons buttons[EXT_MAX] = { // Left device {{{false, false, 0, EXT_L1_GPIO_Port, EXT_L1_Pin, GPIO_PIN_RESET}, {false, false, 0, EXT_L2_GPIO_Port, EXT_L2_Pin, GPIO_PIN_RESET}, {false, false, 0, EXT_L3_GPIO_Port, EXT_L3_Pin, GPIO_PIN_RESET}, {false, false, 0, EXT_L4_GPIO_Port, EXT_L4_Pin, GPIO_PIN_RESET}}}, // Right device {{{false, false, 0, EXT_R1_GPIO_Port, EXT_R1_Pin, GPIO_PIN_RESET}, {false, false, 0, EXT_R2_GPIO_Port, EXT_R2_Pin, GPIO_PIN_RESET}, {false, false, 0, EXT_R3_GPIO_Port, EXT_R3_Pin, GPIO_PIN_RESET}, {false, false, 0, EXT_R4_GPIO_Port, EXT_R4_Pin, GPIO_PIN_RESET}}} }; // *** Structures array for describe encoders inputs ******************** DevEncoders encoders[EXT_MAX] = { // Left device {{0, 0, EXT_L1_GPIO_Port, EXT_L1_Pin, EXT_L2_GPIO_Port, EXT_L2_Pin}, // Encoder {{false, false, 0, EXT_L3_GPIO_Port, EXT_L3_Pin, GPIO_PIN_RESET}, // Button Enter {false, false, 0, EXT_L4_GPIO_Port, EXT_L4_Pin, GPIO_PIN_SET}}}, // Button Back // Right device {{0, 0, EXT_R1_GPIO_Port, EXT_R1_Pin, EXT_R2_GPIO_Port, EXT_R2_Pin}, // Encoder {{false, false, 0, EXT_R3_GPIO_Port, EXT_R3_Pin, GPIO_PIN_RESET}, // Button Enter {false, false, 0, EXT_R4_GPIO_Port, EXT_R4_Pin, GPIO_PIN_SET}}} // Button Back }; // *** Structures array for describe encoders inputs ******************** DevJoysticks joysticks[EXT_MAX] = { // Left device {{0, ADC_CHANNEL_11, EXT_L2_GPIO_Port, EXT_L2_Pin, 0, COEF, COEF, false, // Joystick 0, ADC_CHANNEL_10, EXT_L1_GPIO_Port, EXT_L1_Pin, 0, COEF, COEF, true}, {false, false, 0, EXT_L3_GPIO_Port, EXT_L3_Pin, GPIO_PIN_RESET}}, // Button // Right device {{0, ADC_CHANNEL_13, EXT_R2_GPIO_Port, EXT_R2_Pin, 0, COEF, COEF, false, // Joystick 0, ADC_CHANNEL_12, EXT_R1_GPIO_Port, EXT_R1_Pin, 0, COEF, COEF, true}, {false, false, 0, EXT_R3_GPIO_Port, EXT_R3_Pin, GPIO_PIN_RESET}} // Button }; // Handle to timer used for process encoders input TIM_HandleTypeDef* htim = nullptr; // Handle to timer used for process encoders input ADC_HandleTypeDef* hadc = nullptr; // ************************************************************************* // *** Process Button Input function *********************************** // ************************************************************************* void ProcessButtonInput(ButtonProfile&amp; button); // ************************************************************************* // *** Process Encoder Input function ********************************** // ************************************************************************* void ProcessEncoderInput(EncoderProfile&amp; encoder); // ************************************************************************* // *** Process Joystick Input function ********************************* // ************************************************************************* void ProcessJoystickInput(JoystickProfile&amp; joysticks, PortType port); // ************************************************************************* // *** Emulate buttons using joystick function ************************* // ************************************************************************* void EmulateButtonsByJoystick(PortType port); // ************************************************************************* // *** Emulate encoders using buttons function ************************* // ************************************************************************* void EmulateEncodersByButtons(PortType port); // ************************************************************************* // *** Configure inputs devices types ********************************** // ************************************************************************* ExtDeviceType DetectDeviceType(PortType port); // ************************************************************************* // *** Configure ADC *************************************************** // ************************************************************************* void ConfigADC(ExtDeviceType dev_left, ExtDeviceType dev_right); // ************************************************************************* // *** Configure inputs for read digital/analog data ******************* // ************************************************************************* void ConfigInputIO(bool is_digital, PortType port); // ************************************************************************* // ** Private constructor. Only GetInstance() allow to access this class. ** // ************************************************************************* InputDrv() : AppTask(INPUT_DRV_TASK_STACK_SIZE, INPUT_DRV_TASK_PRIORITY, "InputDrv") {}; }; #endif</span></span></code> </pre> </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tugas </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pemeliharaan layar</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> adalah </font><font style="vertical-align: inherit;">tugas </font><font style="vertical-align: inherit;">yang paling menarik. Untuk memulainya, layarnya berukuran 320x240x16bit, jadi Anda perlu </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">153600 byte</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> untuk framebuffer. Ini bukan hanya banyak, ini sangat besar - dalam mikrokontroler ini hanya ada 192k RAM, dan dalam mikrokontroler mungkin lebih mudah untuk tidak memiliki ukuran yang tepat sama sekali. Bagaimana menjadi? Jawabannya sederhana: gambarkan layar menjadi beberapa bagian! Tetapi Anda dapat menggambar sesuatu dengan cara yang berbeda ... </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Solusi yang saya terapkan untuk tugas ini sama seperti semua yang cerdik. Ini memiliki buffer pada dua garis layar. Kami menggambar semua yang seharusnya berada dalam satu baris, mengirimkannya ke layar melalui SPI dalam mode DMA, dan saat ini kami dapat menyiapkan baris lain. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bagaimana tugas tahu apa yang harus ada dalam barisan dan bagaimana cara menggambarnya? Tapi dia </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tidak tahu!</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tapi dia punya daftar benda yang tahu cara menggambar dirinya sendiri. </font><font style="vertical-align: inherit;">Setiap objek tersebut diwarisi dari kelas </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">VisObject</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Header</font></font></b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//****************************************************************************** // @file VisObject.h // @author Nicolai Shlapunov // // @details DevCore: Visual Object Base Class, header // // @section LICENSE // // Software License Agreement (BSD License) // // Copyright (c) 2016, Devtronic &amp; Nicolai Shlapunov // All rights reserved. // // Redistribution and use in source and binary forms, with or without // modification, are permitted provided that the following conditions are met: // 1. Redistributions of source code must retain the above copyright // notice, this list of conditions and the following disclaimer. // 2. Redistributions in binary form must reproduce the above copyright // notice, this list of conditions and the following disclaimer in the // documentation and/or other materials provided with the distribution. // 3. Neither the name of the Devtronic nor the names of its contributors // may be used to endorse or promote products derived from this software // without specific prior written permission. // // THIS SOFTWARE IS PROVIDED BY DEVTRONIC ''AS IS'' AND ANY EXPRESS OR IMPLIED // WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF // MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. // IN NO EVENT SHALL DEVTRONIC BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, // SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED // TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR // PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY // LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING // NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS // SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. // //****************************************************************************** #ifndef VisObject_h #define VisObject_h // ***************************************************************************** // *** Includes ************************************************************ // ***************************************************************************** #include "DevCfg.h" // ***************************************************************************** // * VisObject class. This class implements base Visual Objects properties. class VisObject { public: // ************************************************************************* // *** Action ********************************************************** // ************************************************************************* typedef enum { ACT_TOUCH, // When object touched ACT_UNTOUCH, // When object detouched ACT_MOVE, // When object moved on object ACT_MOVEIN, // When object moved in to object ACT_MOVEOUT, // When object moved out of object ACT_MAX // Total possible actions } ActionType; // ************************************************************************* // *** VisObject ******************************************************* // ************************************************************************* VisObject() {}; // ************************************************************************* // *** ~VisObject ****************************************************** // ************************************************************************* // * Destructor. Call DelVisObjectFromList() from DisplayDrv class for // * remove from list before delete and delete semaphore. virtual ~VisObject(); // ************************************************************************* // *** LockVisObject *************************************************** // ************************************************************************* void LockVisObject(); // ************************************************************************* // *** UnlockVisObject ************************************************* // ************************************************************************* void UnlockVisObject(); // ************************************************************************* // *** Show ************************************************************ // ************************************************************************* // * Show VisObject on screen. This function call AddVisObjectToList() from // * DisplayDrv class. When this function calls first time, user must // * provide Z level. In future user can call this function without // * parameters - previously set Z will be used. virtual void Show(uint32_t z_pos = 0); // ************************************************************************* // *** Hide ************************************************************ // ************************************************************************* // * Hide VisObject from screen. This function call DelVisObjectFromList() // * from DisplayDrv class. virtual void Hide(void); // ************************************************************************* // *** IsShow ********************************************************** // ************************************************************************* // * Check status of Show Visual Object. Return true if object in DisplayDrv list. virtual bool IsShow(void); // ************************************************************************* // *** Move ************************************************************ // ************************************************************************* // * Move object on screen. Set new x and y coordinates. If flag is set - // * move is relative, not absolute. virtual void Move(int32_t x, int32_t y, bool is_delta = false); // ************************************************************************* // *** DrawInBufH ****************************************************** // ************************************************************************* // * Draw one horizontal line of object in specified buffer. // * Each derived class must implement this function. virtual void DrawInBufH(uint16_t* buf, int32_t n, int32_t row, int32_t start_y = 0) = 0; // ************************************************************************* // *** DrawInBufW ****************************************************** // ************************************************************************* // * Draw one vertical line of object in specified buffer. // * Each derived class must implement this function. virtual void DrawInBufW(uint16_t* buf, int32_t n, int32_t line, int32_t start_x = 0) = 0; // ************************************************************************* // *** Action ********************************************************** // ************************************************************************* virtual void Action(ActionType action, int32_t tx, int32_t ty); // ************************************************************************* // *** Return Start X coordinate *************************************** // ************************************************************************* virtual int32_t GetStartX(void) {return x_start;}; // ************************************************************************* // *** Return Start Y coordinate *************************************** // ************************************************************************* virtual int32_t GetStartY(void) {return y_start;}; // ************************************************************************* // *** Return End X coordinate ***************************************** // ************************************************************************* virtual int32_t GetEndX(void) {return x_end;}; // ************************************************************************* // *** Return End Y coordinate ***************************************** // ************************************************************************* virtual int32_t GetEndY(void) {return y_end;}; // ************************************************************************* // *** Return Width of object ****************************************** // ************************************************************************* virtual int32_t GetWidth(void) {return width;}; // ************************************************************************* // *** Return Height of object ***************************************** // ************************************************************************* virtual int32_t GetHeight(void) {return height;}; protected: // ************************************************************************* // *** Object parameters *********************************************** // ************************************************************************* // X and Y start coordinates of object int16_t x_start = 0, y_start = 0; // X and Y end coordinates of object int16_t x_end = 0, y_end = 0; // Width and Height of object int16_t width = 0, height = 0; // Rotation of object int8_t rotation = 0; // Object active bool active = false; private: // ************************************************************************* // *** Object parameters *********************************************** // ************************************************************************* // * Only base class and DisplayDrv have access to this parameters // Z position of object uint16_t z = 0; // Pointer to next object. This pointer need to maker object list. Object // can be added only to one list. VisObject* p_next = nullptr; // Pointer to next object. This pointer need to maker object list. Object // can be added only to one list. VisObject* p_prev = nullptr; // DisplayDrv is friend for access to pointers and Z friend class DisplayDrv; }; #endif</span></span></code> </pre> </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tugas pemeliharaan layar untuk setiap baris melewati daftar objek dan memanggil fungsi DrawInBufW (), meneruskannya dengan pointer ke buffer, jumlah titik, garis yang akan ditarik, dan posisi awal ( </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sampai ide menggunakan mode pengontrol layar untuk memperbarui "jendela" digunakan</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). Faktanya, setiap objek menggambar dirinya sendiri di atas yang lain yang sudah digambar dan mudah untuk mengatur objek dalam urutan yang diperlukan hanya dengan menempatkannya di posisi yang diinginkan dalam daftar. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Selain itu, pendekatan ini membuatnya mudah untuk mengintegrasikan pemrosesan objek aktif - setelah menerima koordinat dari pengontrol layar sentuh, tugas perawatan layar dapat melalui lembar kerja dari ujung untuk mencari objek aktif yang jatuh ke dalam koordinat penekanan. Jika objek tersebut ditemukan, fungsi virtual Action () dipanggil untuk objek yang diberikan.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Saat ini, ada objek untuk garis, primitif ( </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">garis, persegi, lingkaran</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ), gambar dan peta ubin ( </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">untuk membuat game</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Juga di </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">DevCore</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> memasuki kode lain untuk beberapa elemen UI ( </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">seperti menu</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ), antarmuka untuk driver I2C, sopir I2C dan perpustakaan untuk bekerja dengan sensor BME280 dan EEPROM 24S256, tetapi tidak begitu menarik, namun saya tidak akan menjelaskan - dan ternyata cukup besar . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kode lengkap tersedia </font></font><s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tanpa registrasi dan SMS</font></font></s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> di </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GitHub</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">https://github.com/nickshl/devboy </font></font></a> <br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PS</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Rupanya, perusahaan pergi ke Epic Fail. Pada minggu pertama, hanya tiga tukang roti, termasuk satu dolar dari semacam " </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dana Inovasi</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">", $ 180 dari seseorang yang mungkin belajar tentang proyek ini dari sebuah artikel tentang Habr√© ( </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Terima kasih, Andrey!</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) Dan sisanya dari rekan saya dari kubus tetangga. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tidak mengumpulkan uang bukanlah masalah. Masalahnya adalah kurangnya minat pada proyek ...</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id424309/">https://habr.com/ru/post/id424309/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id424295/index.html">Kursus MIT "Keamanan Sistem Komputer". Kuliah 9: "Keamanan Aplikasi Web," Bagian 2</a></li>
<li><a href="../id424297/index.html">Kursus MIT "Keamanan Sistem Komputer". Kuliah 9: Keamanan Aplikasi Web, Bagian 3</a></li>
<li><a href="../id424301/index.html">Algoritma Filter Gambar Jaringan Syaraf Adaptif</a></li>
<li><a href="../id424305/index.html">RIB Arsitektur Arsitektur Lintas Platform Uber</a></li>
<li><a href="../id424307/index.html">GitLab 11.3 dirilis dengan repositori Maven dan Lingkungan aman</a></li>
<li><a href="../id424311/index.html">Logika bisnis asinkron hari ini</a></li>
<li><a href="../id424313/index.html">EveryLang adalah program yang dapat melakukan hampir semua hal</a></li>
<li><a href="../id424315/index.html">Babak baru substitusi impor. Di mana harus lari dan apa yang harus dilakukan?</a></li>
<li><a href="../id424319/index.html">Struktur toko online. Bagian 2</a></li>
<li><a href="../id424321/index.html">Puting NetFlow Murah dan Marah</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>