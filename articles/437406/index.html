<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>   Microkernel seL4. Verificaci贸n formal de programas en el mundo real.   </title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Se public贸 un art铆culo cient铆fico en Communications of the ACM , octubre de 2018, Volumen 61, N煤mero 10, pp. 68-77, doi: 10.1145 / 3230627 

 En febre...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Microkernel seL4. Verificaci贸n formal de programas en el mundo real.</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/437406/">  <font color="gray">Se public贸 un art铆culo cient铆fico en <i>Communications of the ACM</i> , octubre de 2018, Volumen 61, N煤mero 10, pp. 68-77, doi: 10.1145 / 3230627</font> <br><br><img src="https://habrastorage.org/getpro/habr/post_images/549/555/096/549555096952b991fe97a964cd19d97b.jpg" align="left">  En febrero de 2017, un helic贸ptero despeg贸 de la pista de aterrizaje del Boeing en Arizona con la misi贸n habitual: volar alrededor de las colinas m谩s cercanas.  Vol贸 de manera completamente aut贸noma.  De acuerdo con los requisitos de seguridad de la Administraci贸n Federal de Aviaci贸n de EE. UU., El piloto no toc贸 los controles.  Este no fue el primer vuelo aut贸nomo AH-6, que la compa帽铆a llama El peque帽o p谩jaro no tripulado (ULB).  l ha estado volando as铆 durante muchos a帽os.  Sin embargo, esta vez en medio del vuelo, el helic贸ptero sufri贸 un ataque cibern茅tico.  La computadora de a bordo atac贸 el software malicioso de la videoc谩mara, as铆 como el virus entregado a trav茅s de la unidad flash infectada, que se insert贸 durante el mantenimiento.  El ataque amenaz贸 algunos subsistemas, pero no pudo afectar la operaci贸n segura de la aeronave. <br><a name="habracut"></a><br><h1>  Ideas clave </h1><br><ul><li>  La evidencia formal de la arquitectura de software de un microkernel verificado se puede escalar de manera econ贸mica a sistemas reales. </li><li>  Son posibles y deseables diferentes niveles de seguridad y confiabilidad dentro del mismo sistema.  No es necesario garantizar la m谩xima fiabilidad de todo el c贸digo. </li><li>  Un redise帽o y refactorizaci贸n moderados es suficiente para elevar los sistemas existentes al nivel de c贸digo altamente confiable. </li></ul><br>  Se podr铆a pensar que la aviaci贸n militar puede repeler f谩cilmente un ataque cibern茅tico de este tipo.  En realidad, el equipo de pentesters profesionales encargados por la agencia DARPA, como parte del programa de Sistemas de Seguridad Cibern茅tica Militar (HACMS) para desarrollar sistemas inform谩ticos militares altamente confiables, hacke贸 con 茅xito la primera versi贸n del software ULB en 2013, que fue desarrollado originalmente para garantizar la seguridad del vuelo en lugar de la protecci贸n de los ciberataques.  Los hackers tuvieron la oportunidad de estrellar un helic贸ptero o aterrizarlo en cualquier lugar que lo deseen.  Por lo tanto, el riesgo de tales ataques con un pasajero a bordo dif铆cilmente se puede sobreestimar, y un intento de pirater铆a fallido en febrero de 2017 indica algunos cambios fundamentales en el software. <br><br>  Este art铆culo explica estos cambios y la tecnolog铆a que los hizo posibles.  Esta es una tecnolog铆a desarrollada como parte del programa HACMS destinado a garantizar el funcionamiento seguro de los sistemas cr铆ticos en un entorno cibern茅tico hostil, en este caso, varios veh铆culos aut贸nomos.  La tecnolog铆a se basa en la verificaci贸n formal de software: son programas con pruebas matem谩ticas verificadas autom谩ticamente que funcionan de acuerdo con sus especificaciones.  Aunque el art铆culo no est谩 dedicado a los m茅todos formales en s铆, explica c贸mo usar la verificaci贸n de artefactos para proteger los sistemas reales en la pr谩ctica. <br><br>  Quiz谩s el resultado m谩s impresionante de HACMS es que la tecnolog铆a se puede extender a los sistemas reales existentes, mejorando en gran medida su protecci贸n contra los ataques cibern茅ticos.  Este proceso se llama "modernizaci贸n de la seguridad s铆smica", similar a las actualizaciones de edificios s铆smicos.  Adem谩s, la mayor parte de la reingenier铆a fue realizada por ingenieros de Boeing, en lugar de especialistas en verificaci贸n formal. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/e6f/fbc/1ac/e6ffbc1ac1fb4083ac3961fe43bf8f6e.jpg"><br>  <font color="gray">"P谩jaro" durante un vuelo de prueba no tripulado</font> <br><br>  No todo el software del helic贸ptero se basa en modelos matem谩ticos y evidencia.  El campo de la verificaci贸n formal a煤n no est谩 listo para tal escala.  Sin embargo, el programa HACMS ha demostrado que la aplicaci贸n estrat茅gica de m茅todos formales a las partes m谩s importantes del sistema general mejora enormemente la protecci贸n.  El enfoque HACMS funciona para sistemas en los que la caracter铆stica de seguridad deseada se puede lograr simplemente aplicando a nivel de arquitectura.  Se basa en nuestro microkernel verificado sel4, del que hablaremos a continuaci贸n.  Garantiza el aislamiento entre subsistemas, con la excepci贸n de canales de comunicaci贸n claramente definidos que est谩n sujetos a las pol铆ticas de seguridad del sistema.  Este aislamiento est谩 garantizado a nivel de arquitectura con el marco verificado de CAmkES para los componentes del sistema.  Uso de lenguajes espec铆ficos de dominio de Galois Inc.  CAmkES se integra con herramientas de an谩lisis de arquitectura de Rockwell Collins y la Universidad de Minnesota, as铆 como con componentes de software altamente confiables. <br><br>  Los logros de HACMS se basan en el viejo amigo fiel de un ingeniero de software: la modularizaci贸n.  La innovaci贸n es que los m茅todos formales prueban la observabilidad de las interfaces y la encapsulaci贸n de los componentes internos del m贸dulo.  Esta adhesi贸n garantizada a la modularidad permite a los ingenieros que no son expertos en m茅todos formales (como en Boeing) crear sistemas nuevos o incluso modernizar los existentes y lograr una alta estabilidad.  Aunque las herramientas a煤n no proporcionan evidencia completa de la seguridad del sistema. <br><br><h1>  Verificaci贸n formal </h1><br>  La evidencia de la correcci贸n matem谩tica de los programas se remonta al menos a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">la d茅cada de 1960</a> , pero durante mucho tiempo sus beneficios reales para el desarrollo de software fueron limitados en alcance y profundidad.  Sin embargo, en los 煤ltimos a帽os ha habido una serie de avances impresionantes en la verificaci贸n formal a nivel de c贸digo de sistemas reales, desde el compilador C <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">CompCert</a> verificado <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">hasta el</a> microkernel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">seL4</a> verificado (vea los <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">art铆culos</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">cient铆ficos al</a> respecto), el sistema de conferencia verificado <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">CoCon</a> , el compilador <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">CakeML</a> ML verificado, programas verificados para probar los teoremas de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Milawa</a> y <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Candle</a> , el sistema de archivos <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">FSCQ a</a> prueba de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">fallos</a> verificado, el sistema distribuido IronFleet verificado y el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">marco de</a> kernel paralelo CertiKOS verificado, as铆 como importantes  teoremas matem谩ticos, incluidos los <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">problemas de cuatro colores</a> , la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">prueba</a> autom谩tica <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">de la hip贸tesis de Kepler</a> y <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">el teorema de Fe - Thompson en orden impar</a> .  Todos estos son sistemas reales.  Por ejemplo, CompCert es un producto comercial, el microkernel seL4 se utiliza en aeronaves aeroespaciales y no tripuladas, como la plataforma de Internet de las cosas, y el sistema CoCon se ha utilizado en numerosas conferencias cient铆ficas grandes. <br><br>  Estos proyectos de verificaci贸n requieren un esfuerzo considerable.  Para que los m茅todos formales est茅n disponibles al p煤blico, estos esfuerzos deben reducirse.  Aqu铆 demostramos c贸mo una combinaci贸n estrat茅gica de m茅todos formales e informales, la automatizaci贸n parcial de m茅todos formales y un cuidadoso desarrollo de software para maximizar los beneficios de los componentes aislados nos han permitido aumentar significativamente la confiabilidad de los sistemas cuyo tama帽o y complejidad general son 贸rdenes de magnitud mayores que los mencionados anteriormente. <br><br>  Tenga en cuenta que aplicamos la verificaci贸n formal principalmente para el c贸digo del que depende la seguridad del sistema.  Pero hay otros beneficios.  Por ejemplo, la evidencia de que el c贸digo es correcto hace suposiciones sobre el contexto en el que se ejecuta (por ejemplo, el comportamiento del hardware y la configuraci贸n del software).  La verificaci贸n formal hace expl铆citos estos supuestos, lo que ayuda a los desarrolladores a centrarse en otras herramientas de verificaci贸n, como las pruebas.  Adem谩s, en muchos casos, el sistema incluye c贸digo tanto verificado como no verificado.  Durante las revisiones de c贸digo, las pruebas y la depuraci贸n, la verificaci贸n formal act煤a como una lente, centr谩ndose en el c贸digo del sistema cr铆tico y no verificado. <br><br><h1>  seL4 </h1><br>  Comencemos con la base para construir sistemas demostrablemente confiables: el n煤cleo del sistema operativo (SO).  Esta es la parte m谩s importante que garantiza la confiabilidad de todo el sistema de manera rentable. <br><br>  El microkernel seL4 proporciona un conjunto m铆nimo de mecanismos formalmente verificados para implementar sistemas seguros.  A diferencia de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">los n煤cleos est谩ndar</a> , es a prop贸sito universal y, por lo tanto, adecuado para implementar una serie de pol铆ticas de seguridad y requisitos del sistema. <br><br>  Uno de los objetivos principales del desarrollo de seL4 es proporcionar un fuerte aislamiento entre los componentes que desconf铆an mutuamente y que se ejecutan en la parte superior del n煤cleo.  Admite su trabajo como hipervisor, por ejemplo, para sistemas operativos Linux completos, mientras los mantiene aislados de los componentes cr铆ticos para la seguridad que pueden funcionar juntos, como se muestra en la Figura 1. En particular, esta funci贸n permite a los desarrolladores de sistemas usar componentes heredados con componentes ocultos vulnerabilidades junto a componentes altamente confiables. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/c8c/e73/dfe/c8ce73dfe32eec8ecbef90268fd802d3.jpg"><br>  <i><font color="gray">Fig.</font></i>  <i><font color="gray">1. Aislamiento y comunicaciones controladas en seL4</font></i> <br><br>  El n煤cleo seL4 ocupa una posici贸n especial entre los micron煤cleos de uso general.  No solo proporciona un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">mejor rendimiento en su clase</a> , sus 10,000 l铆neas de c贸digo C han sido sometidas a una verificaci贸n formal m谩s rigurosa que cualquier otro software disponible p煤blicamente en la historia humana en t茅rminos no solo de l铆neas de prueba, sino tambi茅n de la solidez de las propiedades comprobadas.  Se basa en la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">prueba de la "correcci贸n funcional" de la implementaci贸n central en C.</a>  Asegura que cualquier comportamiento del n煤cleo se prediga por su especificaci贸n abstracta formal: consulte la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aplicaci贸n en l铆nea</a> para obtener una idea de c贸mo se ve esta evidencia.  Despu茅s de esta garant铆a, hemos agregado evidencia adicional que explicaremos despu茅s de la introducci贸n a los mecanismos b谩sicos del n煤cleo. <br><br><h3>  seL4 API </h3><br>  El n煤cleo seL4 proporciona un conjunto m铆nimo de mecanismos para implementar sistemas seguros: transmisiones, gesti贸n de capacidades, espacios de direcciones virtuales, comunicaci贸n entre procesos (IPC), se帽alizaci贸n y entrega de interrupciones. <br><br>  El n煤cleo retiene su estado en los "objetos del n煤cleo".  Por ejemplo, para cada subproceso en el sistema, hay un "objeto de flujo" que almacena informaci贸n sobre el desprendimiento, la ejecuci贸n y el control de acceso.  Los programas de espacio de usuario pueden referirse a los objetos del n煤cleo solo indirectamente a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">trav茅s de las llamadas "capacidades"</a> o "capacidades", que combinan un enlace a un objeto con un conjunto de derechos de acceso a 茅l.  Por ejemplo, un hilo no puede iniciar o detener otro hilo si no tiene la "habilidad" para el objeto de hilo correspondiente. <br><br>  Los hilos interact煤an y se sincronizan enviando mensajes a trav茅s de "puntos finales" de comunicaci贸n entre procesos.  Un hilo con la capacidad de enviar al punto final correspondiente puede enviar un mensaje a otro hilo que tiene la capacidad de recibir a este punto final.  Los objetos de notificaci贸n proporcionan sincronizaci贸n entre conjuntos de sem谩foros binarios.  La traducci贸n de direcciones virtuales est谩 controlada por objetos del n煤cleo que representan directorios de p谩ginas, tablas de p谩ginas y objetos de marco o abstracciones sutiles sobre los objetos de arquitectura de procesador correspondientes.  Cada secuencia tiene una cierta capacidad "VSpace", que apunta a la ra铆z del 谩rbol de objetos de traducci贸n de direcciones de secuencia.  Las capacidades en s铆 son administradas por el n煤cleo y almacenadas en los objetos del n煤cleo "CNodes" ubicados en la estructura del gr谩fico, que asigna enlaces a objetos con derechos de acceso, de forma similar a la comparaci贸n de tablas de p谩ginas virtuales con direcciones f铆sicas en la memoria.  Cada hilo tiene su propia capacidad para identificar el c贸digo CN ra铆z.  El conjunto de capacidades disponibles desde esta ra铆z, lo llamamos "CSpace Stream".  Las habilidades se pueden transferir a trav茅s de puntos finales con transferencia de trabajo, y tambi茅n se pueden declarar compartidas usando CSpace com煤n.  La Figura 2 muestra estos objetos del n煤cleo. <br><br> <a href=""><img src="https://habrastorage.org/webt/cy/vr/ea/cyvreajptf3s4kcvgrlj7oyjfw8.png"></a> <br>  <i><font color="gray">Fig.</font></i>  <i><font color="gray">2. Objetos de kernel en un sistema seL4 con dos hilos que interact煤an a trav茅s de un punto final</font></i> <br><br><h3>  Evidencia de seguridad </h3><br>  Debido a su versatilidad, las API del n煤cleo seL4 son de bajo nivel y admiten arquitecturas de sistemas altamente din谩micas.  Por lo tanto, la evidencia directa de estas API es dif铆cil de obtener. <br><br>  El concepto de alto nivel de las pol铆ticas de control de acceso se extrae de objetos individuales y capacidades del n煤cleo, capturando en su lugar la configuraci贸n de control de acceso del sistema utilizando un conjunto de "sujetos" abstractos (componentes) y los poderes que cada uno de ellos tiene sobre los dem谩s (por ejemplo, para leer datos y enviar mensajes) .  En el ejemplo de la fig.  2, los componentes A y B obtuvieron autoridad sobre el punto final. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Sewell y sus colegas han</a> demostrado que las pol铆ticas de control de acceso seL4 aseguran que se respeten dos caracter铆sticas b谩sicas de seguridad: restricci贸n de privilegios e integridad. <br><br>  La restricci贸n de autoridad significa que la pol铆tica de control de acceso es una aproximaci贸n segura est谩tica (sin cambios) de capacidades espec铆ficas y objetos del n煤cleo en el sistema para cualquier estado futuro.  Esta propiedad implica que no importa c贸mo evolucione el sistema, ning煤n componente recibir谩 m谩s autoridad de lo que predice la pol铆tica de control de acceso.  En la Figura 2, la pol铆tica para el componente B no tiene acceso de escritura al componente A. Por lo tanto, el componente B nunca podr谩 obtener este acceso en el futuro.  Esta propiedad implica que el razonamiento a nivel de pol铆tica es una aproximaci贸n segura al razonamiento sobre el estado espec铆fico de control de acceso en el sistema. <br><br>  La integridad significa que no importa lo que haga el componente, nunca podr谩 cambiar los datos en el sistema (incluidas las llamadas al sistema que pueda hacer) que claramente no est谩 permitido cambiar la pol铆tica de control de acceso.  Por ejemplo, en la fig.  2, el 煤nico componente de la autoridad de A sobre otro componente es el derecho a enviar datos al punto final desde donde el componente B recibe informaci贸n. Esto significa que el componente A solo puede cambiar su estado, el estado del hilo B y el estado del b煤fer de mensajes.  No puede cambiar otras partes del sistema. <br><br>  Un efecto secundario de la integridad es la confidencialidad, cuando un componente <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">no puede leer la informaci贸n de otro componente sin permiso</a> : es una propiedad comprobada de la no interferencia no transitiva seL4.  Es decir, en un sistema configurado correctamente (con restricciones m谩s estrictas que solo la integridad), ninguno de los componentes puede, sin permiso, encontrar informaci贸n sobre otro componente o su ejecuci贸n.  La prueba expresa esta propiedad en t茅rminos de la pol铆tica de flujo de informaci贸n, que se puede extraer de la pol铆tica de control de acceso utilizada en la prueba de integridad.  La informaci贸n solo se transmitir谩 cuando la pol铆tica lo permita expl铆citamente.  La prueba cubre flujos de informaci贸n expl铆citos, as铆 como posibles canales de almacenamiento ocultos en el n煤cleo.  Pero los canales de sincronizaci贸n est谩n fuera de su 谩rea y <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">deben procesarse por otros medios</a> . <br><br>  La evidencia adicional en seL4 incluye una extensi贸n de la correcci贸n funcional y, por lo tanto, teoremas de seguridad a un nivel binario <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">para la arquitectura ARMv7</a> y un perfil de tiempo de ejecuci贸n en el peor de los casos para el n煤cleo ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">1</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">2</a> ), que es necesario para los sistemas en tiempo real.  El n煤cleo seL4 est谩 disponible para varias arquitecturas: ARMv6, ARMv7 ARMv7a, ARMv8, RISC-V, Intel x86 e Intel x64.  Por el momento, ha pasado las pruebas de m谩quina en la arquitectura ARMv7 para toda la pila de verificaci贸n, as铆 como en ARMv7a con extensiones de hipervisor para la correcci贸n funcional. <br><br><h1>  Arquitectura de seguridad </h1><br>  La secci贸n anterior describi贸 los m茅todos de programaci贸n mediante los cuales el n煤cleo seL4 crea una base s贸lida para sistemas demostrablemente confiables.  El n煤cleo forma una base inform谩tica confiable (TCB), un componente esencial del software que debe funcionar correctamente para garantizar la seguridad del sistema.  En sistemas reales, esta base es mucho m谩s amplia que solo un microkernel.  Es necesario verificar una pila de software adicional para obtener el mismo nivel de confianza que para el n煤cleo.  Sin embargo, hay clases de sistemas para los cuales no hay necesidad de dicha verificaci贸n: necesitan teoremas de aislamiento a nivel del n煤cleo para derivar ciertas propiedades de seguridad a nivel del sistema.  Esta secci贸n proporciona un ejemplo de dicho sistema. <br><br>  Estos son sistemas en los que las arquitecturas de componentes ya han implementado una propiedad cr铆tica, tal vez junto con varios componentes peque帽os de confianza.  Nuestro ejemplo es el software de control de vuelo quadcopter, un dispositivo de demostraci贸n en el programa HACMS mencionado anteriormente. <br><br>  La Figura 3 muestra los principales componentes de hardware del quadrocopter.  La arquitectura es intencionalmente m谩s compleja que la requerida por el quadcopter, ya que se supon铆a que representaba a ULB y en este nivel de abstracci贸n es similar a la arquitectura de ULB. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/0f4/a7d/3bd/0f4a7d3bd00cb793457c03e11db9bd08.jpg"><br>  <i><font color="gray">Fig.</font></i>  <i><font color="gray">3. Arquitectura de una aeronave aut贸noma.</font></i> <br><br>  La figura muestra dos computadoras principales: una computadora a bordo que interact煤a con la estaci贸n terrestre y controla el software a bordo (por ejemplo, la c谩mara), y una computadora de navegaci贸n para controlar el vuelo del veh铆culo, leer los datos del sensor y controlar los motores.  Las computadoras est谩n conectadas a trav茅s de una red interna o bus CAN en un quadrocopter, Ethernet en ULB.  El quadrocopter tambi茅n tiene un punto WiFi sin protecci贸n, lo que permite demostrar m茅todos de protecci贸n adicionales. <br><br>  En este ejemplo, considere una computadora a bordo.  Para ello se deben cumplir cuatro propiedades b谩sicas: <br><br><ul><li>  autenticaci贸n adecuada de comandos desde la estaci贸n terrestre; <br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> privacidad de claves criptogr谩ficas; </font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> sin mensajes adicionales para la computadora de navegaci贸n; </font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> El software no confiable de otros sistemas integrados no puede afectar el vuelo del dispositivo. </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La hip贸tesis de trabajo es que la c谩mara no es confiable, potencialmente comprometida o maliciosa, que sus controladores y software obsoleto est谩n potencialmente comprometidos, as铆 como cualquier canal de comunicaci贸n externo. </font><font style="vertical-align: inherit;">En este ejemplo, asumimos una criptograf铆a correcta y s贸lida, es decir, que la clave no puede ser recogida, y vamos m谩s all谩 del alcance de la tarea de suprimir las comunicaciones de radio del enemigo con una estaci贸n terrestre.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La Figura 4 muestra c贸mo la arquitectura quadrocopter est谩 dise帽ada para proporcionar estas propiedades. </font><font style="vertical-align: inherit;">La m谩quina virtual (VM) de Linux sirve como contenedor para el software de dispositivo integrado, los controladores de c谩mara y los puntos de acceso WiFi. </font><font style="vertical-align: inherit;">Aislamos el m贸dulo de control de criptograf铆a en su propio componente, con conexiones al bus CAN, el canal de la estaci贸n terrestre y la m谩quina virtual Linux para enviar datos a la estaci贸n terrestre. </font><font style="vertical-align: inherit;">La tarea del componente criptogr谩fico es transmitir (solo) mensajes autorizados a la computadora de a bordo a trav茅s de la interfaz CAN de la pila y enviar datos de diagn贸stico a la estaci贸n terrestre. </font><font style="vertical-align: inherit;">El componente de radio env铆a y recibe mensajes sin procesar que son cifrados y descifrados (con autenticaci贸n) por el componente criptogr谩fico.</font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/c50/909/098/c5090909891798d51b0af4045fc2d19a.jpg"><br> <i><font color="gray"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fig.4. </font><font style="vertical-align: inherit;">Arquitectura de computadora a bordo de quadcopter simplificada</font></font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Establecer las propiedades deseadas del sistema se reduce 煤nicamente a las propiedades de aislamiento y al comportamiento de la arquitectura en t茅rminos de flujos de informaci贸n, as铆 como al comportamiento de un 煤nico componente criptogr谩fico confiable. Suponiendo el comportamiento correcto de este componente, las claves no pueden verse comprometidas, ya que ning煤n otro componente tiene acceso a ellas. El canal entre Linux y el componente criptogr谩fico en la Fig. 4 est谩 destinado solo a mensajes y no da acceso a la memoria. Solo los mensajes autorizados pueden ingresar al bus CAN, porque el componente criptogr谩fico es la 煤nica comunicaci贸n con el bus. El software no confiable y WiFi, como parte de la m谩quina virtual Linux, est谩n encapsulados por el aislamiento de componentes y solo pueden interactuar con el resto del sistema a trav茅s de un componente criptogr谩fico confiable.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es f谩cil imaginar que dicho an谩lisis de arquitectura se puede automatizar en gran medida al verificar modelos y herramientas de razonamiento mec谩nico de un nivel superior. Como se </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">se帽al贸 para los sistemas MILS</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , los l铆mites de los componentes en dicha arquitectura no solo son una herramienta conveniente para la partici贸n y la gesti贸n de c贸digo, sino que con el aislamiento forzado proporcionan l铆mites efectivos para el razonamiento formal sobre el comportamiento del sistema. Sin embargo, todo depende de la aplicaci贸n adecuada de los l铆mites de los componentes en tiempo de ejecuci贸n en la implementaci贸n final del sistema binario.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Los mecanismos discutidos anteriormente del n煤cleo seL4 son capaces de proporcionar dicha implementaci贸n, pero el nivel de abstracci贸n de los mecanismos contrasta fuertemente con los bloques y flechas del esquema arquitect贸nico: una pol铆tica de control de acceso a煤n m谩s abstracta a煤n contiene muchos m谩s detalles que el esquema de arquitectura. </font><font style="vertical-align: inherit;">En un sistema real de este tama帽o, el software crea decenas de miles de objetos y "habilidades" del n煤cleo, y los errores de configuraci贸n pueden conducir a violaciones de seguridad. </font><font style="vertical-align: inherit;">Luego discutimos c贸mo no solo automatizamos la configuraci贸n y creaci贸n de dicho c贸digo, sino tambi茅n c贸mo demostrar autom谩ticamente el cumplimiento de los l铆mites de la arquitectura.</font></font><br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Verificaci贸n de componentes </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como la evidencia de seguridad se simplifica con abstracciones formales de las pol铆ticas de seguridad, la abstracci贸n tambi茅n ayuda en el dise帽o del sistema. </font><font style="vertical-align: inherit;">La plataforma componente de </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Camkes se</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ejecuta en abstracciones seL4 en la parte superior de los mecanismos del n煤cleo de bajo nivel, proporcionando primitivas de comunicaci贸n y descomponiendo el sistema en unidades funcionales, como se muestra en la Fig. </font><font style="vertical-align: inherit;">5. Utilizando esta plataforma, los arquitectos de sistemas pueden dise帽ar y construir sistemas basados en seL4 en t茅rminos de componentes de alto nivel que interact煤an entre s铆 y con dispositivos de hardware a trav茅s de conectores, como llamadas a procedimiento remoto (RPC), puertos de datos y eventos. </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/887/212/48b/88721248b5536a3f3b80501ba3a11d1c.jpg"><br> <i><font color="gray"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fig. </font><font style="vertical-align: inherit;">5. Flujo de trabajo de CAmKES</font></font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Generaci贸n de c贸digo </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Internamente, CAmkES implementa estas abstracciones utilizando objetos de kernel de bajo nivel en seL4. Cada componente contiene (al menos) una secuencia, CSpace y VSpace. Los conectores RPC usan objetos de punto final y CAmkES genera c贸digo intermedio para procesar mensajes y enviarlos a puntos finales IPC. Del mismo modo, el conector del puerto de datos se implementa a trav茅s de la memoria compartida (tramas comunes presentes en los espacios de direcciones de dos componentes) y, opcionalmente, puede limitar la direcci贸n de la transferencia de datos. Finalmente, el conector de eventos se implementa utilizando el mecanismo de notificaci贸n seL4. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CAmkES tambi茅n genera en </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">capDL una</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> especificaci贸n de bajo nivel de la configuraci贸n inicial de objetos y las capacidades del n煤cleo del sistema. Esta especificaci贸n se convierte en entrada para el inicializador seL4, que</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">comienza primero despu茅s de cargar y realiza las operaciones seL4 necesarias para crear una instancia e inicializar el sistema</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Por lo tanto, la plataforma componente genera c贸digo sin esfuerzo adicional por parte del desarrollador. </font><font style="vertical-align: inherit;">La arquitectura de componentes describe un conjunto de bloques y flechas, y la tarea de implementaci贸n se reduce a simplemente completar los campos. </font><font style="vertical-align: inherit;">La plataforma genera el resto, proporcionando la implementaci贸n de la arquitectura descrita. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En una plataforma con componentes tradicionales, el c贸digo generado ampliar谩 la base inform谩tica confiable del sistema, ya que puede afectar la funcionalidad de los componentes. </font><font style="vertical-align: inherit;">Sin embargo, CAmkES tambi茅n genera evidencia.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Evidencia auto </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Al generar el c贸digo "intermedio", CAmkES produce pruebas formales en Isabelle / HOL, realiza la </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">validaci贸n durante la traducci贸n</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> y demuestra que el </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">c贸digo "intermedio" generado obedece la especificaci贸n de alto nivel, y la especificaci贸n capDL generada es la especificaci贸n correcta de la descripci贸n de CAmkES</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Tambi茅n hemos demostrado que el inicializador seL4 configura correctamente el sistema en la configuraci贸n inicial requerida. Al mismo tiempo, automatizamos la mayor parte de la construcci贸n del sistema sin expandir la base inform谩tica confiable.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Los desarrolladores rara vez miran la emisi贸n de generadores de c贸digo; solo est谩n interesados en la funcionalidad y la l贸gica empresarial. </font><font style="vertical-align: inherit;">Tambi茅n asumimos que la evidencia del c贸digo intermedio no necesita ser verificada, es decir, los desarrolladores pueden enfocarse en probar la exactitud de su propio c贸digo. </font><font style="vertical-align: inherit;">As铆 como el encabezado CAmkES generado le da al desarrollador una API para el c贸digo generado, los operadores de lema de nivel superior producen una API como prueba. </font><font style="vertical-align: inherit;">Los lemas describen el comportamiento esperado de los conectores. </font><font style="vertical-align: inherit;">En el ejemplo de middleware RPC en la Figura </font><font style="vertical-align: inherit;">6 funciones generadas</font></font><math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> proporciona una forma de llamar a una funci贸n remota</font></font><span class="MathJax_SVG" id="MathJax-Element-1-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>f</mi></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.279ex" height="2.419ex" viewBox="0 -780.1 550.5 1041.5" role="img" focusable="false" style="vertical-align: -0.607ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/437406/&amp;usg=ALkJrhjaKR67UFZ-jxhbT17oWWD1iE1e-g#MJMATHI-66" x="0" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>f</mi></math></span></span><script type="math/tex" id="MathJax-Element-1"> f </script><font style="vertical-align: inherit;"></font><math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> en otro componente. </font><font style="vertical-align: inherit;">Para guardar la abstracci贸n, llame</font></font><span class="MathJax_SVG" id="MathJax-Element-2-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>g</mi></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.116ex" height="1.817ex" viewBox="0 -520.7 480.5 782.1" role="img" focusable="false" style="vertical-align: -0.607ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/437406/&amp;usg=ALkJrhjaKR67UFZ-jxhbT17oWWD1iE1e-g#MJMATHI-67" x="0" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>g</mi></math></span></span><script type="math/tex" id="MathJax-Element-2"> g </script><font style="vertical-align: inherit;"></font><math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> deber铆a ser equivalente a llamar</font></font><span class="MathJax_SVG" id="MathJax-Element-3-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>f</mi></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.279ex" height="2.419ex" viewBox="0 -780.1 550.5 1041.5" role="img" focusable="false" style="vertical-align: -0.607ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/437406/&amp;usg=ALkJrhjaKR67UFZ-jxhbT17oWWD1iE1e-g#MJMATHI-66" x="0" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>f</mi></math></span></span><script type="math/tex" id="MathJax-Element-3"> f </script><font style="vertical-align: inherit;"></font><math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-4-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>g</mi></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.116ex" height="1.817ex" viewBox="0 -520.7 480.5 782.1" role="img" focusable="false" style="vertical-align: -0.607ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/437406/&amp;usg=ALkJrhjaKR67UFZ-jxhbT17oWWD1iE1e-g#MJMATHI-67" x="0" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>g</mi></math></span></span><script type="math/tex" id="MathJax-Element-4"> g </script>  .<font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> El sistema generado lemma asegura que </font></font><math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> del c贸digo RPC generado se comporta como una llamada directa</font></font><span class="MathJax_SVG" id="MathJax-Element-5-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>f</mi></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.279ex" height="2.419ex" viewBox="0 -780.1 550.5 1041.5" role="img" focusable="false" style="vertical-align: -0.607ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/437406/&amp;usg=ALkJrhjaKR67UFZ-jxhbT17oWWD1iE1e-g#MJMATHI-66" x="0" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>f</mi></math></span></span><script type="math/tex" id="MathJax-Element-5"> f </script><font style="vertical-align: inherit;"></font><math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-6-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>g</mi></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.116ex" height="1.817ex" viewBox="0 -520.7 480.5 782.1" role="img" focusable="false" style="vertical-align: -0.607ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/437406/&amp;usg=ALkJrhjaKR67UFZ-jxhbT17oWWD1iE1e-g#MJMATHI-67" x="0" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>g</mi></math></span></span><script type="math/tex" id="MathJax-Element-6"> g </script>  . <br><br><img src="https://habrastorage.org/getpro/habr/post_images/61e/b0f/111/61eb0f111ab2d64688c3c42aadaba3ab.jpg"><br> <i><font color="gray"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fig. </font><font style="vertical-align: inherit;">6. C贸digo RPC generado</font></font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Para el uso real de evidencia generada por el sistema, deben ser componibles con (casi) evidencia arbitraria provista por el usuario, como para una funci贸n</font></font><math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , y para contextos en los que</font></font><span class="MathJax_SVG" id="MathJax-Element-7-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>g</mi></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.116ex" height="1.817ex" viewBox="0 -520.7 480.5 782.1" role="img" focusable="false" style="vertical-align: -0.607ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/437406/&amp;usg=ALkJrhjaKR67UFZ-jxhbT17oWWD1iE1e-g#MJMATHI-67" x="0" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>g</mi></math></span></span><script type="math/tex" id="MathJax-Element-7"> g </script><font style="vertical-align: inherit;"></font><math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-8-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>g</mi></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.116ex" height="1.817ex" viewBox="0 -520.7 480.5 782.1" role="img" focusable="false" style="vertical-align: -0.607ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/437406/&amp;usg=ALkJrhjaKR67UFZ-jxhbT17oWWD1iE1e-g#MJMATHI-67" x="0" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>g</mi></math></span></span><script type="math/tex" id="MathJax-Element-8"> g </script>  y <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-9-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>f</mi></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.279ex" height="2.419ex" viewBox="0 -780.1 550.5 1041.5" role="img" focusable="false" style="vertical-align: -0.607ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/437406/&amp;usg=ALkJrhjaKR67UFZ-jxhbT17oWWD1iE1e-g#MJMATHI-66" x="0" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>f</mi></math></span></span><script type="math/tex" id="MathJax-Element-9"> f </script>  .<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para lograr esta compostibilidad, la especificaci贸n del conector se parametriza a trav茅s de especificaciones proporcionadas por el usuario para funciones remotas. De esta manera, los ingenieros pueden razonar sobre su arquitectura al proporcionar especificaciones y evidencia para sus componentes, y confiar en las especificaciones para el c贸digo generado. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hasta la fecha, hemos demostrado este proceso de principio a fin utilizando el conector especial CAmkES RPC ( </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). Dado que las plantillas para otros conectores (puertos de datos y eventos) son mucho m谩s simples que los RPC, no ser谩 dif铆cil expandir el generador de evidencia para admitir estos conectores, lo que le permitir谩 crear sistemas verificados m谩s diversos.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Despu茅s del c贸digo de comunicaci贸n, CAmkES crea la configuraci贸n de control de acceso inicial para aplicar los l铆mites de la arquitectura. Para probar que estas dos descripciones del sistema, capDL y CAmkES, coinciden entre s铆, considere la descripci贸n de CAmkES como una abstracci贸n para la descripci贸n de capDL. Usamos el </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">marco</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> previamente </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;">probado</font></a><font style="vertical-align: inherit;"> para derivar la autoridad de un objeto sobre otro objeto a partir de la descripci贸n de capDL. Entonces aumentaremos la evidencia al nivel de la pol铆tica. Adem谩s, hemos definido reglas para retirar la autoridad entre componentes en la descripci贸n de CAmkES. Esta prueba garantiza que los objetos capDL representados como un gr谩fico de privilegios con objetos agrupados por componentes tengan </font></font><a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">los mismos l铆mites entre grupos que en el gr谩fico de componentes CAmkES equivalente</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Intuitivamente, esta correspondencia de l铆mites significa que el an谩lisis de la arquitectura de la pol铆tica a partir de la descripci贸n de CAmkES salvar谩 la pol铆tica de la descripci贸n generada por capDL, que, a su vez, garantiza los requisitos de restricci贸n de autoridad, integridad y confidencialidad, como se mencion贸 anteriormente. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Finalmente, para probar la correcta inicializaci贸n, CAmkES usa un inicializador universal que comienza como la primera tarea del usuario despu茅s de la carga. En seL4, esta primera (y 煤nica) tarea del usuario tiene acceso a toda la memoria disponible, us谩ndola para crear objetos y "habilidades" de acuerdo con la descripci贸n detallada de capDL, que acepta como entrada. Est谩 comprobado que</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El estado despu茅s de la ejecuci贸n del inicializador satisface el estado descrito en la especificaci贸n especificada</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Esta prueba es v谩lida para el modelo de inicializador exacto, pero a煤n no en el nivel de implementaci贸n. </font><font style="vertical-align: inherit;">En comparaci贸n con la profundidad del resto de la cadena de evidencia, esta limitaci贸n puede parecer d茅bil, pero ya es una evidencia m谩s formal que la requerida en el nivel m谩s alto (EAL7) de los criterios generales de evaluaci贸n de seguridad.</font></font><br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Actualizaci贸n de seguridad s铆smica </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En la pr谩ctica, es dif铆cil garantizar el desarrollo de un sistema desde cero por razones de seguridad; por lo tanto, la capacidad de actualizar el software antiguo es crucial para desarrollar sistemas seguros. Nuestro marco basado en seL4 admite un proceso iterativo que llamamos "actualizaciones de seguridad s铆smica", ya que un arquitecto regular actualizar谩 los edificios existentes para una mayor estabilidad s铆smica. Ilustramos el proceso con el ejemplo de la adaptaci贸n gradual de la arquitectura de software existente de un helic贸ptero no tripulado, pasando del esquema de prueba tradicional a un sistema altamente confiable con teoremas respaldados por m茅todos formales. Aunque este ejemplo se basa en un proyecto ULB real, se simplifica aqu铆 y no incluye todos los detalles.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La arquitectura original del helic贸ptero coincide con la arquitectura descrita en la Fig. </font><font style="vertical-align: inherit;">3. Su funcionalidad es proporcionada por dos computadoras separadas: la computadora de navegaci贸n controla el vuelo real y la computadora de a bordo realiza tareas de alto nivel (como comunicarse con una estaci贸n terrestre y navegar la imagen desde la c谩mara). </font><font style="vertical-align: inherit;">La versi贸n inicial de la computadora de a bordo era una aplicaci贸n monol铆tica para Linux. </font><font style="vertical-align: inherit;">Durante el proceso de modernizaci贸n, los ingenieros de Boeing aplicaron los m茅todos, herramientas y componentes proporcionados por los socios de HACMS.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Paso 1. Virtualizaci贸n </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El primer paso fue tomar el sistema como est谩 y ejecutarlo en una m谩quina virtual encima de un hipervisor seguro (ver Figura 7). En la met谩fora de la modernizaci贸n s铆smica, esto corresponde a colocar el sistema sobre una base m谩s m贸vil. Una m谩quina virtual encima de seL4 en este sistema consta de un componente CAmkES, que incluye un monitor de m谩quina virtual (VMM) y un sistema operativo invitado, en este caso Linux. El n煤cleo proporciona abstracciones de hardware de virtualizaci贸n, y VMM gestiona estas abstracciones para la m谩quina virtual. El n煤cleo seL4 limita no solo el sistema operativo invitado, sino tambi茅n VMM, por lo que no necesita confiar en la implementaci贸n de VMM para proporcionar aislamiento forzado. Una falla de VMM dar谩 como resultado una falla del sistema operativo invitado, pero no una falla de todo el sistema. </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/e55/a43/855/e55a4385528bb6b66ed266100f601341.jpg"><br> <i><font color="gray"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fig. 7. Toda la funcionalidad en una m谩quina virtual.</font></font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dependiendo de la configuraci贸n del sistema, la m谩quina virtual puede tener acceso a dispositivos a trav茅s de controladores paravirtualizados, controladores de paso o ambos. </font><font style="vertical-align: inherit;">En el caso de los controladores de paso, los desarrolladores pueden usar el sistema MMU o IOMMU para evitar la violaci贸n de los l铆mites de aislamiento por parte de los dispositivos de hardware y los controladores en el sistema invitado. </font><font style="vertical-align: inherit;">Tenga en cuenta que simplemente iniciar el sistema en una m谩quina virtual no agrega beneficios adicionales de seguridad o confiabilidad. </font><font style="vertical-align: inherit;">El paso 1 solo es necesario para prepararse para el paso 2.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Paso 2. M煤ltiples m谩quinas virtuales </font></font></h3><br>  El segundo paso de la modernizaci贸n s铆smica fortalece los muros existentes.  En software, un desarrollador puede aumentar la seguridad y la confiabilidad dividiendo el sistema fuente en varios subsistemas, cada uno de los cuales consiste en una m谩quina virtual que solo ejecuta parte del c贸digo del sistema fuente.  Cada combinaci贸n VM / VMM se realiza en un componente CAmkES separado, que introduce aislamiento entre diferentes subsistemas, no les permite influirse entre s铆, y luego permite la coexistencia de diferentes niveles de seguridad. <br><br>  En general, las secciones siguen la arquitectura de software existente, aunque si la arquitectura no es suficiente para un aislamiento efectivo, puede ser necesario un redise帽o. <br><br>  Como regla general, las secciones deben interactuar entre s铆, por lo que en este punto tambi茅n agregaremos canales de comunicaci贸n.  Para garantizar la seguridad, es imperativo que estas interfaces sean estrechas, limitando la conexi贸n entre particiones a solo lo que sea absolutamente necesario.  Adem谩s, los protocolos de interfaz deben ser eficientes, con un n煤mero m铆nimo de mensajes o volumen de datos.  Es cr铆tico que seL4 le permita controlar y limitar el intercambio de memoria entre particiones para minimizar la cantidad de datos. <br><br>  Adem谩s de las m谩quinas virtuales que representan los subsistemas del sistema fuente, tambi茅n extraemos e implementamos componentes para cualquier recurso compartido (como una interfaz de red). <br><br>  Puede repetir el paso 2 hasta que alcancemos el detalle deseado de las secciones.  El detalle correcto es un compromiso entre la resistencia del aislamiento, por un lado, y el aumento de los gastos generales de comunicaci贸n y los costos de reconstrucci贸n, por otro lado. <br><br>  En nuestro ejemplo, tenemos tres secciones: una m谩quina virtual que implementa las funciones de comunicaci贸n de una estaci贸n terrestre que ejecuta Linux;  otra m谩quina virtual que implementa funciones de navegaci贸n basadas en c谩mara (tambi茅n ejecutando Linux);  y un componente nativo de red compartida, como se muestra en la fig.  8) <br><br><img src="https://habrastorage.org/getpro/habr/post_images/a25/bd9/760/a25bd97602571f9b3b485b156767a4ec.jpg"><br>  <i><font color="gray">Fig.8.</font></i>  <i><font color="gray">Funcionalidad dividida en varias m谩quinas virtuales.</font></i> <br><br><h3>  Paso 3. Componentes nativos </h3><br>  Cuando un sistema se descompone en secciones separadas de una m谩quina virtual, algunas o todas las secciones individuales se pueden volver a implementar como componentes nativos, en lugar de m谩quinas virtuales.  Esto reducir谩 significativamente la superficie de ataque para la misma funcionalidad.  Una ventaja adicional de convertir un componente en c贸digo de m谩quina es reducir la carga y aumentar la productividad, eliminando el SO hu茅sped y la sobrecarga de la ejecuci贸n del c贸digo y la comunicaci贸n VMM. <br><br>  Los componentes nativos tambi茅n aumentan el potencial para aplicar la verificaci贸n formal y otros m茅todos para aumentar la confiabilidad de un componente.  Las opciones son diferentes: desde la verificaci贸n funcional completa del c贸digo nativo hasta la generaci贸n conjunta de c贸digo y evidencia, verificaci贸n del modelo, uso de lenguajes de programaci贸n de tipo seguro, an谩lisis est谩tico o pruebas rigurosas tradicionales de una base de c贸digo m谩s peque帽a. <br><br>  Gracias al aislamiento proporcionado por seL4 y la arquitectura de componentes, es posible trabajar juntos en un sistema de componentes con diferentes niveles de confiabilidad.  En este caso, los componentes de baja confiabilidad no reducen la confiabilidad general del sistema, y los desarrolladores se benefician del hecho de que no necesita gastar esfuerzo para verificar este c贸digo. <br><br>  En nuestro ejemplo, analizaremos la m谩quina virtual para el canal de comunicaci贸n entre la computadora de a bordo y la estaci贸n terrestre en m贸dulos nativos.  En los componentes nativos, se implementan las funciones de comunicaci贸n, criptograf铆a y control (mission-manager).  Dejaremos la c谩mara y WiFi en la m谩quina virtual como un componente obsoleto poco confiable (ver Fig. 9).  Esta separaci贸n se ha convertido en un compromiso entre los esfuerzos para rehacer subsistemas y los beneficios de usar componentes nativos en t茅rminos de rendimiento y confiabilidad. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f10/86b/5fb/f1086b5fbf5aa5bd1c0f8b73e0c2207b.jpg"><br>  <i><font color="gray">Fig.</font></i>  <i><font color="gray">9. Funcionalidad implementada en componentes nativos</font></i> <br><br><h3>  Paso 4. Fiabilidad del sistema en su conjunto. </h3><br>  Una vez recibidos todos los m贸dulos necesarios, daremos el paso final: an谩lisis de todo el sistema en su conjunto basado en la fiabilidad de la arquitectura y los componentes individuales. <br><br>  Dentro del marco de HACMS, la comunicaci贸n, la criptograf铆a y un m贸dulo de control se implementan en el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">lenguaje orientado a objetos de seguridad probada tipo Ivory</a> , con asignaci贸n de una cantidad fija de memoria en el mont贸n.  Sin verificaci贸n adicional, Ivory no nos da garant铆as de correcci贸n funcional, pero da confianza en la tolerancia a fallas y la confiabilidad de emergencia.  Dado el aislamiento de los componentes, creemos que estas garant铆as permanecen en presencia de componentes poco confiables (como la m谩quina virtual de la c谩mara). <br><br>  El componente de red se implementa en el c贸digo C est谩ndar, que consiste en el c贸digo de usuario para la plataforma y el c贸digo de la biblioteca existente.  Su nivel de confiabilidad corresponde al nivel obtenido a trav茅s de la implementaci贸n cuidadosa de c贸digo conocido.  La confiabilidad se puede mejorar sin muchos gastos mediante el uso de m茅todos como la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">s铆ntesis de controladores</a> , as铆 como el uso de lenguajes de tipo seguro como Ivory.  En un an谩lisis general de la seguridad del sistema, cualquier compromiso de un componente de red solo afectar谩 a los paquetes de red.  Dado que el tr谩fico est谩 encriptado, dicho ataque no pondr谩 en peligro la condici贸n de las especificaciones que solo los comandos autorizados ingresan a la computadora a bordo. <br><br>  La m谩quina virtual de la videoc谩mara es la parte m谩s d茅bil del sistema, ya que se ejecuta en el sistema Linux y se supone que contiene vulnerabilidades.  Pero la VM est谩 aislada, por lo que si los atacantes la rompen, no podr谩n moverse a otros componentes.  Lo peor que puede hacer un atacante es enviar los datos incorrectos al componente de control.  Como en el quadrocopter, este componente verifica los datos recibidos de la c谩mara.  Y resisti贸 con 茅xito el ciberataque mencionado al principio del art铆culo.  Fue un ataque de "caja blanca", donde el equipo de Pentesters tuvo acceso a todo el c贸digo y la documentaci贸n, as铆 como a todos los canales de comunicaci贸n externos.  Se le otorg贸 intencionalmente acceso de root a la m谩quina virtual de la c谩mara, simulando un ataque exitoso a un software obsoleto.  La contenci贸n del ataque y la capacidad de defenderse contra este escenario muy poderoso se convirti贸 en una prueba digna de nuestros requisitos de seguridad y la identificaci贸n de cualquier supuesto perdido, problemas de interfaz u otros problemas de seguridad que el equipo de investigaci贸n podr铆a no reconocer. <br><br><h1>  Limitaciones y trabajo futuro </h1><br>  Este art铆culo proporciona una descripci贸n general del m茅todo para lograr niveles muy altos de seguridad para sistemas en los que la caracter铆stica de seguridad es aplicable a trav茅s de la arquitectura de componentes.  Hemos probado teoremas para el nivel de kernel y su configuraci贸n correcta, as铆 como teoremas que garantizan que la plataforma de componentes establece correctamente los l铆mites de seguridad de acuerdo con la descripci贸n de su arquitectura, y que genera el c贸digo correcto para llamadas a procedimientos remotos.  La conexi贸n con el an谩lisis de seguridad de alto nivel del sistema sigue siendo informal, y los teoremas del c贸digo de comunicaci贸n no cubren todas las primitivas de comunicaci贸n proporcionadas por la plataforma.  Para obtener autom谩ticamente un teorema que cubra todo el sistema de principio a fin, se requiere trabajo adicional.  Sin embargo, en esta etapa est谩 claro que esta es una tarea factible. <br><br>  El objetivo principal del trabajo presentado es reducir dr谩sticamente los esfuerzos de verificaci贸n para clases espec铆ficas de sistemas.  El enfoque puramente arquitect贸nico descrito aqu铆 puede extenderse a sistemas distintos de ULB, pero est谩 claramente limitado por el hecho de que solo puede expresar propiedades determinadas por la arquitectura de componentes del sistema.  Los retornos disminuir谩n si esta arquitectura cambia durante la ejecuci贸n del programa, y si las propiedades dependen cr铆ticamente del comportamiento de demasiados componentes confiables o componentes de un tama帽o demasiado grande. <br><br>  El primer paso para aliviar estas limitaciones es crear una biblioteca de componentes probados previamente de un alto nivel de confiabilidad para su uso como bloques de construcci贸n confiables en tales arquitecturas.  Esta biblioteca puede incluir patrones de seguridad (como desinfecci贸n de datos de entrada, filtros de salida, monitores de privacidad y tiempo de ejecuci贸n) potencialmente generados a partir de especificaciones de nivel superior, as铆 como componentes de infraestructura como m贸dulos criptogr谩ficos reutilizables, almacenamiento de claves, sistemas de archivos, Pilas y controladores de red altamente confiables.  Si la seguridad depende de m谩s de uno de esos componentes, entonces es necesario justificar la confiabilidad de su interacci贸n y uso compartido.  Los principales problemas t茅cnicos aqu铆 son las discusiones sobre concurrencia y protocolos, as铆 como el flujo de informaci贸n en presencia de componentes confiables.  A pesar de estas limitaciones, el trabajo demuestra el r谩pido desarrollo de sistemas reales altamente confiables basados en seL4.  Actualmente, la creaci贸n de tales sistemas es posible a un costo menor que las pruebas tradicionales. <br><br><h1>  Aplicaci贸n: costos laborales </h1><br>  El desarrollo del dise帽o y el c贸digo para seL4 tom贸 dos a帽os-hombre.  Si agregamos toda la evidencia espec铆fica de serotipo, se obtendr谩 un total de 18 a帽os-persona para 8700 l铆neas de c贸digo para C.Para la comparaci贸n, el desarrollo de un microkernel de tama帽o comparable L4Ka :: Pistacho de la familia seL4 tom贸 seis a帽os-hombre y no proporcion贸 un nivel significativo de confiabilidad.  Esto significa una diferencia en la velocidad de desarrollo de solo 3.3 veces entre el software verificado y el tradicional.  Seg煤n <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">el m茅todo de evaluaci贸n de Colbert y Bohm</a> , la certificaci贸n de acuerdo con los criterios tradicionales EAL7 para 8700 l铆neas de c贸digo C tomar谩 m谩s de 45.9 a帽os-persona.  Esto significa que la verificaci贸n formal de la implementaci贸n a nivel binario ya es 2.3 veces m谩s barata que el nivel m谩s alto de certificaci贸n seg煤n los criterios generales, al tiempo que proporciona una confiabilidad significativamente mayor. <br><br>  A modo de comparaci贸n, el enfoque HACMS descrito aqu铆 utiliza solo la evidencia existente para cada nuevo sistema, incluida la evidencia generada por las herramientas.  Por lo tanto, el esfuerzo de prueba general para un sistema que coincide con este enfoque se reduce a semanas-hombre, no a a帽os, y las pruebas se reducen solo para validar los supuestos. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/437406/">https://habr.com/ru/post/437406/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../437386/index.html">Entrevistas - Look de entrevistador</a></li>
<li><a href="../437390/index.html">"Secretos" DPAPI. Mira el burro</a></li>
<li><a href="../437396/index.html">驴Por qu茅 CarPrice es impulsado por inteligencia artificial?</a></li>
<li><a href="../437400/index.html">El gasto en la nube super贸 el gasto en infraestructura tradicional por primera vez, 驴qu茅 significa</a></li>
<li><a href="../437402/index.html">C贸mo le ense帽茅 al robot a correr en videos de YouTube</a></li>
<li><a href="../437408/index.html">802.1x, EX2200, NPS y todo-todo-todo ...</a></li>
<li><a href="../437410/index.html">Introducci贸n a Spring Boot con Spring Data Mongo</a></li>
<li><a href="../437414/index.html">Donde m谩s de 20 millones de tarjetas de transporte son vulnerables en Rusia: desensamblamos y desarrollamos MIFARE Classic</a></li>
<li><a href="../437416/index.html">Gesti贸n de capacidad: encontrar el equilibrio perfecto</a></li>
<li><a href="../437418/index.html">Acerca de las entidades, DTO, ORM y carga diferida</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>