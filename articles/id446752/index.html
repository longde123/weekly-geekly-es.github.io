<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ™†ğŸ¿ ğŸ‘©â€ğŸ‘©â€ğŸ‘§â€ğŸ‘¦ â—€ï¸ Layanan Tracing, OpenTracing dan Jaeger ğŸ‘¨ğŸ»â€ğŸ”§ ğŸ‘ˆ ğŸš®</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dalam proyek kami, kami menggunakan arsitektur microservice. Jika bottleneck kinerja muncul, banyak waktu dihabiskan untuk memantau dan menganalisis l...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Layanan Tracing, OpenTracing dan Jaeger</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/srg/blog/446752/"><img src="https://habrastorage.org/webt/wr/og/f4/wrogf42wbcnwmb394kx6mat_xpc.png" alt="gambar"><br><br>  Dalam proyek kami, kami menggunakan arsitektur microservice.  Jika bottleneck kinerja muncul, banyak waktu dihabiskan untuk memantau dan menganalisis log.  Ketika mencatat waktu operasi individu ke dalam file log, biasanya sulit untuk memahami apa yang menyebabkan panggilan operasi ini, untuk melacak urutan tindakan atau offset waktu dari satu operasi relatif ke yang lain dalam layanan yang berbeda. <br><br>  Untuk meminimalkan tenaga kerja manual, kami memutuskan untuk menggunakan salah satu alat pelacak.  Tentang bagaimana dan mengapa Anda dapat menggunakan pelacakan dan bagaimana kami melakukannya, dan artikel ini akan dibahas. <br><a name="habracut"></a><br><h3>  Masalah apa yang bisa diselesaikan dengan penelusuran </h3><br><ol><li>  Temukan hambatan kinerja dalam satu layanan dan di seluruh pohon eksekusi antara semua layanan yang berpartisipasi.  Sebagai contoh: <br><br><ul><li>  Banyak panggilan singkat berurutan antar layanan, misalnya, ke geocoding atau ke basis data. </li><li>  Lama menunggu input input, misalnya, mentransfer data melalui jaringan atau membaca dari disk. </li><li>  Penguraian data lama. </li><li>  Operasi panjang yang membutuhkan CPU. </li><li>  Potongan kode yang tidak diperlukan untuk mendapatkan hasil akhir dan dapat dihapus atau dijalankan ditunda. </li></ul></li><li>  Pahami dengan jelas dalam urutan apa yang disebut dan apa yang terjadi ketika operasi dilakukan. <br><br><img src="https://habrastorage.org/webt/_1/hn/wo/_1hnwonn-nynd8j5orur89ouw9s.jpeg"><br><br>  Dapat dilihat bahwa, misalnya, Permintaan datang ke layanan WS -&gt; layanan WS melengkapi data melalui layanan R -&gt; kemudian mengirim permintaan ke layanan V -&gt; layanan V memuat banyak data dari layanan R -&gt; pergi ke layanan P -&gt; layanan P mati lagi ke layanan R -&gt; layanan V mengabaikan hasilnya dan pergi ke layanan J -&gt; dan baru kemudian mengembalikan jawaban ke layanan WS, sambil terus menghitung sesuatu yang lain di latar belakang. <br><br>  Tanpa jejak atau dokumentasi terperinci untuk keseluruhan proses, sangat sulit untuk memahami apa yang terjadi saat pertama kali Anda melihat kode, dan kode tersebut tersebar di berbagai layanan dan disembunyikan di balik banyak tempat sampah dan antarmuka. <br></li><li>  Pengumpulan informasi tentang pohon eksekusi untuk analisis tertunda berikutnya.  Pada setiap tahap eksekusi, Anda dapat menambahkan informasi ke jejak yang tersedia pada tahap ini dan kemudian mencari tahu masukan apa yang menyebabkan skenario yang sama.  Sebagai contoh: <br><br><ul><li>  ID pengguna </li><li>  Hak </li><li>  Jenis metode yang dipilih </li><li>  Kesalahan log atau eksekusi </li></ul></li><li>  Ubah jejak menjadi subset metrik dan analisis lebih lanjut sebagai metrik. </li></ol><br><h3>  Apa yang bisa melacak logging.  Rentang </h3><br>  Dalam penelusuran, ada konsep span, ini merupakan analog dari satu log ke konsol.  Rentang memiliki: <br><br><ul><li>  Nama, biasanya nama metode yang dieksekusi </li><li>  Nama layanan tempat rentang dihasilkan </li><li>  ID unik sendiri </li><li>  Beberapa informasi meta dalam bentuk kunci / nilai, yang dijanjikan padanya.  Misalnya, parameter metode atau metode berakhir dengan kesalahan atau tidak </li><li>  Waktu mulai dan akhir rentang ini </li><li>  Id rentang induk </li></ul><br>  Setiap rentang dikirim ke pengumpul rentang untuk disimpan ke database untuk dilihat nanti segera setelah menyelesaikan eksekusi.  Di masa mendatang, Anda dapat membangun pohon dari semua bentang dengan menghubungkan dengan id induk.  Dalam analisis, Anda dapat menemukan, misalnya, semua rentang dalam beberapa layanan yang membutuhkan waktu lebih dari beberapa waktu.  Selanjutnya, pergi ke rentang tertentu, lihat seluruh pohon di atas dan di bawah rentang ini. <br><br><img src="https://habrastorage.org/webt/ev/64/g_/ev64g_pg2xffwnxvcasi9vn2tl0.png" alt="gambar"><br><br><h3>  Opentracing, Jagger dan bagaimana kami menerapkannya untuk proyek kami </h3><br>  Ada standar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Opentracing</a> umum yang menjelaskan bagaimana dan apa yang harus dirakit tanpa terikat dengan implementasi spesifik dalam bahasa apa pun.  Misalnya, di Jawa, semua pekerjaan dengan jejak dilakukan melalui API Opentracing umum, dan di bawahnya, misalnya, Jaeger atau implementasi default kosong yang tidak melakukan apa pun dapat disembunyikan. <br><br>  Kami menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Jaeger</a> sebagai implementasi dari Opentracing.  Ini terdiri dari beberapa komponen: <br><br><img src="https://habrastorage.org/webt/59/f0/93/59f093addc6fd068923241.png" alt="gambar"><br><br><ul><li>  Jaeger-agent adalah agen lokal yang biasanya berdiri di setiap mesin dan layanan masuk ke dalamnya pada port default lokal.  Jika tidak ada agen, maka jejak semua layanan pada mesin ini biasanya dimatikan </li><li>  Jaeger-collector - semua agen mengirim jejak yang dikumpulkan untuk itu, dan dia menempatkan mereka di database yang dipilih </li><li>  Basis data adalah cassandra pilihan mereka, tetapi kami menggunakan elasticsearch, ada implementasi untuk beberapa database lain dan dalam memori implementasi yang tidak menyimpan apa pun ke disk </li><li>  Jaeger-query adalah layanan yang masuk ke database dan memberikan jejak yang sudah dikumpulkan untuk analisis </li><li>  Jaeger-ui adalah antarmuka web untuk mencari dan melihat jejak, ia pergi ke jaeger-query </li></ul><br><img src="https://habrastorage.org/webt/_j/wu/ql/_jwuqlf6l_3wayc-urkvlgfsyuo.png" alt="gambar"><br><br>  Komponen terpisah adalah implementasi opa pelacak jaeger untuk bahasa tertentu, melalui mana bentang dikirim ke agen jaeger. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Menghubungkan Jagger di Jawa</a> turun untuk mensimulasikan antarmuka io.opentracing.Tracer, setelah itu semua jejak melalui itu akan terbang ke agen nyata. <br><br><img src="https://habrastorage.org/webt/0-/vu/uj/0-vuujqmzuc0v1xhwzw93t_bgpi.png" alt="gambar"><br><br>  Anda juga dapat menghubungkan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">opentracing-spring-cloud-starter</a> dan implementasi dari Jaeger <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">opentracing-spring-jaeger-cloud-starter</a> yang secara otomatis akan mengkonfigurasi pelacakan untuk segala sesuatu yang melewati komponen-komponen ini, misalnya, permintaan http ke pengontrol, permintaan basis data melalui jdbc dll. <br><br><h3>  Tracing Logging in Java </h3><br>  Di suatu tempat di tingkat paling atas, Rentang pertama harus dibuat, ini dapat dilakukan secara otomatis, misalnya, oleh pengontrol pegas ketika permintaan diterima, atau secara manual jika tidak ada.  Selanjutnya ditransmisikan melalui Lingkup di bawah ini.  Jika beberapa metode di bawah ini ingin menambahkan Span, dibutuhkan activeSpan saat ini dari Scope, membuat Span baru dan mengatakan bahwa induknya menerima activeSpan, dan membuat Span baru aktif.  Ketika layanan eksternal dipanggil, rentang aktif saat ini ditransfer ke mereka, dan layanan tersebut membuat rentang baru dengan mengacu pada rentang ini. <br><br>  Semua pekerjaan melewati instance Tracer, Anda bisa mendapatkannya melalui mekanisme DI, atau GlobalTracer.get () sebagai variabel global jika mekanisme DI tidak berfungsi.  Secara default, jika pelacak tidak diinisialisasi, NoopTracer akan kembali yang tidak melakukan apa-apa. <br><br>  Selanjutnya, lingkup saat ini diperoleh dari pelacak melalui ScopeManager, lingkup baru dibuat dari yang saat ini dengan pengikatan rentang baru, dan kemudian Lingkup yang dibuat ditutup, yang menutup rentang yang dibuat dan mengembalikan Lingkup sebelumnya ke keadaan aktif.  Lingkup terikat ke aliran, jadi ketika pemrograman multi-utas, Anda jangan lupa untuk mentransfer rentang aktif ke aliran lain, untuk aktivasi lebih lanjut Lingkup aliran lain dengan mengacu pada rentang ini. <br><br><pre><code class="java hljs">io.opentracing.Tracer tracer = ...; <span class="hljs-comment"><span class="hljs-comment">// GlobalTracer.get() void DoSmth () { try (Scope scope = tracer.buildSpan("DoSmth").startActive(true)) { ... } } void DoOther () { Span span = tracer.buildSpan("someWork").start(); try (Scope scope = tracer.scopeManager().activate(span, false)) { // Do things. } catch(Exception ex) { Tags.ERROR.set(span, true); span.log(Map.of(Fields.EVENT, "error", Fields.ERROR_OBJECT, ex, Fields.MESSAGE, ex.getMessage())); } finally { span.finish(); } } void DoAsync () { try (Scope scope = tracer.buildSpan("ServiceHandlerSpan").startActive(false)) { ... final Span span = scope.span(); doAsyncWork(() -&gt; { // STEP 2 ABOVE: reactivate the Span in the callback, passing true to // startActive() if/when the Span must be finished. try (Scope scope = tracer.scopeManager().activate(span, false)) { ... } }); } }</span></span></code> </pre> <br>  Untuk pemrograman multi-utas, ada juga TracedExecutorService dan pembungkus serupa yang secara otomatis meneruskan rentang saat ini ke aliran saat meluncurkan tugas yang tidak sinkron: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> ExecutorService executor = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> TracedExecutorService( Executors.newFixedThreadPool(<span class="hljs-number"><span class="hljs-number">10</span></span>), GlobalTracer.get() );</code> </pre> <br>  Untuk permintaan http eksternal, ada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://github.com/opentracing-contrib/java-apache-">TracingHttpClient</a> <br><br><pre> <code class="java hljs">HttpClient httpClient = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> TracingHttpClientBuilder().build();</code> </pre> <br><h3>  Masalah yang kita hadapi </h3><br><ul><li>  Kacang dan DI tidak selalu berfungsi jika pelacak tidak digunakan dalam layanan atau komponen, maka Pelacak <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" class="user_link">Autowired</a> mungkin tidak berfungsi dan Anda harus menggunakan GlobalTracer.get (). </li><li>  Anotasi tidak berfungsi jika itu bukan komponen atau layanan, atau jika pemanggilan metode berasal dari metode tetangga dari kelas yang sama.  Anda harus berhati-hati, memeriksa apa yang berhasil, dan menggunakan pembuatan jejak secara manual jika @Traced tidak berfungsi.  Anda juga dapat mengacaukan kompiler tambahan untuk penjelasan java, lalu mereka harus bekerja di mana saja. </li><li>  Di pegas dan pegas boot lama, konfigurasi otomatis dari cloud <a href="">pelumasan pembuka</a> tidak berfungsi karena bug di DI, maka jika Anda ingin jejak dalam komponen pegas bekerja secara otomatis, Anda dapat melakukannya dengan analogi dengan <a href="">github.com/opentracing-contrib/java-spring-jaeger/blob/ master / opentracing-spring-jaeger-starter / src / main / java / io / opentracing / contrib / java / spring / jaeger / starter / JaegerAutoConfiguration.java</a> </li><li>  Coba dengan sumber daya tidak berfungsi di asyik, Anda harus menggunakan coba akhirnya. </li><li>  Setiap layanan harus memiliki spring.application.name di mana jejak akan dicatat.  Apa nama yang terpisah untuk dijual dan diuji, agar tidak mengganggu mereka bersama. </li><li>  Jika Anda menggunakan GlobalTracer dan kucing jantan, maka semua layanan yang berjalan di kucing jantan ini memiliki satu GlobalTracer, sehingga mereka semua akan memiliki nama layanan yang sama. </li><li>  Saat menambahkan jejak ke suatu metode, Anda harus memastikan bahwa itu tidak dipanggil berulang kali.  Penting untuk menambahkan satu jejak umum untuk semua panggilan, yang menjamin total waktu kerja.  Kalau tidak, kelebihan beban akan dibuat. </li><li>  Sekali di jaeger-ui mereka membuat permintaan terlalu besar untuk sejumlah besar jejak dan karena mereka tidak menunggu jawaban, mereka melakukannya lagi.  Akibatnya, permintaan-jaeger mulai memakan banyak memori dan memperlambat elastisitasnya.  Membantu me-restart jaeger-query </li></ul><br><h3>  Sampling, penyimpanan dan melihat jejak </h3><br>  Ada tiga jenis <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">jejak sampel</a> : <br><br><ol><li>  Const yang mengirim dan menyimpan semua jejak. </li><li>  Probabilistik yang menyaring jejak dengan beberapa probabilitas yang diberikan. </li><li>  Ratelimiting yang membatasi jumlah jejak per detik.  Anda dapat mengkonfigurasi opsi ini pada klien, baik pada agen jaeger atau di kolektor.  Sekarang kita memiliki const 1 di tumpukan penilai, karena tidak ada banyak permintaan, tetapi mereka membutuhkan waktu lama.  Di masa depan, jika ini akan memberikan beban berlebihan pada sistem, Anda dapat membatasi itu. </li></ol><br>  Jika Anda menggunakan cassandra maka secara default menyimpan jejak hanya dalam dua hari.  Kami menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">elasticsearch</a> dan jejak disimpan sepanjang waktu dan tidak dihapus.  Indeks terpisah dibuat untuk setiap hari, misalnya, jaeger-service-2019-03-04.  Di masa mendatang, Anda harus mengonfigurasi pembersihan otomatis jejak lama. <br><br>  Untuk menonton kursus yang Anda butuhkan: <br><br><ul><li>  Pilih layanan tempat Anda ingin memfilter jejak, misalnya tomcat7-default untuk layanan yang menggunakan tomat dan tidak dapat memiliki nama. </li><li>  Selanjutnya, pilih operasi, interval waktu dan waktu operasi minimum, misalnya dari 10 detik, untuk hanya berjalan lama. <br><img src="https://habrastorage.org/webt/sw/gb/wh/swgbwhwedadxsbtf3nijshtwxvc.png"></li><li>  Pergi ke salah satu trek dan lihat apa yang melambat di sana. <br><img src="https://habrastorage.org/webt/ag/bv/de/agbvdecijeg9jsh08apkch8-fwq.png" alt="gambar"></li></ul><br>  Juga, jika id permintaan diketahui, maka Anda dapat menemukan jejak oleh id ini melalui pencarian tag, jika id ini dicatat dalam rentang trek. <br><br><h3>  Dokumentasi </h3><br><ul><li>  Opentracing dokumentasi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">opentracing.io/docs/overview/what-is-tracing</a> </li><li>  Dokumentasi Jaeger <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">www.jaegertracing.io/docs/1.10</a> </li><li>  Hubungkan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">jaeger</a> java <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">github.com/jaegertracing/jaeger-client-java</a> </li><li>  Hubungkan pegas opentracing <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">github.com/jaegertracing/jaeger-client-java</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">github.com/opentracing-contrib/java-spring-cloud</a> </li></ul><br><h3>  Artikel </h3><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">habr.com/en/company/carprice/blog/340946</a> Jaeger Opentracing dan Microservices dalam proyek nyata di PHP dan Golang </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">eng.uber.com/distributed-tracing</a> Evolving Distributed Tracing di Uber Engineering </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">opentracing.io/guides/java</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">medium.com/jaegertracing/running-jaeger-agent-on-bare-metal-d1fc47d31fab</a> Running Jaeger Agent di bare metal </li></ul><br><h3>  Video </h3><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">www.youtube.com/watch?v=qg0ENOdP1Lo</a> Bagaimana Kami Menggunakan Jaeger dan Prometheus untuk Menyampaikan Permintaan Pengguna Cepat-Kilat - Bryan Boreham </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">www.youtube.com/watch?v=WRntQsUajow</a> Pengenalan: Jaeger - Yuri Shkuro, Uber &amp; Pavol Loffay, Red Hat </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">www.youtube.com/watch?v=fsHb0qK37bc</a> Serghei Iakovlev, â€œKisah Kemenangan Kecil: OpenTracing, AWS, dan Jaegerâ€ </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id446752/">https://habr.com/ru/post/id446752/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id446740/index.html">Menggunakan Python untuk pelaporan dalam satu perusahaan</a></li>
<li><a href="../id446742/index.html">Topik dari Top 3D Expo 2019: "Anisoprinting - teknologi untuk produksi struktur komposit generasi baru", Fedor Antonov</a></li>
<li><a href="../id446744/index.html">VR dengan antarmuka saraf - perendaman lengkap dalam realitas virtual</a></li>
<li><a href="../id446746/index.html">Seorang karyawan UBS mendengar percakapan tentang tetangga kereta Eurostar dan mengetahui tentang kesepakatan $ 15 miliar. Sekarang dia dan bank akan didenda</a></li>
<li><a href="../id446750/index.html">Berita dari bawah: Raksasa IT telah mulai secara aktif membangun jaringan tulang punggung kapal selam mereka sendiri</a></li>
<li><a href="../id446754/index.html">Masa depan cloud</a></li>
<li><a href="../id446756/index.html">Senjata untuk VR - [RAILGUN TUTORIAL]</a></li>
<li><a href="../id446760/index.html">Topik di 3D Expo 2019: Pencetakan Logam 3D, Anton Sotov, Universitas Samara</a></li>
<li><a href="../id446762/index.html">6. Periksa Titik Memulai R80.20. Mulai di SmartConsole</a></li>
<li><a href="../id446764/index.html">Standar WASI: Luncurkan WebAssembly Beyond the Web</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>