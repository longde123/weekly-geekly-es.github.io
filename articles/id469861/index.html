<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ½ â›ï¸ ğŸ¡ Struktur data untuk pemrogram game: data massal ğŸ’¯ ğŸˆ ğŸšº</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Setiap programmer akan mendapat manfaat dari pemahaman tentang berbagai struktur data dan cara menganalisis kinerjanya. Namun dalam praktiknya, saya t...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Struktur data untuk pemrogram game: data massal</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/469861/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7e7/1d7/bb3/7e71d7bb314eaffe2d54f349cc854a5f.png" alt="gambar"></div><br>  Setiap programmer akan mendapat manfaat dari pemahaman tentang berbagai <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">struktur data</a> dan cara menganalisis kinerjanya.  Namun dalam praktiknya, saya tidak pernah berguna untuk <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pohon AVL</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pohon</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">merah-hitam</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pohon awalan</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">lewati daftar</a> , dll.  Saya menggunakan beberapa struktur data hanya untuk satu algoritma spesifik dan tidak lebih (misalnya, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tumpukan</a> untuk mengimplementasikan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">antrian prioritas</a> dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">algoritma pencarian jalur A *</a> ). <br><br>  Dalam pekerjaan sehari-hari, saya biasanya melakukan dengan struktur data yang sangat sedikit.  Paling sering, mereka berguna bagi saya: <br><br><ul><li>  Array data bersama (Data massal) - cara untuk secara efektif menyimpan sejumlah besar objek. </li><li>  Referensi yang lemah (atau <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pegangan</a> ) - cara untuk mengakses objek dalam data massal tanpa crash program jika objek dihapus. </li><li>  Indeks adalah cara untuk dengan cepat mengakses subset individu dalam data massal. </li><li>  Array array adalah cara menyimpan objek data massal dengan ukuran dinamis. </li></ul><br>  Saya akan mencurahkan beberapa artikel untuk bagaimana saya biasanya menerapkan semua struktur ini.  Mari kita mulai dengan data massal yang paling sederhana dan paling berguna. <a name="habracut"></a><br><br><h2>  Data massal </h2><br>  Tidak ada istilah umum untuk konsep ini (atau saya tidak tahu tentang itu).  Saya menyebut " <em>data massal</em> " kumpulan besar benda-benda serupa.  Misalnya, bisa jadi: <br><br><ul><li>  Semua peluru di dalam game. </li><li>  Semua pohon dalam game. </li><li>  Semua koin dalam game. </li></ul><br>  Atau, jika Anda menulis kode pada level abstraksi yang lebih tinggi, bisa jadi: <br><br><ul><li>  Semua entitas dalam game. </li><li>  Semua jerat dalam game. </li><li>  Semua suara dalam game. </li></ul><br>  Biasanya, setiap sistem (render, suara, animasi, fisika, dll.) Dalam permainan memiliki beberapa jenis objek yang perlu dilacak.  Misalnya, untuk sistem suara, dapat berupa: <br><br><ul><li>  Semua sumber suara yang <em>bisa</em> dimainkan. </li><li>  Semua suara <em>sedang</em> diputar. </li><li>  Semua efek (redaman, perubahan nada, dll.) Diterapkan pada suara. </li></ul><br>  Dalam hal data massal, saya akan menganggap sebagai berikut: <br><br><ul><li>  Urutan penyimpanan objek tidak penting.  Yaitu  kita melihat array sebagai <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">banyak</a> objek. </li><li> Setiap objek direpresentasikan sebagai <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">struktur data sederhana (POD-struct) dengan</a> ukuran tetap yang dapat dipindahkan atau diduplikasi menggunakan <code>memcpy()</code> . </li></ul><br>  Tentu saja, Anda dapat menemukan situasi di mana urutan itu <em>penting</em> .  Misalnya, jika objek menunjukkan elemen untuk rendering, maka sebelum rendering kita mungkin perlu mengurutkannya dari depan ke belakang untuk mengurangi jumlah gambar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ulang</a> . <br><br>  Namun, saya percaya bahwa dalam kebanyakan kasus, lebih baik menyortir data dengan <em>cara yang digunakan</em> , daripada menyimpan data dalam wadah yang disortir, seperti <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pohon merah-hitam</a> atau <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pohon-B</a> .  Misalnya, kita bisa mengurutkan objek yang dirender dari depan ke belakang sebelum meneruskannya ke renderer, atau mengurutkan file secara alfabet sebelum menampilkannya di layar sebagai daftar.  Menyortir data dalam setiap frame mungkin tampak mahal, tetapi dalam banyak kasus itu dilakukan dalam <em>O (n)</em> menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">radix sort</a> . <br><br>  Karena saya hanya menggunakan struktur data sederhana, saya lebih suka objek C ++ daripada objek C ++, karena lebih mudah untuk memahami apa yang terjadi dalam memori dan mengevaluasi kinerjanya.  Namun, ada beberapa situasi ketika Anda perlu menyimpan data dalam jumlah besar sesuatu yang tidak memiliki ukuran tetap.  misalnya, nama atau daftar objek anak.  Saya akan berbicara tentang kasus-kasus ini di pos terpisah, di mana kita melihat "array array".  Untuk sekarang, mari kita asumsikan bahwa semua objek sederhana, struktur data ukuran tetap. <br><br>  Misalnya, berikut ini struktur struktur data massal untuk sistem suara hipotetis kami: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">resource_t</span></span> *resource; <span class="hljs-comment"><span class="hljs-comment">// Resource manager data uint64_t bytes; // Size of data uint64_t format; // Data format identifier } sound_resource_t; typedef struct { sound_resource_t *resource; // Resource that's playing uint64_t samples_played; // Number of samples played float volume; // Volume of playing sound } playing_sound_t; typedef struct { playing_sound_t *sound; // Faded sound float fade_from; // Volume to fade from float fade_to; // Volume to fade to double fade_from_ts; // Time to start fade double fade_to_ts; // Time to end fade } playing_fade_t;</span></span></code> </pre> <br>  Saat mempertimbangkan cara untuk menyimpan data massal, kami perlu mempertimbangkan beberapa tujuan: <br><br><ul><li>  Menambah dan menghapus objek harus cepat. </li><li>  Data harus ditempatkan dalam bentuk yang <strong>nyaman untuk caching</strong> , sehingga Anda dapat dengan cepat beralih di atasnya untuk memperbarui sistem. </li><li>  Ini harus mendukung <strong>mekanisme tautan</strong> - harus ada cara untuk mengirimkan informasi <em>tentang</em> objek tertentu dalam data massal.  Pada contoh di atas, fade harus dapat menentukan suara mana yang dilemahkan.  Dalam contoh, saya menulis tautan sebagai pointer, tetapi implementasinya tergantung pada bagaimana data massal diatur. </li><li>  Data harus <strong>ramah</strong> alokasi - harus menggunakan beberapa alokasi memori besar, dan tidak mengalokasikan objek individual di heap. </li></ul><br>  Dua cara termudah untuk merepresentasikan data massal adalah array statis atau vektor C ++: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Static array #define MAX_PLAYING_SOUNDS 1024 uint32_t num_playing_sounds; playing_sound_t playing_sounds[MAX_PLAYING_SOUNDS]; // C++ vector std::vector&lt;playing_sound_t&gt; playing_sounds;</span></span></code> </pre> <br>  Bekerja dengan sebuah array sangat sederhana, dan dapat bekerja dengan baik untuk Anda jika Anda tahu persis berapa banyak objek yang dibutuhkan dalam aplikasi.  Jika Anda <em>tidak tahu ini</em> , maka buang memori Anda atau Anda akan kehabisan objek. <br><br>  Vektor <code>std::vector</code> juga merupakan solusi yang sangat layak dan sederhana, tetapi di sini Anda perlu mempertimbangkan beberapa aspek: <br><br><ul><li>  Implementasi standar <code>std::vector</code> dari Visual Studio lambat dalam mode Debug karena debugging iterators.  Itu harus ditetapkan ke <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">_ITERATOR_DEBUG_LEVEL = 0</a> . </li><li>  Untuk membuat dan menghancurkan objek, <code>std::vector</code> menggunakan konstruktor dan destruktor, dan dalam beberapa kasus mereka bisa jauh lebih lambat daripada <code>memcpy()</code> . </li><li>  <code>std::vector</code> jauh lebih sulit diurai daripada mengimplementasikan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">"stretchy buffer" yang sederhana</a> . </li></ul><br>  Selain itu, tanpa tindakan tambahan, baik array reguler maupun vektor tidak mendukung referensi ke objek individual.  Mari kita lihat topik ini, serta keputusan desain penting lainnya yang terlibat dalam menciptakan sistem data massal. <br><br><h2>  Strategi penghapusan </h2><br>  Keputusan penting pertama: apa yang harus dilakukan ketika menghapus objek <code>a[i]</code> .  Berikut adalah tiga opsi utama: <br><br><ul><li>  Anda dapat menggeser semua elemen berikutnya <code>a[i+1]</code> â†’ <code>a[i]</code> , <code>a[i+2]</code> â†’ <code>a[i+1]</code> , dll., Untuk menutup slot kosong. </li><li>  Anda dapat memindahkan elemen terakhir array ke slot kosong: <code>a[i] = a[n-1]</code> . </li><li>  Atau Anda dapat membiarkan slot kosong dengan membuat lubang di array.  Lubang ini nantinya bisa digunakan untuk menempatkan objek baru. </li></ul><br>  Opsi pertama mengerikan - <em>O (n)</em> dihabiskan untuk pergerakan semua elemen ini.  Satu-satunya manfaat dari metode pertama adalah jika array diurutkan, maka urutan di dalamnya dipertahankan.  Namun seperti yang disebutkan di atas, urutannya tidak mengganggu kita.  Perhatikan bahwa jika Anda menggunakan <code>a.erase()</code> untuk menghapus elemen <code>std::vector</code> , inilah yang akan terjadi! <br><br>  Opsi kedua sering disebut "swap-and-pop".  Mengapa  Karena jika Anda menggunakan vektor C ++, opsi ini biasanya diterapkan dengan menukar elemen yang ingin Anda hapus dengan yang terakhir, diikuti dengan menghapus atau membuka elemen terakhir: <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::swap(a[i], a[a.size() - <span class="hljs-number"><span class="hljs-number">1</span></span>]); a.pop_back();</code> </pre> <br>  Mengapa semua ini perlu?  Dalam C ++, jika kita <em>menetapkan</em> <code>a[i] = a[n-1]</code> , pertama-tama kita harus menghapus <code>a[i]</code> dengan memanggil destruktornya, dan kemudian memanggil copy constructor untuk membuat salinan <code>a[n-1]</code> pada posisi <code>i</code> dan akhirnya, kita menyebut destructor <code>a[n-1]</code> saat menggeser vektor.  Jika konstruktor salin mengalokasikan memori dan menyalin data, maka ini bisa sangat buruk.  Jika kita menggunakan <code>std::swap</code> alih-alih penugasan, maka kita hanya dapat melakukannya dengan pemindahan konstruktor dan tidak seharusnya mengalokasikan memori. <br><br>  Sekali lagi, itu sebabnya C ++ saya lebih suka struktur data sederhana dan operasi C. C ++ memiliki banyak jebakan kinerja yang dapat Anda jatuhkan jika Anda tidak tahu apa yang sedang terjadi di dalam.  Dalam C, operasi swap-erase akan sangat sederhana: <br><br><pre> <code class="cpp hljs">a.data[i] = a.data[--an];</code> </pre> <br>  Saat menggunakan swap-and-pop, objek tetap padat.  Untuk menempatkan objek baru, cukup lekatkan ke ujung array. <br><br>  Jika kita menggunakan opsi â€œwith holeâ€ I, maka ketika menempatkan objek baru pertama-tama kita perlu memeriksa apakah ada â€œholeâ€ gratis yang bisa digunakan.  Layak meningkatkan ukuran array hanya ketika tidak ada "lubang" gratis.  Kalau tidak, dalam proses menghapus dan membuat objek, itu akan tumbuh tanpa batas. <br><br>  Anda dapat menggunakan <code>std::vector&lt;uint32_t&gt;</code> untuk melacak posisi lubang, tetapi ada solusi yang lebih baik yang tidak memerlukan memori tambahan. <br><br>  Karena data objek di "lubang" tidak digunakan untuk apa pun, Anda dapat menggunakannya untuk menyimpan pointer ke lubang bebas berikutnya.  Dengan demikian, semua lubang dalam array membentuk <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">daftar yang terhubung sederhana</a> , dan jika perlu, kita dapat menambah dan menghapus elemen dari daftar tersebut. <br><br>  Jenis struktur data ini, di mana memori yang tidak digunakan digunakan untuk mengikat elemen-elemen bebas, biasanya disebut <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">daftar bebas</a> . <br><br>  Dalam daftar tertaut tradisional, <em>elemen header</em> daftar khusus menunjuk ke simpul pertama dalam daftar, dan elemen daftar terakhir menunjuk ke NULL, yang berarti akhir daftar.  Sebagai gantinya, saya lebih suka menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">daftar tertaut melingkar</a> , di mana tajuk hanya item daftar khusus, dan item daftar terakhir menunjuk ke elemen tajuk: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ffe/fe0/a6b/ffefe0a6b6bd621b9362e84486db65e1.jpg" width="100%"></div><br>  <i>Daftar tradisional dan ditautkan cincin.</i> <br><br>  Keuntungan dari pendekatan ini adalah bahwa kode menjadi lebih sederhana dengan mengurangi jumlah kasus khusus di awal dan akhir daftar. <br><br>  Perhatikan bahwa jika Anda menggunakan <code>std::vector</code> untuk menyimpan objek, maka pointer ke objek akan berubah dengan setiap redistribusi vektor.  Ini berarti bahwa kita tidak dapat menggunakan pointer reguler ke daftar tertaut, karena pointer terus berubah.  Untuk mengatasi masalah ini, Anda dapat menggunakan indeks sebagai "pointer" ke daftar tertaut, karena indeks terus-menerus menunjuk ke slot tertentu bahkan ketika mendistribusikan ulang array.  Kami akan berbicara lebih banyak tentang realokasi di bagian selanjutnya. <br><br>  Anda dapat mengalokasikan ruang untuk elemen khusus dari judul daftar dengan selalu menyimpannya dalam slot array 0. <br><br>  Kode akan terlihat seperti ini: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// The objects that we want to store: typedef struct {...} object_t; // An item in the free list points to the next one. typedef struct { uint32_t next_free; } freelist_item_t; // Each item holds either the object data or the free list pointer. typedef union { object_t; freelist_item_t; } item_t; typedef struct { std::vector&lt;item_t&gt; items; } bulk_data_t; void delete_item(bulk_data_t *bd, uint32_t i) { // Add to the freelist, which is stored in slot 0. bd-&gt;items[i].next = bd-&gt;items[0].next; bd-&gt;items[0].next = i; } uint32_t allocate_slot(bulk_data_t *bd) { const uint32_t slot = bd-&gt;items[0].next; bd-&gt;items[0].next = bd-&gt;items[slot].next; // If the freelist is empty, slot will be 0, because the header // item will point to itself. if (slot) return slot; bd-&gt;items.resize(bd-&gt;items.size() + 1); return bd-&gt;items.size() - 1; }</span></span></code> </pre> <br>  Apa strategi penghapusan terbaik?  Memindahkan elemen terakhir ke slot kosong, memastikan pengemasan array yang ketat atau menjaga semua elemen di tempatnya dengan penciptaan "lubang" di array di tempat elemen yang dihapus? <br><br>  Saat membuat keputusan, dua aspek harus diperhitungkan: <br><br><ul><li>  Iterasi lebih dari array padat lebih cepat karena kita memotong lebih sedikit memori dan kita tidak perlu menghabiskan terlalu banyak waktu melewatkan slot kosong. </li><li>  Jika kita menggunakan array yang sangat padat, elemen akan bergerak.  Ini berarti bahwa kita tidak dapat menggunakan indeks suatu elemen sebagai pengidentifikasi konstan untuk referensi eksternal ke elemen.  Kami harus menetapkan pengidentifikasi yang berbeda untuk setiap elemen dan menggunakan tabel pencarian untuk mencocokkan ID konstan ini dengan indeks objek saat ini.  Tabel pencarian ini bisa berupa tabel hash atau <code>std::vector</code> berlubang, seperti dijelaskan di atas (opsi kedua lebih cepat).  Tapi bagaimanapun, kita akan membutuhkan memori tambahan untuk tabel ini dan langkah tambahan tidak langsung untuk pengidentifikasi. </li></ul><br>  Memilih opsi terbaik tergantung pada proyek Anda. <br><br>  Anda dapat mengatakan bahwa menyimpan array yang padat lebih baik, karena iterasi atas semua elemen (untuk memperbarui sistem) terjadi lebih sering daripada mencocokkan tautan eksternal.  Di sisi lain, kita dapat mengatakan bahwa kinerja "array dengan lubang" lebih buruk hanya dalam kasus sejumlah besar lubang, dan dalam pengembangan game kita biasanya peduli dengan kinerja dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">kasus terburuk</a> (kami ingin memiliki frame rate 60 Hz, bahkan ketika operasi maksimum dilakukan dalam permainan) .  Dalam kasus terburuk, kami memiliki jumlah maksimum objek nyata, dan dalam hal ini <em>tidak akan ada lubang</em> dalam array.  Lubang terjadi hanya ketika jumlah objek berkurang, ketika kita menghapus beberapa objek ini. <br><br>  Ada juga strategi yang dapat digunakan untuk mempercepat pemrosesan array dengan banyak lubang.  Misalnya, kita dapat melacak panjang urutan lubang yang berkelanjutan untuk melewati seluruh urutan lubang pada suatu waktu, daripada elemen demi elemen.  Karena data ini hanya diperlukan untuk "lubang", dan bukan untuk elemen biasa, Anda dapat menyimpannya bersama dengan penunjuk daftar rilis dalam memori objek yang tidak teralokasi dan tidak membuang memori tambahan. <br><br>  Menurut pendapat saya, jika Anda tidak perlu mengoptimalkan kode untuk iterasi cepat, maka mungkin lebih baik menggunakan opsi "array with hole".  Ini lebih sederhana, tidak memerlukan struktur pencarian tambahan, dan Anda dapat menggunakan indeks objek sebagai ID-nya, yang sangat nyaman.  Selain itu, kurangnya objek bergerak menghilangkan kemungkinan bug. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/781/6e3/91f/7816e391f0b8c68dede02d95dffa304f.jpg" width="100%"></div><br>  <i>Strategi penghapusan data massal.</i> <br><br><h2>  Pointer yang lemah </h2><br>  Sebagai catatan, saya akan mengatakan bahwa mudah untuk mengimplementasikan dukungan untuk "pointer lemah" atau "deskriptor" untuk objek data massal. <br><br>  <em>Pointer yang lemah</em> adalah referensi ke objek yang dalam beberapa cara menentukan bahwa objek yang dirujuk telah dihapus.  Nyaman dalam petunjuk lemah adalah bahwa mereka memungkinkan Anda untuk menghapus objek tanpa khawatir tentang siapa yang dapat mereferensikannya.  Tanpa petunjuk lemah untuk menghapus suatu objek, kita perlu mencari setiap tautan individual dan menyatakannya tidak valid.  Ini bisa sangat sulit jika tautan disimpan dalam kode skrip, di komputer lain di jaringan, dll. <br><br>  Ingatlah bahwa kita sudah memiliki ID yang secara unik mengidentifikasi objek yang <em>ada</em> .  Dalam opsi "dengan lubang", ID ini hanyalah indeks elemen (karena elemen tidak pernah bergerak).  Dalam kasus array padat, indeks objek ini adalah catatan dalam <em>array pencarian</em> . <br><br>  ID itu sendiri tidak dapat digunakan sebagai penunjuk yang lemah, karena ID dapat digunakan kembali.  Jika sebuah elemen dihapus dan elemen baru dibuat di slot yang sama, maka kami tidak akan dapat mengetahuinya hanya dengan ID.  Untuk mendapatkan pointer yang lemah, Anda harus menggabungkan ID dengan bidang <code>generation</code> : <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> id; <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> generation; } <span class="hljs-keyword"><span class="hljs-keyword">weak_pointer_t</span></span>;</code> </pre> <br>  Bidang <code>generation</code> adalah bidang dalam struct objek yang melacak berapa kali slot dalam array data massal telah digunakan kembali.  (Dalam hal pengemasan ketat, ini melacak berapa kali slot telah digunakan kembali dalam array <em>pencarian</em> .) <br><br>  Saat Anda menghapus item, kami menambah nomor pembuatan di slotnya.  Untuk memeriksa apakah penunjuk lemah masih valid, kami memeriksa apakah <code>generation</code> dalam struct penunjuk lemah cocok dengan pembuatan slot yang ditunjukkan oleh <code>id</code> .  Jika cocok, maka objek sumber yang kami referensi masih ada.  Jika tidak, itu berarti itu dihapus, dan slotnya ada di daftar rilis, atau telah digunakan kembali. <br><br>  Perlu diingat bahwa karena bidang <code>generation</code> diperlukan untuk lubang dan benda yang ada, Anda harus menyimpannya di luar serikat: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> generation; <span class="hljs-keyword"><span class="hljs-keyword">union</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">object_t</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">freelist_item_t</span></span>; }; } <span class="hljs-keyword"><span class="hljs-keyword">item_t</span></span>;</code> </pre> <br><h2>  Strategi distribusi </h2><br>  Jika Anda menggunakan <code>std::vector</code> untuk menyimpan data elemen, maka ketika array sudah penuh dan perlu ditingkatkan, seluruh array elemen akan didistribusikan kembali.  Item yang ada disalin ke array baru. <br><br>  <code>std::vector</code> tumbuh secara <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><em>geometris</em></a> .  Ini berarti bahwa setiap kali vektor perlu meningkat, jumlah elemen terdistribusi dikalikan dengan beberapa faktor (biasanya dengan Ã— 2).  Pertumbuhan geometris (eksponensial) penting karena menjaga biaya untuk meningkatkan konstanta array. <br><br>  Saat mendistribusikan ulang array, kita perlu memindahkan semua elemen, yang membutuhkan <em>O (n)</em> .  Namun, ketika array bertambah, kami menambahkan ruang untuk elemen <em>n</em> lainnya, karena kami menggandakan ukurannya.  Ini berarti bahwa kita tidak perlu menambah array lagi sampai kita menambahkan <em>n</em> lebih banyak elemen ke dalamnya.  Artinya, kenaikan biaya sama dengan <em>O (n)</em> , tetapi kami hanya mengeksekusi mereka * O (n) * untuk waktu ke-n penulisan ke array, yaitu, rata-rata, biaya penulisan satu elemen adalah <em>O (n) / O (n) = O (1)</em> . <br><br>  Biaya pencatatan suatu item disebut <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><em>konstanta diamortisasi</em></a> , karena jika Anda rata-rata semua catatan yang sedang dieksekusi, biaya akan tetap.  Namun, kita tidak boleh lupa bahwa sebelum kita rata-rata, biayanya menjadi sangat spasmodik.  Setelah setiap <em>O (n)</em> mencatat, kita mendapatkan puncak ketinggian <em>O (n)</em> : <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1d0/331/5be/1d03315be5a0c1ad8096ac05f11c7893.jpg" width="100%"></div><br>  <i>Biaya penulisan ke <code>std::vector</code> .</i> <br><br>  Mari kita lihat apa yang terjadi jika kita tidak menggunakan pertumbuhan geometris.  Misalkan, alih-alih menggandakan memori selama pertumbuhan, kami hanya akan menambahkan 128 slot.  Memindahkan data lama masih membebani kita <em>O (n)</em> , tetapi sekarang kita perlu melakukannya setiap 128 item yang kita tambahkan, yaitu, biaya rata-rata sekarang adalah <em>O (n) / O (128) = O (n)</em> .  Biaya penulisan elemen ke array sebanding dengan ukuran array, jadi ketika array menjadi besar, ia mulai bekerja dengan kecepatan kura-kura.  Ups! <br><br>  Strategi distribusi <code>std::vector</code> adalah opsi standar yang baik, bekerja dengan baik dalam banyak kasus, tetapi memiliki beberapa masalah: <br><br><ul><li>  Constant Amortized tidak cocok untuk perangkat lunak waktu nyata.  Jika Anda memiliki array yang sangat besar, katakanlah, ratusan juta elemen, maka meningkatkan array ini dan memindahkan semua elemen dapat menyebabkan perlambatan yang terlihat dari frame rate.  Ini bermasalah karena alasan yang sama pengumpulan sampah bermasalah dalam game.  Tidak masalah seberapa rendah biaya rata-rata, jika dalam beberapa bingkai biaya dapat melonjak, menyebabkan gangguan permainan. </li><li>  Demikian pula, strategi alokasi ini dalam kasus array besar dapat menghabiskan banyak memori.  Katakanlah kita memiliki array 16 juta elemen dan kita perlu menulis satu lagi ke dalamnya.  Ini akan membuat array bertambah menjadi 32 juta.  Sekarang kita memiliki 16 juta elemen dalam array yang tidak kita gunakan.  Untuk platform dengan memori rendah, ini banyak. </li><li>  Akhirnya, realokasi memindahkan objek dalam memori, membatalkan semua pointer ke objek.  Ini bisa menjadi sumber bug yang sulit dilacak. </li></ul><br>  Kode di bawah ini adalah contoh bug yang dapat terjadi ketika memindahkan objek: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Create two items and return the sum of their costs. float f(bulk_data_t *bd) { const uint32_t slot_1 = allocate_slot(bd); item_t *item_1 = &amp;bd-&gt;items[slot_1]; const uint32_t slot_2 = allocate_slot(bd); item_t *item_2 = &amp;bd-&gt;items[slot_2]; return item_1-&gt;cost + item_2-&gt;cost; }</span></span></code> </pre> <br>  Masalahnya di sini adalah bahwa <code>item_2</code> <code>allocate_slot()</code> mungkin perlu mendistribusikan kembali array untuk membuat ruang untuk <code>item_2</code> .  Dalam hal ini, <code>item_1</code> akan dipindahkan ke memori dan penunjuk ke <code>item_1</code> akan berhenti berlaku.  Dalam kasus khusus ini, kami dapat menghilangkan kesalahan dengan memindahkan <code>item_1</code> penugasan_1, tetapi bug serupa dapat muncul lebih jelas.  Secara pribadi, mereka telah menggigit saya berkali-kali. <br><br>  Situasi seperti itu berbahaya oleh fakta bahwa bug hanya akan keluar ketika array didistribusikan kembali tepat pada saat <code>slot_2</code> .  Program dapat bekerja dengan benar untuk waktu yang lama sampai sesuatu mengubah pola distribusi, setelah itu bug akan bekerja. <br><br>  Semua masalah ini dapat diselesaikan dengan menggunakan strategi distribusi yang berbeda.  Berikut ini beberapa opsi: <br><br><ul><li>       : 16, 32, 64, â€¦,  <em></em>     . ,  16     ,  32   ,  .â€¦     ,         <code>std::vector</code> . </li><li>           ,     .       ,       .               . ,           <em>O(n)</em>  <code>push()</code> ,        . </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">       </a> ,      ,   ,     ,   . </li></ul><br> ,       .   ,   -       ,      ,       .      ,      ,          . <br><br>         ,      â€”       ?    ,       . ,     16  ,      16 ,       .   ,            ,           50 %.        . <br><br>   ,         <em> </em> ,           ,       .          *16 K * n*,  <em>n</em> â€”    bulk data  ,    ,        (      ). <br><br>        . -,         ,    <code>blocks\[i / elements_per_block\][i % elements_per_block]</code> . -,        ,      (heap allocator),   . <br><br>    ,         Â« Â»,  -       <code>std::vector</code> ,     ,    .         ,       ,          . <br><br> ,         ,     ID          .    ,        ,    .   ,   64  ,      32  (4   â€”  ). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/98e/f31/c3d/98ef31c3d3388db45f0897c9a390ce5d.jpg" width="100%"></div><br> <i> </i> <br><br><h2>      </h2><br>         <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="> </a> (Array of Structures, AoS)  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="> </a> (Structure of Arrays, SoA).     . ,      ,      , ,   : <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> t; <span class="hljs-keyword"><span class="hljs-keyword">vec3_t</span></span> pos; <span class="hljs-keyword"><span class="hljs-keyword">vec3_t</span></span> vel; <span class="hljs-keyword"><span class="hljs-keyword">vec3_t</span></span> col; } <span class="hljs-keyword"><span class="hljs-keyword">particle_t</span></span>;</code> </pre> <br>           struct  .      Â« Â».  : <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> num_particles; <span class="hljs-keyword"><span class="hljs-keyword">particle_t</span></span> *particles;</code> </pre> <br> ,          . <br><br>     (SoA)        struct: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> num_particles; <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> *t; <span class="hljs-keyword"><span class="hljs-keyword">vec3_t</span></span> *pos; <span class="hljs-keyword"><span class="hljs-keyword">vec3_t</span></span> *vel; <span class="hljs-keyword"><span class="hljs-keyword">vec3_t</span></span> *col; } particles;</code> </pre> <br>   ,     ,  <code>vec3_t</code>     struct: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> num_particles; <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> *t; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> *pos_x; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> *pos_y; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> *pos_z; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> *vel_x; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> *vel_y; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> *vel_z; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> *col_r; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> *col_g; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> *col_b; } particles;</code> </pre> <br>     ,     AoS,      ?       : <br><br><ul><li>       . ,  <code>tick()</code>    <code>t</code> .  <code>simulate_physics()</code>    <code>pos</code>  <code>vel</code> .   SoA       struct.   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="> </a> (     ),      . ,  <code>tick()</code>    1/10  ,  ,    10 . </li><li>  SoA        <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">SIMD</a>  .     ,    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">FPU</a> .   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">AVX</a>       float  ,     8 . </li></ul><br>   ,     <code>tick()</code>   80 ?  Tidak.      10 ,      ,      , SIMD      . <br><br>   SoA: <br><br><ul><li>   . </li><li>    ,           . </li><li>           <code>particle_t *</code> ,         .      . </li><li>           ,            </li><li>             ( ),  <em></em>   .     <em>  </em> ,     . </li></ul><br>    ,      ,    struct   ,        VM (       ). -    10  struct       .   8- -,   ,          . ! <br><br>       â€”      SIMD.     : <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> num_particles; <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> t[<span class="hljs-number"><span class="hljs-number">8</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> position_x[<span class="hljs-number"><span class="hljs-number">8</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> position_y[<span class="hljs-number"><span class="hljs-number">8</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> position_z[<span class="hljs-number"><span class="hljs-number">8</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> velocity_x[<span class="hljs-number"><span class="hljs-number">8</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> velocity_y[<span class="hljs-number"><span class="hljs-number">8</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> velocity_z[<span class="hljs-number"><span class="hljs-number">8</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> color_r[<span class="hljs-number"><span class="hljs-number">8</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> color_g[<span class="hljs-number"><span class="hljs-number">8</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> color_b[<span class="hljs-number"><span class="hljs-number">8</span></span>]; } <span class="hljs-keyword"><span class="hljs-keyword">eight_particles_t</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">eight_particles_t</span></span> *particles;</code> </pre> <br>     -    SIMD-     ,                  -,   .      ,            . <br><br>     <code>tick()</code>  32 ,  288 ,  32   ..  ,      10- ,       <code>t</code> . -, -    64 ,      ,     ,   5 .    ,    ,       -,   100%     . <br><br>    ,     . ,      <code>[16]</code> ,    float  - . ,       ,        ,   : <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/df8/7a2/558/df87a25586d4afb93a536585a84defef.png" width="100%"></div><br> <i>AoS  SoA.</i> <br><br>    ,  SoA â€”      Â« Â»,      SIMD     ,         (       Â«Â»). <br><br>   SIMD-  Â«Â»  ,    ,   ,    Â«Â» . ,   ,       <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">     </a>   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="> </a> ,  .        <code>next</code>     ,   SIMD-  .      struct. <br><br>       ,      ,        ,    struct  .       ,  ,     . <br><br>  AoS  SoA,  ,              .      Â«Â»     AoS    SoA   ,   SIMD-, ,    .              . <br><br>       â€”    AoS     SoA   - . ,        AoS       SoA,   ,       AoS ( ).        ,     ,       . <br><br> ,        Â« Â».    16-   ,    SoA,      .       scratch buffer  16  . <br><br><h2>  Kesimpulan </h2><br>        ,  Â« Â»    bulk data     : <br><br><blockquote>    Â«Â»   ,         VM (  ),       ( 16    ,     ). </blockquote><br>  ,        : <br><br><blockquote>     ,   8   SIMD         VM      . </blockquote><br>         . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id469861/">https://habr.com/ru/post/id469861/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id469839/index.html">Kerentanan Spam Pikabu</a></li>
<li><a href="../id469843/index.html">"Di mana bajingan muda yang akan menghapus kita dari muka bumi?"</a></li>
<li><a href="../id469849/index.html">Gim â€œSerang 51%â€: menulis gim mandiri sederhana di platform Obyte</a></li>
<li><a href="../id469855/index.html">Gradle + LLVM</a></li>
<li><a href="../id469859/index.html">Pointer dan Value semantik dalam menentukan penerima suatu metode</a></li>
<li><a href="../id469869/index.html">Mengapa Anda harus overclock RAM (mudah!)</a></li>
<li><a href="../id469871/index.html">Ketika keyboard adalah tabel</a></li>
<li><a href="../id469875/index.html">Cara melindungi kata sandi Anda pada tahun 2019</a></li>
<li><a href="../id469877/index.html">Oh metode Newton ini</a></li>
<li><a href="../id469879/index.html">VPN ganda dalam satu klik. Cara mudah membagi alamat IP dari titik masuk dan keluar</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>