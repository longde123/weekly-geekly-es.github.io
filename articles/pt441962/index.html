<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚öôÔ∏è ‚ôíÔ∏è üë®‚Äçüëß‚Äçüëß √çndices no PostgreSQL - 1 ü§úüèø üçô üê¥</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="1. Introdu√ß√£o 
 Esta s√©rie de artigos preocupa-se principalmente com √≠ndices no PostgreSQL. 

 Qualquer assunto pode ser considerado sob diferentes pe...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>√çndices no PostgreSQL - 1</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/postgrespro/blog/441962/"><h1>  1. Introdu√ß√£o </h1><br>  Esta s√©rie de artigos preocupa-se principalmente com √≠ndices no PostgreSQL. <br><br>  Qualquer assunto pode ser considerado sob diferentes perspectivas.  Discutiremos assuntos que devem interessar a um desenvolvedor de aplicativos que usa DBMS: quais √≠ndices est√£o dispon√≠veis, por que existem tantos tipos diferentes deles e como us√°-los para acelerar as consultas.  Provavelmente, o t√≥pico pode ser coberto em menos palavras, mas, em segredo, esperamos que um desenvolvedor curioso tamb√©m se interesse por detalhes internos, principalmente porque a compreens√£o de tais detalhes permite n√£o apenas adiar o julgamento de outros, mas tamb√©m tirar conclus√µes. de sua prefer√™ncia. <br><br>  O desenvolvimento de novos tipos de √≠ndices est√° fora do escopo.  Isso requer conhecimento da linguagem de programa√ß√£o C e pertence √† experi√™ncia de um programador de sistemas, em vez de um desenvolvedor de aplicativos.  Pelo mesmo motivo, quase n√£o discutiremos interfaces de programa√ß√£o, mas focaremos apenas no que √© importante para trabalhar com √≠ndices prontos para uso. <br><br>  Neste artigo, discutiremos a distribui√ß√£o de responsabilidades entre o <strong>mecanismo de indexa√ß√£o geral</strong> relacionado ao n√∫cleo do DBMS e aos m√©todos individuais de acesso ao √≠ndice, que o PostgreSQL nos permite adicionar como extens√µes.  No pr√≥ximo artigo, discutiremos a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">interface do m√©todo de acesso</a> e conceitos cr√≠ticos, como classes e fam√≠lias de operadores.  Ap√≥s essa introdu√ß√£o longa, por√©m necess√°ria, consideraremos detalhes da estrutura e aplica√ß√£o de diferentes tipos de √≠ndices: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Hash</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">B-tree</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">GiST</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">SP-GiST</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">GIN</a> e <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">RUM</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">BRIN</a> e <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Bloom</a> . <br><br><blockquote>  Antes de come√ßar, gostaria de agradecer a Elena Indrupskaya por traduzir os artigos para o ingl√™s. <br>  As coisas mudaram um pouco desde a publica√ß√£o original.  Meus coment√°rios sobre o estado atual das coisas s√£o indicados assim. </blockquote><a name="habracut"></a><br><h2>  √çndices </h2><br>  No PostgreSQL, √≠ndices s√£o objetos de banco de dados especiais, projetados principalmente para acelerar o acesso aos dados.  S√£o estruturas auxiliares: cada √≠ndice pode ser exclu√≠do e recriado novamente a partir das informa√ß√µes na tabela.  √Äs vezes, voc√™ pode ouvir que um DBMS pode funcionar sem √≠ndices, embora lentamente.  No entanto, esse n√£o √© o caso, pois os √≠ndices tamb√©m servem para impor algumas restri√ß√µes de integridade. <br><br>  Atualmente, seis tipos diferentes de √≠ndices est√£o embutidos no PostgreSQL 9.6, e mais um √≠ndice est√° dispon√≠vel como uma extens√£o - gra√ßas a mudan√ßas significativas na vers√£o 9.6.  Portanto, espere novos tipos de √≠ndices em um futuro pr√≥ximo. <br><br>  Apesar de todas as diferen√ßas entre os tipos de √≠ndices (tamb√©m chamados de m√©todos de acesso), cada um deles eventualmente associa uma chave (por exemplo, o valor da coluna indexada) √†s linhas da tabela que cont√™m essa chave.  Cada linha √© identificada por TID (tupla id), que consiste no n√∫mero de blocos no arquivo e na posi√ß√£o da linha dentro do bloco.  Dito isto, com a chave conhecida ou com algumas informa√ß√µes sobre ela, podemos ler rapidamente as linhas que podem conter as informa√ß√µes de nosso interesse sem verificar a tabela inteira. <br><br>  √â importante entender que um √≠ndice acelera o acesso a dados a um certo custo de manuten√ß√£o.  Para cada opera√ß√£o em dados indexados, seja inser√ß√£o, exclus√£o ou atualiza√ß√£o de linhas da tabela, os √≠ndices dessa tabela tamb√©m precisam ser atualizados e na mesma transa√ß√£o.  Observe que a atualiza√ß√£o dos campos da tabela para os quais os √≠ndices n√£o foram criados n√£o resulta em atualiza√ß√£o do √≠ndice;  essa t√©cnica √© chamada de HOT (tuplas somente de pilha). <br><br>  A extensibilidade implica algumas implica√ß√µes.  Para permitir a adi√ß√£o f√°cil de um novo m√©todo de acesso ao sistema, uma interface do mecanismo de indexa√ß√£o geral foi implementada.  Sua principal tarefa √© obter TIDs do m√©todo de acesso e trabalhar com eles: <br><br><ul><li>  Leia os dados das vers√µes correspondentes das linhas da tabela. </li><li>  Busque vers√µes de linha TID por TID ou em um lote usando um bitmap pr√©-constru√≠do. </li><li>  Verifique a visibilidade das vers√µes de linha da transa√ß√£o atual, levando em considera√ß√£o seu n√≠vel de isolamento. </li></ul><br>  O mecanismo de indexa√ß√£o est√° envolvido na execu√ß√£o de consultas.  √â chamado de acordo com um plano criado no est√°gio de otimiza√ß√£o.  O otimizador, classificando e avaliando diferentes maneiras de executar a consulta, deve entender os recursos de todos os m√©todos de acesso potencialmente aplic√°veis.  O m√©todo poder√° retornar dados na ordem necess√°ria ou devemos antecipar a classifica√ß√£o?  Podemos usar esse m√©todo para procurar NULL?  Esses s√£o os problemas que o otimizador est√° resolvendo regularmente. <br><br>  N√£o apenas o otimizador precisa de informa√ß√µes sobre o m√©todo de acesso.  Ao criar um √≠ndice, o sistema deve decidir se o √≠ndice pode ser constru√≠do em v√°rias colunas e se esse √≠ndice garante exclusividade. <br><br>  Portanto, cada m√©todo de acesso deve fornecer todas as informa√ß√µes necess√°rias sobre si mesmo.  As vers√µes inferiores a 9.6 usavam a tabela "pg_am" para isso, enquanto a partir da vers√£o 9.6 os dados eram movidos para n√≠veis mais profundos, dentro de fun√ß√µes especiais.  Vamos nos familiarizar com essa interface um pouco mais. <br><br>  Todo o resto √© tarefa do m√©todo de acesso: <br><br><ul><li>  Implemente um algoritmo para criar o √≠ndice e mapear os dados em p√°ginas (para que o gerenciador de cache do buffer processe uniformemente cada √≠ndice). </li><li>  Pesquise informa√ß√µes no √≠ndice por um predicado no formato " <em>express√£o do operador de campo indexado</em> ". </li><li>  Avalie o custo de uso do √≠ndice. </li><li>  Manipule os bloqueios necess√°rios para o processamento paralelo correto. </li><li> Gere registros de log write-ahead (WAL). </li></ul><br>  Primeiro, consideraremos os recursos do mecanismo de indexa√ß√£o geral e depois consideraremos diferentes m√©todos de acesso. <br><br><h2>  Mecanismo de indexa√ß√£o </h2><br>  O mecanismo de indexa√ß√£o permite que o PostgreSQL trabalhe com v√°rios m√©todos de acesso de maneira uniforme, mas levando em considera√ß√£o seus recursos. <br><br><h3>  Principais t√©cnicas de digitaliza√ß√£o </h3><br><h4>  Varredura de √≠ndice </h4><br>  Podemos trabalhar de maneira diferente com os TIDs fornecidos por um √≠ndice.  Vamos considerar um exemplo: <br><br><pre><code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> t(a <span class="hljs-type"><span class="hljs-type">integer</span></span>, b <span class="hljs-type"><span class="hljs-type">text</span></span>, c <span class="hljs-type"><span class="hljs-type">boolean</span></span>); postgres=# <span class="hljs-keyword"><span class="hljs-keyword">insert</span></span> <span class="hljs-keyword"><span class="hljs-keyword">into</span></span> t(a,b,c) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> s.id, chr((<span class="hljs-number"><span class="hljs-number">32</span></span>+random()*<span class="hljs-number"><span class="hljs-number">94</span></span>)::<span class="hljs-type"><span class="hljs-type">integer</span></span>), random() &lt; <span class="hljs-number"><span class="hljs-number">0.01</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> generate_series(<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">100000</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> s(id) <span class="hljs-keyword"><span class="hljs-keyword">order</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> random(); postgres=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> t(a); postgres=# <span class="hljs-keyword"><span class="hljs-keyword">analyze</span></span> t;</code> </pre> <br>  Criamos uma tabela de tr√™s campos.  O primeiro campo cont√©m n√∫meros de 1 a 100.000, e um √≠ndice (independentemente do tipo) √© criado nesse campo.  O segundo campo cont√©m v√°rios caracteres ASCII, exceto os n√£o imprim√≠veis.  Finalmente, o terceiro campo cont√©m um valor l√≥gico verdadeiro para cerca de 1% das linhas e falso para o restante.  Linhas s√£o inseridas na tabela em uma ordem aleat√≥ria. <br><br>  Vamos tentar selecionar um valor pela condi√ß√£o "a = 1".  Observe que a condi√ß√£o se parece com " <em>express√£o do operador de campo indexado</em> ", em que o <em>operador</em> √© "igual" e a <em>express√£o</em> (chave de pesquisa) √© "1".  Na maioria dos casos, a condi√ß√£o deve ser assim para o √≠ndice a ser usado. <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">explain</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">costs</span></span> <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> t <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> a = <span class="hljs-number"><span class="hljs-number">1</span></span>;</code> </pre><pre> <code class="plaintext hljs"> QUERY PLAN ------------------------------- Index Scan using t_a_idx on t Index Cond: (a = 1) (2 rows)</code> </pre><br>  Nesse caso, o otimizador decidiu usar a <em>verifica√ß√£o de √≠ndice</em> .  Com a varredura de √≠ndice, o m√©todo de acesso retorna os valores TID um a um at√© a √∫ltima linha correspondente ser atingida.  O mecanismo de indexa√ß√£o acessa as linhas da tabela indicadas por TIDs, por sua vez, obt√©m a vers√£o da linha, verifica sua visibilidade em rela√ß√£o √†s regras de simultaneidade multivers√£o e retorna os dados obtidos. <br><br><h4>  Verifica√ß√£o de bitmap </h4><br>  A verifica√ß√£o de √≠ndice funciona bem quando lidamos com apenas alguns valores.  No entanto, √† medida que o n√∫mero de linhas recuperadas aumenta, √© mais prov√°vel que voc√™ volte √† mesma p√°gina da tabela v√°rias vezes.  Portanto, o otimizador alterna para a <em>verifica√ß√£o de bitmap</em> . <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">explain</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">costs</span></span> <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> t <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> a &lt;= <span class="hljs-number"><span class="hljs-number">100</span></span>;</code> </pre><pre> <code class="plaintext hljs"> QUERY PLAN ------------------------------------ Bitmap Heap Scan on t Recheck Cond: (a &lt;= 100) -&gt; Bitmap Index Scan on t_a_idx Index Cond: (a &lt;= 100) (4 rows)</code> </pre><br>  O m√©todo de acesso primeiro retorna todos os TIDs que correspondem √† condi√ß√£o (n√≥ Bitmap Index Scan) e o bitmap das vers√µes de linha √© criado a partir desses TIDs.  As vers√µes de linha s√£o lidas na tabela (Bitmap Heap Scan), cada p√°gina sendo lida apenas uma vez. <br><br>  Observe que, na segunda etapa, a condi√ß√£o pode ser verificada novamente (Verifique novamente Cond).  O n√∫mero de linhas recuperadas pode ser muito grande para que o bitmap das vers√µes de linha se ajuste totalmente √† RAM (limitado pelo par√¢metro "work_mem").  Nesse caso, o bitmap √© criado apenas para p√°ginas que cont√™m pelo menos uma vers√£o de linha correspondente.  Esse bitmap "com perdas" requer menos espa√ßo, mas ao ler uma p√°gina, precisamos verificar novamente as condi√ß√µes de cada linha contida nela.  Observe que, mesmo para um pequeno n√∫mero de linhas recuperadas e, portanto, o bitmap "exato" (como em nosso exemplo), a etapa "Verificar novamente Cond" √© representada no plano de qualquer maneira, embora n√£o seja realmente executada. <br><br>  Se condi√ß√µes forem impostas em v√°rios campos da tabela e esses campos forem indexados, a verifica√ß√£o de bitmap permitir√° o uso de v√°rios √≠ndices simultaneamente (se o otimizador considerar isso eficiente).  Para cada √≠ndice, s√£o criados bitmaps de vers√µes de linha, para os quais √© executada multiplica√ß√£o booleana bit a bit (se as express√µes forem unidas por AND) ou adi√ß√£o booleana (se as express√µes s√£o unidas por OR).  Por exemplo: <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> t(b); postgres=# <span class="hljs-keyword"><span class="hljs-keyword">analyze</span></span> t; postgres=# <span class="hljs-keyword"><span class="hljs-keyword">explain</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">costs</span></span> <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> t <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> a &lt;= <span class="hljs-number"><span class="hljs-number">100</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> b = <span class="hljs-string"><span class="hljs-string">'a'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> QUERY PLAN -------------------------------------------------- Bitmap Heap Scan on t Recheck Cond: ((a &lt;= 100) AND (b = 'a'::text)) -&gt; BitmapAnd -&gt; Bitmap Index Scan on t_a_idx Index Cond: (a &lt;= 100) -&gt; Bitmap Index Scan on t_b_idx Index Cond: (b = 'a'::text) (7 rows)</code> </pre><br>  Aqui, o n√≥ BitmapAnd une dois bitmaps pela opera√ß√£o "e" bit a bit. <br><br>  A verifica√ß√£o de bitmap nos permite evitar acessos repetidos √† mesma p√°gina de dados.  Mas e se os dados nas p√°ginas da tabela forem ordenados fisicamente exatamente da mesma maneira que os registros de √≠ndice?  N√£o h√° d√∫vida de que n√£o podemos confiar totalmente na ordem f√≠sica dos dados nas p√°ginas.  Se dados ordenados forem necess√°rios, devemos especificar explicitamente a cl√°usula ORDER BY na consulta.  Mas √© prov√°vel que existam situa√ß√µes em que "quase todos" os dados sejam ordenados: por exemplo, se as linhas forem adicionadas na ordem necess√°ria e n√£o forem alteradas depois disso ou ap√≥s a execu√ß√£o do comando CLUSTER.  Em casos como esse, a cria√ß√£o de um bitmap √© uma etapa excessiva e uma verifica√ß√£o de √≠ndice regular ser√° igualmente boa (a menos que levemos em considera√ß√£o a possibilidade de ingressar em v√°rios √≠ndices).  Portanto, ao escolher um m√©todo de acesso, o planejador analisa uma estat√≠stica especial que mostra a correla√ß√£o entre a ordena√ß√£o de linha f√≠sica e a ordena√ß√£o l√≥gica dos valores da coluna: <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> attname, correlation <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pg_stats <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> tablename = <span class="hljs-string"><span class="hljs-string">'t'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> attname | correlation ---------+------------- b | 0.533512 c | 0.942365 a | -0.00768816 (3 rows)</code> </pre><br>  Valores absolutos pr√≥ximos a um indicam uma alta correla√ß√£o (como na coluna "c"), enquanto valores pr√≥ximos a zero, pelo contr√°rio, indicam uma distribui√ß√£o ca√≥tica (coluna "a"). <br><br><h4>  Varredura seq√ºencial </h4><br>  Para concluir a imagem, devemos observar que, com uma condi√ß√£o n√£o seletiva, o otimizador ter√° raz√£o em preferir a varredura seq√ºencial de toda a tabela ao uso do √≠ndice: <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">explain</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">costs</span></span> <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> t <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> a &lt;= <span class="hljs-number"><span class="hljs-number">40000</span></span>;</code> </pre><pre> <code class="plaintext hljs"> QUERY PLAN ------------------------ Seq Scan on t Filter: (a &lt;= 40000) (2 rows)</code> </pre><br>  O fato √© que os √≠ndices funcionam melhor, quanto maior a seletividade da condi√ß√£o, ou seja, menos linhas correspondem a ela.  O crescimento do n√∫mero de linhas recuperadas aumenta os custos indiretos da leitura de p√°ginas de √≠ndice. <br><br>  As verifica√ß√µes sequenciais s√£o mais r√°pidas que as verifica√ß√µes aleat√≥rias, que agravam a situa√ß√£o.  Isso vale especialmente para discos r√≠gidos, onde a opera√ß√£o mec√¢nica de levar uma cabe√ßa magn√©tica a uma pista leva muito mais tempo que a pr√≥pria leitura de dados.  Esse efeito √© menos percept√≠vel para o SSD.  Dois par√¢metros est√£o dispon√≠veis para levar em conta as diferen√ßas nos custos de acesso, "seq_page_cost" e "random_page_cost", que podemos definir n√£o apenas globalmente, mas no n√≠vel dos espa√ßos de tabela, ajustando-se √†s caracter√≠sticas dos diferentes subsistemas de disco. <br><br><h3>  Cobrindo √≠ndices </h3><br>  Como regra, a principal tarefa de um m√©todo de acesso √© retornar os identificadores das linhas correspondentes da tabela para que o mecanismo de indexa√ß√£o leia os dados necess√°rios dessas linhas.  Mas e se o √≠ndice j√° contiver todos os dados necess√°rios para a consulta?  Esse √≠ndice √© chamado de <em>cobertura</em> e, nesse caso, o otimizador pode aplicar a <em>verifica√ß√£o apenas</em> do <em>√≠ndice</em> : <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">vacuum</span></span> t; postgres=# <span class="hljs-keyword"><span class="hljs-keyword">explain</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">costs</span></span> <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> a <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> t <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> a &lt; <span class="hljs-number"><span class="hljs-number">100</span></span>;</code> </pre><pre> <code class="plaintext hljs"> QUERY PLAN ------------------------------------ Index Only Scan using t_a_idx on t Index Cond: (a &lt; 100) (2 rows)</code> </pre><br>  Esse nome pode dar uma id√©ia de que o mecanismo de indexa√ß√£o n√£o acessa a tabela e obt√©m todas as informa√ß√µes necess√°rias apenas do m√©todo de acesso.  Mas esse n√£o √© exatamente o caso, pois os √≠ndices no PostgreSQL n√£o armazenam informa√ß√µes que nos permitem avaliar a visibilidade da linha.  Portanto, um m√©todo de acesso retorna vers√µes de linhas que correspondem √† condi√ß√£o de pesquisa, independentemente de sua visibilidade na transa√ß√£o atual. <br><br>  No entanto, se o mecanismo de indexa√ß√£o precisasse procurar sempre visibilidade na tabela, esse m√©todo de verifica√ß√£o n√£o seria diferente de uma verifica√ß√£o de √≠ndice comum. <br><br>  Para resolver o problema, nas tabelas, o PostgreSQL mant√©m um chamado <em>mapa de visibilidade,</em> no qual a aspira√ß√£o marca as p√°ginas em que os dados n√£o foram alterados por tempo suficiente para que esses dados sejam vis√≠veis em todas as transa√ß√µes, independentemente da hora de in√≠cio e do n√≠vel de isolamento.  Se o identificador de uma linha retornada pelo √≠ndice estiver relacionado a essa p√°gina, a verifica√ß√£o de visibilidade poder√° ser evitada. <br><br>  Portanto, a aspira√ß√£o regular aumenta a efici√™ncia dos √≠ndices de cobertura.  Al√©m disso, o otimizador leva em considera√ß√£o o n√∫mero de tuplas mortas e pode decidir n√£o usar a varredura apenas de √≠ndice, se prever altos custos indiretos para a verifica√ß√£o de visibilidade. <br><br>  Podemos aprender o n√∫mero de acessos for√ßados a uma tabela usando o comando EXPLAIN ANALYZE: <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">explain</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">analyze</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">costs</span></span> <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> a <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> t <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> a &lt; <span class="hljs-number"><span class="hljs-number">100</span></span>;</code> </pre><pre> <code class="plaintext hljs"> QUERY PLAN ------------------------------------------------------------------------------- Index Only Scan using t_a_idx on t (actual time=0.025..0.036 rows=99 loops=1) Index Cond: (a &lt; 100) Heap Fetches: 0 Planning time: 0.092 ms Execution time: 0.059 ms (5 rows)</code> </pre><br>  Nesse caso, n√£o era necess√°rio acessar a tabela (Heap Fetches: 0), pois a aspira√ß√£o acabou de ser feita.  Em geral, quanto mais pr√≥ximo esse n√∫mero de zero for, melhor. <br><br>  Nem todos os √≠ndices armazenam valores indexados junto com identificadores de linha.  Se o m√©todo de acesso n√£o puder retornar os dados, n√£o poder√° ser usado para verifica√ß√µes apenas de √≠ndice. <br><br><blockquote>  O PostgreSQL 11 introduziu um novo recurso: INCLUDE-indexes.  E se houver um √≠ndice exclusivo que carece de algumas colunas para ser usado como √≠ndice de cobertura para alguma consulta?  Voc√™ n√£o pode simplesmente adicionar as colunas ao √≠ndice, pois isso quebrar√° sua exclusividade.  O recurso permite incluir colunas <em>n√£o chave</em> que n√£o afetam a exclusividade e n√£o podem ser usadas nos predicados de pesquisa, mas ainda podem servir para verifica√ß√µes apenas de √≠ndice.  O patch foi desenvolvido pela minha colega Anastasia Lubennikova. <br></blockquote><br><h3>  Nulo </h3><br>  Os NULLs desempenham um papel importante nos bancos de dados relacionais como uma maneira conveniente de representar um valor inexistente ou desconhecido. <br><br>  Mas um valor especial √© especial para lidar.  Uma √°lgebra booleana regular se torna tern√°ria;  n√£o est√° claro se NULL deve ser menor ou maior que os valores regulares (isso requer constru√ß√µes especiais para classifica√ß√£o, NULLS FIRST e NULLS LAST);  n√£o √© evidente se as fun√ß√µes agregadas devem considerar NULLs ou n√£o;  uma estat√≠stica especial √© necess√°ria para o planejador ... <br><br>  Da perspectiva do suporte ao √≠ndice, tamb√©m n√£o est√° claro se precisamos indexar esses valores ou n√£o.  Se NULLs n√£o estiverem indexados, o √≠ndice poder√° ser mais compacto.  Mas se NULLs forem indexados, poderemos usar o √≠ndice para condi√ß√µes como " <em>campo indexado</em> IS [N√ÉO] NULL" e tamb√©m como um √≠ndice de cobertura quando nenhuma condi√ß√£o for especificada para a tabela (pois, neste caso, o O √≠ndice deve retornar os dados de todas as linhas da tabela, incluindo aquelas com NULLs). <br><br>  Para cada m√©todo de acesso, os desenvolvedores tomam uma decis√£o individual quanto √† indexa√ß√£o de NULLs ou n√£o.  Mas, como regra, eles s√£o indexados. <br><br><h3>  √çndices em v√°rios campos </h3><br>  Para oferecer suporte a condi√ß√µes para v√°rios campos, <em>√≠ndices de</em> v√°rias <em>colunas</em> podem ser usados.  Por exemplo, podemos criar um √≠ndice em dois campos da nossa tabela: <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> t(a,b); postgres=# <span class="hljs-keyword"><span class="hljs-keyword">analyze</span></span> t;</code> </pre><br>  O otimizador provavelmente preferir√° esse √≠ndice a unir bitmaps, pois aqui obtemos prontamente os TIDs necess√°rios sem nenhuma opera√ß√£o auxiliar: <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">explain</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">costs</span></span> <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> t <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> a &lt;= <span class="hljs-number"><span class="hljs-number">100</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> b = <span class="hljs-string"><span class="hljs-string">'a'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> QUERY PLAN ------------------------------------------------ Index Scan using t_a_b_idx on t Index Cond: ((a &lt;= 100) AND (b = 'a'::text)) (2 rows)</code> </pre><br>  Um √≠ndice de v√°rias colunas tamb√©m pode ser usado para acelerar a recupera√ß√£o de dados por uma condi√ß√£o para alguns dos campos, come√ßando pelo primeiro: <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">explain</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">costs</span></span> <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> t <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> a &lt;= <span class="hljs-number"><span class="hljs-number">100</span></span>;</code> </pre><pre> <code class="plaintext hljs"> QUERY PLAN -------------------------------------- Bitmap Heap Scan on t Recheck Cond: (a &lt;= 100) -&gt; Bitmap Index Scan on t_a_b_idx Index Cond: (a &lt;= 100) (4 rows)</code> </pre><br>  Em geral, se a condi√ß√£o n√£o for imposta no primeiro campo, o √≠ndice n√£o ser√° usado.  Mas, √†s vezes, o otimizador pode considerar o uso do √≠ndice mais eficiente do que a varredura seq√ºencial.  Expandiremos esse t√≥pico ao considerar os √≠ndices "btree". <br><br>  Nem todos os m√©todos de acesso oferecem suporte √† cria√ß√£o de √≠ndices em v√°rias colunas. <br><br><h3>  √çndices em express√µes </h3><br>  J√° mencionamos que a condi√ß√£o de pesquisa deve se parecer com " <em>express√£o do operador de campo indexado</em> ".  No exemplo abaixo, o √≠ndice n√£o ser√° usado, pois uma express√£o contendo o nome do campo √© usada em vez do pr√≥prio nome do campo: <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">explain</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">costs</span></span> <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> t <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> lower(b) = <span class="hljs-string"><span class="hljs-string">'a'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> QUERY PLAN ------------------------------------------ Seq Scan on t Filter: (lower((b)::text) = 'a'::text) (2 rows)</code> </pre><br>  N√£o √© preciso muito tempo para reescrever essa consulta espec√≠fica para que apenas o nome do campo seja gravado √† esquerda do operador.  Mas se isso n√£o for poss√≠vel, os √≠ndices nas express√µes (√≠ndices funcionais) ajudar√£o: <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> t(lower(b)); postgres=# <span class="hljs-keyword"><span class="hljs-keyword">analyze</span></span> t; postgres=# <span class="hljs-keyword"><span class="hljs-keyword">explain</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">costs</span></span> <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> t <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> lower(b) = <span class="hljs-string"><span class="hljs-string">'a'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> QUERY PLAN ---------------------------------------------------- Bitmap Heap Scan on t Recheck Cond: (lower((b)::text) = 'a'::text) -&gt; Bitmap Index Scan on t_lower_idx Index Cond: (lower((b)::text) = 'a'::text) (4 rows)</code> </pre><br>  O √≠ndice funcional √© constru√≠do n√£o em um campo da tabela, mas em uma express√£o arbitr√°ria.  O otimizador considerar√° esse √≠ndice para condi√ß√µes como " <em>express√£o do operador de express√£o indexada</em> ".  Se o c√°lculo da express√£o a ser indexada for uma opera√ß√£o cara, a atualiza√ß√£o do √≠ndice tamb√©m exigir√° recursos de computa√ß√£o significativos. <br><br>  Lembre-se tamb√©m de que uma estat√≠stica individual √© coletada para a express√£o indexada.  Podemos conhecer essa estat√≠stica na visualiza√ß√£o "pg_stats" pelo nome do √≠ndice: <br><br><pre> <code class="pgsql hljs">postgres=# \dt</code> </pre><pre> <code class="plaintext hljs"> Table "public.t" Column | Type | Modifiers --------+---------+----------- a | integer | b | text | c | boolean | Indexes: "t_a_b_idx" btree (a, b) "t_a_idx" btree (a) "t_b_idx" btree (b) "t_lower_idx" btree (lower(b))</code> </pre><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pg_stats <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> tablename = <span class="hljs-string"><span class="hljs-string">'t_lower_idx'</span></span>;</code> </pre><br>  √â poss√≠vel, se necess√°rio, controlar o n√∫mero de cestas de histograma da mesma maneira que para campos de dados regulares (observando que o nome da coluna pode diferir dependendo da express√£o indexada): <br><br><pre> <code class="pgsql hljs">postgres=# \d t_lower_idx</code> </pre><pre> <code class="plaintext hljs"> Index "public.t_lower_idx" Column | Type | Definition --------+------+------------ lower | text | lower(b) btree, for table "public.t"</code> </pre><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">alter</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> t_lower_idx <span class="hljs-keyword"><span class="hljs-keyword">alter</span></span> <span class="hljs-keyword"><span class="hljs-keyword">column</span></span> "lower" <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> <span class="hljs-keyword"><span class="hljs-keyword">statistics</span></span> <span class="hljs-number"><span class="hljs-number">69</span></span>;</code> </pre><br><blockquote>  O PostgreSQL 11 apresenta uma maneira mais limpa de controlar o destino das estat√≠sticas dos √≠ndices, especificando o <em>n√∫mero</em> da coluna no comando ALTER INDEX ... SET STATISTICS.  O patch foi desenvolvido pelo meu colega Alexander Korotkov e Adrien Nayrat. </blockquote><br><h3>  √çndices parciais </h3><br>  √Äs vezes, surge a necessidade de indexar apenas parte das linhas da tabela.  Isso geralmente est√° relacionado a uma distribui√ß√£o altamente n√£o uniforme: faz sentido procurar um valor pouco frequente por um √≠ndice, mas √© mais f√°cil encontrar um valor frequente pela varredura completa da tabela. <br><br>  Certamente, podemos criar um √≠ndice regular na coluna "c", que funcionar√° da maneira que esperamos: <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> t(c); postgres=# <span class="hljs-keyword"><span class="hljs-keyword">analyze</span></span> t; postgres=# <span class="hljs-keyword"><span class="hljs-keyword">explain</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">costs</span></span> <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> t <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> c;</code> </pre><pre> <code class="plaintext hljs"> QUERY PLAN ------------------------------- Index Scan using t_c_idx on t Index Cond: (c = true) Filter: c (3 rows)</code> </pre><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">explain</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">costs</span></span> <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> t <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> c;</code> </pre><pre> <code class="plaintext hljs"> QUERY PLAN ------------------- Seq Scan on t Filter: (NOT c) (2 rows)</code> </pre><br>  E o tamanho do √≠ndice √© 276 p√°ginas: <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> relpages <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pg_class <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> relname=<span class="hljs-string"><span class="hljs-string">'t_c_idx'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> relpages ---------- 276 (1 row)</code> </pre><br>  Mas como a coluna ‚Äúc‚Äù tem o valor true somente para 1% das linhas, 99% do √≠ndice nunca √© realmente usado.  Nesse caso, podemos construir um √≠ndice parcial: <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> t(c) <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> c; postgres=# <span class="hljs-keyword"><span class="hljs-keyword">analyze</span></span> t;</code> </pre><br>  O tamanho do √≠ndice √© reduzido para 5 p√°ginas: <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> relpages <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pg_class <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> relname=<span class="hljs-string"><span class="hljs-string">'t_c_idx1'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> relpages ---------- 5 (1 row)</code> </pre><br>  √Äs vezes, a diferen√ßa de tamanho e desempenho pode ser bastante significativa. <br><br><h3>  Classifica√ß√£o </h3><br>  Se um m√©todo de acesso retornar identificadores de linha em alguma ordem espec√≠fica, isso fornecer√° ao otimizador op√ß√µes adicionais para executar a consulta. <br><br>  Podemos digitalizar a tabela e classificar os dados: <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> enable_indexscan=<span class="hljs-keyword"><span class="hljs-keyword">off</span></span>; postgres=# <span class="hljs-keyword"><span class="hljs-keyword">explain</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">costs</span></span> <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> t <span class="hljs-keyword"><span class="hljs-keyword">order</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> a;</code> </pre><pre> <code class="plaintext hljs"> QUERY PLAN --------------------- Sort Sort Key: a -&gt; Seq Scan on t (3 rows)</code> </pre><br>  Mas podemos ler os dados usando o √≠ndice prontamente na ordem desejada: <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> enable_indexscan=<span class="hljs-keyword"><span class="hljs-keyword">on</span></span>; postgres=# <span class="hljs-keyword"><span class="hljs-keyword">explain</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">costs</span></span> <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> t <span class="hljs-keyword"><span class="hljs-keyword">order</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> a;</code> </pre><pre> <code class="plaintext hljs"> QUERY PLAN ------------------------------- Index Scan using t_a_idx on t (1 row)</code> </pre><br>  Somente ‚Äúbtree‚Äù de todos os m√©todos de acesso pode retornar dados classificados, ent√£o vamos adiar uma discuss√£o mais detalhada at√© considerar esse tipo de √≠ndice. <br><br><h3>  Edif√≠cio concorrente </h3><br>  Normalmente, a cria√ß√£o de um √≠ndice adquire um bloqueio SHARE para a tabela.  Esse bloqueio permite a leitura de dados da tabela, mas pro√≠be qualquer altera√ß√£o enquanto o √≠ndice est√° sendo criado. <br><br>  Podemos garantir isso se, digamos, durante a cria√ß√£o de um √≠ndice na tabela "t", realizarmos a consulta abaixo em outra sess√£o: <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> mode, granted <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pg_locks <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> relation = <span class="hljs-string"><span class="hljs-string">'t'</span></span>::<span class="hljs-type"><span class="hljs-type">regclass</span></span>;</code> </pre><pre> <code class="plaintext hljs"> mode | granted -----------+--------- ShareLock | t (1 row)</code> </pre><br>  Se a tabela for grande o suficiente e usada extensivamente para inser√ß√£o, atualiza√ß√£o ou exclus√£o, isso pode parecer inadmiss√≠vel, pois os processos de modifica√ß√£o aguardam a libera√ß√£o do bloqueio por um longo tempo. <br><br>  Nesse caso, podemos usar a constru√ß√£o simult√¢nea de um √≠ndice. <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> <span class="hljs-keyword"><span class="hljs-keyword">concurrently</span></span> <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> t(a);</code> </pre><br>  Este comando bloqueia a tabela no modo SHARE UPDATE EXCLUSIVE, que permite a leitura e a atualiza√ß√£o (√© proibida apenas a altera√ß√£o da estrutura da tabela, bem como a aspira√ß√£o simult√¢nea, a an√°lise ou a cria√ß√£o de outro √≠ndice nesta tabela). <br><br>  No entanto, h√° tamb√©m um outro lado.  Primeiro, o √≠ndice ser√° criado mais lentamente do que o habitual, pois s√£o feitas duas passagens pela tabela em vez de uma e tamb√©m √© necess√°rio aguardar a conclus√£o de transa√ß√µes paralelas que modificam os dados. <br><br>  Segundo, com a cria√ß√£o simult√¢nea do √≠ndice, um conflito pode ocorrer ou restri√ß√µes exclusivas podem ser violadas.  No entanto, o √≠ndice ser√° criado, embora n√£o operacional.  Esse √≠ndice deve ser exclu√≠do e reconstru√≠do.  Os √≠ndices n√£o operacionais s√£o marcados com a palavra INVALID na sa√≠da do comando psql \ d, e a consulta abaixo retorna uma lista completa dos seguintes: <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> indexrelid::<span class="hljs-type"><span class="hljs-type">regclass</span></span> index_name, indrelid::<span class="hljs-type"><span class="hljs-type">regclass</span></span> <span class="hljs-built_in"><span class="hljs-built_in">table_name</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pg_index <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> indisvalid;</code> </pre><pre> <code class="plaintext hljs"> index_name | table_name ------------+------------ t_a_idx | t (1 row)</code> </pre><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Continue lendo</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt441962/">https://habr.com/ru/post/pt441962/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt441946/index.html">API REST no Laravel em 100 linhas de c√≥digo</a></li>
<li><a href="../pt441950/index.html">Eclipse Che 7 j√° est√° aqui</a></li>
<li><a href="../pt441952/index.html">Escolhendo um sistema de armazenamento de arquivos para o trabalho em equipe</a></li>
<li><a href="../pt441954/index.html">Recompensa do usu√°rio aos autores de Habr</a></li>
<li><a href="../pt441956/index.html">Tratamento de erro unificado (op√ß√£o C ++ para microcontroladores)</a></li>
<li><a href="../pt441964/index.html">Dicas e truques do Kubernetes: movendo recursos de cluster para o Helm 2</a></li>
<li><a href="../pt441966/index.html">Kit de inicia√ß√£o para testes de seguran√ßa na Web</a></li>
<li><a href="../pt441968/index.html">Desenvolvimento de um novo ramo de produtos: como se livrar do impratic√°vel e se manter √∫til</a></li>
<li><a href="../pt441970/index.html">An√°lise do Butkit FinFisher</a></li>
<li><a href="../pt441972/index.html">Invidious - front-end alternativo do YouTube</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>