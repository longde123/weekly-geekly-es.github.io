<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üßëüèø üíª üèáüèª Kami membuat game dev. Bagian 1 üë®üèª‚Äç‚öïÔ∏è ‚≠êÔ∏è üìΩÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Pendahuluan 
 Cerita dimulai dengan hackathon berbasis blockchain. Pada awal acara, saya bertemu dengan seorang pria yang menciptakan permainan papan ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Kami membuat game dev. Bagian 1</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/451458/"><img src="https://habrastorage.org/webt/kj/iq/cp/kjiqcpn8xsrxhus_hsclhpi9w_w.jpeg" align="left"><h2>  <font color="#292e5b">Pendahuluan</font> </h2><br>  Cerita dimulai dengan hackathon berbasis blockchain.  Pada awal acara, saya bertemu dengan seorang pria yang menciptakan permainan papan bisnis sebagai hobi (saya berada di playtest dari satu permainan seperti itu), kami bekerja sama, dan bersama-sama kami menemukan sebuah tim yang dengannya mereka ‚Äúmembutakan‚Äù permainan strategis sederhana selama akhir pekan.  Hackathon berlalu, tetapi antusiasme tetap ada.  Dan kami datang dengan ide permainan kartu multipemain tentang kebahagiaan, komunitas dunia, dan pemilihan umum. <br><br>  Dalam seri artikel kami akan mencerminkan jalan kami untuk membuat game, dengan deskripsi dari rake yang telah kami injak dan akan melangkah seiring kami bergerak maju. <br clear="all">  Di bawah potongan akan: <br><br><ul><li>  Ringkasan Game </li><li> Bagaimana keputusan dibuat tentang apa yang harus dilakukan backend.  Di mana ia "hidup" sehingga tidak membayar untuk itu pada tahap pengembangan </li><li>  Langkah pertama dalam pengembangan - otentikasi pemain dan pengaturan perjodohan </li><li>  Rencana selanjutnya </li></ul><a name="habracut"></a><br><h2>  <font color="#292e5b">Tentang game apa</font> </h2><br>  Manusia bosan dengan perang dunia, menipisnya sumber daya dan kompetisi terus-menerus.  Faksi-faksi utama sepakat untuk menggunakan teknologi modern untuk memilih satu kepemimpinan.  Pada waktu yang ditentukan, pemilih dunia harus memutuskan pilihan fraksi yang akan memerintah planet ini untuk milenium berikutnya.  Faksi-faksi utama terlibat dalam perebutan kekuasaan ‚Äújujur‚Äù.  Dalam sesi permainan, setiap pemain mewakili sebagian kecil. <br><br>  Permainan kartu ini tentang pemilihan.  Setiap faksi memiliki anggaran untuk menyelenggarakan pemilihan, sumber pendapatan meningkatkan anggaran dan mulai memilih.  Di awal permainan, dek dengan kartu aksi dicampur dan 4 kartu dikeluarkan untuk masing-masing peserta.  Setiap belokan, pemain dapat melakukan hingga dua aksi game.  Untuk menggunakan kartu, pemain menaruhnya di atas meja dan, jika perlu, menentukan tujuan dan mengurangi dari anggaran biaya penggunaan kartu.  Setelah akhir ronde, pemain hanya dapat menyimpan satu kartu yang tidak digunakan.  Pada awal setiap putaran, pemain mendapatkan kartu dari dek, sehingga pada awal setiap putaran, setiap pemain memiliki 4 kartu aksi di tangan. <br><br>  Di akhir babak 3, 6 dan 9, pemain dengan jumlah suara paling sedikit dihapus dari permainan.  Jika beberapa pemain memiliki jumlah suara minimum yang sama, maka semua pemain dengan hasil ini dihilangkan dari permainan.  Suara-suara para pemain ini pergi ke kolam pemilih umum. <br><br>  Di akhir babak 12, pemenangnya adalah yang memiliki suara terbanyak. <br><br><h2>  <font color="#292e5b">Memilih alat untuk backend</font> </h2><br>  Dari deskripsi game berikut: <br><br><ol><li>  Ini multipemain </li><li>  Penting untuk mengidentifikasi pemain dan mengelola akun </li><li>  Kehadiran komponen sosial akan menguntungkan permainan - teman, komunitas (klan), obrolan, pencapaian (prestasi) </li><li>  Papan peringkat dan fungsionalitas perjodohan akan diperlukan. </li><li>  Fungsi manajemen turnamen akan berguna di masa depan </li><li>  Mengingat permainan ini adalah permainan kartu, Anda perlu mengelola katalog kartu, Anda mungkin perlu menyimpan kartu yang tersedia untuk pemain dan menyusun deck </li><li>  Di masa depan, ekonomi dalam game mungkin diperlukan, termasuk mata uang dalam game, pertukaran barang virtual (kartu) </li></ol><br>  Melihat daftar kebutuhan, saya langsung sampai pada kesimpulan bahwa membuat backend saya sendiri pada tahap awal tidak masuk akal dan pergi ke google apa opsi lain.  Jadi saya menemukan bahwa ada backend gaming cloud khusus, di antaranya PlayFab (dibeli oleh Microsoft) dan GameSparks (dibeli oleh Amazon) menonjol. <br><br>  Secara umum, mereka secara fungsional serupa dan mencakup kebutuhan dasar.  Selain itu, arsitektur internal mereka sangat berbeda, tugas yang sama diselesaikan sedikit berbeda, dan korespondensi eksplisit dalam fitur sulit untuk dilacak.  Di bawah ini adalah fitur positif dan negatif dari setiap platform dan pertimbangan pada topik pilihan. <br><br><h3>  <font color="#9cc2ce">Playfab</font> </h3><br>  Fitur positif: <br><br><ul><li>  Akun dari game yang berbeda digabungkan menjadi akun master </li><li>  Ekonomi permainan dijelaskan tanpa satu baris kode, termasuk penetapan harga ke toko virtual terpisah </li><li>  Antarmuka pengguna yang ramah </li><li>  Microsoft Mengakuisisi Produk Setelah Akuisisi </li><li>  Biaya kepemilikan dalam produksi oleh langganan Indie Studio adalah $ 99 (hingga 100k MAU), ketika beralih ke langganan MAU 1k Profesional akan dikenakan biaya $ 8 (akun minimum $ 300) </li></ul><br>  Fitur negatif: <br><br><ul><li>  Penyimpanan data permainan sangat terbatas, misalnya, dalam langganan gratis untuk menyimpan data untuk sesi permainan tertentu (jika saya memahami semuanya dengan benar, Grup Entitas digunakan untuk ini) 3 slot masing-masing 500 byte tersedia </li><li>  Untuk mengatur Multiplayer, Anda perlu menghubungkan server pihak ketiga yang akan memproses acara dari klien dan menghitung logika game.  Ini adalah Photon pada perangkat keras Anda atau Azure Thunderhead, dan Anda tidak hanya perlu mengatur server, tetapi juga meningkatkan langganan Anda ke setidaknya Indie Studio </li><li>  Perlu untuk memasang fakta bahwa kode cloud tanpa autocomplete dan tidak ada cara untuk masuk ke modul (atau tidak menemukan?) </li><li>  Tidak ada debugger normal, Anda hanya dapat menulis log di CloudScript dan melihat </li></ul><br><h3>  <font color="#9cc2ce">Taman Bermain</font> </h3><br>  Fitur positif: <br><br><ul><li>  Penyimpanan data game.  Tidak hanya ada banyak tempat di mana Anda dapat menyimpan data (metadata permainan umum, barang virtual, profil pemain, sesi multipemain, dll.), Platform ini juga menyediakan basis data lengkap sebagai layanan yang tidak terikat pada apa pun, Selain itu, baik MongoDB dan Redis tersedia segera untuk berbagai jenis data.  Di lingkungan pengembangan Anda dapat menyimpan 10 MB, dalam pertempuran 10 GB </li><li>  Multiplayer tersedia dalam berlangganan gratis (Pengembangan) dengan batas 10 koneksi simultan dan 10 permintaan per detik </li><li>  Pekerjaan mudah dengan CloudCode, termasuk alat bawaan untuk pengujian dan debugging (Test Harness) </li></ul><br>  Fitur negatif: <br><br><ul><li>  Perasaan bahwa sejak pembelian oleh Amazon (musim dingin 2018) alat ini mengalami stagnasi, tidak ada inovasi </li><li>  Sekali lagi, setelah akuisisi Amazon, tarif menjadi lebih buruk, sebelumnya dimungkinkan untuk menggunakan hingga 10.000 MAU dalam produksi secara gratis </li><li>  Biaya produksi kepemilikan mulai dari $ 300 (berlangganan standar) </li></ul><br><h3>  <font color="#9cc2ce">Refleksi</font> </h3><br>  Pertama, Anda harus memeriksa konsep permainan.  Untuk melakukan ini, saya ingin membuat prototipe stick dan scotch tape tanpa investasi moneter dan mulai bermain tes mekanika game.  Karena itu, sejak awal ketika memilih, saya meningkatkan kesempatan untuk mengembangkan dan menguji mekanik pada berlangganan gratis. <br>  GameSparks memenuhi kriteria ini, tetapi PlayFab tidak, karena Anda akan memerlukan server yang akan menangani acara-acara klien game dan langganan tingkat studio Indie ($ 99). <br><br>  Pada saat yang sama, saya menerima risiko bahwa Amazon tidak mengembangkan GameSparks, yang artinya bisa "mati".  Mengingat hal ini dan masih biaya kepemilikan dalam produksi, saya memikirkan potensi kebutuhan untuk pindah ke platform lain atau ke backend saya sendiri. <br><br><h2>  <font color="#292e5b">Langkah pertama dalam pengembangan</font> </h2><br><h3>  <font color="#9cc2ce">Koneksi dan Otentikasi</font> </h3><br>  Jadi, pilihan jatuh pada GameSparks sebagai backend pada tahap prototyping.  Langkah pertama adalah mempelajari cara menghubungkan ke platform dan mengotentikasi pemain.  Poin penting adalah bahwa pengguna harus dapat bermain tanpa registrasi dan SMS segera setelah menginstal game.  Untuk melakukan ini, GameSparks menawarkan opsi untuk membuat profil anonim dengan memanggil metode DeviceAuthenticationRequest, nanti berdasarkan profil anonim Anda dapat membuat profil lengkap dengan menghubungkan, misalnya, dengan akun Google Anda. <br><br>  Mengingat saya memiliki TDD otak, saya mulai dengan membuat tes untuk menghubungkan klien ke permainan.  Karena di masa depan CloudCode perlu ditulis dalam JS, saya akan melakukan tes integrasi di JS menggunakan mocha.js dan chai.js.  Tes pertama ternyata seperti ini: <br><br><pre><code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> expect = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">"chai"</span></span>).expect; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> GameClientModule = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">"../src/gameClient"</span></span>); describe(<span class="hljs-string"><span class="hljs-string">"Integration test"</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.timeout(<span class="hljs-number"><span class="hljs-number">0</span></span>); it(<span class="hljs-string"><span class="hljs-string">"should connect client to server"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> gameClient = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> GameClientModule.GameClient(); expect(gameClient.connected()).is.false; <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> gameClient.connect(); expect(gameClient.connected()).is.true; }); })</code> </pre> <br>  Secara default, batas waktu di mocha.js adalah 2 detik, saya langsung membuatnya tidak ada habisnya, karena tes adalah integrasi.  Dalam pengujian, saya membuat klien game yang belum diimplementasikan, memeriksa bahwa tidak ada koneksi ke server, memanggil perintah untuk terhubung ke backend, dan memverifikasi bahwa klien telah berhasil terhubung. <br><br>  Agar tes berubah menjadi hijau, Anda perlu mengunduh dan menambahkan GameSparks JS SDK ke proyek, serta menghubungkan dependensinya (crypto-js dan ws), dan, tentu saja, mengimplementasikan GameClientModule: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> GameSparks = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">"../gamesparks-javascript-sdk-2018-04-18/gamesparks-functions"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> config = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">"./config.json"</span></span>); exports.GameClient = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> gamesparks = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> GameSparks(); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.connected = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> (gamesparks.connected === <span class="hljs-literal"><span class="hljs-literal">true</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.connect = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) </span></span>{ gamesparks.initPreview({ <span class="hljs-attr"><span class="hljs-attr">key</span></span>: config.gameApiKey, <span class="hljs-attr"><span class="hljs-attr">secret</span></span>: config.credentialSecret, <span class="hljs-attr"><span class="hljs-attr">credential</span></span>: config.credential, <span class="hljs-attr"><span class="hljs-attr">onInit</span></span>: <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> resolve(), <span class="hljs-attr"><span class="hljs-attr">onMessage</span></span>: onMessage, <span class="hljs-attr"><span class="hljs-attr">onError</span></span>: <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">error</span></span></span><span class="hljs-function">) =&gt;</span></span> reject(error), <span class="hljs-attr"><span class="hljs-attr">logger</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log }); }); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onMessage</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">message</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"GAME onMessage: "</span></span> + <span class="hljs-built_in"><span class="hljs-built_in">JSON</span></span>.stringify(message)); } }</code> </pre><br>  Di awal implementasi klien game, kunci yang diperlukan untuk otorisasi teknis untuk membuat koneksi dari aplikasi klien dibaca dari konfigurasi.  Metode yang terhubung membungkus bidang yang sama dari SDK.  Yang paling penting terjadi dalam metode koneksi, ia mengembalikan janji dengan panggilan balik untuk koneksi yang sukses atau kesalahan, juga mengikat penangan onMessage ke panggilan balik yang sama.  onMessage akan bertindak sebagai manajer pemrosesan pesan dari backend, untuk sekarang biarkan ia mencatat pesan ke konsol. <br><br>  Tampaknya pekerjaan telah selesai, tetapi tes tetap merah.  Ternyata GameSparks JS SDK tidak bekerja dengan node.js; untuk itu, Anda lihat, tidak memiliki konteks browser.  Mari kita buat dia berpikir bahwa simpul adalah Chrome di poppy.  Kami pergi ke gamesparks.js dan pada awalnya menambahkan: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span> <span class="hljs-built_in"><span class="hljs-built_in">module</span></span> === <span class="hljs-string"><span class="hljs-string">'object'</span></span> &amp;&amp; <span class="hljs-built_in"><span class="hljs-built_in">module</span></span>.exports) { <span class="hljs-comment"><span class="hljs-comment">// node.js var navigator = { userAgent: "Chrome/73.0.3683.103", vendor: "Google Inc.", platform: "Mac" }; var window = {}; window.setInterval = setInterval; // &lt;&lt;&lt;   KeepAlive  }</span></span></code> </pre><br>  Tes berubah hijau, bergerak. <br><br>  Seperti yang saya tulis sebelumnya, seorang pemain harus dapat mulai bermain segera setelah dia memasuki permainan, sementara saya ingin mulai mengumpulkan analitik dalam aktivitas.  Untuk melakukan ini, kami mengikat pengidentifikasi perangkat atau pengidentifikasi yang dibuat secara acak.  Periksa ini akan menjadi tes seperti itu: <br><br><pre> <code class="javascript hljs">it(<span class="hljs-string"><span class="hljs-string">"should auth two anonymous players"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> gameClient1 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> GameClientModule.GameClient(); expect(gameClient1.playerId).is.undefined; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> gameClient2 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> GameClientModule.GameClient(); expect(gameClient2.playerId).is.undefined; <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> gameClient1.connect(); <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> gameClient1.authWithCustomId(<span class="hljs-string"><span class="hljs-string">"111"</span></span>); expect(gameClient1.playerId).is.equals(<span class="hljs-string"><span class="hljs-string">"5b5f5614031f5bc44d59b6a9"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> gameClient2.connect(); <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> gameClient2.authWithCustomId(<span class="hljs-string"><span class="hljs-string">"222"</span></span>); expect(gameClient2.playerId).is.equals(<span class="hljs-string"><span class="hljs-string">"5b5f6ddb031f5bc44d59b741"</span></span>); });</code> </pre><br>  Saya memutuskan untuk segera memeriksa 2 klien untuk memastikan bahwa setiap klien membuat profil sendiri di backend.  Untuk melakukan ini, Anda memerlukan metode di klien game tempat Anda dapat memberikan pengenal eksternal ke GameSparks, dan kemudian memeriksa bahwa klien telah menghubungi profil pemain.  Profil dipersiapkan sebelumnya di portal GameSparks. <br><br>  Untuk implementasi di GameClient, tambahkan: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.playerId = <span class="hljs-literal"><span class="hljs-literal">undefined</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.authWithCustomId = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">customId</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> requestData = { <span class="hljs-string"><span class="hljs-string">"deviceId"</span></span>: customId , <span class="hljs-string"><span class="hljs-string">"deviceOS"</span></span>: <span class="hljs-string"><span class="hljs-string">"NodeJS"</span></span> } sendRequest(<span class="hljs-string"><span class="hljs-string">"DeviceAuthenticationRequest"</span></span>, requestData) .then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">response</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (response.userId) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.playerId = response.userId; resolve(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { reject(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>(response)); } }) .catch(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">error</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.error(error); }); }); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sendRequest</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">requestType, requestData</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve</span></span></span><span class="hljs-function">) </span></span>{ gamesparks.sendWithData(requestType, requestData, (response) =&gt; resolve(response)); }); }</code> </pre><br>  Implementasi turun ke mengirim permintaan DeviceAuthenticationRequest, menerima pengidentifikasi pemain dari respons, dan menempatkannya di properti klien.  Dengan segera, dalam metode terpisah, helper mengirim permintaan ke GameSparks dengan pembungkus dengan janji. <br><br>  Kedua tes berwarna hijau, tetap menambahkan penutupan koneksi dan refactor. <br>  Di GameClient, saya menambahkan metode yang menutup koneksi ke server (disconnect) dan connectAsAnonymous menggabungkan connect dan authWithCustomId.  Di satu sisi, connectAsAnonymous melanggar prinsip tanggung jawab tunggal, tetapi tampaknya tidak melanggar ... Pada saat yang sama itu menambah kegunaan, karena dalam tes sering diperlukan untuk mengotentikasi klien.  Apa yang Anda pikirkan tentang ini? <br><br>  Dalam pengujian, ia menambahkan pembantu metode pabrik yang membuat instance baru dari klien game dan menambahkan ke array klien yang dibuat.  Di mocha handler khusus, setelah setiap tes berjalan untuk klien dalam array, saya memanggil metode putuskan sambungan dan menghapus array ini.  Saya belum menyukai "string ajaib" dalam kode, jadi saya menambahkan kamus dengan pengidentifikasi khusus yang digunakan dalam pengujian. <br><br>  Kode akhir dapat dilihat di repositori, tautan yang akan saya berikan di akhir artikel. <br><br><h3>  <font color="#9cc2ce">Organisasi pencarian game (perjodohan)</font> </h3><br>  Saya akan memulai fitur perjodohan, yang sangat penting untuk multipemain.  Sistem ini mulai berfungsi ketika kami menekan tombol "Temukan permainan" di dalam sebuah permainan.  Dia mengambil saingan, atau rekan satu tim, atau keduanya (tergantung pada permainan).  Sebagai aturan, dalam sistem tersebut, setiap pemain memiliki indikator numerik MMR (Match Making Ratio) - peringkat pribadi pemain, yang digunakan untuk memilih pemain lain dengan tingkat keterampilan yang sama. <br><br>  Untuk menguji fungsi ini, saya datang dengan tes berikut: <br><br><pre> <code class="javascript hljs">it(<span class="hljs-string"><span class="hljs-string">"should find match"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> gameClient1 = newGameClient(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> gameClient2 = newGameClient(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> gameClient3 = newGameClient(); <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> gameClient1.connectAsAnonymous(playerCustomIds.id1); <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> gameClient2.connectAsAnonymous(playerCustomIds.id2); <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> gameClient3.connectAsAnonymous(playerCustomIds.id3); <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> gameClient1.findStandardMatch(); expect(gameClient1.state) .is.equals(GameClientModule.GameClientStates.MATCHMAKING); <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> gameClient2.findStandardMatch(); expect(gameClient2.state) .is.equals(GameClientModule.GameClientStates.MATCHMAKING); <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> gameClient3.findStandardMatch(); expect(gameClient3.state) .is.equals(GameClientModule.GameClientStates.MATCHMAKING); <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> sleep(<span class="hljs-number"><span class="hljs-number">3000</span></span>); expect(gameClient1.state) .is.equals(GameClientModule.GameClientStates.CHALLENGE); expect(gameClient1.challenge, <span class="hljs-string"><span class="hljs-string">"challenge"</span></span>).is.not.undefined; expect(gameClient1.challenge.challengeId).is.not.undefined; expect(gameClient2.state) .is.equals(GameClientModule.GameClientStates.CHALLENGE); expect(gameClient2.challenge.challengeId) .is.equals(gameClient1.challenge.challengeId); expect(gameClient3.state) .is.equals(GameClientModule.GameClientStates.CHALLENGE); expect(gameClient3.challenge.challengeId) .is.equals(gameClient1.challenge.challengeId); });</code> </pre><br>  Tiga klien terhubung ke permainan (di masa depan itu adalah minimum yang diperlukan untuk memeriksa beberapa skenario) dan terdaftar untuk mencari permainan.  Setelah mendaftarkan pemain ke-3 di server, sesi permainan terbentuk dan para pemain harus terhubung ke sana.  Pada saat yang sama, keadaan klien berubah, dan konteks sesi permainan dengan pengidentifikasi yang sama muncul. <br><br>  Pertama, siapkan backend.  Di GameSparks ada alat yang siap pakai untuk mengkustomisasi pencarian game, tersedia di jalur "Configurator-&gt; Matches".  Saya membuat yang baru dan melanjutkan dengan pengaturan.  Selain parameter standar seperti kode, nama, dan deskripsi pertandingan, jumlah minimum dan maksimum pemain yang diperlukan untuk mode permainan khusus ditunjukkan.  Saya akan menetapkan kode "StandardMatch" ke pertandingan yang dibuat dan menunjukkan jumlah pemain dari 2 hingga 3. <br><br>  Sekarang Anda perlu mengkonfigurasi aturan untuk memilih pemain di bagian "Ambang Batas".  Untuk setiap ambang, waktu aksinya, ketik (absolut, relatif dan dalam persen) dan batas ditunjukkan. <br><br><img src="https://habrastorage.org/webt/tn/xb/i0/tnxbi0kpa9lb3gwhb3hlbpgs9og.png"><br><br>  Misalkan seorang pemain dengan MMR 19 mulai mencari. Dalam contoh di atas, 10 detik pertama adalah pemilihan pemain lain dengan MMR 19 hingga 21. Jika para pemain tidak dipilih, batas pencarian kedua diaktifkan, yang memperluas rentang pencarian dari 16 selama 20 detik berikutnya ( 19-3) hingga 22 (19 + 3).  Selanjutnya, ambang ketiga dimasukkan, di mana pencarian akan dilakukan selama 30 detik dalam rentang dari 14 (19-25%) hingga 29 (19 + 50%), sementara pertandingan dianggap selesai jika jumlah minimum pemain yang dibutuhkan telah diakumulasikan (Terima tanda Min Min Pemain). <br><br>  Bahkan, mekanismenya lebih rumit, karena memperhitungkan MMR dari semua pemain yang berhasil bergabung dengan pertandingan tertentu.  Saya akan menganalisis detail-detail ini ketika saatnya tiba untuk membuat mode rating dari game (tidak ada dalam artikel ini).  Untuk mode permainan standar, di mana saya belum berencana untuk menggunakan MMR, saya hanya perlu satu ambang batas jenis apa pun. <br><br>  Ketika semua pemain telah dipilih, Anda harus membuat sesi permainan dan menghubungkan pemain ke sana.  Di GameSparks, fungsi sesi permainan adalah "Tantangan".  Sebagai bagian dari entitas ini, data sesi game disimpan, dan pesan dipertukarkan antara klien game.  Untuk membuat tipe Tantangan baru, Anda harus menyusuri jalur "Configurator-&gt; Tantangan".  Di sana saya menambahkan tipe baru dengan kode "StandardChallenge" dan menunjukkan bahwa jenis sesi permainan ini adalah Turn Based, yaitu.  pemain bergiliran, tidak secara bersamaan.  GameSparks pada saat yang sama mengendalikan urutan gerakan. <br><br>  Agar klien mendaftar untuk mencari permainan, Anda dapat menggunakan permintaan tipe MatchmakingRequest, tetapi saya tidak akan merekomendasikannya, karena nilai MMR pemain diperlukan sebagai salah satu parameter.  Hal ini dapat menyebabkan penipuan pada bagian dari klien game, dan klien seharusnya tidak mengetahui MMR, ini adalah bisnis backend.  Untuk mendaftar dengan benar untuk pencarian game, saya membuat acara yang sewenang-wenang dari klien.  Ini dilakukan di bagian "Configurator-&gt; Events".  Saya menyebut acara FindStandardMatch tanpa atribut.  Sekarang Anda perlu mengonfigurasi reaksi untuk acara ini, untuk ini saya akan pergi ke "Configurator-&gt; Cloud Code" dari kode cloud, saya menulis penangan berikut untuk FindStandardMatch di bagian "Acara": <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> matchRequest = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SparkRequests.MatchmakingRequest(); matchRequest.matchShortCode = <span class="hljs-string"><span class="hljs-string">"StandardMatch"</span></span>; matchRequest.skill = <span class="hljs-number"><span class="hljs-number">0</span></span>; matchRequest.Execute();</code> </pre><br>  Kode ini mendaftarkan pemain di StandardMatch dengan MMR 0, sehingga setiap pemain yang terdaftar untuk mencari permainan standar akan cocok untuk membuat sesi permainan.  Dalam pemilihan pertandingan peringkat, mungkin ada banding ke data pribadi dari profil pemain untuk mendapatkan MMR dari jenis pertandingan ini. <br><br>  Ketika ada cukup banyak pemain untuk memulai sesi permainan, GameSparks akan mengirim pesan MatchFoundMessage ke semua pemain yang dipilih.  Di sini Anda dapat secara otomatis membuat sesi permainan dan menambahkan pemain ke dalamnya.  Untuk melakukan ini, di "Pesan Pengguna-&gt; MatchFoundMessage" tambahkan kode: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> matchData = Spark.getData(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Spark.getPlayer().getPlayerId() != matchData.participants[<span class="hljs-number"><span class="hljs-number">0</span></span>].id) { Spark.exit(); } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> challengeCode = <span class="hljs-string"><span class="hljs-string">""</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> accessType = <span class="hljs-string"><span class="hljs-string">"PRIVATE"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (matchData.matchShortCode) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"StandardMatch"</span></span>: challengeCode = <span class="hljs-string"><span class="hljs-string">"StandardChallenge"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: Spark.exit(); } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> createChallengeRequest = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SparkRequests.CreateChallengeRequest(); createChallengeRequest.challengeShortCode = challengeCode; createChallengeRequest.accessType = accessType; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> tomorrow = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Date</span></span>(); tomorrow.setDate(tomorrow.getDate() + <span class="hljs-number"><span class="hljs-number">1</span></span>); createChallengeRequest.endTime = tomorrow.toISOString(); createChallengeRequest.usersToChallenge = []; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> participants = matchData.participants; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> numberOfPlayers = participants.length; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">1</span></span>; i &lt; numberOfPlayers; i++) { createChallengeRequest.usersToChallenge.push(participants[i].id) } createChallengeRequest.Send();</code> </pre><br>  Kode pertama memeriksa bahwa itu adalah pemain pertama dalam daftar peserta.  Selanjutnya, atas nama pemain pertama, sebuah instance dari StandardChallenge dibuat dan pemain yang tersisa diundang.  Pemain yang diundang dikirimi pesan ChallengeIssuedMessage.  Di sini Anda dapat membayangkan perilaku ketika undangan untuk bergabung dengan permainan ditampilkan pada klien dan memerlukan konfirmasi dengan mengirim AcceptChallengeRequest, atau Anda dapat menerima undangan dalam mode senyap.  Jadi saya akan melakukannya, untuk ini di "Pesan Pengguna-&gt; ChallengeIssuedMessage" Saya akan menambahkan kode berikut: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> challangeData = Spark.getData(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> acceptChallengeRequest = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SparkRequests.AcceptChallengeRequest(); acceptChallengeRequest.challengeInstanceId = challangeData.challenge.challengeId; acceptChallengeRequest.message = <span class="hljs-string"><span class="hljs-string">"Joining"</span></span>; acceptChallengeRequest.SendAs(Spark.getPlayer().getPlayerId());</code> </pre><br>  Langkah selanjutnya, GameSparks mengirimkan acara ChallengeStartedMessage.  Penangan global dari acara ini ("Pesan Global-&gt; ChallengeStartedMessage") adalah tempat yang ideal untuk menginisialisasi sesi permainan, saya akan mengurus ini ketika menerapkan logika game. <br><br>  Waktunya telah tiba untuk aplikasi klien.  Perubahan pada modul klien: <br><br><pre> <code class="javascript hljs">exports.GameClientStates = { <span class="hljs-attr"><span class="hljs-attr">IDLE</span></span>: <span class="hljs-string"><span class="hljs-string">"Idle"</span></span>, <span class="hljs-attr"><span class="hljs-attr">MATCHMAKING</span></span>: <span class="hljs-string"><span class="hljs-string">"Matchmaking"</span></span>, <span class="hljs-attr"><span class="hljs-attr">CHALLENGE</span></span>: <span class="hljs-string"><span class="hljs-string">"Challenge"</span></span> } exports.GameClient = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.state = exports.GameClientStates.IDLE; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.challenge = <span class="hljs-literal"><span class="hljs-literal">undefined</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onMessage</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">message</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (message[<span class="hljs-string"><span class="hljs-string">"@class"</span></span>]) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">".MatchNotFoundMessage"</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.state = exports.GameClientStates.IDLE; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">".ChallengeStartedMessage"</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.state = exports.GameClientStates.CHALLENGE; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.challenge = message.challenge; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"GAME onMessage: "</span></span> + <span class="hljs-built_in"><span class="hljs-built_in">JSON</span></span>.stringify(message)); } } onMessage = onMessage.bind(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.findStandardMatch = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> eventData = { <span class="hljs-attr"><span class="hljs-attr">eventKey</span></span>: <span class="hljs-string"><span class="hljs-string">"FindStandardMatch"</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve</span></span></span><span class="hljs-function"> =&gt;</span></span> { sendRequest(<span class="hljs-string"><span class="hljs-string">"LogEventRequest"</span></span>, eventData) .then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">response</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!response.error) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.state = exports.GameClientStates.MATCHMAKING; resolve(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.error(response.error); reject(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>(response)); } }) .catch(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">error</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.error(error); reject(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>(error)); }); }); } }</code> </pre><br>  Sesuai dengan tes, beberapa bidang muncul di negara klien dan tantangan.  Metode onMessage telah memperoleh tampilan yang berarti dan sekarang merespons pesan tentang awal sesi permainan dan pesan bahwa tidak mungkin untuk mengambil permainan.  Metode findStandardMatch juga telah ditambahkan, yang mengirimkan permintaan yang sesuai ke backend.  Tesnya hijau, tapi saya puas, pilihan permainan dikuasai. <br><br><h2>  <font color="#292e5b">Apa selanjutnya</font> </h2><br>  Dalam artikel berikut ini saya akan menjelaskan proses mengembangkan logika game, dari menginisialisasi sesi permainan hingga pemrosesan gerakan.  Saya akan menganalisis fitur penyimpanan berbagai jenis data - deskripsi metadata game, karakteristik dunia game, data dari sesi permainan, dan data tentang pemain.  Logika game akan dikembangkan melalui dua jenis pengujian - unit dan integrasi. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Saya akan mengunggah sumber di github dalam</a> porsi yang terkait dengan artikel. <br><br>  Ada pemahaman bahwa untuk maju secara efektif dalam menciptakan permainan, Anda perlu memperluas tim penggemar kami.  Artis / desainer akan segera bergabung.  Dan guru di, misalnya, Unity3D, yang akan membuat garis depan untuk platform seluler, masih harus ditemukan. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id451458/">https://habr.com/ru/post/id451458/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id451446/index.html">Pengembangan Produk Alat Bantu Visual: Desain</a></li>
<li><a href="../id451448/index.html">Mengapa Tidak Melacak Mungkin Dibutuhkan</a></li>
<li><a href="../id451452/index.html">Build2019, memahami apa yang kami lihat</a></li>
<li><a href="../id451454/index.html">Kami mengubah konten aplikasi notifikasi iOS</a></li>
<li><a href="../id451456/index.html">Penyimpanan AERODISK Rusia: pengujian beban. Meremas IOPS</a></li>
<li><a href="../id451460/index.html">Julia dalam labirin</a></li>
<li><a href="../id451462/index.html">Tulis lebih sedikit kode duplikat menggunakan binder di Laravel</a></li>
<li><a href="../id451464/index.html">Frontend Weekly Digest (6 - 12 Mei 2019)</a></li>
<li><a href="../id451466/index.html">graphql - jebakan</a></li>
<li><a href="../id451468/index.html">Intisari bahan-bahan segar dari dunia front-end untuk minggu terakhir No. 364 (6 - 12 Mei 2019)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>