<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>💶 💳 👰🏻 Pengembangan aplikasi seluler tanpa server 🖲️ 👩🏾‍🏫 💵</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Sangat sering ketika mengembangkan aplikasi mobile (mungkin masalah yang sama dengan aplikasi web), pengembang menemukan diri mereka dalam situasi di ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Pengembangan aplikasi seluler tanpa server</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/surfstudio/blog/477506/">  Sangat sering ketika mengembangkan aplikasi mobile (mungkin masalah yang sama dengan aplikasi web), pengembang menemukan diri mereka dalam situasi di mana backend tidak berfungsi atau tidak menyediakan metode yang diperlukan. <br><br>  Situasi ini dapat terjadi karena berbagai alasan.  Namun, paling sering pada awal pengembangan, backend tidak ditulis dan klien memulai tanpanya.  Dalam hal ini, awal pengembangan tertunda 2-4 bulan <br><br>  Terkadang server dimatikan (crash), terkadang tidak punya waktu untuk meluncurkan metode yang diperlukan, kadang-kadang ada masalah data, dll.  Semua masalah ini membuat kami menulis layanan Mocker kecil yang memungkinkan Anda mengganti backend yang sebenarnya. <br><br><img src="https://habrastorage.org/webt/xj/8e/it/xj8eitbqje5bpz5trubpbzav_qa.png"><br><a name="habracut"></a><br><div class="spoiler">  <b class="spoiler_title">Bagaimana saya bisa sampai pada ini</b> <div class="spoiler_text"> Bagaimana saya sampai pada ini?  Tahun pertama saya di perusahaan berakhir dan mereka menempatkan saya pada proyek e-commerce baru.  Manajer mengatakan bahwa proyek perlu diselesaikan dalam 4 bulan, tetapi tim backend (di sisi pelanggan) akan memulai pengembangan hanya setelah 1,5 bulan.  Dan selama ini kita harus membuang banyak fitur UI. <br><br>  Saya menyarankan untuk menulis backend moch (sebelum saya menjadi pengembang iOS, saya bermain dengan .NET di uni).  Gagasan implementasi sederhana: menurut spesifikasi yang diberikan, perlu menulis metode rintisan yang akan mengambil data dari file JSON yang sudah disiapkan sebelumnya.  Mereka memutuskan itu. <br><br>  Setelah 2 minggu, saya pergi berlibur dan berpikir: "Mengapa saya tidak secara otomatis menghasilkan semua ini?"  Jadi selama 2 minggu liburan saya menulis mirip seorang penerjemah yang mengambil spesifikasi APIBlueprint dan menghasilkan .NET Web App darinya (kode C #). <br><br>  Sebagai hasilnya, versi pertama dari benda ini muncul dan kami bertahan di sana selama hampir 2,5 bulan.  Saya tidak bisa memberikan bilangan real, seberapa banyak ini membantu kami, tetapi saya ingat bagaimana mereka mengatakan dalam retrospeksi bahwa jika itu bukan untuk sistem ini, tidak akan ada rilis. <br><br>  Sekarang, setelah beberapa tahun, saya memperhitungkan kesalahan yang saya lakukan (dan ada banyak kesalahan) dan sepenuhnya menulis ulang instrumen itu. <br><br>  Mengambil kesempatan ini - terima kasih banyak kepada kolega yang membantu dengan umpan balik dan saran.  Dan juga kepada para pemimpin yang menanggung semua "kesewenang-wenangan rekayasa" saya. <br></div></div><br><h3>  Pendahuluan </h3><br>  Sebagai aturan, setiap aplikasi client-server terlihat seperti ini: <br><br><img src="https://habrastorage.org/webt/fs/bh/xa/fsbhxawsxnmbtygz0pxuc7-nbri.png"><br><br>  Setiap layar memiliki setidaknya 1 permintaan (dan seringkali lebih).  Bergerak jauh ke dalam layar, kita perlu membuat lebih banyak permintaan.  Kadang-kadang kita bahkan tidak bisa melakukan transisi sampai server memberi tahu kita "Tampilkan tombol".  Artinya, aplikasi seluler sangat terikat dengan server, tidak hanya selama pekerjaan segera, tetapi juga pada tahap pengembangan.  Pertimbangkan siklus pengembangan produk abstrak: <br><br><img src="https://habrastorage.org/webt/xc/o6/pm/xco6pm2ekp91qzev1lgowrriyle.png"><br><br><ol><li>  Pertama kita mendesain.  Kami membusuk, menggambarkan, dan berdiskusi. </li><li>  Setelah menerima tugas dan persyaratan, kami memulai pengembangan.  Kami menulis kode, set huruf, dll. </li><li>  Setelah kami mengimplementasikan sesuatu, perakitan sedang dipersiapkan, yang masuk ke pengujian manual, di mana aplikasi diperiksa untuk kasus yang berbeda. </li><li>  Jika semuanya baik-baik saja dengan kami, dan penguji menguji perakitan, ia pergi ke pelanggan yang melakukan penerimaan. </li></ol><br>  Setiap proses ini sangat penting.  Terutama yang terakhir, karena pelanggan harus mengerti pada tahap apa kita sebenarnya, dan kadang-kadang dia perlu melaporkan hasilnya kepada manajemen atau investor.  Sebagai aturan, laporan tersebut terjadi, termasuk dalam format demonstrasi aplikasi seluler.  Dalam praktik saya, ada kasus ketika seorang pelanggan menunjukkan hanya setengah dari MVP, yang hanya bekerja pada moka.  Aplikasi mok terlihat seperti hadiah dan dukun seperti hadiah.  Jadi itu nyata (: <br>  Namun, ini adalah mimpi merah muda.  Mari kita lihat apa yang sebenarnya terjadi jika kita tidak memiliki server. <br><br><img src="https://habrastorage.org/webt/v6/gp/vp/v6gpvpbngkjv_mk4mnalkbxulpe.png"><br><br><ol><li>  Proses pengembangan akan lebih lambat dan lebih menyakitkan, karena kami tidak dapat menulis layanan secara normal, kami juga tidak dapat memeriksa semua kasus, kami harus menulis bertopik yang perlu dihapus nanti. </li><li>  Setelah kami melakukan kebaktian dengan kesedihan, para penguji yang melihatnya dan tidak mengerti apa yang harus dilakukan dengannya.  Anda tidak dapat memeriksa apa pun, setengahnya tidak berfungsi sama sekali, karena tidak ada server.  Akibatnya, mereka kehilangan banyak bug: baik logis maupun visual. </li><li>  Nah, setelah "bagaimana mereka bisa terlihat," Anda perlu memberikan perakitan kepada pelanggan dan kemudian yang paling tidak menyenangkan dimulai.  Pelanggan tidak dapat benar-benar mengevaluasi pekerjaan, ia melihat 1-2 kasus dari semua kemungkinan dan tentu saja tidak dapat menunjukkannya kepada investornya. </li></ol><br>  Secara umum, semuanya akan menurun.  Dan sayangnya, situasi seperti itu terjadi hampir selalu: kadang-kadang tidak ada server selama beberapa bulan, kadang-kadang setengah tahun, kadang-kadang hanya dalam proses server sangat terlambat atau Anda perlu dengan cepat memeriksa kasus batas yang dapat direproduksi menggunakan manipulasi data pada server nyata. <br><br>  Misalnya, kami ingin memeriksa bagaimana aplikasi berperilaku jika pembayaran pengguna lebih lama dari tanggal jatuh tempo.  Sangat sulit (dan lama) untuk mereproduksi situasi seperti itu di server dan kita perlu melakukan ini secara buatan. <br><br>  Karena itu, ada masalah berikut: <br><br><ol><li>  Server benar-benar hilang.  Karena itu, tidak mungkin untuk merancang, menguji dan menyajikan. </li><li>  Server tidak punya waktu, yang mengganggu pengembangan dan dapat mengganggu pengujian. </li><li>  Kami ingin menguji batas kasus, dan server tidak dapat membiarkan ini tanpa gerakan panjang. </li><li>  Mempengaruhi pengujian dan presentasi yang mengancam. </li><li>  Server macet (sekali, selama pengembangan stabil, kami kehilangan server selama 3,5 hari). </li></ol><br>  Untuk mengatasi masalah ini, Mocker diciptakan. <br><br><h3>  Prinsip kerja </h3><br>  Mocker adalah layanan web kecil yang di-host di suatu tempat, mendengarkan lalu lintas pada port tertentu dan dapat merespons dengan data yang telah disiapkan untuk permintaan jaringan tertentu. <br><br>  Urutannya adalah sebagai berikut: <br><br>  1. Klien mengirim permintaan. <br>  2. Mocker menerima permintaan tersebut. <br>  3. Mocker menemukan mocker yang diinginkan. <br>  4. Mocker mengembalikan mock yang diinginkan. <br><br>  Jika semuanya jelas dengan poin 1,2 dan 4, maka 3 mengajukan pertanyaan. <br><br>  Untuk memahami bagaimana layanan menemukan tiruan yang diperlukan untuk klien, pertama-tama kita mempertimbangkan struktur tiruan itu sendiri. <br><br>  Mock adalah file JSON dalam format berikut: <br><br><pre><code class="json hljs">{ <span class="hljs-attr"><span class="hljs-attr">"url"</span></span>: <span class="hljs-string"><span class="hljs-string">"string"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"method"</span></span>: <span class="hljs-string"><span class="hljs-string">"string"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"statusCode"</span></span>: <span class="hljs-string"><span class="hljs-string">"number"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"response"</span></span>: <span class="hljs-string"><span class="hljs-string">"object"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"request"</span></span>: <span class="hljs-string"><span class="hljs-string">"object"</span></span> }</code> </pre> <br>  Mari kita menganalisis setiap bidang secara terpisah. <br><br><h4>  url </h4><br>  Parameter ini digunakan untuk menentukan URL permintaan yang diakses klien. <br><br>  Misalnya, jika aplikasi seluler membuat permintaan ke url <code>host.dom/path/to/endpoint</code> , maka di bidang <code>url</code> kita perlu menulis <code>/path/to/endpoint</code> . <br>  Yaitu, bidang ini menyimpan <b>jalur relatif ke titik akhir</b> . <br><br>  Bidang ini harus diformat dalam format url-template, yaitu format berikut diizinkan: <br><br><ol><li>  <code>/path/to/endpoint</code> - alamat url normal.  Ketika permintaan diterima, layanan akan membandingkan garis karakter dengan karakter. </li><li>  <code>/path/to/endpoint/{number}</code> - url dengan pola path.  Mock dengan URL semacam itu akan menanggapi permintaan apa pun yang cocok dengan pola ini. </li><li>  <code>/path/to/endpoint/data?param={value}</code> - url dengan pola-parameter.  Mengejek dengan url seperti itu akan memicu permintaan berisi parameter yang diberikan.  Selain itu, jika salah satu parameter tidak ada dalam permintaan, maka tidak akan cocok dengan templat. </li></ol><br>  Dengan demikian, dengan mengontrol parameter URL, Anda dapat dengan jelas menentukan bahwa tiruan tertentu akan kembali ke url tertentu. <br><br><h4>  metode </h4><br>  Ini adalah metode http yang diharapkan.  Misalnya <code>POST</code> atau <code>GET</code> . <br>  String harus hanya berisi huruf kapital. <br><br><h4>  statusCode </h4><br>  Ini adalah kode status http untuk respons.  Artinya, dengan meminta tiruan ini, klien akan menerima respons dengan status yang tercatat di bidang statusCode. <br><br><h4>  tanggapan </h4><br>  Bidang ini berisi objek JSON yang akan dikirim ke klien dalam isi respons terhadap permintaannya. <br><br><h4>  permintaan </h4><br>  Ini adalah badan permintaan yang diharapkan akan diterima dari klien. Ini akan digunakan untuk memberikan tanggapan yang diinginkan tergantung pada badan permintaan permintaan.  Misalnya, jika kita ingin mengubah jawaban tergantung pada parameter permintaan. <br><br><pre> <code class="json hljs">{ <span class="hljs-attr"><span class="hljs-attr">"url"</span></span>: <span class="hljs-string"><span class="hljs-string">"/auth"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"method"</span></span>: <span class="hljs-string"><span class="hljs-string">"POST"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"statusCode"</span></span>: <span class="hljs-number"><span class="hljs-number">200</span></span>, <span class="hljs-attr"><span class="hljs-attr">"response"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"token"</span></span>: <span class="hljs-string"><span class="hljs-string">"cbshbg52rebfzdghj123dsfsfasd"</span></span> }, <span class="hljs-attr"><span class="hljs-attr">"request"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"login"</span></span>: <span class="hljs-string"><span class="hljs-string">"Tester"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"password"</span></span>: <span class="hljs-string"><span class="hljs-string">"Valid"</span></span> } }</code> </pre><br><pre> <code class="json hljs">{ <span class="hljs-attr"><span class="hljs-attr">"url"</span></span>: <span class="hljs-string"><span class="hljs-string">"/auth"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"method"</span></span>: <span class="hljs-string"><span class="hljs-string">"POST"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"statusCode"</span></span>: <span class="hljs-number"><span class="hljs-number">400</span></span>, <span class="hljs-attr"><span class="hljs-attr">"response"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"message"</span></span>: <span class="hljs-string"><span class="hljs-string">"Bad credentials"</span></span> }, <span class="hljs-attr"><span class="hljs-attr">"request"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"login"</span></span>: <span class="hljs-string"><span class="hljs-string">"Tester"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"password"</span></span>: <span class="hljs-string"><span class="hljs-string">"Invalid"</span></span> } }</code> </pre><br>  Jika klien mengirim permintaan dengan badan: <br><br><pre> <code class="json hljs">{ <span class="hljs-attr"><span class="hljs-attr">"login"</span></span>: <span class="hljs-string"><span class="hljs-string">"Tester"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"password"</span></span>: <span class="hljs-string"><span class="hljs-string">"Valid"</span></span> }</code> </pre><br>  Maka sebagai tanggapan dia akan menerima: <br><br><pre> <code class="json hljs">{ <span class="hljs-attr"><span class="hljs-attr">"token"</span></span>: <span class="hljs-string"><span class="hljs-string">"cbshbg52rebfzdghj123dsfsfasd"</span></span> }</code> </pre><br>  Dan jika kita ingin memeriksa bagaimana aplikasi akan bekerja jika kata sandi dimasukkan secara tidak benar, maka permintaan akan dikirim dengan badan: <br><br><pre> <code class="json hljs">{ <span class="hljs-attr"><span class="hljs-attr">"login"</span></span>: <span class="hljs-string"><span class="hljs-string">"Tester"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"password"</span></span>: <span class="hljs-string"><span class="hljs-string">"Invalid"</span></span> }</code> </pre><br>  Maka sebagai tanggapan dia akan menerima: <br><pre> <code class="json hljs">{ <span class="hljs-attr"><span class="hljs-attr">"message"</span></span>: <span class="hljs-string"><span class="hljs-string">"Bad credentials"</span></span> }</code> </pre><br>  Dan kita dapat memeriksa kasingnya dengan kata sandi yang salah.  Dan untuk semua kasus lainnya. <br><br>  Dan sekarang kita akan mencari tahu bagaimana pengelompokan dan mencari kerja moq yang diinginkan. <br><br><img src="https://habrastorage.org/webt/3g/r4/yj/3gr4yj1z0c4pamlfipuvnoculhg.png"><br><br>  Untuk mencari mok yang diinginkan dengan cepat dan mudah, server memuat semua mokas ke dalam memori dan mengelompokkannya dengan cara yang benar.  Gambar di atas menunjukkan contoh pengelompokan. <br><br>  Server menggabungkan moka berbeda dengan <b>url</b> dan <b>metode</b> .  Ini perlu, antara lain, agar kita dapat membuat banyak mok berbeda di satu url. <br><br>  Sebagai contoh, kami ingin tarik-ke-Refresh yang terus-menerus menarik, jawaban yang berbeda datang dan keadaan layar berubah setiap saat (untuk memeriksa semua kasus batas). <br><br>  Kemudian kita dapat membuat banyak moks yang berbeda dengan <b>metode</b> dan parameter <b>url yang</b> sama, dan server akan mengembalikannya kepada kita secara iteratif (pada gilirannya). <br>  Sebagai contoh, mari kita memiliki moka seperti: <br><br><pre> <code class="json hljs">{ <span class="hljs-attr"><span class="hljs-attr">"url"</span></span>: <span class="hljs-string"><span class="hljs-string">"/products"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"method"</span></span>: <span class="hljs-string"><span class="hljs-string">"GET"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"statusCode"</span></span>: <span class="hljs-number"><span class="hljs-number">200</span></span>, <span class="hljs-attr"><span class="hljs-attr">"response"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"name"</span></span>: <span class="hljs-string"><span class="hljs-string">"product"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"currency"</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-attr"><span class="hljs-attr">"value"</span></span>: <span class="hljs-number"><span class="hljs-number">20</span></span> } }</code> </pre><br><pre> <code class="json hljs">{ <span class="hljs-attr"><span class="hljs-attr">"url"</span></span>: <span class="hljs-string"><span class="hljs-string">"/products"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"method"</span></span>: <span class="hljs-string"><span class="hljs-string">"GET"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"statusCode"</span></span>: <span class="hljs-number"><span class="hljs-number">200</span></span>, <span class="hljs-attr"><span class="hljs-attr">"response"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"name"</span></span>: <span class="hljs-string"><span class="hljs-string">"gdshfjshhkfhsdgfhshdjgfhjkshdjkfsfgbjsfgskdf"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"currency"</span></span>: <span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-attr"><span class="hljs-attr">"value"</span></span>: <span class="hljs-number"><span class="hljs-number">100000000000</span></span> } }</code> </pre><br><pre> <code class="json hljs">{ <span class="hljs-attr"><span class="hljs-attr">"url"</span></span>: <span class="hljs-string"><span class="hljs-string">"/products"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"method"</span></span>: <span class="hljs-string"><span class="hljs-string">"GET"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"statusCode"</span></span>: <span class="hljs-number"><span class="hljs-number">200</span></span>, <span class="hljs-attr"><span class="hljs-attr">"response"</span></span>: <span class="hljs-literal"><span class="hljs-literal">null</span></span> }</code> </pre><br><pre> <code class="json hljs">{ <span class="hljs-attr"><span class="hljs-attr">"url"</span></span>: <span class="hljs-string"><span class="hljs-string">"/products"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"method"</span></span>: <span class="hljs-string"><span class="hljs-string">"GET"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"statusCode"</span></span>: <span class="hljs-number"><span class="hljs-number">400</span></span>, <span class="hljs-attr"><span class="hljs-attr">"response"</span></span>: <span class="hljs-literal"><span class="hljs-literal">null</span></span> }</code> </pre><br>  Kemudian, ketika kita memanggil metode GET / produk untuk pertama kalinya, kita akan mendapatkan jawabannya: <br><br><pre> <code class="json hljs">{ <span class="hljs-attr"><span class="hljs-attr">"name"</span></span>: <span class="hljs-string"><span class="hljs-string">"product"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"currency"</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-attr"><span class="hljs-attr">"value"</span></span>: <span class="hljs-number"><span class="hljs-number">20</span></span> }</code> </pre><br>  Ketika kami memanggil kedua kalinya, pointer iterator akan bergeser ke elemen berikutnya dan kembali kepada kami: <br><br><pre> <code class="json hljs">{ <span class="hljs-attr"><span class="hljs-attr">"name"</span></span>: <span class="hljs-string"><span class="hljs-string">"gdshfjshhkfhsdgfhshdjgfhjkshdjkfsfgbjsfgskdf"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"currency"</span></span>: <span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-attr"><span class="hljs-attr">"value"</span></span>: <span class="hljs-number"><span class="hljs-number">100000000000</span></span> }</code> </pre><br>  Dan kita dapat memeriksa bagaimana aplikasi berperilaku jika kita mendapatkan nilai besar.  Dan sebagainya. <br><br>  Nah, dan ketika kita sampai ke elemen terakhir dan memanggil metode lagi, elemen pertama akan kembali kepada kita lagi, karena iterator akan kembali ke elemen pertama. <br><br><h3>  Proxy caching </h3><br>  Mocker dapat bekerja dalam mode proxy caching.  Ini berarti bahwa ketika suatu layanan menerima permintaan dari klien, ia mengeluarkan alamat host di mana server sebenarnya berada dan skema (untuk menentukan protokol).  Kemudian dibutuhkan permintaan yang diterima (dengan semua tajuknya, jadi jika metode ini memerlukan otentikasi, maka tidak apa-apa, <code>Authorization: Bearer ...</code> Anda <code>Authorization: Bearer ...</code> ditransfer) dan memotong informasi layanan darinya ( <code>host</code> dan <code>scheme</code> ) dan mengirimkan permintaan ke server yang sebenarnya. <br><br>  Setelah menerima respons dengan kode ke-200, Mocker menyimpan jawaban ke file Mock (ya, Anda kemudian dapat menyalin atau mengubahnya) dan mengembalikan kepada klien apa yang diterima dari server sebenarnya.  Selain itu, itu tidak hanya menyimpan file ke tempat acak, tetapi mengatur file sehingga Anda dapat bekerja dengannya secara manual. Misalnya, Mocker mengirimkan permintaan ke URL berikut: <code>hostname.dom/main/products/loans/info</code> .  Kemudian akan membuat folder <code>hostname.dom</code> , lalu di dalamnya akan membuat folder <code>main</code> , di dalamnya folder <code>products</code> ... <br><br>  Untuk menghindari duplikat tiruan, nama dibentuk berdasarkan metode <b>http</b> (GET, PUT ...) dan <b>hash dari badan respons server sebenarnya</b> .  Dalam hal ini, jika sudah ada ejekan pada jawaban tertentu, maka itu hanya akan ditimpa. <br><br>  Fitur ini dapat diaktifkan secara terpisah untuk setiap permintaan.  Untuk melakukan ini, tambahkan tiga header ke permintaan: <br><br><pre> <code class="plaintext hljs">X-Mocker-Redirect-Is-On: "true", X-Mocker-Redirect-Host: "hostaname.ex:1234", X-Mocker-Redirect-Scheme: "http"</code> </pre><br><h3>  Indikasi eksplisit dari jalan ke mock </h3><br>  Terkadang Anda ingin Mocker mengembalikan hanya mokas yang kita inginkan, dan tidak semua yang ada di proyek. <br><br>  Terutama relevan untuk penguji.  Akan lebih mudah bagi mereka untuk memiliki semacam set moka yang disiapkan untuk masing-masing kasus uji.  Dan kemudian, selama pengujian, QA hanya memilih folder yang dibutuhkan dan berfungsi dengan tenang, karena tidak ada lagi suara dari mengejek pihak ketiga. <br><br>  Sekarang ini mungkin.  Untuk mengaktifkan fungsi ini, Anda perlu menggunakan header khusus: <br><br><pre> <code class="plaintext hljs">X-Mocker-Specific-Path: path</code> </pre><br>  Sebagai contoh, biarkan Mocker memiliki struktur folder seperti itu di root <br><br><pre> <code class="plaintext hljs">root/ block_card_test_case/ mocks.... main_test_case/ blocked_test_case/ mocks...</code> </pre><br>  Jika Anda perlu menjalankan test case tentang kartu yang diblokir, maka <br> <b><code>X-Mocker-Specific-Path: block_card_test_case</code></b> <br>  Jika Anda perlu menjalankan test case yang terkait dengan mengunci layar utama, maka <br> <b><code>X-Mocker-Specific-Path: main_test_case/blocked_test_case</code></b> <br> <br><h3>  Antarmuka </h3><br>  Pada awalnya, kami bekerja dengan mokas secara langsung melalui ssh, tetapi dengan peningkatan jumlah mokas dan pengguna, kami beralih ke opsi yang lebih nyaman.  Sekarang kami menggunakan CloudCommander. <br>  Dalam contoh komposisi buruh pelabuhan, ia berikatan dengan wadah Mocker. <br><br>  Itu terlihat seperti ini: <br><br><img src="https://habrastorage.org/webt/g8/ix/y2/g8ixy2mxaomzvo7zwknzhjf33jw.png"><br><br>  Nah, bonusnya adalah web-editor, yang memungkinkan Anda untuk menambah / mengubah moki langsung dari browser. <br><br><img src="https://habrastorage.org/webt/2o/_d/ut/2o_dutkmga1j_dkuwor2isr4jxq.png"><br><br>  Ini juga solusi sementara.  Dalam rencana untuk menjauh dari bekerja dengan moks melalui sistem file ke beberapa database.  Dan karenanya, akan dimungkinkan untuk mengendalikan mokas sendiri dari GUI ke DB ini. <br><br><h3>  Penempatan </h3><br>  Cara termudah untuk menggunakan Mocker adalah menggunakan Docker.  Selain itu, penggelaran layanan dari buruh pelabuhan akan secara otomatis menyebarkan antarmuka berbasis web yang dengannya lebih nyaman untuk bekerja dengan moka.  File yang dibutuhkan untuk penyebaran melalui Docker ada di dalam repositori. <br><br>  Namun, jika opsi ini tidak cocok untuk Anda, Anda dapat secara mandiri mengumpulkan layanan dari sumbernya.  Cukup untuk ini: <br><br><pre> <code class="plaintext hljs">git clone https://github.com/LastSprint/mocker.git cd mocker go build .</code> </pre><br>  Maka Anda perlu menulis file konfigurasi ( <a href="">contoh</a> ) dan memulai layanan: <br><br><pre> <code class="plaintext hljs">mocker config.json</code> </pre><br><h3>  Masalah yang Diketahui </h3><br><ul><li>  Setelah setiap file baru, Anda perlu melakukan <code>curl mockerhost.dom/update_models</code> agar layanan membaca file lagi.  Saya tidak menemukan cara cepat dan elegan untuk memperbaruinya </li><li>  Terkadang bug CloudCommander (atau saya melakukan sesuatu yang salah) dan itu tidak memungkinkan pengeditan moki yang dibuat melalui antarmuka web.  Itu diperlakukan dengan membersihkan cache browser. </li><li>  Layanan hanya berfungsi dengan <code>application/json</code> .  Paket mendukung <code>form-url-encoding</code> . </li></ul><br><h3>  Ringkasan </h3><br>  Mocker adalah layanan web yang memecahkan masalah pengembangan aplikasi client-server ketika server tidak siap karena beberapa alasan. <br><br>  Layanan ini memungkinkan Anda untuk membuat banyak tiruan yang berbeda ke satu URL, memungkinkan Anda untuk menghubungkan Permintaan dan Respons satu sama lain dengan secara eksplisit menentukan parameter di url, atau langsung dengan mengatur badan permintaan yang diharapkan.  Layanan ini memiliki antarmuka berbasis web yang sangat menyederhanakan kehidupan pengguna. <br><br>  Setiap pengguna layanan dapat secara mandiri menambahkan titik akhir yang diperlukan dan permintaan yang dibutuhkannya.  Dalam hal ini, pada klien, untuk beralih ke server nyata, cukup dengan mengganti konstanta dengan alamat host. <br><br>  Saya harap artikel ini akan membantu orang yang menderita masalah serupa dan, mungkin, kita akan bekerja sama untuk mengembangkan alat ini. <br><br>  <a href="https://github.com/LastSprint/mocker">Repositori GitHub</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id477506/">https://habr.com/ru/post/id477506/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id477496/index.html">Masker Kaca Retak - Apakah Ini PR yang Direncanakan?</a></li>
<li><a href="../id477498/index.html">Kami mengumpulkan log dari Nginx menggunakan nginx-clickhouse, mengirim ke Clickhouse dan menampilkannya di Grafana</a></li>
<li><a href="../id477500/index.html">Application Model (Longsor - kerangka kerja aplikasi untuk Java)</a></li>
<li><a href="../id477502/index.html">Pekerjaan jauh dari majikan yang sehat</a></li>
<li><a href="../id477504/index.html">Praktik Pengembangan Aplikasi Terbaik Untuk Diikuti Pada Tahun 2020</a></li>
<li><a href="../id477508/index.html">Detektor radar: beberapa kata lagi tentang etika dan banyak kata tentang hukum</a></li>
<li><a href="../id477510/index.html">Pencadangan otomatis dan pemulihan daftar alamat dinamis di Mikrotik</a></li>
<li><a href="../id477512/index.html">Pertempuran L2TP, RRAS vs SoftEther</a></li>
<li><a href="../id477514/index.html">Otomasi Uji Perangkat Keras Sistem Tertanam</a></li>
<li><a href="../id477518/index.html">Mikroarsitektur tulang sebagai dasar untuk bahan ultralight dan tahan lama</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>