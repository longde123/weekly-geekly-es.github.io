<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ™†ğŸ¿ ğŸ§–ğŸ¿ â¸ï¸ Aplikasi PentQL dengan GraphQL ğŸ¤œğŸ» ğŸ‘¨ğŸ½â€ğŸ”¬ ğŸ¥‡</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Baru-baru ini, GraphQL semakin populer, dan dengan itu semakin menarik minat para pakar keamanan informasi. Teknologi ini digunakan oleh perusahaan-pe...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Aplikasi PentQL dengan GraphQL</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/dsec/blog/444708/"><img src="https://habrastorage.org/webt/nc/28/f2/nc28f2sderdsdwypyfdpksfbe6e.jpeg"><br><br>  Baru-baru ini, GraphQL semakin populer, dan dengan itu semakin menarik minat para pakar keamanan informasi.  Teknologi ini digunakan oleh perusahaan-perusahaan seperti: Facebook, Twitter, PayPal, Github, dan lainnya, yang berarti sudah saatnya mencari cara untuk menguji API semacam itu.  Pada artikel ini, kita akan berbicara tentang prinsip-prinsip bahasa permintaan ini dan arah untuk menguji penetrasi aplikasi dengan GraphQL. <br><a name="habracut"></a><br>  Mengapa Anda perlu tahu GraphQL?  Bahasa permintaan ini secara aktif berkembang dan semakin banyak perusahaan yang menemukan penggunaan praktis untuk itu.  Dalam kerangka program Bug Bounty, popularitas bahasa ini juga berkembang, contoh menarik dapat dilihat di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> , di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> dan di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> . <br><br>  <b>Persiapan</b> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Situs uji</a> tempat Anda akan menemukan sebagian besar contoh dalam artikel ini. <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Daftar</a> dengan aplikasi yang juga dapat Anda gunakan untuk belajar. <br><br>  Untuk berinteraksi dengan berbagai API, lebih baik menggunakan GraphQL IDE: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Graphql-playground</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Altair</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Insomnia</a> </li></ul><br>  Kami merekomendasikan IDE terakhir: Insomnia memiliki antarmuka yang mudah dan sederhana, ada banyak pengaturan dan pelengkapan otomatis bidang permintaan. <br><br>  Sebelum melanjutkan langsung ke metode umum analisis keamanan aplikasi dengan GraphQL, kami mengingat konsep dasar. <br><br><h4>  Apa itu GraphQL? </h4><br>  GraphQL adalah bahasa permintaan API yang dirancang untuk memberikan alternatif REST yang lebih efisien, kuat, dan fleksibel.  Ini didasarkan pada pengambilan sampel data deklaratif, yaitu, klien dapat menentukan dengan tepat data apa yang dibutuhkan dari API.  Alih-alih beberapa titik akhir API (REST), GraphQL menyediakan titik akhir tunggal yang menyediakan klien dengan data yang diminta. <br><br><h4>  Perbedaan utama antara REST dan GraphQL </h4><br>  Biasanya di REST API Anda perlu mendapatkan informasi dari titik akhir yang berbeda.  Di GraphQL, untuk mendapatkan data yang sama, Anda harus membuat satu kueri yang menunjukkan data yang ingin Anda terima. <br><br><img src="https://habrastorage.org/webt/al/ci/gd/alcigdciygrluisjws8skolz7dk.png"><br><br>  REST API memberikan informasi yang akan dimasukkan pengembang ke dalam API, yaitu, jika Anda perlu mendapatkan informasi lebih banyak atau lebih sedikit daripada yang disarankan oleh API, maka tindakan tambahan akan diperlukan.  Sekali lagi, GraphQL menyediakan persis informasi yang diminta. <br>  Tambahan yang bermanfaat adalah GraphQL memiliki skema yang menjelaskan bagaimana dan data apa yang dapat diterima klien. <br><br><h4>  Jenis-jenis Pertanyaan </h4><br>  Ada 3 jenis pertanyaan utama di GraphQL: <br><br><ul><li>  Pertanyaan </li><li>  Mutasi </li><li>  Berlangganan </li></ul><br>  <b>Pertanyaan</b> <br><br>  Kueri kueri digunakan untuk mengambil / membaca data dalam suatu skema. <br><br>  Contoh permintaan seperti itu: <br><br><pre><code class="xml hljs">query { allPersons { name } }</code> </pre> <br>  Dalam permintaan, kami menunjukkan bahwa kami ingin mendapatkan nama semua pengguna.  Selain namanya, kita dapat menentukan bidang lain: <b>usia</b> , <b>id</b> , <b>posting</b> , dll. Untuk mengetahui bidang mana yang bisa kita dapatkan, Anda perlu menekan Ctrl + Spasi.  Dalam contoh ini, kami meneruskan parameter yang digunakan aplikasi untuk mengembalikan dua catatan pertama: <br><br><pre> <code class="xml hljs">query { allPersons(first: 2) { name } }</code> </pre> <br>  <b>Mutasi</b> <br><br>  Jika jenis permintaan diperlukan untuk membaca data, jenis mutasi diperlukan untuk menulis, menghapus dan memodifikasi data dalam GraphQL. <br><br>  Contoh permintaan seperti itu: <br><br><pre> <code class="xml hljs">mutation { createPerson(name:"Bob", age: 37) { id name age } }</code> </pre> <br>  Dalam permintaan ini, kami membuat pengguna dengan nama Bob dan usia 37 (parameter ini diteruskan sebagai argumen), dalam lampiran (kurung keriting) kami menunjukkan data apa yang ingin kami terima dari server setelah membuat pengguna.  Ini diperlukan untuk memahami bahwa permintaan itu berhasil, serta untuk mendapatkan data yang dihasilkan server secara independen, seperti <b>id</b> . <br><br>  <b>Berlangganan</b> <br><br>  Jenis lain dari permintaan dalam GraphQL adalah berlangganan.  Diperlukan untuk memberi tahu pengguna tentang segala perubahan yang terjadi dalam sistem.  Ia bekerja seperti ini: klien berlangganan ke beberapa acara, setelah itu koneksi dibuat dengan server (biasanya melalui WebSocket), dan ketika acara ini terjadi, server mengirimkan pemberitahuan kepada klien tentang koneksi yang dibuat. <br><br>  Contoh: <br><br><pre> <code class="xml hljs">subscription { newPerson { name age id } }</code> </pre> <br>  Ketika Orang baru dibuat, server akan mengirim informasi ke klien.  Kehadiran permintaan berlangganan di skema kurang umum daripada permintaan dan mutasi. <br><br>  Perlu dicatat bahwa semua kemampuan untuk kueri, mutasi, dan berlangganan dibuat dan dikonfigurasikan oleh pengembang API tertentu. <br><br><h4>  Opsional </h4><br>  Dalam praktiknya, pengembang sering menggunakan alias dan OperationName dalam kueri untuk kejelasan. <br><br>  <b>Alias</b> <br><br>  GraphQL untuk kueri menyediakan fitur alias, yang dapat membuatnya lebih mudah untuk memahami apa yang diminta klien. <br><br>  Misalkan kita memiliki kueri formulir: <br><br><pre> <code class="xml hljs">{ Person(id: 123) { age } }</code> </pre> <br>  yang akan menampilkan nama pengguna dengan <b>id</b> 123. Biarkan nama pengguna ini menjadi Vasya. <br><br>  Sehingga lain kali Anda tidak akan mengacaukan tampilan permintaan ini, Anda dapat melakukannya seperti ini: <br><br><pre> <code class="xml hljs">{ Vasya: Person(id: 123) { age } }</code> </pre> <br>  <b>Nama operasi</b> <br><br>  Selain alias, GraphQL menggunakan OperationName: <br><br><pre> <code class="xml hljs">query gettingAllPersons { allPersons { name age } }</code> </pre> <br>  OperationName diperlukan untuk menjelaskan apa yang dilakukan permintaan. <br><br><h3>  Pentest </h3><br>  Setelah kami menemukan dasar-dasarnya, kami langsung menuju ke pentest.  Bagaimana memahami bahwa suatu aplikasi menggunakan GraphQL?  Berikut adalah contoh permintaan yang memiliki permintaan GraphQL: <br><br><pre> <code class="xml hljs">POST /simple/v1/cjp70ml3o9tpa0184rtqs8tmu/ HTTP/1.1 Host: api.graph.cool User-Agent: Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:65.0) Gecko/20100101 Firefox/65.0 Accept: */* Accept-Language: ru-RU,ru;q=0.8,en-US;q=0.5,en;q=0.3 Accept-Encoding: gzip, deflate Referer: https://api.graph.cool/simple/v1/cjp70ml3o9tpa0184rtqs8tmu/ content-type: application/json Origin: https://api.graph.cool Content-Length: 139 Connection: close {"operationName":null,"variables":{},"query":"{\n __schema {\n mutationType {\n fields {\n name\n }\n }\n }\n}\n"}</code> </pre> <br>  Beberapa parameter yang dapat Anda pahami bahwa ini adalah GraphQL, dan bukan sesuatu yang lain: <br><br><ul><li>  di badan permintaan ada kata-kata: __schema, bidang, operationName, mutasi, dll; </li><li>  di badan permintaan ada banyak karakter "\ n".  Seperti yang ditunjukkan oleh latihan, mereka dapat dihapus untuk membuatnya lebih mudah untuk membaca permintaan; </li><li>  sering kali cara mengirim permintaan ke server: â„graphql </li></ul><br>  Hebat, ditemukan dan diidentifikasi.  Tetapi di <s>mana harus memasukkan tanda kutip</s> bagaimana menemukan apa yang perlu kita kerjakan?  Introspeksi akan datang untuk menyelamatkan. <br><br><h4>  Introspeksi diri </h4><br>  GraphQL menyediakan skema introspeksi, mis.  sebuah skema yang menggambarkan data yang bisa kita dapatkan.  Berkat ini, kami dapat mengetahui permintaan apa yang ada, argumen apa yang dapat / harus disampaikan kepada mereka, dan banyak lagi.  Perhatikan bahwa dalam beberapa kasus, pengembang sengaja tidak mengizinkan kemungkinan introspeksi aplikasi mereka.  Namun, sebagian besar masih menyisakan kemungkinan ini. <br><br>  Pertimbangkan contoh dasar kueri. <br><br>  <b>Contoh 1. Mendapatkan semua jenis permintaan</b> <br><br><pre> <code class="xml hljs">query { __schema { types { name fields { name } } } }</code> </pre> <br>  Kami membentuk kueri kueri, menunjukkan bahwa kami ingin menerima data pada __schema, dan di dalamnya ketik, nama dan bidangnya.  Dalam GraphQL, ada nama-nama variabel layanan: __schema, __typename, __type. <br><br>  Dalam jawabannya, kami akan menerima semua jenis permintaan, nama dan bidangnya yang ada dalam skema. <br><br>  <b>Contoh 2. Memperoleh bidang untuk jenis permintaan tertentu (kueri, mutasi, deskripsi)</b> <br><br><pre> <code class="xml hljs">query { __schema { queryType { fields { name args { name } } } } }</code> </pre> <br>  Jawaban atas permintaan ini adalah semua kemungkinan permintaan yang dapat kami lakukan pada skema untuk menerima data (jenis kueri), dan kemungkinan / diperlukan argumen untuknya.  Untuk beberapa pertanyaan, menentukan argumen diperlukan.  Jika Anda menjalankan permintaan seperti itu tanpa menentukan argumen yang diperlukan, server harus menampilkan pesan kesalahan yang harus Anda tentukan.  Alih-alih queryType, kita dapat mengganti mutationType dan berlanggananType untuk mendapatkan semua kemungkinan permintaan untuk mutasi dan langganan. <br><br>  <b>Contoh 3. Mendapatkan informasi tentang jenis permintaan tertentu</b> <br><br><pre> <code class="xml hljs">query { __type(name: "Person") { fields { name } } }</code> </pre> <br>  Berkat kueri ini, kami mendapatkan semua bidang untuk tipe Orang.  Sebagai argumen, alih-alih Orang, kami dapat memberikan nama permintaan lainnya. <br><br>  Sekarang kita dapat mengetahui struktur umum aplikasi yang sedang diuji, mari kita tentukan apa yang kita cari. <br><br>  <b>Pengungkapan informasi</b> <br><br>  Paling sering, aplikasi yang menggunakan GraphQL terdiri dari banyak bidang dan jenis kueri, dan, seperti banyak orang tahu, semakin kompleks dan semakin besar aplikasi, semakin sulit untuk mengkonfigurasi dan memantau keamanannya.  Itulah sebabnya dengan introspeksi yang cermat Anda dapat menemukan sesuatu yang menarik, misalnya: nama lengkap pengguna, nomor telepon mereka, dan data penting lainnya.  Oleh karena itu, jika Anda ingin menemukan sesuatu seperti ini, maka kami sarankan Anda memeriksa semua bidang dan argumen aplikasi yang mungkin.  Jadi, sebagai bagian dari pentest di salah satu aplikasi, data pengguna ditemukan: nama, nomor telepon, tanggal lahir, beberapa data kartu, dll. <br><br>  Contoh: <br><br><pre> <code class="xml hljs">query { User(id: 1) { name birth phone email password } }</code> </pre><br>  Melalui nilai-nilai id, kita dapat memperoleh informasi tentang pengguna lain (dan mungkin tidak, jika semuanya dikonfigurasi dengan benar). <br><br>  <b>Suntikan</b> <br><br>  Tak perlu dikatakan, hampir di mana-mana di mana ada pekerjaan dengan sejumlah besar data, ada database?  Dan di mana ada database - mungkin ada injeksi SQL, injeksi NoSQL dan jenis injeksi lainnya. <br><br>  Contoh: <br><br><pre> <code class="xml hljs">mutation { createPerson(name:"Vasya'--+") { name } }</code> </pre> <br>  Berikut ini adalah injeksi SQL dasar dalam argumen kueri. <br><br>  <b>Bypass otorisasi</b> <br>  Katakanlah kita dapat membuat pengguna: <br><br><pre> <code class="xml hljs">mutation { createPerson(username:"Vasya", password: "Qwerty1") { } }</code> </pre> <br>  Dengan asumsi ada parameter tertentu isAdmin di handler di server, kami dapat mengirim permintaan formulir: <br><br><pre> <code class="xml hljs">mutation { createPerson(username:"Vasya", password: "Qwerty1", isAdmin: True) { } }</code> </pre> <br>  Dan menjadikan Vasya pengguna sebagai administrator. <br><br><h4>  Dos </h4><br>  Selain kenyamanan yang dinyatakan, GraphQL memiliki kelemahan keamanannya sendiri. <br><br>  Pertimbangkan sebuah contoh: <br><br><pre> <code class="xml hljs">query { Person { posts { author { posts { author { posts { author ... } } } } } } }</code> </pre> <br>  Seperti yang Anda lihat, kami membuat subquery loop.  Dengan sejumlah besar investasi semacam itu, misalnya, 50 ribu, kami dapat mengirim permintaan yang akan diproses oleh server untuk waktu yang sangat lama atau "menjatuhkan" semuanya.  Alih-alih memproses permintaan yang valid, server akan sibuk membongkar sarang besar dari permintaan dummy. <br><br>  Selain bersarang besar, kueri sendiri bisa "berat" - ini adalah saat kueri memiliki banyak bidang dan lampiran internal.  Permintaan seperti itu juga dapat menyebabkan kesulitan dalam pemrosesan di server. <br><br><h3>  Kesimpulan </h3><br>  Jadi, kami memeriksa prinsip-prinsip dasar pengujian penetrasi aplikasi dengan GraphQL.  Kami harap Anda telah mempelajari sesuatu yang baru dan bermanfaat untuk diri Anda sendiri.  Jika Anda tertarik dengan topik ini, dan ingin mempelajarinya lebih dalam, kami merekomendasikan sumber daya berikut: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">www.howtographql.com</a> adalah sumber utama untuk belajar dari awal.  Selain teori, itu juga berisi praktik. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">www.graphql.com</a> juga merupakan situs yang bagus untuk mempelajari teknologi ini. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">www.howtographql.com/advanced/4-security</a> - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">GraphQL</a> Security. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">AppSecCali 2019 - Pandangan Penyerang tentang Serverless dan Aplikasi GraphQL</a> - video yang bagus dengan contoh spesifik. </li></ul><br>  Dan jangan lupa: latihan menjadi sempurna.  Semoga beruntung </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id444708/">https://habr.com/ru/post/id444708/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id444694/index.html">Seperti yang kami prediksi arus keluar, mendekatinya sebagai bencana alam</a></li>
<li><a href="../id444696/index.html">Tingkatkan kepadatan kontainer pada suatu simpul menggunakan teknologi PFCACHE</a></li>
<li><a href="../id444700/index.html">Basis data acak. Kualitas Data Oracle Enterprise - Perisai dan Pedang untuk Penyimpanan Perusahaan</a></li>
<li><a href="../id444704/index.html">Peluang nanoCAD SPDS Situs konstruksi dalam proyek konstruksi dan rekonstruksi dalam kondisi sempit</a></li>
<li><a href="../id444706/index.html">Foto Facebook 3D Di Dalam: Parallax Shaders</a></li>
<li><a href="../id444710/index.html">Memahami Protokol Konsensus Stellar</a></li>
<li><a href="../id444712/index.html">"Sikap atipikal terhadap keuangan" - bagaimana jika karyawan sendiri yang akan mengelola pendapatan. Percakapan dengan Flant</a></li>
<li><a href="../id444714/index.html">Bagaimana kami melakukan overclock CAD COMPASS-3D â†’ Bagian 1</a></li>
<li><a href="../id444716/index.html">Ponsel Samsung dengan layar lipat sebesar $ 2000 menampilkan lipatan</a></li>
<li><a href="../id444718/index.html">Amatir holografi - awal dari perjalanan</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>