<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>✒️ 🤹🏽 🎆 Pengantar Kubernetes untuk pengguna VMware. Bagian 1. Teori 🥊 📪 🤚🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ini adalah bagian kedua dari Kubernet saya di seri posting Enterprise . Seperti yang saya sebutkan di posting terakhir saya, sangat penting ketika pin...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Pengantar Kubernetes untuk pengguna VMware. Bagian 1. Teori</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/dataline/blog/436028/">  Ini adalah bagian kedua dari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Kubernet</a> saya <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">di</a> seri posting <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Enterprise</a> .  Seperti yang saya sebutkan di posting terakhir saya, sangat penting ketika pindah ke <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">"Panduan Desain dan Implementasi" bahwa</a> setiap orang berada pada tingkat pemahaman yang sama tentang Kubernetes (K8s). <br><br>  Saya tidak ingin menggunakan pendekatan tradisional di sini untuk menjelaskan arsitektur dan teknologi Kubernetes, tapi saya akan menjelaskan semuanya melalui perbandingan dengan platform vSphere, yang Anda, sebagai pengguna VMware, kenal.  Ini akan memungkinkan Anda untuk mengatasi kebingungan dan keparahan pemahaman Kubernetes.  Saya menggunakan pendekatan ini di dalam VMware untuk memperkenalkan Kubernetes ke audiens pendengar yang berbeda, dan itu membuktikan bahwa itu bekerja dengan baik dan membantu orang terbiasa dengan konsep-konsep kunci lebih cepat. <br><br>  Catatan penting sebelum kita mulai.  Saya tidak menggunakan perbandingan ini untuk membuktikan persamaan atau perbedaan antara vSphere dan Kubernetes.  Baik itu, dan yang lain, pada dasarnya, adalah sistem terdistribusi, dan, oleh karena itu, harus memiliki kesamaan dengan sistem serupa lainnya.  Oleh karena itu, pada akhirnya, saya mencoba untuk memperkenalkan teknologi yang luar biasa seperti Kubernetes kepada komunitas penggunanya yang luas. <br><img src="https://habrastorage.org/webt/2x/8j/gn/2x8jgnlfylvf_sfzkylizlg3huk.png"><a name="habracut"></a><br><br><h3>  Sedikit sejarah </h3><br>  Membaca posting ini melibatkan mengenal wadah.  Saya tidak akan menjelaskan konsep dasar wadah, karena ada banyak sumber daya yang membicarakan hal ini.  Sangat sering berbicara dengan pelanggan, saya melihat mereka tidak dapat memahami mengapa kontainer menangkap industri kami dan menjadi sangat populer dalam waktu singkat.  Untuk menjawab pertanyaan ini, saya akan berbicara tentang pengalaman praktis saya dalam memahami perubahan yang terjadi di industri kami. <br><br>  Sebelum menjelajahi dunia telekomunikasi, saya adalah seorang pengembang Web (2003). <br><br>  Ini adalah pekerjaan bergaji kedua saya setelah saya bekerja sebagai insinyur jaringan / administrator (saya tahu bahwa saya adalah dongkrak dari semua perdagangan).  Saya mengembangkan PHP.  Saya mengembangkan semua jenis aplikasi, mulai dari yang kecil yang digunakan majikan saya, berakhir dengan aplikasi pemungutan suara profesional untuk program televisi, dan bahkan aplikasi telekomunikasi yang berinteraksi dengan hub VSAT dan sistem satelit.  Hidup itu hebat, dengan pengecualian satu rintangan utama yang diketahui setiap pengembang, itu kecanduan. <br><br>  Pada awalnya saya mengembangkan aplikasi di laptop saya, menggunakan sesuatu seperti tumpukan LAMP, ketika itu bekerja dengan baik di laptop saya, saya mengunduh kode sumber ke server host (semua orang ingat RackShack?) Atau ke server pribadi pelanggan.  Anda dapat membayangkan bahwa begitu saya melakukan ini, aplikasi macet dan tidak berfungsi di server ini.  Alasan untuk ini adalah kecanduan.  Server memiliki versi lain dari perangkat lunak (Apache, PHP, MySQL, dll.) Daripada yang digunakan oleh saya di laptop.  Jadi saya perlu menemukan cara untuk memperbarui versi perangkat lunak pada server jauh (ide buruk) atau menulis ulang kode pada laptop saya untuk mencocokkan versi pada server jauh (ide terburuk).  Itu adalah mimpi buruk, kadang-kadang aku membenci diriku sendiri dan bertanya-tanya mengapa ini adalah bagaimana aku mencari nafkah. <br><br>  10 tahun telah berlalu, perusahaan Docker muncul.  Sebagai konsultan VMware di Professional Services (2013), saya mendengar tentang Docker, dan izinkan saya mengatakan bahwa saya tidak dapat memahami teknologi ini pada masa itu.  Saya terus mengatakan sesuatu seperti: mengapa menggunakan wadah jika ada mesin virtual.  Mengapa menyerah teknologi penting seperti vSphere HA, DRS, atau vMotion karena keunggulan aneh seperti peluncuran kontainer instan atau menghilangkan overhead hypervisor.  Bagaimanapun, semua orang bekerja dengan mesin virtual dan bekerja dengan sempurna.  Singkatnya, saya melihatnya dari segi infrastruktur. <br><br>  Tapi kemudian saya mulai melihat dari dekat dan saya sadar.  Segala sesuatu yang terkait dengan Docker terkait dengan pengembang.  Baru mulai berpikir sebagai pengembang, saya segera menyadari bahwa jika saya memiliki teknologi ini pada tahun 2003, saya dapat mengemas semua dependensi saya.  Aplikasi Web saya bisa berfungsi terlepas dari server yang digunakan.  Selain itu, tidak perlu mengunduh kode sumber atau mengkonfigurasi sesuatu.  Anda cukup "mengemas" aplikasi saya ke dalam gambar dan meminta pelanggan mengunduh dan menjalankan gambar ini.  Ini adalah impian pengembang Web! <br><br>  Semua ini bagus.  Docker memecahkan masalah interaksi dan pengemasan yang sangat besar, tetapi bagaimana selanjutnya?  Bisakah saya, sebagai klien korporat, mengelola aplikasi ini saat melakukan penskalaan?  Saya masih ingin menggunakan HA, DRS, vMotion dan DR.  Docker memecahkan masalah pengembang saya dan menciptakan sejumlah masalah bagi administrator saya (tim DevOps).  Mereka membutuhkan platform untuk meluncurkan kontainer, sama seperti yang untuk meluncurkan mesin virtual.  Dan kami kembali lagi ke awal. <br><br>  Tapi kemudian Google muncul, memberi tahu dunia tentang penggunaan kontainer selama bertahun-tahun (pada kenyataannya, kontainer diciptakan oleh Google: cgroups) dan metode yang benar untuk menggunakannya, melalui platform yang mereka sebut Kubernetes.  Kemudian mereka membuka kode sumber untuk Kubernetes.  Disajikan ke komunitas Kubernetes.  Dan itu mengubah segalanya lagi. <br><br><h3>  Memahami Kubernet versus vSphere </h3><br>  Jadi, apa itu Kubernet?  Sederhananya, Kubernetes untuk wadah sama dengan vSphere untuk mesin virtual di pusat data modern.  Jika Anda menggunakan VMware Workstation di awal tahun 2000-an, Anda tahu bahwa solusi ini dianggap serius sebagai solusi untuk pusat data.  Ketika VI / vSphere dengan host vCenter dan ESXi muncul, dunia mesin virtual berubah secara dramatis.  Kubernetes melakukan hal yang sama hari ini dengan dunia kontainer, menghadirkan kemampuan untuk meluncurkan dan mengelola kontainer dalam produksi.  Dan itulah sebabnya kami akan mulai membandingkan vSphere berdampingan dengan Kubernetes untuk menjelaskan perincian sistem terdistribusi ini untuk memahami fungsi dan teknologinya. <br><img src="https://habrastorage.org/webt/2l/ke/vg/2lkevgzxfllfuhfd29vtofvm4ii.png"><br><br><h3>  Tinjauan Sistem </h3><br>  Seperti di vSphere ada host vCenter dan ESXi dalam konsep Kubernet ada Master dan Node.  Dalam konteks ini, Master di K8s adalah setara dengan vCenter, dalam arti bahwa itu adalah Management Plane dari sistem terdistribusi.  Ini juga merupakan titik masuk untuk API yang berinteraksi dengan Anda ketika mengelola beban kerja Anda.  Dengan cara yang sama, K8s Nodes bekerja sebagai sumber daya komputasi, mirip dengan host ESXi.  Ini pada mereka bahwa Anda menjalankan beban kerja (dalam kasus K8, kami menyebutnya Pods).  Node dapat berupa mesin virtual atau server fisik.  Tentu saja, dengan vSphere ESXi, host harus selalu bersifat fisik. <br><img src="https://habrastorage.org/webt/to/va/hq/tovahqozye9ym14sljwpbilywto.png"><br><br>  Anda dapat melihat bahwa K8 memiliki toko nilai kunci yang disebut "etcd".  Penyimpanan ini mirip dengan database vCenter, tempat Anda menyimpan konfigurasi kluster yang diinginkan yang ingin Anda patuhi. <br><br>  Adapun perbedaan: pada Master K8 Anda juga dapat menjalankan beban kerja, tetapi pada vCenter Anda tidak bisa.  vCenter adalah Alat Virtual yang didedikasikan untuk manajemen saja.  Dalam kasus K8, Master dianggap sebagai sumber daya komputasi, tetapi menjalankan aplikasi Enterprise di atasnya bukan ide yang baik. <br><br>  Jadi bagaimana itu akan terlihat dalam kenyataan?  Anda terutama akan menggunakan CLI untuk berinteraksi dengan Kubernetes (tetapi GUI masih merupakan opsi yang sangat layak).  Tangkapan layar di bawah ini menunjukkan bahwa saya menggunakan mesin Windows untuk terhubung ke cluster Kubernetes saya melalui baris perintah (saya menggunakan cmder jika Anda tertarik).  Dalam tangkapan layar saya memiliki satu simpul Master dan 4 simpul.  Mereka bekerja di bawah kendali K8s v1.6.5, dan sistem operasi (OS) Ubuntu 16.04 diinstal pada node.  Pada saat menulis posting ini, kami terutama tinggal di dunia Linux, di mana Master dan Node selalu menjalankan distribusi Linux. <br><br><img src="https://habrastorage.org/webt/gm/qn/gj/gmqngjq1mraqces6uo1sectxm6i.png"><br>  <i>Manajemen cluster K8 melalui CLI dan GUI.</i> <br><br><h3>  Faktor Bentuk Beban Kerja </h3><br>  Di vSphere, mesin virtual adalah batas logis dari sistem operasi.  Di Kubernetes, Pods adalah batas kontainer, seperti host ESXi, yang dapat menjalankan beberapa mesin virtual secara bersamaan.  Setiap Node dapat menjalankan beberapa Pod.  Setiap Pod menerima alamat IP yang dapat dirutekan, seperti mesin virtual, agar Pods dapat saling berkomunikasi. <br><br>  Di vSphere, aplikasi berjalan di dalam OS, dan di Kubernetes, aplikasi berjalan di dalam wadah.  Mesin virtual hanya dapat bekerja dengan satu OS pada satu waktu, dan Pod dapat menjalankan beberapa wadah. <br><img src="https://habrastorage.org/webt/hv/cv/9b/hvcv9bj4gw6wsunhhqeqvvfx5d4.png"><br><br>  Ini adalah bagaimana Anda dapat membuat daftar Pods di dalam cluster K8s menggunakan alat kubectl melalui CLI, memeriksa fungsionalitas Pods, usia mereka, alamat IP dan Node yang sedang mereka kerjakan. <br><img src="https://habrastorage.org/webt/0u/qj/_0/0uqj_0gl0qmxiqbby9gd8ln98nc.png"><br><br><h3>  Manajemen </h3><br>  Jadi, bagaimana kita mengelola Master, Nodes, dan Pods kita?  Di vSphere, kami menggunakan klien Web untuk mengelola sebagian besar (jika tidak semua) komponen infrastruktur virtual kami.  Untuk Kubernetes, sama halnya, menggunakan Dashboard.  Ini adalah portal Web berbasis GUI yang baik yang dapat Anda akses melalui browser Anda dengan cara yang sama seperti dengan klien Web vSphere.  Dari bagian sebelumnya, Anda dapat melihat bahwa Anda dapat mengelola kluster K8s Anda menggunakan perintah kubeclt dari CLI.  Itu selalu bisa diperdebatkan di mana Anda akan menghabiskan sebagian besar waktu Anda di CLI atau di Dashboard grafis.  Karena yang terakhir ini menjadi alat yang semakin kuat setiap hari (Anda dapat melihat video ini dengan pasti).  Secara pribadi, saya berpikir bahwa Dashboard sangat mudah untuk memantau status dengan cepat atau menampilkan rincian berbagai komponen K8, tanpa harus memasukkan perintah panjang di CLI.  Anda akan menemukan keseimbangan di antara mereka secara alami. <br><br><img src="https://habrastorage.org/webt/hi/hu/cj/hihucj_bhrydsrgy0ad5xifupuc.png"><br><br><h3>  Konfigurasi </h3><br>  Salah satu konsep yang sangat penting di Kubernetes adalah kondisi konfigurasi yang diinginkan.  Anda menyatakan apa yang Anda inginkan untuk hampir semua komponen Kubernetes melalui file YAML, dan Anda membuat semua ini menggunakan kubectl (atau melalui Dashboard grafis) sebagai keadaan yang Anda inginkan.  Mulai sekarang, Kubernetes akan selalu berusaha untuk menjaga lingkungan Anda dalam kondisi operasional tertentu.  Misalnya, jika Anda ingin memiliki 4 replika satu Pod, K8 akan terus memantau Pod ini, dan jika salah satu dari mereka meninggal atau Node yang berfungsi bermasalah, K8 akan pulih sendiri dan secara otomatis membuat ini. Pod di tempat lain. <br><br>  Kembali ke file konfigurasi YAML kami, Anda dapat menganggapnya sebagai file .VMX untuk mesin virtual atau deskriptor .OVF untuk Peralatan Virtual yang ingin Anda gunakan ke vSphere.  File-file ini menentukan konfigurasi dari beban kerja / komponen yang ingin Anda jalankan.  Tidak seperti file VMX / OVF, yang eksklusif untuk VMs / Peralatan virtual, file konfigurasi YAML digunakan untuk mendefinisikan komponen K8, seperti ReplicaSets, Layanan, Penyebaran, dll.  Pertimbangkan ini di bagian berikut. <br><img src="https://habrastorage.org/webt/qg/2w/np/qg2wnppfqeu9ksyev67haaiz19m.png"><br><br><h3>  Cluster virtual </h3><br>  Di vSphere, kami memiliki host ESXi fisik yang secara logis dikelompokkan ke dalam kelompok.  Cluster ini dapat dibagi menjadi cluster virtual lainnya yang disebut "Resource Pools".  “Kelompok” ini terutama digunakan untuk membatasi sumber daya.  Di Kubernetes, kami memiliki sesuatu yang sangat mirip.  Kami menyebutnya "Namespaces", mereka juga dapat digunakan untuk memberikan batas sumber daya, yang akan tercermin pada bagian selanjutnya.  Namun, paling sering "Ruang nama" digunakan sebagai alat multi-tenancy untuk aplikasi (atau pengguna, jika Anda menggunakan kluster K8 yang umum).  Ini juga salah satu opsi yang dapat digunakan untuk melakukan segmentasi jaringan menggunakan NSX-T.  Pertimbangkan ini dalam publikasi berikut. <br><img src="https://habrastorage.org/webt/n6/ve/kr/n6vekro9uz1bx9i_0kqgxquyduw.png"><br><br><h3>  Manajemen sumber daya </h3><br>  Seperti yang saya sebutkan di bagian sebelumnya, Namespace di Kubernetes umumnya digunakan sebagai sarana segmentasi.  Penggunaan Namespaces lainnya adalah alokasi sumber daya.  Opsi ini disebut "Sumber Daya Kuota".  Sebagai berikut dari bagian sebelumnya, definisi ini terjadi dalam konfigurasi file YAML, di mana status yang diinginkan dideklarasikan.  Di vSphere, seperti yang dapat dilihat pada tangkapan layar di bawah ini, kami menentukan ini dari pengaturan Resource Pools. <br><img src="https://habrastorage.org/webt/jq/oy/nl/jqoynlerkguited5ozdgsndtj4w.png"><br><br><h3>  Identifikasi beban kerja </h3><br>  Ini cukup sederhana dan hampir sama untuk vSphere dan Kubernetes.  Dalam kasus pertama, kami menggunakan konsep Tag untuk mendefinisikan (atau mengelompokkan) beban kerja yang serupa, dan yang kedua kami menggunakan istilah "Label".  Dalam kasus Kubernetes, identifikasi beban kerja adalah wajib. <br><img src="https://habrastorage.org/webt/j_/2s/go/j_2sgoekii7mwswdmhspterznoq.png"><br><br><h3>  Reservasi </h3><br>  Sekarang benar-benar menyenangkan.  Jika Anda adalah penggemar berat vSphere FT, seperti saya, Anda akan menyukai fitur ini di Kubernetes, meskipun ada beberapa perbedaan dalam kedua teknologi tersebut.  Di vSphere, ini adalah mesin virtual dengan instance shadow yang berjalan pada host yang berbeda.  Kami merekam instruksi pada mesin virtual utama dan memutarnya di mesin virtual shadow.  Jika mesin utama berhenti bekerja, mesin virtual bayangan segera hidup.  Kemudian vSphere mencoba menemukan host ESXi lain untuk membuat contoh bayangan baru dari mesin virtual untuk mempertahankan redundansi yang sama.  Di Kubernetes, kami memiliki sesuatu yang sangat mirip.  ReplicaSets adalah jumlah yang Anda tentukan untuk menjalankan beberapa instance Pods.  Jika satu Pod gagal, instance lain tersedia untuk melayani lalu lintas.  Pada saat yang sama, K8 akan mencoba meluncurkan Pod baru pada Node yang tersedia untuk mempertahankan status konfigurasi yang diinginkan.  Perbedaan utama, seperti yang mungkin telah Anda perhatikan, adalah bahwa dalam kasus K8, Pod selalu berfungsi dan melayani lalu lintas.  Mereka bukan beban kerja bayangan. <br><img src="https://habrastorage.org/webt/29/u-/sd/29u-sdyxbg1n0qdzwpkwjmcyuxe.png"><br><br><h3>  Load balancing </h3><br>  Meskipun ini mungkin bukan fungsi bawaan di vSphere, sangat, sangat sering diperlukan untuk menjalankan load balancers pada platform.  Di dunia vSphere, ada penyeimbang beban virtual atau fisik untuk mendistribusikan lalu lintas jaringan antara beberapa mesin virtual.  Mungkin ada banyak mode konfigurasi yang berbeda, tetapi mari kita asumsikan bahwa yang kami maksud adalah konfigurasi Satu-Bersenjata.  Dalam hal ini, Anda menyeimbangkan beban lalu lintas Timur-Barat pada mesin virtual Anda. <br><br>  Demikian pula, Kubernetes memiliki konsep "Layanan".  Layanan dalam K8 juga dapat digunakan dalam mode konfigurasi yang berbeda.  Mari kita pilih konfigurasi "ClusterIP 'untuk membandingkannya dengan Penyeimbang Beban Satu-Bersenjata.  Dalam hal ini, Layanan di K8 akan memiliki alamat IP virtual (VIP), yang selalu statis dan tidak berubah.  VIP ini akan mendistribusikan lalu lintas di antara beberapa Pod.  Ini sangat penting di dunia Kubernetes, di mana Pods bersifat sementara, Anda kehilangan alamat IP Pod saat ia mati atau dihapus.  Karena itu, Anda harus selalu memberikan VIP statis. <br><br>  Seperti yang telah saya sebutkan, Layanan memiliki banyak konfigurasi lain, misalnya, “NodePort”, di mana Anda menetapkan port pada level Node dan kemudian melakukan terjemahan port-address-translation untuk Pods.  Ada juga "LoadBalancer" tempat Anda menjalankan instance Load Balancer dari pihak ketiga atau penyedia cloud. <br><img src="https://habrastorage.org/webt/s9/4g/my/s94gmy5frfcjkyxeywlp3gcwtkm.png"><br><br>  Kuberentes memiliki mekanisme penyeimbangan beban lain yang sangat penting yang disebut “Pengontrol Masuk”.  Anda dapat menganggapnya sebagai penyeimbang beban aplikasi in-line.  Gagasan utamanya adalah Ingress Controller (dalam bentuk Pod) akan diluncurkan dengan alamat IP yang terlihat dari luar.  Alamat IP ini mungkin memiliki sesuatu seperti catatan Wildcard DNS.  Ketika lalu lintas tiba di Pengontrol Ingress menggunakan alamat IP eksternal, itu memeriksa header dan menentukan menggunakan seperangkat aturan yang sebelumnya Anda atur di mana Pod nama ini milik.  Sebagai contoh: sphinx-v1.esxcloud.net akan diarahkan ke Layanan sphinx-svc-1, dan sphinx-v2.esxcloud.net akan diarahkan ke Layanan sphinx-svc2, dll. <br><img src="https://habrastorage.org/webt/fk/jr/t_/fkjrt_3ho51djc-euoshgcjccas.png"><br><br><h3>  Penyimpanan dan Jaringan </h3><br>  Penyimpanan dan jaringan adalah topik yang sangat, sangat luas dalam hal Kubernetes.  Hampir tidak mungkin untuk berbicara singkat tentang kedua topik ini di posting pengantar, tetapi saya akan segera berbicara secara rinci tentang berbagai konsep dan opsi untuk masing-masing topik ini.  Sementara itu, mari kita cepat melihat bagaimana tumpukan jaringan bekerja di Kubernetes, karena kita akan membutuhkannya di bagian selanjutnya. <br><br>  Kubernetes memiliki berbagai "Plugins" jaringan yang dapat Anda gunakan untuk mengonfigurasi jaringan Nodes dan Pods Anda.  Salah satu plugin yang umum adalah "kubenet," yang saat ini digunakan dalam mega-cloud seperti GCP dan AWS.  Di sini saya akan secara singkat berbicara tentang implementasi GCP, dan kemudian menunjukkan contoh praktis implementasi di GKE. <br><img src="https://habrastorage.org/webt/vc/vh/n6/vcvhn6ll9s46qdbwvurxheaykg8.png"><br><br>  Pada pandangan pertama, ini mungkin terlihat terlalu rumit, tetapi saya harap Anda dapat memahami semua ini pada akhir posting ini.  Pertama, kita melihat bahwa kita memiliki dua Kubernetes Node: Node 1 dan Node (m).  Setiap node memiliki antarmuka eth0, seperti mesin Linux lainnya.  Antarmuka ini memiliki alamat IP untuk dunia luar, dalam kasus kami, pada subnet 10.140.0.0/24.  Perangkat Hulu L3 bertindak sebagai Gerbang Default untuk merutekan lalu lintas kami.  Ini bisa berupa sakelar L3 di pusat data Anda atau router VPC di cloud, seperti GCP, seperti yang akan kita lihat nanti.  Apakah semuanya baik-baik saja? <br><br>  Lebih jauh kita melihat bahwa kita memiliki antarmuka Jembatan cbr0 di dalam node.  Antarmuka ini adalah Gateway Default untuk subnet IP 10.40.1.0/24 dalam kasus Node 1. Subnet ini ditugaskan oleh Kubernetes untuk setiap Node.  Node biasanya mendapatkan subnet / 24, tetapi Anda dapat mengubahnya menggunakan NSX-T (kami akan membahasnya di posting berikut).  Saat ini, subnet ini adalah dari mana kami akan mengeluarkan alamat IP untuk Pods.  Dengan cara ini, sembarang Pod di dalam Node 1 akan mendapatkan alamat IP dari subnet ini.  Dalam kasus kami, Pod 1 memiliki alamat IP 10.40.1.10.  Namun, Anda perhatikan bahwa ada dua wadah bersarang di Pod ini.  Kami telah mengatakan bahwa dalam satu Pod satu atau beberapa kontainer dapat diluncurkan, yang terkait erat satu sama lain dalam hal fungsi.  Inilah yang kita lihat pada gambar.  Kontainer 1 mendengarkan pada port 80, dan container 2 mendengarkan pada port 90. Kedua kontainer memiliki alamat IP yang sama 10.40.1.10, tetapi mereka tidak memiliki Networking Namespace.  Oke, lalu siapa yang memiliki tumpukan jaringan ini?  Sebenarnya ada wadah khusus yang disebut "Pause Container".  Diagram menunjukkan bahwa alamat IP-nya adalah alamat IP Pod untuk komunikasi dengan dunia luar.  Dengan demikian, Pause Container memiliki tumpukan jaringan ini, termasuk alamat IP 10.40.1.10 itu sendiri, dan, tentu saja, itu mengalihkan lalu lintas ke kontainer 1 ke port 80, dan juga mengalihkan lalu lintas ke kontainer 2 ke port 90. <br><br>  Sekarang Anda harus bertanya bagaimana lalu lintas dialihkan ke dunia luar?  Kami telah mengaktifkan Linux IP Forwarding untuk meneruskan lalu lintas dari cbr0 ke eth0.  Ini hebat, tetapi tidak jelas bagaimana perangkat L3 dapat mempelajari cara meneruskan lalu lintas ke tujuannya?  Dalam contoh khusus ini, kami tidak memiliki perutean dinamis untuk pengumuman jaringan ini.  Karena itu, kita harus memiliki semacam rute statis pada perangkat L3.  Untuk mencapai subnet 10.40.1.0/24, Anda perlu meneruskan lalu lintas ke alamat IP Node 1 (10.140.0.11) dan untuk mencapai subnet 10.40.2.0/24, harapan berikutnya adalah Node (m) dengan alamat IP 10.140.0.12. <br><br>  Semua ini hebat, tetapi ini adalah cara yang sangat tidak praktis untuk mengelola jaringan Anda.  Mendukung semua rute ini saat melakukan penskalaan kluster Anda akan menjadi mimpi buruk bagi administrator jaringan.  Itulah sebabnya beberapa solusi, seperti CNI (Container Network Interface) di Kuberentes, diperlukan untuk mengelola konektivitas jaringan.  NSX-T adalah salah satu solusi dengan fungsi yang sangat luas untuk interaksi dan keamanan jaringan. <br><br>  Ingatlah bahwa kami telah melihat plugin kubenet, bukan CNI.  Plugin kubenet adalah apa yang digunakan oleh Google Container Engine (GKE), dan cara mereka melakukannya sangat menyenangkan karena sepenuhnya ditentukan oleh perangkat lunak dan terotomatisasi di cloud mereka.  ,            GCP.     . <br><br><h3>  Apa selanjutnya </h3><br>     Kuberentes.        ,  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">   </a> . <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian kedua.</a> <br><br>     .    . <br>   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="></a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id436028/">https://habr.com/ru/post/id436028/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id436016/index.html">Asterisk Voice Recognition IVR - Cepat, Mudah, Gratis</a></li>
<li><a href="../id436020/index.html">Magento 2: mengimpor produk dari sumber eksternal</a></li>
<li><a href="../id436022/index.html">Bagaimana Kami Mengembangkan Librem 5 DevKit Sepenuhnya dalam Perangkat Lunak Bebas</a></li>
<li><a href="../id436024/index.html">Bagaimana tidak membuang sampah sembarangan di Jawa</a></li>
<li><a href="../id436026/index.html">Info Desk: "Internet Archive" - ​​proyek sejarah, misi dan anak perusahaan</a></li>
<li><a href="../id436032/index.html">Bereaksi Tutorial Bagian 9: Properti Komponen</a></li>
<li><a href="../id436036/index.html">Bisakah para peneliti kecerdasan buatan mempercayakannya pada tes pekerjaan mereka?</a></li>
<li><a href="../id436038/index.html">Suara kesunyian: berapa banyak gadget gila yang diperlukan untuk mencapai lingkungan yang optimal untuk tidur?</a></li>
<li><a href="../id436040/index.html">Optimasi grafis. Hull Cekung Menarik</a></li>
<li><a href="../id436042/index.html">Panel alat tambahan untuk pengembang di InterSystems IRIS</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>