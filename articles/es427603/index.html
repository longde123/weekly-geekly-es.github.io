<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üíø üîî üë®‚Äçüåæ C√≥mo finalmente comenzar a escribir pruebas y no arrepentirse üÖøÔ∏è ‚òùüèø üéûÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Al llegar a un nuevo proyecto, me encuentro regularmente con una de las siguientes situaciones: 



1. No hay pruebas en absoluto. 
2. Hay pocas prueb...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>C√≥mo finalmente comenzar a escribir pruebas y no arrepentirse</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/custis/blog/427603/"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><img src="https://habrastorage.org/webt/vr/v7/q_/vrv7q_kwfiqd5f7qx7jxwukv62g.jpeg"></a> <br><br>  Al llegar a un nuevo proyecto, me encuentro regularmente con una de las siguientes situaciones: <br><br><ol><li>  No hay pruebas en absoluto. </li><li>  Hay pocas pruebas, rara vez se escriben y no se ejecutan de forma continua. </li><li>  Las pruebas est√°n presentes e incluidas en CI (integraci√≥n continua), pero hacen m√°s da√±o que bien. </li></ol><br>  Desafortunadamente, es el √∫ltimo escenario el que a menudo conduce a intentos serios de comenzar a implementar pruebas en ausencia de las habilidades apropiadas. <br><br>  ¬øQu√© se puede hacer para cambiar la situaci√≥n actual?  La idea de usar pruebas no es nueva.  Al mismo tiempo, la mayor√≠a de los tutoriales se asemejan a la famosa imagen sobre c√≥mo dibujar un b√∫ho: conecta JUnit, escribe la primera prueba, usa el primer simulacro, ¬°y listo!  Dichos art√≠culos no responden preguntas sobre qu√© pruebas deben escribirse, a qu√© vale la pena prestar atenci√≥n y c√≥mo vivir con todo esto.  De aqu√≠ naci√≥ la idea de este art√≠culo.  Trat√© de resumir brevemente mi experiencia en la implementaci√≥n de pruebas en diferentes proyectos para facilitar este camino para todos. <br><a name="habracut"></a><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ra/7v/m-/ra7vm-kgn__gsmaeg6xg7aud4ey.jpeg"></div><br>  Hay m√°s que suficientes art√≠culos introductorios sobre este tema, por lo que no nos repetiremos e intentaremos ir desde el otro lado.  En la primera parte, desacreditaremos el mito de que las pruebas conllevan costos exclusivamente adicionales.  Se mostrar√° c√≥mo la creaci√≥n de pruebas de calidad a su vez puede acelerar el proceso de desarrollo.  Luego, en el ejemplo de un proyecto peque√±o, se considerar√°n los principios y reglas b√°sicos que deben seguirse para obtener este beneficio.  Finalmente, en la secci√≥n final, se dar√°n recomendaciones de implementaci√≥n espec√≠ficas: c√≥mo evitar problemas t√≠picos cuando comienzan las pruebas, por el contrario, ralentiza significativamente el desarrollo. <br><br>  Dado que mi especializaci√≥n principal es el backend de Java, se utilizar√° la siguiente pila de tecnolog√≠a en los ejemplos: Java, JUnit, H2, Mockito, Spring, Hibernate.  Al mismo tiempo, una parte importante del art√≠culo est√° dedicada a problemas generales de prueba y los consejos que contiene son aplicables a una gama mucho m√°s amplia de tareas. <br><br>  Sin embargo, ten cuidado!  Las pruebas son muy adictivas: una vez que aprende a usarlas, ya no puede vivir sin ellas. <br><br><div class="spoiler">  <b class="spoiler_title">Contenido</b> <div class="spoiler_text">  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Pruebas vs velocidad de desarrollo</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Ejecutando c√≥digo en cualquier lugar</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Relanzar pruebas</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Depuraci√≥n</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Efectividad</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">De la teor√≠a a la pr√°ctica.</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Desaf√≠o</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Modelo de dominio</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Estructura del proyecto</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Pruebas de integraci√≥n</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Pruebas unitarias</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Recomendaciones de implementaci√≥n</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Conclusi√≥n</a> </div></div><br><a name="TestsVsSpeed"></a><h2>  Pruebas vs velocidad de desarrollo </h2><br>  Las principales preguntas que surgen al discutir la implementaci√≥n de las pruebas: ¬øcu√°nto tiempo tomar√° escribir las pruebas y qu√© beneficios tendr√°?  Las pruebas, como cualquier otra tecnolog√≠a, requerir√°n serios esfuerzos para el desarrollo y la implementaci√≥n, por lo que al principio no deben esperarse beneficios significativos.  En cuanto a los costos de tiempo, dependen mucho del equipo en particular.  Sin embargo, menos del 20-30% de los costos adicionales de codificaci√≥n no deben calcularse exactamente.  Menos simplemente no es suficiente para lograr al menos alg√∫n resultado.  La expectativa de retornos instant√°neos es a menudo la raz√≥n principal para reducir esta actividad incluso antes de que las pruebas sean √∫tiles. <br><br>  ¬øPero de qu√© tipo de eficiencia estamos hablando?  Dejemos caer la letra sobre las dificultades de implementaci√≥n y veamos qu√© oportunidades espec√≠ficas se abren para ahorrar tiempo en las pruebas. <br><br><a name="CodeRun"></a><h3>  Ejecutando c√≥digo en cualquier lugar </h3><br>  Si no hay pruebas en el proyecto, la √∫nica forma de comenzar es levantar toda la aplicaci√≥n.  Es bueno si demora entre 15 y 20 segundos, pero los casos de proyectos grandes en los que un lanzamiento completo puede demorar varios minutos est√°n lejos de ser raros.  ¬øQu√© significa esto para los desarrolladores?  Una parte importante de su tiempo de trabajo ser√°n estas breves sesiones de espera, durante las cuales es imposible continuar trabajando en la tarea actual, pero al mismo tiempo hay muy poco tiempo para cambiar a otra cosa.  Muchos han encontrado al menos una vez proyectos de este tipo en los que el c√≥digo escrito en una hora requiere muchas horas de depuraci√≥n debido a largos reinicios entre correcciones.  En las pruebas, puede limitarse a ejecutar peque√±as partes de la aplicaci√≥n, lo que reducir√° significativamente el tiempo de espera y aumentar√° la productividad de trabajar en el c√≥digo. <br><br>  Adem√°s, la capacidad de ejecutar c√≥digo en cualquier lugar conduce a una depuraci√≥n m√°s completa.  A menudo, verificar incluso los principales casos de uso positivo a trav√©s de la interfaz de la aplicaci√≥n requiere mucho esfuerzo y tiempo.  La presencia de pruebas permite realizar una verificaci√≥n detallada de un funcional espec√≠fico mucho m√°s f√°cil y r√°pido. <br><br>  Otra ventaja es la capacidad de regular el tama√±o de la unidad probada.  Dependiendo de la complejidad de la l√≥gica que se est√° probando, puede restringirse a un m√©todo, una clase, un grupo de clases que implementen alguna funcionalidad, un servicio, etc., hasta la automatizaci√≥n de probar toda la aplicaci√≥n.  Esta flexibilidad le permite descargar pruebas de alto nivel de muchas partes debido al hecho de que se probar√°n en niveles m√°s bajos. <br><br><a name="RepeatedRun"></a><h3>  Relanzar pruebas </h3><br>  Este plus a menudo se cita como la esencia de la automatizaci√≥n de pruebas, pero ve√°moslo desde un √°ngulo menos familiar.  ¬øQu√© nuevas oportunidades abre para los desarrolladores? <br><br>  En primer lugar, cada nuevo desarrollador que particip√≥ en el proyecto podr√° ejecutar f√°cilmente las pruebas existentes para comprender la l√≥gica de la aplicaci√≥n utilizando ejemplos.  Desafortunadamente, la importancia de esto se subestima enormemente.  En las condiciones modernas, las mismas personas rara vez trabajan en un proyecto durante m√°s de 1-2 a√±os.  Y dado que los equipos est√°n formados por varias personas, la aparici√≥n de un nuevo participante cada 2-3 meses es una situaci√≥n t√≠pica para proyectos relativamente grandes.  ¬°Los proyectos particularmente dif√≠ciles est√°n experimentando cambios de generaciones enteras de desarrolladores!  La capacidad de iniciar f√°cilmente cualquier parte de la aplicaci√≥n y observar el comportamiento del sistema a veces simplifica la inmersi√≥n de nuevos programadores en el proyecto.  Adem√°s, un estudio m√°s detallado de la l√≥gica del c√≥digo reduce la cantidad de errores cometidos en la salida y el tiempo para depurarlos en el futuro. <br><br>  En segundo lugar, la capacidad de verificar f√°cilmente que la aplicaci√≥n funciona correctamente abre el camino para la Refactorizaci√≥n Continua.  Este t√©rmino, desafortunadamente, es mucho menos popular que CI.  Significa que la refactorizaci√≥n puede y debe hacerse cada vez que se refina el c√≥digo.  Es la observancia regular de la notoria regla de Boy Scout "dejar el estacionamiento m√°s limpio de lo que estaba antes de su llegada", lo que permite evitar la degradaci√≥n de la base del c√≥digo y garantiza al proyecto una vida larga y feliz. <br><br><a name="Debugging"></a><h3>  Depuraci√≥n </h3><br>  La depuraci√≥n ya se ha mencionado en los p√°rrafos anteriores, pero este punto es tan importante que merece una mirada m√°s cercana.  Desafortunadamente, no hay una manera confiable de medir la relaci√≥n entre el tiempo dedicado a escribir c√≥digo y depurarlo, ya que estos procesos son pr√°cticamente inseparables entre s√≠.  Sin embargo, la presencia de pruebas de calidad en el proyecto reduce significativamente el tiempo de depuraci√≥n, hasta la ausencia casi completa de la necesidad de ejecutar un depurador. <br><br><a name="Efficiency"></a><h3>  Efectividad </h3><br>  Todo lo anterior puede ahorrar significativamente tiempo en la depuraci√≥n inicial del c√≥digo.  Con el enfoque correcto, solo esto pagar√° todos los costos de desarrollo adicionales.  Las bonificaciones de prueba restantes: mejorar la calidad de la base del c√≥digo (el c√≥digo mal dise√±ado es dif√≠cil de probar), reducir la cantidad de defectos, la capacidad de verificar la correcci√≥n del c√≥digo en cualquier momento, etc., ser√° casi gratis. <br><br><a name="FromTheoryToPractice"></a><h2>  De la teor√≠a a la pr√°ctica. </h2><br>  En palabras, todo se ve bien, pero vamos al grano.  Como se mencion√≥ anteriormente, hay materiales m√°s que suficientes sobre c√≥mo hacer la configuraci√≥n inicial del entorno de prueba.  Por lo tanto, procedemos inmediatamente al proyecto terminado.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Fuentes aqu√≠.</a> <br><br><a name="Task"></a><h3>  Desaf√≠o </h3><br>  Como una tarea de plantilla, considere un peque√±o fragmento del backend de una tienda en l√≠nea.  Escribiremos una API t√≠pica para trabajar con productos: creaci√≥n, recepci√≥n, edici√≥n.  Adem√°s de un par de m√©todos para trabajar con clientes: cambiar un "producto favorito" y calcular puntos de bonificaci√≥n para un pedido. <br><br><a name="DomainModel"></a><h3>  Modelo de dominio </h3><br>  Para no sobrecargar el ejemplo, nos restringimos a un conjunto m√≠nimo de campos y clases. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/wc/pn/pz/wcpnpz94fmrb-av0-wkkuu4l2wi.jpeg"></div><br><br>  El cliente tiene un nombre de usuario, un enlace a un producto favorito y una bandera que indica si es un cliente premium. <br><br>  Producto (Producto): nombre, precio, descuento y bandera que indica si se anuncia actualmente. <br><br><a name="ProjectStructure"></a><h3>  Estructura del proyecto </h3><br>  La estructura del c√≥digo principal del proyecto es la siguiente. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ks/qa/m3/ksqam31c3vwkzdfwkmi8r7o3ggk.jpeg"></div><br><br>  Las clases son en capas: <br><br><ul><li>  Modelo: modelo de dominio del proyecto; </li><li>  Jpa: repositorios para trabajar con bases de datos basadas en Spring Data; </li><li>  Servicio - l√≥gica de negocios de la aplicaci√≥n; </li><li>  Controlador: controladores que implementan la API. </li></ul><br>  Estructura de prueba unitaria. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/i3/_1/mi/i3_1micxy4kvvlb6dlgihfmmng0.jpeg"></div><br><br>  Las clases de prueba est√°n en los mismos paquetes que el c√≥digo original.  Adem√°s, se cre√≥ un paquete con creadores para la preparaci√≥n de datos de prueba, pero m√°s sobre eso a continuaci√≥n. <br><br>  Es conveniente separar las pruebas unitarias y las pruebas de integraci√≥n.  A menudo tienen dependencias diferentes, y para un desarrollo c√≥modo, deber√≠a existir la capacidad de ejecutar uno u otro.  Esto se puede lograr de varias maneras: convenciones de nombres, m√≥dulos, paquetes, conjuntos de fuentes.  La elecci√≥n de un m√©todo espec√≠fico es exclusivamente una cuesti√≥n de gustos.  En este proyecto, las pruebas de integraci√≥n se encuentran en un conjunto de fuentes separado: prueba de integraci√≥n. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/qq/1w/z7/qq1wz7n9tq77_zromu01ofx9cns.jpeg"></div><br><br>  Al igual que las pruebas unitarias, las clases con pruebas de integraci√≥n est√°n en los mismos paquetes que el c√≥digo original.  Adem√°s, hay clases base que ayudan a eliminar la duplicaci√≥n de la configuraci√≥n y, si es necesario, contienen m√©todos universales √∫tiles. <br><br><a name="IntegrationTests"></a><h3>  Pruebas de integraci√≥n </h3><br>  Existen diferentes enfoques con respecto a qu√© pruebas vale la pena comenzar.  Si la l√≥gica probada no es muy complicada, puede pasar inmediatamente a las de integraci√≥n (a veces tambi√©n se las denomina aceptaci√≥n).  A diferencia de las pruebas unitarias, se aseguran de que la aplicaci√≥n en su conjunto funcione correctamente. <br><br>  <b>Arquitectura</b> <br><br>  Primero debe decidir en qu√© nivel espec√≠fico se realizar√°n las comprobaciones de integraci√≥n.  Spring Boot proporciona total libertad de elecci√≥n: puede plantear parte del contexto, todo el contexto e incluso un servidor completo, accesible desde las pruebas.  A medida que aumenta el tama√±o de la aplicaci√≥n, este problema se vuelve cada vez m√°s complejo.  A menudo tienes que escribir diferentes pruebas en diferentes niveles. <br><br>  Un buen punto de partida ser√≠an las pruebas del controlador sin iniciar el servidor.  En aplicaciones relativamente peque√±as, es bastante aceptable plantear todo el contexto, ya que por defecto se reutiliza entre pruebas y se inicializa solo una vez.  Considere los m√©todos b√°sicos de la clase <code>ProductController</code> : <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@PostMapping</span></span>(<span class="hljs-string"><span class="hljs-string">"new"</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Product </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createProduct</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@RequestBody Product product)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> productService.createProduct(product); } <span class="hljs-meta"><span class="hljs-meta">@GetMapping</span></span>(<span class="hljs-string"><span class="hljs-string">"{productId}"</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Product </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getProduct</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@PathVariable(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"productId"</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">long</span></span></span><span class="hljs-function"> productId) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> productService.getProduct(productId); } <span class="hljs-meta"><span class="hljs-meta">@PostMapping</span></span>(<span class="hljs-string"><span class="hljs-string">"{productId}/edit"</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">updateProduct</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@PathVariable(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"productId"</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">long</span></span></span><span class="hljs-function"> productId, @RequestBody Product product) </span></span>{ productService.updateProduct(productId, product); }</code> </pre> <br>  La cuesti√≥n del manejo de errores se deja de lado.  Supongamos que se implementa externamente en funci√≥n de un an√°lisis de excepciones lanzadas.  El c√≥digo de los m√©todos es muy simple, su implementaci√≥n en <code>ProductService</code> no <code>ProductService</code> mucho m√°s complicada: <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Transactional</span></span>(readOnly = <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Product </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getProduct</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Long productId)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> productRepository.findById(productId) .orElseThrow(() -&gt; <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> DataNotFoundException(<span class="hljs-string"><span class="hljs-string">"Product"</span></span>, productId)); } <span class="hljs-meta"><span class="hljs-meta">@Transactional</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Product </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createProduct</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Product product)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> productRepository.save(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Product(product)); } <span class="hljs-meta"><span class="hljs-meta">@Transactional</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Product </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">updateProduct</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Long productId, Product product)</span></span></span><span class="hljs-function"> </span></span>{ Product dbProduct = productRepository.findById(productId) .orElseThrow(() -&gt; <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> DataNotFoundException(<span class="hljs-string"><span class="hljs-string">"Product"</span></span>, productId)); dbProduct.setPrice(product.getPrice()); dbProduct.setDiscount(product.getDiscount()); dbProduct.setName(product.getName()); dbProduct.setIsAdvertised(product.isAdvertised()); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> productRepository.save(dbProduct); }</code> </pre> <br>  El repositorio de <code>ProductRepository</code> no contiene sus propios m√©todos: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ProductRepository</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">JpaRepository</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Product</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Long</span></span></span><span class="hljs-class">&gt; </span></span>{ }</code> </pre> <br>  Todo indica que estas clases no necesitan pruebas unitarias simplemente porque toda la cadena se puede verificar de manera f√°cil y eficiente mediante varias pruebas de integraci√≥n.  La duplicaci√≥n de las mismas pruebas en diferentes pruebas complica la depuraci√≥n.  En el caso de un error en el c√≥digo, ahora no caer√° una sola prueba, sino 10-15 a la vez.  Esto a su vez requerir√° m√°s an√°lisis.  Si no hay duplicaci√≥n, es probable que la √∫nica prueba ca√≠da indique inmediatamente un error. <br><br>  <b>Configuracion</b> <br><br>  Para mayor comodidad, destacamos la clase base <code>BaseControllerIT</code> , que contiene la configuraci√≥n Spring y un par de campos: <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@RunWith</span></span>(SpringRunner.class) <span class="hljs-meta"><span class="hljs-meta">@SpringBootTest</span></span>(webEnvironment = SpringBootTest.WebEnvironment.NONE) <span class="hljs-meta"><span class="hljs-meta">@Transactional</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">abstract</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BaseControllerIT</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Autowired</span></span> <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> ProductRepository productRepository; <span class="hljs-meta"><span class="hljs-meta">@Autowired</span></span> <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> CustomerRepository customerRepository; }</code> </pre> <br>  Los repositorios se mueven a la clase base para no saturar las clases de prueba.  Su funci√≥n es exclusivamente auxiliar: preparar datos y verificar el estado de la base de datos despu√©s de que el controlador funciona.  Cuando aumenta el tama√±o de la aplicaci√≥n, puede que esto ya no sea conveniente, pero para empezar es bastante adecuado. <br><br>  La configuraci√≥n principal de Spring est√° definida por las siguientes l√≠neas: <br><br>  <code>@SpringBootTest</code> : se usa para establecer el contexto de la aplicaci√≥n.  <code>WebEnvironment.NONE</code> significa que no es necesario <code>WebEnvironment.NONE</code> contexto web. <br><br>  <code>@Transactional</code> : envuelve todas las pruebas de clase en una transacci√≥n con reversi√≥n autom√°tica para guardar el estado de la base de datos. <br><br>  <b>Estructura de prueba</b> <br><br>  Pasemos a un conjunto minimalista de pruebas para la clase <code>ProductControllerIT</code> : <code>ProductControllerIT</code> . <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Test</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createProduct_productSaved</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ Product product = product(<span class="hljs-string"><span class="hljs-string">"productName"</span></span>).price(<span class="hljs-string"><span class="hljs-string">"1.01"</span></span>).discount(<span class="hljs-string"><span class="hljs-string">"0.1"</span></span>).advertised(<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>).build(); Product createdProduct = productController.createProduct(product); Product dbProduct = productRepository.getOne(createdProduct.getId()); assertEquals(<span class="hljs-string"><span class="hljs-string">"productName"</span></span>, dbProduct.getName()); assertEquals(number(<span class="hljs-string"><span class="hljs-string">"1.01"</span></span>), dbProduct.getPrice()); assertEquals(number(<span class="hljs-string"><span class="hljs-string">"0.1"</span></span>), dbProduct.getDiscount()); assertEquals(<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>, dbProduct.isAdvertised()); }</code> </pre> <br>  El c√≥digo de prueba debe ser extremadamente simple y comprensible de un vistazo.  Si esto no es as√≠, se pierden la mayor√≠a de las ventajas de las pruebas descritas en la primera secci√≥n del art√≠culo.  Es una buena pr√°ctica dividir el cuerpo de prueba en tres partes que se pueden separar visualmente entre s√≠: preparar datos, llamar al m√©todo de prueba, validar los resultados.  Al mismo tiempo, es muy deseable que el c√≥digo de prueba se ajuste a toda la pantalla. <br><br>  Personalmente, me parece m√°s obvio cuando los valores de prueba de la secci√≥n de preparaci√≥n de datos se usan m√°s adelante en las verificaciones.  Alternativamente, podr√≠a comparar objetos expl√≠citamente, por ejemplo, as√≠: <br><br><pre> <code class="java hljs">assertEquals(product, dbProduct);</code> </pre> <br>  En otra prueba para actualizar la informaci√≥n del producto ( <code>updateProduct</code> ), est√° claro que la creaci√≥n de datos se ha vuelto un poco m√°s complicada y para mantener la integridad visual de las tres partes de la prueba, est√°n separadas por dos avances de l√≠nea seguidos: <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Test</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">updateProduct_productUpdated</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ Product product = product(<span class="hljs-string"><span class="hljs-string">"productName"</span></span>).build(); productRepository.save(product); Product updatedProduct = product(<span class="hljs-string"><span class="hljs-string">"updatedName"</span></span>).price(<span class="hljs-string"><span class="hljs-string">"1.1"</span></span>).discount(<span class="hljs-string"><span class="hljs-string">"0.5"</span></span>).advertised(<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>).build(); updatedProduct.setId(product.getId()); productController.updateProduct(product.getId(), updatedProduct); Product dbProduct = productRepository.getOne(product.getId()); assertEquals(<span class="hljs-string"><span class="hljs-string">"updatedName"</span></span>, dbProduct.getName()); assertEquals(number(<span class="hljs-string"><span class="hljs-string">"1.1"</span></span>), dbProduct.getPrice()); assertEquals(number(<span class="hljs-string"><span class="hljs-string">"0.5"</span></span>), dbProduct.getDiscount()); assertEquals(<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>, dbProduct.isAdvertised()); }</code> </pre> <br>  Cada una de las tres partes de la masa se puede simplificar.  Para la preparaci√≥n de datos, los creadores de pruebas son excelentes, que contienen la l√≥gica para crear objetos que es conveniente para usar desde las pruebas.  Las llamadas a m√©todos demasiado complejos se pueden convertir en m√©todos auxiliares dentro de las clases de prueba, ocultando algunos de los par√°metros que son irrelevantes para esta clase.  Para simplificar las comprobaciones complejas, tambi√©n puede escribir funciones auxiliares o implementar sus propios comparadores.  Lo principal con todas estas simplificaciones es no perder la visibilidad de la prueba: todo debe quedar claro de un vistazo al m√©todo principal, sin la necesidad de profundizar. <br><br>  <b>Constructores de prueba</b> <br><br>  Los fabricantes de pruebas merecen especial atenci√≥n.  Encapsular la l√≥gica de crear objetos simplifica el mantenimiento de la prueba.  En particular, el relleno de los campos del modelo que no son relevantes para esta prueba se puede ocultar dentro del generador.  Para hacer esto, no tiene que crearlo directamente, sino que utiliza un m√©todo est√°tico que completar√° los campos faltantes con los valores predeterminados.  Por ejemplo, si aparecen nuevos campos obligatorios en el modelo, se pueden agregar f√°cilmente a este m√©todo.  En <code>ProductBuilder</code> se ve as√≠: <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> ProductBuilder </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">product</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String name)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ProductBuilder() .name(name) .advertised(<span class="hljs-keyword"><span class="hljs-keyword">false</span></span>) .price(<span class="hljs-string"><span class="hljs-string">"0.00"</span></span>); }</code> </pre> <br>  <b>Nombre de la prueba</b> <br><br>  Es imprescindible comprender lo que se prueba espec√≠ficamente en esta prueba.  Para mayor claridad, es mejor dar una respuesta a esta pregunta en su t√≠tulo.  Usando las pruebas de muestra para el m√©todo <code>getProduct</code> considere la convenci√≥n de nomenclatura utilizada: <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Test</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getProduct_oneProductInDb_productReturned</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ Product product = product(<span class="hljs-string"><span class="hljs-string">"productName"</span></span>).build(); productRepository.save(product); Product result = productController.getProduct(product.getId()); assertEquals(<span class="hljs-string"><span class="hljs-string">"productName"</span></span>, result.getName()); } <span class="hljs-meta"><span class="hljs-meta">@Test</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getProduct_twoProductsInDb_correctProductReturned</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ Product product1 = product(<span class="hljs-string"><span class="hljs-string">"product1"</span></span>).build(); Product product2 = product(<span class="hljs-string"><span class="hljs-string">"product2"</span></span>).build(); productRepository.save(product1); productRepository.save(product2); Product result = productController.getProduct(product1.getId()); assertEquals(<span class="hljs-string"><span class="hljs-string">"product1"</span></span>, result.getName()); }</code> </pre> <br>  En el caso general, el t√≠tulo del m√©todo de prueba consta de tres partes, separadas por subrayado: el nombre del m√©todo que se est√° probando, el script y el resultado esperado.  Sin embargo, nadie cancel√≥ el sentido com√∫n, y puede estar justificado omitir algunas partes del nombre si no son necesarias en este contexto (por ejemplo, un script en una sola prueba para crear un producto).  El prop√≥sito de este nombramiento es asegurar que la esencia de cada prueba sea comprensible sin aprender el c√≥digo.  Esto hace que la ventana de resultados de las pruebas sea lo m√°s clara posible, y es con ella que generalmente comienza el trabajo con las pruebas. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/gu/0k/p9/gu0kp9p5hdbswo4i8d6ti2sy1qi.jpeg"></div><br><br>  <b>Conclusiones</b> <br><br>  Eso es todo  Por primera vez, un conjunto m√≠nimo de cuatro pruebas es suficiente para probar los m√©todos de la clase <code>ProductController</code> .  En caso de detecci√≥n de errores, siempre puede agregar las pruebas que faltan.  Al mismo tiempo, el n√∫mero m√≠nimo de pruebas reduce significativamente el tiempo y el esfuerzo para apoyarlas.  Esto, a su vez, es cr√≠tico en el proceso de implementaci√≥n de las pruebas, ya que las primeras pruebas generalmente no se obtienen con la mejor calidad y crean muchos problemas inesperados.  Al mismo tiempo, este conjunto de pruebas es suficiente para recibir los bonos descritos en la primera parte del art√≠culo. <br><br>  Vale la pena se√±alar que tales pruebas no verifican la capa web de la aplicaci√≥n, pero a menudo esto no es obligatorio.  Si es necesario, puede escribir pruebas separadas para la capa web con un c√≥digo auxiliar en lugar de la base ( <code>@WebMvcTest</code> , <code>MockMvc</code> , <code>@MockBean</code> ) o utilizar un servidor completo.  Este √∫ltimo puede complicar la depuraci√≥n y complicar el trabajo con las transacciones, ya que la prueba no puede controlar la transacci√≥n del servidor.  Un ejemplo de dicha prueba de integraci√≥n se puede encontrar en la clase <code>CustomerControllerServerIT</code> . <br><br><a name="UnitTests"></a><h3>  Pruebas unitarias </h3><br>  Las pruebas unitarias tienen varias ventajas sobre las pruebas de integraci√≥n: <br><br><ul><li>  La puesta en marcha lleva milisegundos; </li><li>  Peque√±o tama√±o de la unidad probada; </li><li>  Es f√°cil implementar la verificaci√≥n de una gran cantidad de opciones, ya que cuando se llama directamente al m√©todo, la preparaci√≥n de datos se simplifica enormemente. </li></ul><br>  A pesar de esto, las pruebas unitarias por su naturaleza no pueden garantizar la operatividad de la aplicaci√≥n en su conjunto y no le permiten evitar escribir las de integraci√≥n.  Si la l√≥gica de la unidad bajo prueba es simple, la duplicaci√≥n de las pruebas de integraci√≥n con las pruebas unitarias no traer√° ning√∫n beneficio, sino que solo agregar√° m√°s c√≥digo para soportar. <br><br>  La √∫nica clase en este ejemplo que merece pruebas unitarias es <code>BonusPointCalculator</code> .  Su caracter√≠stica distintiva es una gran cantidad de ramas de la l√≥gica empresarial.  Por ejemplo, se supone que el comprador recibe bonos del 10% del costo del producto, multiplicado por no m√°s de 2 multiplicadores de la siguiente lista: <br><br><ul><li>  El producto cuesta m√°s de 10,000 (√ó 4); </li><li>  El producto participa en una campa√±a publicitaria (√ó 3); </li><li>  El producto es el producto "favorito" del cliente (√ó 5); </li><li>  El cliente tiene un estado premium (√ó 2); </li><li>  Si el cliente tiene un estado premium y compra un producto "favorito", en lugar de los dos multiplicadores indicados, se utiliza uno (√ó 8). </li></ul><br>  En la vida real, por supuesto, valdr√≠a la pena dise√±ar un mecanismo universal flexible para calcular estos bonos, pero para simplificar el ejemplo, nos restringimos a una implementaci√≥n fija.  El c√≥digo de c√°lculo del multiplicador se ve as√≠: <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> List&lt;BigDecimal&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">calculateMultipliers</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Customer customer, Product product)</span></span></span><span class="hljs-function"> </span></span>{ List&lt;BigDecimal&gt; multipliers = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList&lt;&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (customer.getFavProduct() != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> &amp;&amp; customer.getFavProduct().equals(product)) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (customer.isPremium()) { multipliers.add(PREMIUM_FAVORITE_MULTIPLIER); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { multipliers.add(FAVORITE_MULTIPLIER); } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (customer.isPremium()) { multipliers.add(PREMIUM_MULTIPLIER); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (product.isAdvertised()) { multipliers.add(ADVERTISED_MULTIPLIER); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (product.getPrice().compareTo(EXPENSIVE_THRESHOLD) &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span>) { multipliers.add(EXPENSIVE_MULTIPLIER); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> multipliers; }</code> </pre> <br>  Una gran cantidad de opciones lleva al hecho de que dos o tres pruebas de integraci√≥n no est√°n limitadas aqu√≠.  Un conjunto minimalista de pruebas unitarias es perfecto para depurar dicha funcionalidad. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/bk/jw/ai/bkjwai9dy1mrxxarxncx6jgfehq.jpeg"></div><br><br>  El conjunto de pruebas correspondiente se puede encontrar en la clase <code>BonusPointCalculatorTest</code> .  Aqu√≠ hay algunos de ellos: <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Test</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">calculate_oneProduct</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ Product product = product(<span class="hljs-string"><span class="hljs-string">"product"</span></span>).price(<span class="hljs-string"><span class="hljs-string">"1.00"</span></span>).build(); Customer customer = customer(<span class="hljs-string"><span class="hljs-string">"customer"</span></span>).build(); Map&lt;Product, Long&gt; quantities = mapOf(product, <span class="hljs-number"><span class="hljs-number">1L</span></span>); BigDecimal bonus = bonusPointCalculator.calculate(customer, list(product), quantities::get); BigDecimal expectedBonus = bonusPoints(<span class="hljs-string"><span class="hljs-string">"0.10"</span></span>).build(); assertEquals(expectedBonus, bonus); } <span class="hljs-meta"><span class="hljs-meta">@Test</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">calculate_favProduct</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ Product product = product(<span class="hljs-string"><span class="hljs-string">"product"</span></span>).price(<span class="hljs-string"><span class="hljs-string">"1.00"</span></span>).build(); Customer customer = customer(<span class="hljs-string"><span class="hljs-string">"customer"</span></span>).favProduct(product).build(); Map&lt;Product, Long&gt; quantities = mapOf(product, <span class="hljs-number"><span class="hljs-number">1L</span></span>); BigDecimal bonus = bonusPointCalculator.calculate(customer, list(product), quantities::get); BigDecimal expectedBonus = bonusPoints(<span class="hljs-string"><span class="hljs-string">"0.10"</span></span>).addMultiplier(FAVORITE_MULTIPLIER).build(); assertEquals(expectedBonus, bonus); }</code> </pre> <br>  Vale la pena se√±alar que en las pruebas nos referimos espec√≠ficamente a la API p√∫blica de la clase: el m√©todo de <code>calculate</code> .  Probar un contrato de clase en lugar de su implementaci√≥n evita el colapso de las pruebas debido a cambios no funcionales y refactorizaci√≥n. <br><br>  Finalmente, cuando verificamos la l√≥gica interna con pruebas unitarias, ya no necesitamos poner todos estos detalles en integraci√≥n.  En este caso, una prueba m√°s o menos representativa es suficiente, por ejemplo esto: <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Test</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">calculateBonusPoints_twoProductTypes_correctValueCalculated</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ Product product1 = product(<span class="hljs-string"><span class="hljs-string">"product1"</span></span>).price(<span class="hljs-string"><span class="hljs-string">"1.01"</span></span>).build(); Product product2 = product(<span class="hljs-string"><span class="hljs-string">"product2"</span></span>).price(<span class="hljs-string"><span class="hljs-string">"10.00"</span></span>).build(); productRepository.save(product1); productRepository.save(product2); Customer customer = customer(<span class="hljs-string"><span class="hljs-string">"customer"</span></span>).build(); customerRepository.save(customer); Map&lt;Long, Long&gt; quantities = mapOf(product1.getId(), <span class="hljs-number"><span class="hljs-number">1L</span></span>, product2.getId(), <span class="hljs-number"><span class="hljs-number">2L</span></span>); BigDecimal bonus = customerController.calculateBonusPoints( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CalculateBonusPointsRequest(<span class="hljs-string"><span class="hljs-string">"customer"</span></span>, quantities) ); BigDecimal bonusPointsProduct1 = bonusPoints(<span class="hljs-string"><span class="hljs-string">"0.10"</span></span>).build(); BigDecimal bonusPointsProduct2 = bonusPoints(<span class="hljs-string"><span class="hljs-string">"1.00"</span></span>).quantity(<span class="hljs-number"><span class="hljs-number">2</span></span>).build(); BigDecimal expectedBonus = bonusPointsProduct1.add(bonusPointsProduct2); assertEquals(expectedBonus, bonus); }</code> </pre> <br>  Como en el caso de las pruebas de integraci√≥n, el conjunto de pruebas unitarias utilizado es muy peque√±o y no garantiza la correcci√≥n completa de la aplicaci√≥n.  Sin embargo, su presencia aumenta significativamente la confianza en el c√≥digo, facilita la depuraci√≥n y otorga los otros bonos enumerados en la primera parte del art√≠culo. <br><br><a name="ImplementationConsiderations"></a><h2>  Recomendaciones de implementaci√≥n </h2><br>  Espero que las secciones anteriores hayan sido suficientes para convencer al menos a un desarrollador de que intente comenzar a usar pruebas en su proyecto.  Este cap√≠tulo enumerar√° brevemente las principales recomendaciones que ayudar√°n a evitar problemas graves y reducir√°n los costos iniciales de implementaci√≥n. <br><br>  <b>Intente comenzar a implementar las pruebas en la nueva aplicaci√≥n.</b>  Escribir las primeras pruebas en un gran proyecto heredado ser√° mucho m√°s dif√≠cil y requerir√° m√°s habilidad que en uno reci√©n creado.  Por lo tanto, si es posible, es mejor comenzar con una nueva aplicaci√≥n peque√±a.  Si no se esperan nuevas aplicaciones completas, puede intentar desarrollar alguna utilidad √∫til para uso interno.  Lo principal es que la tarea debe ser m√°s o menos realista: los ejemplos inventados no proporcionar√°n una experiencia completa. <br><br>  <b>Configure ejecuciones de prueba regulares.</b>  Si las pruebas no se ejecutan de manera regular, no solo dejan de realizar su funci√≥n principal, verificar la correcci√≥n del c√≥digo, sino que tambi√©n quedan desactualizadas r√°pidamente.  Por lo tanto, es extremadamente importante configurar al menos la canalizaci√≥n m√≠nima de CI con el inicio autom√°tico de las pruebas cada vez que el c√≥digo se actualiza en el repositorio. <br><br>  <b>No persigas la tapa.</b>  Como en el caso de cualquier otra tecnolog√≠a, al principio las pruebas no se obtendr√°n de la mejor calidad.  La literatura relevante (enlaces al final del art√≠culo) o un mentor competente pueden ayudar aqu√≠, pero esto no cancela la necesidad de conos de relleno.  Las pruebas a este respecto son similares al resto del c√≥digo: para comprender c√≥mo afectar√°n el proyecto, solo puede hacerlo despu√©s de vivir con ellos durante un tiempo.  Por lo tanto, para minimizar el da√±o, la primera vez es mejor no perseguir el n√∫mero y los n√∫meros hermosos como una cobertura del cien por ciento.  En cambio, debe limitarse a los principales escenarios positivos para la funcionalidad de su propia aplicaci√≥n. <br><br>  <b>No se deje llevar por las pruebas unitarias.</b>  Continuando con el tema de "cantidad versus calidad", debe tenerse en cuenta que las pruebas unitarias honestas no deben llevarse a cabo por primera vez, porque esto puede conducir f√°cilmente a una especificaci√≥n excesiva de la aplicaci√≥n.  A su vez, esto se convertir√° en un factor inhibidor serio en la refactorizaci√≥n posterior y las mejoras de la aplicaci√≥n.  Las pruebas unitarias solo deben usarse si hay una l√≥gica compleja en una clase particular o grupo de clases, lo cual es inconveniente para verificar a nivel de integraci√≥n. <br><br>  <b>No se deje llevar por las clases de c√≥digo auxiliar y los m√©todos de aplicaci√≥n.</b>  Stubs (stub, simulacro) es otra herramienta que requiere un enfoque equilibrado y mantener un equilibrio.  Por un lado, el aislamiento completo de la unidad le permite concentrarse en la l√≥gica probada y no pensar en el resto del sistema.  Por otro lado, esto requerir√° un tiempo de desarrollo adicional y, como con las pruebas unitarias, puede conducir a una especificaci√≥n excesiva de comportamiento. <br><br>  <b>Desatar las pruebas de integraci√≥n de sistemas externos.</b>  Un error muy com√∫n en las pruebas de integraci√≥n es el uso de una base de datos real, colas de mensajes y otros sistemas externos a la aplicaci√≥n.  Por supuesto, la capacidad de ejecutar una prueba en un entorno real es √∫til para la depuraci√≥n y el desarrollo.  Tales pruebas en peque√±as cantidades pueden tener sentido, especialmente para correr de forma interactiva.  Sin embargo, su uso generalizado genera varios problemas: <br><br><ol><li>  Para ejecutar las pruebas, deber√° configurar el entorno externo.  Por ejemplo, instale una base de datos en cada m√°quina donde se ensamblar√° la aplicaci√≥n.  Esto dificultar√° que los nuevos desarrolladores ingresen al proyecto y configuren CI. </li><li>  El estado de los sistemas externos puede variar en diferentes m√°quinas antes de ejecutar las pruebas.  Por ejemplo, la base de datos ya puede contener las tablas que la aplicaci√≥n necesita con datos que no se esperan en la prueba.  Esto conducir√° a fallas impredecibles en las pruebas, y su eliminaci√≥n requerir√° una cantidad significativa de tiempo. </li><li>  Si se est√° trabajando en paralelo en varios proyectos, es posible la influencia no obvia de algunos proyectos en otros.  Por ejemplo, la configuraci√≥n espec√≠fica de la base de datos realizada para uno de los proyectos puede ayudar a que la funcionalidad de otro proyecto funcione correctamente, lo que, sin embargo, se romper√° cuando se inicie en una base de datos limpia en otra m√°quina. </li><li>  Las pruebas se llevan a cabo durante mucho tiempo: una ejecuci√≥n completa puede alcanzar decenas de minutos.  Esto lleva al hecho de que los desarrolladores dejan de ejecutar pruebas localmente y miran sus resultados solo despu√©s de enviar los cambios al repositorio remoto.  Este comportamiento niega la mayor√≠a de las ventajas de las pruebas, que se discutieron en la primera parte del art√≠culo. </li></ol><br>  <b>Borrar el contexto entre las pruebas de integraci√≥n.</b>  A menudo, para acelerar el trabajo de las pruebas de integraci√≥n, debe reutilizar el mismo contexto entre ellas.  Incluso la documentaci√≥n oficial de Spring hace tal recomendaci√≥n.  Al mismo tiempo, se debe evitar la influencia de las pruebas entre s√≠.  Dado que se lanzan en un orden arbitrario, la presencia de tales conexiones puede conducir a errores aleatorios irreproducibles.  Para evitar que esto suceda, las pruebas no deben dejar atr√°s ning√∫n cambio en el contexto.  Por ejemplo, cuando se usa una base de datos, para el aislamiento, generalmente es suficiente revertir todas las transacciones confirmadas en la prueba.  Si no se pueden evitar los cambios en el contexto, puede configurar su recreaci√≥n utilizando la anotaci√≥n <code>@DirtiesContext</code> . <br><br> <b>  ,      .</b>         ,       - .    ,            .  ,   , ‚Äî      ,           . <br><br> <b>      .</b>      ,    ,       . ,    ,       . <br><br> <b>   TDD (Test-Driven Development).</b> TDD    ,      ,     .  ,        ,     .   ,         ,        . <br><br><h2>   ,  ? </h2><br>              ,  : <br><br><ol><li>       (  )?             . </li><li>           ,      ( ,  CI)?    . </li><li>     ?                     . </li><li>     ?    .   ,      ,      . </li></ol><br>        ,      .     , , -   .   ‚Äî           . <br><br><a name="Conclusion"></a><h2>  Conclusi√≥n </h2><br>       ,     .    -    ,    .  ,  -      .        ‚Äî         ,      ,    -.      ,                 . <br><br> ,    ,        ,            ! <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">   GitHub</a> <br><br><div class="spoiler"> <b class="spoiler_title"> </b> <div class="spoiler_text"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Growing Object-Oriented Software, Guided by Tests</a> , Steve Freeman, Nat Pryce <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">The Art of Unit Testing</a> , Roy Osherove <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Test-driven Development: By Example</a> , Kent Beck <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Refactoring: Improving the Design of Existing Code</a> , Martin Fowler <br></div></div></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es427603/">https://habr.com/ru/post/es427603/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es427589/index.html">Escribimos un chat en l√≠nea en Websockets usando Swoole</a></li>
<li><a href="../es427591/index.html">La arquitectura como carga</a></li>
<li><a href="../es427593/index.html">Magia de comando r√°pido en Vivaldi 2.1</a></li>
<li><a href="../es427595/index.html">Prueba Micronaut o Darling, reduje el marco</a></li>
<li><a href="../es427601/index.html">Caso 5 + 1 donde la especificaci√≥n REST API juega un papel muy importante</a></li>
<li><a href="../es427605/index.html">C√≥mo la plataforma de crowdsourcing de Yandex ayuda a entrenar drones y evaluar la calidad del servicio</a></li>
<li><a href="../es427607/index.html">Datacenter en Suiza: trabajar como un reloj</a></li>
<li><a href="../es427609/index.html">Resolviendo la ecuaci√≥n con divisi√≥n entera sin fuerza bruta</a></li>
<li><a href="../es427611/index.html">La historia de c√≥mo actualic√© Yandex MapKit en iOS o mapas, dinero, 2 mapas</a></li>
<li><a href="../es427613/index.html">10 blogs √∫tiles para programadores en ingl√©s</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>