<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üí´ ‚òùüèæ üïã Huawei Cloud: Heute ist es im PVS-Studio bew√∂lkt üßôüèø ü§ñ ü§Ωüèæ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Heute kennt jeder Cloud-Dienste. Viele Unternehmen haben dieses Marktsegment geknackt und eigene Cloud-Dienste f√ºr verschiedene Zwecke entwickelt. In ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Huawei Cloud: Heute ist es im PVS-Studio bew√∂lkt</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/pvs-studio/blog/477558/"><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2ac/bd2/47b/2acbd247b999e7f8e9e45f77181e2f06.png" alt="Bild 2"></div><br>  Heute kennt jeder Cloud-Dienste.  Viele Unternehmen haben dieses Marktsegment geknackt und eigene Cloud-Dienste f√ºr verschiedene Zwecke entwickelt.  In letzter Zeit hat sich unser Team auch f√ºr diese Dienstleistungen interessiert, um den PVS-Studio Code Analyzer in diese zu integrieren.  Wahrscheinlich haben unsere regelm√§√üigen Leser bereits geraten, welche Art von Projekt wir diesmal pr√ºfen werden.  Die Wahl fiel auf den Code der Huawei Cloud Services. <br><a name="habracut"></a><br><h2>  Einleitung </h2><br>  Wenn Sie PVS-Studio-Teambeitr√§gen folgen, haben Sie wahrscheinlich bemerkt, dass wir uns in letzter Zeit intensiv mit Cloud-Technologien befasst haben.  Wir haben bereits mehrere Artikel zu diesem Thema ver√∂ffentlicht: <br><br><ul><li>  <a href="https://www.viva64.com/en/b/0670/">PVS-Studio in den Wolken: Azure DevOps</a> </li><li>  <a href="https://www.viva64.com/en/b/0636/">PVS-Studio in den Wolken: Travis CI</a> </li><li>  <a href="https://www.viva64.com/en/b/0676/">PVS-Studio in den Wolken: CircleCI</a> </li><li>  <a href="https://www.viva64.com/en/b/0686/">PVS-Studio in den Wolken: GitLab CI / CD</a> </li></ul><br>  Gerade als ich nach einem ungew√∂hnlichen Projekt f√ºr den kommenden Artikel suchte, erhielt ich eine E-Mail mit einem Stellenangebot von <a href="https://www.huawei.com/en/">Huawei</a> .  Nachdem einige Informationen √ºber dieses Unternehmen gesammelt wurden, stellte sich heraus, dass sie ihre eigenen Cloud-Dienste hatten. Hauptsache, der Quellcode dieser Dienste ist auf GitHub verf√ºgbar.  Dies war der Hauptgrund f√ºr die Wahl dieses Unternehmens f√ºr diesen Artikel.  Wie ein chinesischer Weiser sagte: "Die Unf√§lle sind nicht zuf√§llig." <br><br>  Lassen Sie mich einige Details √ºber unseren Analysator geben.  PVS-Studio ist ein statischer Analysator zur Fehlererkennung im Quellcode von Programmen, der in C, C ++, C # und Java geschrieben wurde.  Der Analyzer funktioniert unter Windows, Linux und macOS.  Neben Plugins f√ºr klassische Entwicklungsumgebungen wie Visual Studio oder IntelliJ IDEA kann der Analyzer auch in SonarQube und Jenkins integriert werden: <br><br><ul><li>  <a href="https://www.viva64.com/en/m/0037/">Integration der PVS-Studio-Analyseergebnisse in SonarQube</a> </li><li>  <a href="https://www.viva64.com/en/m/0048/">PVS-Studio l√§uft in Jenkins</a> </li></ul><br><h2>  Projektanalyse </h2><br>  Als ich nach dem Artikel recherchierte, stellte ich fest, dass Huawei √ºber ein <a href="https://developer.huaweicloud.com/en-us">Entwicklercenter</a> mit verf√ºgbaren Informationen, Handb√ºchern und Quellen f√ºr ihre Cloud-Dienste verf√ºgt.  F√ºr die Erstellung dieser Dienste wurde eine Vielzahl von Programmiersprachen verwendet, wobei Sprachen wie Go, Java und Python am h√§ufigsten verwendet wurden. <br><br>  Da ich mich auf Java spezialisiere, wurden die Projekte nach meinen Kenntnissen und F√§higkeiten ausgew√§hlt.  Sie k√∂nnen die im Artikel analysierten <a href="https://github.com/huaweicloud/">Projektquellen</a> in einem GitHub-Repository <a href="https://github.com/huaweicloud/">huaweicloud abrufen</a> . <br><br>  Um Projekte zu analysieren, brauchte ich nur ein paar Dinge zu tun: <br><br><ul><li>  Holen Sie sich Projekte aus dem Repository; </li><li>  Verwenden Sie die <a href="https://www.viva64.com/en/m/0044/">Anweisungen zum</a> Starten von Java Analyzer und f√ºhren Sie die Analyse f√ºr jedes Projekt aus. </li></ul><br>  Nach der Analyse der Projekte haben wir nur drei ausgew√§hlt, auf die wir gerne eingehen m√∂chten.  Dies liegt an der Tatsache, dass die Gr√∂√üe der restlichen Java-Projekte zu gering ausfiel. <br><br>  Projektanalyseergebnisse (Anzahl der Warnungen und Anzahl der Dateien): <br><br><ul><li>  <a href="https://github.com/huaweicloud/huaweicloud-sdk-java">huaweicloud-sdk-java</a> : 31 - Hoch, 2 - Mittel und 16 - Niedrig, 2700+ Dateien. </li><li>  <a href="https://github.com/huaweicloud/huaweicloud-dis-agent">huaweicloud-dis-agent</a> : 7 - Hoch, 6 - Mittel und 6 - Niedrig, √ºber 100 Dateien. </li><li>  <a href="https://github.com/huaweicloud/huaweicloud-sdk-java-dis">huaweicloud-sdk-java-dis</a> : 15 - Hoch, 6 - Mittel und 16 - Niedrig, 270+ Dateien. </li></ul><br>  Es gab nur wenige Warnungen, die auf eine hohe Codequalit√§t hinweisen, zumal nicht alle Warnungen auf echte Fehler hindeuten.  Dies liegt an der Tatsache, dass dem Analysator manchmal Informationen fehlen, um den richtigen Code von dem fehlerhaften zu unterscheiden.  Aus diesem Grund optimieren wir die Diagnose des Analysators Tag f√ºr Tag und greifen dabei auf die Informationen der Benutzer zur√ºck.  Gerne k√∂nnen Sie den Artikel " <a href="https://www.viva64.com/en/b/0488/">Die Art und Weise, wie statische Analyseger√§te gegen falsche Positive k√§mpfen, und warum sie dies tun" lesen</a> . <br><br>  Bei der Analyse des Projekts habe ich nur die h√§ufigsten Warnungen herausgegriffen, √ºber die ich in diesem Artikel sprechen werde. <br><br><h2>  Felder Initialisierungsreihenfolge </h2><br>  <a href="https://www.viva64.com/en/w/v6050/">V6050 Klasseninitialisierungszyklus</a> ist vorhanden.  Die Initialisierung von 'INSTANCE' erscheint vor der Initialisierung von 'LOG'.  UntrustedSSL.java (32), UntrustedSSL.java (59), UntrustedSSL.java (33) <br><br><pre><code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UntrustedSSL</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> UntrustedSSL INSTANCE = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> UntrustedSSL(); <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Logger LOG = LoggerFactory.getLogger(UntrustedSSL.class); .... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">UntrustedSSL</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { .... } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (Throwable t) { LOG.error(t.getMessage(), t); <span class="hljs-comment"><span class="hljs-comment">// &lt;= } } }</span></span></code> </pre> <br>  Wenn der <i>Klassenkonstruktor UntrustedSSL</i> eine Ausnahme <i>enth√§lt</i> , werden die Informationen zu dieser Ausnahme im <i>catch-</i> Block mithilfe des <i>LOG-</i> Protokolls protokolliert.  Aufgrund der Initialisierungsreihenfolge statischer Felder ist <i>LOG</i> zum Zeitpunkt der Initialisierung des <i>INSTANCE-</i> Felds noch nicht initialisiert.  Wenn Sie Informationen zu der Ausnahme im Konstruktor protokollieren, f√ºhrt dies daher zu einer <i>NullPointerException</i> .  Diese Ausnahme ist der Grund f√ºr eine weitere Ausnahme <i>ExceptionInInitializerError</i> , die ausgel√∂st wird, wenn bei der Initialisierung des statischen Felds eine Ausnahme aufgetreten ist.  <i>Um</i> dieses Problem zu l√∂sen, m√ºssen Sie die <i>LOG-</i> Initialisierung vor der <i>INSTANCE-</i> Initialisierung platzieren <i>.</i> <br><br><h2>  Unauff√§lliger Tippfehler </h2><br>  <a href="https://www.viva64.com/en/w/v6005/">V6005</a> Die Variable 'this.metricSchema' ist sich selbst zugeordnet.  OpenTSDBSchema.java (72) <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">OpenTSDBSchema</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@JsonProperty</span></span>(<span class="hljs-string"><span class="hljs-string">"metric"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> List&lt;SchemaField&gt; metricSchema; .... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setMetricsSchema</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(List&lt;SchemaField&gt; metricsSchema)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.metricSchema = metricSchema; <span class="hljs-comment"><span class="hljs-comment">// &lt;= } public void setMetricSchema(List&lt;SchemaField&gt; metricSchema) { this.metricSchema = metricSchema; } .... }</span></span></code> </pre> <br>  Beide Methoden legen das <i>metricSchema-</i> Feld fest, aber die Methodennamen unterscheiden sich durch das Symbol.  Der Programmierer benannte die Argumente dieser Methoden gem√§√ü dem Namen der Methode.  In der Zeile, auf die der Analysator zeigt, wird daher das <i>metricSchema-</i> Feld sich selbst zugewiesen, und das Argument der <i>metricsSchema-</i> Methode wird nicht verwendet. <br><br>  <a href="https://www.viva64.com/en/w/v6005/">V6005</a> Die Variable 'suspend' ist sich selbst zugeordnet.  SuspendTransferTaskRequest.java (77) <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SuspendTransferTaskRequest</span></span></span><span class="hljs-class"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">boolean</span></span> suspend; .... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setSuspend</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">boolean</span></span></span></span><span class="hljs-function"><span class="hljs-params"> suspend)</span></span></span><span class="hljs-function"> </span></span>{ suspend = suspend; } .... }</code> </pre> <br>  Hier ist ein trivialer Fehler im Zusammenhang mit Nachl√§ssigkeit, aufgrund dessen das Argument <i>suspend</i> sich selbst zugewiesen wird.  Infolgedessen wird dem <i>Suspend-</i> Feld nicht der implizite Wert des erhaltenen Arguments zugewiesen.  Die richtige Version: <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setSuspend</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">boolean</span></span></span></span><span class="hljs-function"><span class="hljs-params"> suspend)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.suspend = suspend; }</code> </pre> <br><h2>  Vorausbestimmung der Bedingungen </h2><br>  Wie so oft bricht die <a href="https://www.viva64.com/en/w/v6007/">V6007-</a> Regel in Bezug auf die <a href="https://www.viva64.com/en/w/v6007/">Anzahl</a> der Warnungen vor. <br><br>  <a href="https://www.viva64.com/en/w/v6007/">V6007 Der</a> Ausdruck 'firewallPolicyId == null' ist immer falsch.  FirewallPolicyServiceImpl.java (125) <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> FirewallPolicy </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">removeFirewallRuleFromPolicy</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String firewallPolicyId, String firewallRuleId)</span></span></span><span class="hljs-function"> </span></span>{ checkNotNull(firewallPolicyId); checkNotNull(firewallRuleId); checkState(!(firewallPolicyId == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> &amp;&amp; firewallRuleId == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>), <span class="hljs-string"><span class="hljs-string">"Either a Firewall Policy or Firewall Rule identifier must be set"</span></span>); .... }</code> </pre> <br>  In dieser Methode werden Argumente von der <i>checkNotNull-</i> Methode auf <i>null</i> <i>gepr√ºft</i> : <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@CanIgnoreReturnValue</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> &lt;T&gt; <span class="hljs-function"><span class="hljs-function">T </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">checkNotNull</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(T reference)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (reference == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> NullPointerException(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> reference; } }</code> </pre> <br>  Nachdem Sie das Argument mit der <i>checkNotNull-</i> Methode <i>√ºberpr√ºft haben</i> , k√∂nnen Sie zu 100% sicher sein, dass das an diese Methode √ºbergebene Argument nicht gleich <i>null ist</i> .  Da beide Argumente der <i>removeFirewallRuleFromPolicy-</i> Methode von der <i>checkNotNull-</i> Methode √ºberpr√ºft werden, ist ihre weitere √úberpr√ºfung auf <i>null</i> nicht sinnvoll.  Der Ausdruck, in dem die Argumente <i>firewallPolicyId</i> und <i>firewallRuleId</i> erneut auf <i>null</i> √ºberpr√ºft werden, wird jedoch als erstes Argument an die <i>checkState-</i> Methode √ºbergeben. <br><br>  Eine √§hnliche Warnung wird auch f√ºr <i>firewallRuleId</i> ausgegeben: <br><br><ul><li>  V6007 Der Ausdruck 'firewallRuleId == null' ist immer falsch.  FirewallPolicyServiceImpl.java (125) </li></ul><br>  <a href="https://www.viva64.com/en/w/v6007/">V6007 Der</a> Ausdruck ' <a href="https://www.viva64.com/en/w/v6007/">filtersParams</a> ! = Null' ist immer wahr.  NetworkPolicyServiceImpl.java (60) <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> Invocation&lt;NetworkServicePolicies&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">buildInvocation</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Map&lt;String, String&gt; filteringParams)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (filteringParams == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> servicePoliciesInvocation; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (filteringParams != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { <span class="hljs-comment"><span class="hljs-comment">// &lt;= .... } return servicePoliciesInvocation; }</span></span></code> </pre> <br>  Wenn in dieser Methode das <i>filteringParams-</i> Argument <i>null ist</i> , gibt die Methode einen Wert zur√ºck.  Aus diesem Grund ist die Pr√ºfung, auf die der Analysator zeigt, immer wahr, was wiederum bedeutet, dass diese Pr√ºfung bedeutungslos ist. <br><br>  13 weitere Klassen sind √§hnlich: <br><br><ul><li>  V6007 Der Ausdruck 'filtersParams! = Null' ist immer wahr.  PolicyRuleServiceImpl.java (58) </li><li>  V6007 Der Ausdruck 'filtersParams! = Null' ist immer wahr.  GroupServiceImpl.java (58) </li><li>  V6007 Der Ausdruck 'filtersParams! = Null' ist immer wahr.  ExternalSegmentServiceImpl.java (57) </li><li>  V6007 Der Ausdruck 'filtersParams! = Null' ist immer wahr.  L3policyServiceImpl.java (57) </li><li>  V6007 Der Ausdruck 'filtersParams! = Null' ist immer wahr.  PolicyRuleSetServiceImpl.java (58) </li><li>  und so weiter ... </li></ul><br><h2>  Nullreferenz </h2><br>  <a href="https://www.viva64.com/en/w/v6008/">V6008</a> Potentielle Null-Dereferenzierung von 'm.blockDeviceMapping'.  NovaServerCreate.java (390) <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> ServerCreateBuilder </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">blockDevice</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(BlockDeviceMappingCreate blockDevice)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (blockDevice != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> &amp;&amp; m.blockDeviceMapping == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { m.blockDeviceMapping = Lists.newArrayList(); } m.blockDeviceMapping.add(blockDevice); <span class="hljs-comment"><span class="hljs-comment">// &lt;= return this; }</span></span></code> </pre> <br>  Bei dieser Methode wird die Initialisierung des Referenzfelds <i>m.blockDeviceMapping</i> nicht durchgef√ºhrt, wenn das Argument <i>blockDevice</i> <i>null ist</i> .  Dieses Feld wird nur in dieser Methode initialisiert. Wenn Sie also die Methode <i>add</i> aus dem Feld <i>m.blockDeviceMapping</i> <i>aufrufen</i> , tritt eine <i>NullPointerException</i> auf. <br><br>  <a href="https://www.viva64.com/en/w/v6008/">V6008</a> Potentielle Null-Dereferenzierung von 'FileId.get (path)' in Funktion '&lt;init&gt;'.  TrackedFile.java (140), TrackedFile.java (115) <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TrackedFile</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(FileFlow&lt;?&gt; flow, Path path)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> IOException </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>(flow, path, FileId.get(path), ....); }</code> </pre> <br>  Der Konstruktor der <i>TrackedFile-</i> Klasse erh√§lt als drittes Argument das Ergebnis der statischen <i>FileId.get (path)</i> -Methode.  Diese Methode kann jedoch <i>null zur√ºckgeben</i> : <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> FileId </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Path file)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> IOException </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!Files.exists(file)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; } .... }</code> </pre> <br>  Im √ºber <i>diesen</i> aufgerufenen Konstruktor √§ndert sich das Argument <i>id</i> erst bei seiner ersten Verwendung: <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TrackedFile</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(...., ...., FileId id, ....)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> IOException </span></span>{ .... FileId newId = FileId.get(path); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!id.equals(newId)) { .... } }</code> </pre> <br>  Wie wir sehen k√∂nnen, tritt eine Ausnahme auf, wenn <i>Null</i> als drittes Argument an die Methode √ºbergeben wird. <br><br>  Hier ist ein √§hnlicher Fall: <br><br><ul><li>  V6008 Potentielle Null-Dereferenzierung von 'Buffer'.  PublishingQueue.java (518) </li></ul><br>  <a href="https://www.viva64.com/en/w/v6008/">V6008</a> M√∂gliche Null-Dereferenzierung von 'dataTmpFile'.  CacheManager.java (91) <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">putToCache</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(PutRecordsRequest putRecordsRequest)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (dataTmpFile == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> || !dataTmpFile.exists()) { <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { dataTmpFile.createNewFile(); <span class="hljs-comment"><span class="hljs-comment">// &lt;= } catch (IOException e) { LOGGER.error("Failed to create cache tmp file, return.", e); return ; } } .... }</span></span></code> </pre> <br>  Nochmal NPE.  Eine Reihe von √úberpr√ºfungen im bedingten Operator erm√∂glicht dem Nullobjekt <i>dataTmpFile</i> eine weitere Dereferenzierung.  Ich denke, hier gibt es zwei Tippfehler und die Pr√ºfung sollte tats√§chlich so aussehen: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (dataTmpFile != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> &amp;&amp; !dataTmpFile.exists())</code> </pre> <br><h2>  Teilstrings und negative Zahlen </h2><br>  <a href="https://www.viva64.com/en/w/v6009/">V6009</a> Die Funktion 'substring' kann den Wert '-1' empfangen, wenn ein nicht negativer Wert erwartet wird.  √úberpr√ºfen Sie das Argument: 2. RemoveVersionProjectIdFromURL.java (37) <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">apply</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String url)</span></span></span><span class="hljs-function"> </span></span>{ String urlRmovePojectId = url.substring(<span class="hljs-number"><span class="hljs-number">0</span></span>, url.lastIndexOf(<span class="hljs-string"><span class="hljs-string">"/"</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> urlRmovePojectId.substring(<span class="hljs-number"><span class="hljs-number">0</span></span>, urlRmovePojectId.lastIndexOf(<span class="hljs-string"><span class="hljs-string">"/"</span></span>)); }</code> </pre> <br>  Dies impliziert, dass diese Methode eine URL als Zeichenfolge erh√§lt, die in keiner Weise validiert wird.  Sp√§ter wird diese Zeichenfolge mit der <i>lastIndexOf-</i> Methode mehrmals <i>abgeschnitten</i> .  Wenn die Methode <i>lastIndexOf</i> keine √úbereinstimmung in der Zeichenfolge findet, wird -1 zur√ºckgegeben.  Dies f√ºhrt zu einer <i>StringIndexOutOfBoundsException</i> , da die Argumente der <i>substring-</i> Methode nicht negative Zahlen sein m√ºssen.  F√ºr die korrekte Funktionsweise der Methode muss eine Eingabeargumentvalidierung hinzugef√ºgt oder √ºberpr√ºft werden, ob die Ergebnisse der <i>lastIndexOf-</i> Methode keine negativen Zahlen sind. <br><br>  Hier sind einige andere Snippets mit √§hnlichen Eigenschaften: <br><br><ul><li>  V6009 Die Funktion 'substring' kann den Wert '-1' empfangen, wenn ein nicht negativer Wert erwartet wird.  √úberpr√ºfen Sie das Argument: 2. RemoveProjectIdFromURL.java (37) </li><li>  V6009 Die Funktion 'substring' kann den Wert '-1' empfangen, wenn ein nicht negativer Wert erwartet wird.  √úberpr√ºfen Sie das Argument: 2. RemoveVersionProjectIdFromURL.java (38) </li></ul><br><h2>  Vergessenes Ergebnis </h2><br>  <a href="https://www.viva64.com/en/w/v6010/">V6010</a> Der R√ºckgabewert der Funktion 'concat' muss verwendet werden.  AKSK.java (278) <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">buildCanonicalHost</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(URL url)</span></span></span><span class="hljs-function"> </span></span>{ String host = url.getHost(); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> port = url.getPort(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (port &gt; -<span class="hljs-number"><span class="hljs-number">1</span></span>) { host.concat(<span class="hljs-string"><span class="hljs-string">":"</span></span> + Integer.toString(port)); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> host; }</code> </pre> <br>  Beim Schreiben dieses Codes hat der Autor nicht ber√ºcksichtigt, dass ein Aufruf der <i>concat-</i> Methode den <i>Host-</i> String aufgrund der Unver√§nderlichkeit der Objekte vom Typ <i>String</i> nicht √§ndert.  Damit die Methode korrekt funktioniert, muss das Ergebnis der <i>concat-</i> Methode der <i>Hostvariablen</i> im <i>if-</i> Block zugewiesen werden.  Die richtige Version: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (port &gt; -<span class="hljs-number"><span class="hljs-number">1</span></span>) { host = host.concat(<span class="hljs-string"><span class="hljs-string">":"</span></span> + Integer.toString(port)); }</code> </pre> <br><h2>  Nicht verwendete Variablen </h2><br>  <a href="https://www.viva64.com/en/w/v6021/">V6021</a> Variable 'url' wird nicht verwendet.  TriggerV2Service.java (95) <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> ActionResponse </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">deleteAllTriggersForFunction</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String functionUrn)</span></span></span><span class="hljs-function"> </span></span>{ checkArgument(!Strings.isNullOrEmpty(functionUrn), ....); String url = ClientConstants.FGS_TRIGGERS_V2 + ClientConstants.URI_SEP + functionUrn; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> deleteWithResponse(uri(triggersUrlFmt, functionUrn)).execute(); }</code> </pre> <br>  In dieser Methode wird die <i>URL-</i> Variable nach ihrer Initialisierung nicht mehr verwendet.  H√∂chstwahrscheinlich muss die <i>URL-</i> Variable als zweites Argument anstelle von <i>functionUrn</i> an die <i>uri-</i> Methode √ºbergeben <i>werden</i> , da die <i>functionUrn-</i> Variable an der Initialisierung der <i>URL-</i> Variable beteiligt ist. <br><br><h2>  Das Argument hat den Konstruktor nicht verwendet </h2><br>  <a href="https://www.viva64.com/en/w/v6022/">V6022 Der</a> Parameter 'returnType' wird im Konstruktork√∂rper nicht verwendet.  HttpRequest.java (68) <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">HttpReQuest</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">R</span></span></span><span class="hljs-class">&gt; </span></span>{ .... Class&lt;R&gt; returnType; .... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">HttpRequest</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(...., Class&lt;R&gt; returnType)</span></span></span><span class="hljs-function"> </span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-comment">// &lt;= { this.endpoint = endpoint; this.path = path; this.method = method; this.entity = entity; } .... public Class&lt;R&gt; getReturnType() { return returnType; } .... }</span></span></span></span></code> </pre> <br>  In diesem Konstruktor hat der Programmierer vergessen, das <i>returnType-</i> Argument zu verwenden, und weist dem <i>returnType-</i> Feld seinen Wert zu.  Aus diesem Grund wird beim Aufrufen der Methode <i>getReturnType</i> aus dem von diesem Konstruktor erstellten Objekt standardm√§√üig <i>null</i> zur√ºckgegeben.  Am wahrscheinlichsten war es jedoch, dass der Programmierer beabsichtigte, das zuvor an den Konstruktor √ºbergebene Objekt abzurufen. <br><br><h2>  Gleiche Funktionalit√§t </h2><br>  <a href="https://www.viva64.com/en/w/v6032/">V6032</a> Es ist merkw√ºrdig, dass der Hauptteil der Methode 'enable' dem Hauptteil einer anderen Methode ' <a href="https://www.viva64.com/en/w/v6032/">disable</a> ' vollst√§ndig entspricht.  ServiceAction.java (32), ServiceAction.java (36) <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ServiceAction</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ModelEntity</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> String binary; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> String host; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ServiceAction</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String binary, String host)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.binary = binary; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.host = host; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> ServiceAction </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">enable</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String binary, String host)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// &lt;= return new ServiceAction(binary, host); } public static ServiceAction disable(String binary, String host) { // &lt;= return new ServiceAction(binary, host); } .... }</span></span></code> </pre> <br>  Zwei identische Methoden zu haben, ist kein Fehler, aber die Tatsache, dass zwei Methoden dieselbe Aktion ausf√ºhren, ist zumindest seltsam.  Wenn wir uns die Namen der oben genannten Methoden ansehen, k√∂nnen wir davon ausgehen, dass sie die entgegengesetzten Aktionen ausf√ºhren sollten.  Tats√§chlich tun beide Methoden dasselbe: Erstellen Sie das <i>ServiceAction-</i> Objekt und geben Sie es zur√ºck.  H√∂chstwahrscheinlich wurde die Methode disable durch Kopieren des Codes der Methode <i>enable</i> erstellt, der <i>Inhalt</i> der Methode blieb jedoch unver√§ndert. <br><br><h2>  Ich habe vergessen, die Hauptsache zu √ºberpr√ºfen </h2><br>  <a href="https://www.viva64.com/en/w/v6060/">V6060</a> Die Referenz 'params' wurde verwendet, bevor sie gegen null verifiziert wurde.  DomainService.java (49), DomainService.java (46) <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Domains </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">list</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Map&lt;String, String&gt; params)</span></span></span><span class="hljs-function"> </span></span>{ Preconditions.checkNotNull(params.get(<span class="hljs-string"><span class="hljs-string">"page_size"</span></span>), ....); Preconditions.checkNotNull(params.get(<span class="hljs-string"><span class="hljs-string">"page_number"</span></span>), ....); Invocation&lt;Domains&gt; domainInvocation = get(Domains.class, uri(<span class="hljs-string"><span class="hljs-string">"/domains"</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (params != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { <span class="hljs-comment"><span class="hljs-comment">// &lt;= .... } return domainInvocation.execute(this.buildExecutionOptions(Domains.class)); }</span></span></code> </pre> <br>  Bei dieser Methode hat der Autor beschlossen, den Inhalt einer Struktur vom Typ <i>Map</i> auf <i>null</i> zu pr√ºfen.  Zu diesem <i>Zweck</i> wird die Methode <i>get</i> vom Argument <i>params</i> zweimal <i>aufgerufen</i> .  Das Ergebnis der <i>get-</i> Methode wird an die <i>checkNotNull-</i> Methode √ºbergeben.  Alles scheint logisch, aber so ist es nicht!  Das Argument <i>params</i> wird in <i>if</i> auf <i>null</i> gepr√ºft.  Danach wird erwartet, dass das Eingabeargument m√∂glicherweise <i>null ist</i> , aber vor dieser √úberpr√ºfung wurde die <i>get-</i> Methode bereits zweimal von <i>params aufgerufen.</i>  Wenn <i>null</i> als Argument an diese Methode √ºbergeben wird, wird beim ersten Aufruf der <i>get-</i> Methode eine Ausnahme ausgel√∂st. <br><br>  Eine √§hnliche Situation tritt an drei anderen Orten auf: <br><br><ul><li>  V6060 Die Referenz 'params' wurde verwendet, bevor sie gegen null verifiziert wurde.  DomainService.java (389), DomainService.java (387) </li><li>  V6060 Die Referenz 'params' wurde verwendet, bevor sie gegen null verifiziert wurde.  DomainService.java (372), DomainService.java (369) </li><li>  V6060 Die Referenz 'params' wurde verwendet, bevor sie gegen null verifiziert wurde.  DomainService.java (353), DomainService.java (350) </li></ul><br><h2>  Fazit </h2><br>  Die heutigen gro√üen Unternehmen k√∂nnen nicht auf die Nutzung von Cloud-Diensten verzichten.  Eine gro√üe Anzahl von Menschen nutzt diese Dienste.  Aus dieser Sicht kann bereits ein kleiner Fehler in einem Service zu Problemen f√ºr viele Menschen sowie zu zus√§tzlichen Verlusten f√ºhren, die von einem Unternehmen angeh√§uft werden, um die nachteiligen Folgen dieses Fehlers zu beheben.  Menschliche Fehler sollten immer ber√ºcksichtigt werden, zumal fr√ºher oder sp√§ter jeder Fehler macht, wie in diesem Artikel beschrieben.  Diese Tatsache untermauert den Einsatz aller m√∂glichen Tools zur Verbesserung der Codequalit√§t. <br><br>  PVS-Studio wird das Huawei-Unternehmen auf jeden Fall √ºber die Ergebnisse der √úberpr√ºfung seiner Cloud-Dienste informieren, damit sich die Huawei-Entwickler mit ihnen befassen k√∂nnen, da die einmalige Verwendung der in diesem Artikel ( <a href="https://www.viva64.com/en/b/0594/">1</a> , <a href="https://www.viva64.com/en/b/0639/">2</a> ) beschriebenen statischen Code-Analyse nicht vollst√§ndig demonstrieren kann all seine vorteile.  Sie k√∂nnen den PVS-Studio Analyzer <a href="https://www.viva64.com/en/pvs-studio-download/">hier</a> herunterladen. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de477558/">https://habr.com/ru/post/de477558/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de477544/index.html">So erstellen Sie ein 2D-Spiel mit Python und einer Arcade-Bibliothek</a></li>
<li><a href="../de477548/index.html">Lernen Sie Bootstrap mit 10 n√ºtzlichen Tipps</a></li>
<li><a href="../de477550/index.html">SPS-2019 auf dem N√ºrnberger Messegel√§nde</a></li>
<li><a href="../de477552/index.html">Tests von Ryzen Threadripper 3960X und 3970X haben gezeigt, dass sie wirklich revolution√§re CPUs sind</a></li>
<li><a href="../de477554/index.html">Die .ORG Domain Zone wird an eine private Firma verkauft. Die √ñffentlichkeit fordert die ICANN auf, den Vertrag zu k√ºndigen</a></li>
<li><a href="../de477560/index.html">√Ñndern Sie Ihre Einstellung mit SwiftUI</a></li>
<li><a href="../de477562/index.html">Interface-Design f√ºr das Spiel, zeichnen Sie eine Reihe von Symbolen</a></li>
<li><a href="../de477564/index.html">Komplexe Kunden: So sch√ºtzen Sie Ihr Team vor ihnen</a></li>
<li><a href="../de477566/index.html">Huawei Cloud: Heute ist es in PVS-Studio bew√∂lkt</a></li>
<li><a href="../de477568/index.html">Der Service ist einfach bedingungslose R√ºckgabe. Russische Post</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>