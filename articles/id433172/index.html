<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🛌🏽 ⛺️ 🤝 Kami kencangkan multipemain ke game seluler "Buat kata-kata dari kata-kata" di iOS dan Android, ditulis dalam C ++ 🌋 🧗🏾 😞</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Sebelumnya, saya menulis tentang pengalaman saya dalam mengembangkan permainan kata seluler di Android dan iOS, yang sangat populer, dan saya memutusk...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Kami kencangkan multipemain ke game seluler "Buat kata-kata dari kata-kata" di iOS dan Android, ditulis dalam C ++</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/433172/">  Sebelumnya, saya menulis tentang pengalaman saya dalam mengembangkan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">permainan kata</a> seluler di Android dan iOS, yang sangat populer, dan saya memutuskan untuk mengencangkan mode multipemain ke sana, ketika dua pemain bersaing di antara mereka sendiri, menulis kata-kata pada gilirannya, sebagai putaran terakhir dari siaran televisi Sergey Suponev. jam. " <br><br><img src="https://habrastorage.org/webt/kk/v7/fw/kkv7fwu9wif6l37aoqmyzcp3gjm.png"><br><br>  Butuh waktu satu setengah bulan untuk mempelajari dan mengimplementasikan multiplayer, dalam artikel ini saya akan mencoba untuk menggambarkan konsep tanpa contoh-contoh kode sumber, membuat memeras dari jumlah pekerjaan yang dilakukan. <br><a name="habracut"></a><br><h3>  Sedikit sejarah </h3><br>  Aplikasi ini ditulis dalam C ++ menggunakan Marmalade SDK.  Sejak itu, vendor telah berhenti mendukung platform ini, menjual barang-barang tersebut ke Jepang, dan masa depan lingkungan pengembangan ini menjadi sangat kabur. <br><br><img src="https://habrastorage.org/webt/sa/c4/fy/sac4fyzpnydiynvhugn1fl8olww.jpeg"><br><br>  Muncul pertanyaan tentang apa yang akan dikirimi proyek saat ini untuk dukungan lebih lanjut. <br><br><h3>  Kenapa tidak cocos2d-x </h3><br><img src="https://habrastorage.org/webt/il/dh/fn/ildhfnxa9jhrtc31jiw-sf5b6zm.png"><br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Cocos2d-x</a> adalah salah satu mesin pengembangan game mobile lintas platform C ++ yang paling umum.  Rupanya, karena kode sumbernya gratis dan terbuka.  Mesinnya tidak terdokumentasi dengan baik.  Deskripsi tersebut mencakup bagian mesin yang sedikit dan sebagian besar material sudah usang. <br><br>  Berdasarkan hasil periode, saya masih berhasil membuat prototipe aplikasi saya.  Tapi kesan itu sangat buruk: rasanya seperti cocos2d-x dipasang di lutut.  Tingkat adegan abstraksi, Sprite, Delegasi Aplikasi bagi saya terasa sangat tidak nyaman, dan kebutuhan untuk mencari jawaban atas pertanyaan di forum kelapa semakin membuat Anda berpikir bahwa Anda melakukan sesuatu yang salah.  Mungkin tangan saya tumbuh dari tempat yang salah. <br><br><h3>  Pilihan saya jatuh pada SDL </h3><br><img src="https://habrastorage.org/webt/4q/a4/vf/4qa4vfo-qzvtxas0a6egqpqknjk.png"><br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">SDL</a> , seperti Marmalade SDL, bukan mesin, ini platform.  Ini menyediakan API tingkat rendah, dari mana saya kemudian membangun tingkat abstraksi yang nyaman bagi saya.  Semua ini ditulis dalam C, kode sumbernya terbuka. <br><br>  Singkatnya, SDL adalah perpustakaan lintas platform gratis untuk bekerja dengan grafik, suara, dan memproses pesan dari sistem operasi.  Sangat mudah untuk membuat win32-build dan men-debug logika game di Windows, hanya untuk emulator seluler dan perangkat fisik yang hanya men-debug fungsi OS khusus. <br><br>  Untungnya atau sayangnya, SDL tidak menyediakan alat untuk tugas sesempit itu seperti mengembangkan multiplayer untuk iOS dan Android, jadi saya harus mengintegrasikan sendiri layanan yang sesuai. <br><br><h3>  Arsitektur Aplikasi Multithreaded </h3><br>  Logika aplikasi dan semua pekerjaan dengan grafis diimplementasikan di utas utama, yang merupakan siklus pemrosesan pesan dan dimulai pada fungsi utama.  Sebut aliran ini SDL Thread.  Utas lainnya, pada gilirannya, melempar acara (SDL_PushEvent) untuk diproses ke dalam antrian, dan ia membacanya dari sana menggunakan SDL_WaitEvent dan SDL_PollEvent.  Ini adalah salah satu peristiwa sistem yang dilemparkan oleh sistem dan dukungan yang sudah diterapkan di SDL, atau panggilan Callbacks dan Listener-s, yang kami implementasikan sudah melampaui fungsi SDL. <br><br><img src="https://habrastorage.org/webt/cr/li/-r/crli-rojztdxy1p7fhqhiqa0jru.png"><br><br>  Semua logika game ditulis dalam C ++.  Direktori proyek berisi sekumpulan file * .cpp yang dapat dibagi menjadi tiga grup: <br><br><ul><li>  cross-platform - file-file yang termasuk dalam perakitan semua platform (logika game); </li><li>  monoplatform, mis.  termasuk dalam aplikasi platform apa saja untuk mengimplementasikan fitur-fiturnya. </li></ul><br>  Dengan demikian, ada tiga direktori terpisah untuk desain setiap platform: <br><br><ul><li>  proj.win32 - proyek VS2017 Edisi Komunitas; </li><li>  proj.android - proyek Android menggunakan Gradle; </li><li>  proj.ios - proyek Xcode untuk iOS. </li></ul><br><h3>  Integrasi dengan layanan multi-pemain </h3><br>  Sekarang kita perlu merekatkan lapisan terpisah, yang akan bertanggung jawab untuk fungsi seperti: <br><br><ul><li>  mencari lawan, koneksi ke permainan; </li><li>  olahpesan di antara pesaing; </li><li>  keluar dari ruang permainan; </li><li>  memperbaiki poin pemain di Papan Peringkat. </li></ul><br>  Kedua platform iOS dan Android mendukung Real-time Multiplayer (RTMP).  Dalam kasus Android, kami berintegrasi dengan Google Play Services (GPS), dalam kasus iOS, Game Center.  Sebelumnya, Google mendukung integrasi dengan iOS, tetapi tahun ini memutuskan untuk mengabaikannya. <br><br>  Dalam artikel ini, saya tidak akan menjelaskan tindakan yang perlu Anda lakukan di Google Play Console dan AppStoreConnect untuk mengkonfigurasi multiplayer, saya tidak akan menjelaskan spesifikasi kelas dan metode integrasi - semua ini dijelaskan di situs vendor. <br><br>  Selanjutnya, saya akan menjelaskan secara singkat perubahan apa yang perlu dilakukan dalam proyek untuk setiap platform. <br><br><h4>  Android </h4><br>  Bagaimana?  Saya belum mengatakan ini?  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Android NDK</a> digunakan untuk mengkompilasi kode C ++.  Meskipun, jika Anda adalah pengembang Android, Anda sudah tahu. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Petunjuk umum</a> untuk mengintegrasikan Layanan Google Play ke proyek Android dijelaskan di situs untuk pengembang Android.  Dalam proyek saya, saya menggunakan dependensi berikut: <br><br><pre><code class="json hljs">implementation 'com.google.android.gms:play-services-games:<span class="hljs-number"><span class="hljs-number">16.0</span></span><span class="hljs-number"><span class="hljs-number">.0</span></span>' implementation 'com.google.android.gms:play-services-nearby:<span class="hljs-number"><span class="hljs-number">16.0</span></span><span class="hljs-number"><span class="hljs-number">.0</span></span>' implementation 'com.google.android.gms:play-services-auth:<span class="hljs-number"><span class="hljs-number">16.0</span></span><span class="hljs-number"><span class="hljs-number">.1</span></span>'</code> </pre> <br>  Awalnya, idenya adalah menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">api C ++</a> , yang datang dalam bentuk pustaka statis terkompilasi tanpa sumber.  Karena kenyataan bahwa tidak ada perakitan untuk platform x86_64 dalam daftar perpustakaan, saya memutuskan bahwa orang-orang dari Google tidak benar-benar memantau relevansi SDK ini dan memutuskan untuk <s>menciptakan sepeda mereka</s> untuk menulis lapisan ini di Jawa, membungkusnya dengan pembungkus <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">JNI</a> .  Dan kemudian, mengapa saya perlu ketergantungan ekstra dalam bentuk libs tanpa kode sumber yang di dalam Jawa masih menarik Java?  Selain relevansi kelas Java, Anda juga harus memantau relevansi lib ini. <br><br>  Sebagai panduan, saya menggunakan contoh yang baik dari <a href="">Google Samples</a> .  Terima kasih kepada Google untuk ini.  Apple, ambil contoh dari Google! <br><br><h4>  iOS </h4><br>  Untuk berintegrasi dengan Game Center, Anda harus menghubungkan kerangka kerja GameKit.  Kami menjelaskan seluruh lapisan integrasi dengan Game Center dalam satu file * .m dan menyediakan antarmuka untuknya melalui file * .h yang terpisah.  Karena C ++ adalah bagian dari bahasa objektif-C, tidak akan ada masalah dengan perakitan file * .cpp dan * .m dalam satu proyek. <br><br>  Selain <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dokumentasi resmi, ia</a> dipandu oleh proyek ini: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">GameCenterManager</a> .  Benar, beberapa hal dari contoh sudah usang, Xcode 10 akan memberi tahu Anda hal ini dan Anda akan mengganti fungsionalitas yang sudah ketinggalan zaman dengan yang baru. <br><br><h3>  Prinsip bekerja dengan lapisan Multiplayer </h3><br><h4>  Titik masuk tunggal </h4><br>  Setelah mempelajari fitur-fitur bekerja dengan multi-pemain pada kedua platform, saya membuat satu asbstraksi C ++ tunggal untuk aplikasi saya dan pada saat kompilasi, implementasi yang sesuai “cocok”, tergantung pada platform tertentu.  Artinya, aplikasi saya tidak tahu tentang Google Play Services, Game Center, dan fitur-fiturnya.  Hanya tahu api C ++ yang disediakan untuknya, di mana misalnya, ada metode seperti: <br><br><pre> <code class="cpp hljs">SignIn() <span class="hljs-comment"><span class="hljs-comment">//     SignOut() //     LeaveRoom() //    SendMessage(...) //    ShowLeaderboards() //    SubmitScore(...) //    ...</span></span></code> </pre><br><h4>  Cari lawan </h4><br>  Pemain dapat mengundang teman dari daftar kontaknya, atau memulai permainan dengan lawan acak.  Pemain yang menerima undangan dapat menerima atau menolaknya.  Untuk semua skenario ini, saya menggunakan antarmuka standar dari layanan yang digunakan.  Saya ingin mencatat bahwa moncong Google terlihat jauh lebih baik iOS iOS.  Mungkin suatu hari tangan saya akan sampai di sana dan saya akan menulis antarmuka saya dengan kartu domino dan wanita muda. <br><br><h4>  Koneksi ke ruang permainan </h4><br>  Ketika dua pemain terhubung ke ruang permainan virtual, mereka menerima Callback yang sesuai.  Sekarang Anda harus memilih siapa yang akan menjadi tuan rumah. <br><br><h4>  Seleksi tuan rumah </h4><br>  Di antara pemain Anda harus memilih tuan rumah, sehingga ia menentukan kondisi awal permainan. <br>  Pertimbangkan cara-cara yang memungkinkan untuk merutekan pesan antar pemain dalam kasus umum.  Harap dicatat bahwa dalam perwujudan kedua, tuan rumah juga diberi peran sebagai router. <br><br><img src="https://habrastorage.org/webt/zl/u8/qu/zlu8qufestbs25fic3j8ajfn2w8.png"><br><br>  Karena saya selalu memiliki hanya dua pemain dalam permainan, ternyata saya memiliki kasus khusus koneksi peer-to-peer.  Dan oleh karena itu, hanya definisi dari keadaan awal jatuh pada peran tuan rumah, yaitu, pilihan kata dari mana kata-kata akan disusun. <br><br>  Jadi, setelah pemain terhubung ke ruang permainan, masing-masing pemain mengetahui daftar pengidentifikasi peserta permainan yang telah dimulai.  Kami akan menyebutnya daftar <b>participantID</b> .  participantID adalah pengenal string tertentu dari peserta game, yang ditugaskan oleh layanan.  Anda harus memilih yang mana dari mereka yang akan menjadi tuan rumah, bawalah ini ke tuan rumah itu sendiri dan beri tahu yang lain bahwa lawannya dipilih sebagai tuan rumah.  Bagaimana cara melakukannya? <br><br><h5>  Pilihan host Android </h5><br>  Saya tidak menemukan saran untuk memilih host di google dock.  Mereka diam, partisan.  Tetapi orang-orang baik di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">stackoverflow.com</a> melemparkan tautan ke <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">video tersebut</a> , yang menjelaskan prinsip berikut secara rinci: <br><br><ul><li>  setiap peserta mengurutkan daftar participantID (naik atau turun - tidak masalah, yang utama adalah bahwa setiap orang melakukannya dalam urutan yang sama); </li><li>  setiap peserta membandingkan ID partisipan dengan ID peserta pertama dari daftar; </li><li>  jika mereka cocok, maka pemain saat ini diberikan hak untuk memilih siapa yang akan menjadi tuan rumah.  Dia <s>melempar koin,</s> menarik acak (), sehingga memilih tuan rumah dari peserta yang ada, dan memberi tahu semua orang yang menjadi tuan rumah. </li></ul><br><h5>  Seleksi host di iOS </h5><br>  Untuk iOS, ada metode <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">selectBestHostPlayerWithCompletionHandler</a> , yang sangat menyederhanakan skenario pemilihan host dibandingkan dengan apa yang saya jelaskan untuk Android.  Tetapi menilai dari keterlambatan nyata selama panggilan ke metode ini, ia memperkirakan parameter respon dari jaringan, mengukur ping, dan berdasarkan statistik ini memutuskan siapa yang harus menjadi tuan rumah.  Ini lebih mungkin untuk arsitektur client-server di atas, di mana tuan rumah bertindak sebagai router.  Dalam versi saya dari koneksi peer-to-peer pribadi, ini tidak masuk akal, dan untuk menghemat waktu, saya menggunakan prinsip yang mirip dengan apa yang saya lakukan untuk Android. <br><br><h4>  Perpesanan antar pemain </h4><br>  Apa itu pesan?  Pesan adalah array byte. <br><br><ul><li>  di java, ini adalah tipe: <pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[]</code> </pre> </li><li>  dalam objektif-C, ini adalah: <pre> <code class="objectivec hljs"><span class="hljs-built_in"><span class="hljs-built_in">NSData</span></span> *</code> </pre> </li><li>  di C ++, saya memetakan semua hal di atas ke <pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;Uint8&gt;</code> </pre> </li></ul><br>  Ada 2 jenis pengiriman pesan: <br><br><ul><li>  Andal - pengiriman terjamin melalui antrian.  Digunakan untuk mengirimkan pesan penting. </li><li>  Tidak dapat diandalkan - pengiriman tidak dijamin.  Pesan bekas yang keberhasilan pengirimannya dapat diabaikan. </li></ul><br>  Tidak dapat diandalkan biasanya disampaikan lebih cepat daripada Handal.  Anda dapat membaca lebih lanjut di situs web vendor: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Layanan Google Play: Multiplayer Real-time</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Panduan Pemrograman Game Center: Pertandingan Real-Time</a> </li></ul><br>  Bagaimana kita akan menggunakan array ini?  Sangat sederhana: <br><br><ul><li>  pada byte pertama kita akan menulis jenis pesan. </li><li>  jika pesan memiliki parameter, maka kita akan memasukkannya dalam byte berikut.  Untuk setiap jenis pesan yang telah ditambahkan.  parameter, kami menerapkan fungsi serialisasi dan deserialization kami. </li><li>  di akhir pesan untuk memeriksa integritas kami akan menempatkan sebuah checksum. </li></ul><br>  Jadi, kami mendefinisikan <b>enum</b> dengan jenis pesan yang akan ditukar pemain di antara mereka sendiri selama pertandingan: <br><br><ul><li>  Saya dipilih oleh tuan rumah.  Saya menyampaikan keadaan awal.  Sekarang giliranku (parameter: nomor versi protokol pengiriman pesan, kata sumber); </li><li>  Anda dipilih oleh tuan rumah.  Saya berharap dapat mendengar dari Anda; </li><li>  Saya membuka (memanggil) kata itu.  Sekarang giliran Anda (parameter: kata bernama); </li><li>  Saya menyerah.  Anda telah menang; </li><li>  Saya tidak bisa mengucapkan sepatah kata pun selama beraktivitas.  Anda telah menang; </li><li>  Saya setuju untuk membalas dendam; </li><li>  Saya keluar dari game; </li><li>  Kesalahan saat menguraikan pesan.  Terputus; </li><li>  Versi protokol pengiriman pesan Anda kedaluwarsa.  Periksa pembaruan aplikasi.  Terputus; </li><li>  Versi protokol pengiriman pesan saya kedaluwarsa.  Perlu memeriksa pembaruan.  Terputus; </li><li>  Ping (pesan sistem); </li></ul><br>  Ketika aplikasi menerima pesan masuk dari lawan, Callback yang sesuai dipanggil, yang pada gilirannya meneruskannya ke Thread SDL utama untuk diproses. <br><br><h4>  Pemantauan koneksi </h4><br>  Layanan game (layanan Google, layanan Apple) memiliki fungsi pendengar yang dalam satu atau lain bentuk dirancang untuk memberi tahu kami tentang pemutusan sambungan dari lawan.  Tapi, saya perhatikan bahwa jika salah satu pemain terputus dari Internet, maka yang kedua tidak segera mengenali bahwa yang pertama telah terputus dan tidak ada yang bisa bermain.  Callback tidak dipanggil dalam kasus seperti itu, atau dipanggil setelah waktu yang agak lama.  Sehingga dalam hal ini pemain kedua tidak menunggu kanker bersiul di gunung, saya harus melakukan pemantauan sendiri koneksi, bekerja pada prinsip: <br><br><ul><li>  Setiap pemain mengirim pesan ping ke lawan setiap detik; </li><li>  Setiap pemain memeriksa: jika tidak ada pesan dari lawan selama lebih dari 5 detik, maka koneksi terputus, kami keluar dari permainan. </li></ul><br><h3>  Hasil </h3><br>  Sebagai hasil dari pekerjaan yang dilakukan, saya mendapat permainan yang saya mainkan sendiri dengan teman dan keluarga saya.  Saya bermain di iOS dan Android. <br><br>  Benar, ada nuansa pada iOS - untuk beberapa alasan, kacamata tidak diperbaiki di Papan, tentang yang saat ini saya korespondensi dengan dukungan Apple. <br><br>  Saya harap artikel ini bermanfaat bagi anggota tim saya dan mereka yang tertarik mengembangkan aplikasi mobile.  Terima kasih atas perhatian anda </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id433172/">https://habr.com/ru/post/id433172/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id433158/index.html">Parodi musik dari SUSE tentang Kubernetes, Linus Torvalds, dan lainnya</a></li>
<li><a href="../id433164/index.html">Fast and the Furious: Forza Horizon 4 Mempercepat dengan Window Shaders</a></li>
<li><a href="../id433166/index.html">Memprediksi Solusi Tiket Waktu Menggunakan Machine Learning</a></li>
<li><a href="../id433168/index.html">Mengapa seorang programmer memiliki magang di dapur - percakapan dengan Dodo Pizza tentang gemba, .NET, dan keterbukaan</a></li>
<li><a href="../id433170/index.html">Bagaimana kami tidak bisa mengulang arsitektur perusahaan</a></li>
<li><a href="../id433174/index.html">Tidak semua tambalan sama-sama bermanfaat.</a></li>
<li><a href="../id433176/index.html">Certificate Remote Authentication Docker Remote dengan verifikasi pencabutan</a></li>
<li><a href="../id433178/index.html">Bagaimana kami memulihkan file .wav yang rusak</a></li>
<li><a href="../id433180/index.html">Memecahkan masalah tipe data di Ruby atau Membuat data kembali dapat diandalkan</a></li>
<li><a href="../id433182/index.html">Apakah mungkin untuk melatih agen untuk perdagangan di pasar saham dengan bala bantuan? Implementasi bahasa R</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>