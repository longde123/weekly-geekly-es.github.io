<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë©‚Äçüöí üë©üèº üë©üèø‚Äçü§ù‚Äçüë©üèº √â f√°cil adicionar novos recursos √† estrutura antiga? Farinha de escolha no exemplo do desenvolvimento do SObjectizer üï§ üç© üî£</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="O desenvolvimento de uma estrutura livre para as necessidades dos desenvolvedores √© um t√≥pico espec√≠fico. Se, ao mesmo tempo, a estrutura viver e se d...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>√â f√°cil adicionar novos recursos √† estrutura antiga? Farinha de escolha no exemplo do desenvolvimento do SObjectizer</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/423879/"><img src="https://habrastorage.org/webt/en/lw/bb/enlwbb8hjnjmprjbfysbwsnejiy.jpeg"><br><br>  O desenvolvimento de uma estrutura livre para as necessidades dos desenvolvedores √© um t√≥pico espec√≠fico.  Se, ao mesmo tempo, a estrutura viver e se desenvolver por um per√≠odo bastante longo, as especificidades ser√£o adicionadas.  Hoje vou tentar mostrar isso usando um exemplo de uma tentativa de expandir a funcionalidade de uma estrutura de "ator" para C ++ chamada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">SObjectizer</a> . <br><br>  O fato √© que esse quadro j√° √© bastante antigo, mudou drasticamente v√°rias vezes.  At√© sua encarna√ß√£o atual, SObjectizer-5, passou por muitas mudan√ßas, tanto graves quanto n√£o.  Al√©m disso, somos bastante sens√≠veis √† compatibilidade e a introdu√ß√£o de altera√ß√µes que quebram a compatibilidade √© um passo muito s√©rio para que possamos decidir sobre isso. <br><br>  No momento, precisamos decidir como adicionar um novo recurso √† pr√≥xima vers√£o.  No processo de encontrar uma solu√ß√£o adequada, duas op√ß√µes surgiram.  Ambos parecem bastante realiz√°veis.  Mas eles s√£o muito diferentes um do outro.  Tanto em termos de complexidade e complexidade de implementa√ß√£o, quanto em sua "apar√™ncia".  I.e.  o que o desenvolvedor ir√° lidar ser√° diferente em cada uma das op√ß√µes.  Provavelmente at√© fundamentalmente diferente. <br><br>  E agora, como desenvolvedores da estrutura, temos que fazer uma escolha em favor de uma ou outra solu√ß√£o.  Ou √© preciso admitir que nenhum deles √© satisfat√≥rio e, portanto, algo mais precisa ser inventado.  Tais decis√µes durante a hist√≥ria do SObjectizer tiveram que ser tomadas mais de uma vez.  Se algu√©m estiver interessado em se sentir no lugar do desenvolvedor de tal estrutura, voc√™ ser√° bem-vindo ao gato. <br><a name="habracut"></a><br><h1>  Problema original </h1><br>  Ent√£o, brevemente, a ess√™ncia do problema original.  Desde o in√≠cio de sua exist√™ncia, o SObjectizer tinha o seguinte recurso: uma mensagem de timer n√£o √© t√£o f√°cil de cancelar.  Sob o temporizador ser√° entendido, em primeiro lugar, uma mensagem atrasada.  I.e.  uma mensagem que n√£o deve ser enviada imediatamente ao destinat√°rio, mas depois de algum tempo.  Por exemplo, enviamos_delayed com uma pausa de 1s.  Isso significa que, na realidade, a mensagem ser√° enviada pelo timer 1s ap√≥s a chamada send_delayed. <br><br>  Uma mensagem pendente pode, em princ√≠pio, ser cancelada.  Se a mensagem ainda estiver na posse do cron√¥metro, a mensagem ap√≥s o cancelamento n√£o ser√° levada a lugar algum.  Ser√° lan√ßado pelo cron√¥metro e √© isso.  Mas se o cron√¥metro j√° enviou uma mensagem e agora est√° na fila de solicita√ß√µes do agente receptor, o cancelamento do cron√¥metro n√£o funcionar√°.  N√£o h√° mecanismo no SObjectizer para remover uma mensagem da fila do aplicativo. <br><br>  O problema √© composto por pelo menos dois fatores. <br><br>  Em primeiro lugar, o SObjectizer suporta a entrega no modo 1: N, ou seja,  se a mensagem foi enviada para a mbox Multi-Consumidor, a mensagem n√£o estar√° em uma fila, mas em v√°rias filas para N destinat√°rios ao mesmo tempo. <br><br>  Em segundo lugar, o SObjectizer usa um mecanismo de expedidor e os expedidores podem ser muito diferentes, incluindo aqueles escritos pelo usu√°rio para suas necessidades espec√≠ficas.  As filas de pedidos s√£o gerenciadas pelos despachantes.  E na interface do expedidor n√£o h√° funcionalidade para retirar um aplicativo que j√° foi transferido para o expedidor.  Mas, mesmo que essa funcionalidade tenha sido incorporada √† interface, est√° longe de ser poss√≠vel implement√°-la efetivamente em todos os casos.  Sem mencionar o fato de que essa funcionalidade aumentaria a complexidade do desenvolvimento de novos despachantes. <br><br>  Em geral, objetivamente, se o cron√¥metro j√° enviou uma mensagem pendente ao (s) destinat√°rio (s), for√ßar o SObjectizer a n√£o entregar essa inst√¢ncia da mensagem √© atualmente imposs√≠vel. <br><blockquote>  De fato, esse problema tamb√©m √© relevante para mensagens peri√≥dicas (ou seja, mensagens que o timer deve enviar periodicamente em intervalos de tempo predeterminados).  Mas, na pr√°tica, cancelar mensagens peri√≥dicas √© muito menos necess√°rio do que cancelar uma mensagem pendente.  Pelo menos em nossa pr√°tica √© assim. </blockquote><h2>  O que pode ser feito agora? </h2><br>  Portanto, esse problema n√£o √© novo e, por um longo tempo, h√° recomenda√ß√µes sobre como lidar com ele. <br><br><h3>  ID exclusivo dentro da mensagem pendente </h3><br>  A maneira mais f√°cil √© manter um balc√£o.  O agente possui um contador; ao enviar uma mensagem pendente, o valor atual do contador √© enviado na mensagem.  Quando uma mensagem √© cancelada, o contador no agente √© incrementado.  Ap√≥s o recebimento da mensagem, o valor atual do contador no agente √© comparado com o valor da mensagem.  Se os valores n√£o corresponderem, a mensagem ser√° rejeitada: <br><br><pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">demo_agent</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> so_5::<span class="hljs-keyword"><span class="hljs-keyword">agent_t</span></span> { <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">delayed_msg</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">final</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> id_; ... }; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> expected_msg_id_{}; so_5::<span class="hljs-keyword"><span class="hljs-keyword">timer_id_t</span></span> timer_; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">on_some_event</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//   . //   send_periodic, ..    //  timer_id   . timer_ = so_5::send_periodic&lt;delayed_msg&gt;(*this, 25s, //     . 0s, //    . //      delayed_msg, //      id   . ++expected_msg_id_, ... //  . ); ... } void on_cancel_event() { //   ,        //   .   : timer_.reset(); //     . ++expected_msg_id_; //   id-. ... } void on_delayed_msg(mhood_t&lt;delayed_msg&gt; cmd) { //     id    //  . if(expected_msg_id_ == cmd-&gt;id_) { ... //  . } } };</span></span></code> </pre> <br>  O problema com esse m√©todo √© que o desenvolvedor do agente precisa ficar intrigado mantendo esses contadores.  E se, como uma mensagem atrasada, precisamos enviar a mensagem de outra pessoa que outra pessoa enviou e na qual n√£o h√° campo id_, ent√£o nos encontramos em uma situa√ß√£o dif√≠cil. <br><br>  Embora, por outro lado, essa seja a maneira mais eficaz que existe atualmente. <br><br><h3>  Use mbox exclusivo para mensagens atrasadas </h3><br>  Outra maneira que funciona bem √© usar uma caixa de correio exclusiva (mbox) para uma mensagem atrasada.  Nesse caso, criamos uma nova mbox para cada mensagem pendente, assinamos e enviamos a mensagem pendente para essa mbox.  Quando uma mensagem precisa ser cancelada, simplesmente exclu√≠mos as assinaturas da mbox. <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">demo_agent</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> so_5::<span class="hljs-keyword"><span class="hljs-keyword">agent_t</span></span> { <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">delayed_msg</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">final</span></span></span><span class="hljs-class"> {</span></span> ... <span class="hljs-comment"><span class="hljs-comment">//   id_   . }; so_5::mbox_t timer_mbox_; //   . so_5::timer_id_t timer_; void on_some_event() { //        mbox //     . timer_mbox_ = so_environment().create_mbox(); some_state.event(time_mbox_, ...); another_state.event(time_mbox_, ...); ... //    . timer_ = so_5::send_delayed&lt;delayed_msg&gt;( so_environment(), timer_mbox_, //     . 25s, 0s, ... //    delayed_msg. ); } void on_cancel_event() { //        mbox. timer_.reset(); so_drop_subscription_for_all_states(timer_mbox_); } void on_delayed_msg(mhood_t&lt;delayed_msg&gt; cmd) { //     ,   //    . ... } };</span></span></code> </pre> <br>  Esse m√©todo j√° pode funcionar com mensagens de outras pessoas, nas quais n√£o h√° identificador exclusivo.  Mas tamb√©m requer trabalho e aten√ß√£o do desenvolvedor. <br><br>  Por exemplo, na modalidade acima, n√£o h√° prote√ß√£o contra o fato de que uma mensagem pendente j√° foi enviada anteriormente.  De uma maneira boa, antes de enviar uma nova mensagem pendente, voc√™ sempre deve executar a√ß√µes de on_cancel_event (), caso contr√°rio, o agente ter√° assinaturas desnecess√°rias. <br><br><h2>  Por que esse problema n√£o foi resolvido antes? </h2><br>  Tudo √© bem simples aqui: na verdade, esse n√£o √© um problema t√£o s√©rio quanto possa parecer.  Pelo menos na vida real, voc√™ n√£o precisa lidar com isso com frequ√™ncia.  Normalmente, as mensagens pendentes e peri√≥dicas n√£o s√£o canceladas (e √© por isso que, a prop√≥sito, a fun√ß√£o send_delayed n√£o retorna timer_id).  E quando surgir a necessidade de cancelamento, voc√™ poder√° usar um dos m√©todos descritos acima.  Ou at√© mesmo usar outro.  Por exemplo, crie agentes separados que processar√£o uma mensagem pendente.  Esses agentes podem ser cancelados o registro quando uma mensagem pendente precisar ser cancelada. <br><br>  Portanto, no contexto de outras tarefas que nos confrontavam, simplificar o cancelamento garantido de uma mensagem pendente n√£o era t√£o priorit√°rio quanto gastar nossos recursos na solu√ß√£o desse problema. <br><br><h2>  Por que o problema √© relevante agora? </h2><br>  Tudo √© t√£o simples aqui.  Por um lado, as m√£os finalmente alcan√ßaram. <br><br>  Por outro lado, quando novas pessoas que n√£o tiveram experi√™ncia em trabalhar com ele come√ßaram a usar o SObjectizer, esse recurso com o cancelamento de temporizadores os surpreende bastante.  N√£o que agradavelmente surpreendente.  Se sim, gostaria de minimizar as impress√µes negativas de conhecer nossa ferramenta. <br><br>  Al√©m disso, t√≠nhamos nossas pr√≥prias tarefas, n√£o precis√°vamos constantemente cancelar mensagens pendentes.  E os novos usu√°rios t√™m suas pr√≥prias tarefas, talvez tudo seja o contr√°rio. <br><br><h1>  Nova declara√ß√£o do problema </h1><br>  Quase imediatamente, assim que come√ßou a considera√ß√£o da possibilidade de um "cancelamento garantido do temporizador", pensei em que a tarefa poderia ser expandida.  Voc√™ pode tentar resolver o problema de recuperar qualquer uma das mensagens enviadas anteriormente, n√£o necessariamente atrasadas e peri√≥dicas. <br><br>  De tempos em tempos, essa oportunidade √© procurada.  Por exemplo, imagine que temos v√°rios agentes interagindo de dois tipos: entry_point (aceita solicita√ß√µes de clientes) e processador (processa solicita√ß√µes): <br><br><img src="https://habrastorage.org/webt/s7/mo/jp/s7mojpeyu9s6prshykrqxul14he.png"><br><br>  Os agentes Entry_point enviam solicita√ß√µes ao agente do processador, que os processa o m√°ximo poss√≠vel e responde aos agentes do entry_point.  Mas, √†s vezes, o entry_point pode achar que o processamento de uma solicita√ß√£o enviada anteriormente n√£o √© mais necess√°rio.  Por exemplo, o cliente enviou um comando de cancelamento ou "caiu" e voc√™ n√£o precisa mais processar suas solicita√ß√µes.  Agora, se as mensagens de solicita√ß√£o estiverem na fila pelo agente do processador, n√£o ser√° poss√≠vel recuper√°-las.  E seria √∫til. <br><br>  Portanto, a abordagem atual para resolver o problema do "cancelamento garantido do temporizador" √© realizada precisamente como adi√ß√£o de suporte para "mensagens de rechamada".  Enviamos qualquer mensagem de uma maneira especial, temos uma al√ßa na m√£o, com a qual voc√™ pode recuperar a mensagem.  E n√£o √© t√£o importante se uma mensagem regular ou atrasada responde. <br><br><h1>  Uma tentativa de propor a implementa√ß√£o de "rechamar mensagens" </h1><br>  Portanto, voc√™ precisa introduzir o conceito de "mensagem de rechamada" e apoiar esse conceito no SObjectizer.  E assim, permanecer no ramo 5.5.  A primeira vers√£o deste segmento, 5.5.0, saiu quase quatro anos atr√°s, em outubro de 2014.  Desde ent√£o, n√£o houve grandes mudan√ßas no 5.5.  Projetos que j√° foram trocados ou iniciados imediatamente no SObjectize-5.5 podem mudar para novas vers√µes na ramifica√ß√£o 5.5 sem problemas.  Essa compatibilidade deve ser mantida neste momento. <br><br>  Em geral, tudo √© simples: voc√™ precisa pegar e fazer. <br><br><h2>  O que est√° claro como fazer </h2><br>  Ap√≥s a primeira abordagem do problema, duas coisas ficaram claras sobre a implementa√ß√£o de "rechamar mensagens". <br><br><h3>  Sinalizador at√¥mico e sua verifica√ß√£o antes do processamento da mensagem </h3><br>  Em primeiro lugar, √© √≥bvio que dentro da estrutura da arquitetura atual do SObjectizer-5.5 (e talvez ainda mais globalmente: dentro da estrutura dos princ√≠pios do pr√≥prio SObjectizer-5), √© imposs√≠vel remover mensagens das filas de solicita√ß√£o do despachante, onde as mensagens aguardam at√© que os agentes receptores as processem.  Tentar fazer isso eliminar√° toda a ideia de despachantes heterog√™neos, que at√© o usu√°rio pode fazer por conta pr√≥pria, de acordo com as especificidades de sua tarefa (por exemplo, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">esta</a> ).  Al√©m disso, no caso de enviar uma mensagem no modo 1: N, onde N ser√° grande, ser√° caro manter uma lista de ponteiros para uma inst√¢ncia da mensagem enviada em todas as filas. <br><br>  Isso significa que, juntamente com a mensagem, algum tipo de sinalizador at√¥mico deve ser transmitido, que precisar√° ser analisado imediatamente ap√≥s a remo√ß√£o da mensagem da fila de solicita√ß√µes, mas antes que a mensagem seja enviada para processamento no agente receptor.  I.e.  a mensagem entra na fila e n√£o √© removida de nenhum lugar.  Mas quando chega a vez da mensagem, sua bandeira √© verificada.  E se o sinalizador indicar que a mensagem foi retirada, a mensagem n√£o ser√° processada. <br><br>  Consequentemente, a pr√≥pria rechamada de mensagens consiste em definir um valor especial para o sinalizador at√¥mico dentro da mensagem. <br><br><h3>  Objeto Revocable_handle_t &lt;M&gt; </h3><br>  Em segundo lugar, at√© agora (?) √â √≥bvio que, para enviar uma mensagem revog√°vel, n√£o devem ser utilizados os m√©todos usuais de envio de mensagens, mas um objeto especial com o nome de c√≥digo revocable_handle_t. <br><br>  Para enviar uma mensagem revog√°vel, o usu√°rio deve criar uma inst√¢ncia de revocable_handle_t e, em seguida, chamar o m√©todo send nessa inst√¢ncia.  E se a mensagem precisar ser recuperada, isso ser√° feito usando o m√©todo revoke.  Algo como: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">my_message</span></span></span><span class="hljs-class"> {</span></span>...}; ... so_5::<span class="hljs-keyword"><span class="hljs-keyword">revocable_handle_t</span></span>&lt;my_message&gt; msg; <span class="hljs-comment"><span class="hljs-comment">//    . msg.send(target, //  . ... //    my_message. ); ... //   . msg.revoke();</span></span></code> </pre> <br>  Ainda n√£o h√° detalhes claros da implementa√ß√£o revocable_handle_t, o que n√£o √© surpreendente, pois  o mecanismo de trabalho das mensagens de rechamada ainda n√£o foi selecionado.  Mas o princ√≠pio do trabalho √© que, em revocable_handle_t, um link inteligente √© salvo na mensagem enviada e no sinalizador at√¥mico para ela.  O m√©todo revoke () tenta substituir o valor do sinalizador.  Se isso der certo, a mensagem, ap√≥s extrair da fila de pedidos, n√£o ser√° mais processada. <br><br><h3>  O que n√£o vai ser amigo de </h3><br>  Infelizmente, h√° algumas coisas com as quais a rechamada de mensagens n√£o pode ser adequadamente vinculada.  S√≥ porque a mensagem retirada continua a permanecer nas filas onde j√° chegou. <br><br><h4>  message_limits </h4><br>  Um recurso t√£o importante do SObjectizer como <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">message_limits</a> foi projetado para proteger os agentes contra sobrecarga.  Limites de mensagens funcionam com base na contagem de mensagens na fila.  Enfileirou uma mensagem - aumentou o contador.  Saiu da linha - reduzido. <br><br>  Porque  quando uma mensagem √© revogada, ela permanece na fila e, em seguida, message_limits n√£o afeta a resposta da mensagem.  Portanto, pode acontecer que a fila tenha um limite no n√∫mero de mensagens do tipo M, mas todas elas foram recuperadas.  De fato, nenhum deles ser√° processado.  Mas enfileirar uma nova mensagem do tipo M n√£o funcionar√°, porque  o limite √© excedido. <br><br>  A situa√ß√£o n√£o √© boa  Mas como sair disso?  N√£o est√° claro. <br><br><h4>  mchains de fila fixa </h4><br>  No SObjectizer, uma mensagem pode ser enviada n√£o apenas para o mbox, mas tamb√©m para o mchain (este √© o nosso <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">an√°logo do canal CSP</a> ).  E os mchains podem ter um tamanho fixo para suas filas.  Uma tentativa de colocar uma nova mensagem para o mchain com um tamanho fixo no mchain completo deve levar a algum tipo de rea√ß√£o.  Por exemplo, aguardando a libera√ß√£o de espa√ßo na fila.  Ou para enviar a mensagem mais antiga. <br><br>  No caso de uma rechamada de mensagem, ela permanecer√° dentro da fila do mchain.  Acontece que a mensagem n√£o √© mais necess√°ria, mas ocupa espa√ßo na fila do mchain.  E evita que novas mensagens sejam enviadas para o mchain. <br><br>  A mesma situa√ß√£o ruim que com message_limits.  E, novamente, n√£o est√° claro como isso pode ser corrigido. <br><br><h2>  O que n√£o est√° claro como fazer </h2><br>  Ent√£o, escolhemos duas op√ß√µes (at√© agora?) Para implementar mensagens de recall.  A primeira op√ß√£o √© simples de implementar e n√£o requer altera√ß√£o dos giblets do SObjectizer.  A segunda op√ß√£o √© muito mais complicada, mas nela o destinat√°rio da mensagem nem sabe que est√° lidando com mensagens revog√°veis.  Vamos considerar brevemente cada um deles. <br><br><h3>  Receba mensagens revog√°veis ‚Äã‚Äãcomo revocable_t &lt;M&gt; </h3><br>  A primeira solu√ß√£o, que parece, em primeiro lugar, vi√°vel e, em segundo lugar, bastante pr√°tica, √© a introdu√ß√£o de um inv√≥lucro especial revocable_t &lt;M&gt;.  Quando o usu√°rio envia uma mensagem revog√°vel do tipo M via revocable_handle_t &lt;M&gt;, n√£o √© a mensagem M que √© enviada, mas a mensagem M dentro do inv√≥lucro especial revocable_t &lt;M&gt;.  E, consequentemente, o usu√°rio n√£o receber√° e processar√° a mensagem do tipo M, mas a mensagem revocable_t &lt;M&gt;.  Por exemplo, desta maneira: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">processor</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> so_5::<span class="hljs-keyword"><span class="hljs-keyword">agent_t</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">request</span></span></span><span class="hljs-class"> {</span></span> ... }; <span class="hljs-comment"><span class="hljs-comment">// ,    . void so_define_agent() override { //   . so_subscribe_self().event( //     ,    //   . [this](mhood_t&lt; revocable_t&lt;request&gt; &gt; cmd) { // ,      . cmd-&gt;try_handle([this](mhood_t&lt;request&gt; msg) { ... }); }); ... } ... };</span></span></code> </pre> <br>  O m√©todo revocable_t &lt;M&gt; :: try_handle () verifica o valor do sinalizador at√¥mico e, se a mensagem n√£o for recuperada, chama a fun√ß√£o lambda passada para ele.  Se a mensagem for retirada, try_handle () n√£o far√° nada. <br><br><h4>  Pr√≥s e contras dessa abordagem </h4><br>  A principal vantagem √© que esta viagem √© facilmente implementada (pelo menos at√© agora parece).  De fato, revocable_handle_t &lt;M&gt; e revocable_t &lt;M&gt; ser√£o apenas um complemento sutil para o SObjectizer. <br><br>  Pode ser necess√°ria uma interven√ß√£o nas partes internas do SObjectizer para fazer amigos revocable_t e mutable_msg.  O fato √© que no SObjectizer existe o conceito de mensagens imut√°veis ‚Äã‚Äã(elas podem ser enviadas no modo 1: 1 e no modo 1: N).  E existe o conceito de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">mensagens mut√°veis</a> que s√≥ podem ser enviadas no modo 1: 1.  Nesse caso, o SObjectizer trata de maneira especial o marcador mutable_msg &lt;M&gt; e executa as verifica√ß√µes correspondentes no tempo de execu√ß√£o.  No caso de revocable_t &lt;mutable_msg &lt;M&gt;&gt;, voc√™ precisar√° ensinar o SObjectizer a tratar essa constru√ß√£o como mutable_msg &lt;M&gt;. <br><br>  Outra vantagem √© que a sobrecarga adicional (tanto nos metadados da mensagem revog√°vel quanto na verifica√ß√£o da bandeira at√¥mica) estar√° apenas em locais onde voc√™ n√£o pode ficar sem ela.  Onde as mensagens de rechamada n√£o s√£o usadas, n√£o haver√° sobrecarga adicional. <br><br>  Mas o principal menos √© ideol√≥gico.  Nessa abordagem, o fato de usar mensagens revog√°veis ‚Äã‚Äãafeta tanto o remetente (usando revocable_handle_t &lt;M&gt;) quanto o destinat√°rio (usando revocable_t &lt;M&gt;).  Mas o destinat√°rio simplesmente n√£o precisa saber que est√° recebendo mensagens de recall.  Al√©m disso, como destinat√°rio, voc√™ pode ter um agente de terceiros pronto que √© gravado sem revocable_t &lt;M&gt;. <br><br>  Al√©m disso, permanecem quest√µes ideol√≥gicas sobre, por exemplo, a possibilidade de encaminhar essas mensagens.  Mas, de acordo com as primeiras estimativas, esses problemas foram resolvidos. <br><br><h3>  Receba mensagens de rechamada como mensagens regulares </h3><br>  A segunda abordagem √© ver apenas a mensagem do tipo M no lado do receptor e n√£o ter uma id√©ia da exist√™ncia de revocable_handle_t &lt;M&gt; e revocable_t &lt;M&gt;.  I.e.  se o processador receber uma solicita√ß√£o, dever√° ver apenas uma solicita√ß√£o, sem nenhum inv√≥lucro adicional. <br><br>  Na verdade, n√£o se pode prescindir de alguns inv√≥lucros nessa abordagem, mas eles ser√£o ocultados no SObjectizer e o usu√°rio n√£o dever√° v√™-los.  Depois que o aplicativo √© recuperado da fila, o SObjectizer determinar√° por si s√≥ que essa √© uma mensagem revog√°vel especialmente encapsulada, verificar√° o sinalizador da relev√¢ncia da mensagem e expandir√° a mensagem, se ainda for relevante.  Em seguida, ele enviar√° uma mensagem ao agente para processamento como se fosse uma mensagem regular. <br><br><h4>  Pr√≥s e contras dessa abordagem </h4><br>  A principal vantagem dessa abordagem √© √≥bvia - o destinat√°rio da mensagem n√£o sabe com quais mensagens ele trabalha.  Isso permite que o remetente da mensagem retire calmamente as mensagens de quaisquer agentes, mesmo aqueles que foram gravados por outros desenvolvedores. <br><br>  Outra vantagem importante √© a capacidade de integrar-se ao mecanismo de rastreamento de entrega de mensagens ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aqui, a fun√ß√£o desse mecanismo √© descrita em mais detalhes</a> ).  I.e.  se msg_tracing estiver ativado e o remetente retirar a mensagem, os tra√ßos poder√£o ser encontrados no log msg_tracing.  O que √© muito conveniente ao depurar. <br><br>  Mas a principal desvantagem √© a complexidade da implementa√ß√£o dessa abordagem.  Em que v√°rios fatores precisar√£o ser considerados. <br><br>  Primeiro, sobrecarga.  Todo o tipo de coisas. <br><br>  Digamos que voc√™ possa fazer um sinalizador especial dentro de uma mensagem que indique se essa mensagem √© revog√°vel ou n√£o.  E, em seguida, verifique esse sinalizador antes de come√ßar a processar cada mensagem.  Grosso modo, outro se √© adicionado ao mecanismo de entrega da mensagem, que funcionar√° durante o processamento de cada mensagem (!). <br><br>  Estou certo de que em aplica√ß√µes reais a perda disso ser√° quase impercept√≠vel.  Mas o rebaixamento nos benchmarks sint√©ticos certamente aparecer√°.  Al√©m disso, quanto mais abstrato o benchmark, menos trabalho real ele realiza, mais ele afunda.  E isso √© ruim do ponto de vista de marketing, porque  Existem v√°rias pessoas que tiram conclus√µes sobre a estrutura em termos de par√¢metros de refer√™ncia sint√©ticos.  E eles fazem isso especificamente: n√£o entendendo que tipo de refer√™ncia √©, que basicamente mostra em qual hardware trabalha, mas comparando os totais com o desempenho de alguma ferramenta especializada, em outro cen√°rio, em outro hardware, etc. ., etc. <br><br>  Em geral, como estamos criando uma estrutura universal, que, como se v√™, √© julgada por n√∫meros abstratos em benchmarks abstratos, n√£o queremos perder, digamos, 5% do desempenho no mecanismo de entrega de <i>todas as</i> mensagens devido √† adi√ß√£o de um recurso que levar√° apenas tempo de tempos em tempos e nem para todos os usu√°rios. <br><br>  Portanto, voc√™ precisa garantir que, ao enviar a mensagem ao destinat√°rio, o SObjectizer entenda que, ao extrair a mensagem, voc√™ deve lidar com isso de uma maneira especial.  Em princ√≠pio, quando uma mensagem √© entregue a um agente, o SObjectizer armazena com a mensagem um ponteiro para uma fun√ß√£o que ser√° usada ao processar a mensagem.  Isso √© necess√°rio agora para lidar com mensagens ass√≠ncronas e solicita√ß√µes s√≠ncronas de maneiras diferentes.  Na verdade, √© assim que a solicita√ß√£o da mensagem endere√ßada ao agente se parece: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">execution_demand_t</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-comment"><span class="hljs-comment">//! Receiver of demand. agent_t * m_receiver; //! Optional message limit for that message. const message_limit::control_block_t * m_limit; //! ID of mbox. mbox_id_t m_mbox_id; //! Type of the message. std::type_index m_msg_type; //! Event incident. message_ref_t m_message_ref; //! Demand handler. demand_handler_pfn_t m_demand_handler; ... };</span></span></code> </pre> <br>  Onde demand_handler_pfn_t √© um ponteiro de fun√ß√£o regular: <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">typedef</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">void</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(*</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">demand_handler_pfn_t</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">current_thread_id_t</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">execution_demand_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp; )</span></span></span></span>;</code> </pre><br>  O mesmo mecanismo tamb√©m pode ser usado para processar especialmente a mensagem que est√° sendo retirada.  I.e.  Quando o mbox envia uma mensagem ao agente, ele sabe se uma mensagem ass√≠ncrona ou uma solicita√ß√£o s√≠ncrona √© enviada para ele.  Da mesma forma, um agente pode receber uma mensagem de retorno de chamada ass√≠ncrona de uma maneira especial.  E o agente salvar√°, junto com a mensagem, um ponteiro para uma fun√ß√£o que saiba como deve lidar com mensagens revogadas. <br><br>  Tudo parece estar bem, mas existem dois grandes "buts" ... :( <br><br>  Em primeiro lugar, a interface mbox existente (a classe <a href="">abstract_message_mbox_t</a> ) n√£o possui m√©todos para enviar mensagens de rechamada.  Portanto, essa interface precisa ser expandida.  E para que as implementa√ß√µes de mbox de outras pessoas vinculadas a abstract_message_box_t do SObjectizer-5.5 n√£o sejam interrompidas (em particular, a s√©rie mbox √© implementada em <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">so_5_extra</a> e eu apenas n√£o as quero). <br><br>  Em segundo lugar, as mensagens podem ser enviadas n√£o apenas para mbox-s, atr√°s das quais os agentes est√£o ocultos, mas tamb√©m para mchain-s.  Quais s√£o as <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">nossas contrapartes nos canais CSP</a> .  E at√© agora, os aplicativos permaneciam sem indicadores adicionais para as fun√ß√µes.  Para introduzir um ponteiro adicional em cada elemento do mchain da fila de aplicativos ... Voc√™ pode, √© claro, mas parece uma solu√ß√£o bastante cara.  Al√©m disso, as pr√≥prias implementa√ß√µes do mchain at√© agora n√£o previram uma situa√ß√£o em que a mensagem extra√≠da precisa ser verificada e possivelmente descartada. <br><br>  Se voc√™ tentar resumir todos os problemas descritos acima, o principal problema dessa abordagem √© que n√£o √© t√£o f√°cil fazer sua implementa√ß√£o, por isso √© barato nos casos em que as mensagens de rechamada n√£o s√£o usadas. <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Mas e quanto ao cancelamento garantido de mensagens pendentes? </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Receio que o problema original tenha se perdido na natureza de detalhes t√©cnicos. </font><font style="vertical-align: inherit;">Suponha que haja mensagens revog√°veis, como ocorrer√° o cancelamento de mensagens pendentes / peri√≥dicas? </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aqui, como se costuma dizer, s√£o poss√≠veis op√ß√µes. </font><font style="vertical-align: inherit;">Por exemplo, trabalhar com mensagens pendentes / peri√≥dicas pode fazer parte da funcionalidade revocable_handle_t &lt;M&gt;:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">revocable_handle_t</span></span>&lt;my_mesage&gt; msg; msg.send_delayed(target, <span class="hljs-number"><span class="hljs-number">15</span></span>s, ...); ... msg.revoke();</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ou voc√™ pode criar sobre revocable_handle_t &lt;M&gt; uma classe auxiliar adicional cancelable_timer_t &lt;M&gt;, que fornecer√° os m√©todos send_delayed / send_periodic. </font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ponto branco: solicita√ß√µes s√≠ncronas </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O SObjectizer-5 suporta n√£o apenas intera√ß√£o ass√≠ncrona entre entidades no programa (enviando mensagens para mbox e mchain), mas tamb√©m intera√ß√£o s√≠ncrona atrav√©s de request_value / request_future. </font><font style="vertical-align: inherit;">Essa intera√ß√£o s√≠ncrona n√£o funciona apenas para agentes.</font></font> I.e.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Voc√™ n√£o pode apenas enviar uma solicita√ß√£o s√≠ncrona para um agente por meio de sua mbox. </font><font style="vertical-align: inherit;">No caso de mchains, voc√™ tamb√©m pode fazer solicita√ß√µes s√≠ncronas, por exemplo, para outro encadeamento de trabalho, no qual receive () ou select () foi chamado para mchain. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Portanto, ainda n√£o est√° claro se √© permitido usar solicita√ß√µes s√≠ncronas em conjunto com mensagens revog√°veis. </font><font style="vertical-align: inherit;">Por um lado, talvez isso fa√ßa algum sentido. </font><font style="vertical-align: inherit;">E pode parecer, por exemplo, assim:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">revocable_handle_t</span></span>&lt;my_request&gt; msg; <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> f = msg.request_future&lt;my_reply&gt;(target, ...); ... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(some_condition) msg.revoke(); ... f.get(); <span class="hljs-comment"><span class="hljs-comment">//      revoke().</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Por outro lado, ainda existem muitas mensagens incompreens√≠veis com mensagens de rechamada, portanto a quest√£o da intera√ß√£o s√≠ncrona foi adiada para tempos melhores. </font></font><br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Escolha, mas tenha cuidado. </font><font style="vertical-align: inherit;">Mas escolha</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Portanto, h√° uma compreens√£o do problema. </font><font style="vertical-align: inherit;">Existem duas op√ß√µes para resolv√™-lo. </font><font style="vertical-align: inherit;">O que no momento parece vi√°vel. </font><font style="vertical-align: inherit;">Mas eles diferem muito no n√≠vel de conveni√™ncia fornecido ao usu√°rio e, ainda mais fortemente, diferem no custo de implementa√ß√£o. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Voc√™ tem que escolher entre essas duas op√ß√µes. </font><font style="vertical-align: inherit;">Ou invente outra coisa. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Qual √© a dificuldade de escolher? </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A dificuldade √© que o SObjectizer √© uma estrutura livre. </font><font style="vertical-align: inherit;">Ele n√£o nos traz dinheiro diretamente. </font><font style="vertical-align: inherit;">Fazemos isso, como dizem, por n√≥s mesmos. </font><font style="vertical-align: inherit;">Portanto, puramente por prefer√™ncias econ√¥micas, uma op√ß√£o mais simples e r√°pida de implementar √© mais lucrativa.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mas, por outro lado, nem tudo √© medido em dinheiro e, a longo prazo, uma ferramenta bem-feita, cujos recursos normalmente est√£o ligados entre si, √© melhor do que um patchwork feito de remendos, de alguma forma colados. A qualidade √© avaliada pelos usu√°rios e por n√≥s mesmos, quando subsequentemente acompanhamos nosso desenvolvimento e adicionamos novos recursos a ele. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Assim, a escolha, de fato, varia entre benef√≠cios de curto prazo e perspectivas de longo prazo. √â verdade que, no mundo moderno, as ferramentas C ++ com perspectivas de longo prazo s√£o de alguma forma nebulosas. O que torna a escolha ainda mais dif√≠cil. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√â nessas condi√ß√µes que voc√™ tem que escolher. Cuidado Mas escolha.</font></font><br><br><h1>  Conclus√£o </h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Neste artigo, tentamos mostrar um pouco o processo de projetar e implementar novos recursos em nossa estrutura. </font><font style="vertical-align: inherit;">Esse processo ocorre regularmente conosco. </font><font style="vertical-align: inherit;">Anteriormente porque </font><font style="vertical-align: inherit;">Em 2014-2016, o SObjectizer se desenvolveu muito mais ativamente. </font><font style="vertical-align: inherit;">Agora, o ritmo de lan√ßamento de novas vers√µes diminuiu. </font><font style="vertical-align: inherit;">O que √© objetivo, inclusive porque, ao adicionar novas funcionalidades sem interromper nada, fica mais dif√≠cil a cada nova vers√£o. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Espero que tenha sido interessante olhar nos bastidores para n√≥s.</font></font> Obrigado pela aten√ß√£o! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt423879/">https://habr.com/ru/post/pt423879/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt423869/index.html">O futuro dos empregos. A principal coisa do relat√≥rio do F√≥rum Econ√¥mico Mundial</a></li>
<li><a href="../pt423871/index.html">Resolvemos um problema l√≥gico para estudantes em SQL</a></li>
<li><a href="../pt423873/index.html">Vis√£o geral da impressora 3D PICASO 3D Designer X</a></li>
<li><a href="../pt423875/index.html">Armazenamento de um grande n√∫mero de arquivos</a></li>
<li><a href="../pt423877/index.html">29-31 de outubro: criando um cluster Kubernetes pronto para produ√ß√£o</a></li>
<li><a href="../pt423881/index.html">Quais foram os soldadores para √≥ptica (parte dois)</a></li>
<li><a href="../pt423885/index.html">Um convite para um show de luzes e um pouco de informa√ß√£o da futura plataforma Circle of Light em Moscou</a></li>
<li><a href="../pt423889/index.html">Minha decep√ß√£o com o software</a></li>
<li><a href="../pt423891/index.html">√Årvores de express√£o de desenvolvimento empresarial</a></li>
<li><a href="../pt423893/index.html">Hello World por receber dados de um dispositivo Bluetooth (BLE) via C #</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>