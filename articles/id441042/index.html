<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚úãüèº üç∑ üà∑Ô∏è Menghasilkan ikon multi-platform multi-merek dengan Sketch dan skrip Node.js - Bagian # 2 üèä ü¶Å üëéüèº</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ini adalah bagian kedua dari posting tentang pembuatan pipa yang dapat mengambil file Sketch dan mengekspor semua ikon yang termasuk dalam file, dalam...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Menghasilkan ikon multi-platform multi-merek dengan Sketch dan skrip Node.js - Bagian # 2</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/badoo/blog/441042/"><img src="https://habrastorage.org/webt/na/kj/v5/nakjv5srowi99bsjteoqabwtoz8.png"><br><br>  Ini adalah bagian kedua dari posting tentang pembuatan pipa yang dapat mengambil file Sketch dan mengekspor semua ikon yang termasuk dalam file, dalam format yang berbeda, untuk platform yang berbeda, dengan kemungkinan AB menguji setiap ikon. <br><br>  Anda dapat membaca bagian pertama dari posting di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> . <br><br><img src="https://habrastorage.org/webt/s6/lt/2d/s6lt2dttycpvlqbolmyeyacaeas.png"><br><br>  File Sketsa, dengan semua ikon yang dikumpulkan, ditata dan dinamai dengan benar, sudah siap.  Sekarang saatnya untuk mulai menulis kode. <br><br>  Cukuplah untuk mengatakan, prosesnya sangat coba-coba: setelah inti kode awal yang penting, yang dikembangkan oleh pemimpin tim saya <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Nikhil Verma</a> (yang menetapkan fondasi skrip), saya melalui proses bertahap yang membutuhkan setidaknya tiga fase refactoring dan beberapa revisi.  Untuk alasan ini, saya tidak akan membahas terlalu banyak tentang bagaimana skrip dikembangkan, tetapi lebih fokus pada bagaimana skrip bekerja hari ini, dalam bentuk akhirnya. <br><a name="habracut"></a><br><h2>  Skrip pembuatan </h2><br>  Skrip build - ditulis dalam Node.js - relatif mudah dalam alurnya: setelah mengimpor dependensi, mendeklarasikan daftar file Sketsa untuk diproses (sebagai daftar merek, dan untuk setiap merek daftar file untuk merek itu) dan memeriksa apakah Sketch diinstal pada klien, skrip loop pada susunan merek, dan untuk masing-masing skrip itu mengeksekusi langkah-langkah ini secara berurutan: <br><br><ol><li>  Dapatkan token desain untuk merek (kita perlu nilai warna) </li><li>  Mengkloning file Sketsa yang terkait dengan merek, unzip mereka untuk mengekspos file JSON internal, dan memanipulasi beberapa nilai internal file JSON ini (lebih lanjut tentang ini nanti) </li><li>  Baca meta-data yang relevan dari file Sketch JSON ( <i>document.json</i> , <i>meta.json</i> , dan <i>pages / pageUniqueID.json</i> );  khususnya kita membutuhkan daftar gaya bersama dan daftar aset / ikon yang terkandung dalam file </li><li>  Setelah beberapa manipulasi lebih lanjut dari file Sketch JSON, kembalikan dan, dengan menggunakan file Sketsa (kloning dan diperbarui), ekspor dan hasilkan file hasil akhir untuk tiga platform (iOS, Android, Mobile Web) </li></ol><br>  Anda dapat melihat bagian yang relevan dari skrip pembuatan utama di sini: <br><br><pre><code class="plaintext hljs">// ... modules imports here const SKETCH_FILES = { badoo: ['icons_common'], blendr: ['icons_common', 'icons_blendr'], fiesta: ['icons_common', 'icons_fiesta'], hotornot: ['icons_common', 'icons_hotornot'], }; const SKETCH_FOLDER_PATH = path.resolve(__dirname, '../src/'); const SKETCH_TEMP_PATH = path.resolve(SKETCH_FOLDER_PATH, 'tmp'); const DESTINATION_PATH = path.resolve(__dirname, '../dist'); console.log('Build started...'); if (sketchtool.check()) { console.log(`Processing Sketch file via ${sketchtool.version()}`); build(); } else { console.info('You need Sketch installed to run this script'); process.exit(1); } // ---------------------------------------- function build() { // be sure to start with a blank slate del.sync([SKETCH_TEMP_PATH, DESTINATION_PATH]); // process all the brands declared in the list of Sketch files Object.keys(SKETCH_FILES).forEach(async (brand) =&gt; { // get the design tokens for the brand const brandTokens = getDesignTokens(brand); // prepare the Sketch files (unzipped) and get a list of them const sketchUnzipFolders = await prepareSketchFiles({ brand, sketchFileNames: SKETCH_FILES[brand], sketchFolder: SKETCH_FOLDER_PATH, sketchTempFolder: SKETCH_TEMP_PATH }); // get the Sketch metadata const sketchMetadata = getSketchMetadata(sketchUnzipFolders); const sketchDataSharedStyles = sketchMetadata.sharedStyles; const sketchDataAssets = sketchMetadata.assetsMetadata; generateAssetsPDF({ platform: 'ios', brand, brandTokens, sketchDataSharedStyles, sketchDataAssets }); generateAssetsSVGDynamicMobileWeb({ platform: 'mw', brand, brandTokens, sketchDataSharedStyles, sketchDataAssets }); generateAssetsVectorDrawableDynamicAndroid({ platform: 'android', brand, brandTokens, sketchDataSharedStyles, sketchDataAssets }); }); }</code> </pre> <br>  Sebenarnya, seluruh kode pipa jauh lebih kompleks dari ini, dan kerumitannya terletak pada <b>prepSketchFiles</b> , <b>getSketchMetadata</b> , dan <b>menghasilkan</b> fungsi <b>[format] [platform]</b> perangkat <b>asset</b> .  Saya akan mencoba menjelaskannya secara lebih rinci di bawah ini. <br><br><h2>  Mempersiapkan file Sketsa </h2><br>  Langkah pertama dalam proses pembuatan adalah persiapan file Sketsa, sehingga mereka dapat digunakan nanti untuk ekspor aset untuk platform yang berbeda. <br><br>  File yang terkait dengan merek - untuk Blendr, misalnya, file <i>icons_common.sketch</i> dan <i>icons_blendr.sketch</i> - pada awalnya dikloning dalam folder sementara (lebih tepatnya, dalam subfolder bernama setelah merek yang sedang diproses) dan membuka ritsleting. <br><br>  Kemudian file JSON internal diproses, menjadi awalan yang ditambahkan ke aset yang akan menjalani pengujian AB, sehingga ketika diekspor mereka akan disimpan dalam subfolder dengan nama yang telah ditentukan (nama unik percobaan).  Untuk memahami aset mana yang akan diuji, kami cukup memeriksa apakah nama halaman tempat mereka disimpan dalam Sketsa diawali dengan <i>"XP_"</i> . <br><br><img src="https://habrastorage.org/webt/k7/qo/df/k7qodfiyytkacnk1uknx_6gxhzw.png"><br>  <i>Perbandingan nama layer, di dalam file Sketch, sebelum dan sesudah pembaruan.</i> <br><br>  Dalam contoh di atas, ketika diekspor, aset akan disimpan dalam subfolder <i>"this__is_an_experiment"</i> , dengan nama file <i>"icon-name [variant-name] .ext"</i> . <br><br><h2>  Membaca metadata sketsa </h2><br>  Langkah penting kedua dalam proses ini adalah mengeluarkan semua meta-data yang relevan dari file Sketch, khususnya dari file JSON internal mereka.  Seperti dijelaskan di atas, file-file ini adalah dua file utama ( <i>document.json</i> dan <i>meta.json</i> ) dan file <i>halaman</i> ( <i>halaman / pageUniqueId.json</i> ). <br><br>  File <i>document.json</i> digunakan untuk mendapatkan daftar Gaya Bersama, yang muncul di bawah properti objek <i>layerStyles</i> : <br><br><pre> <code class="plaintext hljs">{ "_class": "document", "do_objectID": "45D2DA82-B3F4-49D1-A886-9530678D71DC", "colorSpace": 1, ... "layerStyles": { "_class": "sharedStyleContainer", "objects": [ { "_class": "sharedStyle", "do_objectID": "9BC39AAD-CDE6-4698-8EA5-689C3C942DB4", "name": "features/feature-like", "value": { "_class": "style", "fills": [ { "_class": "fill", "isEnabled": true, "color": { "_class": "color", "alpha": 1, "blue": 0.10588235408067703, "green": 0.4000000059604645, "red": 1 }, "fillType": 0, "noiseIndex": 0, "noiseIntensity": 0, "patternFillType": 1, "patternTileScale": 1 } ], "blur": {...}, "startMarkerType": 0, "endMarkerType": 0, "miterLimit": 10, "windingRule": 1 } }, ...</code> </pre> <br>  Untuk setiap gaya, kami menyimpan beberapa informasi dasar dalam objek nilai kunci.  Ini akan digunakan nanti setiap kali kita perlu mengambil nama gaya berdasarkan ID uniknya (dalam Sketsa, properti <i>do_objectID</i> ): <br><br><pre> <code class="plaintext hljs">const parsedSharedStyles = {}; parsedDocument.layerStyles.objects.forEach((object) =&gt; { parsedSharedStyles[object.do_objectID] = { name: object.name, isFill: _.get(object, 'value.fills[0].color') !== undefined, isBorder: _.get(object, 'value.borders[0].color') !== undefined, }; });</code> </pre> <br><br>  Pada titik ini, kita beralih pada file <i>meta.json</i> untuk mendapatkan daftar halaman, khususnya kita memerlukan <i>id</i> dan <i>nama</i> <i>unik</i> mereka: <br><br><pre> <code class="plaintext hljs">{ "commit": "623a23f2c4848acdbb1a38c2689e571eb73eb823", "pagesAndArtboards": { "EE6BE8D9-9FAD-4976-B0D8-AB33D2B5DBB7": { "name": "Icons", "artboards": { "3275987C-CE1B-4369-B789-06366EDA4C98": { "name": "badge-feature-like" }, "C6992142-8439-45E7-A346-FC35FA01440F": { "name": "badge-feature-crush" }, ... "7F58A1C4-D624-40E3-A8C6-6AF15FD0C32D": { "name": "tabbar-livestream" } ... } }, "ACF82F4E-4B92-4BE1-A31C-DDEB2E54D761": { "name": "XP_this__is_an_experiment", "artboards": { "31A812E8-D960-499F-A10F-C2006DDAEB65": { "name": "this__is_an_experiment/tabbar-livestream[variant1]" }, "20F03053-ED77-486B-9770-32E6BA73A0B8": { "name": "this__is_an_experiment/tabbar-livestream[variant2]" }, "801E65A4-3CC6-411B-B097-B1DBD33EC6CC": { "name": "this__is_an_experiment/tabbar-livestream[control]" } } },</code> </pre> <br>  Kemudian, untuk setiap halaman kami membaca file JSON yang sesuai di bawah folder <i>halaman</i> (seperti yang sudah dikatakan, nama file adalah <i>[pageUniqueId] .json</i> ), dan kami menelusuri aset-aset yang terkandung dalam halaman itu (mereka muncul sebagai layer).  Dengan cara ini, untuk setiap ikon kita mendapatkan namanya, lebar / tingginya, meta-data Sketsa untuk ikon lapisan itu, dan jika itu ada di halaman percobaan, nama tes AB yang dipertanyakan, dan nama varian untuk ikon itu. <br><br>  <i>Perhatikan</i> : objek "page.json" sangat kompleks, jadi saya tidak akan membahasnya di sini.  Jika Anda penasaran dan ingin melihat seperti apa bentuknya, saya sarankan Anda untuk membuat file Sketsa baru yang kosong, menambahkan beberapa konten di dalamnya, dan menyimpannya;  kemudian ganti ekstensi di zip, unzip dan lihat salah satu file yang muncul di bawah folder "halaman". <br><br>  Saat memproses artboards, kami juga membuat daftar percobaan (dengan aset terkait) yang akan digunakan nanti untuk menentukan opsi ikon mana yang digunakan dan untuk eksperimen mana, mengaitkan nama opsi ikon ke objek "ikon dasar". <br><br>  Untuk setiap file Sketsa yang sedang diproses yang terkait dengan merek, kami menghasilkan objek <i>asetMetadata</i> yang terlihat seperti ini: <br><br><pre> <code class="plaintext hljs">{ "navigation-bar-edit": { "do_objectID": "86321895-37CE-4B3B-9AA6-6838BEDB0977", ...sketch_artboard_properties, "name": "navigation-bar-edit", "assetname": "navigation-bar-edit", "source": "icons_common", "width": 48, "height": 48 "layers": [ { "do_objectID": "A15FA03C-DEA6-4732-9F85-CA0412A57DF4", "name": "Path", ...sketch_layer_properties, "sharedStyleID": "6A3C0FEE-C8A3-4629-AC48-4FC6005796F5", "style": { ... "fills": [ { "_class": "fill", "isEnabled": true, "color": { "_class": "color", "alpha": 1, "blue": 0.8784313725490196, "green": 0.8784313725490196, "red": 0.8784313725490196 }, } ], "miterLimit": 10, "startMarkerType": 0, "windingRule": 1 }, }, ], ... }, "experiment-name/navigation-bar-edit[variant]": { "do_objectID": "00C0A829-D8ED-4E62-8346-E7EFBC04A7C7", ...sketch_artboard_properties, "name": "experiment-name/navigation-bar-edit[variant]", "assetname": "navigation-bar-edit", "source": "icons_common", "width": 48, "height": 48 ...</code> </pre> <br>  Seperti yang Anda lihat, "ikon" yang sama (dalam hal ini <i>navigasi-bar-edit</i> ) dapat memiliki beberapa "aset" yang terkait dengannya, dalam hal eksperimen.  Tetapi ikon yang sama dapat muncul dengan nama yang sama dalam file Sketsa kedua yang terkait dengan merek, dan ini sangat berguna: ini adalah trik yang telah kami gunakan, untuk mengkompilasi satu set ikon yang umum dan kemudian menentukan varian ikon tertentu yang berbeda tergantung pada merek. <br><br>  Itu sebabnya kami mendeklarasikan file Sketsa yang terkait dengan masing-masing merek sebagai array: <br><br><pre> <code class="plaintext hljs">const SKETCH_FILES = { badoo: ['icons_common'], blendr: ['icons_common', 'icons_blendr'], fiesta: ['icons_common', 'icons_fiesta'], hotornot: ['icons_common', 'icons_hotornot'], };</code> </pre> <br>  Karena dalam hal ini urutan penting.  Dan pada kenyataannya, dalam fungsi <i>getSketchMetadata</i> , dipanggil oleh skrip build, kami tidak mengembalikan objek <i>asetMetadata</i> (satu per file) sebagai daftar, melainkan melakukan penggabungan mendalam dari setiap objek, satu ke yang lain, lalu kami mengembalikan objek <i>asetMetadata</i> gabungan tunggal. <br><br>  Ini tidak lebih dari gabungan "logis" dari file Sketsa, dan asetnya, menjadi satu file tunggal.  Tetapi logikanya sebenarnya tidak sesederhana kelihatannya.  Berikut adalah skema yang harus kami buat untuk mencari tahu apa yang terjadi ketika ada ikon dengan nama yang sama (mungkin di bawah pengujian AB) dalam file berbeda yang terkait dengan merek yang sama: <br><br><img src="https://habrastorage.org/webt/yg/ug/-6/ygug-6xnds3cvysntithaenmbfw.png"><br>  <i>Skema logis tentang bagaimana "penggantian" dari ikon yang sama bekerja, antara seperangkat ikon dan ikon bersama yang dirancang khusus untuk label putih (juga mempertimbangkan kasus pengujian AB)</i> <br><br><h2>  Membuat file akhir dalam berbagai format untuk berbagai platform </h2><br>  Langkah terakhir dari proses ini adalah pembuatan file ikon dengan format berbeda untuk platform yang berbeda (PDF untuk iOS, SVG / JSX untuk Web, dan VectorDrawable untuk Android). <br><br>  Seperti yang dapat Anda lihat dari jumlah parameter yang diteruskan ke fungsi <i>generateAssets [format] [platform]</i> ini adalah bagian paling kompleks dari pipeline.  Di sinilah <b>proses mulai membelah dan menyimpang</b> untuk platform yang berbeda.  Lihat di bawah ini alur logis lengkap skrip, dan bagaimana bagian yang terkait dengan pembuatan aset <b>terbagi menjadi tiga aliran yang serupa tetapi tidak identik:</b> <br><br> <a href=""><img src="https://habrastorage.org/webt/jv/83/xy/jv83xyzcpvzmn4snh0xakkrfu8k.png"></a> <br><br>  Untuk menghasilkan aset akhir dengan warna yang benar terkait dengan merek yang sedang diproses, kita perlu melakukan serangkaian manipulasi pada file Sketch JSON: kita mengulangi secara berulang-ulang setiap lapisan yang memiliki gaya berbagi yang diterapkan, dan mengganti nilai warna dengan warna dari token desain untuk merek. <br><br>  Untuk generasi Android, diperlukan manipulasi tambahan (lebih lanjut tentang ini nanti): kami mengubah properti aturan-isi setiap lapisan dari <i>even-odd</i> ke <i>non-zero</i> (ini dikendalikan oleh properti "windingRule" di objek JSON, di mana " 1 "berarti" genap-genap "dan" 0 "berarti" bukan-nol "). <br><br>  Setelah menyelesaikan manipulasi ini, kami mengompres file Sketch JSON kembali ke file Sketch standar, sehingga dapat diproses untuk mengekspor aset dengan properti yang diperbarui (file yang diklon dan diperbarui adalah file Sketsa yang benar-benar normal: mereka dapat dibuka di Sketch , dilihat, diedit, disimpan, dll). <br><br>  Pada titik ini kita dapat menggunakan sketchtool ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dalam pembungkus simpul</a> ) untuk secara otomatis mengekspor semua aset dalam format tertentu untuk platform tertentu.  Untuk setiap file yang terkait dengan merek (lebih tepatnya, versi yang dikloning dan dimutakhirkan) kami menjalankan perintah ini: <br><br><pre> <code class="plaintext hljs">sketchtool.run(`export slices ${cloneSketchFile} --formats=svg &lt;i&gt;--scales=1 &lt;/i&gt;--output=${destinationFolder} --overwriting`);</code> </pre> <br>  Seperti yang Anda tebak, perintah ini mengekspor aset dalam format tertentu, menerapkan penskalaan opsional (untuk saat ini kami selalu menyimpan skala aslinya), ke folder tujuan.  Opsi <i>--overwriting</i> adalah kunci di sini: dengan cara yang sama kita melakukan "penggabungan mendalam" dari objek assetsMetadata (yang berjumlah "gabungan logis" dari file Sketsa), ketika kita mengekspor kita melakukannya dari banyak file ke dalam folder yang sama (unik per merek / platform).  Ini berarti bahwa jika suatu aset - diidentifikasi dengan nama lapisannya - sudah ada dalam file Sketsa sebelumnya, itu akan ditimpa oleh ekspor berikut.  Yang, sekali lagi, tidak lebih dari operasi "penggabungan". <br><br>  Namun dalam hal ini, kita mungkin memiliki beberapa aset yang merupakan "hantu".  Ini terjadi ketika ikon diuji AB dalam file, tetapi ditimpa dalam file berikutnya.  Dalam kasus seperti itu, file varian diekspor ke folder tujuan, direferensikan dalam objek <i>assetsMetadata</i> sebagai aset (dengan kunci dan propertinya), tetapi tidak terkait dengan aset "basis" apa pun (karena penggabungan mendalam dari objek <i>assetsMetadata aset</i> ).  File-file ini akan dihapus pada langkah selanjutnya, sebelum proses selesai. <br><br><hr><br>  Seperti disebutkan di atas, kita membutuhkan format final yang berbeda untuk platform yang berbeda.  Untuk iOS kami menginginkan file PDF, dan kami dapat mengekspornya langsung dengan perintah <i>sketchtool</i> .  Sementara, untuk Web Seluler kami menginginkan file JSX, dan untuk Android kami menginginkan file VectorDrawable;  untuk alasan ini kami mengekspor aset dalam format SVG ke folder perantara, dan kemudian kami akan memprosesnya lebih lanjut. <br><br><h2>  File PDF untuk iOS </h2><br>  Anehnya, PDF adalah (hanya?) Format yang didukung oleh Xcode dan OS / iOS untuk mengimpor dan merender aset vektor ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">berikut adalah penjelasan singkat tentang</a> alasan teknis di balik pilihan ini oleh Apple). <br><br>  Karena kita dapat mengekspor langsung dalam PDF melalui Sketchtool, tidak perlu langkah-langkah tambahan untuk platform ini: kita cukup menyimpan file secara langsung di folder tujuan, dan hanya itu. <br><br><h2>  Bereaksi / file JSX untuk web </h2><br>  Dalam kasus Web, kami menggunakan perpustakaan Node yang disebut <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">svgr</a> yang mengubah file SVG sederhana menjadi komponen Bereaksi.  Tapi kami ingin melakukan sesuatu yang lebih kuat: kami ingin "melukis secara dinamis" ikon saat runtime, dengan warna yang berasal dari token desain.  Untuk alasan ini, tepat sebelum konversi, kami mengganti dalam SVG nilai <i>isian</i> lintasan yang awalnya memiliki gaya bersama diterapkan, dengan nilai token terkait yang terkait dengan gaya itu. <br><br>  Jadi, jika ini adalah file <i>badge-feature-like.svg yang</i> diekspor dari Sketch: <br><br><pre> <code class="plaintext hljs">&lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;svg width="128px" height="128px" viewBox="0 0 128 128" version="1.1" xmlns="&lt;a href="http://www.w3.org/2000/svg"&gt;http://www.w3.org/2000/svg&lt;/a&gt;" xmlns:xlink="&lt;a href="http://www.w3.org/1999/xlink"&gt;http://www.w3.org/1999/xlink&lt;/a&gt;"&gt; &lt;!-- Generator: sketchtool 52.2 (67145) - &lt;a href="http://www.bohemiancoding.com/sketch"&gt;http://www.bohemiancoding.com/sketch&lt;/a&gt; --&gt; &lt;title&gt;badge-feature-like&lt;/title&gt; &lt;desc&gt;Created with sketchtool.&lt;/desc&gt; &lt;g id="Icons" fill="none" fill-rule="evenodd"&gt; &lt;g id="badge-feature-like"&gt; &lt;circle id="circle" fill="#E71032" cx="64" cy="64" r="64"&gt; &lt;path id="Shape" fill="#FFFFFF" d="M80.4061668,..."&gt;&lt;/path&gt; &lt;/g&gt; &lt;/g&gt; &lt;/svg&gt;</code> </pre> <br>  ikon aset / ikon <i>badge-feature-like.js akhir</i> akan terlihat seperti ini: <br><br><pre> <code class="plaintext hljs">/* This file is generated automatically - DO NOT EDIT */ /* eslint-disable max-lines,max-len,camelcase */ const React = require('react'); module.exports = function badge_feature_like({ tokens }) { return ( &lt;svg data-origin="pipeline" viewBox="0 0 128 128"&gt; &lt;g fill="none" fillRule="evenodd"&gt; &lt;circle fill={tokens.TOKEN_COLOR_FEATURE_LIKED_YOU} cx={64} cy={64} r={64} /&gt; &lt;path fill="#FFF" d="M80.4061668,..." /&gt; &lt;/g&gt; &lt;/svg&gt; ); };</code> </pre> <br>  Seperti yang Anda lihat, kami telah mengganti nilai statis untuk warna <i>isian</i> lingkaran, dengan yang dinamis, yang mengambil nilainya dari token desain (ini akan tersedia untuk komponen Bereaksi <i>&lt;Ikon /&gt;</i> melalui Context API, tapi itu cerita lain). <br><br>  Penggantian ini dimungkinkan melalui meta-data Sketsa untuk aset yang disimpan dalam <i>aset Metadata</i> objek: pengulangan secara rekursif melalui lapisan aset, dimungkinkan untuk membuat pemilih DOM (dalam kasus di atas, itu akan menjadi <i>#Icons # badge-feature- seperti #circle</i> ) dan gunakan itu untuk menemukan simpul di pohon SVG, dan ganti nilai atribut <i>fill</i> -nya (untuk operasi ini kita menggunakan library <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">cheerio</a> ). <br><br><h2>  File VectorDrawable untuk Android </h2><br>  Android mendukung grafik vektor menggunakan format vektor kustom, yang disebut <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">VectorDrawable</a> .  Biasanya konversi dari SVG ke VectorDrawable dilakukan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">langsung di Android Studio</a> oleh pengembang.  Tapi di sini kami ingin mengotomatiskan seluruh proses, jadi kami perlu menemukan cara untuk mengubahnya melalui kode. <br><br>  Setelah melihat berbagai pustaka dan alat, kami memutuskan untuk menggunakan pustaka yang disebut <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">svg2vectordrawable</a> .  Tidak hanya itu dipelihara secara aktif (setidaknya, lebih baik dari yang lain yang kami temukan) tetapi juga lebih lengkap. <br><br>  Faktanya adalah bahwa VectorDrawable tidak dalam paritas fitur dengan SVG: beberapa fitur canggih SVG (misalnya gradien radial, masker kompleks, dll.) <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Tidak didukung</a> , dan beberapa dari mereka telah mendapatkan dukungan baru-baru ini (dengan Android API 24 dan lebih tinggi).  Satu kelemahan dari hal ini adalah bahwa di Android pra-24 <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">aturan isi "genap" tidak didukung</a> .  Tetapi di Badoo kita perlu mendukung Android 5 dan di atasnya.  Itu sebabnya, seperti dijelaskan di atas, untuk Android kita perlu mengkonversi setiap jalur dalam file Sketch menjadi isian "non-zero". <br><br>  Secara potensial, para desainer dapat melakukan ini secara manual: <br><br><img src="https://habrastorage.org/webt/oj/ec/bp/ojecbp2no3lxsas5uwxcqmobcji.png"><br><br>  tapi ini mungkin mudah diabaikan, dan jadi rentan terhadap kesalahan manusia. <br><br>  Untuk alasan ini, kami telah menambahkan langkah ekstra dalam proses kami untuk Android, di mana kami secara otomatis mengonversi semua jalur menjadi <i>nol</i> di Sketch JSON.  Ini agar ketika kita mengekspor ikon ke SVG, ikon tersebut sudah ada dalam format ini, dan setiap VectorDrawable yang dihasilkan juga kompatibel dengan perangkat Android 5. <br><br>  File <i>badge-feature-like.xml akhir</i> dalam kasus ini terlihat seperti ini: <br><br><pre> <code class="plaintext hljs">&lt;!-- This file is generated automatically - DO NOT EDIT --&gt; &lt;vector xmlns:android="&lt;a href="http://schemas.android.com/apk/res/android"&gt;http://schemas.android.com/apk/res/android&lt;/a&gt;" android:width="128dp" android:height="128dp" android:viewportWidth="128" android:viewportHeight="128"&gt; &lt;path android:fillColor="?color_feature_liked_you" android:pathData="M64 1a63 63 0 1 0 0 126A63 63 0 1 0 64 1z" /&gt; &lt;path android:fillColor="#FFFFFF" android:pathData="M80.406 ..." /&gt; &lt;/vector&gt;</code> </pre> <br>  Seperti yang Anda lihat, juga dalam file VectorDrawable kami menyuntikkan nama variabel untuk warna <i>isian</i> , yang terkait dengan token desain melalui gaya kustom di aplikasi Android. <br><br>  Inilah yang terlihat seperti VectorDrawable yang pernah diimpor di Android Studio: <br><br> <a href=""><img src="https://habrastorage.org/webt/zu/n4/8q/zun48q0knfv8k9xy4amb6eqrxxa.png"></a> <br>  <i>Contoh ikon VectorDrawable yang diimpor ke Android Studio</i> <br><br>  Satu hal yang perlu diperhatikan dalam kasus ini: Android Studio memiliki cara yang sangat ketat dan preskriptif mengatur aset: tidak ada folder bersarang dan semua nama huruf kecil!  Ini berarti kami harus membuat format yang sedikit berbeda untuk nama ikon mereka: dalam kasus aset yang sedang dalam percobaan, namanya akan seperti <i>ic_icon-name__experiment-name__variant-name</i> . <br><br><h2>  Kamus JSON sebagai perpustakaan aset </h2><br>  Setelah file aset disimpan dalam format terakhirnya, hal terakhir yang masih harus dilakukan adalah menyimpan semua informasi meta yang dikumpulkan selama proses pembangunan, dan menyimpannya dalam "kamus", sehingga dapat dibuat tersedia nanti ketika aset diimpor dan dikonsumsi oleh basis kode dari platform yang berbeda. <br><br>  Setelah mengekstrak daftar datar ikon dari objek <i>assetsMetadata</i> , kami mengulanginya dan untuk setiap item kami memeriksa: <br><br><ul><li>  jika itu adalah aset normal (mis. <i>tabbar-livestream</i> ), dan jika ya, kita simpan saja; </li><li>  jika ini merupakan varian dalam tes AB (mis. <i>eksperimen / tabbar-livestream [varian]</i> ), kita asosiasikan namanya, jalur, uji AB, dan nama varian, dengan properti properti dari aset "basis" (dalam hal ini, <i>tabbar- streaming langsung</i> ), dan kemudian kita menghapus entri varian dari daftar / objek (hanya "basis" yang dihitung); </li><li>  jika itu adalah varian "hantu", kami menghapus file, dan kemudian menghapus entri dari daftar / objek. </li></ul><br>  Setelah loop selesai, kamus akan berisi daftar semua dan hanya ikon "dasar" (dan tes AB-nya, jika sedang dalam percobaan).  Untuk masing-masing ini akan berisi nama, ukuran, jalur dan, jika ikon di bawah pengujian AB, informasi tentang berbagai opsi aset. <br><br>  Kamus ini kemudian disimpan dalam format JSON di folder tujuan untuk <i>merek</i> dan <i>platform</i> .  Di sini, misalnya, adalah file <i>assets.json yang</i> dihasilkan untuk aplikasi "Blendr" di "web seluler": <br><br><pre> <code class="plaintext hljs">{ "platform": "mw", "brand": "blendr", "assets": { "badge-feature-like": { "assetname": "badge-feature-like", "path": "assets/badge-feature-like.jsx", "width": 64, "height": 64, "source": "icons_common" }, "navigation-bar-edit": { "assetname": "navigation-bar-edit", "path": "assets/navigation-bar-edit.jsx", "width": 48, "height": 48, "source": "icons_common" }, "tabbar-livestream": { "assetname": "tabbar-livestream", "path": "assets/tabbar-livestream.jsx", "width": 128, "height": 128, "source": "icons_blendr", "abtest": { "this__is_an_experiment": { "control": "assets/this__is_an_experiment/tabbar-livestream__control.jsx", "variant1": "assets/this__is_an_experiment/tabbar-livestream__variant1.jsx", "variant2": "assets/this__is_an_experiment/tabbar-livestream__variant2.jsx" }, "a_second-experiment": { "control": "assets/a_second-experiment/tabbar-livestream__control.jsx", "variantA": "assets/a_second-experiment/tabbar-livestream__variantA.jsx" } } }, ... } }</code> </pre> <br>  Langkah terakhir adalah mengompres semua folder <i>aset</i> di.  <i>zip</i> file, sehingga mereka dapat diunduh dengan lebih mudah. <br><br><h2>  Hasil akhir </h2><br>  Proses yang dijelaskan di atas - mulai dari kloning awal dan manipulasi file Sketch, hingga ekspor (dan konversi) aset dalam format yang diinginkan untuk setiap platform yang didukung, hingga penyimpanan meta-informasi yang dikumpulkan di perpustakaan aset - adalah diulang untuk setiap merek yang dinyatakan dalam skrip build. <br><br>  Di bawah ini adalah tangkapan layar seperti apa struktur folder <i>src</i> dan <i>dist</i> , setelah proses pembangunan selesai: <br><br><img src="https://habrastorage.org/webt/yg/nc/d9/ygncd9uupdngcnav-rmkrsq1dsg.png"><br>  <i>Struktur folder "src" dan "dist" setelah proses build selesai.</i> <br><br>  Pada titik ini, dengan satu perintah sederhana dimungkinkan untuk mengunggah semua sumber daya (file JSON, file ZIP dan file aset) ke repositori jarak jauh, dan membuatnya tersedia untuk semua platform yang berbeda, untuk mengunduh dan menggunakan dalam basis kode mereka. <br><br>  (Bagaimana platform yang sebenarnya mengambil dan memproses aset - melalui skrip khusus yang dibuat ad-hoc untuk tujuan ini - berada di luar cakupan artikel ini. Tetapi ini mungkin akan dibahas segera dalam posting blog khusus lainnya, oleh salah satu dari pengembang lain yang bekerja dengan saya di proyek ini). <br><br><h2>  Kesimpulan (dan pelajaran yang didapat sepanjang jalan) </h2><br>  Saya selalu menyukai <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Sketsa</a> .  Selama bertahun-tahun ini telah menjadi alat "de-facto" pilihan untuk desain web dan aplikasi (dan pengembangan).  Jadi saya sangat tertarik dan ingin tahu untuk mengeksplorasi kemungkinan integrasi seperti <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">html-sketchapp</a> atau alat serupa, apa saja yang bisa kita gunakan dalam alur kerja dan jalur pipa kami. <br><br>  Aliran (ideal) ini selalu menjadi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">cawan suci bagi saya</a> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dan banyak lainnya</a> ): <br><br><img src="https://habrastorage.org/webt/kq/7l/n4/kq7ln4kr6txurb-mvh6brqbhnqe.png"><br><br>  Sketsa sebagai alat desain dapat dibayangkan sebagai kemungkinan "target" basis kode. <br><br>  Tetapi saya harus mengakui bahwa saya baru-baru ini mulai bertanya-tanya apakah Sketch masih merupakan alat yang tepat, terutama dalam konteks Sistem Desain.  Jadi, saya mulai menjelajahi alat-alat baru seperti <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Figma</a> , dengan API terbuka, dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Framer X</a> , dengan integrasinya yang luar biasa dengan React, karena saya tidak melihat upaya setara dari Sketch untuk bergerak menuju integrasi dengan kode (kode apa pun itu). <br><br>  Nah, proyek ini berubah pikiran.  Tidak sepenuhnya, tapi pasti banyak. <br><br>  Mungkin Sketch tidak secara resmi mengekspos API-nya, tetapi tentu cara mereka membangun struktur internal file-file mereka adalah semacam API "tidak resmi".  Mereka bisa menggunakan nama samar, atau mengaburkan kunci dalam objek JSON;  alih-alih, mereka memilih konvensi penamaan semantik yang jelas, mudah dibaca, dapat dibaca manusia.  Saya tidak bisa berpikir ini hanya kebetulan. <br><br>  Fakta bahwa file Sketch dapat dimanipulasi telah membuka pikiran saya berbagai kemungkinan perkembangan dan peningkatan di masa depan.  Dari pengaya untuk memvalidasi penamaan, penataan, dan struktur lapisan untuk ikon, hingga kemungkinan integrasi dengan wiki kami dan dokumentasi sistem desain kami (di kedua arah), melalui pembuatan aplikasi Node yang dihosting di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Electron</a> atau <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Carlo</a> untuk memfasilitasi banyak dari tugas berulang yang harus dilakukan oleh desainer. <br><br>  Satu bonus tak terduga dari proyek ini (setidaknya bagi saya) adalah bahwa sekarang file Sketsa dengan "ikon Cosmos" telah menjadi "sumber kebenaran", mirip dengan apa yang terjadi dengan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sistem desain Cosmos</a> .  Jika sebuah ikon tidak ada, itu tidak ada di basis kode (atau lebih baik, itu tidak seharusnya ada: tapi setidaknya kita tahu itu pengecualian).  Saya tahu itu agak jelas sekarang, tetapi tidak sebelumnya, setidaknya untuk saya. <br><br>  Apa yang dimulai sebagai proyek MVP, segera menjadi penyelaman mendalam (secara harfiah) ke internal file Sketch, dengan kesadaran bahwa ini dapat dimanipulasi.  Kami belum tahu ke mana semua ini akan mengarah, tapi sejauh ini itu sukses.  Desainer, pengembang, PM, dan pemangku kepentingan, semua sepakat bahwa ini akan menghemat banyak pekerjaan manual untuk semua orang, dan mencegah banyak kesalahan potensial.  Tapi itu juga akan membuka pintu untuk penggunaan ikon-ikon yang tidak mungkin sampai sekarang. <br><br>  Satu hal terakhir: apa yang saya jelaskan di posting panjang ini adalah pipa yang telah kami bangun di sini untuk menyelesaikan masalah khusus <i>kami</i> , dan itu tentu sangat disesuaikan untuk konteks <i>kami</i> .  Ingatlah bahwa itu mungkin tidak sesuai <i>dengan</i> kebutuhan bisnis <i>Anda</i> atau sesuai untuk konteks <i>Anda</i> . <br><br>  Tetapi yang penting bagi saya, dan apa yang ingin saya bagikan, adalah hal itu bisa dilakukan.  Mungkin dengan cara yang berbeda, dengan pendekatan yang berbeda dan format keluaran yang berbeda, mungkin melibatkan kompleksitas yang lebih sedikit (yaitu: Anda mungkin tidak memerlukan multi-branding dan pengujian AB).  Tapi sekarang Anda dapat mengotomatiskan alur kerja yang terlibat dalam memberikan ikon Anda dengan skrip dan Skrip Node.js khusus. <br><br>  Temukan cara Anda sendiri untuk melakukannya.  Sangat menyenangkan (dan relatif mudah). <br><br><h2>  Kredit </h2><br>  Proyek besar ini dikembangkan bekerja sama dengan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Nikhil Verma</a> (Mobile Web), yang menciptakan versi pertama skrip build, dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Artem Rudoi</a> (Android) dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Igor Savelev</a> (iOS), yang mengembangkan skrip yang mengimpor dan menggunakan aset di platform asli masing-masing.  Terima kasih, semuanya, ini adalah ledakan yang bekerja dengan Anda dalam proyek ini dan menyaksikannya menjadi hidup. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id441042/">https://habr.com/ru/post/id441042/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id441030/index.html">Mendeteksi Serangan Web dengan Autoencoder Seq2Seq</a></li>
<li><a href="../id441032/index.html">KeeBee Membuat keyboard USB Anda sendiri dari awal</a></li>
<li><a href="../id441034/index.html">6 poin pertumbuhan konversi atau cara meningkatkan kepercayaan menggunakan telepon di situs</a></li>
<li><a href="../id441036/index.html">Cara memberi dan menerima umpan balik jika Anda sparrow-sociophobus</a></li>
<li><a href="../id441040/index.html">Menghasilkan ikon multi-platform multi-merek dengan Sketch dan skrip Node.js - Bagian # 1</a></li>
<li><a href="../id441044/index.html">Kisah bagaimana kami mengubah ikon PVS-Studio</a></li>
<li><a href="../id441046/index.html">Kisah bagaimana kami mengubah ikon PVS-Studio</a></li>
<li><a href="../id441048/index.html">Kantor yang pro agresif</a></li>
<li><a href="../id441050/index.html">Membuat kamera termal DIY berdasarkan Raspberry Pi</a></li>
<li><a href="../id441052/index.html">16 Maret Badoo PHP Meetup: Tes dan kualitas kode. Pendaftaran terbuka</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>