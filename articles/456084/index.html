<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🧒🏼 🧛🏽 🥝 Kubernetes 1.15: Resumen de lo más destacado 👰 ☸️ 🛀🏽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Se suponía que el lunes tendría lugar oficialmente ( pero hasta ahora esto no ha sucedido ... ACTUALIZADO 20/06 : el anuncio apareció en el blog de K8...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Kubernetes 1.15: Resumen de lo más destacado</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/flant/blog/456084/"><img src="https://habrastorage.org/webt/dy/xn/j8/dyxnj8d_ebukiyin8evgrfph4es.png"><br><br>  <a href="">Se suponía que el</a> lunes tendría lugar oficialmente <i>( <s>pero hasta ahora esto no ha sucedido ...</s> <b>ACTUALIZADO 20/06</b> : el anuncio <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">apareció</a> en el blog de K8) El</i> próximo lanzamiento de <i>Kubernetes</i> es <a href="">1.15</a> .  Según la tradición que se ha desarrollado para nuestro blog, hablamos de los cambios más significativos en la nueva versión. <br><br>  La información utilizada para preparar este material se toma de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">la tabla de seguimiento de mejoras de Kubernetes</a> , <a href="">CHANGELOG-1.15</a> y cuestiones relacionadas, solicitudes de extracción, así como las Propuestas de mejora de Kubernetes (KEP).  Dado que la conferencia KubeCon en Shanghai se llevará a cabo la próxima semana, este lanzamiento tuvo un ciclo acortado de 11 semanas (en lugar de 12 semanas), que, sin embargo, no afectó significativamente la cantidad de cambios significativos.  ¡Entonces vamos! .. <a name="habracut"></a><br><br><h2>  Almacenes de datos </h2><br>  Introdujo un <b>nuevo API <code>ExecutionHook</code></b> , que le permite ejecutar dinámicamente comandos de usuario en un pod / contenedor o grupo de pods / contenedores, y con él el controlador correspondiente ( <code>ExecutionHookController</code> ) que implementa la gestión del ciclo de vida del gancho.  La motivación para la aparición de esta función fue el deseo de proporcionar a los usuarios la capacidad de crear / eliminar instantáneas de acuerdo con la lógica de la aplicación, es decir.  ejecute cualquier comando específico de la aplicación antes y después de crear la instantánea.  Se supone que dichos enlaces también pueden ser útiles en otras situaciones, por ejemplo, realizar actualizaciones, depurar, actualizar archivos de configuración, reiniciar el contenedor, prepararse para otros eventos como la migración de la base de datos.  Estado actual - versión alfa (se espera que se traduzca a beta para la próxima versión), detalles - en <a href="">KEP</a> . <br><br>  <b>En el almacenamiento efímero</b> , que le permite diferenciar para contenedores / contenedores específicos el volumen de espacio compartido compartido <i>(almacenamiento compartido)</i> , <b><a href="">se ha</a> agregado <a href="">soporte para las cuotas del</a></b> sistema de archivos.  Este nuevo mecanismo utiliza <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">cuotas de proyectos</a> disponibles en XFS y ext4, que proporcionan monitoreo del consumo de recursos y la imposición opcional de límites sobre ellos.  Estado actual - versión alfa;  aún no se han especificado planes para lanzamientos futuros. <br><br>  Otra nueva característica introducida por sig-storage es el uso de PVC existentes como <code>DataSource</code> para crear nuevos PVC.  En otras palabras, esta es una <b>implementación de la función de clonación de volumen</b> .  Los clones deben distinguirse de las instantáneas, ya que cada clon es un volumen nuevo y "completo": se crea como una copia de uno existente, pero sigue completamente el ciclo de vida de los volúmenes ordinarios (a diferencia de las instantáneas, aunque son copias de volúmenes en un determinado momento, pero no independientes volúmenes).  Ilustración de oportunidad: <br><br><pre> <code class="plaintext hljs">kind: PersistentVolumeClaim apiVersion: v1 metadata: name: pvc-2 namespace: myns spec: capacity: storage: 10Gi dataSource: kind: PersistentVolumeClaim name: pvc-1</code> </pre> <br>  <i>En este caso, se creará un nuevo PV / PVC independiente ( <code>pvc-2</code> ) que contenga los mismos datos que en <code>pvc-1</code> .</i>  <i>Se indica que el nuevo PVC debe tener el mismo espacio de nombres que el original.</i> <br><br>  Las limitaciones existentes son compatibles solo con el aprovisionador dinámico y solo los complementos CSI (deben tener la capacidad <code>CLONE_VOLUME</code> ).  Lea más en <a href="">KEP</a> . <br><br>  Las siguientes características han "crecido" al estado de la versión beta (y, por lo tanto, a la activación en las instalaciones predeterminadas de Kubernetes): <br><br><ul><li>  <a href="">Función de</a> expansión de tamaño de volumen persistente `` en línea '', es decir  sin la necesidad de reiniciar el pod usando el PVC apropiado.  Por primera vez (en estado alfa), apareció en K8s 1.11. </li><li>  <a href="">Soporte para</a> variables de entorno para nombres de directorio montados como <code>subPath</code> , que se introdujo por primera vez en K8s 1.11 y se desarrolló en el pasado 1.14. </li></ul><br>  Pero el proceso de migración de los componentes internos de los antiguos complementos para repositorios implementados dentro de la base de código de Kubernetes (en el árbol) se ha prolongado a favor de los complementos para la nueva interfaz CSI.  Se esperaba que el lanzamiento de 1.15 completara la migración de todos los complementos de los proveedores de la nube, sin embargo, se <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">decidió</a> mantener el estado de la versión alfa, ya que la función depende de las API introducidas en K8s 1.15 y hasta ahora solo se implementa en la versión alfa (en particular, estamos hablando de mejoras en soporte de Azure: complementos de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Azure File</a> y <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Azure Disk</a> en csi-translation-lib). <br><br><h2>  Planificador </h2><br>  Dos innovaciones notables, ambas en forma alfa hasta ahora, están disponibles en el Programador de Kubernetes. <br><br>  El primero es el <b>marco de programación</b> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Kubernetes Scheduling Framework</a> ), que es un nuevo conjunto de API para complementos que amplían las capacidades de un programador existente.  Los complementos se crean fuera del repositorio principal (fuera del árbol), pero se incluyen en el planificador durante la compilación.  Por lo tanto, el núcleo funcional del planificador sigue siendo tan simple y conveniente como sea posible, y las características adicionales se implementan por separado, sin las muchas restricciones que la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">forma actual de</a> expandir las características del planificador "sufrió" con la ayuda de webhooks. <br><br>  En el nuevo marco, cada intento de programación de pod se divide en dos etapas: <br><br><ul><li>  <i>ciclo de programación</i> : donde se selecciona el nodo para el pod, </li><li>  y enlace <i>(ciclo de enlace)</i> : donde la solución seleccionada se implementa dentro del clúster. </li></ul><br>  En cada una de estas etapas (juntas también se denominan <i>contexto de programación</i> ), hay muchos <i>puntos de extensión</i> , en cada uno de los cuales se pueden llamar los complementos del marco. <br><br><img src="https://habrastorage.org/webt/9m/2m/0p/9m2m0pnjignm_ozrazd_0fuiuza.png"><br>  <i>(Ciclo de vida para llamar a complementos en Scheduling Framework).</i> <br><br>  Como parte de la versión alfa del framework, solo <i>se implementan los puntos</i> <i>Reserve</i> , <i>Unreserve</i> y <i>Prebind</i> .  Lea más sobre esta innovación masiva en <a href="">KEP</a> . <br><br>  La segunda es la <b>opción de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">No Preliminar</a> para <code>PriorityClasses</code></b> . <br><br>  Las clases de prioridad recibieron un estado estable (GA) en la última versión de Kubernetes, lo que afectó la planificación y selección de pods: los pods se planifican según la prioridad, y si el pod no se puede crear debido a la falta de recursos, entonces los pods Se puede desplazar una prioridad más baja para liberar el espacio necesario. <br><br>  La nueva opción: <code>Preempting</code> , definida como un booleano en la estructura <code>PriorityClass</code> , significa: si un pod está esperando su planificación y tiene <code>Preempting=false</code> , crearlo <b>no</b> prevalecerá sobre otros pods.  Este campo aparece en <code>PodSpec</code> durante el proceso de <i>admisión de pod</i> (similar al valor de <code>PriorityClass</code> ).  Los detalles de la implementación se encuentran en <a href="">KEP</a> . <br><br><h2>  Maquinaria API </h2><br>  Para <b>CustomResources</b> , se presentan mejoras diseñadas para implementar para los datos almacenados de esta manera (en el marco de JSON en CRD) un comportamiento que se corresponde mejor con el generalmente aceptado en la API de Kubernetes (para objetos K8 "nativos"): <br><br><ul><li>  <b>eliminación automática de campos</b> no especificados en los esquemas de validación de OpenAPI; para obtener más información, consulte KEP " <a href="">Poda para recursos personalizados</a> "; </li><li>  la capacidad de establecer <i>valores</i> <b>predeterminados</b> para los campos en los esquemas de validación de OpenAPI v3, que es especialmente importante para mantener la compatibilidad de la API al agregar nuevos campos a los objetos; para obtener más información, consulte KEP "Configuración <b>predeterminada de</b> <a href="">recursos personalizados</a> ". </li></ul><br>  Originalmente se planeó que ambas características se incluyeran en el lanzamiento de K8s 1.12, pero solo ahora se presentan en versiones alfa. <br><br>  Los cambios en CRD no se limitaron a esto: <br><br><ul><li>  <a href="">Publicar la función CRD OpenAPI</a> , es decir  validación CustomResources del lado del servidor (usando el esquema OpenAPI v3) introducida en la última versión de Kubernetes - alcanzó la versión beta y ahora está habilitada de manera predeterminada; </li><li>  <a href="">El mecanismo de</a> conversión de versión <a href="">para</a> recursos CRD basado en webhooks externos también se ha convertido a beta. </li></ul><br>  Otra innovación interesante se llama <a href=""><b>Watch bookmark</b></a> .  Su esencia se reduce a agregar un nuevo tipo de evento a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Watch API</a> - <code>Bookmark</code> .  Este tipo significa una etiqueta que el reloj ya ha procesado todos los objetos hasta un cierto <code>resourceVersion</code> .  Dicho mecanismo reducirá la carga en kube-apiserver, reduciendo la cantidad de eventos que deben procesarse cada vez que se reinicia el reloj, así como la cantidad de errores no deseados como <i>"versión de recursos demasiado antigua"</i> .  En Kubernetes 1.15, la función tiene el estado de la versión alfa, y se espera su aumento a beta para la próxima versión. <br><br><pre> <code class="plaintext hljs"> Added EventType = "ADDED" Modified EventType = "MODIFIED" Deleted EventType = "DELETED" Error EventType = "ERROR" Bookmark EventType = "BOOKMARK"</code> </pre> <br>  <i>(Posibles tipos de eventos en la API Watch).</i> <br><br>  En Admisión Webhooks: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Se agregó</a> soporte para un <i><a href="">selector de objetos</a></i> además de los selectores de espacio de nombres existentes </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">implementó la</a> capacidad de registrar una versión específica de un recurso y llamar cuando se modifica cualquier versión anterior de este recurso; </li><li>  El campo <code>Option</code> se ha <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">agregado</a> a la API AdmissionReview, que informa las opciones para la operación que se realiza. </li></ul><br><h2>  Red </h2><br>  Una innovación importante en la parte de la red de Kubernetes es la llamada " <i>Protección del finalizador"</i> para equilibradores de carga.  Ahora, antes de eliminar los recursos de LoadBalancer, se verifica que el recurso del Servicio correspondiente no se haya eliminado por completo.  Para hacer esto, se adjunta un llamado finalizador a cada servicio con <code>type=LoadBalancer</code> : cuando se elimina dicho servicio, la eliminación real del recurso se bloquea hasta que se elimina el finalizador, y el finalizador no se elimina hasta que se completa la "eliminación" de los recursos del equilibrador de carga correspondiente ( <code>service.kubernetes.io/load-balancer-cleanup</code> ).  La versión actual de la implementación es la versión alfa, y los detalles al respecto se pueden encontrar en <a href="">KEP</a> . <br><br>  Además <br><br><ul><li>  El <a href="">complemento NodeLocal DNS Cache</a> introducido en Kubernetes 1.13 y que mejora el rendimiento de DNS ha llegado a beta. </li><li>  Kube-proxy ya no <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">elimina</a> automáticamente las reglas de red creadas como resultado de su funcionamiento en otros modos (esto requiere el lanzamiento explícito de <code>kube-proxy --cleanup</code> ). </li></ul><br><h2>  CLI </h2><br>  Como siempre, hubo algunos pequeños detalles agradables en los comandos de consola para trabajar con clústeres de Kubernetes: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">La transferencia de</a> <code>kubectl get</code> para recibir datos del servidor (y no del cliente) para admitir completamente las extensiones se declara completa (estable). </li><li>  En <code>kubectl top</code> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">agregó la</a> opción - <code>--sort-by</code> : <br><br><pre> <code class="bash hljs">$ kubectl --kubeconfig=kubectl.kubeconfig top pod --sort=memory NAME CPU(cores) MEMORY(bytes) elasticsearch-logging-v1-psc43 2m 2406Mi hadoop-journalnode-2 13m 362Mi hodor-v0.0.5-3204531036-fqb0q 23m 64Mi kubernetes-admin-mongo-... 5m 44Mi cauth-v0.0.5-2463911897-165m8 34m 10Mi <span class="hljs-built_in"><span class="hljs-built_in">test</span></span>-1440672787-kvx8h 0m 1Mi</code> </pre> </li><li>  En el <code>kubectl rollout restart</code> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">agregó</a> soporte para DaemonSets y StatefulSets. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Se</a> ha <code>kubeadm upgrade node</code> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">un</a> nuevo comando de <code>kubeadm upgrade node</code> para actualizar los nodos del clúster, reemplazando (ahora declarado obsoleto) la <code>kubeadm upgrade node config</code> <code>kubeadm upgrade node experimental-control-plane</code> y el <code>kubeadm upgrade node experimental-control-plane</code> . </li><li>  Se <code>kubeadm alpha certs certificate-key</code> nuevos comandos de <code>kubeadm alpha certs certificate-key</code> (para generar una clave aleatoria, que luego se puede pasar a <code>kubeadm init --experimental-upload-certs</code> ) y <code>kubeadm alpha certs check-expiration</code> (para verificar el período de validez de los certificados PKI locales). </li><li>  El <code>kubeadm config upload</code> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">quedado en</a> desuso porque su reemplazo ( <code>kubeadm init phase upload-config</code> ) ha madurado. </li></ul><br><h2>  Otros </h2><br>  Entre otros cambios notables en Kubernetes 1.15: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Se ha</a> agregado <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">compatibilidad con el</a> Presupuesto de interrupción de pod (PDB) para recursos / controladores basados ​​en CRD de terceros (por ejemplo: EtcdCluster, MySQLReplicaSet ...) utilizando el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">subrecurso Scale</a> .  Hasta ahora, esta es una versión beta que se estabilizará en la próxima versión.  Los detalles están en el <a href="">KEP</a> . </li><li>  Dos características para los nodos / Kubelet llegaron a la versión beta: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">soporte para</a> complementos de monitoreo de dispositivos de terceros (para eliminar todo el conocimiento específico del dispositivo de Kubelet, es decir, fuera del árbol) y <a href=""><code>SupportNodePidsLimit</code></a> (aislamiento de PID del nodo al vainas). </li><li>  <a href=""><b>La compatibilidad con los módulos Go se</b></a> ha <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">agregado</a> y habilitado de forma predeterminada <a href=""><b>para</b></a> la base de código de Kubernetes (en lugar de Godep y el modo GOPATH, que está en desuso). </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">El soporte para</a> AWS NLB (Network Load Balancer), introducido por primera vez en K8s 1.9, ha alcanzado el nivel beta.  En particular, obtuvo la capacidad de configurar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><code>accessLogs</code></a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">terminar TLS</a> y <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><code> LoadBalancerSourceRanges</code></a> . </li><li>  Se implementó la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">capacidad de</a> configurar el proveedor de la nube de Azure a partir de los secretos de Kubernetes (para esto, se ha <code>cloudConfigType</code> una nueva opción <code>cloudConfigType</code> , una de las cuales puede ser <code>secret</code> ).  Además, Kubelet en Azure ahora <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">puede funcionar</a> sin identidad de Azure ( <code>useInstanceMetadata</code> debe estar habilitado para esto). </li><li>  En el ciclo de vida del clúster, la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">posibilidad de</a> crear clústeres HA usando kubeadm se llevó a beta, y también completaron el siguiente paso (v1beta2) para <a href="">reorganizar el</a> formato del archivo de configuración de kubeadm. </li><li>  El número de pods en el estado <i>pendiente</i> en diferentes colas se <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">agrega a las</a> métricas del planificador, y se <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">agregan</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">estadísticas</a> sobre volúmenes a través de métricas de volumen de kubelet de CSI. </li><li>  Actualizaciones en el software usado / dependiente: Go 1.12.5, cri-tools 1.14.0, etcd 3.3.10 <i>(la versión no ha cambiado para el servidor, pero se ha actualizado para el cliente)</i> .  Las versiones de CNI, CSI, CoreDNS no han cambiado <i>(en una de las versiones alfa de Kubernetes 1.15 se actualizó a 1.5.0, pero luego volvió a 1.3.1)</i> , versiones compatibles de Docker. </li></ul><br><h2>  PS </h2><br>  Lea también en nuestro blog: <br><br><ul><li>  " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Kubernetes 1.14: una visión general de las innovaciones clave</a> "; </li><li>  " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Kubernetes 1.13: Una visión general de las innovaciones clave</a> "; </li><li>  " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Kubernetes 1.12: Resumen de las innovaciones clave</a> "; </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Kubernetes 1.11: una descripción general de las innovaciones clave</a> . </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/456084/">https://habr.com/ru/post/456084/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../456068/index.html">5 errores de principiante</a></li>
<li><a href="../456070/index.html">Cómo atraer usuarios al portal de autoservicio</a></li>
<li><a href="../456072/index.html">Dav1d: el decodificador AV1 más rápido ahora en Firefox por defecto</a></li>
<li><a href="../456078/index.html">Proyección de conflicto corporativo sobre conectividad de red</a></li>
<li><a href="../456082/index.html">Cómo desarrollamos recomendaciones personalizadas de productos</a></li>
<li><a href="../456086/index.html">iOS Storyboards: análisis de los pros y contras, mejores prácticas</a></li>
<li><a href="../456090/index.html">Introducción a las pruebas unitarias en Unity</a></li>
<li><a href="../456092/index.html">Siete signos preocupantes de que depende del clima, incluso si no lo cree</a></li>
<li><a href="../456094/index.html">Leemos hojas de datos 2: SPI en STM32; Temporizadores e interrupciones PWM en el STM8</a></li>
<li><a href="../456096/index.html">Lo que hace el lector promedio de geektimes mientras se cierne en las nubes</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>