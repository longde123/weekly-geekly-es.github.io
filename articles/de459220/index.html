<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👮 👨‍👩‍👦‍👦 🌨️ Integrationstests zur Überprüfung auf Speicherlecks 🆔 🏂🏽 🤸🏾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Wir schreiben viele Unit-Tests und entwickeln die SoundCloud- Anwendung für iOS. Unit-Tests sehen sehr gut aus. Sie sind kurz, (hoffentlich) lesbar un...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Integrationstests zur Überprüfung auf Speicherlecks</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/459220/">  Wir schreiben viele Unit-Tests und entwickeln die <b>SoundCloud-</b> Anwendung für iOS.  Unit-Tests sehen sehr gut aus.  Sie sind kurz, (hoffentlich) lesbar und geben uns das Vertrauen, dass der von uns geschriebene Code wie erwartet funktioniert.  Unit-Tests decken jedoch, wie der Name schon sagt, nur einen Codeblock ab, meistens eine Funktion oder Klasse.  Wie können Sie also Fehler abfangen, die bei Interaktionen zwischen Klassen auftreten - Fehler wie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Speicherlecks</a> ? <br><a name="habracut"></a><br><br><h3>  Speicherlecks </h3><br>  Manchmal ist es ziemlich schwierig, einen Speicherverlustfehler zu erkennen.  Es besteht die Möglichkeit eines starken Verweises auf den Delegierten, aber es gibt auch Fehler, die viel schwieriger zu erkennen sind.  Ist es beispielsweise offensichtlich, dass der folgende Code einen Speicherverlust enthalten kann? <br><br><pre><code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UseCase</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">weak</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> delegate: <span class="hljs-type"><span class="hljs-type">UseCaseDelegate?</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> service: <span class="hljs-type"><span class="hljs-type">Service</span></span> <span class="hljs-keyword"><span class="hljs-keyword">init</span></span>(service: <span class="hljs-type"><span class="hljs-type">Service</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.service = service } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">run</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { service.makeRequest(handleResponse) } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">handleResponse</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(response: ServiceResponse)</span></span></span></span> { <span class="hljs-comment"><span class="hljs-comment">// some business logic and then... delegate.operationDidComplete() } }</span></span></code> </pre> <br><br>  Da der <i>Service</i> bereits implementiert ist, gibt es keine Garantie für sein Verhalten.  <i>Indem</i> wir die Funktion <i>handleResponse</i> an eine private Funktion übergeben, die sich selbst erfasst, stellen wir dem <i>Service einen</i> starken Verweis auf <i>UseCase</i> zur <i>Verfügung</i> .  Wenn der <i>Service</i> beschließt, diesen Link beizubehalten - und wir haben keine Garantie dafür, dass dies nicht geschieht -, tritt ein Speicherverlust auf.  Bei einer flüchtigen Untersuchung des Codes ist es jedoch nicht offensichtlich, dass dies wirklich passieren kann. <br><br>  Es gibt auch einen wunderbaren <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Beitrag von John Sandell</a> über die Verwendung von Komponententests zum Erkennen von Speicherlecks für Klassen.  Im obigen Beispiel, in dem es sehr einfach ist, einen Speicherverlust zu überspringen, ist jedoch nicht immer klar, wie ein solcher Komponententest geschrieben werden soll.  (Natürlich sprechen wir hier nicht über Erfahrung.) <br><br>  Wie Guilherme <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">kürzlich</a> in einem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Beitrag schrieb</a> , sind die neuen Funktionen in der SoundCloud-App für iOS nach „sauberen Architekturmustern“ geschrieben - meistens handelt es sich um eine Art <b>VIPER</b> .  Die meisten dieser <b>VIPER-</b> Module werden mit der sogenannten <b>ModuleFactory erstellt</b> .  Eine solche <b>ModuleFactory</b> benötigt einige Eingaben, Abhängigkeiten und Konfigurationen - und erstellt einen <b>UIViewController</b> , der bereits mit dem Rest des Moduls verbunden ist und <b>auf</b> den Navigationsstapel <b>verschoben werden</b> kann. <br><br>  Dieses <b>VIPER-</b> Modul kann mehrere Delegaten, Beobachter und außer Kontrolle geratene Fehler aufweisen, von denen jeder dazu führen kann, dass der Controller nach dem Entfernen aus dem Navigationsstapel im Speicher verbleibt.  In diesem Fall erhöht sich der Arbeitsspeicher, und das Betriebssystem entscheidet sich möglicherweise dafür, die Anwendung zu stoppen. <br><br>  Ist es also möglich, so viele potenzielle Lecks abzudecken, indem Sie so wenige Unit-Tests wie möglich schreiben?  Wenn nicht, dann war das alles eine enorme Zeitverschwendung. <br><br><h3>  Integrationstests </h3><br>  Die Antwort lautet, wie Sie vielleicht aus dem Titel dieses Beitrags erraten haben, ja.  Und das tun wir durch Integrationstests.  Mit dem Integrationstest soll getestet werden, wie Objekte miteinander interagieren.  Natürlich sind <b>VIPER-</b> Module Gruppen von Objekten, Speicherlecks sind eine Form der Interaktion, die wir unbedingt vermeiden möchten. <br><br>  Unser Plan ist einfach: Wir werden unsere <i>ModuleFactory verwenden</i> , um ein <b>VIPER-</b> Modul zu instanziieren.  Dann entfernen wir den Link zum <i>UIViewController</i> und stellen sicher, dass alle wichtigen Teile des Moduls zusammen mit diesem zerstört werden. <br><br>  Das erste Problem, dem wir gegenüberstehen, ist, dass wir von Natur aus nicht einfach auf einen anderen Teil des <b>VIPER-</b> Moduls als den <i>UIViewController zugreifen können</i> .  Die einzige <i>öffentliche</i> Funktion in unserer <b>ModuleFactory</b> ist <b>func</b> <i>make () -&gt; UIViewController</i> .  Was aber, wenn wir nur für unsere Tests einen weiteren Einstiegspunkt hinzufügen?  Diese neue Methode wird über <b>intern</b> deklariert, sodass wir nur über den <i>@ testable-Import</i> , das <i>ModuleFactory-</i> Framework, darauf <i>zugreifen können</i> .  Es werden Links zu allen wichtigen Teilen des Moduls zurückgegeben, die wir dann halten könnten, damit schwache Links in unseren Test aufgenommen werden.  Es sieht letztendlich so aus: <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ModuleFactory</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//     ,   ... public func make() -&gt; UIViewController { makeAndExpose().view } typealias ModuleComponents = ( view: UIViewController, presenter: Presenter, Interactor: Interactor ) func makeAndExpose() -&gt; ModuleComponents { // Set up code, and then... return ( view: viewController, presenter: presenter, interactor: interactor ) } }</span></span></code> </pre><br><br>  Dies löst das Problem des fehlenden direkten Zugriffs auf Objektdaten.  Dies ist natürlich nicht ideal, aber es entspricht unseren Anforderungen. Schreiben wir also den Test.  Es wird so aussehen: <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ModuleMemoryLeakTests</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">XCTestCase</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//      .     //    . private var view: UIViewController? //        //   ,    // UIKit,   UIViewController  . private weak var presenter: Presenter? private weak var interactor: Interactor? //   setUp    ModuleFactory  //   makeAndExpose.     ,   //     ModuleComponents // ,          . //     . func setUp() { super.setUp() let moduleFactory = ModuleFactory(/* mocked dependencies &amp; config */) let components = moduleFactory.makeAndExpose() view = components.view presenter = components.presenter interactor = components.interactor } //   ,   tearDown   , //        ,     ,   //     . func tearDown() { view = nil presenter = nil interactor = nil super.tearDown() } func test_module_doesNotLeakMemory() { //   ,      . //      ,  //          setUp. XCTAssertNotNil(presenter) XCTAssertNotNil(interactor) //        . //    ,   //     ,    //      . view = nil // ,  ,    //  Presenter  Interactor   . //  ,       //  ,    . XCTAssertNil(presenter) XCTAssertNil(interactor) } }</span></span></code> </pre><br><br>  So haben wir eine einfache Möglichkeit, Speicherlecks im <b>VIPER-</b> Modul zu erkennen.  Es ist keineswegs ideal und erfordert eine bestimmte Benutzerarbeit für jedes neue Modul, das wir testen möchten, aber dies ist sicherlich viel weniger Arbeit als das Schreiben separater Komponententests für jeden möglichen Speicherverlust.  Es hilft auch dabei, Speicherlecks zu identifizieren, die wir nicht einmal vermuten.  Tatsächlich hat sich nach dem Schreiben mehrerer dieser Tests herausgestellt, dass wir einen Test haben, der nicht bestanden wird, und nach einigen Recherchen haben wir einen Speicherverlust im Modul festgestellt.  Nach der Korrektur sollte der Test wiederholt werden. <br><br>  Es gibt uns auch einen Ausgangspunkt für das Schreiben eines allgemeineren Satzes von Integrationstests für Module.  Wenn wir nur eine starke Verbindung zu <b>Presenter</b> <b>beibehalten</b> und den <b>UIViewController</b> durch <b>Mock</b> ersetzen, können wir Benutzereingaben fälschen, dann die Presenter-Methoden aufrufen und die Dummy-Anzeige der Daten in der <b>Ansicht</b> überprüfen. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de459220/">https://habr.com/ru/post/de459220/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de459206/index.html">9 Jahre in einem Monolithen bei Node.JS</a></li>
<li><a href="../de459208/index.html">Laufen mit Prothesen: Nekstgen-Simulation der menschlichen Bewegung mit Muskeln, Knochen und einem neuronalen Netzwerk</a></li>
<li><a href="../de459212/index.html">Eigenschaftsimplementierung in C ++</a></li>
<li><a href="../de459214/index.html">Fehlertoleranz im Qsan-Speicher</a></li>
<li><a href="../de459216/index.html">B-Baum-Datenstruktur</a></li>
<li><a href="../de459224/index.html">Vom Makler zum Spieleentwickler 2. „Operation: Android“</a></li>
<li><a href="../de459226/index.html">"Fast-PoE und Perpetual-PoE - sind das neue Standards oder nicht?"</a></li>
<li><a href="../de459230/index.html">Eine Reise zum Call Center und Product Backlog mit den Augen des Entwicklers</a></li>
<li><a href="../de459232/index.html">Surround, Bite, Cut: Der neue Mini AI Cup # 4 Wettbewerb</a></li>
<li><a href="../de459234/index.html">Smem - Berichte zur Speicherzuordnung zwischen Prozessen und Benutzern unter Linux</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>