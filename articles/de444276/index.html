<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤛🏾 👿 📚 Einführung in die Reaktion auf Faserarchitektur ✋🏼 🌔 👥</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hallo Habr! Ich mache Sie auf eine Übersetzung des Artikels "React Fibre Architecture" von Andrew Clark aufmerksam . 
 Eintrag 


 React Fibre ist ein...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Einführung in die Reaktion auf Faserarchitektur</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/444276/"><p> Hallo Habr!  Ich mache Sie auf eine Übersetzung des Artikels <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">"React Fibre Architecture"</a> von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Andrew Clark aufmerksam</a> . </p><br><h2 id="vstuplenie">  Eintrag </h2><br><p>  React Fibre ist eine progressive Implementierung des wichtigsten React-Algorithmus.  Dies ist der Höhepunkt einer zweijährigen Studie des React-Entwicklungsteams. </p><br><p>  Das Ziel von Fibre ist es, die Produktivität bei der Entwicklung von Aufgaben wie Animation, Organisieren von Elementen auf einer Seite und Verschieben von Elementen zu steigern.  Das Hauptmerkmal ist das inkrementelle Rendern: Die Möglichkeit, die Rendering-Arbeit in Einheiten zu unterteilen und auf mehrere Frames zu verteilen. </p><br><p>  Weitere wichtige Funktionen sind die Möglichkeit, eingehende Aktualisierungen des DOM-Baums anzuhalten, abzubrechen oder wiederzuverwenden, verschiedene Arten von Aktualisierungen zu priorisieren und die Koordination von Grundelementen. </p><a name="habracut"></a><br><p>  <em>Bevor Sie diesen Artikel lesen, empfehlen wir Ihnen, sich mit den Grundprinzipien von React vertraut zu machen:</em> </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Reagieren Sie auf Komponenten, Elemente und Instanzen</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Versöhnung</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Reagieren - Grundlegende theoretische Konzepte</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Gestaltungsprinzipien</a> </li></ul><br><h2 id="obzor">  Rückblick </h2><br><h4 id="chto-takoe-sverka-reconciliation">  Was ist Versöhnung? </h4><br><p>  <strong>Die Abstimmung</strong> ist ein Reaktionsalgorithmus, mit dem ein Elementbaum von einem anderen unterschieden wird, um die Teile zu bestimmen, die ersetzt werden müssen. </p><br><p>  <strong>Ein Update</strong> ist eine Änderung der Daten, die zum Rendern einer React-Anwendung verwendet werden.  Dies ist normalerweise das Ergebnis des Aufrufs der setState-Methode.  Das Endergebnis des Renderns der Komponente. </p><br><p>  Die Schlüsselidee der React-API besteht darin, sich Updates so vorzustellen, als könnten sie zu einem vollständigen Rendern der Anwendung führen.  Auf diese Weise kann der Entwickler deklarativ handeln und sich keine Gedanken darüber machen, wie rational der Übergang der Anwendung von einem Zustand in einen anderen sein wird (von A nach B, von B nach C, von C nach A usw.). </p><br><p>  Im Allgemeinen funktioniert das Rendern der gesamten Anwendung für jede Änderung nur in den meisten herkömmlichen Anwendungen.  In der realen Welt wirkt sich dies nachteilig auf die Leistung aus.  Der Vorgang umfasst Optimierungen, die eine vollständige Renderansicht erstellen, ohne einen großen Teil der Leistung zu beeinträchtigen.  Die meisten dieser Optimierungen umfassen einen Prozess namens Abgleich. </p><br><p>  Die Abstimmung ist ein Algorithmus hinter dem, was wir gewohnt sind, "virtuelles DOM" zu nennen.  Die Definition klingt ungefähr so: Wenn Sie eine React-Anwendung rendern, wird der Elementbaum, der die Anwendung beschreibt, im reservierten Speicher generiert.  Dieser Baum wird dann in die Rendering-Umgebung aufgenommen. Am Beispiel einer Browser-Anwendung wird er in eine Reihe von DOM-Operationen übersetzt.  Wenn der Anwendungsstatus aktualisiert wird (normalerweise durch Aufrufen von setState), wird ein neuer Baum generiert.  Der neue Baum wird mit dem vorherigen Baum verglichen, um genau die Vorgänge zu berechnen und zu aktivieren, die zum erneuten Zeichnen der aktualisierten Anwendung erforderlich sind. </p><br><p>  Obwohl Fibre eine enge Implementierung des Reconcilers ist, wird der in der React-Dokumentation erläuterte High-Level-Algorithmus ziemlich gleich sein. </p><br><h4 id="klyuchevye-ponyatiya">  Schlüsselkonzepte: </h4><br><ul><li>  Verschiedene Arten von Komponenten legen die Erzeugung wesentlich unterschiedlicher Bäume nahe.  React versucht nicht, sie zu vergleichen, sondern ersetzt einfach den alten Baum vollständig. </li><li>  Listen werden anhand von Schlüsseln unterschieden.  Schlüssel sollten "dauerhaft, vorhersehbar und eindeutig" sein. </li></ul><br><h2 id="sverka-protiv-renderinga">  Versöhnung vs. Rendern </h2><br><p>  Der DOM-Baum ist eine der Umgebungen, die React zeichnen kann, der Rest kann nativen iOS- und Android-Ansichten mit React Native zugeordnet werden (aus diesem Grund ist Virtual Dom ein wenig unangemessener Name). </p><br><p>  Der Grund, warum React so viele Ziele unterstützt, liegt darin, dass React so aufgebaut ist, dass Abgleich und Rendern separate Phasen sind.  Der arbeitende Abgleich berechnet, welche Teile des Baums geändert wurden. Der Renderer verwendet diese Informationen später, um den zuvor gerenderten Baum zu aktualisieren. </p><br><p>  Diese Trennung bedeutet, dass React DOM und React Native ihre eigenen Rendering-Mechanismen verwenden können, wenn dasselbe Caching-Tool verwendet wird, das sich in React Core befindet. </p><br><p>  Fiber ist eine neu gestaltete Implementierung des Abstimmungsalgorithmus.  Es hat eine indirekte Beziehung zum Rendern, während die Rendermechanismen (Rendering) geändert werden können, um alle Vorteile der neuen Architektur zu unterstützen. </p><br><p>  <strong>Planung</strong> ist ein Prozess, der festlegt, wann die Arbeit abgeschlossen sein soll. </p><br><p>  <strong>Arbeit</strong> - alle Berechnungen, die durchgeführt werden müssen.  Arbeit ist normalerweise das Ergebnis eines Updates (z. B. Aufruf von setState). </p><br><p>  Die Prinzipien der React-Architektur sind so gut, dass sie nur mit diesem Zitat beschrieben werden können: </p><br><blockquote>  In der aktuellen React-Implementierung wird der Baum rekursiv durchlaufen und die Rendering-Funktionen für den gesamten aktualisierten Baum in einem einzigen Tick (16 ms) aufgerufen.  In Zukunft kann er jedoch einige Aktualisierungen abbrechen, um Frame-Sprünge zu verhindern. <br>  Dies ist ein häufig diskutiertes Thema in Bezug auf React Design.  Einige beliebte Bibliotheken implementieren einen Push-Ansatz, bei dem Berechnungen durchgeführt werden, wenn neue Daten verfügbar sind.  React hält sich jedoch an den Pull-Ansatz, bei dem Berechnungen bei Bedarf abgebrochen werden können. <br>  React ist keine Bibliothek zur Verarbeitung verallgemeinerter Daten.  Dies ist eine Bibliothek zum Erstellen von Benutzeroberflächen.  Wir sind der Meinung, dass es eine eindeutige Position in der Anwendung haben sollte, um festzustellen, welche Berechnungen geeignet sind und welche nicht. <br>  Wenn sich etwas hinter den Kulissen befindet, können wir die gesamte damit verbundene Logik rückgängig machen.  Wenn die Daten schneller als die Frame-Rendering-Rate ankommen, können wir die Aktualisierungen kombinieren.  Wir können die Priorität der Arbeit, die sich aus der Benutzerinteraktion ergibt (z. B. das Erscheinen einer Animation beim Drücken einer Schaltfläche), gegenüber weniger wichtigen Arbeiten im Hintergrund (Rendern neuer vom Server geladener Inhalte) erhöhen, um das Herunterladen von Frames zu verhindern. </blockquote><br><h4 id="klyuchevye-ponyatiya-1">  Schlüsselkonzepte: </h4><br><ul><li>  In Benutzeroberflächen ist es nicht wichtig, dass jedes Update sofort angewendet wird.  In der Tat wird dieses Verhalten überflüssig sein, es wird zum Fall von Frames und zur Verschlechterung von UX beitragen. </li><li>  Verschiedene Arten von Updates haben unterschiedliche Prioritäten - Animationsupdates sollten schneller enden als beispielsweise das Aktualisieren des Datenspeichers. </li><li>  Bei einem Push-basierten Ansatz muss die Anwendung (Sie als Entwickler) entscheiden, wie die Arbeit geplant werden soll.  Ein Pull-basierter Ansatz ermöglicht es dem Framework, Entscheidungen für Sie zu treffen. </li></ul><br><p>  Reagieren im Moment hat nicht den Vorteil, in erheblichem Maße zu planen;  Aktualisierungsergebnisse für den gesamten Teilbaum werden sofort gezeichnet.  Die Schlüsselidee von Fibre besteht darin, die Elemente im React-Kernel-Algorithmus sorgfältig auszuwählen, um die Zeitplanung anzuwenden. </p><br><h2 id="chto-zhe-takoe-fiber">  Was ist Faser? </h2><br><p>  Wir werden das Herz der React Fibre-Architektur diskutieren.  Fiber ist eine Abstraktion auf niedrigerer Ebene über die Anwendung, als Entwickler es gewohnt sind zu denken.  Wenn Sie Ihre Versuche, es zu verstehen, für hoffnungslos halten, lassen Sie sich nicht entmutigen (Sie sind nicht allein).  Schau weiter und es wird endlich Früchte tragen. </p><br><p>  Und so! </p><br><p>  Wir haben dieses Hauptziel der Fiber-Architektur erreicht - React die Planung nutzen zu lassen.  Insbesondere müssen wir in der Lage sein: </p><br><ul><li>  Stoppen Sie die Arbeit und kehren Sie später zurück. </li><li>  verschiedene Arten von Arbeit priorisieren. </li><li>  Verwenden Sie die zuvor geleistete Arbeit erneut. </li><li>  brechen Sie die Arbeit ab, wenn sie nicht mehr benötigt wird. </li></ul><br><p>  Um all dies zu tun, müssen wir zuerst die Arbeit in Einheiten aufteilen.  In gewissem Sinne ist dies Faser.  Faser repräsentiert eine Arbeitseinheit. </p><br><p>  Um weiter zu gehen, kehren wir zum Grundkonzept von React <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">"Komponenten als Funktionsdaten" zurück</a> , das häufig ausgedrückt wird als: </p><br><pre><code class="javascript hljs">v = f(d)</code> </pre> <br><p>  Daraus folgt, dass das Rendern einer React-Anwendung dem Aufrufen einer Funktion gleicht, deren Hauptteil Aufrufe anderer Funktionen enthält, und so weiter.  Diese Analogie ist nützlich, wenn man an Fasern denkt. </p><br><p>  Die Art und Weise, wie Computer die Ausführungsreihenfolge eines Programms überprüfen, wird als Aufrufstapel bezeichnet.  Wenn die Funktion abgeschlossen ist, wird der neue Stapelcontainer zum Stapel hinzugefügt.  Dieser Stapelcontainer repräsentiert die Arbeit einer Funktion. </p><br><p>  Wenn Sie mit Benutzeroberflächen arbeiten, wird sofort zu viel Arbeit geleistet. Dies ist ein Problem. Dies kann zu Sprüngen in der Animation führen und wird zeitweise angezeigt.  Darüber hinaus sind einige dieser Arbeiten möglicherweise nicht erforderlich, wenn sie durch das neueste Update ersetzt werden.  Zu diesem Zeitpunkt unterscheidet sich der Vergleich zwischen der Benutzeroberfläche und der Funktion, da Komponenten eine spezifischere Verantwortung haben als Funktionen im Allgemeinen. <br>  Die neuesten Browser und React Native implementieren APIs, mit denen dieses Problem gelöst werden kann: <br>  requestIdleCallback verteilt Aufgaben so, dass Funktionen mit niedriger Priorität in einem einfachen Zeitraum aufgerufen werden, und requestAnimationFrame verteilt Aufgaben so, dass Funktionen mit hoher Priorität im nächsten Frame aufgerufen werden.  Das Problem ist, dass Sie zur Verwendung dieser APIs die Rendering-Arbeit in inkrementelle Einheiten aufteilen müssen.  Wenn Sie sich nur auf den Aufrufstapel verlassen, wird die Arbeit fortgesetzt, bis der Stapel leer ist. </p><br><p>  Wäre es nicht schön, wenn wir das Verhalten des Aufrufstapels anpassen könnten, um die Anzeige von Teilen der Benutzeroberfläche zu optimieren?  Wäre es schön, wenn wir den Aufrufstapel brechen könnten, um Container manuell zu manipulieren? </p><br><p>  Dies ist die Berufung von React Fibre.  Fibre ist eine neue Stack-Implementierung, die auf React-Komponenten zugeschnitten ist.  Sie können sich eine einzelne Glasfaser als virtuellen Stapelcontainer vorstellen. </p><br><p>  Der Vorteil dieser Implementierung des Stapels besteht darin, dass Sie den Containerstapel im Speicher speichern und dann (und wo) ausführen können.  Dies ist eine entscheidende Definition für das Erreichen Ihrer Planungsziele. </p><br><p>  Neben der Planung zeigen manuelle Aktionen mit dem Stack das Potenzial von Konzepten wie Konsistenz (Parallelität) und Fehlerbehandlung (Fehlergrenzen). </p><br><p>  Im nächsten Abschnitt betrachten wir die Struktur der Fasern. </p><br><h2 id="struktura-volokna">  Faserstruktur </h2><br><p>  Insbesondere ist eine „Faser“ ein JavaScript-Objekt, das Informationen zu einer Komponente, ihrer Eingabe und Ausgabe enthält. </p><br><p>  Die Faser stimmt mit dem Stapelbehälter überein, aber sie stimmt auch mit dem Wesen der Komponente überein. </p><br><p>  Hier sind einige wichtige Eigenschaften der „Faser“ (Diese Liste ist nicht vollständig): </p><br><p>  <strong>Typ und Schlüssel</strong> </p><br><p>  Typ und Schlüssel dienen sowohl der Faser als auch den React-Elementen.  Wenn eine Faser erstellt wird, werden diese beiden Felder direkt darauf kopiert. </p><br><p>  Der Fasertyp beschreibt die Komponente, der er entspricht.  Für die Zusammensetzung von Komponenten ist Typ eine Funktion oder Klasse von Komponenten.  Für Servicekomponenten (div, span) ist der Typ eine Zeichenfolge. </p><br><p>  Konzeptionell ist ein Typ eine Funktion, deren Ausführung von einem Stapelcontainer verfolgt wird. </p><br><p>  Zusammen mit dem Typ wird der Schlüssel beim Vergleichen von Bäumen verwendet, um festzustellen, ob die Faser wiederverwendet werden kann. </p><br><p>  <strong>Kind und Geschwister</strong> <strong><br></strong> <br>  Diese Felder zeigen auf andere Fasern und beschreiben die rekursive Struktur der Fasern. </p><br><p>  Das untergeordnete Glasfaserkabel entspricht dem Wert, der beim Aufrufen der Rendermethode für die Komponente zurückgegeben wurde.  Im folgenden Beispiel: </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Parent</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">Child</span></span></span></span><span class="xml"><span class="hljs-tag"> /&gt;</span></span></span><span class="xml"> }</span></span></code> </pre> <br><p>  Parent Fibre Child entspricht Child. </p><br><p>  Das relative (oder Nachbar-) Feld wird verwendet, wenn beim Rendern mehrere untergeordnete Elemente zurückgegeben werden (eine neue Funktion in Fibre): </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Parent</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [<span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">Child1</span></span></span></span><span class="xml"><span class="hljs-tag"> /&gt;</span></span></span><span class="xml">, </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">Child2</span></span></span></span><span class="xml"><span class="hljs-tag"> /&gt;</span></span></span><span class="xml">] }</span></span></code> </pre> <br><p>  Kinderfasern sind eine einfach verknüpfte Liste, an deren Spitze das erste Kind steht.  In diesem Beispiel ist das untergeordnete Element Child1, und die Verwandten von Child1 sind Child2. </p><br><p>  Zurück zu unserer Analogie mit Funktionen: Sie können sich eine untergeordnete Faser als eine Funktion vorstellen, die am Ende aufgerufen wird (Schwanzfunktion). </p><br><p>  Wikipedia-Beispiel: </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">data</span></span></span><span class="hljs-function">) </span></span>{ a(data); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> b(data); }</code> </pre> <br><p>  In diesem Beispiel lautet die Schwanzfunktion b. </p><br><p>  <strong>Rückgabewert (Rückgabe)</strong> </p><br><p>  Rückfaser ist die Faser, zu der das Programm nach der Verarbeitung der aktuellen Faser zurückkehren soll.  Dies entspricht der Rückgabe der Adresse des Stapelcontainers. <br>  Es kann auch als Ausgangsfaser betrachtet werden. </p><br><p>  Wenn eine Faser mehrere untergeordnete Fasern hat, gibt die Rückgabe jeder untergeordneten Faser die übergeordnete Faser zurück.  Im obigen Beispiel ist die Rückgabefaser von Child1 und Child2 Parent. </p><br><p>  <strong>Aktuelle und zwischengespeicherte Eigenschaften (ausstehendeProps und gespeicherteProps)</strong> </p><br><p>  Konzeptionell sind Eigenschaften Funktionsargumente.  Die aktuellen Fasereigenschaften sind eine Reihe dieser Eigenschaften zu Beginn der Ausführung, zwischengespeicherte Eigenschaften sind eine Menge am Ende der Ausführung. </p><br><p>  Wenn die Eigenschaften der Eingabewartung zwischengespeichert werden, bedeutet dies, dass die vorherige Faserausgabe ohne Berechnungen wiederverwendet werden kann. </p><br><p>  <strong>Priorität der aktuellen Arbeit (ausstehendeWorkPriority)</strong> </p><br><p>  Der Umfang der prioritätsbestimmenden Arbeit wird von der Faser angezeigt.  Das Prioritätsstufenmodul in React <a href="">ReactPrioritylevel</a> enthält verschiedene Prioritätsstufen und deren Darstellung. </p><br><p>  Beginnend mit einer Ausnahme vom Typ NoWork (0) definiert eine höhere Zahl die niedrigste Priorität.  Mit der folgenden Funktion können Sie beispielsweise überprüfen, ob die Faserpriorität größer als die angegebene Stufe ist: </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">matchesPriority</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">fiber, priority</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> fiber.pendingWorkPriority !== <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; fiber.pendingWorkPriority &lt;= priority }</code> </pre> <br><p>  <em>Diese Funktion dient nur zu Illustrationszwecken.</em>  <em>Es ist nicht Teil der React Fibre-Datenbank.</em> </p><br><p>  Der Scheduler verwendet das Prioritätsfeld, um die nächste Arbeitseinheit zu finden, die ausgeführt werden kann.  Wir werden diesen Algorithmus im nächsten Abschnitt diskutieren. </p><br><p>  <strong>Alternative (oder Paar)</strong> </p><br><p>  Faser aktualisieren (spülen) - Dies bedeutet, dass die Ausgabe auf dem Bildschirm angezeigt wird. </p><br><p>  Faser in Entwicklung (in Arbeit) - Faser, die noch nicht gebaut wurde;  Mit anderen Worten, es handelt sich um einen Stapelcontainer, der noch nicht zurückgegeben wurde. </p><br><p>  Zu jedem Zeitpunkt hat die Essenz der Komponente nicht mehr als zwei Zustände für die Faser, die entsprechen: Faser in ihrem aktuellen Zustand, aktualisierte Faser oder Faser in Entwicklung. </p><br><p>  Auf die aktuelle Faser folgt die zu entwickelnde Faser, und dann wird die Faser wiederum aktualisiert. </p><br><p>  Der nächste Faserzustand wird träge mit der Funktion cloneFiber erstellt.  Fast immer versucht cloneFiber beim Erstellen eines neuen Objekts, eine Alternative (ein Paar) von Glasfasern wiederzuverwenden, falls vorhanden, und minimiert gleichzeitig die Kosten für Ressourcen. </p><br><p>  Sie sollten sich das Dampffeld (oder eine Alternative) als Implementierungsdetail vorstellen, aber es taucht so oft in der Dokumentation auf, dass es einfach unmöglich war, es nicht zu erwähnen. </p><br><p>  Schlussfolgerung ist ein Serviceelement (oder eine Reihe von Serviceelementen);  Blattknoten Reagieren Sie auf Anwendungen.  Sie sind für jede Anzeigeumgebung spezifisch (in einem Browser ist dies beispielsweise "div", "span" usw.).  In JSX werden sie als Tag-Namen in Kleinbuchstaben bezeichnet. </p><br><p>  Fazit: Ich empfehle, die Funktionen der neuen React v16.0-Architektur auszuprobieren </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de444276/">https://habr.com/ru/post/de444276/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de444264/index.html">Wie man ein Committer wird und braucht man es wirklich?</a></li>
<li><a href="../de444268/index.html">Sicherheitswoche 12: Tastaturangriffe</a></li>
<li><a href="../de444270/index.html">Group-IB-Webinar „Group-IB-Ansatz zur Cyber-Aufklärung: Ein Überblick über aktuelle Programme und praktische Fälle“</a></li>
<li><a href="../de444272/index.html">PyDERASN: Als ich die ASN.1-Bibliothek mit Slots und Blobs schrieb</a></li>
<li><a href="../de444274/index.html">Eine ausführliche Antwort auf den Kommentar sowie ein wenig über das Leben der Anbieter in der Russischen Föderation</a></li>
<li><a href="../de444278/index.html">So bringen Sie Zehntausende dazu, Ihren englischsprachigen Artikel für Habr zu lesen: 3 einfache Tipps</a></li>
<li><a href="../de444282/index.html">7 Chrome-Erweiterungen zum Englischlernen</a></li>
<li><a href="../de444284/index.html">Vervollständigung von Komponisten und Befehlszeilen</a></li>
<li><a href="../de444286/index.html">PTZ-Kamera-Analyse: Was ist drin und wie funktioniert es?</a></li>
<li><a href="../de444288/index.html">Neue mobile Anwendung LampTest.ru</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>