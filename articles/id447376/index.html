<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸš£ â„¢ï¸ ğŸ‘¨ğŸ¾â€ğŸš€ SNA Hackathon 2019 ğŸ™Œ ğŸ§“ğŸ» ğŸ‘©ğŸ¿â€ğŸ¤â€ğŸ‘©ğŸ¼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Pada bulan Februari-Maret 2019, diadakan kompetisi untuk memberi peringkat umpan jejaring sosial SNA Hackathon 2019 , di mana tim kami mengambil tempa...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>SNA Hackathon 2019</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/447376/"><p>  Pada bulan Februari-Maret 2019, diadakan kompetisi untuk memberi peringkat umpan jejaring sosial <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">SNA Hackathon 2019</a> , di mana tim kami mengambil tempat pertama.  Pada artikel ini saya akan berbicara tentang organisasi kontes, metode yang kami coba, dan pengaturan catboost untuk pelatihan tentang data besar. </p><br><p><img src="https://habrastorage.org/webt/8b/bd/vv/8bbdvvg9ih5_0h5tdqmx4fho3io.jpeg"></p><a name="habracut"></a><br><p>  <strong>SNA Hackathon</strong> </p><br><p>  Hackathon dengan nama ini diadakan untuk ketiga kalinya.  Ini diatur oleh jejaring sosial ok.ru, masing-masing, tugas dan data terkait langsung dengan jejaring sosial ini. <br>  SNA (analisis jejaring sosial) dalam hal ini lebih baik dipahami bukan sebagai analisis grafik sosial, melainkan sebagai analisis jejaring sosial. </p><br><ul><li>  Pada tahun 2014, tugasnya adalah memprediksi jumlah suka yang akan diperoleh pos. </li><li>  Pada tahun 2016, tujuan VVZ (mungkin Anda sudah familiar), lebih dekat dengan analisis grafik sosial. </li><li>  Pada tahun 2019 - peringkat umpan pengguna berdasarkan kemungkinan bahwa pengguna akan menyukai posting tersebut. </li></ul><br><p>  Saya tidak bisa mengatakan tentang 2014, tetapi pada 2016 dan 2019, selain kemampuan untuk menganalisis data, keterampilan dalam bekerja dengan data besar juga diperlukan.  Saya pikir itu adalah kombinasi dari pembelajaran mesin dan tugas pemrosesan data besar yang menarik saya ke kontes ini, dan pengalaman di bidang ini membantu untuk menang. </p><br><p>  <strong>mlbootcamp</strong> </p><br><p>  Pada 2019, kompetisi diselenggarakan di platform <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://mlbootcamp.ru</a> . </p><br><p>  Kompetisi mulai online 7 Februari dan terdiri dari 3 tugas.  Setiap orang dapat mendaftar di situs, mengunduh <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">baseline,</a> dan mengunggah mobil mereka selama beberapa jam.  Pada akhir tahap online pada 15 Maret, 15 besar dari setiap pertunjukan diundang ke kantor Mail.ru untuk tahap offline, yang berlangsung dari 30 Maret hingga 1 April. </p><br><h1 id="zadacha">  Tantangan </h1><br><p>  Sumber data menyediakan pengidentifikasi pengguna (userId) dan pengidentifikasi pos (objectId).  Jika pengguna ditampilkan sebuah posting, maka data tersebut berisi garis yang berisi userId, objectId, reaksi pengguna terhadap posting ini (umpan balik) dan satu set berbagai tanda atau tautan ke gambar dan teks. </p><br><table><thead><tr><th>  userId </th><th>  objectId </th><th>  ownerId </th><th>  umpan balik </th><th>  gambar </th></tr></thead><tbody><tr><td>  3555 </td><td>  22 </td><td>  5677 </td><td>  [disukai, diklik] </td><td>  [hash1] </td></tr><tr><td>  12842 </td><td>  55 </td><td>  32144 </td><td>  [tidak disukai] </td><td>  [hash2, hash3] </td></tr><tr><td>  13145 </td><td>  35 </td><td>  5677 </td><td>  [diklik, dibagikan ulang] </td><td>  [hash2] </td></tr></tbody></table><br><p>  Set data uji berisi struktur yang serupa, tetapi bidang umpan balik tidak ada.  Tujuannya adalah untuk memprediksi kehadiran reaksi 'disukai' di bidang umpan balik. <br>  File kirim memiliki struktur berikut: </p><br><table><thead><tr><th>  userId </th><th>  SortedList [objectId] </th></tr></thead><tbody><tr><td>  123 </td><td>  78.13.54.22 </td></tr><tr><td>  128 </td><td>  35.61.55 </td></tr><tr><td>  131 </td><td>  35,68.129,11 </td></tr></tbody></table><br><p>  Metrik - rata - rata ROC AUC oleh pengguna. </p><br><p>  Deskripsi data yang lebih terperinci dapat ditemukan di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">situs kesempurnaan</a> .  Anda juga dapat mengunduh data di sana, termasuk tes dan gambar. </p><br><p>  <strong>Panggung online</strong> </p><br><p>  Pada tahap online, tugas dibagi menjadi 3 bagian </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Sistem kolaboratif</a> - mencakup semua tanda, kecuali untuk gambar dan teks; </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Gambar</a> - hanya menyertakan informasi tentang gambar; </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Teks</a> - hanya menyertakan informasi tentang teks. </li></ul><br><p>  <strong>Tahap offline</strong> </p><br><p>  Pada tahap offline, data menyertakan semua atribut, sedangkan teks dan gambar jarang.  Ada 1,5 kali lebih banyak baris dalam dataset, yang sudah banyak. </p><br><h1 id="reshenie-zadachi">  Pemecahan masalah </h1><br><p>  Karena saya melakukan cv di tempat kerja, saya memulai perjalanan saya dalam kompetisi ini dengan tugas "Gambar".  Data yang disediakan adalah userId, objectId, ownerId (grup tempat posting diterbitkan), cap waktu membuat dan menampilkan posting, dan, tentu saja, gambar untuk posting ini. <br>  Setelah membuat beberapa fitur berdasarkan stempel waktu, ide berikutnya adalah mengambil lapisan kedua dari belakang neuron yang sudah dilatih imagenet dan mengirimkan embed ini untuk ditingkatkan. </p><br><p><img src="https://habrastorage.org/webt/g6/pq/id/g6pqidmcs0hqgilcqvmii7qdzz0.png"></p><br><p>  Hasilnya tidak mengesankan.  Embeddings dari neuron imagenet tidak relevan, saya pikir, saya perlu mengajukan encoder otomatis saya. </p><br><p><img src="https://habrastorage.org/webt/8b/n_/pu/8bn_pui29109tsvwsf_s5sktlgq.png"></p><br><p>  Butuh banyak waktu dan hasilnya tidak membaik. </p><br><p>  <strong>Pembuatan Fitur</strong> </p><br><p>  Bekerja dengan gambar membutuhkan banyak waktu, dan saya memutuskan untuk melakukan sesuatu yang lebih sederhana. <br>  Seperti yang dapat Anda lihat segera, ada beberapa tanda kategoris dalam dataset, dan agar tidak terlalu merepotkan, saya hanya mengambil catboost.  Solusinya luar biasa, tanpa pengaturan apa pun, saya langsung sampai ke baris pertama papan peringkat. </p><br><p>  Ada banyak data dan mereka diletakkan dalam format parket, jadi tanpa berpikir dua kali, saya mengambil scala dan mulai menulis semuanya dalam percikan. </p><br><p>  Fitur paling sederhana, yang memberikan pertumbuhan lebih dari embeddings gambar: </p><br><ul><li>  berapa kali objectId, userId, dan ownerId bertemu dalam data (harus berkorelasi dengan popularitas); </li><li>  berapa banyak posting userId yang dilihat ownerId (harus berkorelasi dengan minat pengguna dalam grup); </li><li>  berapa banyak pos unik userId yang ditonton oleh ownerId (mencerminkan ukuran audiens grup). </li></ul><br><p>  Dari cap waktu dimungkinkan untuk mendapatkan waktu di mana pengguna menonton rekaman itu (pagi / siang / malam / malam).  Dengan menggabungkan kategori-kategori ini, Anda dapat terus menghasilkan fitur: </p><br><ul><li>  berapa kali userId login di malam hari; </li><li>  jam berapa posting ini sering ditampilkan (objectId) dan sebagainya. </li></ul><br><p>  Semua ini secara bertahap meningkatkan metrik.  Tetapi ukuran dataset pelatihan sekitar 20 juta catatan, jadi menambahkan fitur sangat memperlambat pembelajaran. </p><br><p>  Saya mendefinisikan ulang pendekatan penggunaan data.  Meskipun data tergantung pada waktu, saya belum melihat ada informasi eksplisit yang bocor di masa depan, namun, untuk berjaga-jaga, saya mematahkannya seperti ini: </p><br><p><img src="https://habrastorage.org/webt/jf/zr/gq/jfzrgq7s0l3q465pa-cc0x-rkxq.png"></p><br><p>  Set pelatihan yang diberikan kepada kami (Februari dan 2 minggu Maret) dibagi menjadi 2 bagian. <br>  Pada data N hari terakhir ia melatih model.  Agregasi yang dijelaskan di atas dibangun di atas semua data, termasuk tes.  Pada saat yang sama, data muncul di mana berbagai encoders dari variabel target dapat dibangun.  Pendekatan paling sederhana adalah dengan menggunakan kembali kode yang sudah membuat fitur baru, dan cukup berikan dengan data yang tidak akan dilatih dan target = 1. </p><br><p>  Dengan demikian, kami mendapat fitur serupa: </p><br><ul><li>  Berapa kali userId telah melihat pos di grup ownerId; </li><li>  Berapa kali userId menyukai pos ke ownerId; </li><li>  Persentase pos yang disukai penggunaId pemilikId. </li></ul><br><p>  Artinya, ternyata <em>target maksud pengkodean</em> pada bagian dataset sesuai dengan berbagai kombinasi fitur kategorikal.  Pada prinsipnya, catboost juga membangun pengkodean target, dan dari sudut pandang ini tidak ada manfaatnya, tetapi, misalnya, menjadi mungkin untuk menghitung jumlah pengguna unik yang menyukai posting di grup ini.  Pada saat yang sama, tujuan utama tercapai - dataset saya menurun beberapa kali, dan dimungkinkan untuk terus menghasilkan fitur. </p><br><p>  Sementara catboost hanya dapat membangun encoders sesuai dengan reaksi suka, umpan balik memiliki reaksi lain: dibagikan ulang, tidak disukai, tidak disukai, diklik, diabaikan, yang dapat dilakukan secara manual.  Saya menceritakan semua jenis agregat dan menyaring fitur dengan kepentingan rendah, agar tidak mengembang dataset. </p><br><p>  Pada saat itu saya berada di tempat pertama dengan selisih yang lebar.  Satu-satunya hal yang memalukan adalah bahwa pemasangan gambar hampir tidak memberikan keuntungan.  Idenya datang untuk memberikan segalanya kepada catboost.  Cluster Kmeans gambar dan dapatkan imageCat fitur kategori baru. </p><br><p>  Berikut adalah beberapa kelas setelah secara manual memfilter dan menggabungkan kluster yang diperoleh dari KMeans. </p><br><p><img src="https://habrastorage.org/webt/i3/s5/m2/i3s5m2ftpdmvr0m_0dvpau4eggs.png"></p><br><p>  Berdasarkan imageCat kami menghasilkan: </p><br><ul><li>  Fitur kategorikal baru: <br><ul><li>  ImageCat apa yang paling sering terlihat userId; </li><li>  ImageCat mana yang paling sering ditampilkan oleh ownerId; </li><li>  ImageCat mana yang paling sering disukai userId; </li></ul></li><li>  Berbagai penghitung: <br><ul><li>  Berapa banyak imageCat unik yang tampak userId; </li><li>  Sekitar 15 fitur serupa ditambah pengodean target seperti dijelaskan di atas. </li></ul></li></ul><br><p>  <strong>Teks</strong> </p><br><p>  Hasil dalam kontes gambar cocok untuk saya dan saya memutuskan untuk mencoba sendiri dalam teks.  Sebelumnya, saya tidak banyak bekerja dengan teks dan, karena kebodohan, saya membunuh sehari di tf-idf dan svd.  Lalu saya melihat garis dasar dengan doc2vec, yang tidak hanya apa yang saya butuhkan.  Setelah sedikit menyesuaikan parameter doc2vec, saya menerima embeddings teks. </p><br><p>  Dan kemudian dia hanya menggunakan kembali kode untuk gambar, di mana dia mengganti gambar embeddings dengan embeddings teks.  Alhasil, saya mendapat posisi ke-2 dalam kontes teks. </p><br><p>  <strong>Sistem kolaboratif</strong> </p><br><p>  Hanya ada satu kompetisi di mana saya belum "menyodok", tetapi menilai oleh AUC di leaderboard, hasil kompetisi khusus ini seharusnya memiliki dampak terbesar pada tahap offline. <br>  Saya mengambil semua tanda yang ada di sumber data, memilih yang kategorikal dan menghitung agregat yang sama seperti untuk gambar, kecuali untuk fitur dari gambar itu sendiri.  Hanya menempatkannya di catboost, saya sampai di posisi ke-2. </p><br><h1 id="pervye-shagi-optimizacii-catboost">  Langkah pertama untuk mengoptimalkan catboost </h1><br><p>  Satu tempat pertama dan kedua menyenangkan saya, tetapi ada pemahaman bahwa saya tidak melakukan sesuatu yang istimewa, yang berarti bahwa kita dapat mengharapkan kehilangan posisi. </p><br><p>  Tugas kompetisi adalah untuk menentukan peringkat tulisan dalam kerangka kerja pengguna, dan selama ini saya telah memecahkan masalah klasifikasi, yaitu, saya telah mengoptimalkan metrik yang salah. </p><br><p>  Saya akan memberikan contoh sederhana: </p><br><table><thead><tr><th>  userId </th><th>  objectId </th><th>  prediksi </th><th>  kebenaran dasar </th></tr></thead><tbody><tr><td>  1 </td><td>  10 </td><td>  0,9 </td><td>  1 </td></tr><tr><td>  1 </td><td>  11 </td><td>  0.8 </td><td>  1 </td></tr><tr><td>  1 </td><td>  12 </td><td>  0,7 </td><td>  1 </td></tr><tr><td>  1 </td><td>  13 </td><td>  0,6 </td><td>  1 </td></tr><tr><td>  1 </td><td>  14 </td><td>  0,5 </td><td>  0 </td></tr><tr><td>  2 </td><td>  15 </td><td>  0,4 </td><td>  0 </td></tr><tr><td>  2 </td><td>  16 </td><td>  0,3 </td><td>  1 </td></tr></tbody></table><br><p>  Kami melakukan permutasi kecil </p><br><table><thead><tr><th>  userId </th><th>  objectId </th><th>  prediksi </th><th>  kebenaran dasar </th></tr></thead><tbody><tr><td>  1 </td><td>  10 </td><td>  0,9 </td><td>  1 </td></tr><tr><td>  1 </td><td>  11 </td><td>  0.8 </td><td>  1 </td></tr><tr><td>  1 </td><td>  12 </td><td>  0,7 </td><td>  1 </td></tr><tr><td>  1 </td><td>  13 </td><td>  0,6 </td><td>  0 </td></tr><tr><td>  2 </td><td>  16 </td><td>  0,5 </td><td>  1 </td></tr><tr><td>  2 </td><td>  15 </td><td>  0,4 </td><td>  0 </td></tr><tr><td>  1 </td><td>  14 </td><td>  0,3 </td><td>  1 </td></tr></tbody></table><br><p>  Kami mendapatkan hasil sebagai berikut: </p><br><table><thead><tr><th>  Model </th><th>  Auc </th><th>  User1 AUC </th><th>  User2 AUC </th><th>  berarti AUC </th></tr></thead><tbody><tr><td>  Opsi 1 </td><td>  0.8 </td><td>  1,0 </td><td>  0,0 </td><td>  0,5 </td></tr><tr><td>  Opsi 2 </td><td>  0,7 </td><td>  0,75 </td><td>  1,0 </td><td>  0,875 </td></tr></tbody></table><br><p>  Seperti yang Anda lihat, meningkatkan keseluruhan metrik AUC tidak berarti meningkatkan rata-rata metrik AUC dalam pengguna. </p><br><p>  Catboost <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dapat mengoptimalkan metrik peringkat di</a> luar kotak.  Saya membaca tentang metrik peringkat, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">kisah sukses</a> ketika menggunakan catboost dan mengatur YetiRankPairwise untuk belajar malam itu.  Hasilnya tidak mengesankan.  Setelah memutuskan bahwa saya belum belajar dengan baik, saya mengubah fungsi kesalahan menjadi QueryRMSE, yang, dilihat dari dokumentasi catboost, lebih cepat menyatu.  Hasilnya, saya mendapat hasil yang sama seperti saat pelatihan untuk klasifikasi, tetapi ansambel kedua model ini memberikan peningkatan yang baik, yang membawa saya ke tempat pertama di ketiga kompetisi. </p><br><p>  5 menit sebelum penutupan panggung online dalam kompetisi Sistem Kolaboratif, Sergey Shalnov memindahkan saya ke tempat kedua.  Cara selanjutnya kami pergi bersama. </p><br><h1 id="podgotovka-k-oflayn-etapu">  Mempersiapkan fase offline </h1><br><p>  Kemenangan di panggung online dijamin bagi kami di kartu video RTX 2080 TI, tetapi hadiah utama 300.000 rubel dan, bahkan, tempat pertama terakhir memaksa kami untuk bekerja selama 2 minggu ini. </p><br><p>  Ternyata, Sergey juga menggunakan catboost.  Kami bertukar ide dan fitur, dan saya mengetahui tentang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">laporan Anna Veronika Dorogush</a> di mana ada jawaban untuk banyak pertanyaan saya, dan bahkan untuk yang belum saya <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">temui</a> . </p><br><p>  Melihat laporan itu membawa saya pada gagasan bahwa perlu untuk mengembalikan semua parameter ke nilai default, dan untuk menyetel pengaturan dengan sangat hati-hati dan hanya setelah memperbaiki satu set tanda.  Sekarang, satu pelatihan memakan waktu sekitar 15 jam, tetapi satu model berhasil mendapatkan kecepatan yang lebih baik daripada di ansambel dengan peringkat. </p><br><p>  <strong>Pembuatan Fitur</strong> </p><br><p>  Dalam kompetisi "Sistem kolaboratif" sejumlah besar fitur dievaluasi sebagai penting untuk model.  Misalnya, <em>auditweights_spark_svd</em> adalah atribut yang paling penting, dan tidak ada informasi tentang artinya.  Saya pikir layak menghitung berbagai unit berdasarkan tanda-tanda penting.  Misalnya, rata-rata auditweights_spark_svd per pengguna, per grup, per objek.  Hal yang sama dapat dihitung dari data di mana pelatihan tidak dilakukan dan target = 1, yaitu, rata-rata <em>auditweights_spark_svd</em> per pengguna untuk objek yang ia sukai.  <em>Ada</em> beberapa tanda penting, selain <em>auditweights_spark_svd</em> .  Inilah beberapa di antaranya: </p><br><ul><li>  <em>auditweightsCtrGender</em> </li><li>  <em>auditweightsCtrTinggi</em> </li><li>  <em>userOwnerCounterCreateLikes</em> </li></ul><br><p>  Sebagai contoh, nilai rata-rata <em>auditweightsCtrGender</em> oleh userId ternyata menjadi fitur penting, serta nilai rata-rata <em>userOwnerCounterCreateLikes</em> oleh userId + ownerId.  Ini seharusnya membuat kami berpikir tentang bagaimana memahami arti dari ladang. </p><br><p>  Fitur penting lainnya adalah <em>auditweightsLikesCount</em> dan <em>auditweightsShowsCount</em> .  Membagi satu menjadi yang lain, fitur yang lebih penting diperoleh. </p><br><p>  <strong>Kebocoran data</strong> </p><br><p>  Model persaingan dan produksi adalah tugas yang sangat berbeda.  Saat menyiapkan data, sangat sulit untuk memperhitungkan semua detail dan tidak mentransfer beberapa informasi non-sepele tentang variabel target pada tes.  Jika kami membuat solusi produksi, kami akan mencoba menghindari penggunaan kebocoran data saat melatih model.  Tetapi jika kita ingin memenangkan kontes, maka kebocoran data adalah fitur terbaik. </p><br><p>  Setelah memeriksa data, Anda dapat melihat bahwa menurut objectId, nilai <em>auditweightsLikesCount</em> dan <em>auditweightsShowsCount</em> berubah, yang berarti bahwa rasio nilai maksimum tanda-tanda ini akan mencerminkan konversi pos jauh lebih baik daripada rasio pada saat pengiriman. </p><br><p>  Kebocoran pertama yang kami temukan adalah <em>auditweightsLikesCountMax / auditweightsShowsCountMax</em> . <br>  Tetapi bagaimana jika Anda melihat data lebih dekat?  Urutkan berdasarkan tanggal pengiriman dan dapatkan: </p><br><table><thead><tr><th>  objectId </th><th>  userId </th><th>  auditweightsShowsCount </th><th>  auditweightsLikesCount </th><th>  target (disukai) </th></tr></thead><tbody><tr><td>  1 </td><td>  1 </td><td>  12 </td><td>  3 </td><td>  mungkin juga tidak </td></tr><tr><td>  1 </td><td>  2 </td><td>  15 </td><td>  3 </td><td>  mungkin ya </td></tr><tr><td>  1 </td><td>  3 </td><td>  16 </td><td>  4 </td><td></td></tr></tbody></table><br><p>  Mengejutkan ketika saya menemukan contoh pertama dan ternyata prediksi saya tidak menjadi kenyataan.  Namun, mengingat fakta bahwa nilai maksimum dari tanda-tanda ini dalam kerangka objek memberikan peningkatan, kami tidak terlalu malas dan memutuskan untuk menemukan <em>auditweightsShowsCountNext</em> dan <em>auditweightsLikesCountNext</em> , yaitu, nilai pada saat berikutnya dalam waktu.  Menambahkan fitur <br>  <em>(auditweightsShowsCountNext-auditweightsShowsCount) / (auditweightsLikesCount-auditweightsLikesCountNext)</em> kami melakukan lompatan tajam sepanjang waktu. <br>  Kebocoran serupa dapat digunakan jika nilai-nilai berikut ditemukan untuk <em>userOwnerCounterCreateLikes</em> dalam userId + ownerId dan, misalnya, <em>auditweightsCtrGender</em> dalam objectId + userGender.  Kami menemukan 6 bidang serupa dengan kebocoran dan menarik informasi dari mereka sebanyak mungkin. </p><br><p>  Pada saat itu, kami telah memeras maksimal informasi dari atribut kolaboratif, tetapi tidak kembali ke kontes gambar dan teks.  Ada ide bagus untuk memeriksa: berapa banyak fitur secara langsung memberikan gambar atau teks dalam kompetisi yang sesuai? </p><br><p>  Tidak ada kebocoran dalam kontes untuk gambar dan teks, tetapi pada saat itu saya telah mengembalikan parameter default dari catboost, menyisir kode dan menambahkan beberapa fitur.  Hasil total: </p><br><table><thead><tr><th>  Solusi </th><th>  kecepatan </th></tr></thead><tbody><tr><td>  Maksimum dengan gambar </td><td>  0,6411 </td></tr><tr><td>  Maksimal tidak ada gambar </td><td>  0,6297 </td></tr><tr><td>  Hasil tempat kedua </td><td>  0,6295 </td></tr></tbody></table><br><table><thead><tr><th>  Solusi </th><th>  kecepatan </th></tr></thead><tbody><tr><td>  Maksimum dengan teks </td><td>  0,666 </td></tr><tr><td>  Maksimum tanpa teks </td><td>  0,660 </td></tr><tr><td>  Hasil tempat kedua </td><td>  0,656 </td></tr></tbody></table><br><table><thead><tr><th>  Solusi </th><th>  kecepatan </th></tr></thead><tbody><tr><td>  Maksimal kolaboratif </td><td>  0,745 </td></tr><tr><td>  Hasil tempat kedua </td><td>  0,723 </td></tr></tbody></table><br><p>  Menjadi jelas bahwa banyak teks dan gambar tidak mungkin diperas, dan setelah mencoba beberapa ide yang paling menarik, kami berhenti bekerja dengan mereka. </p><br><p>  Generasi fitur selanjutnya dalam sistem kolaboratif tidak memberikan pertumbuhan, dan kami mulai memberi peringkat.  Pada tahap online, ansambel klasifikasi dan peringkat memberi saya sedikit peningkatan, ternyata karena saya memiliki klasifikasi yang kurang terlatih.  Tidak ada fungsi kesalahan, termasuk YetiRanlPairwise, bahkan memberikan hasil dekat yang diberikan LogLoss (0,745 melawan 0,725).  Ada harapan untuk QueryCrossEntropy yang tidak dapat diluncurkan. </p><br><h1 id="oflayn-etap">  Tahap offline </h1><br><p>  Pada tahap offline, struktur data tetap sama, tetapi ada perubahan kecil: </p><br><ul><li>  pengidentifikasi userId, objectId, ownerId telah diacak ulang; </li><li>  beberapa tanda telah dihapus dan beberapa diganti namanya; </li><li>  data telah menjadi sekitar 1,5 kali lebih banyak. </li></ul><br><p>  Selain kesulitan yang terdaftar, ada satu nilai tambah besar: server besar dengan RTX 2080TI dialokasikan untuk tim.  Saya menikmati htop untuk waktu yang lama. <br><img src="https://habrastorage.org/webt/0c/6n/zp/0c6nzpburmw8nxsxz9y8iwkxmwa.jpeg"></p><br><p>  Idenya adalah satu - hanya untuk mereproduksi apa yang sudah ada.  Setelah menghabiskan beberapa jam menyiapkan lingkungan di server, kami secara bertahap mulai memverifikasi bahwa hasilnya sedang direproduksi.  Masalah utama yang kita hadapi adalah peningkatan volume data.  Kami memutuskan untuk sedikit mengurangi beban dan mengatur parameter catboost ctr_complexity = 1.  Ini sedikit menurunkan kecepatan, tetapi model saya mulai bekerja, hasilnya bagus - 0,733.  Sergei, tidak seperti saya, tidak membagi data menjadi 2 bagian dan melatih semua data, meskipun ini memberikan hasil terbaik pada tahap online, ada banyak kesulitan pada tahap offline.  Jika kita mengambil semua fitur yang telah kita hasilkan dan mencoba memasukkannya ke dalam catboost "di dahi", maka tidak ada yang akan terjadi di panggung online.  Sergey melakukan optimasi tipe, misalnya, mengubah tipe float64 menjadi float32.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Dalam artikel ini</a> Anda dapat menemukan informasi tentang cara mengoptimalkan memori dalam panda.  Alhasil, Sergey melatih CPU pada semua data dan ternyata sekitar 0,735. </p><br><p>  Hasil ini cukup untuk menang, tetapi kami menyembunyikan kecepatan kami yang sebenarnya dan tidak dapat memastikan bahwa tim lain tidak melakukan hal yang sama. </p><br><h1 id="bitva-do-poslednego">  Pertempuran hingga yang terakhir </h1><br><p>  <strong>Tuning kapal cat</strong> </p><br><p>  Solusi kami sepenuhnya direproduksi, kami menambahkan fitur data teks dan gambar, sehingga yang tersisa hanyalah menyesuaikan parameter catboost.  Sergey belajar pada CPU dengan sejumlah kecil iterasi, dan saya belajar dengan ctr_complexity = 1.  Hanya ada satu hari tersisa, dan jika Anda hanya menambahkan iterasi atau meningkatkan ctr_complexity, maka di pagi hari Anda bisa mendapatkan kecepatan yang lebih baik, dan berjalan sepanjang hari. </p><br><p>  Pada tahap offline, skor bisa sangat mudah disembunyikan, hanya dengan memilih bukan solusi terbaik di situs.  Kami mengharapkan perubahan tajam pada leaderboard di menit terakhir sebelum penutupan pengiriman dan memutuskan untuk tidak berhenti. </p><br><p>  Dari video Anna, saya belajar bahwa untuk meningkatkan kualitas model, yang terbaik adalah memilih parameter berikut: </p><br><ul><li>  <em>learning_rate</em> - Nilai default dihitung berdasarkan ukuran dataset.  Dengan penurunan learning_rate, perlu untuk meningkatkan jumlah iterasi untuk mempertahankan kualitas. </li><li>  <em>l2_leaf_reg</em> - Koefisien <em>regularisasi</em> , nilai default 3, lebih disukai dari 2 hingga 30. Penurunan nilai mengarah ke peningkatan overfit. </li><li>  <em>bagging_temperature</em> - Menambahkan pengacakan ke bobot objek dalam seleksi.  Nilai default adalah 1, di mana bobot dipilih dari distribusi eksponensial.  Penurunan nilai menyebabkan peningkatan pakaian dalam. </li><li>  <em>random_strength</em> - Mempengaruhi pilihan split untuk iterasi tertentu.  Semakin tinggi random_strength, semakin tinggi peluang pemisahan kepentingan rendah yang dipilih.  Pada setiap iterasi berikutnya, keacakan menurun.  Penurunan nilai menyebabkan peningkatan pakaian dalam. </li></ul><br><p>  Parameter lain secara signifikan kurang mempengaruhi hasil akhir, jadi saya tidak mencoba untuk memilihnya.  Satu iterasi pelatihan pada dataset GPU saya dengan ctr_complexity = 1 membutuhkan waktu 20 menit, dan parameter yang dipilih pada dataset berkurang sedikit berbeda dari yang optimal pada dataset lengkap.  Akibatnya, saya melakukan sekitar 30 iterasi pada 10% data, dan kemudian sekitar 10 iterasi lagi pada semua data.  Ternyata kira-kira sebagai berikut: </p><br><ul><li>  Saya meningkatkan <em>learning_rate</em> sebesar 40% dari standar; </li><li>  <em>l2_leaf_reg</em> meninggalkan yang sama; </li><li>  <em>bagging_temperature</em> dan <em>random_strength</em> dikurangi menjadi 0,8. </li></ul><br><p>  Kita dapat menyimpulkan bahwa dengan parameter default, modelnya kurang terlatih. </p><br><p>  Saya sangat terkejut ketika saya melihat hasilnya di papan peringkat: </p><br><table><thead><tr><th>  Model </th><th>  model 1 </th><th>  model 2 </th><th>  model 3 </th><th>  ansambel </th></tr></thead><tbody><tr><td>  Tanpa penyetelan </td><td>  0,7403 </td><td>  0,7404 </td><td>  0,7404 </td><td>  0,7407 </td></tr><tr><td>  Dengan penyetelan </td><td>  0,7406 </td><td>  0,7405 </td><td>  0,7406 </td><td>  0,7408 </td></tr></tbody></table><br><p>  Saya menyimpulkan sendiri bahwa jika Anda tidak memerlukan aplikasi cepat dari model, maka lebih baik untuk mengganti pemilihan parameter dengan ansambel beberapa model pada parameter yang tidak dioptimalkan. </p><br><p>  Sergey terlibat dalam mengoptimalkan ukuran dataset untuk menjalankannya pada GPU.    â€”    ,      : </p><br><ul><li>      ( ),       ; </li><li>      ; </li><li>  userId,      ; </li><li>   userId,    . </li></ul><br><p>     â€”     . </p><br><p> <strong> </strong> </p><br><p>          ,   0,742.        ctr_complexity=2   30    5 .   4   ,     ,      0,7433. </p><br><p>       ,     ,      .          predict(prediction_type='RawFormulaVal')   scale_pos_weight=neg_count/pos_count. </p><br><p><img src="https://habrastorage.org/webt/ki/yv/yj/kiyvyjpnsouo46k-ny9e9hmyjxa.png"></p><br><p>     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">    </a> . </p><br><p> <strong> </strong> </p><br><p>       . ,      ,    ,   2  . </p><br><ul><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">  </a> . ,   Mail.ru,    ,         ,     . </li><li>  ,   ,   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">   facebook</a> ,        . </li></ul><br><h1 id="zaklyuchenie">  Kesimpulan </h1><br><p>      : </p><br><ul><li>      ,       target encoding,     catboost. </li><li>     ,       ,  learning_rate  iterations.    â€”    . </li><li>     GPU. Catboost      GPU,    . </li><li>          rsm~=0.2 (CPU only)  ctr_complexity=1. </li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tidak seperti tim lain, ansambel model kami memberi peningkatan besar. </font><font style="vertical-align: inherit;">Kami bertukar ide dan menulis dalam berbagai bahasa. </font><font style="vertical-align: inherit;">Kami memiliki pendekatan berbeda untuk memisahkan data, dan saya pikir semua orang memiliki bug sendiri.</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Tidak jelas mengapa optimasi peringkat menghasilkan hasil yang lebih buruk daripada optimasi klasifikasi. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Saya mendapat sedikit pengalaman dengan teks dan pemahaman tentang bagaimana sistem rekomendasi dibuat. </font></font></li></ul><br><p><img src="https://habrastorage.org/webt/en/m_/to/enm_topolhyttqfezaldsddvjs0.jpeg"></p><br><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Terima kasih kepada panitia atas emosi, pengetahuan, dan hadiah yang diterima. </font></font></p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id447376/">https://habr.com/ru/post/id447376/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id447366/index.html">Apa cara terbaik untuk memulai proyek atau cara membuatnya sehingga tidak akan sangat menyakitkan</a></li>
<li><a href="../id447368/index.html">Bukan hanya menangkap kutu. Mengapa kecepatan sangat penting untuk setiap toko</a></li>
<li><a href="../id447370/index.html">Mengapa, karena sistem paten yang rusak, bayangan Theranos masih membayangi kita</a></li>
<li><a href="../id447372/index.html">Transformasi TI tidak bisa dihindari: harus mulai dari mana</a></li>
<li><a href="../id447374/index.html">Membuat Elemen Antarmuka Secara Programatis Menggunakan PureLayout (Bagian 2)</a></li>
<li><a href="../id447380/index.html">Pengecualian Kotlin dan fitur-fiturnya</a></li>
<li><a href="../id447382/index.html">Buku "Persatuan dan C #. Gamedev dari ide hingga implementasi. 2nd ed</a></li>
<li><a href="../id447384/index.html">Semikonduktor daya jaga ekologi</a></li>
<li><a href="../id447388/index.html">TL; DR-digest dari ITMO University: penerimaan non-klasik ke universitas, acara mendatang dan materi yang paling menarik</a></li>
<li><a href="../id447390/index.html">Pedoman konfigurasi AFA AccelStor untuk VMware vSphere</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>