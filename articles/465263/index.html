<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üç´ ‚è™ ‚òÆÔ∏è Bloquea en PostgreSQL: 3. Bloquea otros objetos üë®üèª‚Äçüåæ ü§û üë©üèº</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ya hemos hablado sobre algunos bloqueos a nivel de objeto (en particular, sobre bloqueos en las relaciones), as√≠ como sobre bloqueos a nivel de fila ,...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Bloquea en PostgreSQL: 3. Bloquea otros objetos</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/postgrespro/blog/465263/">  Ya hemos hablado sobre algunos <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">bloqueos a nivel de objeto</a> (en particular, sobre bloqueos en las relaciones), as√≠ como sobre <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">bloqueos a nivel de fila</a> , su relaci√≥n con los bloqueos de objetos y la cola de espera, que no siempre es honesto. <br><br>  Hoy tenemos una mezcolanza.  Comencemos con los <strong>puntos muertos</strong> (en realidad, iba a hablar sobre ellos la √∫ltima vez, pero ese art√≠culo result√≥ indecentemente largo), luego <strong>repasaremos los bloqueos de objetos</strong> restantes y hablaremos sobre los <strong>bloqueos de predicados</strong> en conclusi√≥n. <br><br><h1>  Puntos muertos </h1><br>  Cuando se usan bloqueos, es posible una situaci√≥n de <em>punto</em> <em>muerto</em> (o <em>punto muerto</em> ).  Ocurre cuando una transacci√≥n intenta capturar un recurso ya capturado por otra transacci√≥n, mientras que otra transacci√≥n intenta capturar un recurso capturado por la primera.  Esto se ilustra en la figura de la izquierda a continuaci√≥n: las flechas s√≥lidas muestran los recursos capturados, las flechas discontinuas muestran los intentos de capturar un recurso ya ocupado. <br><br>  Es conveniente visualizar un punto muerto mediante la construcci√≥n de un gr√°fico de expectativas.  Para hacer esto, eliminamos recursos espec√≠ficos y dejamos solo transacciones, notando qu√© transacci√≥n est√° esperando.  Si el gr√°fico tiene un contorno (desde la parte superior se puede llegar con las flechas), este es un punto muerto. <br><br><img src="https://habrastorage.org/webt/-b/rg/yr/-brgyrpjzf-xgudc27jgtyzr6d4.png"><br><a name="habracut"></a><br>  Por supuesto, el punto muerto es posible no solo para dos transacciones, sino tambi√©n para cualquier n√∫mero mayor. <br><br>  Si se produce un punto muerto, las transacciones involucradas en √©l no pueden hacer nada al respecto; esperar√°n indefinidamente.  Por lo tanto, todos los DBMS y PostgreSQL tambi√©n rastrean autom√°ticamente los puntos muertos. <br><br>  Sin embargo, la verificaci√≥n requiere ciertos esfuerzos, que no quiero hacer cada vez que se solicita un nuevo bloqueo (despu√©s de todo, los puntos muertos son bastante raros).  Por lo tanto, cuando el proceso intenta capturar el bloqueo y no puede, ingresa a la cola y se queda dormido, pero inicia el temporizador por el valor especificado en el par√°metro <em>deadlock_timeout</em> (por defecto, 1 segundo).  Si el recurso se libera antes, entonces bueno, lo guardamos en la verificaci√≥n.  Pero si despu√©s de <em>deadlock_timeout la</em> espera contin√∫a, entonces el proceso de espera se despertar√° e iniciar√° una verificaci√≥n. <br><br>  Si la verificaci√≥n (que consiste en construir un gr√°fico de expectativas y buscar contornos en ella) no revel√≥ puntos muertos, entonces el proceso contin√∫a durmiendo, ahora ya hasta el final. <br><br><blockquote>  Anteriormente en los comentarios, me reprocharon con raz√≥n por no decir nada sobre el par√°metro <em>lock_timeout</em> , que act√∫a sobre cualquier operador y evita una espera indefinidamente larga: si no se pudo obtener el bloqueo en el tiempo especificado, la declaraci√≥n finaliza con el error lock_not_available.  No debe confundirse con el par√°metro <em>Statement_timeout</em> , que limita el tiempo total de ejecuci√≥n de la instrucci√≥n, sin importar si espera un bloqueo o simplemente hace el trabajo. <br></blockquote><br>  Si se detecta un punto muerto, entonces una de las transacciones (en la mayor√≠a de los casos, la que inici√≥ la verificaci√≥n) se termina por la fuerza.  En este caso, los bloqueos capturados por √©l se liberan y las transacciones restantes pueden continuar funcionando. <br><br>  Los puntos muertos generalmente significan que la aplicaci√≥n no est√° dise√±ada correctamente.  Hay dos formas de detectar tales situaciones: en primer lugar, aparecer√°n mensajes en el registro del servidor y, en segundo lugar, aumentar√° el valor de pg_stat_database.deadlocks. <br><br><h2>  Ejemplo de punto muerto </h2><br>  Una causa com√∫n de puntos muertos es el orden diferente en el que las filas de las tablas est√°n bloqueadas. <br>  Un simple ejemplo.  La primera transacci√≥n tiene la intenci√≥n de transferir 100 rublos de la primera cuenta a la segunda.  Para hacer esto, primero reduce la primera cuenta: <br><br><pre><code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = amount - <span class="hljs-number"><span class="hljs-number">100.00</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> acc_no = <span class="hljs-number"><span class="hljs-number">1</span></span>;</code> </pre> <pre> <code class="plaintext hljs">UPDATE 1</code> </pre><br>  Al mismo tiempo, la segunda transacci√≥n tiene la intenci√≥n de transferir 10 rublos de la segunda cuenta a la primera.  Ella comienza reduciendo el segundo conteo: <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = amount - <span class="hljs-number"><span class="hljs-number">10.00</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> acc_no = <span class="hljs-number"><span class="hljs-number">2</span></span>;</code> </pre><pre> <code class="plaintext hljs">| UPDATE 1</code> </pre><br>  Ahora la primera transacci√≥n est√° tratando de aumentar la segunda cuenta, pero descubre que la fila est√° bloqueada. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = amount + <span class="hljs-number"><span class="hljs-number">100.00</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> acc_no = <span class="hljs-number"><span class="hljs-number">2</span></span>;</code> </pre><br>  Luego, la segunda transacci√≥n intenta aumentar la primera cuenta, pero tambi√©n est√° bloqueada. <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = amount + <span class="hljs-number"><span class="hljs-number">10.00</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> acc_no = <span class="hljs-number"><span class="hljs-number">1</span></span>;</code> </pre><br>  Hay una expectativa c√≠clica que nunca terminar√° por s√≠ sola.  Despu√©s de un segundo, la primera transacci√≥n, al no tener acceso al recurso, inicia una comprobaci√≥n de punto muerto y corta el servidor. <br><br><pre> <code class="plaintext hljs">ERROR: deadlock detected DETAIL: Process 16477 waits for ShareLock on transaction 530695; blocked by process 16513. Process 16513 waits for ShareLock on transaction 530694; blocked by process 16477. HINT: See server log for query details. CONTEXT: while updating tuple (0,2) in relation "accounts"</code> </pre><br>  Ahora la segunda transacci√≥n puede continuar. <br><br><pre> <code class="plaintext hljs">| UPDATE 1</code> </pre><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">ROLLBACK</span></span>;</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">ROLLBACK</span></span>;</code> </pre><br>  La forma correcta de realizar tales operaciones es bloquear los recursos en el mismo orden.  Por ejemplo, en este caso, puede bloquear cuentas en orden ascendente de sus n√∫meros. <br><br><h2>  Punto muerto para dos comandos ACTUALIZAR </h2><br>  A veces puedes obtener un punto muerto donde, al parecer, no deber√≠a ser.  Por ejemplo, es conveniente y familiar percibir los comandos SQL como at√≥micos, pero tome ACTUALIZAR: este comando bloquea las filas a medida que se actualizan.  Esto no est√° sucediendo de inmediato.  Por lo tanto, si un comando actualiza las filas en un orden y el otro en otro, pueden quedar bloqueadas. <br><br>  Es poco probable que se produzca una situaci√≥n de este tipo, pero sin embargo puede encontrarse.  Para la reproducci√≥n, crearemos un √≠ndice en la columna de cantidad, construido en orden descendente de cantidad: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INDEX</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> accounts(amount <span class="hljs-keyword"><span class="hljs-keyword">DESC</span></span>);</code> </pre><br>  Para tener tiempo de ver lo que est√° sucediendo, escribiremos una funci√≥n que aumente el valor transmitido, pero lentamente, lentamente, por un segundo: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FUNCTION</span></span> inc_slow(n <span class="hljs-type"><span class="hljs-type">numeric</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">RETURNS</span></span> <span class="hljs-type"><span class="hljs-type">numeric</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> $$<span class="pgsql"><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">SELECT</span></span></span><span class="pgsql"> pg_sleep(</span><span class="hljs-number"><span class="pgsql"><span class="hljs-number">1</span></span></span><span class="pgsql">); </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">SELECT</span></span></span><span class="pgsql"> n + </span><span class="hljs-number"><span class="pgsql"><span class="hljs-number">100.00</span></span></span><span class="pgsql">; $$</span><span class="undefined"></span></span><span class="pgsql"><span class="undefined"></span></span> <span class="hljs-keyword"><span class="hljs-keyword">LANGUAGE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SQL</span></span>;</code> </pre><br>  Tambi√©n necesitamos la extensi√≥n pgrowlocks. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">EXTENSION</span></span> pgrowlocks;</code> </pre><br>  El primer comando ACTUALIZAR actualizar√° toda la tabla.  El plan de ejecuci√≥n es obvio: un escaneo secuencial: <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">EXPLAIN</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">costs</span></span> <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>) | <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = inc_slow(amount);</code> </pre><pre> <code class="plaintext hljs">| QUERY PLAN | ---------------------------- | Update on accounts | -&gt; Seq Scan on accounts | (2 rows)</code> </pre><br>  Dado que las versiones de las filas en la p√°gina de nuestra tabla est√°n en el orden creciente de la suma (exactamente como las agregamos), se actualizar√°n en el mismo orden.  Comenzamos la actualizaci√≥n para trabajar. <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = inc_slow(amount);</code> </pre><br>  Mientras tanto, en otra sesi√≥n, prohibiremos el uso del escaneo secuencial: <br><br><pre> <code class="pgsql hljs">|| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> enable_seqscan = <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>;</code> </pre><br>  En este caso, el planificador decide usar la exploraci√≥n de √≠ndice para la siguiente instrucci√≥n UPDATE: <br><br><pre> <code class="pgsql hljs">|| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">EXPLAIN</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">costs</span></span> <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>) || <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = inc_slow(amount) <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> amount &gt; <span class="hljs-number"><span class="hljs-number">100.00</span></span>;</code> </pre><pre> <code class="plaintext hljs">|| QUERY PLAN || -------------------------------------------------------- || Update on accounts || -&gt; Index Scan using accounts_amount_idx on accounts || Index Cond: (amount &gt; 100.00) || (3 rows)</code> </pre><br>  La segunda y tercera filas se encuentran bajo la condici√≥n y, dado que el √≠ndice se construye en orden descendente, las filas se actualizar√°n en orden inverso. <br><br>  Lanzamos la pr√≥xima actualizaci√≥n. <br><br><pre> <code class="pgsql hljs">|| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = inc_slow(amount) <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> amount &gt; <span class="hljs-number"><span class="hljs-number">100.00</span></span>;</code> </pre><br>  Un vistazo r√°pido a la p√°gina tabular muestra que el primer operador ya ha logrado actualizar la primera fila (0,1) y la segunda, la √∫ltima (0,3): <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pgrowlocks(<span class="hljs-string"><span class="hljs-string">'accounts'</span></span>) \gx</code> </pre><pre> <code class="plaintext hljs">-[ RECORD 1 ]----------------- locked_row | (0,1) locker | 530699 &lt;-  multi | f xids | {530699} modes | {"No Key Update"} pids | {16513} -[ RECORD 2 ]----------------- locked_row | (0,3) locker | 530700 &lt;-  multi | f xids | {530700} modes | {"No Key Update"} pids | {16549}</code> </pre><br>  Otro segundo pase.  El primer operador actualiz√≥ la segunda l√≠nea, y al segundo le gustar√≠a hacer esto, pero no puede. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pgrowlocks(<span class="hljs-string"><span class="hljs-string">'accounts'</span></span>) \gx</code> </pre><pre> <code class="plaintext hljs">-[ RECORD 1 ]----------------- locked_row | (0,1) locker | 530699 &lt;-  multi | f xids | {530699} modes | {"No Key Update"} pids | {16513} -[ RECORD 2 ]----------------- locked_row | (0,2) locker | 530699 &lt;-    multi | f xids | {530699} modes | {"No Key Update"} pids | {16513} -[ RECORD 3 ]----------------- locked_row | (0,3) locker | 530700 &lt;-  multi | f xids | {530700} modes | {"No Key Update"} pids | {16549}</code> </pre><br>  Ahora a la primera instrucci√≥n le gustar√≠a actualizar la √∫ltima fila de la tabla, pero ya est√° bloqueada por la segunda.  Aqu√≠ est√° el punto muerto. <br><br>  Una de las transacciones se cancela: <br><br><pre> <code class="plaintext hljs">|| ERROR: deadlock detected || DETAIL: Process 16549 waits for ShareLock on transaction 530699; blocked by process 16513. || Process 16513 waits for ShareLock on transaction 530700; blocked by process 16549. || HINT: See server log for query details. || CONTEXT: while updating tuple (0,2) in relation "accounts"</code> </pre><br>  Y el otro completa la ejecuci√≥n: <br><br><pre> <code class="plaintext hljs">| UPDATE 3</code> </pre><br><blockquote>  Los detalles interesantes sobre la detecci√≥n y prevenci√≥n de puntos muertos se pueden encontrar en el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">administrador de bloqueos README</a> . <br></blockquote><br>  Eso se trata de puntos muertos, y procedemos a los bloqueos de objetos restantes. <br><br><img src="https://habrastorage.org/webt/wb/wm/ho/wbwmhoocvz64odsj3qqooqup9jw.png"><br><br><h1>  Cerraduras sin relaci√≥n </h1><br>  Cuando desea bloquear un recurso que no es una <em>relaci√≥n</em> en la comprensi√≥n de PostgreSQL, se utilizan bloqueos de objetos.  Tal recurso puede ser casi cualquier cosa: espacios de tablas, suscripciones, esquemas, roles, tipos de datos enumerados ... En t√©rminos generales, todo lo que se puede encontrar en el cat√°logo del sistema. <br><br>  Veamos un ejemplo simple.  Comenzamos la transacci√≥n y creamos una tabla en ella: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> example(n <span class="hljs-type"><span class="hljs-type">integer</span></span>);</code> </pre><br>  Ahora veamos qu√© tipo de bloqueos de objetos aparecieron en pg_locks: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">database</span></span>, (<span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> datname <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_database <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> <span class="hljs-type"><span class="hljs-type">oid</span></span> = l.<span class="hljs-keyword"><span class="hljs-keyword">database</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> dbname, classid, (<span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> relname <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_class <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> <span class="hljs-type"><span class="hljs-type">oid</span></span> = l.classid) <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> classname, objid, mode, granted <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_locks l <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> l.locktype = <span class="hljs-string"><span class="hljs-string">'object'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> l.pid = pg_backend_pid();</code> </pre><pre> <code class="plaintext hljs"> database | dbname | classid | classname | objid | mode | granted ----------+--------+---------+--------------+-------+-----------------+--------- 0 | | 1260 | pg_authid | 16384 | AccessShareLock | t 16386 | test | 2615 | pg_namespace | 2200 | AccessShareLock | t (2 rows)</code> </pre><br>  Para comprender qu√© se bloquea exactamente aqu√≠, debe mirar tres campos: base de datos, classid y objid.  Comencemos con la primera l√≠nea. <br><br>  La base de datos es el OID de la base de datos a la que pertenece el recurso bloqueado.  En nuestro caso, hay cero en esta columna.  Esto significa que estamos tratando con un objeto global que no pertenece a ninguna base en particular. <br><br>  Classid contiene el OID de pg_class, que corresponde al nombre de la tabla de cat√°logo del sistema, que determina el tipo de recurso.  En nuestro caso, pg_authid, es decir, el rol es el recurso (usuario). <br><br>  Objid contiene el OID de la tabla de cat√°logo del sistema que classid nos indic√≥. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> rolname <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_authid <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> <span class="hljs-type"><span class="hljs-type">oid</span></span> = <span class="hljs-number"><span class="hljs-number">16384</span></span>;</code> </pre><pre> <code class="plaintext hljs"> rolname --------- student (1 row)</code> </pre><br>  Por lo tanto, el rol del estudiante est√° bloqueado, desde el cual estamos trabajando. <br><br>  Ahora tratemos con la segunda l√≠nea.  Se indica la base de datos, y esta es la base de datos de prueba a la que estamos conectados. <br><br>  Classid apunta a la tabla pg_namespace que contiene los esquemas. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> nspname <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_namespace <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> <span class="hljs-type"><span class="hljs-type">oid</span></span> = <span class="hljs-number"><span class="hljs-number">2200</span></span>;</code> </pre><pre> <code class="plaintext hljs"> nspname --------- public (1 row)</code> </pre><br>  Por lo tanto, el esquema p√∫blico est√° bloqueado. <br><br>  Entonces, vimos que al crear un objeto, el rol de propietario y el esquema en el que se crea el objeto se bloquean (en modo compartido).  Lo cual es l√≥gico: de lo contrario, alguien podr√≠a eliminar el rol o el esquema mientras la transacci√≥n a√∫n no se haya completado. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">ROLLBACK</span></span>;</code> </pre><br><h1>  Bloqueo de extensi√≥n de relaci√≥n </h1><br>  Cuando aumenta el n√∫mero de filas en una relaci√≥n (es decir, en una tabla, √≠ndice, vista materializada), PostgreSQL puede usar el espacio libre en las p√°ginas existentes para insertar, pero, obviamente, en alg√∫n momento debe agregar nuevas p√°ginas.  F√≠sicamente, se agregan al final del archivo correspondiente.  Esto se entiende como <em>expandir la relaci√≥n</em> . <br><br>  Para evitar que dos procesos se apresuren a agregar p√°ginas al mismo tiempo, este proceso est√° protegido por un bloqueo especial de tipo extender.  El mismo bloqueo se usa al limpiar √≠ndices para que otros procesos no puedan agregar p√°ginas durante el escaneo. <br><br>  Por supuesto, este bloqueo se libera sin esperar el final de la transacci√≥n. <br><br><blockquote>  Anteriormente, las tablas se expand√≠an solo una p√°gina a la vez.  Esto caus√≥ problemas cuando varios procesos insertaron filas simult√°neamente, por lo tanto, en PostgreSQL 9.6, se agregaron varias p√°ginas a las tablas a la vez (en proporci√≥n al n√∫mero de procesos que esperan el bloqueo, pero no m√°s de 512). <br></blockquote><br><h1>  Bloqueo de p√°gina </h1><br>  Se aplica un bloqueo de nivel de p√°gina en el √∫nico caso (a excepci√≥n de los bloqueos de predicados, que se analizan m√°s adelante). <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Los √≠ndices GIN le</a> permiten acelerar la b√∫squeda en valores compuestos, por ejemplo, palabras en documentos de texto (o elementos en matrices).  Para una primera aproximaci√≥n, dichos √≠ndices pueden representarse como un √°rbol B normal, en el que no se almacenan los documentos en s√≠, sino palabras individuales de estos documentos.  Por lo tanto, al agregar un nuevo documento, el √≠ndice debe reconstruirse con bastante fuerza, introduciendo en √©l cada palabra incluida en el documento. <br><br>  Para mejorar el rendimiento, los √≠ndices GIN tienen una funci√≥n de inserci√≥n retrasada que est√° habilitada por la opci√≥n de almacenamiento fastupdate.  Primero se agregan r√°pidamente nuevas palabras a la lista pendiente desordenada, y despu√©s de un tiempo, todo lo que se ha acumulado se mueve a la estructura de √≠ndice principal.  Los ahorros se deben al hecho de que es probable que diferentes documentos contengan palabras duplicadas. <br><br>  Para evitar que varios procesos pasen de la lista de espera al √≠ndice principal al mismo tiempo, la metap√°gina del √≠ndice se bloquea en modo exclusivo durante la transferencia.  Esto no interfiere con el uso del √≠ndice en modo normal. <br><br><h1>  Cerraduras de asesoramiento </h1><br>  A diferencia de otros bloqueos (como los bloqueos de relaci√≥n), los bloqueos de aviso nunca se configuran autom√°ticamente, son administrados por el desarrollador de la aplicaci√≥n.  Son convenientes de usar, por ejemplo, si una aplicaci√≥n necesita una l√≥gica de bloqueo para alg√∫n prop√≥sito que no se ajusta a la l√≥gica est√°ndar de los bloqueos ordinarios. <br><br>  Supongamos que tenemos un recurso condicional que no corresponde a ning√∫n objeto de la base de datos (que podr√≠amos bloquear con comandos como SELECT FOR o LOCK TABLE).  Necesitas encontrar un identificador num√©rico para ello.  Si el recurso tiene un nombre √∫nico, entonces una opci√≥n simple es tomarle un c√≥digo hash: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> hashtext(<span class="hljs-string"><span class="hljs-string">'1'</span></span>);</code> </pre><pre> <code class="plaintext hljs"> hashtext ----------- 243773337 (1 row)</code> </pre><br>  As√≠ es como capturamos la cerradura: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_advisory_lock(hashtext(<span class="hljs-string"><span class="hljs-string">'1'</span></span>));</code> </pre><br>  Como de costumbre, la informaci√≥n de bloqueo est√° disponible en pg_locks: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> locktype, objid, mode, granted <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_locks <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> locktype = <span class="hljs-string"><span class="hljs-string">'advisory'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> pid = pg_backend_pid();</code> </pre><pre> <code class="plaintext hljs"> locktype | objid | mode | granted ----------+-----------+---------------+--------- advisory | 243773337 | ExclusiveLock | t (1 row)</code> </pre><br>  Para que un bloqueo funcione realmente, otros procesos tambi√©n deben obtener un bloqueo antes de acceder al recurso.  Obviamente, la aplicaci√≥n debe garantizar el cumplimiento de esta regla. <br><br>  En el ejemplo anterior, el bloqueo es v√°lido hasta el final de la sesi√≥n, y no la transacci√≥n, como de costumbre. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> locktype, objid, mode, granted <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_locks <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> locktype = <span class="hljs-string"><span class="hljs-string">'advisory'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> pid = pg_backend_pid();</code> </pre><pre> <code class="plaintext hljs"> locktype | objid | mode | granted ----------+-----------+---------------+--------- advisory | 243773337 | ExclusiveLock | t (1 row)</code> </pre><br>  Debe ser lanzado expl√≠citamente: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_advisory_unlock(hashtext(<span class="hljs-string"><span class="hljs-string">'1'</span></span>));</code> </pre><br>  Hay un gran conjunto de funciones para trabajar con bloqueos de aviso para todas las ocasiones: <br><br><ul><li>  pg_advisory_lock_shared trata un bloqueo compartido, </li><li>  pg_advisory_xact_lock (y pg_advisory_xact_lock_shared) obtiene un bloqueo hasta el final de la transacci√≥n, </li><li>  pg_try_advisory_lock (as√≠ como pg_try_advisory_xact_lock y pg_try_advisory_xact_lock_shared) no espera recibir un bloqueo, pero devuelve un valor falso si el bloqueo no se pudo obtener de inmediato. </li></ul><br>  El conjunto de funciones de prueba proporciona otra forma de no esperar un bloqueo, adem√°s de las enumeradas <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">en un art√≠culo anterior</a> . <br><br><h1>  Cerraduras de predicado </h1><br>  El t√©rmino <em>bloqueo de predicados</em> apareci√≥ hace mucho tiempo, en los primeros intentos de implementar un aislamiento completo basado en bloqueos en los primeros DBMS (el nivel es serializable, aunque el est√°ndar SQL no exist√≠a en ese momento).  El problema que se encontr√≥ luego fue que incluso el bloqueo de todas las l√≠neas le√≠das y modificadas no proporciona un aislamiento completo: pueden aparecer <em>nuevas</em> l√≠neas en la tabla que caen bajo las mismas condiciones de selecci√≥n, lo que conduce a <em>fantasmas</em> (consulte el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">art√≠culo sobre aislamiento</a> ) . <br><br>  La idea de los bloqueos de predicados era bloquear predicados, no filas.  Si, al ejecutar una consulta con la condici√≥n <em>a</em> &gt; 10, el predicado <em>a</em> &gt; 10 est√° bloqueado, esto no agregar√° nuevas filas a la tabla que se encuentren bajo la condici√≥n y evitar√° fantasmas.  El problema es que, en el caso general, esta es una tarea computacionalmente dif√≠cil;  en la pr√°ctica, se puede resolver solo para predicados que tienen una forma muy simple. <br><br>  En PostgreSQL, la capa serializable se implementa de manera diferente, adem√°s del aislamiento basado en instant√°neas existente.  El t√©rmino <em>bloqueo de predicados</em> permanece, pero su significado ha cambiado radicalmente.  De hecho, tales "bloqueos" no bloquean nada, pero se utilizan para rastrear las dependencias de datos entre transacciones. <br><br>  Est√° demostrado que el aislamiento basado en im√°genes permite una <em>anomal√≠a de grabaci√≥n inconsistente</em> y una <em>anomal√≠a de solo una transacci√≥n de lectura</em> , pero no son posibles otras anomal√≠as.  Para comprender que estamos lidiando con una de las dos anomal√≠as enumeradas, podemos analizar las dependencias entre transacciones y encontrar ciertos patrones en ellas. <br><br>  Estamos interesados ‚Äã‚Äãen dos tipos de dependencias: <br><br><ul><li>  una transacci√≥n lee una fila, que luego es cambiada por otra transacci√≥n (dependencia RW), </li><li>  una transacci√≥n modifica la l√≠nea que luego lee otra transacci√≥n (dependencia WR). </li></ul><br>  Las dependencias WR se pueden rastrear utilizando bloqueos convencionales existentes, pero las dependencias RW solo tienen que rastrearse adicionalmente. <br><br>  Repito una vez m√°s: a pesar del nombre, los bloqueos de predicados no bloquean nada.  En cambio, cuando se confirma una transacci√≥n, se realiza una verificaci√≥n y, si se detecta una secuencia de dependencias "incorrecta" que puede indicar una anomal√≠a, la transacci√≥n se rompe. <br><br>  Veamos c√≥mo se produce la instalaci√≥n de bloqueos de predicados.  Para hacer esto, cree una tabla con un n√∫mero suficientemente grande de filas y un √≠ndice en ella. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> pred(n <span class="hljs-type"><span class="hljs-type">integer</span></span>); =&gt; <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> pred(n) <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> gn <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> generate_series(<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">10000</span></span>) g(n); =&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INDEX</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> pred(n) <span class="hljs-keyword"><span class="hljs-keyword">WITH</span></span> (fillfactor = <span class="hljs-number"><span class="hljs-number">10</span></span>); =&gt; <span class="hljs-keyword"><span class="hljs-keyword">ANALYZE</span></span> pred;</code> </pre><br>  Si la consulta se ejecuta mediante exploraci√≥n secuencial de toda la tabla, el bloqueo del predicado se establece en toda la tabla (incluso si no todas las filas caen bajo las condiciones de filtrado). <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_backend_pid();</code> </pre><pre> <code class="plaintext hljs">| pg_backend_pid | ---------------- | 12763 | (1 row)</code> </pre><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ISOLATION</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LEVEL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SERIALIZABLE</span></span>; | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">EXPLAIN</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">analyze</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">costs</span></span> <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>) | <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pred <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> n &gt; <span class="hljs-number"><span class="hljs-number">100</span></span>;</code> </pre><pre> <code class="plaintext hljs">| QUERY PLAN | ---------------------------------------------------------------- | Seq Scan on pred (actual time=0.047..12.709 rows=9900 loops=1) | Filter: (n &gt; 100) | Rows Removed by Filter: 100 | Planning Time: 0.190 ms | Execution Time: 15.244 ms | (5 rows)</code> </pre><br>  Todos los bloqueos de predicados siempre se capturan en un modo especial SIReadLock (Lectura de aislamiento serializable): <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> locktype, relation::<span class="hljs-type"><span class="hljs-type">regclass</span></span>, page, tuple <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_locks <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> mode = <span class="hljs-string"><span class="hljs-string">'SIReadLock'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> pid = <span class="hljs-number"><span class="hljs-number">12763</span></span>;</code> </pre><pre> <code class="plaintext hljs"> locktype | relation | page | tuple ----------+----------+------+------- relation | pred | | (1 row)</code> </pre><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">ROLLBACK</span></span>;</code> </pre><br>  Pero si la consulta se ejecuta mediante exploraci√≥n de √≠ndice, la situaci√≥n cambia para mejor.  Si hablamos del √°rbol B, entonces es suficiente establecer el bloqueo en las filas de la tabla de lectura y en las p√°ginas escaneadas del √≠ndice, por lo que bloqueamos no solo valores espec√≠ficos, sino tambi√©n todo el rango le√≠do. <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ISOLATION</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LEVEL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SERIALIZABLE</span></span>; | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">EXPLAIN</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">analyze</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">costs</span></span> <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>) | <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pred <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> n <span class="hljs-keyword"><span class="hljs-keyword">BETWEEN</span></span> <span class="hljs-number"><span class="hljs-number">1000</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> <span class="hljs-number"><span class="hljs-number">1001</span></span>;</code> </pre><pre> <code class="plaintext hljs">| QUERY PLAN | ------------------------------------------------------------------------------------ | Index Only Scan using pred_n_idx on pred (actual time=0.122..0.131 rows=2 loops=1) | Index Cond: ((n &gt;= 1000) AND (n &lt;= 1001)) | Heap Fetches: 2 | Planning Time: 0.096 ms | Execution Time: 0.153 ms | (5 rows)</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> locktype, relation::<span class="hljs-type"><span class="hljs-type">regclass</span></span>, page, tuple <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_locks <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> mode = <span class="hljs-string"><span class="hljs-string">'SIReadLock'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> pid = <span class="hljs-number"><span class="hljs-number">12763</span></span>;</code> </pre><pre> <code class="plaintext hljs"> locktype | relation | page | tuple ----------+------------+------+------- tuple | pred | 3 | 236 tuple | pred | 3 | 235 page | pred_n_idx | 22 | (3 rows)</code> </pre><br>  Puede notar varias dificultades. <br><br>  En primer lugar, se crea un bloqueo por separado para cada versi√≥n de la l√≠nea que se lee, pero potencialmente puede haber muchas de esas versiones.  El n√∫mero total de bloqueos de predicados en el sistema est√° limitado por el producto de los valores de los par√°metros <em>max_pred_locks_per_transaction</em> √ó <em>max_connections</em> (los valores predeterminados son 64 y 100, respectivamente).  La memoria para tales bloqueos se asigna al inicio del servidor;  intentar superar este n√∫mero dar√° lugar a errores. <br><br>  Por lo tanto, para bloqueos de predicados (¬°y solo para ellos!), Se utiliza un <em>aumento de nivel</em> .  Antes de PostgreSQL 10, hab√≠a restricciones que estaban cableadas en el c√≥digo y, a partir de √©l, puede controlar los par√°metros elevando el nivel.  Si el n√∫mero de bloqueos de versi√≥n de fila <em>por fila es</em> mayor que <em>max_pred_locks_per_page</em> , dichos bloqueos se reemplazan con un bloqueo de nivel de p√°gina.  Aqu√≠ hay un ejemplo: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SHOW</span></span> max_pred_locks_per_page;</code> </pre><pre> <code class="plaintext hljs"> max_pred_locks_per_page ------------------------- 2 (1 row)</code> </pre><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">EXPLAIN</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">analyze</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">costs</span></span> <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>) | <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pred <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> n <span class="hljs-keyword"><span class="hljs-keyword">BETWEEN</span></span> <span class="hljs-number"><span class="hljs-number">1000</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> <span class="hljs-number"><span class="hljs-number">1002</span></span>;</code> </pre><pre> <code class="plaintext hljs">| QUERY PLAN | ------------------------------------------------------------------------------------ | Index Only Scan using pred_n_idx on pred (actual time=0.019..0.039 rows=3 loops=1) | Index Cond: ((n &gt;= 1000) AND (n &lt;= 1002)) | Heap Fetches: 3 | Planning Time: 0.069 ms | Execution Time: 0.057 ms | (5 rows)</code> </pre><br>  En lugar de tres bloqueos de tupla, vemos un tipo de p√°gina: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> locktype, relation::<span class="hljs-type"><span class="hljs-type">regclass</span></span>, page, tuple <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_locks <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> mode = <span class="hljs-string"><span class="hljs-string">'SIReadLock'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> pid = <span class="hljs-number"><span class="hljs-number">12763</span></span>;</code> </pre><pre> <code class="plaintext hljs"> locktype | relation | page | tuple ----------+------------+------+------- page | pred | 3 | page | pred_n_idx | 22 | (2 rows)</code> </pre><br>  Del mismo modo, si el n√∫mero de bloqueos de p√°gina <em>asociados</em> con una sola relaci√≥n excede <em>max_pred_locks_per_relation</em> , dichos bloqueos se reemplazan con un bloqueo de nivel de relaci√≥n. <br><br>  No hay otros niveles: los bloqueos de predicados solo se capturan para las relaciones, p√°ginas o versiones de fila, y siempre con el modo SIReadLock. <br><br>  Por supuesto, un aumento en el nivel de bloqueos conduce inevitablemente al hecho de que un mayor n√∫mero de transacciones dar√° como resultado falsamente un error de serializaci√≥n y, como resultado, el rendimiento del sistema disminuir√°.  Aqu√≠ debe buscar un equilibrio entre el consumo de memoria y el rendimiento. <br><br>  La segunda dificultad es que en varias operaciones con el √≠ndice (por ejemplo, debido a la divisi√≥n de las p√°ginas de √≠ndice al insertar nuevas l√≠neas), el n√∫mero de p√°ginas de hoja que cubren el rango de lectura puede cambiar.  Pero la implementaci√≥n de esto tiene en cuenta: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> pred <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-number"><span class="hljs-number">1001</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> generate_series(<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1000</span></span>); =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> locktype, relation::<span class="hljs-type"><span class="hljs-type">regclass</span></span>, page, tuple <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_locks <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> mode = <span class="hljs-string"><span class="hljs-string">'SIReadLock'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> pid = <span class="hljs-number"><span class="hljs-number">12763</span></span>;</code> </pre><pre> <code class="plaintext hljs"> locktype | relation | page | tuple ----------+------------+------+------- page | pred | 3 | page | pred_n_idx | 211 | page | pred_n_idx | 212 | page | pred_n_idx | 22 | (4 rows)</code> </pre><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">ROLLBACK</span></span>;</code> </pre><br>  Por cierto, los bloqueos de predicados no siempre se eliminan inmediatamente despu√©s de completar la transacci√≥n, ya que son necesarios para rastrear las dependencias entre <em>varias</em> transacciones.  Pero en cualquier caso, se gestionan autom√°ticamente. <br><br>  No todos los tipos de √≠ndice en PostgreSQL admiten bloqueos de predicados.  Anteriormente, solo los √°rboles B pod√≠an presumir de esto, pero en PostgreSQL 11 la situaci√≥n mejor√≥: se agregaron √≠ndices hash, GiST y GIN a la lista.  Si se utiliza el acceso al √≠ndice, y el √≠ndice no funciona con bloqueos de predicados, entonces todo el √≠ndice est√° bloqueado en el bloqueo.  Por supuesto, esto tambi√©n aumenta el n√∫mero de saltos falsos de transacciones. <br><br>  En conclusi√≥n, observo que es con el uso de bloqueos de predicados que existe una restricci√≥n que, para garantizar un aislamiento completo, <em>todas las</em> transacciones deben funcionar en el nivel Serializable.  Si una transacci√≥n usa un nivel diferente, simplemente no establecer√° (y comprobar√°) bloqueos de predicados. <br><br><blockquote>  Por tradici√≥n, dejar√© un enlace a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">README en bloqueos de predicados</a> , desde el cual puede comenzar a estudiar el c√≥digo fuente. <br></blockquote><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Continuar√°</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/465263/">https://habr.com/ru/post/465263/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../465251/index.html">El verano casi ha terminado. Casi no se filtraron datos</a></li>
<li><a href="../465255/index.html">Implementaci√≥n de la agrupaci√≥n de conexiones WCF para .Net Core usando HttpClientFactory</a></li>
<li><a href="../465257/index.html">‚Äú¬°Cuidado, FAS!‚Äù: Trucos de McDonald's, shawarma divino, falso Clooney y algo de magia callejera</a></li>
<li><a href="../465259/index.html">ValueTask <TResult>: ¬øpor qu√©, por qu√© y c√≥mo?</a></li>
<li><a href="../465261/index.html">El poder m√°gico de las macros, o c√≥mo hacer la vida m√°s f√°cil para un programador ensamblador AVR</a></li>
<li><a href="../465267/index.html">TypeScript Magia de expresi√≥n</a></li>
<li><a href="../465269/index.html">Entrenamiento Cisco 200-125 CCNA v3.0. D√≠a 26. DNS y DHCP</a></li>
<li><a href="../465271/index.html">Los hackers roban y lavan dinero mediante la entrega de alimentos y los servicios de reserva de hotel.</a></li>
<li><a href="../465273/index.html">C√≥mo los desarrolladores de software de Microgaming protegen a los usuarios de los hacks</a></li>
<li><a href="../465275/index.html">Alice adquiere habilidad</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>