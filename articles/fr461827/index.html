<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üéì üíÖüèæ üçº D√©veloppement d'applications hybrides PHP / Go √† l'aide de RoadRunner üïµüèæ üç´ üå¶Ô∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="L'application PHP classique est un thread unique, un chargement lourd (sauf si vous √©crivez bien s√ªr sur des microframes) et la mort in√©vitable du pro...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>D√©veloppement d'applications hybrides PHP / Go √† l'aide de RoadRunner</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/oleg-bunin/blog/461827/"> L'application PHP classique est un thread unique, un chargement lourd (sauf si vous √©crivez bien s√ªr sur des microframes) et la mort in√©vitable du processus apr√®s chaque requ√™te ... Une telle application est lourde et lente, mais nous pouvons lui donner une seconde vie par hybridation.  Pour acc√©l√©rer - nous diabolisons et optimisons les fuites de m√©moire pour obtenir de meilleures performances - nous pr√©senterons notre propre serveur d'applications PHP Golang RoadRunner pour ajouter de la flexibilit√© - simplifier le code PHP, √©tendre la pile et partager la responsabilit√© entre le serveur et l'application.  Essentiellement, nous ferons fonctionner notre application comme si nous l'√©crivions en Java ou dans un autre langage. <br><br>  Gr√¢ce √† l'hybridation, une application auparavant lente a cess√© de souffrir de 502 erreurs sous charge, le temps de r√©ponse moyen aux demandes a diminu√©, la productivit√© a augment√© et le d√©ploiement et l'assemblage sont devenus plus faciles en raison de l'unification de l'application et de l'√©limination des liaisons inutiles sous la forme nginx + php-fpm. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/RUm94xCaXMo" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  <strong>Anton Titov</strong> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" class="user_link">Lachezis</a> ) est CTO et co-fondateur de SpiralScout LLC avec 12 ans d'exp√©rience active en d√©veloppement commercial en PHP.  Au cours des derni√®res ann√©es, il a activement mis en ≈ìuvre Golang sur la pile de d√©veloppement de l'entreprise.  Anton a parl√© d'un exemple √† <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">PHP Russie 2019</a> . <br><a name="habracut"></a><br><h2>  Cycle de vie des applications PHP </h2><br>  Sch√©matiquement, un dispositif d'application abstrait avec un certain cadre ressemble √† ceci. <br><br><img src="https://habrastorage.org/webt/mm/va/0d/mmva0djqxjc5l733ikzi738ydry.jpeg"><br><br>  Lorsque nous envoyons une demande √† un processus, cela se produit: <br><br><ul><li>  initialisation du projet; </li><li>  chargement de biblioth√®ques, de cadres et d'ORM partag√©s; </li><li>  chargement des biblioth√®ques requises pour un projet sp√©cifique; </li><li>  routage; </li><li>  acheminer la demande vers un contr√¥leur sp√©cifique; </li><li>  g√©n√©ration de r√©ponse. </li></ul><br>  C'est le principe de fonctionnement d'une <strong>application monothread</strong> classique avec un seul point d'entr√©e, qui apr√®s chaque ex√©cution est compl√®tement d√©truite ou efface son √©tat.  Tout le code est d√©charg√© de la m√©moire, le travailleur est effac√© ou r√©initialise simplement son √©tat. <br><br><h3>  Chargement paresseux </h3><br>  La mani√®re standard et simple d'acc√©l√©rer est l'impl√©mentation du <strong>syst√®me de chargement diff√©r√©</strong> ou des biblioth√®ques de chargement √† la demande. <br><br><img src="https://habrastorage.org/webt/vj/eb/gp/vjebgpv7_a4fuvu64x4g8eqmbke.jpeg"><br><br><blockquote>  Avec Lazy-loading, nous demandons uniquement le code n√©cessaire. </blockquote><br>  Lors de l'acc√®s √† un contr√¥leur sp√©cifique, seules les biblioth√®ques n√©cessaires seront charg√©es en m√©moire, trait√©es, puis d√©charg√©es.  Cela vous permet de <strong>r√©duire le temps de r√©ponse moyen du projet</strong> et de faciliter consid√©rablement le processus de travail sur le serveur.  Dans tous les frameworks que nous utilisons actuellement, le principe du chargement paresseux est impl√©ment√©. <br><br><h3>  Cachez les calculs fr√©quents </h3><br>  La m√©thode est plus compliqu√©e et activement utilis√©e, par exemple, dans le framework Symfony, les moteurs de mod√®le, les sch√©mas ORM et le routage.  Ce n'est pas la mise en cache comme memcached ou Redis pour les donn√©es utilisateur.  Ce syst√®me <strong>r√©chauffe √† l'avance certaines parties du code</strong> .  A la premi√®re demande, le syst√®me g√©n√®re un code ou un fichier cache, et aux demandes suivantes, ces calculs, n√©cessaires par exemple pour compiler un mod√®le, ne seront plus effectu√©s. <br><br><img src="https://habrastorage.org/webt/nb/44/f6/nb44f6isfvs6vouultxridabeps.jpeg"><br><br>  La mise en cache <strong>acc√©l√®re</strong> consid√©rablement <strong>l'application</strong> , mais en m√™me temps la <strong>complique</strong> .  Par exemple, il y a des probl√®mes pour invalider le cache et mettre √† jour l'application.  Ne confondez pas le cache utilisateur avec le cache d'application - dans l'un, les donn√©es changent au fil du temps, dans l'autre uniquement lorsque le code est mis √† jour. <br><br><h3>  Traitement des demandes </h3><br>  Lorsqu'une demande est re√ßue d'un serveur PHP-FPM externe, le point d'entr√©e de la demande et l'initialisation correspondent. <br><br><blockquote>  Il s‚Äôav√®re que la demande du client est l‚Äô√©tat de notre processus. </blockquote><br>  La seule fa√ßon de changer cet √©tat est de d√©truire compl√®tement le travailleur et de recommencer avec une nouvelle demande. <br><br><img src="https://habrastorage.org/webt/jc/cr/rb/jccrrb-szkhb6_nfn2zthotuctk.jpeg"><br><br>  Il s'agit d'un mod√®le classique √† filetage unique avec ses avantages. <br><br><ul><li>  Tous les travailleurs √† la fin de la demande meurent. </li><li>  Les fuites de m√©moire, la condition de concurrence, les blocages ne sont pas inh√©rents √† PHP.  Vous ne pouvez pas vous en soucier. </li><li>  Le code est simple: nous √©crivons, traitons la demande, mourons et passons. </li></ul><br>  En revanche, pour chaque requ√™te, nous chargeons compl√®tement le framework, toutes les librairies, effectuons quelques calculs, recompilons les templates.  Avec chaque demande dans un cercle, nous produisons beaucoup de manipulations et de travail inutile. <br><br><h3>  Comment √ßa marche sur le serveur </h3><br>  Tr√®s probablement, un tas de nginx et PHP fonctionnera.  Nginx fonctionnera comme un proxy inverse: fournissez aux utilisateurs une partie de la statique et d√©l√©guez une partie des requ√™tes au gestionnaire de processus PHP PHP-FPM ci-dessous.  Le gestionnaire √©l√®ve d√©j√† un travailleur distinct pour la demande et la traite.  Apr√®s cela, le travailleur est d√©truit ou autoris√©.  Ensuite, un nouveau travailleur est cr√©√© pour la prochaine demande. <br><br><img src="https://habrastorage.org/webt/8f/lc/fp/8flcfpz6zxemgxlas6avx5aguqa.jpeg"><br><br>  Un tel mod√®le fonctionne de mani√®re stable - l'application est presque impossible √† tuer.  Mais sous de lourdes charges, la quantit√© de travail pour l'initialisation et la destruction des travailleurs affecte les performances du syst√®me, car m√™me pour une simple demande GET, nous devons souvent tirer un tas de d√©pendances et relancer la connexion √† la base de donn√©es. <br><br><h2>  Acc√©l√©rer l'application </h2><br>  Comment acc√©l√©rer l'application classique apr√®s l'introduction du cache et du chargement diff√©r√©?  Quelles sont les autres options? <br><br>  <strong>Tournez-vous vers la langue elle-m√™me</strong> . <br><br><ul><li>  <strong>Utilisez OPCache.</strong>  Je pense que personne n'ex√©cute PHP en production sans OPCache activ√©? </li><li>  Attendez <strong>RFC: pr√©chargement</strong> .  Il vous permet de pr√©charger un ensemble de fichiers dans une machine virtuelle. </li><li>  <strong>JIT</strong> - acc√©l√®re s√©rieusement l'application sur les t√¢ches li√©es au processeur.  Malheureusement, avec les t√¢ches li√©es aux bases de donn√©es, cela n'aidera pas beaucoup. </li></ul><br>  <strong>Utilisez des alternatives</strong> .  Par exemple, la machine virtuelle HHVM de Facebook.  Il ex√©cute du code dans un environnement plus optimis√©.  Malheureusement, HHVM n'est pas enti√®rement compatible avec la syntaxe PHP.  Comme alternative, les compilateurs kPHP de VK ou PeachPie, qui convertit compl√®tement le code en .NET C #, sont une alternative. <br><br>  <strong>R√©√©crire enti√®rement dans une autre langue.</strong>  C'est une option radicale - d√©barrassez-vous compl√®tement du chargement de code entre les requ√™tes. <br><br>  Vous pouvez <b>stocker</b> compl√®tement <b>l'√©tat de l'application dans la m√©moire</b> , utiliser activement cette m√©moire pour le travail, oublier le concept d'un travailleur mourant et effacer compl√®tement l'application entre les demandes. <br><br>  Pour y parvenir, nous d√©pla√ßons le point d'entr√©e, qui √©tait auparavant avec le point d'initialisation, profond√©ment dans l'application. <br><br><h3>  Transfert du point d'entr√©e - diabolisation </h3><br>  Cela cr√©e une boucle infinie dans l'application: demande entrante - ex√©cutez-la dans le cadre - g√©n√©rez une r√©ponse √† l'utilisateur.  Il s'agit d'une √©conomie s√©rieuse - tous les bootstrap, toutes les initialisations du framework ne sont effectu√©es qu'une seule fois, puis plusieurs requ√™tes sont trait√©es par l'application. <br><br><img src="https://habrastorage.org/webt/ce/7k/3l/ce7k3lov0kzcyxc3zyjq008taiy.jpeg"><br><br><h3>  Nous adaptons l'application </h3><br>  Fait int√©ressant, nous pouvons nous concentrer sur l'optimisation uniquement de la partie de l'application qui s'ex√©cutera <strong>au moment de l'ex√©cution</strong> : contr√¥leurs, logique m√©tier.  Dans ce cas, vous pouvez abandonner le mod√®le de chargement diff√©r√©.  Nous prendrons une partie du projet d'amor√ßage au d√©but - au moment de l'initialisation.  Calculs pr√©liminaires: routage, mod√®les, param√®tres, sch√©mas ORM gonfleront l'initialisation, mais √† l'avenir, ils gagneront du temps de traitement pour une demande sp√©cifique. <br><br><img src="https://habrastorage.org/webt/fz/kj/ft/fzkjftdkc41niwqyrmml-ijjkwy.jpeg"><br><br>  Je ne recommande pas de compiler des mod√®les lors du t√©l√©chargement d'un travailleur, mais le t√©l√©chargement, par exemple, de toutes les configurations est utile. <br><br><h3>  Comparez les mod√®les </h3><br>  Comparez les mod√®les diabolis√©s (√† gauche) et classiques. <br><br><img src="https://habrastorage.org/webt/zo/en/6r/zoen6rl8zyj6tpn7bghp_ozv61m.jpeg"><br><br>  Le mod√®le diabolis√© prend plus de temps √† partir du moment o√π le processus a √©t√© cr√©√© jusqu'au moment o√π la r√©ponse est retourn√©e √† l'utilisateur.  L'application classique est optimis√©e pour une cr√©ation, un traitement et une destruction rapides. <br><br>  Cependant, toutes les demandes ult√©rieures apr√®s avoir r√©chauff√© le code sont beaucoup plus rapides.  Le framework, l'application, le conteneur est d√©j√† en m√©moire et pr√™t √† accepter les requ√™tes et √† r√©pondre rapidement. <br><br><h3>  Probl√®mes du mod√®le √† longue dur√©e de vie </h3><br>  Malgr√© les avantages, le mod√®le pr√©sente un ensemble de limitations. <br><br>  <strong>Fuites de m√©moire.</strong>  L'application se trouve dans la m√©moire pendant tr√®s longtemps, et si vous utilisez les "courbes" de la biblioth√®que, les mauvaises d√©pendances ou les √©tats globaux - la m√©moire commencera √† fuir.  √Ä un moment donn√©, une erreur fatale appara√Ætra qui interrompra la demande de l'utilisateur. <br><br>  Le probl√®me est r√©solu de deux mani√®res. <br><br><ul><li>  √âcrivez du code pr√©cis, utilisez des biblioth√®ques √©prouv√©es. </li><li>  Surveiller activement les travailleurs.  Si vous pensez que la m√©moire fuit √† l'int√©rieur du processus, remplacez-la de mani√®re proactive par un analogue avec une limite inf√©rieure, c'est-√†-dire simplement par une nouvelle copie qui n'a pas encore r√©ussi √† accumuler de la m√©moire non nettoy√©e. </li></ul><br>  <strong>Fuites de donn√©es</strong> .  Par exemple, si lors d'une demande entrante, nous enregistrons l'utilisateur actuel du syst√®me dans une variable globale et oublions de r√©initialiser cette variable apr√®s la demande, il y a une chance que le prochain utilisateur du syst√®me acc√®de accidentellement √† des donn√©es qu'il ne devrait pas voir. <br><br>  Le probl√®me est r√©solu au niveau de l'architecture de l'application. <br><br><ul><li>  Ne stockez pas un utilisateur actif dans un contexte global.  Toutes les donn√©es sp√©cifiques au contexte de la demande sont supprim√©es et effac√©es avant la prochaine demande. </li><li>  Manipulez les donn√©es de session avec soin.  Sessions en PHP - avec l'approche classique, c'est un objet global.  Enveloppez-le correctement afin qu'il soit r√©initialis√© √† la demande suivante. </li></ul><br>  <strong>Gestion des ressources</strong> . <br><br><ul><li>  Surveillez les connexions √† la base de donn√©es.  Si l'application se bloque en m√©moire pendant un mois ou deux, la connexion ouverte se fermera tr√®s probablement dans ce d√©lai: la base de donn√©es sera r√©install√©e, red√©marr√©e ou le pare-feu r√©initialisera la connexion.  Au niveau du code, pensez √† vous reconnecter ou, apr√®s chaque demande, r√©initialisez la connexion et relancez-la √† la demande suivante. </li><li>  √âvitez le verrouillage de fichiers de longue dur√©e.  Si votre collaborateur √©crit des informations dans un fichier, il n'y a aucun probl√®me.  Mais si ce fichier est ouvert et comporte un verrou, aucun autre processus de votre syst√®me n'y aura acc√®s tant que le verrou ne sera pas lib√©r√©. </li></ul><br><br><h2>  Explorez le mod√®le √† longue dur√©e de vie </h2><br>  Envisagez un mod√®le de travail √† long terme - diaboliser une application - et explorez les moyens de le mettre en ≈ìuvre. <br><br><h3>  Approche non bloquante </h3><br>  Nous utilisons PHP asynchrone - nous chargeons l'application une fois en m√©moire et traitons les requ√™tes HTTP entrantes √† l'int√©rieur de l'application.  Maintenant, l' <strong>application et le serveur sont un processus</strong> .  Lorsque la demande arrive, nous cr√©ons une coroutine distincte ou dans la boucle d'√©v√©nements, nous donnons une promesse, la traitons et la donnons √† l'utilisateur. <br><br><img src="https://habrastorage.org/webt/v6/js/od/v6jsodvtlxjfy1udzwvl0wa2njk.jpeg"><br><br>  L'avantage ind√©niable de l'approche est une performance maximale.  Il est √©galement possible d'utiliser des outils int√©ressants, par exemple, <strong>configurer WebSocket directement sur votre application</strong> . <br><br>  Cependant, l'approche <strong>augmente</strong> consid√©rablement <strong>la complexit√© du d√©veloppement</strong> .  Il est n√©cessaire d'installer ELDO, n'oubliez pas que tous les pilotes de base de donn√©es ne seront pas pris en charge et que la biblioth√®que PDO est exclue. <br><br>  Pour r√©soudre les probl√®mes en cas de diabolisation avec une approche non bloquante, vous pouvez utiliser des outils bien connus: <strong>ReactPHP</strong> , <strong>amphp</strong> et <strong>Swoole</strong> - un d√©veloppement int√©ressant sous la forme d'une extension C.  Ces outils fonctionnent rapidement, ils ont une bonne communaut√© et une bonne documentation. <br><br><h3>  Approche de blocage </h3><br>  Nous n'√©levons pas de coroutines √† l'int√©rieur de l'application, mais le faisons de l'ext√©rieur. <br><br><img src="https://habrastorage.org/webt/ad/ul/eq/adulequ1msa3sb6ae6saah3bu-c.jpeg"><br><br>  Nous prenons juste <strong>quelques processus d'application</strong> , comme le ferait PHP-FPM.  Au lieu de transmettre ces requ√™tes sous forme d'√©tat de processus, nous les d√©livrons de l'ext√©rieur sous forme de protocole ou de messagerie. <br><br>  Nous √©crivons le m√™me <strong>code monothread</strong> que nous connaissons, nous utilisons toutes les m√™mes biblioth√®ques et le m√™me PDO.  Tout le travail acharn√© de travailler avec des sockets, HTTP et d'autres outils se fait en <strong>dehors de l'application PHP</strong> . <br><br>  Parmi les inconv√©nients: nous devons <strong>surveiller la m√©moire</strong> et nous rappeler que la <strong>communication entre deux processus diff√©rents n'est pas gratuite</strong> , mais nous devons transf√©rer des donn√©es.  Cela cr√©era une l√©g√®re surcharge. <br><br>  Pour r√©soudre le probl√®me, il existe d√©j√† un <strong>outil PHP-RM</strong> √©crit en PHP.  Sur la biblioth√®que ReactPHP, il est <strong>int√©gr√© √† plusieurs frameworks</strong> .  Cependant, PHP-PM est tr√®s <strong>lent, il fuit de la m√©moire au niveau du serveur</strong> et sous charge, il ne montre pas autant de croissance que PHP-FRM. <br><br><h2>  Nous √©crivons notre serveur d'applications </h2><br>  Nous avons √©crit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">notre serveur d'applications</a> , qui est similaire √† PHP-RM, mais il y a plus de fonctionnalit√©s.  Que voulions-nous du serveur? <br><br>  <strong>Combinez avec les cadres existants.</strong>  Nous souhaitons une int√©gration flexible avec presque tous les frameworks du march√©.  Je n'ai pas envie d'√©crire un outil qui ne fonctionne que dans un cas particulier. <br><br>  <strong>Diff√©rents processus pour le serveur et l'application</strong> .  Possibilit√© d'un red√©marrage √† chaud, de sorte que lors du d√©veloppement local, appuyez sur F5 et voyez le nouveau code mis √† jour, ainsi que de pouvoir les d√©velopper individuellement. <br><br>  <strong>Grande vitesse et stabilit√©</strong> .  Pourtant, nous √©crivons un serveur HTTP. <br><br>  <strong>Extensibilit√© facile</strong> .  Nous voulons utiliser le serveur non seulement comme serveur HTTP, mais √©galement pour des sc√©narios individuels comme un serveur de file d'attente ou un serveur gRPC. <br><br>  <strong>Travaillez d√®s</strong> que possible: Windows, Linux, ARM CPU. <br><br>  Possibilit√© d'√©crire <strong>des extensions multi-threads</strong> tr√®s <strong>rapides</strong> sp√©cifiques √† notre application. <br><br>  Comme vous l'avez d√©j√† compris, nous √©crirons √† Golang. <br><br><h2>  Serveur RoadRunner </h2><br>  Pour cr√©er un serveur PHP, vous devez r√©soudre 4 probl√®mes principaux: <br><br><ul><li>  √âtablissez la communication entre Golang et les processus PHP. </li><li>  Gestion des processus: cr√©ation, destruction, suivi des travailleurs. </li><li>  √âquilibrer les t√¢ches - distribution efficace des t√¢ches aux travailleurs.  √âtant donn√© que nous mettons en ≈ìuvre un syst√®me qui bloque un travailleur individuel pour une t√¢che entrante sp√©cifique particuli√®re, il est important de cr√©er un syst√®me qui dirait rapidement que le processus a termin√© le travail et est pr√™t √† accepter la t√¢che suivante. </li><li>  Pile HTTP - envoi des donn√©es de requ√™te HTTP au travailleur.  C'est une t√¢che simple d'√©crire un point entrant auquel l'utilisateur envoie une demande, qui est transmise √† PHP et renvoy√©e. </li></ul><br><h3>  Variantes d'interaction entre les processus </h3><br>  Tout d'abord, r√©solvons le probl√®me de communication entre Golang et les processus PHP.  Nous avons plusieurs fa√ßons. <br><br>  <strong>Int√©gration: incorporer un interpr√©teur PHP directement dans Golang.</strong>  Ceci est possible, mais n√©cessite un assemblage PHP personnalis√©, une configuration complexe et un processus commun pour le serveur et PHP.  Comme dans <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">go-php</a> , par exemple, o√π l'interpr√©teur PHP est int√©gr√© √† Golang. <br><br>  <strong>M√©moire partag√©e - Utilisation de l'espace de m√©moire partag√©e,</strong> <strong>o√π les processus partagent cet espace</strong> .  Cela demande un travail minutieux.  Lors de l'√©change de donn√©es, vous devrez synchroniser l'√©tat manuellement et le nombre d'erreurs qui peuvent se produire est assez important.  La m√©moire partag√©e d√©pend √©galement du syst√®me d'exploitation. <br><br><h3>  R√©daction de votre protocole de transport - Goridge </h3><br>  Nous avons suivi un chemin simple qui est utilis√© dans presque toutes les solutions sur les syst√®mes Linux - nous avons utilis√© le protocole de transport.  Il est <strong>√©crit au-dessus des PIPES et des PRISES UNIX / TCP standard</strong> . <br><br>  Il a la capacit√© de transf√©rer des donn√©es dans les deux sens, de d√©tecter les erreurs, de baliser les demandes et de mettre des en-t√™tes dessus.  Une nuance importante pour nous est la possibilit√© de mettre en ≈ìuvre le protocole sans d√©pendances √† la fois du c√¥t√© de PHP et de Golang - sans extensions C dans un langage pur. <br><br>  Comme pour tout protocole, la base est un paquet de donn√©es.  Dans notre cas, le paquet a un en-t√™te fixe de 17 octets. <br><br><img src="https://habrastorage.org/webt/wb/_h/g_/wb_hg_qtkmoxe74sthy12rhtzms.jpeg"><br><br>  Le premier octet est allou√© pour d√©terminer le type de paquet.  Il peut s'agir d'un flux ou d'un indicateur qui indique le type de s√©rialisation des donn√©es.  Ensuite, nous emballons deux fois la taille des donn√©es dans Little Endian et Big Endian.  Nous utilisons cet h√©ritage pour d√©tecter les erreurs de transmission.  Si nous constatons que la taille des donn√©es compress√©es dans deux commandes diff√©rentes ne correspond pas, une erreur de transfert de donn√©es s'est probablement produite.  Ensuite, les donn√©es sont transmises. <br><br><img src="https://habrastorage.org/webt/bt/rb/dr/btrbdre8cwionih8m6e7yze2crw.jpeg"><br><br>  Dans la troisi√®me version du package, nous nous d√©barrasserons d'un tel h√©ritage, introduirons une approche plus classique avec une somme de contr√¥le et ajouterons √©galement la possibilit√© d'utiliser ce protocole avec des processus PHP asynchrones. <br><br>  Pour impl√©menter le protocole dans Golang et PHP, nous avons utilis√© des outils standard. <br><br>  <strong>Sur Golang:</strong> encodage / biblioth√®ques binaires et io et biblioth√®ques net pour travailler avec des canaux standard et des sockets UNIX / TCP. <br><br>  <strong>En PHP:</strong> la fonction famili√®re pour travailler avec les paquets de donn√©es binaires / d√©compresser et les flux d'extensions et les sockets pour les pipes et sockets. <br><br>  Un <strong>effet secondaire</strong> int√©ressant <strong>est</strong> apparu lors de la mise en ≈ìuvre.  Nous l'avons int√©gr√© √† la biblioth√®que standard Golang net / rpc, ce qui nous permet d'appeler le code de service depuis Golang directement dans l'application. <br><br>  Nous √©crivons un service: <br><br><pre><code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">//  sample type  struct{} // Hi returns greeting message. func (a *App) Hi(name string, r *string) error { *r = fmt.Sprintf("ll, %s!", name) return nil }</span></span></code> </pre> <br>  Avec une petite quantit√© de code, nous l'appelons depuis l'application: <br><br><pre> <code class="go hljs">&lt;?php use Spiral\Goridge; require <span class="hljs-string"><span class="hljs-string">"vendor/autoload.php"</span></span>; $rpc = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> Goridge\RPC( <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> Goridge\SocketRelay(<span class="hljs-string"><span class="hljs-string">"127.0.0.1"</span></span>, <span class="hljs-number"><span class="hljs-number">6001</span></span>) ); echo $rpc-&gt;call(<span class="hljs-string"><span class="hljs-string">"App.Hi"</span></span>, <span class="hljs-string"><span class="hljs-string">"Antony"</span></span>);</code> </pre> <br><h3>  Gestionnaire de processus PHP </h3><br>  La prochaine partie du serveur est la gestion des travailleurs PHP. <br><img src="https://habrastorage.org/webt/vt/jy/tk/vtjytk9effas7jkgjgadvbek_zw.jpeg"><br><br>  Worker est un processus PHP que nous observons constamment depuis Golang.  Nous collectons le journal de ses erreurs dans le fichier STDERR, communiquons avec le travailleur via le protocole de transport Goridge et collectons des statistiques sur la consommation de m√©moire, l'ex√©cution des t√¢ches et le blocage. <br><br>  L'impl√©mentation est simple - c'est la fonctionnalit√© standard de os / exec, runtime, sync, atomic.  Pour cr√©er des travailleurs, nous utilisons <strong>Worker Factory</strong> . <br><img src="https://habrastorage.org/webt/wq/kr/tt/wqkrtt0n0xxvhdnxuvx_4f2deiy.jpeg"><br><br>  Pourquoi Worker Factory?  Parce que nous voulons communiquer √† la fois sur des tuyaux standard et sur des prises.  Dans ce cas, le processus d'initialisation est l√©g√®rement diff√©rent.  Lors de la cr√©ation d'un travailleur qui communique par pipe, nous pouvons le cr√©er imm√©diatement et envoyer des donn√©es directement.  Dans le cas des sockets, vous devez cr√©er un travailleur, attendre qu'il atteigne le syst√®me, effectuer une n√©gociation PID, puis continuer √† travailler. <br><br><h3>  √âquilibreur de t√¢ches </h3><br>  La troisi√®me partie du serveur est la plus importante pour les performances. <br><br>  Pour la mise en ≈ìuvre, nous utilisons la fonctionnalit√© standard de Golang - un <strong>canal tamponn√©</strong> .  En particulier, nous cr√©ons plusieurs travailleurs et les mettons dans ce canal en tant que pile LIFO. <br><img src="https://habrastorage.org/webt/bm/po/f4/bmpof4s5-owl810px69ectqiw_i.jpeg"><br>  √Ä la r√©ception des t√¢ches de l'utilisateur, nous envoyons une demande √† la pile LIFO et demandons l'√©mission du premier travailleur gratuit.  Si le travailleur ne peut pas √™tre allou√© pendant un certain temps, alors l'utilisateur re√ßoit une erreur du type "Timeout Error".  Si le travailleur est allou√© - il obtient de la pile, est bloqu√©, apr√®s quoi il re√ßoit la t√¢che de l'utilisateur. <br><img src="https://habrastorage.org/webt/cm/2o/cq/cm2ocqak94ubao7tk8vxnglfyyo.jpeg"><br>  Une fois la t√¢che trait√©e, la r√©ponse est renvoy√©e √† l'utilisateur et le travailleur se trouve √† la fin de la pile.  Il est pr√™t √† effectuer √† nouveau la t√¢che suivante. <br><img src="https://habrastorage.org/webt/oj/f_/l4/ojf_l4ipil8fcslpyherhsg02la.jpeg"><br>  Si une erreur se produit, l'utilisateur recevra une erreur, car le travailleur sera d√©truit.  Nous demandons √† Worker Pool et Worker Factory de cr√©er un processus identique et de le remplacer sur la pile.  Cela permet au syst√®me de fonctionner m√™me en cas d'erreurs fatales en recr√©ant simplement les travailleurs par analogie avec PHP-FPM. <br><img src="https://habrastorage.org/webt/qs/li/dq/qslidqche8glb-q5pucwfwnpogw.jpeg"><br><br>  En cons√©quence, il s'est av√©r√© impl√©menter un petit syst√®me qui fonctionne tr√®s rapidement - <strong>200 ns pour l'allocation des travailleurs</strong> .  Il est capable de fonctionner m√™me en cas d'erreurs fatales.  Chaque travailleur √† un moment donn√© ne traite qu'une seule t√¢che, ce qui nous permet d'utiliser l' <strong>approche de blocage classique</strong> . <br><br><h3>  Surveillance proactive </h3><br>  Une partie distincte du gestionnaire de processus et de l'√©quilibreur de t√¢ches est le syst√®me de surveillance proactif. <br><img src="https://habrastorage.org/webt/83/zq/ep/83zqepdmerd6ozakntcmv33hnus.jpeg"><br><br>  Il s'agit d'un syst√®me qui, une fois par seconde, interroge les travailleurs et surveille les indicateurs: il examine la quantit√© de m√©moire qu'ils consomment, la quantit√© dans laquelle ils se trouvent, s'ils sont inactifs.  En plus du suivi, le syst√®me surveille les fuites de m√©moire.  Si le travailleur d√©passe une certaine limite, nous le verrons et le retirerons soigneusement du syst√®me avant qu'une fuite fatale ne se produise. <br><br><h3>  Pile HTTP </h3><br>  La derni√®re et simple partie. <br><img src="https://habrastorage.org/webt/hl/cc/7e/hlcc7ehfob5vhc_zjse_em8e0eg.jpeg"><br>  <strong>Comment est-il mis en ≈ìuvre:</strong> <br><br><ul><li>  soul√®ve un point HTTP du c√¥t√© de Golang; </li><li>  nous recevons une demande; </li><li>  convertir au format PSR-7; </li><li>  envoyer la demande au premier travailleur libre; </li><li>  D√©compressez la demande dans un objet PSR-7; </li><li>  nous traitons; </li><li>  nous g√©n√©rons la r√©ponse. </li></ul><br>  Pour l'impl√©mentation, nous avons utilis√© la <strong>biblioth√®que Golang NET / HTTP</strong> standard.  Il s'agit d'une biblioth√®que c√©l√®bre avec de nombreuses extensions.  Capable de travailler √† la fois sur HTTPS et sur le protocole HTTP / 2. <br><br>  C√¥t√© PHP, nous avons utilis√© la norme PSR-7 <strong>.</strong>  Il s'agit d'un <strong>framework ind√©pendant</strong> avec de nombreuses extensions et middlewares.  Le PSR-7 est <strong>immuable dans sa conception</strong> , ce qui correspond bien au concept des applications √† longue dur√©e de vie et √©vite les erreurs de requ√™te globales. <br><br>  Les deux structures dans Golang et PSR-7 sont similaires, ce qui a consid√©rablement gagn√© du temps pour mapper une demande d'une langue √† une autre. <br><br>  Pour d√©marrer le serveur n√©cessite une <strong>liaison minimale</strong> : <br><br><pre> <code class="go hljs">http: address: <span class="hljs-number"><span class="hljs-number">0.0</span></span><span class="hljs-number"><span class="hljs-number">.0</span></span><span class="hljs-number"><span class="hljs-number">.0</span></span>:<span class="hljs-number"><span class="hljs-number">8080</span></span> workers: command: <span class="hljs-string"><span class="hljs-string">"php psr-worker.php"</span></span> pool: numWorkers: <span class="hljs-number"><span class="hljs-number">4</span></span></code> </pre> <br>  De plus, √† partir de la version 1.3.0, la derni√®re partie de la configuration peut √™tre omise. <br><br>  T√©l√©chargez le fichier binaire du serveur, placez-le dans le conteneur Docker ou dans le dossier du projet.  Alternativement, globalement, nous √©crivons un petit fichier de configuration qui d√©crit quel pod nous allons √©couter, quel travailleur est le point d'entr√©e et combien sont n√©cessaires. <br><br>  C√¥t√© PHP, nous √©crivons une boucle primaire qui re√ßoit une requ√™te PSR-7, la traite et renvoie une r√©ponse ou une erreur au serveur. <br><br><pre> <code class="go hljs">while ($req = $psr7-&gt;acceptRequest()) { try { $resp = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> \Zend\Diactoros\Response(); $resp-&gt;getBody()-&gt;write(<span class="hljs-string"><span class="hljs-string">"hello world"</span></span>); $psr7-&gt;respond($resp); } catch (\Throwable $e) { $psr7-&gt;getWorker()-&gt;error((<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>)$e); } }</code> </pre> <br>  <strong>Assemblage</strong>  Pour impl√©menter le serveur, nous avons choisi une architecture avec une approche composante.  Cela permet d'assembler le serveur pour les besoins du projet, en ajoutant ou en supprimant des pi√®ces individuelles en fonction des exigences de l'application. <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { rr.Container.Register(env.ID, &amp;env.Service{}) rr.Container.Register(rpc.ID, &amp;rpc.Service{}) rr.Container.Register(http.ID, &amp;http.Service{}) rr.Container.Register(static.ID, &amp;static.Service{}) rr.Container.Register(limit.ID, &amp;limit.Service{} <span class="hljs-comment"><span class="hljs-comment">// you can register additional commands using cmd.CLI rr.Execute() }</span></span></code> </pre> <br><h2>  Cas d'utilisation </h2><br>  Consid√©rez les options d'utilisation du serveur et de modification de la structure.  Pour commencer, consid√©rez le pipeline classique - le travail du serveur avec les requ√™tes. <br><br><h3>  Modularit√© </h3><br>  Le serveur re√ßoit la demande vers un point HTTP et la transmet √† travers un ensemble de middleware, qui sont √©crits en Golang.  Une demande entrante est convertie en une t√¢che que le travailleur comprend.  Le serveur confie la t√¢che au travailleur et la renvoie. <br><br><img src="https://habrastorage.org/webt/zz/v5/ak/zzv5akvapzklanxdlzunxdq-xpu.jpeg"><br><br>  Dans le m√™me temps, le travailleur, utilisant le protocole Goridge, communique avec le serveur, surveille son √©tat et lui transf√®re des donn√©es. <br><br><h3>  Middleware sur Golang: Autorisation </h3><br>  C'est la premi√®re chose √† faire.  Dans notre application, nous avons √©crit Middleware pour <strong>autoriser l'utilisateur par jeton JWT</strong> .  Le middleware est √©crit de la m√™me mani√®re pour tout autre type d'autorisation.  Une impl√©mentation tr√®s banale et simple consiste √† √©crire Rate-Limiter ou Circuit-Breaker. <br><br><img src="https://habrastorage.org/webt/on/zg/ro/onzgroqwxc7umuy-y2xfv9s7dqe.jpeg"><br><br>  <strong>L'autorisation est rapide</strong> .  Si la demande n'est pas valide - il suffit de ne pas l'envoyer √† l'application PHP et de ne pas gaspiller de ressources pour traiter des t√¢ches inutiles. <br><br><h3>  Suivi </h3><br>  Le deuxi√®me cas d'utilisation.  Nous pouvons int√©grer le syst√®me de surveillance directement dans Golang Middleware.  Par exemple, Prom√©th√©e, pour collecter des statistiques sur la vitesse des points de r√©ponse, le nombre d'erreurs. <br><br><img src="https://habrastorage.org/webt/rz/_o/hz/rz_ohzkiz6bwjoebzqu2qt4e6dc.jpeg"><br><br>  Vous pouvez √©galement <strong>combiner la surveillance avec des mesures sp√©cifiques √† l'application</strong> (disponibles en standard avec 1.4.5).  Par exemple, nous pouvons envoyer le nombre de demandes √† la base de donn√©es ou le nombre de demandes sp√©cifiques trait√©es au serveur Golang, puis √† Prom√©th√©e. <br><br><h3>  Suivi et journalisation distribu√©s </h3><br>  Nous √©crivons Middleware avec un gestionnaire de processus.  En particulier, nous pouvons nous connecter au syst√®me en temps r√©el pour surveiller les journaux et <strong>collecter tous les journaux dans une base de donn√©es centrale</strong> , ce qui est utile lors de l'√©criture d'applications distribu√©es. <br><br><img src="https://habrastorage.org/webt/lf/ir/cd/lfircdprhx6nqetmadblqftvbu4.jpeg"><br><br>  Nous pouvons √©galement <strong>√©tiqueter les demandes</strong> , leur donner un ID sp√©cifique et transmettre cet ID √† tous les services en aval ou syst√®mes de communication entre eux.  Par cons√©quent, nous pouvons cr√©er une <strong>trace distribu√©e</strong> et voir comment vont les journaux d'application. <br><br><h3>  Enregistrez l'historique de vos requ√™tes </h3><br>  Il s'agit d'un petit module qui enregistre toutes les demandes entrantes et les stocke dans une base de donn√©es externe.  Le module vous permet de rejouer les requ√™tes dans le projet et d'impl√©menter un syst√®me de test automatique, un syst√®me de test de charge, ou simplement de v√©rifier l'API. <br><br><img src="https://habrastorage.org/webt/ex/q3/kg/exq3kgpym1uf6tjcfwysjk1so00.jpeg"><br><br>  Comment avons-nous impl√©ment√© le module? <br><br>  <strong>Nous traitons une partie des demandes de Golang</strong> .  Nous √©crivons Middleware √† Golang et nous pouvons envoyer une partie des demandes au gestionnaire, qui est √©galement √©crite en Golang.  Si un point de l'application est inqui√©tant en termes de performances, nous le r√©√©crivons sur Golang et faisons glisser la pile d'une langue √† l'autre. <br><br><img src="https://habrastorage.org/webt/q0/zf/qn/q0zfqnzddo_mn7h-d779cg9ganm.jpeg"><br><br>  <strong>Nous √©crivons un serveur WebSocket</strong> .  L'impl√©mentation d'un serveur WebSocket ou d'un serveur de notifications push devient une t√¢che triviale. <br><br><ul><li>  Service Golang au niveau du serveur. </li><li>  Pour la communication, nous utilisons Goridge. </li><li>  Couche de service mince en PHP. </li><li>  Nous impl√©mentons le serveur de notification. </li></ul><br>  Nous recevons une demande et √©tablissons une connexion WebSocket.  Si l'application doit envoyer une sorte de notification √† l'utilisateur, elle lance ce message via le protocole RPC au serveur WebSocket. <br><br><img src="https://habrastorage.org/webt/go/ta/fv/gotafvsepr8u8_r_lvfdjpff2rg.jpeg"><br><br>  <strong>G√©rez votre environnement PHP.</strong>  Lors de la cr√©ation d'un pool de travailleurs, RoadRunner a un contr√¥le total sur l'√©tat des variables d'environnement et vous permet de les modifier √† votre guise.  Si nous √©crivons une grande application distribu√©e, nous pouvons utiliser une seule source de donn√©es de configuration et la connecter en tant que syst√®me pour configurer l'environnement.  Si nous √©levons un ensemble de services, tous ces services se heurteront √† un seul syst√®me, se configureront et fonctionneront.  Cela peut grandement simplifier le d√©ploiement et √©liminer les fichiers .env. <br><br><img src="https://habrastorage.org/webt/iv/m5/03/ivm503pht02yug6do6-od3pyt6i.jpeg"><br><br>  Fait int√©ressant, les variables env qui sont disponibles √† l'int√©rieur du travailleur ne sont pas globales dans le syst√®me.  Cela am√©liore l√©g√®rement la s√©curit√© des conteneurs. <br><br><h3>  Int√©gration de la biblioth√®que Golang en PHP </h3><br>  Nous avons utilis√© cette option sur le site officiel de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">RoadRunner</a> .  Il s'agit d'une int√©gration d'une base <strong>de</strong> donn√©es √† part enti√®re <strong>avec la recherche en texte int√©gral BleveSearch</strong> √† l'int√©rieur du serveur. <br><br><img src="https://habrastorage.org/webt/5a/ba/uc/5abaucml3dmvxqpns_h7bug_ldi.jpeg"><br><br>  Nous avons index√© les pages de documentation: nous les avons plac√©es dans Bolt DB, apr√®s quoi nous avons effectu√© une recherche en texte int√©gral sans v√©ritable base de donn√©es comme MySQL, et sans cluster de recherche comme Elasticsearch.  Le r√©sultat a √©t√© un petit projet dont certaines fonctionnalit√©s sont en PHP, mais la recherche est en Golang. <br><br><h3>  Impl√©mentation des fonctions Lambda </h3><br>  Vous pouvez aller plus loin et <strong>vous d√©barrasser compl√®tement de la couche HTTP.</strong>  Dans ce cas, l'impl√©mentation, par exemple, des fonctions Lambda est une t√¢che simple. <br><br><img src="https://habrastorage.org/webt/ty/ie/dy/tyiedyrsetx2l5wljnllkbju0xg.jpeg"><br><br>  Pour l'impl√©mentation, nous utilisons le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">runtime</a> standard <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">AWS</a> pour la fonction Lambda.  Nous √©crivons une petite liaison, coupons compl√®tement les serveurs HTTP et envoyons les donn√©es au format binaire aux travailleurs.  Nous avons √©galement acc√®s aux param√®tres d'environnement, ce qui nous permet d'√©crire des fonctions qui sont configur√©es directement √† partir du panneau d'administration Amazon. <br><br>  Les travailleurs sont en m√©moire pendant toute la dur√©e de vie du processus et la fonction Lambda apr√®s la demande initiale reste en m√©moire pendant 15 minutes.  Pour le moment, le code ne se charge pas et r√©pond rapidement.  Dans les tests synth√©tiques, nous avons re√ßu jusqu'√† <strong>0,5 ms pour une demande entrante</strong> . <br><br><h3>  gRPC pour PHP </h3><br>  L'option la plus difficile consiste √† remplacer la couche HTTP par la couche gRPC.  Ce <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">package est disponible sur GitHub</a> . <br><img src="https://habrastorage.org/webt/jh/u5/cg/jhu5cgv7-cdj6wf4ifukhqxnd0u.jpeg"><br><br>  Nous pouvons compl√®tement proxy toutes les demandes de Protobuf entrantes vers une application PHP subordonn√©e, o√π elles peuvent √™tre d√©compress√©es, trait√©es et r√©pondues.  Nous pouvons √©crire du code √† la fois en PHP et en Golang, en combinant et en transf√©rant des fonctionnalit√©s d'une pile √† une autre.  Le service prend en charge le middleware.  Les deux applications autonomes et en conjonction avec HTTP peuvent fonctionner. <br><br><h3>  Serveur de file d'attente </h3><br>  La derni√®re option et la plus int√©ressante est l'impl√©mentation du <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">serveur de file d'attente</a> . <br><img src="https://habrastorage.org/webt/rn/ch/1i/rnch1i0ieekunszmsv_ppegtwbu.jpeg"><br><br>  Du c√¥t√© de PHP, tout ce que nous faisons est d'obtenir une charge utile binaire, de la d√©compresser, de faire le travail et d'informer le serveur du succ√®s.  Du c√¥t√© de Golang, nous sommes pleinement engag√©s dans la gestion des relations avec les courtiers.  Il peut s'agir de RabbitMQ, Amazon SQS ou Beanstalk. <br><br>  Du c√¥t√© de Golang, nous mettons en ≈ìuvre la ¬´ <strong>fermeture progressive¬ª des</strong> travailleurs.  Nous pouvons admirablement attendre la mise en ≈ìuvre de la ¬´connexion durable¬ª - si la connexion avec le courtier est perdue, le serveur attend un certain temps en utilisant la ¬´strat√©gie de secours¬ª, il l√®ve la connexion et l'application ne le remarque m√™me pas. <br><br>  Nous pouvons traiter ces demandes √† la fois en PHP et en Golang, et les mettre en file d'attente des deux c√¥t√©s: <br><br><ul><li>  de PHP via le protocole Goridge Goridge RPC; </li><li>  de Golang - communiquer avec la biblioth√®que du SDK. </li></ul><br>  Si la charge utile tombe, alors pas le consommateur entier ne tombe, mais un seul processus distinct.  Le syst√®me la soul√®ve imm√©diatement, la t√¢che est envoy√©e au travailleur suivant.  Cela vous permet d'effectuer des t√¢ches non-stop. <br><br>  Nous avons impl√©ment√© l'un des courtiers directement dans la m√©moire du serveur et utilis√© la fonctionnalit√© Golang.  Cela nous permet d'√©crire une application √† l'aide de files d'attente avant de choisir la pile finale.  Nous levons l'application localement, la d√©marrons et nous avons des files d'attente qui fonctionnent en m√©moire et se comportent de la m√™me mani√®re qu'elles se comporteraient sur RabbitMQ, Amazon SQS ou Beanstalk. <br><br>  Lorsque vous utilisez deux langues dans un tel ensemble hybride, il convient de se rappeler comment les s√©parer. <br><br><h3>  Domaines de domaine s√©par√©s </h3><br><blockquote>  Golang est un langage multithread et rapide qui convient √† l'√©criture de la logique d'infrastructure et de la logique de surveillance et d'autorisation des utilisateurs. </blockquote><br>  Il est √©galement utile pour <strong>impl√©menter des pilotes personnalis√©s</strong> pour acc√©der aux sources de donn√©es - ce sont des files d'attente, par exemple, Kafka, Cassandra. <br><br><blockquote>  PHP est un excellent langage pour √©crire la logique m√©tier. </blockquote><br>  C'est un bon syst√®me pour le rendu HTML, ORM et pour travailler avec la base de donn√©es. <br><br><h2>  Comparaison d'outils </h2><br>  Il y a plusieurs mois, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Habr√© a compar√©</a> PHP-FPM, PHP-PM, React-PHP, Roadrunner et d'autres outils.  Le benchmark a eu lieu sur un projet avec du vrai Symfony 4. <br><br>  RoadRunner sous charge affiche de bons r√©sultats et devance tous les serveurs.  Par rapport √† PHP-FPM, les performances sont 6 √† 8 fois sup√©rieures. <br><img src="https://habrastorage.org/webt/ny/tx/yl/nytxylmddyrmglxjoe8hos7tnka.jpeg"><br><br>  Dans le m√™me benchmark, RoadRunner n'a pas perdu une seule demande, tout a √©t√© 100% √©labor√©.  Malheureusement, React-PHP a perdu 8 √† 9 requ√™tes sous charges - c'est inacceptable.  Nous souhaitons que le serveur ne plante pas et fonctionne de mani√®re stable. <br><img src="https://habrastorage.org/webt/7b/fl/gq/7bflgqhrq1f-y0jixnud_k1ckdg.jpeg"><br><br>  Depuis la publication de RoadRunner en acc√®s public sur GitHub, nous avons re√ßu plus de 30 000 installations.  La communaut√© nous a aid√©s √† √©crire un ensemble sp√©cifique d'extensions, d'am√©liorations et de croire que la solution a le droit √† la vie. <br><br>  RoadRunner est bon si vous souhaitez <strong>acc√©l√©rer consid√©rablement l'application, mais que vous n'√™tes pas encore pr√™t √† passer en PHP asynchrone</strong> .  Il s'agit d'un compromis qui n√©cessitera un certain effort, mais pas aussi important qu'une r√©√©criture compl√®te de la base de code. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Prenez RoadRunner</a> si vous voulez <strong>plus de contr√¥le sur le cycle de vie de PHP</strong> , <strong>s'il n'y a pas assez de capacit√©s PHP,</strong> par exemple, pour le syst√®me de file d'attente ou Kafka, et quand votre biblioth√®que Golang populaire r√©sout votre probl√®me, qui n'est pas en PHP, et l'√©criture prend du temps, ce que vous n'avez pas non plus. <br><br><h2>  R√©sum√© </h2><br>  Ce que nous avons obtenu en √©crivant ce serveur et en l'utilisant dans notre infrastructure de production. <br><br><ul><li>  <strong>Ils ont augment√© la vitesse de r√©action des points d'application de 4 fois</strong> par rapport √† PHP-FPM. </li><li>  <strong>Compl√®tement d√©barrass√© de 502 erreurs sous charges</strong> .  Aux pics de charge, le serveur attend juste un peu plus longtemps et r√©pond comme s'il n'y avait pas de charges. </li><li>  Apr√®s avoir optimis√© les fuites de m√©moire, les employ√©s <strong>restent en m√©moire jusqu'√† 2 mois</strong> .  Cela aide lors de l'√©criture d'applications distribu√©es, car toutes les demandes entre les services sont d√©j√† mises en cache au niveau du socket. </li><li>  <strong>Nous utilisons Keep-Alive.</strong>  Cela acc√©l√®re consid√©rablement la communication entre un syst√®me distribu√©. </li><li>  √Ä l'int√©rieur de la v√©ritable infrastructure, <strong>nous avons tout mis dans l'Alpine Docker √† Kubernetes</strong> .  Le syst√®me de d√©ploiement et de construction du projet est d√©sormais plus facile.  Tout ce qui est n√©cessaire est de cr√©er une construction RoadRunner personnalis√©e pour le projet, de la placer dans le projet Docker, de remplir l'image Docker, puis de t√©l√©charger calmement notre pod sur Kubernetes. </li><li>  Selon le calendrier r√©el de l'un des projets vers des points individuels qui n'ont pas acc√®s √† la base de donn√©es, le <strong>temps de r√©ponse moyen est de 0,33 ms</strong> . </li></ul><br><blockquote>  La prochaine conf√©rence professionnelle pour les d√©veloppeurs <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">PHP PHP Russie</a> seulement l'ann√©e prochaine.  Pour l'instant, nous vous proposons: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Faites</a> attention √† <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">GolangConf</a> si vous √™tes int√©ress√© par la partie Go et souhaitez en savoir plus de d√©tails ou entendre des arguments en faveur du passage √† cette langue.  Si vous √™tes pr√™t √† partager votre exp√©rience, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">veuillez envoyer des r√©sum√©s</a> . </li><li>  Participez √† <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">HighLoad ++</a> √† Moscou, si tout ce qui est important pour vous est li√© √† la haute performance, soumettez un rapport avant le 7 septembre ou r√©servez un billet. </li><li>  Abonnez-vous √† la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">newsletter</a> et √† la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">cha√Æne t√©l√©gramme</a> afin de recevoir une invitation √† PHP Russie 2020 plus t√¥t que les autres. </li></ul></blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr461827/">https://habr.com/ru/post/fr461827/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr461815/index.html">Une r√©volution dans la conception des alimentations informatiques il y a un demi-si√®cle</a></li>
<li><a href="../fr461817/index.html">CMake et C ++ - fr√®res pour toujours</a></li>
<li><a href="../fr461819/index.html">Pourquoi la conception d'un site Web simple est meilleure scientifiquement</a></li>
<li><a href="../fr461821/index.html">Une nouvelle immunoth√©rapie a √©limin√© toutes les tumeurs chez une femme atteinte d'un cancer du sein m√©tastatique</a></li>
<li><a href="../fr461823/index.html">Quatre r√®gles am√©lior√©es pour la conception de logiciels</a></li>
<li><a href="../fr461829/index.html">TCP vs UDP ou l'avenir des protocoles r√©seau</a></li>
<li><a href="../fr461831/index.html">StealthWatch: d√©ploiement et personnalisation. 2e partie</a></li>
<li><a href="../fr461833/index.html">Ne vous perdez pas dans trois pins: une repr√©sentation √©gocentrique de l'environnement</a></li>
<li><a href="../fr461835/index.html">Comment les diagrammes de Gantt simplifient et renforcent la gestion de projet</a></li>
<li><a href="../fr461841/index.html">PVS-Studio a examin√© le moteur de puces de Red Dead Redemption</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>