<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩‍🎨 🧑🏾‍🤝‍🧑🏾 👩‍👧‍👧 Mengkonfigurasi server untuk menggunakan aplikasi Rails menggunakan Ansible 🧒🏻 🐩 👇🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Belum lama ini, saya perlu menulis beberapa buku pedoman yang mungkin untuk mempersiapkan server untuk menyebarkan aplikasi rel. Dan, yang mengejutkan...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Mengkonfigurasi server untuk menggunakan aplikasi Rails menggunakan Ansible</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/460769/"><p>  Belum lama ini, saya perlu menulis beberapa buku pedoman yang mungkin untuk mempersiapkan server untuk menyebarkan aplikasi rel.  Dan, yang mengejutkan, saya tidak menemukan petunjuk langkah demi langkah yang sederhana.  Saya tidak ingin menyalin buku pedoman orang lain tanpa memahami apa yang terjadi dan akibatnya saya harus membaca dokumentasi, mengumpulkan semuanya sendiri.  Mungkin seseorang yang bisa saya bantu mempercepat proses ini dengan artikel ini. </p><br><p>  Hal pertama yang harus dipahami adalah memungkinkan menyediakan Anda dengan antarmuka yang nyaman untuk melakukan daftar tindakan yang telah ditentukan pada server jauh melalui SSH.  Tidak ada keajaiban di sini, Anda tidak dapat menginstal plugin dan keluar dari kotak nol downtime penyebaran aplikasi Anda dengan buruh pelabuhan, pemantauan dan barang lainnya.  Untuk menulis buku pedoman, Anda harus tahu apa sebenarnya yang ingin Anda lakukan dan bagaimana melakukannya.  Karenanya, saya tidak suka buku pedoman yang sudah jadi dari github, atau artikel seperti: "Salin dan jalankan, itu akan berhasil." </p><a name="habracut"></a><br><h2 id="chto-nam-nuzhno">  Apa yang kita butuhkan </h2><br><p>  Seperti yang saya katakan, untuk menulis buku pedoman, Anda harus tahu apa yang ingin Anda lakukan dan bagaimana melakukannya.  Mari kita putuskan apa yang kita butuhkan.  Untuk aplikasi Rails, kita memerlukan beberapa paket sistem: nginx, postgresql (redis, dll).  Selain itu, kita perlu ruby ​​versi tertentu.  Yang terbaik adalah menginstalnya melalui rbenv (rvm, asdf ...).  Menjalankan semua ini dari root pengguna selalu merupakan ide yang buruk, jadi Anda perlu membuat pengguna yang terpisah dan mengkonfigurasi hak untuknya.  Setelah itu, Anda perlu mengunggah kode kami ke server, menyalin konfigurasi untuk nginx, postgres, dll dan menjalankan semua layanan ini. </p><br><p>  <strong>Akibatnya, urutan tindakan adalah sebagai berikut:</strong> </p><br><ol><li>  Masuk sebagai root </li><li>  instal paket sistem </li><li>  buat pengguna baru, konfigurasikan hak, kunci ssh </li><li>  konfigurasikan paket sistem (nginx dll) dan jalankan </li><li>  Buat pengguna di basis data (Anda dapat langsung membuat basis data) </li><li>  Masuk sebagai pengguna baru </li><li>  Instal rbenv dan ruby </li><li>  Instal bundler </li><li>  Isi kode aplikasi </li><li>  Kami memulai server Puma </li></ol><br><p>  Selain itu, langkah-langkah terakhir dapat dilakukan dengan menggunakan capistrano, setidaknya dia dapat menyalin kode ke direktori rilis dari kotak, beralih rilis dengan symlink pada penyebaran yang sukses, salin konfigurasi dari direktori bersama, restart puma, dll.  Semua ini bisa dilakukan dengan Ansible, tetapi mengapa? </p><br><h2 id="faylovaya-struktura">  Struktur file </h2><br><p>  Ansible memiliki <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">struktur file yang</a> ketat untuk semua file-nya, jadi yang terbaik adalah menyimpannya dalam direktori yang terpisah.  Dan tidak begitu penting apakah akan di aplikasi rel itu sendiri, atau secara terpisah.  Anda dapat menyimpan file dalam repositori git yang terpisah.  Secara pribadi, itu paling nyaman bagi saya untuk membuat direktori yang mungkin di / config dari direktori rel aplikasi dan menyimpan semuanya dalam satu repositori. </p><br><h3 id="simple-playbook">  Buku pedoman sederhana </h3><br><p>  Playbook adalah file yml yang menjelaskan apa dan bagaimana seharusnya dilakukan dengan menggunakan sintaks khusus.  Mari kita buat buku pedoman pertama yang tidak melakukan apa-apa: </p><br><pre><code class="plaintext hljs">--- - name: Simple playbook hosts: all</code> </pre> <br><p>  Di sini, kami hanya mengatakan bahwa playbook kami disebut <code>Simple Playbook</code> dan isinya harus dijalankan untuk semua host.  Kita dapat menyimpannya di direktori / ansible dengan nama <code>playbook.yml</code> dan mencoba menjalankannya: </p><br><pre> <code class="plaintext hljs">ansible-playbook ./playbook.yml PLAY [Simple Playbook] ************************************************************************************************************************************ skipping: no hosts matched</code> </pre> <br><p>  Ansible mengatakan tidak tahu host yang cocok dengan semua daftar.  Mereka harus terdaftar dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">file inventaris</a> khusus. </p><br><p>  Mari kita buat di direktori yang sama: </p><br><pre> <code class="plaintext hljs">123.123.123.123</code> </pre> <br><p>  Jadi cukup tentukan host (idealnya, host VPS Anda untuk tes, atau Anda dapat mendaftarkan localhost) dan simpan di bawah <code>inventory</code> nama. <br>  Anda dapat mencoba menjalankan ansible dengan file invetory: </p><br><pre> <code class="plaintext hljs">ansible-playbook ./playbook.yml -i inventory PLAY [Simple Playbook] ************************************************************************************************************************************ TASK [Gathering Facts] ************************************************************************************************************************************ PLAY RECAP ************************************************************************************************************************************</code> </pre> <br><p>  Jika Anda memiliki akses ssh ke host yang ditentukan, maka ansible akan menghubungkan dan mengumpulkan informasi tentang sistem jarak jauh.  (TUGAS default [Fakta Berkumpul]) setelah itu akan memberikan laporan kemajuan singkat (MAINKAN KEMBALI). </p><br><p>  Secara default, nama pengguna tempat Anda masuk ke sistem digunakan untuk koneksi.  Kemungkinan besar tidak akan berada di host.  Dalam file playbook, Anda dapat menentukan pengguna mana yang akan digunakan untuk terhubung menggunakan arahan remote_user.  Selain itu, informasi tentang sistem jarak jauh seringkali tidak perlu bagi Anda dan Anda tidak perlu membuang waktu untuk mengumpulkannya.  Anda juga dapat mematikan tugas ini: </p><br><pre> <code class="plaintext hljs">--- - name: Simple playbook hosts: all remote_user: root become: true gather_facts: no</code> </pre> <br><p>  Coba jalankan playbook lagi dan pastikan koneksi berfungsi.  (Jika Anda menentukan root dari pengguna, Anda juga harus menentukan menjadi: arahan benar untuk mendapatkan hak-hak yang ditinggikan. Seperti yang disebutkan dalam dokumentasi: <code>become set to 'true'/'yes' to activate privilege escalation.</code> Meskipun tidak jelas mengapa) . </p><br><p>  Mungkin Anda mendapatkan kesalahan yang disebabkan oleh kemungkinan yang tidak dapat ditentukan oleh penerjemah python, maka Anda dapat menentukannya secara manual: </p><br><pre> <code class="plaintext hljs">ansible_python_interpreter: /usr/bin/python3</code> </pre> <br><p>  di mana Anda memiliki python dapat ditemukan dengan perintah <code>whereis python</code> . </p><br><h3 id="ustanovka-sistemnyh-paketov">  Instal paket sistem </h3><br><p>  Ansible hadir dengan banyak modul untuk bekerja dengan berbagai paket sistem, jadi kami tidak perlu menulis skrip bash dengan alasan apa pun.  Sekarang kita memerlukan salah satu modul ini untuk memperbarui sistem dan menginstal paket sistem.  Saya memiliki Ubuntu Linux di VPS, masing-masing, untuk menginstal paket, saya menggunakan <code>apt-get</code> dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">modul untuk itu</a> .  Jika Anda menggunakan sistem operasi yang berbeda, maka Anda mungkin memerlukan modul yang berbeda (ingat, saya katakan di awal bahwa kita perlu tahu sebelumnya apa dan bagaimana yang akan kita lakukan).  Namun, sintaksisnya cenderung serupa. </p><br><p>  Kami melengkapi buku pedoman kami dengan tugas pertama: </p><br><pre> <code class="plaintext hljs">--- - name: Simple playbook hosts: all remote_user: root become: true gather_facts: no tasks: - name: Update system apt: update_cache=yes - name: Install system dependencies apt: name: git,nginx,redis,postgresql,postgresql-contrib state: present</code> </pre> <br><p>  Tugas hanyalah tugas yang mungkin dilakukan pada server jarak jauh.  Kami memberi nama tugas untuk melacak kemajuannya dalam log.  Dan kami menjelaskan, menggunakan sintaks modul tertentu, apa yang perlu dilakukan.  Dalam hal ini, <code>apt: update_cache=yes</code> - mengatakan perbarui paket sistem menggunakan modul apt.  Tim kedua sedikit lebih rumit.  Kami meneruskan daftar paket ke modul apt, dan mengatakan bahwa <code>state</code> mereka harus <code>present</code> , yaitu, kami katakan untuk menginstal paket-paket ini.  Demikian pula, kami dapat memberitahu mereka untuk dihapus, atau diperbarui, hanya dengan mengubah <code>state</code> .  Harap dicatat bahwa agar rel dapat bekerja dengan postgresql, kita memerlukan paket postgresql-contrib yang sedang kita instal.  Ini lagi perlu diketahui dan dilakukan, mungkin dengan sendirinya tidak akan melakukan ini. </p><br><p>  Coba jalankan lagi playbook dan verifikasi bahwa paket sudah diinstal. </p><br><h3 id="sozdanie-novyh-polzovateley">  Pembuatan pengguna baru. </h3><br><p>  Untuk bekerja dengan pengguna, Ansible juga memiliki modul - pengguna.  Tambahkan tugas lain (saya menyembunyikan bagian yang sudah diketahui dari buku pedoman di belakang komentar, agar tidak menyalinnya sepenuhnya setiap waktu): </p><br><pre> <code class="plaintext hljs">--- - name: Simple playbook # ... tasks: # ... - name: Add a new user user: name: my_user shell: /bin/bash password: "{{ 123qweasd | password_hash('sha512') }}"</code> </pre> <br><p>  Kami membuat pengguna baru, memberinya skema dan kata sandi.  Dan kemudian kita dihadapkan dengan beberapa masalah.  Bagaimana jika nama pengguna harus berbeda untuk host yang berbeda?  Ya, dan membiarkan kata sandi terbuka di buku pedoman adalah ide yang sangat buruk.  Untuk memulainya, kita akan memasukkan nama pengguna dan kata sandi ke dalam variabel, dan di akhir artikel saya akan menunjukkan cara mengenkripsi kata sandi. </p><br><pre> <code class="plaintext hljs">--- - name: Simple playbook # ... tasks: # ... - name: Add a new user user: name: "{{ user }}" shell: /bin/bash password: "{{ user_password | password_hash('sha512') }}"</code> </pre> <br><p>  Variabel diatur menggunakan kurung keriting ganda di buku pedoman. </p><br><p>  Kami akan menunjukkan nilai-nilai variabel dalam file inventaris: </p><br><pre> <code class="plaintext hljs">123.123.123.123 [all:vars] user=my_user user_password=123qweasd</code> </pre> <br><p>  Perhatikan arahan <code>[all:vars]</code> - ia mengatakan bahwa blok teks berikutnya adalah variabel (vars) dan mereka berlaku untuk semua host (semua). </p><br><p>  Konstruksi <code>"{{ user_password | password_hash('sha512') }}"</code> juga menarik.  Faktanya adalah bahwa ansible tidak mengatur pengguna melalui <code>user_add</code> seperti yang Anda lakukan secara manual.  Dan itu menyimpan semua data secara langsung, itulah sebabnya kita juga harus mengonversi kata sandi menjadi hash terlebih dahulu, yang dilakukan perintah ini. </p><br><p>  Mari tambahkan pengguna kami ke grup sudo.  Namun, sebelum ini, Anda perlu memastikan bahwa grup tersebut ada karena tidak ada yang akan melakukan ini untuk kami: </p><br><pre> <code class="plaintext hljs">--- - name: Simple playbook # ... tasks: # ... - name: Ensure a 'sudo' group group: name: sudo state: present - name: Add a new user user: name: "{{ user }}" shell: /bin/bash password: "{{ user_password | password_hash('sha512') }}" groups: "sudo"</code> </pre> <br><p>  Cukup sederhana, kami juga memiliki modul grup untuk membuat grup, dengan sintaks yang sangat mirip dengan apt.  Maka cukup mendaftarkan grup ini ke pengguna ( <code>groups: "sudo"</code> ). <br>  Juga berguna untuk menambahkan kunci ssh ke pengguna ini sehingga kami dapat masuk di bawahnya tanpa kata sandi: </p><br><pre> <code class="plaintext hljs">--- - name: Simple playbook # ... tasks: # ... - name: Ensure a 'sudo' group group: name: sudo state: present - name: Add a new user user: name: "{{ user }}" shell: /bin/bash password: "{{ user_password | password_hash('sha512') }}" groups: "sudo" - name: Deploy SSH Key authorized_key: user: "{{ user }}" key: "{{ lookup('file', '~/.ssh/id_rsa.pub') }}" state: present</code> </pre> <br><p>  Dalam kasus ini, konstruk <code>"{{ lookup('file', '~/.ssh/id_rsa.pub') }}"</code> menarik - ini menyalin isi file id_rsa.pub (nama Anda mungkin berbeda), yaitu, bagian publik dari kunci ssh dan mengunggahnya ke daftar kunci resmi untuk pengguna di server. </p><br><h3 id="roli">  Peran </h3><br><p>  Ketiga tugas untuk pembuatan dapat dengan mudah digunakan sebagai satu kelompok tugas, dan alangkah baiknya untuk memisahkan kelompok ini dari buku pedoman utama sehingga tidak tumbuh terlalu banyak.  Ada beberapa <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">peran</a> untuk hal ini. <br>  Menurut struktur file yang ditunjukkan di bagian paling awal, peran harus diletakkan dalam direktori peran terpisah, untuk setiap peran - direktori terpisah dengan nama yang sama, di dalam tugas, file, template, direktori dll <br>  Mari kita buat struktur file: <code>./ansible/roles/user/tasks/main.yml</code> (utama adalah file utama yang akan dimuat dan dieksekusi ketika peran terhubung ke playbook, file peran lainnya dapat dihubungkan di dalamnya).  Sekarang Anda dapat mentransfer ke file ini semua tugas yang terkait dengan pengguna: </p><br><pre> <code class="plaintext hljs"># Create user and add him to groups - name: Ensure a 'sudo' group group: name: sudo state: present - name: Add a new user user: name: "{{ user }}" shell: /bin/bash password: "{{ user_password | password_hash('sha512') }}" groups: "sudo" - name: Deploy SSH Key authorized_key: user: "{{ user }}" key: "{{ lookup('file', '~/.ssh/id_rsa.pub') }}" state: present</code> </pre> <br><p>  Di buku pedoman utama, Anda harus menentukan untuk menggunakan peran pengguna: </p><br><pre> <code class="plaintext hljs">--- - name: Simple playbook hosts: all remote_user: root gather_facts: no tasks: - name: Update system apt: update_cache=yes - name: Install system dependencies apt: name: git,nginx,redis,postgresql,postgresql-contrib state: present roles: - user</code> </pre> <br><p>  Juga, mungkin masuk akal untuk melakukan pembaruan sistem sebelum semua tugas lain, untuk ini Anda dapat mengganti nama blok <code>tasks</code> yang didefinisikan dalam <code>pre_tasks</code> . </p><br><h3 id="nastroyka-nginx">  Pengaturan nginx </h3><br><p>  Nginx seharusnya sudah diinstal bersama kami, Anda perlu mengkonfigurasi dan menjalankannya.  Mari kita lakukan segera dalam peran itu.  Buat struktur file: </p><br><pre> <code class="plaintext hljs">- ansible - roles - nginx - files - tasks - main.yml - templates</code> </pre> <br><p>  Sekarang kita membutuhkan file dan templat.  Perbedaan antara keduanya adalah bahwa file yang mungkin disalin disalin secara langsung, sebagaimana adanya.  Dan templat harus memiliki ekstensi j2 dan mereka dapat menggunakan nilai variabel menggunakan kurung keriting ganda yang sama. </p><br><p>  Mari kita sertakan nginx dalam file <code>main.yml</code> .  Untuk ini, kami memiliki modul systemd: </p><br><pre> <code class="plaintext hljs"># Copy nginx configs and start it - name: enable service nginx and start systemd: name: nginx state: started enabled: yes</code> </pre> <br><p>  Di sini kita tidak hanya mengatakan bahwa nginx harus dimulai (mis., Jalankan), tetapi segera katakan bahwa itu harus diaktifkan. <br>  Sekarang salin file konfigurasi: </p><br><pre> <code class="plaintext hljs"># Copy nginx configs and start it - name: enable service nginx and start systemd: name: nginx state: started enabled: yes - name: Copy the nginx.conf copy: src: nginx.conf dest: /etc/nginx/nginx.conf owner: root group: root mode: '0644' backup: yes - name: Copy template my_app.conf template: src: my_app_conf.j2 dest: /etc/nginx/sites-available/my_app.conf owner: root group: root mode: '0644'</code> </pre> <br><p>  Kami membuat file konfigurasi nginx utama (Anda dapat mengambilnya langsung dari server, atau menulisnya sendiri).  Dan juga file konfigurasi untuk aplikasi kita di direktori sites_available (ini tidak perlu tetapi berguna).  Dalam kasus pertama, kami menggunakan modul salin untuk menyalin file (file tersebut harus di <code>/ansible/roles/nginx/files/nginx.conf</code> ).  Dalam kedua - salin templat, gantikan nilai-nilai variabel.  Template harus di <code>/ansible/roles/nginx/templates/my_app.j2</code> ).  Dan mungkin terlihat seperti ini: </p><br><pre> <code class="plaintext hljs">upstream {{ app_name }} { server unix:{{ app_path }}/shared/tmp/sockets/puma.sock; } server { listen 80; server_name {{ server_name }} {{ inventory_hostname }}; root {{ app_path }}/current/public; try_files $uri/index.html $uri.html $uri @{{ app_name }}; .... }</code> </pre> <br><p>  Perhatikan sisipan <code>{{ app_name }}</code> , <code>{{ app_path }}</code> , <code>{{ server_name }}</code> , <code>{{ inventory_hostname }}</code> - ini semua variabel yang nilainya tidak akan diganti dalam templat sebelum disalin.  Ini berguna jika Anda menggunakan buku pedoman untuk grup host yang berbeda.  Misalnya, kami dapat melengkapi file inventaris kami: </p><br><pre> <code class="plaintext hljs">[production] 123.123.123.123 [staging] 231.231.231.231 [all:vars] user=my_user user_password=123qweasd [production:vars] server_name=production app_path=/home/www/my_app app_name=my_app [staging:vars] server_name=staging app_path=/home/www/my_stage app_name=my_stage_app</code> </pre> <br><p>  Jika kami menjalankan buku pedoman kami sekarang, itu akan melakukan tugas yang ditentukan untuk kedua host.  Tetapi pada saat yang sama, untuk host panggung, variabel-variabel akan berbeda dari produksi, dan tidak hanya dalam peran dan buku pedoman, tetapi juga dalam konfigurasi nginx.  <code>{{ inventory_hostname }}</code> tidak perlu ditentukan dalam file inventaris - ini adalah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">variabel khusus yang dimungkinkan</a> dan host yang sedang dijalankan playbook disimpan di sana. <br>  Jika Anda ingin memiliki file inventaris untuk beberapa host, dan dijalankan hanya untuk satu grup, ini dapat dilakukan dengan perintah berikut: </p><br><pre> <code class="plaintext hljs">ansible-playbook -i inventory ./playbook.yml -l "staging"</code> </pre> <br><p>  Pilihan lain adalah memiliki file inventaris terpisah untuk grup yang berbeda.  Atau Anda dapat menggabungkan dua pendekatan jika Anda memiliki banyak host yang berbeda. </p><br><p>  Mari kita kembali ke konfigurasi nginx.  Setelah menyalin file konfigurasi, kita perlu membuat symlink di sitest_enabled di my_app.conf dari sites_available.  Dan restart nginx. </p><br><pre> <code class="plaintext hljs">... # old code in mail.yml - name: Create symlink to sites-enabled file: src: /etc/nginx/sites-available/my_app.conf dest: /etc/nginx/sites-enabled/my_app.conf state: link - name: restart nginx service: name: nginx state: restarted</code> </pre> <br><p>  Semuanya sederhana di sini - sekali lagi, modul yang memungkinkan dengan sintaksis yang cukup standar.  Tetapi ada satu poin.  Memulai ulang nginx setiap kali tidak masuk akal.  Anda perhatikan bahwa kami tidak menulis perintah dalam bentuk: "lakukan ini seperti ini", sintaksisnya lebih mirip "ini seharusnya memiliki keadaan ini".  Dan paling sering ini adalah cara kerja yang memungkinkan.  Jika grup sudah ada atau paket sistem sudah diinstal, maka ansible akan memeriksa ini dan melewatkan tugas.  Selain itu, file tidak akan disalin jika benar-benar bertepatan dengan apa yang sudah ada di server.  Kita dapat memanfaatkan ini dan memulai ulang nginx hanya jika file konfigurasi telah diubah.  Ada arahan register untuk ini: </p><br><pre> <code class="plaintext hljs"># Copy nginx configs and start it - name: enable service nginx and start systemd: name: nginx state: started enabled: yes - name: Copy the nginx.conf copy: src: nginx.conf dest: /etc/nginx/nginx.conf owner: root group: root mode: '0644' backup: yes register: restart_nginx - name: Copy template my_app.conf template: src: my_app_conf.j2 dest: /etc/nginx/sites-available/my_app.conf owner: root group: root mode: '0644' register: restart_nginx - name: Create symlink to sites-enabled file: src: /etc/nginx/sites-available/my_app.conf dest: /etc/nginx/sites-enabled/my_app.conf state: link - name: restart nginx service: name: nginx state: restarted when: restart_nginx.changed</code> </pre> <br><p>  Jika salah satu file konfigurasi berubah, maka salin akan dilakukan dan variabel <code>restart_nginx</code> akan terdaftar.  Dan hanya jika variabel ini telah terdaftar, layanan akan restart. </p><br><p>  Yah, tentu saja, Anda perlu menambahkan peran nginx ke buku pedoman utama. </p><br><h3 id="nastroyka-postgresql">  Penyiapan postgresql </h3><br><p>  Kita perlu mengaktifkan postgresql dengan systemd seperti yang kita lakukan dengan nginx, dan juga membuat pengguna yang akan kita gunakan untuk mengakses database dan database itu sendiri. <br>  Buat peran <code>/ansible/roles/postgresql/tasks/main.yml</code> : </p><br><pre> <code class="plaintext hljs"># Create user in postgresql - name: enable postgresql and start systemd: name: postgresql state: started enabled: yes - name: Create database user become_user: postgres postgresql_user: name: "{{ db_user }}" password: "{{ db_password }}" role_attr_flags: SUPERUSER - name: Create database become_user: postgres postgresql_db: name: "{{ db_name }}" encoding: UTF-8 owner: "{{ db_user }}"</code> </pre> <br><p>  Saya tidak akan menjelaskan cara menambahkan variabel ke inventaris, ini telah dilakukan berkali-kali, serta sintaks dari modul postgresql_db dan postgresql_user.  Lebih banyak data dapat ditemukan dalam dokumentasi.  Arahan <code>become_user: postgres</code> paling menarik di <code>become_user: postgres</code> .  Faktanya adalah bahwa secara default hanya pengguna postgres yang memiliki akses ke database postgresql dan hanya secara lokal.  Arahan ini memungkinkan kami untuk menjalankan perintah atas nama pengguna ini (kecuali tentu saja kami memiliki akses). <br>  Juga, Anda mungkin harus menambahkan baris ke pg_hba.conf untuk membuka akses ke database untuk pengguna baru.  Ini dapat dilakukan dengan cara yang sama seperti kita mengubah konfigurasi nginx. </p><br><p>  Dan tentu saja Anda perlu menambahkan peran postgresql ke buku pedoman utama. </p><br><h3 id="ustanovka-ruby-cherez-rbenv">  Instal ruby ​​melalui rbenv </h3><br><p>  Ansible tidak memiliki modul untuk bekerja dengan rbenv, tetapi diinstal dengan mengkloning repositori git.  Karenanya, tugas ini menjadi yang paling non-standar.  Mari kita buat peran <code>/ansible/roles/ruby_rbenv/main.yml</code> untuknya dan mulai mengisinya: </p><br><pre> <code class="plaintext hljs"># Install rbenv and ruby - name: Install rbenv become_user: "{{ user }}" git: repo=https://github.com/rbenv/rbenv.git dest=~/.rbenv</code> </pre> <br><p>  Kami lagi menggunakan arahan be_user untuk bekerja dari bawah pengguna yang kami buat untuk tujuan ini.  Karena rbenv diinstal di direktori home-nya, tidak secara global.  Dan kami juga menggunakan modul git untuk mengkloning repositori dengan menentukan repo dan dest. </p><br><p>  Selanjutnya, kita perlu mendaftarkan rbenv init di bashrc dan menambahkan rbenv ke PATH di tempat yang sama.  Untuk ini, kami memiliki modul lineinfile: </p><br><pre> <code class="plaintext hljs">- name: Add rbenv to PATH become_user: "{{ user }}" lineinfile: path: ~/.bashrc state: present line: 'export PATH="${HOME}/.rbenv/bin:${PATH}"' - name: Add rbenv init to bashrc become_user: "{{ user }}" lineinfile: path: ~/.bashrc state: present line: 'eval "$(rbenv init -)"'</code> </pre> <br><p>  Kemudian instal ruby_build: </p><br><pre> <code class="plaintext hljs">- name: Install ruby-build become_user: "{{ user }}" git: repo=https://github.com/rbenv/ruby-build.git dest=~/.rbenv/plugins/ruby-build</code> </pre> <br><p>  Dan akhirnya instal ruby.  Ini dilakukan melalui rbenv, yaitu, hanya perintah bash: </p><br><pre> <code class="plaintext hljs">- name: Install ruby become_user: "{{ user }}" shell: | export PATH="${HOME}/.rbenv/bin:${PATH}" eval "$(rbenv init -)" rbenv install {{ ruby_version }} args: executable: /bin/bash</code> </pre> <br><p>  Kami mengatakan tim mana yang harus dieksekusi dan bagaimana caranya.  Namun, di sini kita menemukan fakta bahwa ansible tidak menjalankan kode yang terkandung dalam bashrc sebelum menjalankan perintah.  Jadi, rbenv harus didefinisikan secara langsung dalam skrip yang sama. </p><br><p>  Masalah selanjutnya adalah bahwa perintah shell tidak memiliki status dalam hal ansible.  Yaitu, pemeriksaan otomatis apakah versi ruby ​​ini diinstal atau tidak tidak.  Kita bisa melakukannya sendiri: </p><br><pre> <code class="plaintext hljs">- name: Install ruby become_user: "{{ user }}" shell: | export PATH="${HOME}/.rbenv/bin:${PATH}" eval "$(rbenv init -)" if ! rbenv versions | grep -q {{ ruby_version }} then rbenv install {{ ruby_version }} &amp;&amp; rbenv global {{ ruby_version }} fi args: executable: /bin/bash</code> </pre> <br><p>  Dan masih menginstal bundler: </p><br><pre> <code class="plaintext hljs">- name: Install bundler become_user: "{{ user }}" shell: | export PATH="${HOME}/.rbenv/bin:${PATH}" eval "$(rbenv init -)" gem install bundler</code> </pre> <br><p>  Dan lagi, tambahkan peran ruby_rbenv kami ke buku pedoman utama. </p><br><h3 id="shared-files">  File bersama. </h3><br><p>  Secara umum, pengaturan ini dapat diselesaikan.  Kemudian tetap menjalankan capistrano dan akan menyalin kode itu sendiri, membuat direktori yang diperlukan dan meluncurkan aplikasi (jika semuanya dikonfigurasi dengan benar).  Namun, seringkali capistrano memerlukan file konfigurasi tambahan, seperti <code>database.yml</code> atau <code>.env</code> dapat menyalinnya seperti file dan templat untuk nginx.  Hanya ada satu kehalusan.  Sebelum menyalin file, Anda perlu membuat struktur direktori untuk mereka, sesuatu seperti ini: </p><br><pre> <code class="plaintext hljs"># Copy shared files for deploy - name: Ensure shared dir become_user: "{{ user }}" file: path: "{{ app_path }}/shared/config" state: directory</code> </pre> <br><p>  kami menetapkan hanya satu direktori dan ansible akan secara otomatis membuat induk, jika perlu. </p><br><h2 id="ansible-vault">  Lemari besi yang memungkinkan </h2><br><p>  Kami telah menemukan fakta bahwa data rahasia seperti kata sandi pengguna dapat muncul dalam variabel.  Jika Anda membuat file <code>.env</code> untuk aplikasi, dan <code>database.yml</code> maka harus ada lebih banyak data penting seperti itu.  Akan lebih baik menyembunyikan mereka dari mata yang mengintip.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Lemari besi yang memungkinkan</a> digunakan untuk ini. </p><br><p>  Mari kita membuat file untuk variabel <code>/ansible/vars/all.yml</code> (di sini Anda dapat membuat file yang berbeda untuk berbagai kelompok host, seperti dalam file inventaris: production.yml, staging.yml, dll) <br>  Dalam file ini, Anda perlu mentransfer semua variabel yang harus dienkripsi menggunakan sintaks yml standar: </p><br><pre> <code class="plaintext hljs"># System vars user_password: 123qweasd db_password: 123qweasd # ENV vars aws_access_key_id: xxxxx aws_secret_access_key: xxxxxx aws_bucket: bucket_name rails_secret_key_base: very_secret_key_base</code> </pre> <br><p>  Maka file ini dapat dienkripsi dengan perintah: </p><br><pre> <code class="plaintext hljs">ansible-vault encrypt ./vars/all.yml</code> </pre> <br><p>  Secara alami, selama enkripsi akan diperlukan untuk mengatur kata sandi untuk dekripsi.  Anda dapat melihat apa yang muncul di dalam file setelah memanggil perintah ini. </p><br><p>  Menggunakan <code>ansible-vault decrypt</code> file dapat didekripsi, dimodifikasi, dan kemudian dienkripsi lagi. </p><br><p>  Untuk bekerja, dekripsi file tidak diperlukan.  Anda menyimpannya dalam bentuk terenkripsi dan menjalankan playbook dengan argumen <code>--ask-vault-pass</code> .  Ansible akan meminta kata sandi, mendapatkan variabel, dan menyelesaikan tugas.  Semua data akan tetap terenkripsi. </p><br><p>  Perintah lengkap untuk beberapa grup host dan vault yang dimungkinkan akan terlihat seperti ini: </p><br><pre> <code class="plaintext hljs">ansible-playbook -i inventory ./playbook.yml -l "staging" --ask-vault-pass</code> </pre> <br><p>  Dan saya tidak akan memberi Anda teks lengkap buku pedoman dan peran, tulis sendiri.  Karena hal yang mungkin adalah ini - jika Anda tidak mengerti apa yang perlu dilakukan, maka dia tidak akan melakukannya. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id460769/">https://habr.com/ru/post/id460769/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id460743/index.html">Panduan Pemula Bergetar</a></li>
<li><a href="../id460745/index.html">Pengalaman dalam menggunakan modul GSM di otomatisasi rumah</a></li>
<li><a href="../id460747/index.html">Mencari keuntungan atau mengencangkan kacang: Spotify telah berhenti bekerja dengan penulis secara langsung - apa artinya</a></li>
<li><a href="../id460751/index.html">Bagaimana kami meluncurkan robot dalam Chernobyl kecil. Bagian 1</a></li>
<li><a href="../id460755/index.html">ROS Trolley Robot - Bagian 1: Besi</a></li>
<li><a href="../id460773/index.html">Menerapkan pencocokan pola di Jawa</a></li>
<li><a href="../id460777/index.html">Inilah gilirannya: mengapa Apple telah mengubah persyaratan untuk pengembang aplikasi</a></li>
<li><a href="../id460779/index.html">Debug Lanjutan</a></li>
<li><a href="../id460783/index.html">Konsensus tentang reputasi simpul. Apakah itu perlu?</a></li>
<li><a href="../id460785/index.html">Aplikasi untuk e-book di sistem operasi Android. Bagian 1. Pendahuluan dan aplikasi kantor</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>