<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🎳 🚣🏻 👎🏾 Beschleunigung der PHP-Konnektoren für Tarantool mit Async, Swoole und Parallel 💅🏼 🏙️ 👨‍🚒</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Im PHP-Ökosystem gibt es derzeit zwei Konnektoren für den Tarantool-Server: die in C geschriebene offizielle PECL-Erweiterung tarantool / tarantool-ph...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Beschleunigung der PHP-Konnektoren für Tarantool mit Async, Swoole und Parallel</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/mailru/blog/480032/"><img src="https://habrastorage.org/webt/5r/bm/wi/5rbmwilvinacbni2aggejp0n7sk.jpeg"><br><br>  Im PHP-Ökosystem gibt es derzeit zwei Konnektoren für den Tarantool-Server: die in C geschriebene offizielle PECL-Erweiterung <a href="https://github.com/tarantool/tarantool-php">tarantool / tarantool-php</a> und <a href="https://github.com/tarantool-php/client">tarantool-php / client</a> in PHP.  Ich bin der Autor des letzteren. <br><br>  In diesem Artikel möchte ich die Ergebnisse der Leistungstests beider Bibliotheken teilen und zeigen, wie Sie mit minimalen Codeänderungen eine 3x-5x-Leistungsverbesserung ( <i>bei synthetischen Tests!</i> ) Erzielen können. <br><a name="habracut"></a><br><h2>  Was werden wir testen? </h2><br>  Wir werden die oben genannten synchronen Konnektoren asynchron, parallel und asynchron parallel testen.  Außerdem möchten wir keine Änderungen am Quellcode der Connectors vornehmen.  Im Moment sind mehrere Erweiterungen verfügbar, die diese Aufgabe übernehmen können: <br><br><ul><li>  <a href="https://github.com/swoole/swoole-src">Swoole</a> , ein leistungsstarkes asynchrones Framework für PHP.  Wird von Internetgiganten wie Alibaba und Baidu verwendet.  Seit Version 4.1.0 gibt es den erstaunlichen Laufzeit-Hook <i>Swoole \ Runtime :: enableCoroutine ()</i> , der es ermöglicht, „synchrone PHP-Netzwerkbibliotheken mit einer einzigen Codezeile in Co-Routine-Bibliotheken umzuwandeln“. </li><li>  Async, eine vielversprechende Erweiterung für das asynchrone Arbeiten in PHP bis vor kurzem.  Warum bis vor kurzem?  Leider hat der Autor aus mir unbekannten Gründen das Repository gelöscht und die Zukunft des Projekts ist fraglich.  Ich werde <a href="https://github.com/dreamsxin/ext-async">eine</a> der Gabeln benutzen.  Wie Swoole macht es diese Erweiterung einfach, den asynchronen Modus zu aktivieren, indem die Standard-Stream-Implementierungen von PHP durch ihre asynchronen Gegenstücke ersetzt werden.  Dies erfolgt über die Option „ <i>async.tcp = 1</i> “. </li><li>  <a href="https://github.com/krakjoe/parallel">Parallel dazu</a> eine ganz neue Erweiterung des bekannten Joe Watkins, dem Autor von Bibliotheken wie phpdbg, apcu, pthreads, pcov, uopz.  Die Erweiterung bietet eine Multi-Threading-API für PHP und ist als Ersatz für pthreads positioniert.  Eine wesentliche Einschränkung der Bibliothek besteht darin, dass sie nur mit der ZTS-Version (Zend Thread Safe) von PHP funktioniert. </li></ul><br><h2>  Wie werden wir testen? </h2><br>  Wir werden eine Tarantool-Instanz mit deaktivierter Write-Ahead-Protokollierung ( <i>wal_mode = none</i> ) und einem erweiterten Netzwerkpuffer ( <i>readahead = 1 * 1024 * 1024</i> ) <i>ausführen</i> .  Die erste Option verhindert E / A-Vorgänge auf dem Festplattenlaufwerk, die zweite Option ermöglicht das Lesen weiterer Anforderungen aus dem Betriebssystempuffer und minimiert so die Anzahl der Systemaufrufe. <br><br>  Für Benchmarks, die mit Daten arbeiten (Einfügen, Löschen, Lesen usw.), wird vor dem Start des Benchmarks ein Memtx-Bereich (neu) erstellt, und die anfänglichen Indexwerte für diesen Bereich werden vom Sequenzgenerator erstellt. <br><br>  Die DDL des Space ist wie folgt: <br><br><pre><code class="lua hljs">space = box.schema.space.<span class="hljs-built_in"><span class="hljs-built_in">create</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">config</span></span>.space_name, { id = <span class="hljs-built_in"><span class="hljs-built_in">config</span></span>.space_id, temporary = <span class="hljs-literal"><span class="hljs-literal">true</span></span> }) space:create_index(<span class="hljs-string"><span class="hljs-string">'primary'</span></span>, { <span class="hljs-built_in"><span class="hljs-built_in">type</span></span> = <span class="hljs-string"><span class="hljs-string">'tree'</span></span>, parts = {<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">'unsigned'</span></span>}, sequence = <span class="hljs-literal"><span class="hljs-literal">true</span></span> }) space:<span class="hljs-built_in"><span class="hljs-built_in">format</span></span>({ {name = <span class="hljs-string"><span class="hljs-string">'id'</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">type</span></span> = <span class="hljs-string"><span class="hljs-string">'unsigned'</span></span>}, {name = <span class="hljs-string"><span class="hljs-string">'name'</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">type</span></span> = <span class="hljs-string"><span class="hljs-string">'string'</span></span>, is_nullable = <span class="hljs-literal"><span class="hljs-literal">false</span></span>} })</code> </pre> <br>  Falls erforderlich, wird der Platz vor dem Start des Benchmarks mit 10.000 Tupeln der folgenden Form gefüllt: <br><br><pre> <code class="lua hljs">{id, <span class="hljs-string"><span class="hljs-string">'tuple_'</span></span> .. id}</code> </pre> <br>  Auf die Tupel wird mit dem Zufallsschlüsselwert zugegriffen. <br><br>  Der Benchmark ist eine einzelne Anforderung an den Server, die 10.000 Mal (Umdrehungen) ausgeführt wird, die wiederum in Iterationen ausgeführt werden.  Die Iterationen werden wiederholt, bis alle Zeitabweichungen zwischen 5 Iterationen innerhalb der 3% igen Fehlertoleranz liegen *.  Danach wird das Durchschnittsergebnis genommen.  Zwischen den Iterationen gibt es eine Pause von 1 Sekunde, um ein Drosseln der CPU zu verhindern.  Der Lua Garbage Collector wird vor jeder Iteration deaktiviert und muss nach Abschluss der Iteration gestartet werden.  Der PHP-Prozess wird nur mit den für den Benchmark erforderlichen Erweiterungen gestartet, wobei die Ausgabepufferung aktiviert und der Garbage Collector deaktiviert ist. <br><br>  <i>* Die Anzahl der Umdrehungen, Iterationen und die Fehlerschwelle können in den Benchmark-Einstellungen geändert werden.</i> <br><br><h2>  Testumgebung </h2><br>  Die unten angegebenen Ergebnisse wurden auf MacBookPro (Mitte 2015) mit Fedora 30 (Kernel-Version 5.3.8-200.fc30.x86_64) erstellt.  Tarantool wurde im Docker mit der Einstellung " <i>--network host</i> " gestartet. <br><br>  <b>Paketversionen:</b> <br><br>  Tarantool: 2.3.0-115-g5ba5ed37e <br>  Docker: 19.03.03, Build a872fc2f86 <br>  PHP: 7.3.11 (cli) (erstellt: 22. Oktober 2019 08:11:04) <br>  Tarantool / Client: 0.6.0 <br>  rybakit / msgpack: 0.6.1 <br>  ext-tarantool: 0.3.2 (gepatcht) * <br>  ext-msgpack: 2.0.3 <br>  ext-asynchron: 0,3,0-8c1da46 <br>  ext-swoole: 4.4.12 <br>  ext-parallel: 1.1.3 <br><br>  <i>* Leider funktioniert der offizielle Connector nicht mit PHP&gt; 7.2.</i>  <i>Um die Erweiterung auf PHP 7.3 zu kompilieren und auszuführen, musste ich einen <a href="https://github.com/tarantool/tarantool-php/pull/148/files">Patch verwenden</a> .</i> <br><br><h2>  Ergebnisse </h2><br><h4>  Synchronisieren (Standard) </h4><br>  Das Tarantool-Protokoll verwendet das <a href="https://msgpack.org/">MessagePack-</a> Binärformat, um Nachrichten zu serialisieren.  Im PECL-Konnektor ist die Serialisierung tief in der Bibliothek verborgen, sodass <a href="https://github.com/tarantool/tarantool-php/issues/89">es unmöglich erscheint</a> , den Codierungsprozess über den Userland-Code zu beeinflussen.  Im Gegensatz dazu bietet der reine PHP-Connector die Möglichkeit, den Codierungsprozess anzupassen, indem Sie entweder einen der Standardcodierer erweitern oder Ihre eigene Implementierung verwenden.  Zwei Encoder sind sofort verfügbar: Einer basiert auf <a href="https://github.com/msgpack/msgpack-php/">msgpack / msgpack-php</a> (der offiziellen MessagePack PECL-Erweiterung) und der andere auf <a href="https://github.com/rybakit/msgpack.php">rybakit / msgpack</a> (reines PHP). <br><br>  Bevor wir mit dem Vergleichen der Konnektoren fortfahren, messen wir die Leistung der MessagePack-Encoder für den PHP-Konnektor, damit wir in unseren Tests den besten Performer verwenden können: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d72/e70/645/d72e70645fb9c1ec359eb6ac25ec5b57.png"></div><br>  Obwohl die PHP-Version (Pure) nicht so schnell ist wie die PECL-Erweiterung, würde ich dennoch die Verwendung von <a href="https://github.com/rybakit/msgpack.php">rybakit / msgpack</a> in realen Projekten empfehlen, da die offizielle PECL-Erweiterung die MessagePack-Spezifikation nur teilweise implementiert (z. B. gibt es keine Unterstützung für benutzerdefinierte Datentypen, und ohne können Sie Decimal nicht verwenden - ein neuer Datentyp, der in Tarantool 2.3 eingeführt wurde) und eine Reihe anderer <a href="https://github.com/msgpack/msgpack-php/issues">Probleme aufweist</a> (einschließlich Kompatibilitätsprobleme mit PHP 7.4).  Und das Projekt sieht im Allgemeinen verlassen aus. <br><br>  Lassen Sie uns also die Leistung der Konnektoren im synchronen Modus messen: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/051/bb3/ed3/051bb3ed3341d0c19788325ea624f7c6.png"></div><br>  Wie Sie in der Grafik sehen können, ist der PECL-Connector (Tarantool) besser als der PHP-Connector (Client).  Dies ist nicht verwunderlich, da letztere nicht nur in einer langsameren Sprache implementiert sind, sondern auch mehr Arbeit leisten: Mit jeder Anforderung wird ein neues <i>Anforderungs-</i> und <i>Antwortobjekt</i> erstellt (im Fall von Select gibt es auch <i>Kriterien</i> , und im Im Falle von Update / Upsert gibt es <i>Operations</i> ), <i>Connection</i> , <i>Packer</i> und <i>Handler</i> fügen ebenfalls etwas Overhead hinzu.  Es ist unnötig zu erwähnen, dass eine höhere Flexibilität mit Kosten verbunden ist.  Der PHP-Interpreter zeigt jedoch im Allgemeinen eine gute Leistung.  Obwohl es einen Unterschied gibt, ist er unbedeutend und kann mit der Verwendung von Preloading in PHP 7.4 noch weniger werden, ganz zu schweigen von JIT in PHP 8. <br><br>  Jetzt weitermachen.  Tarantool 2.0 führte die SQL-Unterstützung ein.  Versuchen wir, Select-, Insert-, Update- und Delete-Operationen unter Verwendung des SQL-Protokolls durchzuführen und die Ergebnisse mit noSQL-Entsprechungen (binär) zu vergleichen: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8d0/4e5/308/8d04e5308574fb007c8fa1480987a92e.png"></div><br>  Die SQL-Ergebnisse sind nicht besonders beeindruckend (lassen Sie mich daran erinnern, dass wir den synchronen Modus noch testen).  Ich würde mich jedoch nicht vorzeitig darüber aufregen: Die SQL-Unterstützung befindet sich noch in der aktiven Entwicklung (z. B. wurde die Unterstützung für <a href="https://github.com/tarantool/tarantool/commit/ff2091e09b5a7e9b7aa3f3e996dc7a06189889f3">vorbereitete Anweisungen</a> vor nicht allzu langer Zeit hinzugefügt), und die SQL-Engine wird es laut der Liste der <a href="https://github.com/tarantool/tarantool/issues%3Fq%3Dis%253Aissue%2Bis%253Aopen%2Bsql%2Blabel%253Aperformance">Probleme</a> tun erhalten Sie eine Reihe von Optimierungen in der Zukunft. <br><br><h4>  Async </h4><br>  Nun wollen wir sehen, wie uns die Async-Erweiterung dabei helfen kann, die oben genannten Ergebnisse zu verbessern.  Für die asynchrone Programmierung stellt die Erweiterung eine Coroutine-basierte API bereit, die wir hier verwenden werden.  Erstens, wie wir durch Tests herausfinden, beträgt die optimale Anzahl von Koroutinen für unsere Umgebung 25: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/578/89f/32d/57889f32d5370c1074ca1ff637807acf.png"></div><br>  Dann verteilen wir 10.000 Operationen auf 25 Koroutinen und überprüfen das Ergebnis: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/53e/e14/337/53ee143371549b9f11c70b1305901e7e.png"></div><br>  Die Anzahl der Operationen pro Sekunde hat sich für den PHP-Connector mehr als verdreifacht!  Leider konnte der PECL-Connector nicht mit ext-async gestartet werden. <br><br>  Und was ist mit SQL? <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4bc/e45/cad/4bce45caddc5079eb38ac26498aa0dfc.png"></div><br>  Wie Sie sehen, liegt der Unterschied zwischen dem Binärprotokoll und SQL im asynchronen Modus innerhalb der Fehlergrenze. <br><br><h4>  Swoole </h4><br>  Lassen Sie uns noch einmal die optimale Anzahl von Koroutinen bestimmen, diesmal für Swoole: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/452/d71/3b2/452d713b2d513c9cd97a1fbce3f706ef.png"></div><br>  Nehmen wir 25. Wiederholen Sie nun den gleichen Trick wie bei der Async-Erweiterung: Verteilen Sie 10.000 Operationen auf 25 Coroutinen.  Ansonsten fügen wir noch einen Test hinzu, bei dem wir das Ganze in zwei Prozesse aufteilen (d. H. Jeder Prozess führt 5.000 Operationen in 25 Coroutinen aus).  Die Prozesse werden mit Hilfe von <i>Swoole \ Process erstellt</i> . <br><br>  Ergebnisse: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/763/606/55c/76360655ca3480a8e57aff8cd55ad53c.png"></div><br>  Swoole zeigt eine etwas geringere Leistung als Async, wenn es in einem Prozess ausgeführt wird, aber bei 2 Prozessen ändert sich das Bild drastisch (2 ist kein Zufall, auf meinem Computer zeigte genau diese Anzahl von Prozessen das beste Ergebnis). <br><br>  <i>Übrigens gibt es auch eine API für die Arbeit mit Prozessen in der Async-Erweiterung, aber ich habe keinen Unterschied zwischen dem Starten von Benchmarks in einem einzelnen Prozess oder in mehreren Prozessen festgestellt (es ist jedoch möglich, dass ich einige Fehler gemacht habe).</i> <i><br></i> <br>  SQL versus binäres Protokoll: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f1b/0c6/ed1/f1b0c6ed18c9a2dd153d2307564937ab.png"></div><br>  Wie bei Async wird der Unterschied zwischen Binär- und SQL-Operationen im asynchronen Modus ausgeglichen. <br><br><h4>  Parallel </h4><br>  Da es sich bei der Erweiterung Parallel um Threads und nicht um Coroutinen handelt, messen wir die optimale Anzahl paralleler Threads: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f44/7a6/c2f/f447a6c2f9bc50be507bfd56c70f5b2c.png"></div><br>  Es ist 16 auf meinem Computer.  Lassen Sie uns nun die Anschlüsse auf 16 parallelen Threads vergleichen: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6db/5f7/489/6db5f7489dcb97871993cdb7476a764a.png"></div><br>  Wie Sie sehen, ist das Ergebnis sogar noch besser als bei asynchronen Erweiterungen (mit Ausnahme von Swoole, das mit zwei Prozessen gestartet wurde).  Beachten Sie, dass für den PECL-Connector für Aktualisierungs- und Upsert-Vorgänge keine Leiste angezeigt wird.  Dies liegt daran, dass diese Vorgänge mit einem Fehler abgestürzt sind und ich nicht sicher bin, was daran schuld ist: ext-parallel oder ext-tarantool oder beides. <br><br>  Fügen wir nun die SQL-Leistung zum Vergleich hinzu: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d86/59c/8c2/d8659c8c25b466fc5cc538b08e6d2441.png"></div><br>  Haben Sie Ähnlichkeiten mit dem Diagramm für die synchron gestarteten Connectors festgestellt? <br><br><h4>  Alles in einem </h4><br>  Lassen Sie uns zum Schluss alle Ergebnisse in einem Diagramm zusammenfassen, um das gesamte Bild für die getesteten Erweiterungen zu sehen.  Wir werden dem Diagramm nur einen neuen Test hinzufügen, den wir noch nicht durchgeführt haben: Starten Sie Async Coroutines parallel mit Parallel *.  Die Idee, die oben genannten Erweiterungen zu integrieren, wurde bereits von den Autoren <a href="https://github.com/krakjoe/parallel/issues/25">diskutiert, es</a> wurde jedoch kein Konsens erzielt, sodass wir dies selbst tun müssen. <br><br>  <i>* Ich konnte Swoole-Coroutinen nicht mit Parallel starten.</i>  <i>Es scheint, dass diese Erweiterungen nicht kompatibel sind.</i> <br><br>  Nun sind die endgültigen Ergebnisse: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/15a/23e/81c/15a23e81c9d330223990c6e60f127369.png"></div><br><h2>  Fazit </h2><br>  Meiner Meinung nach sind die Ergebnisse recht anständig, aber es gibt etwas, das mich glauben lässt, dass wir noch nicht da sind!  Wenn Sie Ideen zur Verbesserung der Benchmarks haben, werde ich Ihre Pull-Anfrage gerne prüfen.  Der gesamte Code mit Startanweisungen und Ergebnissen wird in einem dedizierten <a href="https://github.com/tarantool-php/benchmarks">Repository veröffentlicht</a> . <br><br>  Ich überlasse es Ihnen, zu entscheiden, ob Sie dies für ein reales Projekt benötigen, und möchte nur sagen, dass es ein aufregendes Experiment war, mit dem ich abschätzen konnte, wie viel man mit minimalem Aufwand aus einem synchronen TCP-Connector herausholen kann. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de480032/">https://habr.com/ru/post/de480032/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de480018/index.html">Mobile App-Entwicklung in Python. KivyMD-Bibliothek</a></li>
<li><a href="../de480022/index.html">Python-Instanziierung</a></li>
<li><a href="../de480024/index.html">Immergrün: Einzelanweisungsprozessor</a></li>
<li><a href="../de480026/index.html">Ankündigung der Vorschau von virtuellen Azure Spot-Maschinen</a></li>
<li><a href="../de480028/index.html">Die friedlichste Revolution</a></li>
<li><a href="../de480034/index.html">Habraiting 2019: Statistik und Ranking der Autoren für 2019</a></li>
<li><a href="../de480038/index.html">Bewegen Sie sich mit Xamarin.Forms 4.4</a></li>
<li><a href="../de480040/index.html">Was bedeutet es für die Rambler Group, Nginx und die Gründer zu treffen und wie wirkt es sich auf die Online-Branche aus?</a></li>
<li><a href="../de480042/index.html">Selbstständige und eigene Projekte. Nach Nginx</a></li>
<li><a href="../de480044/index.html">Ein zweites Jahr von Q #</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>