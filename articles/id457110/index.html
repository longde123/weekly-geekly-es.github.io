<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ‘©ğŸ¾â€ğŸ¤â€ğŸ‘¨ğŸ¼ ğŸ£ ğŸ‘©ğŸ¾â€ğŸ¤â€ğŸ‘©ğŸ½ Unit Pengujian Pola C ++ dan Injeksi Mock Menggunakan Sifat ğŸ•‹ ğŸ‘©â€ğŸ¨ ğŸ‘¨ğŸ¼â€ğŸš€</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Halo lagi! Kurang dari satu minggu yang tersisa sebelum dimulainya kelas dalam grup di kursus "Pengembang C ++" . Dalam hal ini, kami terus membagikan...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Unit Pengujian Pola C ++ dan Injeksi Mock Menggunakan Sifat</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/otus/blog/457110/">  Halo lagi!  Kurang dari satu minggu yang tersisa sebelum dimulainya kelas dalam grup di kursus <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">"Pengembang C ++"</a> .  Dalam hal ini, kami terus membagikan materi yang bermanfaat yang diterjemahkan secara khusus untuk siswa kursus ini. <br><br><img src="https://habrastorage.org/webt/sz/i0/sv/szi0svsyxbos9msuikvdds-vc44.png"><br><br>  Pengujian unit terhadap kode Anda dengan templat mengingatkan dirinya sendiri dari waktu ke waktu.  (Anda menguji templat Anda, bukan?) Beberapa templat mudah diuji.  Beberapa tidak.  Terkadang ada ketidakjelasan tentang implementasi kode-mock (stub) dalam templat yang diuji.  Saya telah mengamati beberapa alasan mengapa kode embedding menjadi rumit. <br><br>  Di bawah ini saya memberikan beberapa contoh dengan sekitar peningkatan kompleksitas implementasi kode. <br><a name="habracut"></a><br><ol><li>  Templat mengambil argumen tipe dan objek dengan tipe yang sama dengan referensi dalam konstruktor. </li><li>  Templat mengambil argumen tipe.  Membuat salinan argumen konstruktor atau tidak menerimanya. </li><li>  Templat mengambil argumen tipe dan membuat beberapa templat yang saling berhubungan tanpa fungsi virtual. </li></ol><br>  Mari kita mulai dengan yang sederhana. <br><br><h2>  Templat mengambil argumen tipe dan objek dengan tipe yang sama dengan referensi dalam konstruktor </h2><br>  Kasus ini tampaknya sederhana, karena unit test hanya membuat instance dari templat pengujian dengan tipe rintisan.  Beberapa pernyataan dapat diperiksa untuk kelas mock.  Dan itu saja. <br><br>  Secara alami, pengujian dengan hanya satu argumen jenis mengatakan apa-apa tentang sisa jumlah tak terbatas jenis yang dapat diteruskan ke templat.  Cara yang elegan untuk mengatakan hal yang sama: pola dihubungkan oleh penjumlahan umum, jadi kita mungkin harus menjadi sedikit lebih berwawasan untuk pengujian yang lebih ilmiah.  Lebih lanjut tentang ini nanti. <br><br>  Sebagai contoh: <br><br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TemplateUnderTest</span></span></span><span class="hljs-class"> {</span></span> T *t_; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: TemplateUnderTest(T *t) : t_(t) {} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SomeMethod</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ t-&gt;DoSomething(); t-&gt;DoSomeOtherThing(); } }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MockT</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DoSomething</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// Some assertions here. } void DoSomeOtherThing() { // Some more assertions here. } }; class UnitTest { void Test1() { MockT mock; TemplateUnderTest&lt;MockT&gt; test(&amp;mock); test.SomeMethod(); assert(DoSomethingWasCalled(mock)); assert(DoSomeOtherThingWasCalled(mock)); } };</span></span></code> </pre> <br><br><h2>  Templat mengambil argumen tipe.  Membuat salinan argumen konstruktor atau tidak menerimanya </h2><br>  Dalam hal ini, akses ke objek di dalam templat mungkin tidak dimungkinkan karena hak akses.  Anda bisa menggunakan kelas <code>friend</code> . <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TemplateUnderTest</span></span></span><span class="hljs-class"> {</span></span> T t_; <span class="hljs-keyword"><span class="hljs-keyword">friend</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UnitTest</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SomeMethod</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ t.DoSomething(); t.DoSomeOtherThing(); } }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UnitTest</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Test2</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ TemplateUnderTest&lt;MockT&gt; test; test.SomeMethod(); assert(DoSomethingWasCalled(test.t_)); <span class="hljs-comment"><span class="hljs-comment">// access guts assert(DoSomeOtherThingWasCalled(test.t_)); // access guts } };</span></span></code> </pre> <br>  <code>UnitTest :: Test2</code> memiliki akses ke badan TemplateUnderTest dan dapat memeriksa pernyataan pada salinan internal MockT. <br><br><h2>  Templat mengambil argumen tipe dan membuat beberapa templat yang saling berhubungan tanpa fungsi virtual </h2><br>  Untuk kasus ini, saya akan melihat contoh dunia nyata: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Asynchronous Google RPC</a> . <br><br>  Dalam C ++, async gRPC memiliki sesuatu yang disebut CallData, yang, seperti namanya, menyimpan <i>data yang terkait dengan panggilan RPC</i> .  Templat CallData dapat menangani beberapa jenis RPC yang berbeda.  Jadi wajar jika diimplementasikan dengan tepat oleh templat. <br><br>  CallData generik menerima dua jenis argumen: Permintaan dan Respons.  Ini bisa terlihat seperti ini: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Request</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Response</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CallData</span></span></span><span class="hljs-class"> {</span></span> grpc::ServerCompletionQueue *cq_; grpc::ServerContext context_; grpc::ServerAsyncResponseWriter&lt;Response&gt; responder_; <span class="hljs-comment"><span class="hljs-comment">// ... some more state public: using RequestType = Request; using ResponseType = Response; CallData(grpc::ServerCompletionQueue *q) : cq_(q), responder_(&amp;context_) {} void HandleRequest(Request *req); // application-specific code Response *GetResponse(); // application-specific code };</span></span></code> </pre> <br>  Tes unit untuk templat CallData harus memeriksa perilaku HandleRequest dan HandleResponse.  Fungsi-fungsi ini memanggil sejumlah fungsi anggota.  Oleh karena itu, memverifikasi kesehatan panggilan mereka sangat penting untuk kesehatan CallData.  Namun, ada triknya. <br><br><ol><li>  Beberapa jenis dari namespace grpc dibuat secara internal dan tidak melewati konstruktor.  <code>ServerAsyncResponseWriter</code> dan <code>ServerContext</code> , misalnya. </li><li>  <code>grpc :: ServerCompletionQueue</code> diteruskan ke konstruktor sebagai argumen, tetapi tidak memiliki fungsi virtual.  Hanya destruktor virtual. </li><li>  <code>grpc :: ServerContext</code> dibuat secara internal dan tidak memiliki fungsi virtual. </li></ol><br>  Pertanyaannya adalah bagaimana cara menguji CallData tanpa menggunakan gRPC penuh dalam tes?  Bagaimana cara mensimulasikan ServerCompletionQueue?  Bagaimana cara mensimulasikan ServerAsyncResponseWriter, yang merupakan templat?  dan seterusnya ... <br><br>  Tanpa fungsi virtual, mengganti perilaku pengguna menjadi tugas yang menakutkan.  Jenis hardcoded, seperti grpc :: ServerAsyncResponseWriter, tidak dapat dimodelkan karena mereka, hmm, hardcoded dan tidak diimplementasikan. <br><br>  Ada sedikit akal dalam menyampaikannya sebagai argumen konstruktor.  Bahkan jika Anda melakukan ini, itu mungkin tidak masuk akal, karena mereka mungkin kelas akhir atau tidak memiliki fungsi virtual. <br><br>  Jadi apa yang kita lakukan? <br><br><h2>  Solusi: Ciri-ciri </h2><br><img src="https://habrastorage.org/webt/1x/gi/42/1xgi42rvmoxkiksfd2wfxre8dne.png"><br><br>  Alih-alih menanamkan perilaku kustom dengan mewarisi dari tipe generik (seperti yang dilakukan dalam pemrograman berorientasi objek), INSERT THE TYPE.  Kami menggunakan sifat untuk ini.  Kami mengkhususkan diri dalam sifat-sifat dalam berbagai cara tergantung pada jenis kode itu: kode produksi atau kode pengujian unit. <br><br>  Pertimbangkan <code>CallDataTraits</code> <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CallData</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CallDataTraits</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> ServerCompletionQueue = grpc::ServerCompletionQueue; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> ServerContext = grpc::ServerContext; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> ServerAsyncResponseWriter = grpc::ServerAsyncResponseWrite&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> CallData::ResponseType&gt;; };</code> </pre> <br>  Ini adalah templat utama untuk sifat yang digunakan untuk kode produksi.  Mari kita gunakan dalam CallDatatemplate. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/// Unit testable CallData template &lt;class Request, class Response&gt; class CallData { typename CallDataTraits&lt;CallData&gt;::ServerCompletionQueue *cq_; typename CallDataTraits&lt;CallData&gt;::ServerContext context_; typename CallDataTraits&lt;CallData&gt;::ServerAsyncResponseWriter responder_; // ... some more state public: using RequestType = Request; using ResponseType = Response; CallData(typename CallDataTraits::ServerCompletionQueue *q) : cq_(q), responder_(&amp;context_) {} void HandleRequest(Request *req); // application-specific code Response *GetResponse(); // application-specific code };</span></span></code> </pre> <br>  Melihat kode di atas, jelas bahwa kode aplikasi masih menggunakan tipe dari namespace grpc.  Namun, kami dapat dengan mudah mengganti tipe grpc dengan tipe dummy.  Lihat di bawah. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/// In unit test code struct TestRequest{}; struct TestResponse{}; struct MockServerCompletionQueue{}; struct MockServerContext{}; struct MockServerAsyncResponseWriter{}; /// We want to unit test this type. using CallDataUnderTest = CallData&lt;TestRequest, TestResponse&gt;; /// A specialization of CallDataTraits for unit testing purposes only. template &lt;&gt; class CallDataTraits&lt;CallDataUnderTest&gt; { using ServerCompletionQueue = MockServerCompletionQueue; using ServerContext = MockServerContext; using ServerAsyncResponseWriter = MockServerAsyncResponseWrite; }; MockServerCompletionQueue mock_queue; CallDataUnderTest cdut(&amp;mock_queue); // Now injected with mock types.</span></span></code> </pre><br>  Ciri memungkinkan kita untuk memilih jenis yang diterapkan di CallData, tergantung pada situasinya.  Metode ini tidak memerlukan kinerja tambahan, karena tidak ada fungsi virtual yang tidak perlu dibuat untuk menambah fungsionalitas.  Teknik ini juga dapat digunakan di kelas akhir. <br><br>  Bagaimana Anda suka bahannya?  Tulis komentar.  Dan sampai jumpa di pintu terbuka ;-) </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id457110/">https://habr.com/ru/post/id457110/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id457098/index.html">Penanganan kesalahan JavaScript yang elegan dengan Either monad</a></li>
<li><a href="../id457100/index.html">AWS Lambda - Teori, Kenalan</a></li>
<li><a href="../id457102/index.html">File QVD - apa yang ada di dalamnya, bagian 3</a></li>
<li><a href="../id457106/index.html">Perang robo-panggilan AS - siapa yang menang dan mengapa</a></li>
<li><a href="../id457108/index.html">WWDC19: Memulai dengan Rencana Tes untuk XCTest</a></li>
<li><a href="../id457112/index.html">Hasil HolyJS 2019 Piter</a></li>
<li><a href="../id457114/index.html">Pilih sistem pengawasan video: cloud vs lokal dengan Internet</a></li>
<li><a href="../id457116/index.html">Fitur AvaloniaUI menggunakan MessageBox khusus</a></li>
<li><a href="../id457118/index.html">Habr Weekly # 6 / Runet siap berdiri terpisah, Adobe mencari jejak Photoshop, kerentanan Vim, geo-chat di Keranjang dan sesuatu yang lain</a></li>
<li><a href="../id457120/index.html">Apa yang biasa terjadi antara mengupas telur dan DevOps?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>