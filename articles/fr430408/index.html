<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🏽 🗾 🐹 Nous vérifions la vulnérabilité fermée et obtenons quatre nouveaux CVE 💰 🐎 🉑</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="On m'a demandé de continuer la série d'articles sur la fermeture des vulnérabilités et sur la façon dont elles sont fermées (notre premier article peu...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Nous vérifions la vulnérabilité fermée et obtenons quatre nouveaux CVE</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/acribia/blog/430408/">  On m'a demandé de continuer la série d'articles sur la fermeture des vulnérabilités et sur la façon dont elles sont fermées (notre premier article peut être lu <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> ).  La dernière fois, nous avons découvert que même si le fabricant signale la fermeture de la vulnérabilité, alors en réalité, tout pourrait ne pas l'être. <br><br><img src="https://habrastorage.org/webt/me/ds/nj/medsnjr0lbtdxy9vots_csy_bbg.jpeg"><br><a name="habracut"></a><br><h3>  Critères de sélection: </h3><br>  Les critères de sélection pour les vulnérabilités considérées cette fois étaient les mêmes (à l'exception que cette fois, je voulais examiner d'autres types de vulnérabilités): <br><br><ul><li>  il devrait y avoir un exploit - nous voulons voir qu'avant la mise à jour, tout était <s>bien</s> mal <s>exploité</s> , et après cela il est devenu bon; </li><li>  la vulnérabilité doit être critique (idéalement RCE) et avoir un score élevé; </li><li>  le produit doit être open source; </li><li>  le produit ne doit pas être abandonné et utilisé activement; </li><li>  la vulnérabilité devrait être relativement nouvelle; </li><li>  comme toujours, l'essentiel est que nous-mêmes nous intéressions. </li></ul><br><h3>  Quoi et comment j'ai choisi: </h3><br>  Je suis allé sur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">vulners.com</a> et <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">j'ai</a> demandé à montrer tous les exploits avec <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">exploit-db.com</a> au cours des deux dernières semaines.  Cette fois dans la catégorie Web, presque tous les exploits ont été créés par Ihsan Sencan, mais en raison du fait qu'ils concernent le plus souvent des injections SQL dans de vieilles applications et plugins non pris en charge, je les ai supprimés.  Parmi les produits restants, seul l'outil de gestion de projet ProjeQtOr 7.2.5 avec la vulnérabilité CVE-2018-18924 est entré dans la catégorie «non abandonné et en développement actif». <br>  Cette vulnérabilité répondait à tous les critères de sélection: <br><br><ul><li>  il y a un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">exploit</a> ; </li><li>  Vulnérabilité RCE (bien qu'elle nécessite l'autorisation de l'utilisateur); </li><li>  le produit est assez open source; </li><li> le produit n'est pas abandonné, en 2018 il y avait 28 versions et seulement sourceforge.net il y avait 702 téléchargements (et la plupart des téléchargements de mise à jour résolvent le problème CVE, ce qui indique très probablement que les gens ont vu CVE et ont commencé à mettre à jour); </li><li>  CVE du 4 novembre, un exploit du 25 octobre, cela répond aux exigences de nouveauté; </li><li>  J'ai regardé le problème et sa solution, je me suis intéressé (plus à ce sujet plus tard). </li></ul><br><h4>  Comprendre l'outil de gestion de projet ProjeQtOr </h4><br>  Nous lisons la description de l' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">exploit</a> et la description <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">CVE sur nist.gov</a> , nous comprenons que la version 7.2.5 n'est vulnérable que pour un utilisateur autorisé.  Et aussi que vous pouvez télécharger un fichier .shtml en tant qu'image, bien que le message d'erreur <i>"Ce fichier n'est pas une image valide"</i> sera affiché, mais le fichier sera toujours enregistré dans les images sur le serveur et accessible via un lien direct dans l' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">hôte / fichiers / images / nom_image</a> . <br><br><img src="https://habrastorage.org/webt/8d/wu/0x/8dwu0x1uezs-x_ws7egw9szchue.png"><br><br>  L'accès via un lien direct est bon, mais ici vous devez encore deviner le nom avec lequel le fichier sera téléchargé.  Nous avons de la chance, et ce n'est pas aléatoire, mais il est généré à partir de l'heure actuelle au format: année, mois, jour, heures, minutes, secondes.  Le résultat est un tel numéro 20181114140320. Ensuite, l'ID utilisateur, puis le nom de fichier d'origine passent par le trait de soulignement.  Il y a pas mal d'inconnues: <br><br><ul><li>  Fuseau horaire sur le serveur </li><li>  si l'horloge du serveur est en panne; </li><li>  ID utilisateur </li></ul><br>  Et encore une fois, nous avons de la chance: si vous téléchargez une image valide, tous ces paramètres nous seront signalés.  Il n'est pas difficile de passer en revue plusieurs options de liens (plusieurs, car il y a des secondes, mais il est difficile de les entrer tout de suite). <br><br><img src="https://habrastorage.org/webt/zq/ce/lh/zqcelhvlhrk7496dafoiqart2nk.png"><br><br>  En général, l'obtention du nom de fichier n'est pas un problème.  Nous continuons.  Et nous pensons, pourquoi ne pas simplement télécharger un script php?  Nous essayons de le télécharger, la même fenêtre apparaît, mais le fichier n'apparaît pas dans le répertoire.  Il est temps de regarder le code! <br><br>  Le script uploadImage.php est responsable du téléchargement de l'image sur le serveur dans la version 7.2.5. Nous sommes intéressés par les lignes 100 à 117. <br><br><pre><code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (substr($ext,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>)==<span class="hljs-string"><span class="hljs-string">'php'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> substr($ext,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">4</span></span>)==<span class="hljs-string"><span class="hljs-string">'phtm'</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(@!getimagesize($uploadedFile[<span class="hljs-string"><span class="hljs-string">'tmp_name'</span></span>])) { $error=i18n(<span class="hljs-string"><span class="hljs-string">'errorNotAnImage'</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { traceHack(<span class="hljs-string"><span class="hljs-string">"Try to upload php file as image in CKEditor"</span></span>); } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( ! move_uploaded_file($uploadedFile[<span class="hljs-string"><span class="hljs-string">'tmp_name'</span></span>], $uploadfile)) { $error = htmlGetErrorMessage(i18n(<span class="hljs-string"><span class="hljs-string">'errorUploadFile'</span></span>,<span class="hljs-string"><span class="hljs-string">'hacking ?'</span></span>)); errorLog(i18n(<span class="hljs-string"><span class="hljs-string">'errorUploadFile'</span></span>,<span class="hljs-string"><span class="hljs-string">'hacking ?'</span></span>)); } } } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!$error) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(@!getimagesize($uploadfile)) { $error=i18n(<span class="hljs-string"><span class="hljs-string">'errorNotAnImage'</span></span>); } }</code> </pre> <br>  La ligne 100 est chargée de vérifier l'extension du fichier: s'il s'agit de php ou phtm, le fichier est rejeté et non enregistré.  Par conséquent, les fichiers php n'apparaissent pas dans le répertoire "files / images /".  La ligne 115 crée l'erreur que nous voyons, mais ne fait rien avec le fichier. <br><br>  Eh bien, ne quittons pas l'exploit et téléchargeons le fichier avec l'extension .shtml.  Ici, il vaut la peine de faire une petite digression et de dire ce qu'est le .shtml et avec quoi il est mangé. <br><br><h4>  SHTML et SSI </h4><br>  Définition Wikipédia: <br><br>  SSI (Server Side includes - inclusion côté serveur) - un langage simple pour l '"assemblage" dynamique de pages Web sur le serveur à partir des composants individuels et la livraison du document HTML reçu au client.  Implémenté dans le serveur Web Apache à l'aide du module mod_include.  La fonctionnalité incluse dans les paramètres par défaut du serveur Web vous permet d'inclure des fichiers HTML, par conséquent, pour utiliser les instructions, le fichier doit se terminer par l'extension .shtml, .stm ou .shtm. <br><br>  Dans vos propres mots: <br><br>  SHTML est du HTML qui peut exécuter des jeux d'instructions côté serveur.  De l'utile, il y a une fonction exec qui exécute des commandes arbitraires sur le serveur (oui, nous pouvons télécharger le fichier en utilisant le code HTML et l'exécuter). <br><br>  Voici un exemple de code pour exécuter du code arbitraire: <br><br><pre> <code class="php hljs">&lt;!--<span class="hljs-comment"><span class="hljs-comment">#exec cmd=”ls” --&gt;</span></span></code> </pre> <br>  La bonne nouvelle est que cette fonctionnalité n'est pas activée par défaut sur le serveur Apache2, et pour l'activer, vous devez danser avec un tambourin.  En quelques heures de sélection de la configuration, j'ai pu faire fonctionner le retour des variables d'environnement, mais pas la commande.  Voici mon code SSI: <br><br><pre> <code class="php hljs">&lt;html&gt; &lt;head&gt; &lt;title&gt;thegeekstuff.com&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;p&gt; Today is &lt;!--<span class="hljs-comment"><span class="hljs-comment">#echo var="DATE_LOCAL" --&gt; &lt;!--#exec cmd="ls" --&gt; &lt;/p&gt; &lt;/body&gt; &lt;/html&gt;  : Today is Wednesday, 14-Nov-2018 17:29:14 MSK [an error occurred while processing this directive]</span></span></code> </pre><br>  Si quelqu'un vous dit quoi écrire dans la config pour qu'elle fonctionne correctement, j'adorerais la lire. <br><br><h4>  Exploiter la vulnérabilité </h4><br>  Si les étoiles convergent, vous pouvez télécharger le fichier shtml et exécuter des commandes arbitraires (ou, comme moi, voir l'heure sur le serveur). <br><br><h4>  Regarder le patch </h4><br>  La prochaine version est 7.2.6, mais il n'y a pas de changement concernant la vulnérabilité qui nous intéresse (nist.gov trompé à nouveau). <br><br>  Nous regardons la version 7.2.7 et il semble que tout soit corrigé (les développeurs eux-mêmes disent que tout est corrigé juste dans cette version).  Il y a deux changements clés: <br><br>  1. Parmi les extensions interdites, "shtm" a été ajouté (si les 4 premiers caractères sont tels, shtml tombe également ici): <br><br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (substr($ext,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>)==<span class="hljs-string"><span class="hljs-string">'php'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> substr($ext,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">4</span></span>)==<span class="hljs-string"><span class="hljs-string">'phtm'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> substr($ext,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">4</span></span>)==<span class="hljs-string"><span class="hljs-string">'shtm'</span></span>) {</code> </pre> <br><br>  2. Les fichiers qui ne sont pas des images sont maintenant supprimés: <br><br><pre> <code class="php hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(@!getimagesize($uploadfile)) { $error=i18n(<span class="hljs-string"><span class="hljs-string">'errorNotAnImage'</span></span>); kill($uploadfile); }</code> </pre> <br>  Il semblerait que vous pouvez diverger, car les non-images sont supprimées et shtml n'essaie même pas de persister.  Mais je n’aimais pas toujours s’ils essayaient de résoudre un problème avec les listes noires.  Par exemple, dans certains pays, les entreprises interdisent les réseaux sociaux.  Cela conduit au fait que les utilisateurs commencent à utiliser les «miroirs» des réseaux sociaux, où leurs noms d'utilisateur et mots de passe sont volés.  Leurs mots de passe coïncident avec les mots de passe d'entreprise, mais il peut alors y avoir des problèmes bien plus importants qu'un employé feuilletant un instagram autour d'une tasse de café. <br><br>  Dans la programmation Web et sa sécurité, les listes noires sont également mauvaises. <br><br><h4>  Contournez la liste noire de ProjeQtOr </h4><br>  Eh bien, tout est simple.  Tout d'abord, voyons quels fichiers Apache2 + PHP peut interpréter avec les paramètres par défaut (tout a été installé sur Ubuntu 16.04 avec un référentiel mis à jour).  La directive «FilesMatch» est responsable de la capacité d'interpréter les fichiers.  Nous effectuons une recherche avec la commande "grep -r" &lt;FilesMatch "/ etc / apache2" et voici le résultat: <br><br><pre> <code class="php hljs">/etc/apache2/mods-available/php7<span class="hljs-number"><span class="hljs-number">.0</span></span>.conf:&lt;FilesMatch <span class="hljs-string"><span class="hljs-string">".+\.ph(p[3457]?|t|tml)$"</span></span>&gt; /etc/apache2/mods-available/php7<span class="hljs-number"><span class="hljs-number">.0</span></span>.conf:&lt;FilesMatch <span class="hljs-string"><span class="hljs-string">".+\.phps$"</span></span>&gt; /etc/apache2/mods-available/php7<span class="hljs-number"><span class="hljs-number">.0</span></span>.conf:&lt;FilesMatch <span class="hljs-string"><span class="hljs-string">"^\.ph(p[3457]?|t|tml|ps)$"</span></span>&gt; /etc/apache2/sites-available/<span class="hljs-keyword"><span class="hljs-keyword">default</span></span>-ssl.conf: &lt;FilesMatch <span class="hljs-string"><span class="hljs-string">"\.(cgi|shtml|phtml|php)$"</span></span>&gt; /etc/apache2/apache2.conf:&lt;FilesMatch <span class="hljs-string"><span class="hljs-string">"^\.ht"</span></span>&gt;</code> </pre> <br>  Dans la configuration default-ssl.conf, toutes les extensions sont simplement listées dans leur intégralité; ce sont: cgi, shtml, phtml, php.  Hélas, tout sauf cgi est filtré dans ProjeQtOr. <br><br>  La configuration php7.0.conf est beaucoup plus intéressante, les extensions y sont définies par l'expression régulière.  Nous obtenons: <br><table><tbody><tr><th>  Extension </th><th>  Ce qui est filtré </th></tr><tr><td>  php </td><td>  substr ($ ext, 0,3) == 'php' </td></tr><tr><td>  php3 </td><td>  substr ($ ext, 0,3) == 'php' </td></tr><tr><td>  php4 </td><td>  substr ($ ext, 0,3) == 'php' </td></tr><tr><td>  php5 </td><td>  substr ($ ext, 0,3) == 'php' </td></tr><tr><td>  php7 </td><td>  substr ($ ext, 0,3) == 'php' </td></tr><tr><td>  pht </td><td>  RIEN </td></tr><tr><td>  phtml3 </td><td>  substr ($ ext, 0.4) == 'phtm' </td></tr></tbody></table><br>  Génial, une extension de fichier non filtrée est trouvée.  Nous vérifions qu'il est vraiment interprété. <br><br>  Créez un fichier test.pht avec le contenu suivant: <br><br><pre> <code class="php hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?php</span></span> phpinfo();</code> </pre> <br>  Nous allons à ce fichier dans le navigateur et voyons des informations sur le php installé.  Remarquablement, la liste noire a été contournée, tandis que pour les paramètres non par défaut, pour une raison quelconque, d'autres extensions d'interprétation pourraient être autorisées. <br><br>  Nous chargeons notre fichier de test dans l'outil de gestion de projet ProjeQtOr.  Bien sûr, nous obtenons une erreur, car ce n'est pas une image (dans la version antérieure à 7.2.7, nous avons déjà l'exécution de code sur le serveur, car changer phpinfo en exécutant des commandes n'est pas difficile).  Dans la version 7.2.7, le fichier est supprimé et le code n'est pas exécuté. <br><br>  Mais nous ne sommes pas fâchés et ne contournons pas le contrôle de l'image. <br><br><h4>  Image PHP </h4><br>  La vérification si le fichier téléchargé est une image dans l'outil de gestion de projet ProjeQtOr est effectuée par la fonction getimagesize, qui regarde simplement l'en-tête du fichier transféré. <br><br>  Profitant du fait qu'il peut y avoir des ordures dans le fichier php et que l'interprétation du code php ne commence qu'avec les caractères «&lt;? Php», nous écrivons un petit code qui écrit d'abord l'image, puis le code php dont nous avons besoin.  Comme image, nous enverrons une capture d'écran de la fenêtre d'erreur.  3 lignes de code python et vous avez terminé: <br><br><pre> <code class="python hljs">data = open (<span class="hljs-string"><span class="hljs-string">'test.png'</span></span>,<span class="hljs-string"><span class="hljs-string">'rb'</span></span>).read() data += open (<span class="hljs-string"><span class="hljs-string">'test.pht'</span></span>,<span class="hljs-string"><span class="hljs-string">'rb'</span></span>).read() open (<span class="hljs-string"><span class="hljs-string">'new_pht_png.pht'</span></span>,<span class="hljs-string"><span class="hljs-string">'wb'</span></span>).write(data)</code> </pre> <br>  Vous pourriez probablement écrire un en-tête d'image valide au début du fichier, mais c'est plus facile, et plus encore, l'image est affichée dans tous les visualiseurs. <br><br>  Nous téléchargeons cette création sur le serveur et, voilà, elle est chargée (et affichée dans la visionneuse sous forme d'image), et il est également agréable de voir le nom complet avec lequel ce fichier a été téléchargé. <br><br><img src="https://habrastorage.org/webt/xi/px/mh/xipxmhyuzvcaqbxl28pcrrezd1q.png"><br><br>  Nous allons dans le fichier téléchargé <a href="">localhost / files / images / 20181114171730_1_new_pht_png.pht</a> et voyons l'image téléchargée sous forme de texte, et la sortie phpinfo en dessous.  Il est clair que remplacer phpinfo par un simple shell web n'est pas difficile.  Par exemple, ceci: &lt;? Php system ($ _ GET ['cmd']); <br><br><img src="https://habrastorage.org/webt/m-/kv/ad/m-kvadznv4ev99yge_zwwsgzf6m.png"><br><br>  Une fois que vous avez commencé à sélectionner les téléchargements de fichiers, vous devez terminer le travail et voir où il y a d'autre téléchargement de fichiers avec ou sans listes noires. <br><br><h4>  Un autre téléchargement de fichier </h4><br>  Nous regarderons dans la dernière version disponible.  En supposant que vous utilisez la même fonction pour télécharger des fichiers comme auparavant, c'est-à-dire  move_uploaded_file, nous le recherchons dans le répertoire du projet "grep -r" move_uploaded_file "./".  Nous obtenons les 5 fichiers suivants: <br><br>  ./tool/uploadImage.php <br>  ./tool/saveDocumentVersion.php <br>  ./tool/uploadPlugin.php <br>  ./tool/import.php <br>  ./tool/saveAttachment.php <br><br>  File uploadImage.php - déjà regardé. <br>  File saveDocumentVersion.php - télécharge les versions des documents (comme son nom l'indique).  Nous essayons de télécharger un document et de le regarder (pour commencer, nous chargerons toujours une image).  Après le téléchargement, nous voyons que l'extension .1 est ajoutée au fichier.  Nous regardons dans le code comment le nom est obtenu (cela se fait à la ligne 229): <br><br><pre> <code class="php hljs">$uploadfile = $dv-&gt;getUploadFileName();</code> </pre> <br>  La fonction getUploadFileName est déclarée dans le fichier DocumentVersionMain.php.  Là, à la ligne 227, nous voyons que «.» Est ajouté au nom renvoyé.  et l'ID du document.  Nous ne pouvons pas contourner même le point ajouté: <br><br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> $uploaddir . $paramPathSeparator . $fileName . <span class="hljs-string"><span class="hljs-string">'.'</span></span> . <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;id;</code> </pre> <br>  Le fichier uploadPlugin.php n'est accessible qu'aux administrateurs et le fait que le plugin puisse avoir un mauvais code est très logique et difficile à éliminer sans avoir à entrer la validation du plugin (comme le font les CMS populaires).  Bien sûr, lorsque vous essayez de télécharger quelque chose, il se charge avec succès, puis il est exécuté. <br><br>  Le fichier import.php n'est également disponible que pour les administrateurs.  Lors du téléchargement d'un fichier, on nous dit qu'il doit s'agir d'un fichier csv ou d'un fichier xlsx.  Bien sûr, nous essayons de charger le fichier php et voyons une erreur: <br><br><h4>  ERREUR - Le type de fichier fourni et le format de fichier sélectionné ne correspondent pas </h4><br>  Importation abandonnée <br><br>  Le problème est que, comme dans le bogue d'origine de CVE, le fichier n'est pas supprimé, mais reste disponible dans <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">localhost / files / attach / import / test.php</a> . <br><br>  Le fichier saveAttachment est utilisé lors du chargement de pièces jointes (par exemple, lors du chargement de votre propre image).  Le script PHP n'y rampe pas, car il y a une protection du formulaire: <br><br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (substr($ext,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>)==<span class="hljs-string"><span class="hljs-string">'php'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> substr($ext,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">4</span></span>)==<span class="hljs-string"><span class="hljs-string">'phtm'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> substr($ext,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">4</span></span>)==<span class="hljs-string"><span class="hljs-string">'shtm'</span></span>) { $attachment→fileName.=<span class="hljs-string"><span class="hljs-string">".projeqtor"</span></span>;</code> </pre> <br>  il s'avère que les fichiers d'extension php *, phtm *, shtm * l'extension ".projeqtor" est ajoutée, c'est-à-dire, évidemment notre fichier pht y rampera (même sans explorer les images).  Nous essayons, et nous obtenons tout à l'adresse <a href="">localhost / files / attach / attachment_1 / test.pht</a> . <br><br>  Résultat total de cinq emplacements de téléchargement de fichiers rapidement trouvés: <br><br><ul><li>  réussi à charger le script php ou pht 4 fois; </li><li>  la validation de la liste noire est en deux; </li><li>  la validation de la liste blanche n'est nulle part; </li><li>  une fois n'a pas réussi à télécharger le fichier (n'a pas pu télécharger, mais n'a pas pu s'exécuter), car  l'expansion changeait </li></ul><br><h3>  Conclusions sur l'outil de gestion de projet ProjeQtOr et CVE-2018-18924 </h3><br><br><ul><li>  la vulnérabilité signalée a été pratiquement éliminée; </li><li>  il existe d'autres vulnérabilités dans le code (signalées aux développeurs, et ils ont même promis des listes blanches d'extensions); </li><li>  une configuration correcte du serveur Apache2 pourrait nous sauver de tout (limiter les formats exécutables aux seuls nécessaires, interdire l'exécution de scripts dans les dossiers utilisateurs); </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">nist.gov</a> ne <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">contient</a> pas la dernière version vulnérable. </li></ul><br><h3>  Note de maîtresse </h3><br><ul><li>  refuser les listes noires dans la mesure du possible (je ne sais pas où cela est impossible); </li><li>  soyez prudent et attentif lors du traitement des fichiers téléchargés (il vaut mieux qu'ils soient au même endroit, et non répartis par 5); </li><li>  un serveur Web correctement configuré évite de nombreux problèmes dans le code du projet (il est important d'écrire du code et de bien configurer le serveur). </li></ul><br><h3>  Réponse détaillée des développeurs </h3><br>  La première réponse des développeurs était quelque chose comme «nous avons tout corrigé, alors voyez le code corrigé».  J'ai dû peindre en détail où se trouvent certains problèmes et comment ils peuvent être exploités. <br><br>  Il a ensuite reçu une réponse détaillée: «oui, il y a des problèmes, et ils seront corrigés dans la version 7.3.0.  Des listes blanches seront également ajoutées pour les images à la fois pour xlslx et csv. »  Ils ont également écrit qu'ils avaient recommandé d'ajouter les répertoires «pièces jointes» et «documents» en dehors de l'accès Web dans les instructions d'installation. <br><br>  Les développeurs m'ont permis d'enregistrer CVE et d'écrire un article après la mise à jour (qui est sorti et est disponible en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">téléchargement</a> ). <br><br><h3>  Conclusion </h3><br>  Comme je l'ai écrit au début, pas mal de gens ont téléchargé la mise à jour décidant CVE (plus de 500 téléchargements), et c'est cool que les gens mettent à jour leur logiciel vulnérable, mais c'est triste que le logiciel reste vulnérable. <br><br>  En conséquence, quatre CVE m'ont été attribués ainsi qu'à notre entreprise: CVE-2018-19307, CVE-2018-19308, CVE-2018-19309, CVE-2018-19310. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr430408/">https://habr.com/ru/post/fr430408/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr430398/index.html">Comment comprendre que vous n'êtes pas le bienvenu ou discuter des méthodes de retrait des travailleurs de l'entreprise</a></li>
<li><a href="../fr430400/index.html">Expérience de l'utilisation d'un hybride clavier et souris dans la programmation</a></li>
<li><a href="../fr430402/index.html">Qu'est-ce que developer.android.com ne dit rien sur RecyclerView?</a></li>
<li><a href="../fr430404/index.html">Nous collectons des données sur le comportement des clients sur le site</a></li>
<li><a href="../fr430406/index.html">C ++ 20 et modules, mise en réseau, coroutines, gammes, graphiques. Résultats de la réunion à San Diego</a></li>
<li><a href="../fr430410/index.html">«Il faudra toujours se développer»: un entretien avec Evgeny Kuvshinov (ManyChat) sur le développement dans une startup</a></li>
<li><a href="../fr430412/index.html">Logique floue contre PID. Nous croisons le hérisson et le serpent. Moteur d'aéronef et algorithmes de contrôle des centrales nucléaires</a></li>
<li><a href="../fr430414/index.html">Azure DevOps pour Commodore 64?</a></li>
<li><a href="../fr430418/index.html">Expérience personnelle en utilisant des capteurs de proximité en développement</a></li>
<li><a href="../fr430420/index.html">Conférence "Contenu" - désormais avec prise en charge de l'hyper-threading</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>