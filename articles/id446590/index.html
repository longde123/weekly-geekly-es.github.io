<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>☝🏽 🍨 🧡 39 fitur baru akan tersedia di Java 12 🏊 👀 👩‍🔧</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dari wawancara yang luar biasa tentang Habré: “Simon Ritter adalah orang yang bekerja di Jawa sejak awal dan terus melakukan ini sebagai wakil direktu...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>39 fitur baru akan tersedia di Java 12</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/446590/"><blockquote>  Dari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">wawancara yang luar biasa</a> tentang Habré: “Simon Ritter adalah orang yang bekerja di Jawa sejak awal dan terus melakukan ini sebagai wakil direktur teknis Azul, sebuah perusahaan yang bekerja pada mesin virtual Zing JVM dan salah satu pengumpul sampah terbaik, C4 (Continuously Concurrent Compacting) Kolektor) » <br>  Di bawah ini adalah terjemahan dari artikelnya tentang fitur JDK 12 baru dan beberapa kesulitan yang mungkin Anda temui ketika bermigrasi ke bangunan baru. </blockquote><p> Saya menulis beberapa posting blog yang mencantumkan semua perubahan untuk setiap rilis Java terbaru ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">JDK 10</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">JDK 11</a> ).  Sekarang saya akan menjelajahi sisi gelap JDK 12, berfokus pada beberapa jebakan yang dapat menyebabkan masalah jika Anda ingin port aplikasi ke versi ini. </p><br><img src="https://habrastorage.org/webt/0e/rn/j0/0ernj0wwnqnwdejls6zvzjup5k8.png"><br><p><a name="habracut"></a>  JDK 12 memiliki jumlah fitur baru terkecil dari semua rilis Java hingga saat ini (saya menghitung 109 di JDK 10 dan 90 di JDK 11).  Ini tidak buruk - karena siklus rilis, beberapa versi akan berisi lebih banyak perubahan, dan beberapa lagi kurang. </p><br><p>  Saya akan memecah fungsi baru menjadi area logis yang jelas: Java, libraries, JVM, dan fungsi JDK lainnya. </p><br><h2>  Perubahan Bahasa </h2><br><p>  Fungsi yang saya (dan saya berasumsi bahwa banyak orang lain) akan mempertimbangkan yang paling terlihat di JDK 12 adalah pernyataan switch baru ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">JEP 325</a> ).  Ini juga merupakan perubahan bahasa pertama yang digunakan sebagai fungsi untuk "melihat dulu".  Gagasan "previewing" diperkenalkan pada awal 2018 sebagai bagian dari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">JEP 12</a> .  Ini pada dasarnya adalah cara untuk mengaktifkan versi beta dari fitur baru menggunakan opsi baris perintah.  Menggunakan pratinjau, masih dimungkinkan untuk membuat perubahan berdasarkan umpan balik pengguna, dan dalam kasus terburuk, sepenuhnya menghapus fungsi jika tidak diterima dengan benar.  Kunci untuk fungsi pratinjau adalah bahwa mereka tidak termasuk dalam spesifikasi Java SE.  Tentang peralihan baru ada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">terjemahan yang sangat bagus</a> tentang Habré. <br>  Dalam JDK 12, sebuah saklar telah menjadi ekspresi yang mengevaluasi "konten" untuk menghasilkan suatu hasil.  Saya akan segera menjelaskan bahwa ini tidak memengaruhi kompatibilitas ke belakang, jadi Anda tidak perlu mengubah kode apa pun yang menggunakan sakelar sebagai operator. </p><br><p>  Saya akan menggunakan contoh dari JEP, karena sederhana dan jelas: </p><br><div class="spoiler">  <b class="spoiler_title">Saklar lama</b> <div class="spoiler_text"><pre><code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> numLetters; <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (day) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> MONDAY: <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> FRIDAY: <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> SUNDAY: numLetters = <span class="hljs-number"><span class="hljs-number">6</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> TUESDAY: numLetters = <span class="hljs-number"><span class="hljs-number">7</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> THURSDAY: <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> SATURDAY: numLetters = <span class="hljs-number"><span class="hljs-number">8</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> WEDNESDAY: numLetters = <span class="hljs-number"><span class="hljs-number">9</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> IllegalStateException(<span class="hljs-string"><span class="hljs-string">"Huh? "</span></span> + day); }</code> </pre> </div></div><br><p>  Seperti yang Anda lihat, kami memetakan hari dalam seminggu dengan nama <code>day</code> variabel, kemudian menetapkan <code>numLetters</code> nilai.  Sekarang switch adalah operator, kita dapat melakukan penugasan sekali (secara signifikan mengurangi kemungkinan kode yang salah) menggunakan hasil dari pernyataan switch: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> numLetters = <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (day) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> MONDAY, FRIDAY, SUNDAY -&gt; <span class="hljs-number"><span class="hljs-number">6</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> TUESDAY -&gt; <span class="hljs-number"><span class="hljs-number">7</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> THURSDAY, SATURDAY -&gt; <span class="hljs-number"><span class="hljs-number">8</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> WEDNESDAY -&gt; <span class="hljs-number"><span class="hljs-number">9</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> -&gt; <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> IllegalStateException(<span class="hljs-string"><span class="hljs-string">"Huh? "</span></span> + day); };</code> </pre> <br><p>  Anda akan segera melihat dua perubahan sintaks.  Pengembang OpenJDK menemukan fungsi sintaksis yang tidak dikenal yang disebut daftar yang dipisahkan koma.  Juga operator ekspresi lambda <code>-&gt;</code> membuat mengembalikan nilai lebih mudah.  Anda masih dapat menggunakan <code>break</code> dengan sebuah nilai jika Anda benar-benar menginginkannya.  Ada beberapa detail lain tentang fitur ini, tetapi mungkin lebih mudah untuk membaca JEP. </p><br><h2>  Perpustakaan </h2><br><p>  Ada satu perubahan yang menurut saya sangat berguna.  Ada juga sejumlah yang sekunder. </p><br><h3>  kolektor teeing </h3><br><p>  Streams API, seperti biasa, memiliki Kolektor baru, yang disediakan oleh kelas utilitas Kolektor.  Seorang kolektor baru dapat diperoleh dengan menggunakan metode <code>teeing()</code> .  Kolektor teeing mengambil tiga argumen: dua kolektor dan bifungsi.  Untuk memahami karya kolektor ini, saya merekomendasikan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">artikel ini tentang Habré</a> . <br>  Untuk memahami bagaimana dia melakukan ini, saya menggambar diagram: </p><br><img src="https://habrastorage.org/getpro/habr/post_images/821/2db/503/8212db5034c04db49aed57dd44697b22.jpg" alt="gambar"><br><p>  Semua nilai dari aliran input diteruskan ke setiap kolektor.  Hasil dari setiap kolektor dilewatkan sebagai argumen untuk BiFunction untuk dan menghasilkan hasil akhir. </p><br><p>  Contoh sederhana menghitung nilai rata-rata (ya, saya tahu bahwa sudah ada kolektor untuk ini, seperti <code>averagingInt()</code> , tetapi ini adalah contoh sederhana untuk membantu memahami konsep). </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">/* Assume Collectors is statically imported */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> average = Stream.of(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">7</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>) .collect(teeing( summingDouble(i -&gt; i), counting(), (sum, n) -&gt; sum / n) );</code> </pre> <br><p>  Kolektor pertama menghitung jumlah aliran input, dan yang kedua - jumlah elemen.  BiFunction membagi jumlah dengan jumlah elemen untuk mendapatkan nilai rata-rata. </p><br><h3>  java.io </h3><br><p>  <code>InputStream skipNBytes(long n)</code> - melompati dan membuang dengan tepat n byte dari aliran input InputStream.  Jika n nol atau kurang, byte tidak dilewati. </p><br><h3>  java.lang </h3><br><p>  Paket baru telah muncul, java.lang.constant, yang merupakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">bagian dari JVM API konstan, JEP 334</a> . </p><br><p>  Setiap file kelas Java memiliki kumpulan persisten yang menyimpan operan untuk instruksi bytecode di kelas.  Sulit bagi pengembang untuk memanipulasi file kelas karena masalah memuat kelas.  Konstanta JVM API menyediakan tipe referensi simbolis untuk menggambarkan setiap bentuk konstanta (kelas, konstanta yang dapat dimuat, <code>MethodHandle</code> , konstanta <code>MethodType</code> , konstanta <code>MethodType</code> ). </p><br><p>  Ini juga memengaruhi beberapa kelas lainnya.  Semua kelas berikut sekarang memiliki metode <code>describeConstable()</code> : </p><br><ul><li>  Kelas </li><li>  Dobel </li><li>  Enum </li><li>  Mengapung </li><li>  Integer </li><li>  Panjang </li><li>  Tali </li><li>  Menangani metode </li><li>  Tipe Metode </li><li>  Varhandle </li></ul><br><p>  Sebagai orang Inggris, saya menganggapnya lucu.  Istilah Constable, <code>describeConstable</code> digunakan sejak abad ke-11, dan itulah yang sering kita sebut sebagai petugas polisi.  Itu juga nama seniman abad ke-18 yang terkenal, John Constable.  Ini membuat saya bertanya-tanya apakah metode <code>describeTurner()</code> akan ada di versi yang akan datang.  Jelas, dalam hal ini merupakan singkatan dari <code>Constant Table</code> , tidak terkait dengan petugas hukum atau pelukis lanskap. </p><br><p>  Kelas-kelas berikut sekarang termasuk metode <code>resolveConstantDesc()</code> : </p><br><ul><li>  Dobel </li><li>  Enum.EnumDesc </li><li>  Mengapung </li><li>  Integer </li><li>  Panjang </li><li>  Tali </li></ul><br><h3>  java.lang.Character </h3><br><p>  Kelas dalam telah diperbarui untuk menyertakan blok Unicode baru.  Saya selalu suka melihat apa yang ditemukan orang untuk ditambahkan ke Unicode, berikut adalah beberapa contoh: </p><br><ul><li>  Simbol catur </li><li>  Angka Maya </li><li>  Sogdian adalah bahasa Iran timur yang tidak lagi digunakan pada abad ke-11. </li><li>  Sogdian Lama adalah versi Sogdian yang lebih lama (dan, saya kira, bahkan lebih terbatas) </li></ul><br><h3>  java.lang.Class </h3><br><p>  <code>arrayType()</code> mengembalikan <code>Class</code> untuk jenis array yang tipe komponennya dijelaskan oleh <code>Class</code> ini.  Ini dapat diverifikasi menggunakan <code>jshell</code> : </p><br><pre> <code class="bash hljs">jshell&gt; (new String[2]).getClass().getName() <span class="hljs-variable"><span class="hljs-variable">$11</span></span> ==&gt; <span class="hljs-string"><span class="hljs-string">"[Ljava.lang.String;"</span></span> jshell&gt; (new String[2]).getClass().arrayType() <span class="hljs-variable"><span class="hljs-variable">$12</span></span> ==&gt; class [[Ljava.lang.String; jshell&gt; <span class="hljs-string"><span class="hljs-string">"foo"</span></span>.getClass().arrayType() <span class="hljs-variable"><span class="hljs-variable">$15</span></span> ==&gt; class [Ljava.lang.String;</code> </pre> <br><p>  Saya tidak yakin apa arti dari metode ini, karena semua yang dilakukannya hanyalah menambahkan <code>Class</code> ke jenis yang diwakili oleh kelas ini. </p><br><p>  <code>componentType()</code> , sama dengan <code>getComponentType()</code> .  Pertanyaannya memohon - mengapa menambahkan metode yang berlebihan? </p><br><p>  <code>descriptorString()</code> - sekali lagi, mengembalikan hasil yang sama dengan <code>getName()</code> .  Namun, itu perlu karena <code>Class</code> sekarang mengimplementasikan antarmuka <code>TypeDescriptor</code> terkait dengan API JVM konstan baru. </p><br><h3>  lava.lang.String </h3><br><p>  <code>indent()</code> - Menambahkan serangkaian spasi utama ke string.  Jika parameter negatif, maka jumlah spasi utama ini akan dihapus (jika mungkin). </p><br><p>  <code>transform()</code> - Menerapkan fungsi yang disediakan ke string.  Hasilnya mungkin bukan string. </p><br><h3>  java.lang.invoke </h3><br><p>  <code>VarHandle</code> sekarang memiliki <code>toString()</code> untuk mengembalikan deskripsi yang ringkas. </p><br><p>  <code>java.net.SecureCacheResponse</code> dan <code>java.net.ssl.HttpsConnection</code> memiliki metode baru, <code>getSSLSession()</code> yang mengembalikan <code>Optional</code> berisi <code>SSLSession</code> digunakan dalam koneksi. </p><br><h3>  java.nio.files </h3><br><p>  Kelas <code>Files</code> memiliki metode baru, <code>mismatch()</code> , yang menemukan dan mengembalikan posisi byte ketidakcocokan pertama dalam isi dua file, atau -1L jika tidak ada ketidakcocokan. </p><br><h3>  java.text </h3><br><p>  Ada <code>CompactNumberFormat</code> kelas baru.  Ini adalah subkelas dari <code>NumberFormat</code> yang memformat angka desimal dalam bentuk ringkas.  Contoh bentuk ringkas - <code>1M</code> bukan <code>1000000</code> , karenanya - memerlukan dua bukannya sembilan karakter.  <code>NumberFormat</code> dan <code>java.text.spi.NumberFormatProvider</code> telah diperluas untuk menyertakan metode <code>getCompactNumberInstance()</code> yang baru.  Ada juga enum baru, <code>NumberFormatStyle</code> yang memiliki dua arti: PANJANG dan SINGKAT. </p><br><h3>  java.util.concurrent </h3><br><p>  CompletionStage sekarang mencakup beberapa formulir kelebihan beban dengan tiga metode: </p><br><ul><li>  sangat async </li><li>  luar biasaCompose </li><li>  luar biasaComposeAsync </li></ul><br><p>  Metode-metode ini memperluas kemungkinan membuat <code>CompletionStage</code> baru dari yang sudah ada, <code>CompletionStage</code> jika yang sekarang berakhir dengan pengecualian.  Periksa dokumentasi API untuk detailnya. </p><br><h3>  javax.crypto </h3><br><p>  Kelas <code>Cipher</code> memiliki metode <code>toString()</code> yang mengembalikan string yang berisi transformasi, mode, dan penyedia <code>Cipher</code> . </p><br><h3>  javax.naming.ldap.spi </h3><br><p>  Ini adalah paket baru di JDK 12 dan berisi dua kelas: <code>LdapDnsProvider</code> , yang merupakan kelas penyedia untuk pencarian DNS selama operasi LDAP, dan <code>LdapDnsProviderResults</code> yang merangkum hasil pencarian DNS untuk URL LDAP. </p><br><h3>  Ayun </h3><br><p>  Ayunan masih diperbarui!  Ya, <code>filechooser.FileSystemView</code> sekarang memiliki metode <code>getChooserShortcutPanelFiles()</code> .  Ini mengembalikan array file yang mewakili nilai-nilai untuk ditampilkan secara default di bar pintasan pemilihan file. </p><br><h2>  Perubahan JVM </h2><br><h3>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">JEP 189: Shenandoah</a> : Pengumpul Sampah Rendah Jeda </h3><br><p>  Shenandoah adalah proyek penelitian yang diumumkan oleh Red Hat pada tahun 2014 yang berfokus pada persyaratan aplikasi latensi rendah untuk manajemen memori di JVM.  Sasarannya adalah waktu jeda maksimum 1..10ms untuk tumpukan lebih dari 20 GB ( <del>  oleh karena itu tidak dimaksudkan untuk aplikasi kecil </del>  - seperti yang dikatakan oleh <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">salah satu pengembang Shenandoah</a> , ini tidak benar dan ia melakukan pekerjaan yang sangat baik dengan aplikasi kecil).  Kolektor ini dirancang untuk bekerja secara paralel dengan utas aplikasi, jadi hindari masalah yang kita lihat di sebagian besar pemulung. </p><br><h3>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">JEP 344: Koleksi G1 Campuran</a> </h3><br><p>  Perubahan ini dimaksudkan untuk meningkatkan perilaku kolektor G1 ketika mencapai tujuan penundaan yang ditetapkan.  G1 membagi ruang tumpukan (baik tua dan lama) menjadi daerah.  Idenya adalah bahwa di generasi lama Anda tidak perlu mengumpulkan sampah dalam satu operasi.  Ketika G1 perlu mengumpulkan sampah, ia memilih daerah yang ditentukannya.  Ini disebut koleksi kit.  Sebelum JDK 12, ketika pekerjaan dimulai di set, semua pekerjaan harus diselesaikan, pada dasarnya, sebagai operasi atom.  Masalahnya adalah bahwa kadang-kadang karena perubahan dalam penggunaan ruang timbunan aplikasi, kumpulan itu ternyata terlalu besar dan terlalu banyak waktu untuk dikumpulkan, yang mengarah pada fakta bahwa waktu jeda tidak tercapai. </p><br><p>  Dalam JDK 12, jika G1 mengidentifikasi situasi ini, itu akan mengganggu pengumpulan data di tengah jalan jika ini tidak mempengaruhi kemampuan aplikasi untuk terus mengalokasikan ruang untuk objek baru.  Efek bersih G1 akan lebih baik ketika waktu jeda singkat tercapai. </p><br><h3>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">JEP 346: dengan cepat mengembalikan memori yang dialokasikan tidak terpakai dari G1</a> </h3><br><p>  Ini adalah peningkatan kinerja lain untuk G1, tetapi yang lain terkait dengan bagaimana JVM berinteraksi dengan seluruh sistem.  Jelas, memori diperlukan untuk tumpukan JVM, dan saat startup, ia meminta memori dari pengalokasi memori virtual sistem operasi.  Ketika aplikasi dimulai, mungkin ada kalanya jumlah memori yang dibutuhkan untuk tumpukan turun, dan bagian dari memori yang dialokasikan dapat dikembalikan ke sistem operasi untuk digunakan oleh aplikasi lain. </p><br><p>  G1 sudah melakukan ini, tetapi hanya bisa melakukan ini di salah satu dari dua tempat.  Pertama, selama koleksi lengkap, dan kedua, selama salah satu siklus paralel.  G1 mencoba untuk tidak melakukan pengumpulan penuh, dan dengan penggunaan memori yang rendah, mungkin ada periode yang signifikan antara siklus pengumpulan.  Ini mengarah pada fakta bahwa G1 dapat menyimpan memori tetap untuk waktu yang lama. </p><br><p>  Dalam JDK 12, G1 secara berkala akan mencoba untuk melanjutkan atau menjalankan loop paralel sementara aplikasi idle untuk menentukan keseluruhan penggunaan heap Java.  Memori yang tidak digunakan dapat dikembalikan ke sistem operasi dengan cara yang lebih tepat waktu dan dapat diprediksi. </p><br><p>  Bendera baris perintah baru <code>-XX:G1PeriodicGCInterval</code> dapat digunakan untuk mengatur jumlah milidetik di antara pemeriksaan. </p><br><p>  Fitur ini akan mengarah pada penggunaan memori JVM yang lebih konservatif untuk aplikasi yang tidak digunakan dalam waktu yang lama. </p><br><h2>  Fitur JDK baru lainnya </h2><br><h3>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">JEP 230: Perangkat Microbenchmarking</a> </h3><br><p>  Java Microbenchmarking Harness (JMH) dikembangkan oleh Alexey Shipilev ketika ia bekerja di Oracle dan menyediakan platform yang luas untuk mengembangkan tes kinerja untuk aplikasi Java.  Alexey melakukan pekerjaan luar biasa membantu orang-orang untuk menghindari banyak kesalahan sederhana yang mereka buat ketika mencoba menganalisis kinerja aplikasi: pemanasan, hindari pengecualian, dll. </p><br><p>  Sekarang JMH dapat dimasukkan dalam OpenJDK.  Siapa pun yang tertarik untuk bekerja pada JDK itu sendiri dan mengubah kode dapat menggunakan ini untuk membandingkan kinerja sebelum dan sesudah perubahan mereka, serta untuk membandingkan kinerja dalam rilis yang berbeda.  Sejumlah tes disertakan untuk memungkinkan pengujian;  Desain JMH sedemikian rupa sehingga mudah untuk menambahkan tes baru ke tempat yang dibutuhkan. </p><br><h3>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">JEP 340: Satu Pelabuhan Aarch64, Bukan Dua</a> </h3><br><p>  OpenJDK memiliki dua port untuk arsitektur Arm64, satu disediakan oleh Oracle dan lainnya oleh Red Hat.  Karena ini tidak diperlukan, dan Oracle berhenti mendukung Arm untuk binari JDK-nya, diputuskan untuk hanya menggunakan port Red Hat, yang masih didukung dan dikembangkan. </p><br><h3>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">JEP 341: arsip CDS default</a> </h3><br><p>  Kelas Data Sharing (CDS) digunakan untuk fitur komersial di Oracle JDK.  Dengan transisi baru-baru ini yang dibuat dalam JDK 11 untuk menghilangkan semua perbedaan fungsional antara Oracle JDK dan OpenJDK, itu dimasukkan dalam OpenJDK. </p><br><p>  Untuk menggunakan CDS, Anda memerlukan arsip yang dibuat untuk kelas yang memuat saat aplikasi dimulai.  JDK 12 untuk platform 64-bit sekarang memiliki file <code>classes.jsa</code> di <code>lib/server</code> .  Ini adalah arsip CDS untuk "kelas default".  Saya berasumsi bahwa itu berarti semua kelas publik dalam modul JDK;  Saya tidak dapat menemukan cara untuk membongkar untuk memeriksanya.  Karena CDS diaktifkan secara default, yang setara dengan opsi <code>-Xshare:auto</code> pada baris perintah, pengguna akan mendapat manfaat dari peningkatan waktu startup aplikasi darinya. </p><br><h2>  Kesimpulan </h2><br><p>  JDK 12 menyediakan sejumlah kecil fungsi dan API baru, dengan <code>switch</code> menjadi yang paling menarik bagi pengembang.  Pengguna G1 tentu akan menghargai peningkatan kinerja. </p><br><p>  Dengan versi baru rilis, saya akan menyarankan semua pengguna untuk menguji aplikasi mereka dalam rilis ini.  Melacak perubahan inkremental akan membantu Anda menghindari kejutan jika Anda memutuskan untuk beralih ke rilis dukungan jangka panjang berikutnya. </p><br><p>  Kami memiliki <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">JDK 12</a> build gratis <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">untuk Zulu Community Edition</a> untuk membantu Anda dengan pengujian Anda.  Pastikan untuk mencobanya. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id446590/">https://habr.com/ru/post/id446590/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id446576/index.html">Mengganti impor, atau bagaimana Helikopter Rusia melakukan kesalahan</a></li>
<li><a href="../id446578/index.html">Bahasa pemrograman berbasis kartu pos</a></li>
<li><a href="../id446582/index.html">Refleksi tentang Hosting Surya untuk Lebah</a></li>
<li><a href="../id446586/index.html">Pengaturan Jaringan dari FreeRadius via DHCP</a></li>
<li><a href="../id446588/index.html">Memeriksa Kode Sumber Roslyn</a></li>
<li><a href="../id446592/index.html">Memeriksa kode sumber Roslyn</a></li>
<li><a href="../id446598/index.html">Menciptakan Font CRT</a></li>
<li><a href="../id446602/index.html">Maksimum Arus DC Melalui Transistor Efek Bidang</a></li>
<li><a href="../id446604/index.html">ESET: Skema Pengiriman Backdoor OceanLotus Cybergroup Baru</a></li>
<li><a href="../id446606/index.html">Periksa seberapa baik Anda dalam teknologi aditif</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>