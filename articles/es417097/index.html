<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🏬 👷 🤟🏼 Metaprogramación de JavaScript 👩 🚌 🏴</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="La metaprogramación es un tipo de programación asociada con la creación de programas que generan otros programas como resultado de su trabajo, o progr...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Metaprogramación de JavaScript</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/docsvision/blog/417097/"><blockquote>  La metaprogramación es un tipo de programación asociada con la creación de programas que generan otros programas como resultado de su trabajo, o programas que cambian a sí mismos durante la ejecución.  (Wikipedia) </blockquote><p>  En un lenguaje más simple, la metaprogramación dentro de JavaScript puede considerarse mecanismos que le permiten analizar y cambiar el programa en tiempo real dependiendo de cualquier acción.  Y, muy probablemente, de alguna manera los usas al escribir scripts todos los días. </p><a name="habracut"></a><br><p>  JavaScript, por su naturaleza, es un lenguaje dinámico muy poderoso y le permite escribir código flexible muy bien: </p><br><pre><code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">/** *   save-    */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> comment = { <span class="hljs-attr"><span class="hljs-attr">authorId</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-attr"><span class="hljs-attr">comment</span></span>: <span class="hljs-string"><span class="hljs-string">''</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> name <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> comment) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> pascalCasedName = name.slice(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>).toUpperCase() + name.slice(<span class="hljs-number"><span class="hljs-number">1</span></span>); comment[<span class="hljs-string"><span class="hljs-string">`save</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${pascalCasedName}</span></span></span><span class="hljs-string">`</span></span>] = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//   } } comment.saveAuthorId(); //  authorId comment.saveComment(); //  comment</span></span></code> </pre> <br><p>  Un código similar para crear métodos dinámicamente en otros idiomas muy a menudo puede requerir una sintaxis especial o API para esto.  Por ejemplo, PHP también es un lenguaje dinámico, pero en él requerirá más esfuerzo: </p><br><pre> <code class="php hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?php</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Comment</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> $authorId; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> $comment; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__construct</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($authorId, $comment)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;authorId = $authorId; <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;comment = $comment; } <span class="hljs-comment"><span class="hljs-comment">//       public function __call($methodName, $arguments) { foreach (get_object_vars($this) as $fieldName =&gt; $fieldValue) { $saveMethodName = "save" . strtoupper($fieldName[0]) . substr($fieldName, 1); if ($methodName == $saveMethodName) { //   } } } } $comment = new Comment(1, ''); $comment-&gt;saveAuthorId(); //  authorId $comment-&gt;saveComment(); //  comment</span></span></code> </pre> <br><p>  Además de la sintaxis flexible, también tenemos un montón de funciones útiles para escribir código dinámico: Object.create, Object.defineProperty, Function.apply y muchos otros. </p><br><p>  Considérelos con más detalle. </p><br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Generación de código</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Trabajar con funciones</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Trabajar con objetos</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">API de reflejo</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Los símbolos</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Proxy</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Conclusión</a> </li></ol><br><h2 id="1-generaciya-koda">  1. Generación de código </h2><br><p>  La herramienta estándar para ejecutar código dinámicamente es la función <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">eval</a> , que le permite ejecutar código desde la cadena pasada: </p><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">eval</span></span>(<span class="hljs-string"><span class="hljs-string">'alert("Hello, world")'</span></span>);</code> </pre> <br><p>  Desafortunadamente, eval tiene muchos matices: </p><br><ul><li>  Si nuestro código está escrito en modo estricto ('use estricto'), las variables declaradas dentro de eval no serán visibles en el código de evaluación de llamada.  Al mismo tiempo, el código en sí dentro de eval siempre puede cambiar las variables externas. </li><li>  el código dentro de eval puede ejecutarse tanto en el contexto global (si se llama a través de window.eval) como en el contexto de la función dentro de la cual se realizó la llamada (si solo eval, sin ventana). </li><li>  Pueden surgir problemas debido a la minificación JS, cuando los nombres de las variables se reemplazan por otros más cortos para reducir el tamaño.  El código pasado como una cadena para evaluar generalmente no toca el minificador, debido a esto podemos comenzar a acceder a variables externas usando nombres antiguos no minificados, lo que conducirá a errores sutiles. </li></ul><br><p>  Hay una gran alternativa para resolver estos problemas: la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">nueva función</a> . </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> hello = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Function</span></span>(<span class="hljs-string"><span class="hljs-string">'name'</span></span>, <span class="hljs-string"><span class="hljs-string">'alert("Hello, " + name)'</span></span>); hello(<span class="hljs-string"><span class="hljs-string">''</span></span>) <span class="hljs-comment"><span class="hljs-comment">// alert("Hello, ");</span></span></code> </pre> <br><p>  A diferencia de eval, siempre podemos pasar parámetros explícitamente a través de los argumentos de una función y darle dinámicamente el contexto de esta (a través de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Function.apply</a> o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Function.call</a> ).  Además, la función creada siempre se llama en el ámbito global. </p><br><p>  En los viejos tiempos, eval se usaba a menudo para cambiar dinámicamente el código, ya que  JavaScript tenía muy pocos mecanismos de reflexión y era imposible hacerlo sin eval.  Pero en el estándar de lenguaje moderno, ha aparecido mucha más funcionalidad de alto nivel y eval se usa ahora con mucha menos frecuencia. </p><br><h2 id="2-rabota-s-funkciyami">  2. Trabajar con funciones </h2><br><p>  JavaScript nos proporciona muchas herramientas excelentes para trabajar dinámicamente con funciones, permitiéndonos obtener información diversa sobre la función en tiempo de ejecución y cambiarla: </p><br><ul><li><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Function.length</a> : le permite averiguar la cantidad de argumentos de una función: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> func = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">name, surname</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">`Hello, </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${surname}</span></span></span><span class="hljs-string"> </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${name}</span></span></span><span class="hljs-string">`</span></span>) }; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(func.length) <span class="hljs-comment"><span class="hljs-comment">// 2</span></span></code> </pre> <br></li><li><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Function.apply</a> y <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Function.call</a> : le permiten cambiar dinámicamente el contexto de esta función: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> person = { <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">''</span></span>, <span class="hljs-attr"><span class="hljs-attr">introduce</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">` </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${</span></span><span class="hljs-keyword"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-string"><span class="hljs-subst">.name}</span></span></span><span class="hljs-string">`</span></span>; } } person.introduce(); <span class="hljs-comment"><span class="hljs-comment">//   person.introduce.call({ name: '' }); //  </span></span></code> </pre> <br><p>  Se diferencian entre sí solo en que, en Function.apply, los argumentos de la función se sirven como una matriz, y en Function.call, separados por comas.  Esta característica a menudo se usaba antes para pasar una lista de argumentos a la función como una matriz.  Un ejemplo común es la función <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Math.max</a> (por defecto, no puede funcionar con matrices): </p><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.max.apply(<span class="hljs-literal"><span class="hljs-literal">null</span></span>, [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>]); <span class="hljs-comment"><span class="hljs-comment">// 4</span></span></code> </pre> <br><p>  Con el advenimiento del nuevo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">operador de propagación,</a> simplemente puede escribir esto: </p><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.max(...[<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>]); <span class="hljs-comment"><span class="hljs-comment">// 4</span></span></code> </pre> <br></li><li><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Function.bind</a> : le permite crear una copia de una función a partir de una existente, pero con un contexto diferente: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> person = { <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">''</span></span>, <span class="hljs-attr"><span class="hljs-attr">introduce</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">` </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${</span></span><span class="hljs-keyword"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-string"><span class="hljs-subst">.name}</span></span></span><span class="hljs-string">`</span></span>; } } person.introduce(); <span class="hljs-comment"><span class="hljs-comment">//   const introduceEgor = person.introduce.bind({ name: '' }); introduceEgor(); //  </span></span></code> </pre> <br></li><li><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Function.caller</a> : le permite obtener la función de llamada.  <strong>No se recomienda usarlo</strong> , ya que está ausente en el estándar de idioma y no funcionará en modo estricto.  Esto se debió al hecho de que si varios motores de JavaScript implementan la optimización de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">llamada de cola</a> descrita en la especificación del lenguaje, entonces llamar a Function.caller puede comenzar a producir resultados incorrectos.  Ejemplo de uso: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> a = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(a.caller == b); } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> b = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ a(); } b(); <span class="hljs-comment"><span class="hljs-comment">// true</span></span></code> </pre> <br></li><li><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Function.toString</a> : devuelve una representación de cadena de la función.  Esta es una característica muy poderosa que le permite examinar tanto el contenido de una función como sus argumentos: </p><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> getFullName = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">name, surname, middlename</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">`</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${surname}</span></span></span><span class="hljs-string"> </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${name}</span></span></span><span class="hljs-string"> </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${middlename}</span></span></span><span class="hljs-string">`</span></span>); } getFullName.toString() <span class="hljs-comment"><span class="hljs-comment">/* * "(name, surname, middlename) =&gt; { * console.log(`${surname} ${name} ${middlename}`); * }" */</span></span></code> </pre> <br><p>  Habiendo recibido una representación de cadena de una función, podemos analizarla y analizarla.  Esto se puede utilizar para, por ejemplo, extraer los nombres de los argumentos de la función y, según el nombre, sustituir automáticamente el parámetro deseado.  En general, hay dos formas de analizar: </p><br><ul><li>  Analizando un grupo de clientes habituales y obtenemos un nivel aceptable de confiabilidad (puede no funcionar si no cubrimos todos los tipos posibles de entradas de funciones). </li><li>  Obtenemos la representación de cadena de la función y la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">colocamos</a> en el analizador JavaScript terminado (por ejemplo, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">esprima</a> o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">bellota</a> ), y luego trabajamos con el AST estructurado.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Ejemplo de análisis AST a través de esprima.</a>  También puedo recomendar un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">buen informe sobre los analizadores</a> de Alexei Okhrimenko. </li></ul><br></li></ul><br><p>  Ejemplos simples con análisis de funciones regulares: </p><br><div class="spoiler">  <b class="spoiler_title">Obtener una lista de argumentos de funciones</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">/** *    . * @param fn  */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> getFunctionParams = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">fn</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> COMMENTS = <span class="hljs-regexp"><span class="hljs-regexp">/(\/\/.*$)|(\/\*[\s\S]*?\*\/)|(\s*=[^,\)]*(('(?:\\'|[^'\r\n])*')|("(?:\\"|[^"\r\n])*"))|(\s*=[^,\)]*))/gm</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> DEFAULT_PARAMS = <span class="hljs-regexp"><span class="hljs-regexp">/=[^,]+/gm</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> FAT_ARROW = <span class="hljs-regexp"><span class="hljs-regexp">/=&gt;.*$/gm</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> ARGUMENT_NAMES = <span class="hljs-regexp"><span class="hljs-regexp">/([^\s,]+)/g</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> formattedFn = fn .toString() .replace(COMMENTS, <span class="hljs-string"><span class="hljs-string">""</span></span>) .replace(FAT_ARROW, <span class="hljs-string"><span class="hljs-string">""</span></span>) .replace(DEFAULT_PARAMS, <span class="hljs-string"><span class="hljs-string">""</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> params = formattedFn .slice(formattedFn.indexOf(<span class="hljs-string"><span class="hljs-string">"("</span></span>) + <span class="hljs-number"><span class="hljs-number">1</span></span>, formattedFn.indexOf(<span class="hljs-string"><span class="hljs-string">")"</span></span>)) .match(ARGUMENT_NAMES); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> params || []; }; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> getFullName = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">name, surname, middlename</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(surname + <span class="hljs-string"><span class="hljs-string">' '</span></span> + name + <span class="hljs-string"><span class="hljs-string">' '</span></span> + middlename); }; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(getFunctionParams(getFullName)); <span class="hljs-comment"><span class="hljs-comment">// ["name", "surname", "middlename"]</span></span></code> </pre> <br><iframe width="560" height="315" src="https://www.youtube.com/embed/https://translate" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe></div></div><br><div class="spoiler">  <b class="spoiler_title">Obtención de la función corporal</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">/** *     . * @param fn  */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> getFunctionBody = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">fn</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> restoreIndent = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">body</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> lines = body.split(<span class="hljs-string"><span class="hljs-string">"\n"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> bodyLine = lines.find(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">line</span></span></span><span class="hljs-function"> =&gt;</span></span> line.trim() !== <span class="hljs-string"><span class="hljs-string">""</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> indent = <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span> bodyLine !== <span class="hljs-string"><span class="hljs-string">"undefined"</span></span> ? <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-regexp"><span class="hljs-function"><span class="hljs-params"><span class="hljs-regexp">/[ \t]*/</span></span></span></span><span class="hljs-function"><span class="hljs-params">.exec(bodyLine</span></span></span><span class="hljs-function">) || [])[0] : ""; </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">indent</span></span></span><span class="hljs-function"> = </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">indent</span></span></span><span class="hljs-function"> || ""; </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">return</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">lines</span></span></span><span class="hljs-function">.</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">map</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">line =&gt; line.replace(indent, </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">""</span></span></span></span></span><span class="hljs-function">)).</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">join</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"\n"</span></span></span></span></span><span class="hljs-function">); }; </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">const</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">fnStr</span></span></span><span class="hljs-function"> = </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">fn</span></span></span><span class="hljs-function">.</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">toString</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">; </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">const</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">rawBody</span></span></span><span class="hljs-function"> = </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">fnStr</span></span></span><span class="hljs-function">.</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">substring</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> fnStr.indexOf(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"{"</span></span></span></span></span><span class="hljs-function">) + 1, </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">fnStr</span></span></span><span class="hljs-function">.</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">lastIndexOf</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"}"</span></span></span></span></span><span class="hljs-function">) ); </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">const</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">indentedBody</span></span></span><span class="hljs-function"> = </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">restoreIndent</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">rawBody</span></span></span><span class="hljs-function">); </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">const</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">trimmedBody</span></span></span><span class="hljs-function"> = </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">indentedBody</span></span></span><span class="hljs-function">.</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">replace</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-regexp"><span class="hljs-function"><span class="hljs-params"><span class="hljs-regexp">/^\s+|\s+$/g</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">""</span></span></span></span></span><span class="hljs-function">); </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">return</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">trimmedBody</span></span></span><span class="hljs-function">; }; //       </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">getFullName</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">const</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">getFullName</span></span></span><span class="hljs-function"> = (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">name, surname, middlename</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(surname + <span class="hljs-string"><span class="hljs-string">' '</span></span> + name + <span class="hljs-string"><span class="hljs-string">' '</span></span> + middlename); }; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(getFunctionBody(getFullName));</code> </pre> <br><iframe width="560" height="315" src="https://www.youtube.com/embed/https://translate" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe></div></div><br><p>  Es importante tener en cuenta que cuando se usa el minificador, tanto el código en sí mismo dentro de la función analizada como sus argumentos pueden optimizarse y, por lo tanto, cambiar. </p><br><h2 id="3-rabota-s-obektami">  3. Trabajar con objetos. </h2><br><p>  JavaScript tiene un objeto Object global que contiene muchos métodos para trabajar dinámicamente con objetos. </p><br><p>  La mayoría de estos métodos a partir de ahí han existido durante mucho tiempo en el lenguaje y son ampliamente utilizados. </p><br><h3 id="svoystva-obekta">  Propiedades del objeto </h3><br><ul><li><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Object.assign</a> : para copiar convenientemente las propiedades de uno o más objetos al objeto especificado por el primer parámetro: </p><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.assign({}, { <span class="hljs-attr"><span class="hljs-attr">a</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span> }, { <span class="hljs-attr"><span class="hljs-attr">b</span></span>: <span class="hljs-number"><span class="hljs-number">2</span></span> }, { <span class="hljs-attr"><span class="hljs-attr">c</span></span>: <span class="hljs-number"><span class="hljs-number">3</span></span> }) <span class="hljs-comment"><span class="hljs-comment">// {a: 1, b: 2, c: 3}</span></span></code> </pre> <br></li><li><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Object.keys</a> y <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Object.values</a> : devuelve una lista de claves o una lista de valores de objeto: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> obj = { <span class="hljs-attr"><span class="hljs-attr">a</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-attr"><span class="hljs-attr">b</span></span>: <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-attr"><span class="hljs-attr">c</span></span>: <span class="hljs-number"><span class="hljs-number">3</span></span> }; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.keys(obj)); <span class="hljs-comment"><span class="hljs-comment">// ["a", "b", "c"] console.log(Object.values(obj)); // [1, 2, 3]</span></span></code> </pre> <br></li><li><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Object.entries</a> : devuelve una lista de sus propiedades en el formato <em>[[clave1, valor1], [clave2, valor2]]</em> : </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> obj = { <span class="hljs-attr"><span class="hljs-attr">a</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-attr"><span class="hljs-attr">b</span></span>: <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-attr"><span class="hljs-attr">c</span></span>: <span class="hljs-number"><span class="hljs-number">3</span></span> }; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.entries(obj)); <span class="hljs-comment"><span class="hljs-comment">// [["a", 1], ["b", 2], ["c", 3]]</span></span></code> </pre> <br></li><li><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Object.prototype.hasOwnProperty</a> : comprueba si una propiedad está contenida en un objeto (no en su cadena de prototipo): </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> obj = { <span class="hljs-attr"><span class="hljs-attr">a</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span> }; obj.__proto__ = { <span class="hljs-attr"><span class="hljs-attr">b</span></span>: <span class="hljs-number"><span class="hljs-number">2</span></span> }; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(obj.hasOwnProperty(<span class="hljs-string"><span class="hljs-string">'a'</span></span>)); <span class="hljs-comment"><span class="hljs-comment">// true console.log(obj.hasOwnProperty('b')) // false</span></span></code> </pre> <br></li><li><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Object.getOwnPropertyNames</a> : devuelve una lista de sus propias propiedades, incluidas las enumeradas y las no enumeradas: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> obj = { <span class="hljs-attr"><span class="hljs-attr">a</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-attr"><span class="hljs-attr">b</span></span>: <span class="hljs-number"><span class="hljs-number">2</span></span> }; <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.defineProperty(obj, <span class="hljs-string"><span class="hljs-string">'c'</span></span>, { <span class="hljs-attr"><span class="hljs-attr">value</span></span>: <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-attr"><span class="hljs-attr">enumerable</span></span>: <span class="hljs-literal"><span class="hljs-literal">false</span></span> }); <span class="hljs-comment"><span class="hljs-comment">//    for (let key in obj) { console.log(key); } // "a", "b" console.log(Object.getOwnPropertyNames(obj)); // [ "a", "b", "c" ]</span></span></code> </pre> <br></li><li><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Object.getOwnPropertySymbols</a> : devuelve una lista de sus propios caracteres (contenidos en el objeto y no en su cadena de prototipo): </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> obj = {}; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> a = <span class="hljs-built_in"><span class="hljs-built_in">Symbol</span></span>(<span class="hljs-string"><span class="hljs-string">'a'</span></span>); obj[a] = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.getOwnPropertySymbols(obj)); <span class="hljs-comment"><span class="hljs-comment">// [ Symbol(a) ]</span></span></code> </pre> <br></li><li><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Object.prototype.propertyIsEnumerable</a> : comprueba si una propiedad es enumerable (por ejemplo, está disponible en bucles for-in, for-of): </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> arr = [ <span class="hljs-string"><span class="hljs-string">' '</span></span> ]; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(arr.propertyIsEnumerable(<span class="hljs-number"><span class="hljs-number">0</span></span>)); <span class="hljs-comment"><span class="hljs-comment">// true —  ' '   console.log(arr.propertyIsEnumerable('length')); // false —  length   </span></span></code> </pre> <br></li></ul><br><h3 id="deskriptory-svoystv-obekta">  Descriptores de propiedad de objeto </h3><br><p>  Los descriptores le permiten ajustar los parámetros de propiedad.  Al usarlos, podemos hacer convenientemente nuestros propios interceptores mientras leemos / escribimos cualquier propiedad (getters y setters - get / set), hacemos que las propiedades sean inmutables o no enumerables, y una serie de otras cosas. </p><br><ul><li><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Object.defineProperty</a> y <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Object.defineProperties</a> : crea uno o más descriptores de propiedades.  Crea tu propio descriptor con getter y setter: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> obj = { <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">''</span></span>, <span class="hljs-attr"><span class="hljs-attr">surname</span></span>: <span class="hljs-string"><span class="hljs-string">''</span></span> }; <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.defineProperty(obj, <span class="hljs-string"><span class="hljs-string">'fullname'</span></span>, { <span class="hljs-comment"><span class="hljs-comment">//     fullname get: function() { return `${this.name} ${this.surname}`; }, //     fullname (     delete obj.fullname) set: function(value) { const [name, surname] = value.split(' '); this.name = name; this.surname = surname; }, }); console.log(obj.fullname); //   obj.fullname = ' '; console.log(obj.name); //  console.log(obj.surname); // </span></span></code> </pre> <br><p>  En el ejemplo anterior, la propiedad de nombre completo no tenía su propio valor, sino que funcionaba dinámicamente con las propiedades de nombre y apellido.  No es necesario definir tanto un getter como un setter al mismo tiempo; solo podemos dejar el getter y obtener una propiedad de solo lectura.  O podemos agregar una acción adicional en el setter junto con la configuración del valor, por ejemplo, el registro. <br>  Además de las propiedades get / set, los descriptores tienen varias propiedades más para configurar: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> obj = {}; <span class="hljs-comment"><span class="hljs-comment">//      get/set,       value.    get/set  value.   — undefined. Object.defineProperty(obj, 'name', { value: '' }); // ,         (for-in, for-of, Object.keys).   — false. Object.defineProperty(obj, 'a', { enumerable: true }); //         defineProperty     delete.   — false. Object.defineProperty(obj, 'b', { configurable: false }); //      .   — false. Object.defineProperty(obj, 'c', { writable: true });</span></span></code> </pre> <br></li><li><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Object.getOwnPropertyDescriptor</a> y <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Object.getOwnPropertyDescriptors</a> : le permiten obtener el descriptor de objeto deseado o su lista completa: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> obj = { <span class="hljs-attr"><span class="hljs-attr">a</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-attr"><span class="hljs-attr">b</span></span>: <span class="hljs-number"><span class="hljs-number">2</span></span> }; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.getOwnPropertyDescriptor(obj, <span class="hljs-string"><span class="hljs-string">"a"</span></span>)); <span class="hljs-comment"><span class="hljs-comment">// { configurable: true, enumerable: true, value: 1, writable: true } /** * { * a: { configurable: true, enumerable: true, value: 1, writable: true }, * b: { configurable: true, enumerable: true, value: 2, writable: true } * } */ console.log(Object.getOwnPropertyDescriptors(obj));</span></span></code> </pre> <br></li></ul><br><h3 id="sozdanie-ogranicheniy-pri-rabote-s-obektami">  Crear restricciones al trabajar con objetos </h3><br><ul><li><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Object.freeze</a> - "congela" las propiedades de un objeto.  La consecuencia de tal "congelación" es la inmutabilidad completa de las propiedades del objeto: no se pueden cambiar ni eliminar, se agregan otras nuevas, se cambian los descriptores: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> obj = <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.freeze({ <span class="hljs-attr"><span class="hljs-attr">a</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span> }); <span class="hljs-comment"><span class="hljs-comment">//       ,       . obj.a = 2; obj.b = 3; console.log(obj); // { a: 1 } console.log(Object.isFrozen(obj)) // true</span></span></code> </pre> <br></li><li><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Object.seal</a> - "sella" las propiedades de un objeto.  El sellado es similar a Object.freeze, pero tiene varias diferencias.  Nosotros, como en Object.freeze, prohibimos agregar nuevas propiedades, eliminar las existentes, cambiar sus descriptores, pero al mismo tiempo podemos cambiar los valores de las propiedades: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> obj = <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.seal({ <span class="hljs-attr"><span class="hljs-attr">a</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span> }); obj.a = <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-comment"><span class="hljs-comment">//  a   2 //     ,       . obj.b = 3; console.log(obj); // { a: 2 } console.log(Object.isSealed(obj)) // true</span></span></code> </pre> <br></li><li><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Object.preventExtensions</a> : prohíbe agregar nuevas propiedades / descriptores: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> obj = <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.preventExtensions({ <span class="hljs-attr"><span class="hljs-attr">a</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span> }); obj.a = <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-comment"><span class="hljs-comment">//       ,       . obj.b = 3; console.log(obj); // { a: 2 } console.log(Object.isExtensible(obj)) // false</span></span></code> </pre> <br></li></ul><br><h3 id="prototipy-obektov">  Prototipos de objetos </h3><br><ul><li><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Object.create</a> : para crear un objeto con el prototipo especificado en el parámetro.  Esta característica se puede usar tanto para la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">herencia de prototipos</a> como para crear objetos "limpios", sin propiedades de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Object.prototype</a> : </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> pureObj = <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.create(<span class="hljs-literal"><span class="hljs-literal">null</span></span>);</code> </pre> <br></li><li><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Object.getPrototypeOf</a> y <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Object.setPrototypeOf</a> - para obtener / cambiar el prototipo de un objeto: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> duck = {}; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> bird = {}; <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.setPrototypeOf(duck, bird); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.getPrototypeOf(duck) === bird); <span class="hljs-comment"><span class="hljs-comment">// true console.log(duck.__proto__ === bird); // true</span></span></code> </pre> <br></li><li><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Object.prototype.isPrototypeOf</a> : comprueba si el objeto actual está contenido en la cadena de prototipo de otro: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> duck = {}; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> bird = {}; duck.__proto__ = bird; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(bird.isPrototypeOf(duck)); <span class="hljs-comment"><span class="hljs-comment">// true</span></span></code> </pre> <br></li></ul><br><h2 id="4-reflect-api">  4. Reflejar API </h2><br><p>  Con la llegada de ES6, se ha agregado un objeto <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Reflect</a> global a JavaScript para almacenar varios métodos relacionados con la reflexión y la introspección. </p><br><p>  La mayoría de sus métodos son el resultado de transferir métodos existentes de objetos globales como <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Objeto</a> y <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Función</a> a un espacio de nombres separado con una pequeña refactorización para un uso más cómodo. </p><br><p>  La transferencia de funciones al objeto Reflect no solo facilitó la búsqueda de los métodos necesarios para la reflexión y proporcionó una mayor semántica, sino que también evitó situaciones desagradables cuando nuestro objeto no contiene <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Object.prototype</a> en su prototipo, sino que queremos utilizar los métodos a partir de ahí: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> obj = <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.create(<span class="hljs-literal"><span class="hljs-literal">null</span></span>); obj.qwerty = <span class="hljs-string"><span class="hljs-string">'qwerty'</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(obj.__proto__) <span class="hljs-comment"><span class="hljs-comment">// null console.log(obj.hasOwnProperty('qwerty')) // Uncaught TypeError: obj.hasOwnProperty is not a function console.log(obj.hasOwnProperty === undefined); // true console.log(Object.prototype.hasOwnProperty.call(obj, 'qwerty')); // true</span></span></code> </pre> <br><p>  La refactorización ha hecho que el comportamiento de los métodos sea más explícito y monótono.  Por ejemplo, si antes, al llamar a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Object.defineProperty</a> con un valor incorrecto (como un número o una cadena), se <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">generaba</a> una excepción, pero al mismo tiempo, llamar a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Object.getOwnPropertyDescriptor</a> en un descriptor de objeto inexistente devuelto en silencio sin definir, luego métodos similares de Reflect siempre arrojan excepciones para datos incorrectos . </p><br><p>  También se han agregado varios métodos nuevos: </p><br><ul><li><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Reflect.construct</a> es una alternativa más conveniente a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Object.create</a> , que permite no solo crear un objeto con el prototipo especificado, sino también inicializarlo de inmediato: </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Person</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">name, surname</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.name = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.formatParam(name); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.surname = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.formatParam(surname); } Person.prototype.formatParam = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">param</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> param.slice(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>).toUpperCase() + param.slice(<span class="hljs-number"><span class="hljs-number">1</span></span>).toLowerCase(); } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> oldPerson = <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.create(Person.prototype); <span class="hljs-comment"><span class="hljs-comment">// {} Person.call(oldPerson, '', ''); // {name: "", surname: ""} const newPerson = Reflect.construct(Person, ['', '']); // {name: "", surname: ""}</span></span></code> </pre> <br></li><li><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Reflect.ownKeys</a> : devuelve una matriz de propiedades que pertenecen al objeto especificado (y no a los objetos en la cadena del prototipo): </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> person = { <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">''</span></span>, <span class="hljs-attr"><span class="hljs-attr">surname</span></span>: <span class="hljs-string"><span class="hljs-string">''</span></span> }; person.__proto__ = { <span class="hljs-attr"><span class="hljs-attr">age</span></span>: <span class="hljs-number"><span class="hljs-number">30</span></span> }; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-built_in"><span class="hljs-built_in">Reflect</span></span>.ownKeys(person)); <span class="hljs-comment"><span class="hljs-comment">// ["name", "surname"]</span></span></code> </pre> <br></li><li><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Reflect.deleteProperty</a> : una alternativa al operador de <em>eliminación</em> , realizada en forma de método: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> person = { <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">''</span></span>, <span class="hljs-attr"><span class="hljs-attr">surname</span></span>: <span class="hljs-string"><span class="hljs-string">''</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> person.name; <span class="hljs-comment"><span class="hljs-comment">// person = {surname: ""} Reflect.deleteProperty(person, 'surname'); // person = {}</span></span></code> </pre> <br></li><li><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Reflect.has</a> : una alternativa al operador <em>in</em> , realizada en forma de método: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> person = { <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">''</span></span>, <span class="hljs-attr"><span class="hljs-attr">surname</span></span>: <span class="hljs-string"><span class="hljs-string">''</span></span> }; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'name'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> person); <span class="hljs-comment"><span class="hljs-comment">// true console.log(Reflect.has(person, 'name')); // true</span></span></code> </pre> <br></li><li><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Reflect.get</a> y <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Reflect.set</a> : para leer / cambiar las propiedades del objeto: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> person = { <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">''</span></span>, <span class="hljs-attr"><span class="hljs-attr">surname</span></span>: <span class="hljs-string"><span class="hljs-string">''</span></span> }; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-built_in"><span class="hljs-built_in">Reflect</span></span>.get(person, <span class="hljs-string"><span class="hljs-string">'name'</span></span>)); <span class="hljs-comment"><span class="hljs-comment">//  Reflect.set(person, 'surname', '') // person = {name: "", surname: ""}</span></span></code> </pre> <br></li></ul><br><p>  Más detalles sobre los cambios se pueden encontrar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aquí</a> . </p><br><h3 id="reflect-metadata">  Reflejar metadatos </h3><br><p>  Además de los métodos de objeto Reflect enumerados anteriormente, existe una propuesta experimental para vincular convenientemente varios metadatos a los objetos. </p><br><p>  Los metadatos pueden ser cualquier información útil que no esté directamente relacionada con el objeto, por ejemplo: </p><br><ul><li>  TypeScript, cuando el indicador <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">emitDecoratorMetadata</a> está <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">activado,</a> escribe información sobre los tipos en los metadatos, lo que le permite acceder a ellos en tiempo de ejecución.  Además, esta información se puede obtener mediante el diseño clave: tipo: <br><pre> <code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> typeData = Reflect.getMetadata(<span class="hljs-string"><span class="hljs-string">"design:type"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">object</span></span>, propertyName);</code> </pre> </li><li>  La popular biblioteca <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">InversifyJS</a> para control de inversión almacena diversa información sobre las relaciones descritas en los metadatos. </li></ul><br><p>  Por el momento, este <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">polyfill se</a> utiliza para trabajar en navegadores <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">.</a> </p><br><h2 id="5-simvoly-symbols">  5. Símbolos </h2><br><p>  Los símbolos son un nuevo tipo de datos inmutable, utilizado principalmente para crear nombres únicos para identificadores de propiedades de objeto.  Tenemos la capacidad de crear personajes de dos maneras: </p><br><ol><li><p>  Símbolos locales: el texto en los parámetros de la función Símbolo no afecta la unicidad y solo es necesario para la depuración: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> sym1 = <span class="hljs-built_in"><span class="hljs-built_in">Symbol</span></span>(<span class="hljs-string"><span class="hljs-string">'name'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> sym2 = <span class="hljs-built_in"><span class="hljs-built_in">Symbol</span></span>(<span class="hljs-string"><span class="hljs-string">'name'</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(sym1 == sym2); <span class="hljs-comment"><span class="hljs-comment">// false</span></span></code> </pre> <br></li><li><p>  Caracteres globales: los caracteres se almacenan en el registro global, por lo que los caracteres con la misma clave son iguales: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> sym3 = <span class="hljs-built_in"><span class="hljs-built_in">Symbol</span></span>.for(<span class="hljs-string"><span class="hljs-string">'name'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> sym4 = <span class="hljs-built_in"><span class="hljs-built_in">Symbol</span></span>.for(<span class="hljs-string"><span class="hljs-string">'name'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> sym5 = <span class="hljs-built_in"><span class="hljs-built_in">Symbol</span></span>.for(<span class="hljs-string"><span class="hljs-string">'other name'</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(sym3 == sym4); <span class="hljs-comment"><span class="hljs-comment">// true,        'name' console.log(sym3 == sym5); // false,    </span></span></code> </pre> <br></li></ol><br><p>  La capacidad de crear tales identificadores nos permite no tener miedo de que podamos sobrescribir alguna propiedad en un objeto desconocido para nosotros.  Esta calidad permite a los creadores del estándar agregar fácilmente nuevas propiedades estándar a los objetos, sin romper la compatibilidad con varias bibliotecas existentes (que ya podrían definir la misma propiedad) y el código de usuario.  Por lo tanto, hay varios símbolos estándar y algunos de ellos brindan nuevas oportunidades para la reflexión: </p><br><ul><li><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Symbol.iterator</a> : le permite crear sus propias reglas para iterar objetos utilizando el <em>operador</em> <em>for-of</em> o <em>... spread</em> : </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> arr = [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>]; <span class="hljs-comment"><span class="hljs-comment">//       arr[Symbol.iterator] = function() { const self = this; let pos = this.length - 1; return { next() { if (pos &gt;= 0) { return { done: false, value: self[pos--] }; } else { return { done: true }; } } } }; console.log([...arr]); // [3, 2, 1]</span></span></code> </pre> <br></li><li><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Symbol.hasInstance</a> es un método que determina si un constructor reconoce un objeto como su instancia.  Utilizado por el operador instanceof: </p><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyArray</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> [<span class="hljs-built_in"><span class="hljs-built_in">Symbol</span></span>.hasInstance](instance) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>.isArray(instance); } } <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log([] <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> MyArray); <span class="hljs-comment"><span class="hljs-comment">// true</span></span></code> </pre> <br></li><li><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Symbol.isConcatSpreadable</a> : indica si la matriz debe aplanarse cuando se concatena en Array.concat: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> firstArr = [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> secondArr = [<span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>]; firstArr.concat(secondArr); <span class="hljs-comment"><span class="hljs-comment">// [1, 2, 3, 4, 5, 6] secondArr[Symbol.isConcatSpreadable] = false; console.log(firstArr.concat(secondArr)); // [1, 2, 3, [4, 5, 6]]</span></span></code> </pre> <br></li><li><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Symbol.species</a> : le permite especificar qué constructor se usará para crear objetos derivados dentro de la clase. <br>  Por ejemplo, tenemos una clase de matriz estándar para trabajar con matrices y tiene un método .map que crea una nueva matriz basada en la actual.  Para averiguar qué clase usar para crear esta nueva matriz, Array llama a <em>this.constructor [Symbol.species] de</em> esta manera: </p><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>.prototype.map = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">cb</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> ArrayClass = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.constructor[<span class="hljs-built_in"><span class="hljs-built_in">Symbol</span></span>.species]; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> result = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayClass(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.length); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.forEach(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">value, index, arr</span></span></span><span class="hljs-function">) =&gt;</span></span> { result[index] = cb(value, index, arr); }); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; }</code> </pre> <br><p>  Por lo tanto, anulando Symbol.species, podemos crear nuestra propia clase para trabajar con matrices y decir que todos los métodos estándar como .map, .reduce, etc. no devuelven una instancia de la clase Array, sino una instancia de nuestra clase: </p><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyArray</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Array</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> get [<span class="hljs-built_in"><span class="hljs-built_in">Symbol</span></span>.species]() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> arr = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MyArray(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>); <span class="hljs-comment"><span class="hljs-comment">// [1, 2, 3] console.log(arr instanceof MyArray); // true console.log(arr instanceof Array); // true //   Array.map     Array,    Symbol.species  this      MyArray const doubledArr = arr.map(x =&gt; x * 2); console.log(doubledArr instanceof MyArray); // true console.log(doubledArr instanceof Array); // true</span></span></code> </pre> <br><p>  Por supuesto, esto funciona no solo con matrices, sino también con otras clases estándar.  Además, incluso si simplemente creamos nuestra propia clase con métodos que devuelven nuevas instancias de la misma clase, deberíamos usar this.constructor [Symbol.species] para obtener una referencia al constructor. </p><br></li><li><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Symbol.toPrimitive</a> : le permite especificar cómo convertir nuestro objeto a un valor primitivo.  Si antes, para reducir a una primitiva, necesitábamos usar toString junto con valueOf, ahora todo se puede hacer en un método conveniente: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> figure = { <span class="hljs-attr"><span class="hljs-attr">id</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">''</span></span>, [<span class="hljs-built_in"><span class="hljs-built_in">Symbol</span></span>.toPrimitive](hint) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (hint === <span class="hljs-string"><span class="hljs-string">'string'</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.name; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (hint === <span class="hljs-string"><span class="hljs-string">'number'</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.id; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-comment"><span class="hljs-comment">// default return this.name; } } } console.log(`${figure}`); // hint = string console.log(+figure); // hint = number console.log(figure + ''); // hint = default</span></span></code> </pre> <br></li><li><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Symbol.match</a> : le permite crear sus propias clases de manejador para el método de la función <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">String.prototype.match</a> : </p><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">StartAndEndsWithMatcher</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(value) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.value = value; } [<span class="hljs-built_in"><span class="hljs-built_in">Symbol</span></span>.match](str) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> startsWith = str.startsWith(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.value); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> endsWith = str.endsWith(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.value); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (startsWith &amp;&amp; endsWith) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.value]; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> testMatchResult = <span class="hljs-string"><span class="hljs-string">'||'</span></span>.match(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StartAndEndsWithMatcher(<span class="hljs-string"><span class="hljs-string">'|'</span></span>)); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(testMatchResult); <span class="hljs-comment"><span class="hljs-comment">// ["|"] const catMatchResult = '|'.match(new StartAndEndsWithMatcher('|')); console.log(catMatchResult) // null</span></span></code> </pre> <br><p>     — <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Symbol.replace</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Symbol.search</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Symbol.split</a>     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">String.prototype</a> . </p><br></li></ul><br><p>  ,   (  reflect-metadata   )         .  -   ,    ,       .        : </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> validationRules = <span class="hljs-built_in"><span class="hljs-built_in">Symbol</span></span>(<span class="hljs-string"><span class="hljs-string">'validationRules'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> person = { <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">''</span></span>, <span class="hljs-attr"><span class="hljs-attr">surname</span></span>: <span class="hljs-string"><span class="hljs-string">''</span></span> }; person[validationRules] = { <span class="hljs-attr"><span class="hljs-attr">name</span></span>: [<span class="hljs-string"><span class="hljs-string">'max-length-256'</span></span>, <span class="hljs-string"><span class="hljs-string">'required'</span></span>], <span class="hljs-attr"><span class="hljs-attr">surname</span></span>: [<span class="hljs-string"><span class="hljs-string">'max-length-256'</span></span>] };</code> </pre> <br><h2 id="6-proksi-proxy"> 6.  (Proxy) </h2><br><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Proxy</a>    ,    Reflect API  Symbols  ES6,       //  ,  ,       .  ,  <em>   </em> . </p><br><p>           ,    data-binding  MobX  React, Vue  .       . </p><br><p>  : </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> formData = { <span class="hljs-attr"><span class="hljs-attr">login</span></span>: <span class="hljs-string"><span class="hljs-string">'User'</span></span>, <span class="hljs-attr"><span class="hljs-attr">password</span></span>: <span class="hljs-string"><span class="hljs-string">'pass'</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> proxyFormData = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Proxy</span></span>(formData, { set(target, name, value) { target[name] = value; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.forceUpdate(); <span class="hljs-comment"><span class="hljs-comment">//   React- } }); //       forceUpdate()    React proxyFormData.login = 'User2'; //     ,   -      proxyFormData.age = 20;</span></span></code> </pre> <br><p>        ,  /: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> formData = { <span class="hljs-attr"><span class="hljs-attr">login</span></span>: <span class="hljs-string"><span class="hljs-string">'User'</span></span>, <span class="hljs-attr"><span class="hljs-attr">password</span></span>: <span class="hljs-string"><span class="hljs-string">'pass'</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> proxyFormData = {}; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> param <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> formData) { <span class="hljs-built_in"><span class="hljs-built_in">Reflect</span></span>.defineProperty(proxyFormData, <span class="hljs-string"><span class="hljs-string">`__private__</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${param}</span></span></span><span class="hljs-string">`</span></span>, { <span class="hljs-attr"><span class="hljs-attr">value</span></span>: formData[param], <span class="hljs-attr"><span class="hljs-attr">enumerable</span></span>: <span class="hljs-literal"><span class="hljs-literal">false</span></span>, <span class="hljs-attr"><span class="hljs-attr">configurable</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span> }); <span class="hljs-built_in"><span class="hljs-built_in">Reflect</span></span>.defineProperty(proxyFormData, param, { <span class="hljs-attr"><span class="hljs-attr">get</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>[<span class="hljs-string"><span class="hljs-string">`__private__</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${param}</span></span></span><span class="hljs-string">`</span></span>]; }, <span class="hljs-attr"><span class="hljs-attr">set</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">value</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>[<span class="hljs-string"><span class="hljs-string">`__private__</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${param}</span></span></span><span class="hljs-string">`</span></span>] = value; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.forceUpdate(); <span class="hljs-comment"><span class="hljs-comment">//   React- }, enumerable: true, configurable: true }); } //       forceUpdate()    React proxyFormData.login = 'User2'; //                  -  Reflect.defineProperty proxyFormData.age = 20;</span></span></code> </pre> <br><p>          -,     —   Proxy            (  ,       ),    /             ,           <em>delete obj[name]</em> . </p><br><h2 id="7-zaklyuchenie"> 7.  </h2><br><p> JavaScript        ,           ECMAScript 4,             .               ,   . </p><br><p>             <a href="">  </a>   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">You Don't Know JS</a> . </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es417097/">https://habr.com/ru/post/es417097/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es417085/index.html">Los navegadores silencian el sonido en su aplicación WebRTC. ¿Detener qué?</a></li>
<li><a href="../es417087/index.html">HPE Digitize 2018: evento y transmisión en vivo</a></li>
<li><a href="../es417089/index.html">Computadora cuántica: un fotón para gobernar todo</a></li>
<li><a href="../es417091/index.html">Crea un sombreador de agua de dibujos animados para la web. Parte 3</a></li>
<li><a href="../es417093/index.html">Interruptores táctiles con Modbus: por qué son necesarios y cómo aplicarlos en un apartamento inteligente</a></li>
<li><a href="../es417099/index.html">¿Cómo escribí la biblioteca estándar de C ++ 11 o por qué boost es tan aterrador? Capítulo 2</a></li>
<li><a href="../es417101/index.html">Definición de Listo: lo que olvidamos contar</a></li>
<li><a href="../es417103/index.html">Spark SQL. Un poco sobre el optimizador de consultas</a></li>
<li><a href="../es417105/index.html">Impresión en una impresora 3D. Experiencias secretas de 3Dtool</a></li>
<li><a href="../es417107/index.html">Creador del juego mientras es verdadero: aprenda () sobre la programación de gamedev, los problemas de realidad virtual y las simulaciones de ML</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>