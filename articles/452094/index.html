<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üòæ üóûÔ∏è üßïüèª .NET: Herramientas para trabajar con subprocesos m√∫ltiples y asincron√≠a. Parte 1 üßë üë©‚Äç‚öïÔ∏è üé∫</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Publico el art√≠culo original sobre Habr, cuya traducci√≥n se publica en el blog Codingsight . 
 La segunda parte est√° disponible aqu√≠. 

 La necesidad ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>.NET: Herramientas para trabajar con subprocesos m√∫ltiples y asincron√≠a. Parte 1</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/452094/">  <i>Publico el art√≠culo original sobre Habr, cuya traducci√≥n se publica en el blog <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Codingsight</a> .</i> <br>  <i>La segunda parte est√° disponible <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aqu√≠.</a></i> <br><br>  La necesidad de hacer algo de forma asincr√≥nica, sin esperar el resultado aqu√≠ y ahora, o compartir mucho trabajo entre varias unidades que lo realizaban, fue incluso antes del advenimiento de las computadoras.  Con su apariencia, tal necesidad se ha vuelto muy tangible.  Ahora, en 2019, escribiendo este art√≠culo en una computadora port√°til con un procesador Intel Core de 8 n√∫cleos, en el que no funcionan cien procesos al mismo tiempo, sino incluso m√°s subprocesos.  Junto a √©l se encuentra un tel√©fono ligeramente maltratado, comprado hace un par de a√±os, con un procesador de 8 n√∫cleos a bordo.  Los recursos tem√°ticos est√°n llenos de art√≠culos y videos donde sus autores admiran los tel√©fonos inteligentes emblem√°ticos de este a√±o donde colocan procesadores de 16 n√∫cleos.  Por menos de $ 20 / hora, MS Azure proporciona una m√°quina virtual con 128 procesadores centrales y 2 TB de RAM.  Desafortunadamente, es imposible maximizar y frenar este poder sin poder controlar la interacci√≥n de los flujos. <br><a name="habracut"></a><br><h3>  Terminolog√≠a </h3><br>  <b>Proceso</b> : un objeto del sistema operativo, un espacio de direcciones aislado, contiene subprocesos. <br>  <b>Thread (Thread)</b> : un objeto del sistema operativo, la unidad de ejecuci√≥n m√°s peque√±a, parte de un proceso, los hilos comparten memoria y otros recursos entre s√≠ dentro del proceso. <br>  <b>La multitarea</b> es una caracter√≠stica del sistema operativo, la capacidad de ejecutar m√∫ltiples procesos al mismo tiempo <br>  <b>Multin√∫cleo</b> : una propiedad del procesador, la capacidad de usar m√∫ltiples n√∫cleos para el procesamiento de datos <br>  <b>Multiprocesamiento</b> : una propiedad de una computadora, la capacidad de trabajar simult√°neamente con m√∫ltiples procesadores f√≠sicamente <br>  <b>El</b> subprocesamiento m√∫ltiple es una propiedad de un proceso, la capacidad de distribuir el procesamiento de datos entre m√∫ltiples subprocesos. <br>  <b>Paralelismo</b> : realizar varias acciones f√≠sicamente al mismo tiempo por unidad de tiempo <br>  <b>Asincron√≠a</b> : la ejecuci√≥n de una operaci√≥n sin esperar el final de este procesamiento, el resultado de la ejecuci√≥n se puede procesar m√°s adelante. <br><br><h3>  Met√°fora </h3><br>  No todas las definiciones son buenas y algunas necesitan una explicaci√≥n adicional, por lo que agregar√© una met√°fora para cocinar el desayuno a la terminolog√≠a introducida formalmente.  Preparar el desayuno en esta met√°fora es un proceso. <br><br>  Preparando el desayuno en la ma√±ana I ( <b>CPU</b> ) vengo a la cocina ( <b>Computadora</b> ).  Tengo 2 manos ( <b>n√∫cleos</b> ).  La cocina tiene varios dispositivos ( <b>IO</b> ): horno, tetera, tostadora, refrigerador.  Enciendo el gas, pongo una sart√©n y vierto el aceite all√≠, sin esperar hasta que se caliente ( <b>asincr√≥nicamente, sin bloqueo, IO-Wait</b> ), saco los huevos del refrigerador y los rompo en un plato, y luego los golpeo con una mano ( <b>Hilo # 1</b> ), y el segundo ( <b>Hilo # 2</b> ) sostengo la placa (Recurso compartido).  Ahora todav√≠a encender√≠a la tetera, pero no hay suficientes manos ( <b>Hambre de hambre</b> ) Durante este tiempo, la sart√©n se calienta (Procesando el resultado) donde vierto lo que bat√≠.  Alcanzo la tetera, la enciendo y observo est√∫pidamente c√≥mo hierve el agua ( <b>Bloqueo-IO-Espera</b> ), aunque podr√≠a lavar el plato durante este tiempo, donde bat√≠ la tortilla. <br><br>  Cocin√© una tortilla usando solo 2 manos, y no tengo m√°s, pero al mismo tiempo, 3 operaciones tuvieron lugar en el momento de batir una tortilla: batir una tortilla, sostener un plato, calentar una sart√©n. La CPU es la parte m√°s r√°pida de la computadora, IO es eso con m√°s frecuencia ralentiza todo, por lo que a menudo una soluci√≥n efectiva es tomar algo de CPU mientras recibe datos de IO. <br><br>  Continuando con la met√°fora: <br><br><ul><li>  Si en el proceso de preparar una tortilla, tambi√©n intentara cambiarme de ropa, este ser√≠a un ejemplo de multitarea.  Un matiz importante: las computadoras con esto son mucho mejores que las personas. </li><li>  Una cocina con varios chefs, por ejemplo en un restaurante, es una computadora de varios n√∫cleos. </li><li>  Muchos restaurantes de patio de comidas en un centro comercial - centro de datos </li></ul><br><h3>  Herramientas .NET </h3><br>  Al trabajar con subprocesos, como en muchas otras cosas, .NET es bueno.  Con cada nueva versi√≥n, presenta cada vez m√°s herramientas nuevas para trabajar con ellas, nuevas capas de abstracci√≥n sobre los hilos del sistema operativo.  Al trabajar con la construcci√≥n de abstracciones, los desarrolladores de framework usan el enfoque que deja la posibilidad cuando se usa abstracci√≥n de alto nivel, bajar√° uno o varios niveles por debajo.  En la mayor√≠a de los casos, esto no es necesario, adem√°s, esto abre la posibilidad de que se dispare una escopeta en el pie, pero a veces, en casos excepcionales, esta puede ser la √∫nica forma de resolver un problema que no se resuelve en el nivel actual de abstracci√≥n. <br><br>  Por herramientas, me refiero a las interfaces de programa (API) proporcionadas por el marco y los paquetes de terceros, y a una soluci√≥n de software completa que simplifica la b√∫squeda de cualquier problema asociado con el c√≥digo de subprocesos m√∫ltiples. <br><br><h4>  Inicio de transmisi√≥n </h4><br>  La clase Thread, la clase m√°s b√°sica en .NET para trabajar con hilos.  El constructor acepta uno de los dos delegados: <br><br><ul><li>  ThreadStart: sin par√°metros </li><li>  ParametrizedThreadStart: con un par√°metro de tipo objeto. </li></ul><br>  El delegado se ejecutar√° en el subproceso reci√©n creado despu√©s de llamar al m√©todo Start, si un delegado del tipo ParametrizedThreadStart se pas√≥ al constructor, se debe pasar un objeto al m√©todo Start.  Este mecanismo es necesario para transferir cualquier informaci√≥n local a la secuencia.  Vale la pena se√±alar que crear una secuencia es una operaci√≥n costosa, y la secuencia en s√≠ misma es un objeto pesado, al menos porque se asigna 1 MB de memoria a la pila, y requiere interacci√≥n con la API del sistema operativo. <br><br><pre><code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Thread(...).Start(...);</code> </pre> <br>  La clase ThreadPool representa el concepto de un grupo.  En .NET, el grupo de subprocesos es una obra de arte y los desarrolladores de Microsoft se han esforzado mucho para que funcione de manera √≥ptima en una amplia variedad de escenarios. <br><br>  <b>Concepto general:</b> <br><br>  <i>Desde el comienzo, la aplicaci√≥n en segundo plano crea varios subprocesos en reserva y brinda la oportunidad de ponerlos en uso.</i>  <i>Si los hilos se usan con frecuencia y en grandes cantidades, el grupo se expande para satisfacer la necesidad del c√≥digo de llamada.</i>  <i>Cuando no hay flujos libres en la agrupaci√≥n en el momento adecuado, esperar√° a que regrese uno de los flujos o crear√° uno nuevo.</i>  <i>De ello se deduce que el grupo de subprocesos es ideal para algunas acciones cortas y poco adecuado para operaciones que operan como un servicio en toda la aplicaci√≥n.</i> <i><br><br></i>  <i>Para usar un subproceso del grupo, hay un m√©todo QueueUserWorkItem que acepta un delegado de tipo WaitCallback, que es la misma firma que ParametrizedThreadStart, y el par√°metro que se le pasa realiza la misma funci√≥n.</i> <br><br><pre> <code class="cs hljs">ThreadPool.QueueUserWorkItem(...);</code> </pre><br>  El m√©todo de grupo de subprocesos menos conocido RegisterWaitForSingleObject se utiliza para organizar operaciones de E / S sin bloqueo.  El delegado pasado a este m√©todo se llamar√° cuando WaitHandle pasado al m√©todo est√© "Liberado". <br><br><pre> <code class="cs hljs">ThreadPool.RegisterWaitForSingleObject(...)</code> </pre><br>  .NET tiene un temporizador de flujo y se diferencia de los temporizadores WinForms / WPF en que su controlador se llamar√° en un flujo tomado del grupo. <br><br><pre> <code class="cs hljs">System.Threading.Timer</code> </pre><br>  Tambi√©n hay una forma bastante ex√≥tica de enviar un delegado al hilo desde el grupo: el m√©todo BeginInvoke. <br><br><pre> <code class="cs hljs">DelegateInstance.BeginInvoke</code> </pre><br>  Tambi√©n quiero detenerme en transmitir una funci√≥n que llama a muchos de los m√©todos anteriores: CreateThread desde Kernel32.dll Win32 API.  Hay una manera, gracias al mecanismo de m√©todos externos, de llamar a esta funci√≥n.  Vi tal desaf√≠o solo una vez en un terrible ejemplo de c√≥digo heredado, y la motivaci√≥n del autor para hacer eso sigue siendo un misterio para m√≠. <br><br><pre> <code class="cs hljs">Kernel32.dll CreateThread</code> </pre><br><h4>  Ver y depurar hilos </h4><br>  Los hilos que cre√≥ personalmente por todos los componentes de terceros y el grupo .NET se pueden ver en la ventana Threads de Visual Studio.  Esta ventana mostrar√° informaci√≥n sobre los flujos solo cuando la aplicaci√≥n est√© en depuraci√≥n y en modo de interrupci√≥n (modo de interrupci√≥n).  Aqu√≠ puede ver convenientemente los nombres de pila y las prioridades de cada subproceso, cambiar la depuraci√≥n a un subproceso espec√≠fico.  La propiedad Prioridad de la clase Thread le permite establecer la prioridad del hilo, que OC y CLR percibir√°n como una recomendaci√≥n al dividir el tiempo de CPU entre los hilos. <br><br><img src="https://habrastorage.org/webt/ow/kq/i5/owkqi5zdx2m8oe7iava3q1mikri.png"><br><br><h4>  Biblioteca paralela de tareas </h4><br>  La biblioteca paralela de tareas (TPL) apareci√≥ en .NET 4.0.  Ahora es el est√°ndar y la herramienta principal para trabajar con asincron√≠a.  Cualquier c√≥digo que use un enfoque anterior se considera heredado.  La unidad b√°sica de TPL es la clase Task del espacio de nombres System.Threading.Tasks.  La tarea es una abstracci√≥n sobre un hilo.  Con la nueva versi√≥n de C #, obtuvimos una forma elegante de trabajar con Task: operadores as√≠ncronos / en espera.  Estos conceptos hicieron posible escribir c√≥digo asincr√≥nico como si fuera simple y sincr√≥nico, esto hizo posible que incluso las personas con poca comprensi√≥n de la cocina interna de hilos escriban aplicaciones que los usan, aplicaciones que no se congelan durante operaciones largas.  El uso de async / await es un tema para uno o incluso varios art√≠culos, pero intentar√© obtener la esencia de algunas oraciones: <br><br><ul><li>  async es un modificador del m√©todo que devuelve Task o void </li><li>  y esperar es la declaraci√≥n de espera sin bloqueo de la tarea. </li></ul><br>  Una vez m√°s: el operador de espera, en el caso general (hay excepciones), liberar√° a√∫n m√°s el hilo de ejecuci√≥n actual, y cuando la Tarea termine su ejecuci√≥n, y el hilo (de hecho es m√°s correcto decir el contexto, pero m√°s sobre eso m√°s adelante) ser√° libre de continuar el m√©todo.  Dentro de .NET, este mecanismo se implementa de la misma manera que el rendimiento de rendimiento, cuando un m√©todo escrito se convierte en una clase completa, que es una m√°quina de estados y puede ejecutarse en partes separadas dependiendo de estos estados.  Cualquier persona interesada puede escribir cualquier c√≥digo simple usando asyn / await, compilar y ver el ensamblaje usando JetBrains dotPeek con el c√≥digo generado por el compilador habilitado. <br><br>  Considere las opciones para iniciar y usar Tarea.  Usando el siguiente ejemplo de c√≥digo, creamos una nueva tarea que no hace nada √∫til ( <i>Thread.Sleep (10000)</i> ), pero en la vida real deber√≠a ser alg√∫n tipo de trabajo complejo que involucra CPU. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> TCO = System.Threading.Tasks.TaskCreationOptions; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">VoidAsyncMethod</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> cancellationSource = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CancellationTokenSource(); <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> Task.Factory.StartNew( <span class="hljs-comment"><span class="hljs-comment">// Code of action will be executed on other context () =&gt; Thread.Sleep(10000), cancellationSource.Token, TCO.LongRunning | TCO.AttachedToParent | TCO.PreferFairness, scheduler ); // Code after await will be executed on captured context }</span></span></code> </pre><br>  La tarea se crea con una serie de opciones: <br><br><ul><li>  LongRunning es una pista de que la tarea no se completar√° r√°pidamente, lo que significa que puede valer la pena considerar no tomar un hilo del grupo, sino crear uno separado para esta Tarea para no da√±ar a los dem√°s. </li><li>  AttachedToParent: las tareas se pueden organizar en una jerarqu√≠a.  Si se utiliz√≥ esta opci√≥n, la Tarea puede estar en un estado cuando se ha completado y est√° esperando a que se completen los ni√±os. </li><li>  PreferFairness: significa que ser√≠a bueno ejecutar las tareas enviadas antes para su ejecuci√≥n antes de las que se enviaron m√°s tarde.  Pero esto es solo una recomendaci√≥n y el resultado no est√° garantizado. </li></ul><br>  El segundo par√°metro para el m√©todo pas√≥ CancellationToken.  Para procesar correctamente la cancelaci√≥n de una operaci√≥n despu√©s de su lanzamiento, el c√≥digo ejecutado debe completarse con verificaciones de estado de CancellationToken.  Si no hay comprobaciones, el m√©todo de cancelaci√≥n invocado en el objeto CancellationTokenSource podr√° detener la ejecuci√≥n de la tarea solo antes de que comience. <br><br>  El √∫ltimo par√°metro pas√≥ el objeto del planificador de tipo TaskScheduler.  Esta clase y sus descendientes est√°n dise√±ados para controlar las estrategias para distribuir Task'ov por subproceso, de forma predeterminada, la Tarea se ejecutar√° en un subproceso aleatorio del grupo. <br><br>  El operador de espera se aplica a la Tarea creada, lo que significa que el c√≥digo escrito despu√©s, si lo hay, se ejecutar√° en el mismo contexto (a menudo esto significa que est√° en el mismo hilo) que el c√≥digo antes de esperar. <br><br>  El m√©todo est√° marcado como vac√≠o as√≠ncrono, lo que significa que puede usar el operador de espera en √©l, pero el c√≥digo de llamada no puede esperar a la ejecuci√≥n.  Si esta caracter√≠stica es necesaria, entonces el m√©todo deber√≠a devolver la Tarea.  Los m√©todos marcados como nulo as√≠ncrono son bastante comunes: por regla general, estos son controladores de eventos u otros m√©todos que funcionan seg√∫n el principio de disparar y olvidar.  Si necesita no solo dar la oportunidad de esperar hasta la finalizaci√≥n de la ejecuci√≥n, sino tambi√©n devolver el resultado, debe usar Tarea. <br><br>  Sin embargo, en la Tarea que devolvi√≥ el m√©todo StartNew, como en cualquier otro, puede llamar al m√©todo ConfigureAwait con el par√°metro falso, luego la ejecuci√≥n despu√©s de esperar continuar√° no en el contexto capturado, sino en uno arbitrario.  Esto siempre debe hacerse cuando el contexto de ejecuci√≥n no es importante para el c√≥digo despu√©s de esperar.  Tambi√©n es una recomendaci√≥n de MS al escribir c√≥digo que vendr√° empaquetado en forma de biblioteca. <br><br>  Deteng√°monos un poco m√°s sobre c√≥mo puede esperar hasta la finalizaci√≥n de la Tarea.  A continuaci√≥n se muestra un c√≥digo de muestra, con comentarios, cuando la espera se realiza condicionalmente buena y cuando es condicionalmente mala. <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AnotherMethod</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> result = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> AsyncMethod(); <span class="hljs-comment"><span class="hljs-comment">// good result = AsyncMethod().Result; // bad AsyncMethod().Wait(); // bad IEnumerable&lt;Task&gt; tasks = new Task[] { AsyncMethod(), OtherAsyncMethod() }; await Task.WhenAll(tasks); // good await Task.WhenAny(tasks); // good Task.WaitAll(tasks.ToArray()); // bad }</span></span></code> </pre><br>  En el primer ejemplo, esperamos que la Tarea se complete y sin bloquear el hilo de llamada, volveremos a procesar el resultado solo cuando ya est√© all√≠, hasta que el hilo de llamada se deje solo. <br><br>  En la segunda opci√≥n, bloqueamos el hilo de llamada hasta que se calcule el resultado del m√©todo.  Esto es malo no solo porque tomamos el hilo, un recurso tan valioso del programa, por simple inactividad, sino tambi√©n porque si el c√≥digo del m√©todo que llamamos ha esperado, y el contexto de sincronizaci√≥n implica volver al hilo de llamada despu√©s de esperar, entonces obtendremos un punto muerto : el hilo de llamada espera hasta que se calcule el resultado del m√©todo asincr√≥nico, el m√©todo asincr√≥nico intenta en vano continuar su ejecuci√≥n en el hilo de llamada. <br><br>  Otro inconveniente de este enfoque es el complicado manejo de errores.  El hecho es que los errores en el c√≥digo asincr√≥nico cuando se usa async / await son muy f√°ciles de manejar: se comportan como si el c√≥digo fuera s√≠ncrono.  Si bien, si aplicamos <s>exorcismo,</s> expectativa sincr√≥nica a la tarea, la excepci√≥n original se convierte en una excepci√≥n agregada, es decir  Para manejar una excepci√≥n, tendr√° que examinar el tipo InnerException y escribir la cadena if dentro de un bloque catch o usar el catch cuando se construye en lugar de la cadena de bloque catch m√°s familiar en C #. <br><br>  El tercer y √∫ltimo ejemplo tambi√©n est√°n marcados como malos por la misma raz√≥n y contienen los mismos problemas. <br><br>  Los m√©todos WhenAny y WhenAll son extremadamente convenientes para esperar un grupo de Task'ov, envuelven un grupo de Task'ov en uno, que funcionar√° en la primera operaci√≥n de Task'a del grupo o cuando todos terminen su ejecuci√≥n. <br><br><h4>  Parada de flujo </h4><br>  Por varias razones, puede ser necesario detener la transmisi√≥n despu√©s de que comience.  Hay varias formas de hacer esto.  La clase Thread tiene dos m√©todos con nombres apropiados: <b>Abortar</b> e <b>Interrumpir</b> .  El primero no se recomienda para su uso, ya que  despu√©s de que se llame en cualquier momento aleatorio, durante el procesamiento de cualquier instrucci√≥n, se lanzar√° una <b>ThreadAbortedException</b> .  No espera que una excepci√≥n de este tipo se bloquee al incrementar una variable entera, ¬øverdad?  Y cuando se usa este m√©todo, esta es una situaci√≥n muy real.  Si desea evitar que el CLR arroje dicha excepci√≥n en una secci√≥n espec√≠fica del c√≥digo, puede envolverla en llamadas a <b>Thread.BeginCriticalRegion</b> , <b>Thread.EndCriticalRegion</b> .  Cualquier c√≥digo escrito en un bloque finalmente est√° envuelto con tales llamadas.  Por esta raz√≥n, en las entra√±as del c√≥digo marco, puede encontrar bloques con un intento vac√≠o, pero no un vac√≠o finalmente.  Microsoft no recomienda usar este m√©todo que no lo incluyeron en .net core. <br><br>  El m√©todo de interrupci√≥n funciona de manera m√°s predecible.  Puede interrumpir un subproceso con la excepci√≥n de <b>ThreadInterruptedException</b> solo cuando el subproceso est√° en estado inactivo.  En este estado, se suspende mientras espera WaitHandle, lock o despu√©s de llamar a Thread.Sleep. <br><br>  Ambas opciones descritas anteriormente son malas para su imprevisibilidad.  La soluci√≥n es usar la estructura <b>CancellationToken</b> y la clase <b>CancellationTokenSource</b> .  La conclusi√≥n es: se crea una instancia de la clase CancellationTokenSource y solo la persona propietaria puede detener la operaci√≥n llamando al m√©todo <b>Cancel</b> .  Solo el CancellationToken se pasa a la operaci√≥n misma.  Los propietarios de CancellationToken no pueden cancelar la operaci√≥n ellos mismos, pero solo pueden verificar si la operaci√≥n ha sido cancelada.  Para hacer esto, hay una propiedad booleana <b>IsCancellationRequested</b> y el m√©todo <b>ThrowIfCancelRequested</b> .  Este √∫ltimo generar√° una <b>TaskCancelledException</b> si se llama al m√©todo Cancel en la instancia CancellationToken cancelada de CancellationTokenSource.  Y es este m√©todo el que recomiendo usar.  Esto es mejor que las opciones anteriores al obtener el control total sobre en qu√© puntos se puede interrumpir la operaci√≥n de excepci√≥n. <br><br>  La opci√≥n m√°s cruel para detener el hilo es llamar a la funci√≥n Win32 API TerminateThread.  El comportamiento del CLR despu√©s de llamar a esta funci√≥n puede ser impredecible.  En MSDN, se escribe lo siguiente sobre esta funci√≥n: <i>‚ÄúTerminateThread es una funci√≥n peligrosa que solo debe usarse en los casos m√°s extremos.</i>  <i>"</i> <br><br><h4>  Convierta API heredada a basada en tareas utilizando el m√©todo FromAsync </h4><br>  Si tiene la suerte de trabajar en un proyecto que se inici√≥ despu√©s de que se introdujeron las tareas y dej√≥ de causar un horror silencioso para la mayor√≠a de los desarrolladores, entonces no tendr√° que lidiar con muchas API antiguas, tanto de terceros como de las que su equipo tortur√≥ en el pasado.  Afortunadamente, el equipo de desarrollo de .NET Framework nos cuid√≥, aunque quiz√°s el objetivo era cuidarnos a nosotros mismos.  Sea como fuere, .NET tiene una serie de herramientas para convertir sin problemas el c√≥digo escrito en viejos enfoques de programaci√≥n asincr√≥nica a uno nuevo.  Uno de ellos es el m√©todo FromAsync de TaskFactory.  Usando el siguiente ejemplo de c√≥digo, envuelvo los viejos m√©todos asincr√≥nicos de la clase WebRequest en Tarea usando este m√©todo. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">object</span></span> state = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; WebRequest wr = WebRequest.CreateHttp(<span class="hljs-string"><span class="hljs-string">"http://github.com"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> Task.Factory.FromAsync( wr.BeginGetResponse, we.EndGetResponse );</code> </pre><br>  <i>Este es solo un ejemplo y es poco probable que lo haga con los tipos integrados, pero cualquier proyecto antiguo simplemente est√° repleto de m√©todos BeginDoSomething que devuelven los m√©todos IAsyncResult y EndDoSomething que lo aceptan.</i> <br><br><h4>  Convierta API heredada a basada en tareas usando la clase TaskCompletionSource </h4><br>  Otra herramienta importante a considerar es la clase <b>TaskCompletionSource</b> .  En t√©rminos de funciones, prop√≥sito y principio de funcionamiento, de alguna manera puede recordar el m√©todo RegisterWaitForSingleObject de la clase ThreadPool sobre la que escrib√≠ anteriormente.  Con esta clase, puede envolver API asincr√≥nicas antiguas de manera f√°cil y conveniente en Task. <br><br>  <i>Dir√°s que ya habl√© sobre el m√©todo FromAsync de la clase TaskFactory destinada a estos fines.</i>  <i>Aqu√≠ tendremos que recordar toda la historia del desarrollo de modelos as√≠ncronos en .net que Microsoft ha estado ofreciendo durante los √∫ltimos 15 a√±os: antes del Patr√≥n As√≠ncrono Basado en Tareas (TAP) hab√≠a un Patr√≥n de Programaci√≥n Asincr√≥nico (APP), que trataba sobre los m√©todos <b>Begin</b> DoSomething que devuelven los m√©todos <b>IAsyncResult</b> y <b>End</b> DoSomething que lo aceptan y el m√©todo FromAsync est√° bien para el legado de estos a√±os, pero con el tiempo, fue reemplazado por un patr√≥n asincr√≥nico basado en eventos ( <b>EAP</b> ), que supon√≠a que se llamar√≠a a un evento al finalizar la operaci√≥n asincr√≥nica.</i> <br><br>  TaskCompletionSource es excelente para envolver en Task y API heredada construida alrededor del modelo de evento.  La esencia de su trabajo es la siguiente: un objeto de esta clase tiene una propiedad p√∫blica de tipo Tarea cuyo estado puede controlarse mediante los m√©todos SetResult, SetException, etc. de la clase TaskCompletionSource.  En los lugares donde se aplic√≥ el operador de espera a esta Tarea, se ejecutar√° o se bloquear√° con una excepci√≥n, seg√∫n el m√©todo aplicado a TaskCompletionSource.  Si todo a√∫n no est√° claro, veamos este ejemplo de c√≥digo, donde alguna API EAP antigua est√° envuelta en la Tarea usando TaskCompletionSource: cuando se dispara el evento, la Tarea se transferir√° al estado Completado, y el m√©todo que aplic√≥ el operador de espera a esta Tarea reanudar√° la ejecuci√≥n obteniendo el objeto <b>resultado</b> . <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Task&lt;Result&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DoAsync</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-function"><span class="hljs-params"> SomeApiInstance someApiObj</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> completionSource = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> TaskCompletionSource&lt;Result&gt;(); someApiObj.Done += result =&gt; completionSource.SetResult(result); someApiObj.Do(); result completionSource.Task; }</code> </pre><br><h4>  TaskCompletionSource Consejos y trucos </h4><br>  Ajustar las API m√°s antiguas no es todo lo que puede hacer con TaskCompletionSource.  El uso de esta clase abre una posibilidad interesante de dise√±ar varias API en tareas que no ocupan subprocesos.  Y el flujo, como recordamos, es un recurso costoso y su n√∫mero es limitado (principalmente por RAM).  Esta limitaci√≥n se logra f√°cilmente mediante el desarrollo, por ejemplo, de una aplicaci√≥n web cargada con l√≥gica empresarial compleja.  Considere las posibilidades de las que estoy hablando para implementar un truco como Long-Polling. <br><br>  <i>En resumen, la esencia del truco es la siguiente: necesita obtener informaci√≥n de la API sobre algunos eventos que ocurren de forma paralela, mientras que la API por alguna raz√≥n no puede informar el evento, pero solo puede devolver el estado.</i>  <i>Un ejemplo de esto es todas las API creadas sobre HTTP antes de los tiempos de WebSocket o cuando es imposible por alguna raz√≥n usar esta tecnolog√≠a.</i>  <i>El cliente puede preguntarle al servidor HTTP.</i>  <i>Un servidor HTTP no puede provocar la comunicaci√≥n con un cliente.</i>  <i>Una soluci√≥n simple es interrogar al servidor por temporizador, pero esto crea una carga adicional en el servidor y un retraso adicional en promedio TimerInterval / 2. Para solucionar este problema, se invent√≥ un truco llamado Long Polling, que consiste en retrasar la respuesta del servidor hasta que expire el tiempo de espera o Un evento suceder√°.</i>  <i>Si se ha producido un evento, se procesa; de lo contrario, la solicitud se vuelve a enviar.</i> <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(!eventOccures &amp;&amp; !timeoutExceeded) { CheckTimout(); CheckEvent(); Thread.Sleep(<span class="hljs-number"><span class="hljs-number">1</span></span>); }</code> </pre><br>  Pero tal soluci√≥n se mostrar√° terriblemente tan pronto como aumente el n√∫mero de clientes que esperan el evento, porque  Cada uno de estos clientes, en previsi√≥n del evento, ocupa una secuencia completa.  S√≠, y tenemos un retraso adicional de 1 ms en la operaci√≥n del evento, la mayor√≠a de las veces no es significativo, pero ¬øpor qu√© empeorar el software de lo que puede ser?  Si elimina Thread.Sleep (1), en vano cargaremos un n√∫cleo de procesador al 100% inactivo, girando en un ciclo in√∫til.  Con TaskCompletionSource, puede rehacer f√°cilmente este c√≥digo y resolver todos los problemas identificados anteriormente: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">LongPollingApi</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Dictionary&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, TaskCompletionSource&lt;Msg&gt;&gt; tasks; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> Task&lt;Msg&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AcceptMessageAsync</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> userId, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> duration</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> cs = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> TaskCompletionSource&lt;Msg&gt;(); tasks[userId] = cs; <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> Task.WhenAny(Task.Delay(duration), cs.Task); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> cs.Task.IsCompleted ? cs.Task.Result : <span class="hljs-literal"><span class="hljs-literal">null</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SendMessage</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> userId, Msg m</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (tasks.TryGetValue(userId, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> completionSource)) completionSource.SetResult(m); } }</code> </pre><br>  <i>Este c√≥digo no est√° listo para producci√≥n, sino solo una demostraci√≥n.</i>  <i>Para usarlo en casos reales, debe al menos manejar la situaci√≥n cuando llega un mensaje en un momento en que nadie lo espera: en este caso, el m√©todo AsseptMessageAsync deber√≠a devolver una tarea ya completada.</i>  <i>Si este caso es el m√°s frecuente, puede pensar en usar ValueTask.</i> <br><br>  Al recibir una solicitud de mensaje, creamos y colocamos TaskCompletionSource en el diccionario, y luego esperamos lo que sucede primero: el intervalo de tiempo especificado expira o se recibe un mensaje. <br><br><h4>  ValueTask: por qu√© y c√≥mo </h4><br>  Los operadores as√≠ncronos / en espera, como el operador de retorno de rendimiento, generan una m√°quina de estado a partir del m√©todo, que est√° creando un nuevo objeto, que casi siempre no es importante, pero en casos raros puede crear un problema.  Este caso puede ser un m√©todo llamado con mucha frecuencia, que habla de decenas y cientos de miles de llamadas por segundo.  Si dicho m√©todo se escribe de modo que en la mayor√≠a de los casos devuelva un resultado sin pasar por todos los m√©todos en espera, .NET proporciona una herramienta para optimizar esto: la estructura ValueTask.  Para que quede claro, considere un ejemplo de su uso: hay un cach√© al que vamos muy a menudo.  Hay algunos valores en √©l y luego los devolvemos, si no, entonces vamos a alg√∫n IO lento detr√°s de ellos.  Quiero hacer esto √∫ltimo de forma as√≠ncrona, lo que significa que todo el m√©todo es as√≠ncrono.  Por lo tanto, la forma obvia de escribir un m√©todo es la siguiente: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> Task&lt;</span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">string</span></span></span><span class="hljs-function">&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetById</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> id</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cache.TryGetValue(id, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> val)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> val; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> RequestById(id); }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Debido al deseo de optimizar un poco y un ligero temor a lo que generar√° Roslyn al compilar este c√≥digo, podemos reescribir este ejemplo de la siguiente manera: </font></font><br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Task&lt;</span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">string</span></span></span><span class="hljs-function">&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetById</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> id</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cache.TryGetValue(id, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> val)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Task.FromResult(val); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> RequestById(id); }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> De hecho, la soluci√≥n √≥ptima en este caso es optimizar la ruta de acceso directo, es decir, obtener el valor del diccionario sin asignaciones adicionales y cargar en el GC, mientras que en esos raros casos cuando a√∫n tenemos que ir al IO, todo seguir√° siendo positivo. / menos viejo: </font></font><br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> ValueTask&lt;</span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">string</span></span></span><span class="hljs-function">&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetById</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> id</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cache.TryGetValue(id, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> val)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ValueTask&lt;<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>&gt;(val); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ValueTask&lt;<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>&gt;(RequestById(id)); }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Echemos un vistazo m√°s de cerca a este fragmento de c√≥digo: si hay un valor en la memoria cach√©, creamos una estructura, de lo contrario, la tarea real se envolver√° en una significativa. </font><font style="vertical-align: inherit;">Al c√≥digo de llamada no le importa de qu√© manera se ejecut√≥ este c√≥digo: ValueTask desde el punto de vista de la sintaxis de C # se comportar√° como la Tarea habitual en este caso.</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> TaskSchedulers: gesti√≥n de estrategias de lanzamiento de tareas </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La siguiente API que me gustar√≠a considerar es la clase </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TaskScheduler</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> y sus derivados. </font><font style="vertical-align: inherit;">Ya mencion√© anteriormente que en TPL existe la capacidad de controlar las estrategias para distribuir Task'ov por hilo. </font><font style="vertical-align: inherit;">Dichas estrategias se definen en los descendientes de la clase TaskScheduler. </font><font style="vertical-align: inherit;">Casi cualquier estrategia que pueda ser necesaria se encontrar√° en la biblioteca </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ParallelExtensionsExtras</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , desarrollada por microsoft, pero no es parte de .NET, pero se entrega como un paquete Nuget. </font><font style="vertical-align: inherit;">Consideremos brevemente algunos de ellos:</font></font><br><br><ul><li> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CurrentThreadTaskScheduler</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : realiza la tarea en el hilo actual</font></font></li><li> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">LimitedConcurrencyLevelTaskScheduler</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : limita el n√∫mero de tareas ejecutadas simult√°neamente al par√°metro N, que se acepta en el constructor</font></font></li><li> <b>OrderedTaskScheduler</b> ‚Äî   LimitedConcurrencyLevelTaskScheduler(1),     . </li><li> <b>WorkStealingTaskScheduler</b> ‚Äî  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">work-stealing</a>    .     ThreadPool.   ,   .NET ThreadPool   ,    ,                  .        . ..      WorkStealingTaskScheduler'    ,   ThreadPool     . </li><li> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">QueuedTaskScheduler</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : le permite realizar tareas de acuerdo con las reglas de la cola con prioridades</font></font></li><li> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ThreadPerTaskScheduler</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : crea un hilo separado para cada tarea que se ejecuta en √©l. </font><font style="vertical-align: inherit;">Puede ser √∫til para tareas que se ejecutan de forma impredecible.</font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hay un buen </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">art√≠culo</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> detallado </font><font style="vertical-align: inherit;">sobre TaskSchedulers en el blog de Microsoft. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para una depuraci√≥n conveniente de todo lo relacionado con Tareas en Visual Studio, hay una ventana de Tareas. </font><font style="vertical-align: inherit;">En esta ventana, puede ver el estado actual de la tarea e ir a la l√≠nea de c√≥digo que se est√° ejecutando actualmente.</font></font><br><br><img src="https://habrastorage.org/webt/tb/fv/3l/tbfv3l-sdz-jw0mpcakbt_-lve8.png"><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> PLinq y la clase paralela </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Adem√°s de Task y todo lo que se dijo con ellos en .NET, hay dos herramientas m√°s interesantes: PLinq (Linq2Parallel) y la clase Parallel. El primero promete la ejecuci√≥n paralela de todas las operaciones de Linq en m√∫ltiples hilos. El n√∫mero de subprocesos se puede configurar con el m√©todo de extensi√≥n WithDegreeOfParallelism. Desafortunadamente, la mayor√≠a de las veces PLinq en el modo de ejecuci√≥n por defecto no tendr√° suficiente informaci√≥n sobre el interior de su fuente de datos para proporcionar una ganancia de velocidad significativa, por otro lado, el precio de intento es muy bajo: solo necesita llamar al m√©todo AsParallel frente a la cadena del m√©todo Linq y realizar pruebas de rendimiento. Adem√°s, es posible transferir a PLinq informaci√≥n adicional sobre la naturaleza de su fuente de datos utilizando el mecanismo de Particiones. Puedes leer m√°s </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">aqu√≠</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> y </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">aqu√≠.</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La clase est√°tica paralela proporciona m√©todos para iterar sobre una colecci√≥n Foreach en paralelo, ejecutar un bucle For y ejecutar m√∫ltiples delegados en paralelo a Invoke. La ejecuci√≥n del hilo actual se detendr√° hasta el final de los c√°lculos. El n√∫mero de subprocesos se puede configurar pasando ParallelOptions como √∫ltimo argumento. Usando opciones, tambi√©n puede especificar TaskScheduler y CancellationToken.</font></font><br><br><h4>  Conclusiones </h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cuando comenc√© a escribir este art√≠culo basado en los materiales de mi informe y la informaci√≥n que recolect√© durante el trabajo posterior, no esperaba que resultara tanto. </font><font style="vertical-align: inherit;">Ahora, cuando el editor de texto en el que estoy escribiendo este art√≠culo me dice con reproche que la p√°gina 15 ha desaparecido, resumir√© los resultados intermedios. </font><font style="vertical-align: inherit;">Otros trucos, API, herramientas visuales y dificultades se discutir√°n en un art√≠culo futuro. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Conclusiones:</font></font></b> <br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Debe conocer las herramientas para trabajar con subprocesos, asincron√≠a y paralelismo para utilizar los recursos de las PC modernas. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .NET tiene muchas herramientas diferentes para este prop√≥sito. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> No todos aparecieron a la vez, porque a menudo se puede encontrar legado, sin embargo, hay formas de convertir API antiguas sin mucho esfuerzo. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> El trabajo con subprocesos en .NET est√° representado por las clases Thread y ThreadPool </font></font></li><li>  Thread.Abort, Thread.Interrupt,  Win32 API TerminateThread      .      CancellationToken' </li><li>  ‚Äî  ,   .   ,     .      TaskCompletionSource </li><li>      .NET        Task'. </li><li>  c# async/await     </li><li>   Task'       TaskScheduler'  </li><li>  ValueTask      hot-paths  memory-traffic </li><li>  Tasks  Threads Visual Studio           </li><li> PLinq  ,            ,        partitioning </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="></a> ... </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/452094/">https://habr.com/ru/post/452094/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../452082/index.html">Flujo flexible de actualizaciones en la aplicaci√≥n: acelerar el proceso de actualizaci√≥n de aplicaciones en Android</a></li>
<li><a href="../452086/index.html">Qu√© hay en mi p√≠xel para ti: crear nanop√≠xeles usando metasuperficies de plasm√≥n</a></li>
<li><a href="../452088/index.html">Reconocimiento de carreteras mediante segmentaci√≥n sem√°ntica.</a></li>
<li><a href="../452090/index.html">Crear un generador de rompecabezas procesal</a></li>
<li><a href="../452092/index.html">Actualizaciones en la aplicaci√≥n: acelerar las actualizaciones de aplicaciones de Android</a></li>
<li><a href="../452098/index.html">Registros del desarrollador front-end Habr: refactor y reflex</a></li>
<li><a href="../452102/index.html">Juego de fotos para quienes gustan de los drones: brevemente sobre AirSelfie 2</a></li>
<li><a href="../452106/index.html">Invitamos a los oradores a la reuni√≥n de verano de bricolaje el 16 de junio de 2019</a></li>
<li><a href="../452108/index.html">Docker: consejos inofensivos</a></li>
<li><a href="../452110/index.html">Automatice el reemplazo del disco con Ansible</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>