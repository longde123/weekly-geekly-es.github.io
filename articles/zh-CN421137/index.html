<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🧕🏾 ⛹🏼 🤵🏾 无头Chrome的工作原理 👨🏿‍🤝‍👨🏽 ⚕️ ✌🏾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="从名称中已经很清楚，无头浏览器是没有头的东西。 在前端环境中，它是开发人员必不可少的工具，您可以使用它来测试代码，检查质量和布局是否符合要求。 Frontend Conf的Vitaliy Slobodin认为有必要更深入地了解此工具的设备。 

 在Headless Chrome的主要组成部分和功能...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>无头Chrome的工作原理</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/oleg-bunin/blog/421137/"> 从名称中已经很清楚，无头浏览器是没有头的东西。 在前端环境中，它是开发人员必不可少的工具，您可以使用它来测试代码，检查质量和布局是否符合要求。  Frontend Conf的Vitaliy Slobodin认为有必要更深入地了解此工具的设备。 <br><br> 在Headless Chrome的主要组成部分和功能下，介绍了使用Headless Chrome的有趣场景。 关于Puppeteer的第二部分是一个方便的Node.js库，用于在Google Chrome和Chromium中管理Headless模式。 <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/WPcahL2K27w" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  <strong>关于发言人：</strong> Vitaliy Slobodin-PhantomJS的前开发人员-将其关闭并掩埋的人。 有时，它有助于Konstantin Tokarev（ <u><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">annulen</a></u> ）使用QtWebKit的“复活”版本-非常QtWebKit，其中支持ES6，Flexbox和许多其他现代标准。 <br><br>  Vitaliy喜欢在空闲时间探索浏览器，挖掘WebKit，Chrome等。 今天，我们将讨论浏览器，即无头浏览器及其整个幽灵系列。 <a name="habracut"></a><br><br><h2>  <strong>什么是无头浏览器？</strong> <br></h2><br> 从名字开始，很明显这是没有头脑的。 在浏览器上下文中，这表示以下含义。 <br><br><ol><li> 它没有<strong>内容的真实呈现</strong> ，也就是说，它<strong>绘制</strong>了内存中的所有内容。 </li><li>因此，它<strong>消耗的内存更少</strong> ，因为不需要绘制图像或千兆字节的PNG，而人们尝试使用炸弹将它们放入后端。 </li><li> 它<strong>工作更快，</strong>因为它不需要在实际屏幕上呈现任何内容。 </li><li> 具有<strong>用于管理</strong>的<strong>编程接口</strong> 。 您问-他没有界面，按钮，窗口？ 如何管理？ 因此，它当然具有用于管理的界面。 </li><li> 一个重要的特性是<strong>能够在裸露的Linux服务器上安装</strong> 。 这是必要的，这样，如果您有全新安装的Ubuntu或Red Hat，则只需将二进制文件放入其中或将软件包放入其中，浏览器即可使用。 不需要萨满教或伏都教魔法。 </li></ol><br> 这是典型的基于WebKit的浏览器。 您无法掌握这些组件-这只是一个视觉图像。 <br><br><img src="https://habrastorage.org/webt/un/7p/zj/un7pzjwjsn1a3psu2augn59jmj0.jpeg"><br><br> 我们只对浏览器用户界面的顶部组件感兴趣。 这是相同的用户界面-窗口，菜单，弹出通知和其他所有内容。 <br><br><img src="https://habrastorage.org/webt/14/ds/oa/14dsoabrnydhu5hb6iovu_gd2m8.jpeg"><br><br> 这就是无头浏览器的外观。 注意区别吗？ 我们完全删除了用户界面。 他不再。  <strong>仅浏览器保留</strong> 。 <br><br> 今天我们将讨论Headless Chrome（）。 它们之间有什么区别？ 实际上，Chrome是Chromium的品牌版本，具有专有的编解码器，相同的H.264，与Google服务的集成以及所有其他功能。  Chromium只是一个开源实现。 <br><br><img src="https://habrastorage.org/webt/ti/14/-e/ti14-etgpuf8lm5euapnu1qk3rs.jpeg"><br><br> 无头Chrome的诞生日期：2016年。 如果遇到他，您可以问我一个棘手的问题：“怎么回事，我还记得2017年的消息？” 事实上，早在2016年，来自Google的工程师团队就与PhantomJS开发人员联系，当时他们才刚刚开始在Chrome中实现Headless模式。 我们编写了整个Google Docks，以及如何实现该接口等。 然后，Google希望使接口与PhantomJS完全兼容。 直到那时，工程师团队才决定不做这种兼容性。 <br><br> 稍后，我们将讨论管理接口（API）（即Chrome DevTools协议），并了解如何使用它。 <br><br> 本文将以伪造金字塔的原理为基础（来自英语伪造者）。 选择了一个好名字-木偶戏是控制其他所有人的人！ <br><br><img src="https://habrastorage.org/webt/4y/2i/lq/4y2ilqrqu3fxx8lrinrjp90zgfq.jpeg"><br><br> 金字塔的底部是无头铬-无头铬-这是什么？ <br><br><h2>  <strong>无头铬</strong> <br></h2><br><img src="https://habrastorage.org/webt/tx/id/ql/txidqlimkcdam_vcyah-fu4vlk0.jpeg"><br><br> 在中心-无头浏览器-相同的Chromium或Chrome（通常是Chromium）。 它具有所谓的渲染器（RENDERER）-绘制页面（您的窗口）内容的过程。 此外，每个标签页都需要有自己的渲染器，因此，如果您打开多个标签页，那么Chrome将启动许多渲染过程。 <br><br> 最重要的是您的应用程序。 如果我们使用Chromium或Headless Chrome，则Chrome或其他可嵌入其中的应用程序将位于其中。 最接近的类似物可以称为Steam。 所有人都知道，Steam本质上只是Steam网站的浏览器。 当然，他并非没有头脑，但与该计划相似。 <br><br> 有两种方法可以将无头Chrome嵌入（或使用）应用程序： <br><br><ol><li> 使用<strong>Puppeteer</strong>并使用Headless Chrome时为标准配置。 <br></li><li> 当您使用<strong>Headless库</strong>组件时，即实现无头模式并将其嵌入到您的应用程序中的库，例如，在C ++中。 <br></li></ol><br> 您可能会问，为什么C ++在前端？ 答案是DevTools C ++ API。 您可以通过多种方式实现和使用无头Chrome浏览器的功能。 如果使用Puppeteer，则将通过Web套接字与无头浏览器进行通信。 如果将Headless库嵌入桌面应用程序中，则将使用用C ++编写的本机接口。 <br><br> 但是除了所有这些，您还有其他事情，包括： <br><br><ul><li>  <strong>定制网络</strong> -与网络交互的定制实现。 假设您在银行或政府机构中工作，该机构由三个字母组成，以“ F”开头，并使用浏览器不支持的非常棘手的身份验证或授权协议。 因此，您可能需要网络的自定义处理程序。 您可以简单地获取已经实施的库，然后在Chrome中使用它。 </li><li>  <strong>Mojo模块</strong> 。  Mojo最接近的类似物是Node.js中的本地活页夹，它是用C ++编写的本地库。  Mojo所做的相同-您获取本机库，为其编写Mojo接口，然后可以在浏览器中调用本机库的方法。 </li></ul><br><h3> 铬成分 <br></h3><br><img src="https://habrastorage.org/webt/zh/-x/jf/zh-xjfbpq4mjz2ntcwr_tjriuhe.jpeg"><br><br> 我再次听到一个棘手的问题：“为什么我需要这个可怕的计划？ 我写了（插入您喜欢的框架的名称）。” <br><br><blockquote> 我相信开发人员应该知道他的工具如何工作。 如果您在React下写作，您应该知道React是如何工作的。 如果您使用Angular进行编写，则应该了解Angular的内幕。 <br></blockquote><br> 因为在某些情况下，例如致命错误或生产中的非常严重的错误，您必须处理好胆量，然后才可以在那里，什么地方，如何以及如何迷路。 例如，如果您编写测试或使用Headless Chrome，您也可能会遇到一些奇怪的行为和错误。 因此，我将简要介绍一下铬具有哪些成分。 当您看到较大的堆栈跟踪时，您将完全知道挖掘的方式以及如何修复它。 <br><br>  <strong>平台层</strong>的最低级别。 其组成部分： <br><br><ul><li>  <strong>Ozone</strong>是Chrome中的抽象窗口管理器，它与操作系统的窗口管理器进行交互。 在Linux上，它是X服务器或Wayland。 在Windows上，它是Windows窗口管理器。 </li><li>  <strong>Scheduler</strong>是与之相同的调度程序，没有它，我们无处不在，因为我们都知道Chrome是一个多进程应用程序，并且我们需要以某种方式解析所有线程，进程以及其他所有内容。 </li><li>  <strong>网络</strong> -浏览器应始终具有用于与网络配合使用的组件，例如，解析HTTP，创建标头，进行编辑等。 </li></ul><br>  <strong>内容层</strong>是Chrome拥有的最大组件。 它包括： <br><br><ul><li>  <strong>Blink</strong>是WebKit中基于WebCore的Web引擎。 它可以将HTML当作字符串，解析，执行JavaScript-就是这样。 他不再知道如何做：既不能使用网络，也不能画画-所有这些都发生在Blink之上。 <br> 闪烁包括：WebCore的高度修改版本-用于处理HTML和CSS的Web引擎；  V8（JavaScript引擎）； 以及我们在Chrome浏览器中使用的所有扩展程序的API，例如广告拦截器。 它还包括DevTools协议。 <br></li><li>  <strong>Content API</strong>是一个接口，您可以使用它很容易地使用Web引擎的所有功能。 由于Blink内部有很多东西（可能有超过一百万个接口），为了不迷失所有这些方法和功能，您需要一个Content API。 输入HTML，引擎将自动对其进行处理，解析DOM，构建CSS OM，执行JavaScript，运行计时器，处理程序以及其他所有内容。 <br></li></ul><br>  <strong>无头层</strong>级别-无头浏览器级别： <br><br><ul><li>  <strong>无头图书馆</strong> 。 </li><li>  <strong>Embedder API</strong>接口，用于在应用程序中嵌入Headless库。 </li><li>  <strong>客户端API</strong>是Puppeteer使用的接口。 </li></ul><br>  <strong>应用层应用层</strong> ： <br><br><ul><li> 您的应用程序（ <strong>Embedding app</strong> ）； </li><li> 小工具，例如<strong>Headless shell</strong> 。 </li></ul><br> 现在让我们从更高的深度上升，激活-现在前端将运行。 <br><br><img src="https://habrastorage.org/webt/_p/p6/10/_pp610df2doffm9nfysj-62ioea.jpeg"><br><br><h3>  Chrome DevTools协议 <br></h3><br> 我们都遇到了Chrome DevTools协议，因为我们使用Chrome中的开发人员面板或远程调试器-相同的开发工具。 如果您远程运行开发人员工具，则使用DevTools协议与浏览器进行通信。 安装调试器时，请参见代码覆盖率，使用地理位置或其他方式-所有这些操作均由DevTools控制。 <br><br><img src="https://habrastorage.org/webt/qe/wy/2b/qewy2b3vwphvwanus0zqqnnxeq4.jpeg"><br><br> 实际上，DevTools协议本身具有大量方法。 您的开发人员工具无权访问，其中可能有80％。 真的，您可以在那里做所有事情！ <br><br> 让我们看看该协议的全部含义。 实际上，这很简单。 它包含2个组件： <br><br><ol><li>  DevTools目标-您正在检查的选项卡； <br></li><li>  DevTools客户端-假设这是一个远程启动的开发人员面板。 <br></li></ol><br><img src="https://habrastorage.org/webt/-a/t8/ch/-at8chx2k1wsarzbzqhxtftflay.jpeg"><br><br> 他们使用简单的JSON进行通信： <br><br><ul><li> 该命令有一个标识符，要执行的方法的名称以及一些参数。 </li><li> 我们发送请求并得到一个看起来非常简单的答案：所需的标识符，因为使用该协议执行的所有命令都是异步的。 为了使我们始终能够比较收到哪个团队的答复，我们需要一个标识符。 </li><li> 有结果。 在我们的例子中，它是一个具有以下属性的结果对象： <strong>类型：</strong> <strong>“数字”，</strong> <strong>值：</strong> <strong>2，</strong> <strong>描述：</strong> <strong>“ 2”</strong> ，未引发任何异常： <strong>wasThrown：</strong> <strong>false。</strong> <br></li></ul><br> 但除此之外，您的标签页还可以将事件发送回给您。 假设页面上发生事件或页面上发生异常时，您将通过此协议收到通知。 <br><br><img src="https://habrastorage.org/webt/-f/nc/8g/-fnc8gvu6h9dy5p5ovh3wf0v6ua.jpeg"><br><br><img src="https://habrastorage.org/webt/h0/tx/ud/h0txudupxhjb8brbckihbe7wzum.jpeg"><br><br><h2>  <strong>木偶戏</strong> <br></h2><br> 您可以使用自己喜欢的软件包管理器安装Puppeteer-不论是yarn，npm还是其他任何软件包。 <br><br> 使用它也很容易-只需在Node.js脚本中请求它，您就可以使用它了。 <br><br><img src="https://habrastorage.org/webt/pi/ia/or/piiaoriro3hvbrm_yhvd1h-scq4.jpeg"><br><br> 使用链接<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">https://try-puppeteer.appspot.com，</a>您可以直接在网站上编写脚本，执行脚本并直接在浏览器中获取结果。 所有这些都将使用Headless Chrome来实现。 <br><br> 考虑一下Node.js下最简单的脚本： <br><br><pre><code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> puppeteer = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'puppeteer'</span></span>); <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">async</span></span></span></span><span class="hljs-function"><span class="hljs-params">(</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> browser = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> puppeteer.launch() ; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> page = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> browser.newPage(); <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> page.goto(<span class="hljs-string"><span class="hljs-string">'http://devconf.ru/'</span></span>) ; <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> page.emulateMedia(<span class="hljs-string"><span class="hljs-string">'screen'</span></span>) ; <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> page.pdf({ <span class="hljs-attr"><span class="hljs-attr">path</span></span>: <span class="hljs-string"><span class="hljs-string">'./devconf.pdf, printBackground: true }); await browser.close() ; })();</span></span></code> </pre> <br> 在这里，我们只需打开页面并将其打印为PDF。 让我们实时查看此脚本的操作： <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/WPcahL2K27w" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br> 一切都会很酷，但是还不清楚里面有什么。 当然，我们有一个无头的浏览器，但看不到任何东西。 因此，Puppeteer具有一个称为headless的特殊标志：false： <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> browser = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> puppeteer.launch({ <span class="hljs-attr"><span class="hljs-attr">headless</span></span>: <span class="hljs-literal"><span class="hljs-literal">false</span></span> });</code> </pre><br> 当您可以看到一些窗口并实时查看页面发生的情况（即脚本与页面的交互方式）时，需要以无头模式启动无头浏览器。 <br><br><img src="https://habrastorage.org/webt/qz/oo/ie/qzooiejebek5gqaww2gw9tv0sgc.jpeg"><br><br> 当我们添加此标志时，它将看起来相同的脚本。 浏览器窗口显示在左侧-更清楚。 <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/WPcahL2K27w" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  <strong>木偶的优点：</strong> <br><br>  +这是无头Chrome的Node.js库。 <br>  +支持旧版本的Node.js&gt; = 6。 <br>  +易于安装。 <br>  +用于管理整个巨型计算机的高级API。 <br><br> 无头Chrome易于安装，无需系统干预。 在第一次安装时，Puppeteer下载Chromium的版本，并将其直接安装在专门针对您的体系结构和OS的node_modules文件夹中。 您无需下载任何其他内容，它会自动执行此操作。 您还可以使用自己喜欢的Chrome版本，该版本已安装在系统上。 您也可以这样做-Puppeteer为您提供了这样的API。 <br><br> 不幸的是，如果仅进行基本安装，则也有缺点。 <br><br>  <strong>伪造者</strong> ： <br><br>  - <strong>没有顶级功能</strong> ：书签和密码的同步； 个人资料支持； 硬件加速等 <br>  - <strong>软件渲染</strong>是最重要的减号。 所有计算和渲染都在您的CPU上进行。 但是在这里，Google工程师很快就会感到惊讶-实施硬件加速的工作已经在进行中。 如果您勇敢而勇敢，现在可以尝试使用它。 <br>  -直到最近，还没有对扩展的支持-现在就可以了！ 如果您是一个狡猾的开发人员，则可以使用自己喜欢的AdBlock，指定Puppeteer的使用方式，所有广告都将被屏蔽。 <br>  - <strong>不支持音频/视频</strong> 。 因为，为什么要选择无头浏览器音频和视频。 <br><br>  <strong>木偶可以做什么：</strong> <br><br><ul><li> 隔离会话。 </li><li> 虚拟计时器。 </li><li> 拦截网络请求。 </li></ul><br> 还有一些很酷的东西，我将进一步介绍。 <br><br><h4> 会话隔离 <br></h4><br> 这是什么，它是和什么一起吃的，我们不会窒息吗？  -不要cho！ <br><br> 会话隔离是<strong>每个选项卡</strong>的<strong>单独“存储库”</strong> 。 启动Puppeteer时，可以创建一个新页面，每个新页面都可以有自己的存储库，其中包括： <br><br><ul><li> 厨师 <br></li><li> 本地存储； <br></li><li> 缓存。 <br></li></ul><br> 所有页面将彼此独立存在。 例如，这对于维持测试的原子性是必要的。 <br><br> 会话隔离<strong>在启动并行会话时节省了资源和​​时间</strong> 。 假设您正在测试以开发模式构建的网站，即未最小化捆绑包，其重量为20 MB。 如果只想缓存它，则可以告诉Puppeteer使用所有已创建页面共有的缓存，并且该捆绑包将被缓存。 <br><br> 您可以<strong>序列化会话以供以后使用</strong> 。 您编写了一个测试，以检查您网站上的特定操作。 但是您遇到了问题-该站点需要授权。 您不会在每次测试前都不断添加该站点上的授权。  Puppeteer允许您登录到该站点一次，然后在将来再次使用此会话。 <br><br><h4> 虚拟计时器 <br></h4><br> 您可能已经在使用虚拟计时器。 如果您在开发工具中移动了滑块以加快或减慢动画速度（当然，然后洗了手！），那么那时您在浏览器中使用了虚拟计时器。 <br><br> 浏览器可以使用虚拟计时器而不是真实计时器来<strong>“滚动”时间，</strong>以加快页面加载或完成动画的速度。 假设您具有相同的测试，请转至主页，然后播放动画30秒钟。 任何时候都让测试等待对任何人都没有好处。 因此，您可以简单地加快动画的速度，以便在页面加载时立即完成动画，然后继续测试。 <br><br> 您可以<strong>在网络请求运行时停止时间</strong> 。 例如，当到达后端的请求需要很长时间才能执行或返回错误时，您可以测试应用程序的响应。 您可以停止时间-Puppeteer允许。 <br><br> 在下面的幻灯片上，还有另一个选项： <strong>停止并继续</strong>渲染器。 在实验模式下，可以告诉浏览器不要进行渲染，然后，如有必要，可以请求截图。 然后，无头的Chrome会快速渲染所有内容，提供屏幕截图，然后再次停止绘制任何内容。 不幸的是，开发人员已经设法更改了此API的工作原理，并且不再有此类功能。 <br><br> 下面的虚拟计时器的示意图。 <br><br><img src="https://habrastorage.org/webt/dy/zm/bu/dyzmbucfttmfjlbsdkpmlk6bypq.jpeg"><br><br> 最上面一行有两个常规计时器：第一个在第一个时间单位中启动，并以一个时间单位运行，第二个在第三个时间单位中启动，并以三个时间单位运行。 <br><br> 加速计时器-它们一个接一个地启动。 当我们暂停它们时，我们会等待一段时间，然后所有计时器开始计时。 <br><br> 以这个为例。 以下是一段截断的代码，它实际上只是从codepen.io加载动画页面并等待： <br><br><pre> <code class="javascript hljs">(<span class="hljs-keyword"><span class="hljs-keyword">async</span></span>() =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> browser = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> puppeteer.launch(); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> page = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> browser.newPage(); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> url = <span class="hljs-string"><span class="hljs-string">'https ://codepen.o/ajerez/full/EaEEOW/'</span></span>; <span class="hljs-comment"><span class="hljs-comment">// # 1 await page.goto(url, { waitUnitl: 'load' }); // # 2 })();</span></span></code> </pre><br><br> 演示过程中的实现演示只是动画。 <br><br> 现在，使用Chrome DevTools协议，我们将发送一个名为Animation.setPlaybackRate的方法，并将值为12的playbackRate传递给它： <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> url = <span class="hljs-string"><span class="hljs-string">'https://codepen.o/ajerez/full/EaEEOW/'</span></span>; <span class="hljs-comment"><span class="hljs-comment">// # 1 await page._client.send('Animation.setPlaybackRate', { playbackRate: 12 }); // # 3 await page.goto(url, { waitUntil: 'load' }); // # 2</span></span></code> </pre><br> 我们加载了相同的链接，并且animashka开始工作得更快。 这是因为我们使用了虚拟计时器，并将动画的播放速度提高了12倍。 <br><br> 现在让我们做一个实验-传递playbackRate：0-看看会发生什么。 就是这样：根本没有动画，它不能播放。 零和负值只是完全暂停整个动画。 <br><br><h4> 处理网络请求 <br></h4><br> 您可以通过设置以下标志来<strong>拦截网络请求</strong> ： <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">await</span></span> page.setRequestlnterception(<span class="hljs-literal"><span class="hljs-literal">true</span></span>);</code> </pre> <br> 在这种模式下，将出现一个附加事件，该事件在发送或接收网络请求时触发。 <br><br> 您可以随时<strong>更改请求</strong> 。 这意味着您可以完全更改其所有内容（正文）及其标题，检查甚至取消请求。 <br><br> 为了<strong>处理授权或身份验证</strong> （包括通过HTTP的基本身份<strong>验证）</strong> ，这是必需的。 <br><br> 您还可以进行<strong>代码覆盖（JS / CSS）</strong> 。 使用Puppeteer，您可以自动化所有这些操作。 我们都知道可以加载页面，显示页面中使用了哪些类的实用程序。 但是我们对他们满意吗？ 我认为不是。 <br><br><blockquote> 浏览器更了解使用了哪些选择器和类-这是一个浏览器！ 他总是知道执行哪个JavaScript，不执行，不使用CSS。 <br></blockquote><br>  Chrome DevTools协议可助您一臂之力： <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">await</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>.all ( [ page.coverage.startJSCoverage(), page.coverage.startCSSCoverage() ]); <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> page.goto(<span class="hljs-string"><span class="hljs-string">'https://example.com'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> [jsCoverage, cssCoverage] = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>,all([ page.coverage.stopJSCoverage(), page.coverage.stopCSSCoverage() ]):</code> </pre><br> 在前两行中，我们启动了一个相对较新的功能，使您可以查找代码覆盖率。 运行JS和CSS，转到某个页面，然后说-停止-我们可以看到结果。 这些不是想象中的结果，而是浏览器由于引擎而看到的结果。 <br><br> 除其他外，已经有一个插件供Puppeteer将其全部导出到伊斯坦布尔。 <br><br> 在Puppeteer金字塔的顶部是您在Node.js上编写的脚本-就像教父一样，在所有底部。 <br><br><img src="https://habrastorage.org/webt/gx/j6/xl/gxj6xlxcpfwiuekgcszpnijrzf8.jpeg"><br><br> 但是……“在丹麦王国，并非一切都平静……”-正如莎士比亚写道。 <br><br><h2>  <strong>无头浏览器有什么问题？</strong> <br></h2><br> 尽管无头浏览器的所有出色功能都可以完成很多工作，但它们仍然存在问题。 <br><br><h4> 不同平台上页面渲染的差异 <br></h4><br> 我真的很喜欢这个项目，并不断谈论它。 让我们看看这张照片。 <br><br><img src="https://habrastorage.org/webt/62/r2/rj/62r2rjsc0ggbgpedb5lhp_tceki.jpeg"><br><br> 这是一个带有纯文本的常规页面：右侧-在Linux上的Chrome中呈现，左侧-在Windows下。 那些使用屏幕快照进行测试的人都知道，始终会设置一个值，称为“错误裕度”，该值确定何时将屏幕快照视为相同，何时将其视为相同。 <br><br> 实际上，问题在于，无论您如何尝试设置此阈值，该错误将始终超出此范围，并且您仍将收到假阳性结果。 这是由于所有三个平台上的所有页面甚至Web字体都呈现不同的事实-在Windows上根据一种算法，在MacOS上不同，在Linux上通常是动物园。  <strong>您不能只接受并测试屏幕截图</strong> 。 <br><br> 您会说：“我只需要一台参考计算机，即可在其中运行所有这些测试并比较屏幕截图。” 但是实际上，这非常不方便，因为您必须等待CI，并且希望在计算机上本地检查是否损坏了某些东西。 如果您在Linux机器上拍摄了参考屏幕截图，并且您使用的是Mac，那么将会有错误的结果。 <br><br><blockquote> 因此，我说完全不用屏幕截图进行测试-算了吧。 <br></blockquote><br> 顺便说一句，如果您仍然想使用屏幕截图进行测试，Roman Dvornov的精彩文章“ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">使用屏幕截图进行单元测试：打破声音障碍</a> ”。 这是侦探小说。 <br><br><h4> 锁具 <br></h4><br> 许多大型内容提供商不喜欢您以非法方式抓取或获取其内容。 想象一下，我是一家主要的内容提供商，并希望与您一起玩同一游戏。 在两个不同的浏览器中有两个GET请求。 <br><img src="https://habrastorage.org/webt/ku/ys/5e/kuys5eq81wzsqfci9kpddrd-ahm.jpeg"><br><br> 你能猜出Chrome在这里吗？ 不接受“两个”选项-Chrome仅是其中之一。 最有可能，您将无法回答这个问题，作为主要的内容提供商，我可以：在右侧-PhantomJS，在左侧-Chrome。 <br><img src="https://habrastorage.org/webt/l8/vc/lt/l8vcltt3bh-ccdysbg3azvqjxxe.jpeg"><br><br> 通过匹配请求中HTTP标头的顺序，我可以检测到您的浏览器（确切地说是Chrome或FireFox）。 如果主机优先（我很清楚），那就是Chrome。 那我无法比较。 是的，当然，还有更复杂的算法-我们不仅检查顺序，还检查值等。 等 但是重要的是，我可以放弃您的标题，检查您的身份，然后才阻止您或不阻止您。 <br><br><h4> 无法实现某些功能（Flash） <br></h4><br> 您是否曾经在浏览器中深入研究过直接使用Flash的硬盘？ 我莫名其妙地看着-然后六个月没睡觉了。 <br><br> 我们都记得曾经有Flash时曾经观看YouTube的方式：视频旋转，一切都很好。 但是，当在诸如Flash之类的页面上创建嵌入式对象时，它总是向您的OS请求一个真实的窗口。 也就是说，除了浏览器窗口外，Flash YouTube窗口中还有操作系统的另一个窗口。 除非您提供一个真实的窗口-不仅是真实的窗口，还是在屏幕上可见的窗口，否则Flash无法工作。 因此，某些功能无法在无头浏览器（包括Flash）中实现。 <br><br><h4> 全自动和机器人 <br></h4><br> 就像我之前说的，大型内容提供商非常害怕当您编写仅窃取有偿提供的信息的蜘蛛或抓斗时。 <br><br> 使用了各种技巧。 有关如何仍然检测无头浏览器的文章。 我可以说<strong>您将无法检测无头浏览器</strong> 。 此处描述的所有方法均被绕过。 例如，存在使用画布的检测方法。 我记得甚至有一个脚本看着鼠标在屏幕上移动并填充了画布。 我们是人，我们移动鼠标的速度相当慢，而无头Chrome的速度要快得多。 该脚本了解到Canvas填充得太快-这意味着它很可能是无头Chrome。 我们也对此进行了规避，只是放慢了浏览器的速度就没有问题。 <br><br><h4> 没有标准（单个）API <br></h4><br> 如果您在其他浏览器（无论是Safari还是FireFox）中观看了无头实现，那么所有这些都可以使用webdriver API来实现。  Chrome具有Chrome DevTools协议。 在Edge中，没有任何东西是清晰的-什么在里面，什么不在。 <br><br><h4>  WebGL？ <br></h4><br> 人们还要求在无头模式下使用WebGL。 此<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">链接可让</a>您访问Google Chrome浏览器错误跟踪器。 在那里，开发人员正在积极投票支持WebGL的无头模式的实现，并且他已经可以画点东西了。 现在，它们仅受硬件渲染的约束。 硬件渲染的实现完成后，WebGL将自动可用，也就是说，可以在后台完成某些操作。 <br><br> 但是，并非一切都那么糟糕！ <br><br> 我们在市场上有第二个参与者-2018年5月11日，有<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">消息</a>称Microsoft在其Edge浏览器中决定实现与Google Chrome中几乎相同的协议。 他们专门创建了一个财团，在这里讨论要引入行业标准的协议，以便您可以获取脚本并在Edge，Chrome和FireFox下运行它。 <br><br> 但是只有一个“但是”-不幸的是，Microsoft Edge没有无头模式。 他们的投票结果是：“给我们一个无头的模式！”  -但他们保持沉默。 大概看到了秘密。 <br><br><h2>  <strong>TODO（结论）</strong> <br></h2><br> 我告诉所有这些，以便您可以去找经理，或者，如果您是经理，可以去开发人员，然后说：“就是这样！  <strong>我们不再需要硒-给我们伪娘！</strong> 我们将在其中进行测试。” 如果发生这种情况，我将很高兴。 <br><br> 但是，如果您可以像我一样学习使用Puppeteer的浏览器，主动发布错误或发送请求请求，那么我将感到更加高兴。  OpenSource中的该<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">工具</a>位于GitHub上，是用Node.js编写的-您可以借用它并为它做贡献。 <br><br>  Puppeteer的情况很独特，因为有两个团队在Google工作：一个专门与Puppeteer交易，另一个与无头模式交易。 如果用户发现了一个错误并在GitHub上编写了该错误，那么如果该错误不是在Puppeteer中，而是在Headless Chrome中，则该错误将转至Headless Chrome命令。 如果他们在那里修复了问题，那么Puppeteer将会非常快速地更新。 当社区帮助改善浏览器时，这将形成一个单一的生态系统。 <br><br> 因此，我敦促您帮助改进该工具，该工具不仅会被您使用，还会被其他开发人员和测试人员使用。 <br><br> 联络资料： <br><br><ul><li>  github.com/vitallium </li><li>  vk.com/vitallium </li><li>  twitter.com/vitalliumm </li></ul><br><blockquote>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Frontend Conf Moscow-前端</a>开发人员专业会议将于<strong>10月4日至5日在莫斯科</strong> Infospace举行。 会议网站上已经发布<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">了</a>接受报告<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">的列表</a> 。 <br><br> 在我们的时事通讯中，我们会定期对演讲进行主题审查，谈论已发布的成绩单和未来的事件- <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">报名</a>首先接收新闻。 <br><br> 这是指向我们<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">YouTube</a>前端<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">频道</a>的链接，其中包含与项目客户部分的开发有关的所有演讲。 <br></blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN421137/">https://habr.com/ru/post/zh-CN421137/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN421127/index.html">Skillbox星期五网络研讨会：设计与开发人员</a></li>
<li><a href="../zh-CN421129/index.html">如何将代码审查从两周减少到几个小时。 Yandex.Market团队的经验</a></li>
<li><a href="../zh-CN421131/index.html">1Cloud服务器的严重漏洞</a></li>
<li><a href="../zh-CN421133/index.html">LINKa。 纸键盘。 超大按钮</a></li>
<li><a href="../zh-CN421135/index.html">Au / Ni / MgO：纳米级传热</a></li>
<li><a href="../zh-CN421139/index.html">前端会议-照顾用户</a></li>
<li><a href="../zh-CN421141/index.html">变异分析，或如何测试</a></li>
<li><a href="../zh-CN421143/index.html">Aurora Labs S-Titanium Pro迷你金属3D打印机</a></li>
<li><a href="../zh-CN421147/index.html">假期后的怪兽：AMD Threadripper 2990WX 32核和2950X 16核</a></li>
<li><a href="../zh-CN421149/index.html">关于渐变的几句话</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>