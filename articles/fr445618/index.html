<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§≤üèæ üë©üèæ‚Äçü§ù‚Äçüë©üèª üèôÔ∏è Nous √©crivons un syst√®me d'exploitation sur Rust. Impl√©mentation de la m√©moire de page (nouveau) üî† üíü üñãÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dans cet article, nous d√©couvrirons comment impl√©menter la prise en charge de la m√©moire de page dans notre noyau. Tout d'abord, nous √©tudierons diff√©...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Nous √©crivons un syst√®me d'exploitation sur Rust. Impl√©mentation de la m√©moire de page (nouveau)</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/445618/">  Dans cet article, nous d√©couvrirons comment impl√©menter la prise en charge de la m√©moire de page dans notre noyau.  Tout d'abord, nous √©tudierons diff√©rentes m√©thodes afin que les cadres de la table de pages physiques deviennent disponibles pour le noyau, et discuterons de leurs avantages et inconv√©nients.  Ensuite, nous impl√©mentons la fonction de traduction d'adresse et la fonction de cr√©ation d'un nouveau mapping. <br><br>  Cette s√©rie d'articles publi√©e sur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">GitHub</a> .  Si vous avez des questions ou des probl√®mes, ouvrez-y le ticket correspondant.  Toutes les sources de l'article sont <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">dans ce fil</a> . <br><br>  <i><b>Un autre article sur la pagination?</b></i> <i><br></i>  <i>Si vous suivez ce cycle, vous avez vu l'article <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">¬´M√©moire de page: niveau avanc√©¬ª</a> fin janvier.</i>  <i>Mais <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">j'ai √©t√© critiqu√©</a> pour les tableaux de pages r√©cursifs.</i>  <i>Par cons√©quent, j'ai d√©cid√© de r√©√©crire l'article, en utilisant une approche diff√©rente pour acc√©der aux cadres.</i> <br><a name="habracut"></a><br>  <i>Voici une nouvelle option.</i>  <i>L'article explique toujours comment fonctionnent les tableaux de pages r√©cursifs, mais nous utilisons une impl√©mentation plus simple et plus puissante.</i>  <i>Nous ne supprimerons pas l'article pr√©c√©dent, mais le marquerons comme obsol√®te et ne le mettrons pas √† jour.</i> <i><br><br></i>  <i>J'esp√®re que vous appr√©cierez la nouvelle option!</i> <br><br><h1>  Table des mati√®res </h1><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Pr√©sentation</a> <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Mises √† jour des d√©pendances</a> </li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Acc√®s aux tableaux de pages</a> <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Cartographie d'identit√©</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Carte de d√©calage fixe</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Mappage complet de la m√©moire physique</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Affichage temporaire</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Tables de pages r√©cursives</a> </li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Prise en charge du chargeur de d√©marrage</a> <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Informations de d√©marrage</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Macro de point d'entr√©e</a> </li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Impl√©mentation</a> <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Acc√®s aux tableaux de pages</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Traduction d'adresse</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Utilisation de MappedPageTable</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Cr√©er une nouvelle cartographie</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">S√©lection du cadre</a> </li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">R√©sum√©</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Et ensuite?</a> </li></ul><br><a name="1"></a><h1>  Pr√©sentation </h1><br>  Dans le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">dernier article,</a> nous avons d√©couvert les principes de la m√©moire de pagination et le fonctionnement des tables de pages √† quatre niveaux sur <code>x86_64</code> .  Nous avons √©galement constat√© que le chargeur avait d√©j√† configur√© la hi√©rarchie des tables de pages pour notre noyau, donc le noyau s'ex√©cute sur des adresses virtuelles.  Cela augmente la s√©curit√© car l'acc√®s non autoris√© √† la m√©moire provoque une erreur de page au lieu de modifier de fa√ßon al√©atoire la m√©moire physique. <br><br>  L'article a fini par ne pas pouvoir acc√©der aux tables de pages √† partir de notre noyau, car elles sont stock√©es dans la m√©moire physique et le noyau s'ex√©cute d√©j√† sur des adresses virtuelles.  Ici, nous continuons le sujet et explorons diff√©rentes options pour acc√©der aux cadres du tableau des pages √† partir du noyau.  Nous discuterons des avantages et des inconv√©nients de chacun d'eux, puis choisirons l'option appropri√©e pour notre c≈ìur. <br><br>  La prise en charge du chargeur de d√©marrage est requise, nous allons donc la configurer en premier.  Ensuite, nous impl√©mentons une fonction qui parcourt toute la hi√©rarchie des tables de pages afin de traduire les adresses virtuelles en adresses physiques.  Enfin, nous apprendrons comment cr√©er de nouveaux mappages dans des tables de pages et comment trouver des cadres de m√©moire inutilis√©s pour cr√©er de nouvelles tables. <br><br><a name="1_1"></a><h3>  Mises √† jour des d√©pendances </h3><br>  Cet article vous oblige √† enregistrer le <code>bootloader</code> version 0.4.0 ou sup√©rieure et <code>x86_64</code> version 0.5.2 ou sup√©rieure dans les d√©pendances.  Vous pouvez mettre √† jour les d√©pendances dans <code>Cargo.toml</code> : <br><br><pre> <code class="plaintext hljs">[dependencies] bootloader = "0.4.0" x86_64 = "0.5.2"</code> </pre> <br>  Pour les modifications de ces versions, consultez <a href="">le journal du chargeur de d√©marrage</a> et le <a href="">journal x86_64</a> . <br><br><a name="2"></a><h1>  Acc√®s aux tableaux de pages </h1><br>  Acc√©der aux tables de pages √† partir du noyau n'est pas aussi simple qu'il y para√Æt.  Pour comprendre le probl√®me, jetez un autre coup d'≈ìil √† la hi√©rarchie des tables √† quatre niveaux de l'article pr√©c√©dent: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9c8/5e8/a14/9c85e8a145a9078cfcfd92e204f69a5b.svg"></div><br><br>  L'important est que chaque entr√©e de page stocke l'adresse <i>physique</i> du tableau suivant.  Cela √©vite la traduction de ces adresses, ce qui r√©duit les performances et conduit facilement √† des boucles sans fin. <br><br>  Le probl√®me est que nous ne pouvons pas acc√©der directement aux adresses physiques √† partir du noyau, car cela fonctionne √©galement sur les adresses virtuelles.  Par exemple, lorsque nous allons √† l'adresse <code>4 KiB</code> , nous avons acc√®s √† l'adresse <i>virtuelle</i> <code>4 KiB</code> , et non √† l'adresse <i>physique</i> o√π est stock√© le tableau des pages du 4e niveau.  Si nous voulons acc√©der √† l'adresse physique de <code>4 KiB</code> , nous devons utiliser une adresse virtuelle, qui est traduite en elle. <br><br>  Par cons√©quent, pour acc√©der aux cadres des tables de pages, vous devez mapper certaines pages virtuelles √† ces cadres.  Il existe diff√©rentes fa√ßons de cr√©er de tels mappages. <br><br><a name="2_1"></a><h3>  Cartographie d'identit√© </h3><br>  Une solution simple est l' <b>affichage identique de tous les tableaux de pages</b> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8f3/813/916/8f3813916cd0a5b5174c8d14dabedb7a.svg"></div><br><br>  Dans cet exemple, nous voyons l'affichage identique des images.  Les adresses physiques des tables de pages sont en m√™me temps des adresses virtuelles valides, afin que nous puissions facilement acc√©der aux tables de pages de tous les niveaux, √† commencer par le registre CR3. <br><br>  Cependant, cette approche encombre l'espace d'adressage virtuel et rend difficile de trouver de grandes zones contigu√´s de m√©moire libre.  Disons que nous voulons cr√©er une zone de m√©moire virtuelle de 1000 Ko dans la figure ci-dessus, par exemple, pour <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">afficher un fichier en m√©moire</a> .  Nous ne pouvons pas commencer par la r√©gion des <code>28 KiB</code> , car elle repose sur une page d√©j√† occup√©e √† <code>1004  KiB</code> .  Par cons√©quent, vous devrez regarder plus loin jusqu'√† ce que nous trouvions un grand fragment appropri√©, par exemple, avec <code>1008  KiB</code> .  Il y a le m√™me probl√®me de fragmentation que dans la m√©moire segment√©e. <br><br>  De plus, la cr√©ation de nouveaux tableaux de pages est beaucoup plus compliqu√©e, car nous devons trouver des cadres physiques dont les pages correspondantes ne sont pas encore utilis√©es.  Par exemple, pour notre fichier, nous avons r√©serv√© une zone de 1000 Ko de m√©moire <i>virtuelle</i> , √† partir de l'adresse <code>1008  KiB</code> .  Maintenant, nous ne pouvons plus utiliser de trame avec une adresse physique comprise entre <code>1000  KiB</code> et <code>2008  KiB</code> , car elle ne peut pas √™tre affich√©e de mani√®re identique. <br><br><a name="2_2"></a><h3>  Carte de d√©calage fixe </h3><br>  Pour √©viter d'encombrer l'espace d'adressage virtuel, vous pouvez afficher les tableaux de pages dans une <b>zone de m√©moire distincte</b> .  Par cons√©quent, au lieu d'identifier le mappage, nous mappons des trames avec un d√©calage fixe dans l'espace d'adressage virtuel.  Par exemple, le d√©calage peut √™tre de 10 TiB: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f4a/c8a/5ea/f4ac8a5ea64fd215de176248b5f74e20.svg"><br><br>  En allouant cette plage de m√©moire virtuelle uniquement pour l'affichage des tables de pages, nous √©vitons les probl√®mes d'affichage identiques.  La r√©servation d'une si grande zone d'espace d'adressage virtuel n'est possible que si l'espace d'adressage virtuel est beaucoup plus grand que la taille de la m√©moire physique.  Sur <code>x86_64</code> ce n'est pas un probl√®me car l'espace d'adressage 48 bits est de 256 TiB. <br><br>  Mais cette approche pr√©sente l'inconv√©nient que lors de la cr√©ation de chaque table de pages, vous devez cr√©er un nouveau mappage.  De plus, il ne permet pas d'acc√©der aux tables dans d'autres espaces d'adressage, ce qui serait utile lors de la cr√©ation d'un nouveau processus. <br><br><a name="2_3"></a><h3>  Mappage complet de la m√©moire physique </h3><br>  Nous pouvons r√©soudre ces probl√®mes en <b>affichant toute la m√©moire physique</b> , et pas seulement les cadres de table de pages: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/c39/3cf/7df/c393cf7df76515739e1d9274160c4b5d.svg"><br><br>  Cette approche permet au noyau d'acc√©der √† la m√©moire physique arbitraire, y compris les cadres de table de pages d'autres espaces d'adressage.  Une plage de m√©moire virtuelle est r√©serv√©e de la m√™me taille qu'auparavant, mais seulement il n'y a plus de pages sans correspondance. <br><br>  L'inconv√©nient de cette approche est que des tables de pages suppl√©mentaires sont n√©cessaires pour afficher la m√©moire physique.  Ces tableaux de pages doivent √™tre stock√©s quelque part, afin qu'ils utilisent une partie de la m√©moire physique, ce qui peut √™tre un probl√®me sur les appareils avec une petite quantit√© de RAM. <br><br>  Cependant, sur x86_64, nous pouvons utiliser d' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">√©normes pages</a> de 2 Mio pour afficher au lieu de la taille par d√©faut de 4 Ko.  Ainsi, pour afficher 32 Go de m√©moire physique, seulement 132 Ko par table de pages sont n√©cessaires: une seule table de troisi√®me niveau et 32 ‚Äã‚Äãtables de deuxi√®me niveau.  Les pages volumineuses sont √©galement mises en cache plus efficacement car elles utilisent moins d'entr√©es dans le tampon de traduction dynamique (TLB). <br><br><a name="2_4"></a><h3>  Affichage temporaire </h3><br>  Pour les appareils avec tr√®s peu de m√©moire physique, vous ne pouvez <b>afficher les tableaux de pages que temporairement</b> lorsque vous devez y acc√©der.  Pour les comparaisons temporaires, un affichage identique de la seule table de premier niveau est requis: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/00a/3ab/5ce/00a3ab5ce85057d3679a48379d3d2297.svg"></div><br><br>  Sur cette figure, une table de niveau 1 g√®re les 2 premiers Mo d'espace d'adressage virtuel.  Cela est possible car l'acc√®s est effectu√© √† partir du registre CR3 via des entr√©es nulles dans les tableaux des niveaux 4, 3 et 2. L'enregistrement avec index <code>8</code> traduit la page virtuelle √† <code>32 KiB</code> en un cadre physique √† <code>32 KiB</code> , identifiant ainsi la table de niveau 1 elle-m√™me. Dans la figure, cela est indiqu√© par une fl√®che horizontale. <br><br>  En √©crivant dans la table de niveau 1 √† mappage identique, notre noyau peut cr√©er jusqu'√† 511 comparaisons temporelles (512 moins l'enregistrement n√©cessaire pour le mappage d'identit√©).  Dans l'exemple ci-dessus, le noyau cr√©e deux comparaisons temporelles: <br><br><ul><li>  Mappage d'une entr√©e nulle dans une table de niveau 1 √† une trame √† <code>24 KiB</code> .  Cela cr√©e un mappage temporaire de la page virtuelle √† <code>0 KiB</code> au cadre physique du tableau de niveau de page 2 indiqu√© par la fl√®che en pointill√©s. </li><li>  Faites correspondre le 9e enregistrement d'une table de niveau 1 avec un cadre √† <code>4 KiB</code> .  Cela cr√©e une correspondance temporaire de la page virtuelle √† <code>36 KiB</code> avec le cadre physique de la table de niveau de page 4 indiqu√©e par la fl√®che en pointill√©s. </li></ul><br>  Maintenant, le noyau peut acc√©der √† une table de niveau 2 en √©crivant sur une page qui commence √† <code>0 KiB</code> et √† une table de niveau 4 en √©crivant sur une page qui commence √† <code>33 KiB</code> . <br><br>  Ainsi, l'acc√®s √† un cadre arbitraire de la table des pages avec des mappages temporaires comprend les actions suivantes: <br><br><ul><li>  Trouvez une entr√©e gratuite dans le tableau de niveau 1 affich√© de mani√®re identique. <br></li><li>  Mappez cette entr√©e au cadre physique du tableau de pages auquel nous voulons acc√©der. <br></li><li>  Acc√©dez √† ce cadre via la page virtuelle associ√©e √† l'entr√©e. <br></li><li>  Red√©finissez l'enregistrement sur inutilis√©, supprimant ainsi le mappage temporaire. </li></ul><br>  Avec cette approche, l'espace d'adressage virtuel reste propre, car les m√™mes 512 pages virtuelles sont constamment utilis√©es.  L'inconv√©nient est une certaine lourdeur, d'autant plus qu'une nouvelle comparaison peut n√©cessiter de modifier plusieurs niveaux de la table, c'est-√†-dire que nous devons r√©p√©ter le processus d√©crit plusieurs fois. <br><br><a name="2_5"></a><h3>  Tables de pages r√©cursives </h3><br>  Une autre approche int√©ressante qui ne n√©cessite pas du tout de tables de pages suppl√©mentaires est la <b>correspondance r√©cursive</b> . <br><br>  L'id√©e est de traduire certains enregistrements de la table de quatri√®me niveau en elle-m√™me.  Ainsi, nous r√©servons en fait une partie de l'espace d'adressage virtuel et mappons tous les cadres de table actuels et futurs √† cet espace. <br><br>  Regardons un exemple pour comprendre comment tout cela fonctionne: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/779/ee6/d9b/779ee6d9bf771dec8e6d22c0440e503d.png"></div><br><br>  La seule diff√©rence avec l'exemple au d√©but de l'article est un enregistrement suppl√©mentaire avec l'index <code>511</code> dans la table de niveau 4, qui est mapp√© √† la trame physique <code>4 KiB</code> , qui se trouve dans cette table elle-m√™me. <br><br>  Lorsque le processeur va sur cet enregistrement, il ne fait pas r√©f√©rence √† la table de niveau 3, mais se r√©f√®re √† nouveau √† la table de niveau 4. Ceci est similaire √† une fonction r√©cursive qui s'appelle elle-m√™me.  Il est important que le processeur suppose que chaque entr√©e de la table de niveau 4 pointe vers une table de niveau 3. Par cons√©quent, il traite maintenant la table de niveau 4 comme une table de niveau 3. Cela fonctionne car les tables de tous les niveaux dans x86_64 ont la m√™me structure. <br><br>  En suivant une ou plusieurs fois un enregistrement r√©cursif avant de d√©marrer la conversion r√©elle, nous pouvons effectivement r√©duire le nombre de niveaux que le processeur traverse.  Par exemple, si nous suivons une fois l'enregistrement r√©cursif, puis passons √† la table de niveau 3, le processeur pense que la table de niveau 3 est une table de niveau 2. En poursuivant, il consid√®re la table de niveau 2 comme une table de niveau 1 et la table de niveau 1 comme mapp√©e trame dans la m√©moire physique.  Cela signifie que nous pouvons maintenant lire et √©crire dans la table de niveau de page 1 car le processeur pense qu'il s'agit d'un cadre mapp√©.  La figure ci-dessous montre les cinq √©tapes d'une telle traduction: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bda/ac7/191/bdaac719103c574c655efa3604d0b842.png"></div><br><br>  De m√™me, nous pouvons suivre une entr√©e r√©cursive deux fois avant de d√©marrer la conversion pour r√©duire le nombre de niveaux pass√©s √† deux: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7f4/b9a/c47/7f4b9ac47fce9552dead4e551b804256.png"></div><br><br>  Passons en revue cette proc√©dure √©tape par √©tape.  Tout d'abord, le CPU suit une entr√©e r√©cursive dans la table de niveau 4 et pense qu'il a atteint la table de niveau 3. Ensuite, il suit √† nouveau l'enregistrement r√©cursif et pense qu'il a atteint le niveau 2. Mais en r√©alit√©, il est toujours au niveau 4. Ensuite, le CPU va √† la nouvelle adresse et entre dans la table de niveau 3, mais pense qu'il est d√©j√† dans la table de niveau 1. Enfin, au point d'entr√©e suivant dans la table de niveau 2, le processeur pense qu'il a acc√©d√© √† la trame de m√©moire physique.  Cela nous permet de lire et d'√©crire dans une table de niveau 2. <br><br>  Les tables des niveaux 3 et 4 sont √©galement accessibles. Pour acc√©der √† la table du niveau 3, nous suivons une entr√©e r√©cursive trois fois: le processeur pense qu'il est d√©j√† dans la table du niveau 1, et √† l'√©tape suivante, nous atteignons le niveau 3, que le CPU consid√®re comme un cadre mapp√©.  Pour acc√©der √† la table de niveau 4 elle-m√™me, nous suivons simplement l'enregistrement r√©cursif quatre fois jusqu'√† ce que le processeur traite la table de niveau 4 elle-m√™me comme un cadre mapp√© (en bleu dans la figure ci-dessous). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/487/a82/92c/487a8292cf8fe673f1914f5f198c0956.png"></div><br><br>  Le concept est difficile √† comprendre au d√©but, mais dans la pratique, il fonctionne plut√¥t bien. <br><br><h4>  Calcul d'adresse </h4><br>  Ainsi, nous pouvons acc√©der aux tables de tous les niveaux en suivant une ou plusieurs fois un enregistrement r√©cursif.  √âtant donn√© que les index des tables de quatre niveaux sont d√©riv√©s directement de l'adresse virtuelle, des adresses virtuelles sp√©ciales doivent √™tre cr√©√©es pour cette m√©thode.  Comme nous le rappelons, les index des tables de pages sont extraits de l'adresse comme suit: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c44/33c/8f9/c4433c8f99b6fcb54d4b79983ca35dbc.svg"></div><br><br>  Supposons que nous voulons acc√©der √† un tableau de niveau 1 qui affiche une page sp√©cifique.  Comme nous l'avons appris ci-dessus, vous devez passer par un enregistrement r√©cursif une fois, puis par les indices des 4e, 3e et 2e niveaux.  Pour ce faire, nous d√©pla√ßons tous les blocs d'adresse d'un bloc vers la droite et mettons l'index de l'enregistrement r√©cursif √† la place de l'index initial de niveau 4: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/62a/d82/b54/62ad82b54b233a37e40b964953a16bf8.svg"></div><br><br>  Pour acc√©der au tableau de niveau 2 de cette page, nous d√©pla√ßons tous les blocs d'index deux blocs vers la droite et d√©finissons l'index r√©cursif √† la place des deux blocs source: niveau 4 et niveau 3: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1d9/ae5/7c8/1d9ae57c8c68a0b239e5b37397a4d0f7.svg"></div><br><br>  Pour acc√©der au tableau de niveau 3, on fait de m√™me, on d√©cale juste √† droite d√©j√† trois blocs d'adresse. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4b8/6ee/c9f/4b86eec9fd1df3445718ed8246fd4473.svg"></div><br><br>  Enfin, pour acc√©der √† la table de niveau 4, d√©placez les quatre blocs vers la droite. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/36b/6b0/29b/36b6b029b31578b143ff1e7605e358fb.svg"></div><br><br>  Vous pouvez maintenant calculer des adresses virtuelles pour les tables de pages des quatre niveaux.  Nous pouvons m√™me calculer une adresse qui pointe exactement vers une entr√©e de table de pages sp√©cifique en multipliant son index par 8, la taille de l'entr√©e de table de pages. <br><br>  Le tableau ci-dessous montre la structure des adresses pour acc√©der √† diff√©rents types de trames: <br><br><table><thead><tr><th>  Adresse virtuelle pour </th><th>  Structure d'adresse ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">octale</a> ) </th></tr></thead><tbody><tr><td>  La page </td><td> <code>0o_SSSSSS_AAA_BBB_CCC_DDD_EEEE</code> </td> </tr><tr><td>  Entr√©e dans le tableau de niveau 1 </td><td> <code>0o_SSSSSS_RRR_AAA_BBB_CCC_DDDD</code> </td> </tr><tr><td>  Entr√©e dans une table de niveau 2 </td><td> <code>0o_SSSSSS_RRR_RRR_AAA_BBB_CCCC</code> </td> </tr><tr><td>  Entr√©e dans une table de niveau 3 </td><td> <code>0o_SSSSSS_RRR_RRR_RRR_AAA_BBBB</code> </td> </tr><tr><td>  Entr√©e dans le tableau de niveau 4 </td><td> <code>0o_SSSSSS_RRR_RRR_RRR_RRR_AAAA</code> </td> </tr></tbody></table><br>  Ici, <code></code> est l'indice de niveau 4, <code></code> est de niveau 3, <code></code> est de niveau 2 et <code>DDD</code> est l'indice de niveau 1 pour la trame affich√©e, <code>EEEE</code> est son d√©calage.  <code>RRR</code> est l'indice de l'enregistrement r√©cursif.  Un index (trois chiffres) est converti en d√©calage (quatre chiffres) en multipliant par 8 (la taille de l'entr√©e du tableau de pages).  Avec ce d√©calage, l'adresse r√©sultante pointe directement vers l'entr√©e de table de pages correspondante. <br><br>  <code>SSSS</code> sont des bits d'extension du chiffre sign√©, c'est-√†-dire qu'ils sont tous des copies du bit 47. Il s'agit d'une exigence sp√©ciale pour les adresses valides dans l'architecture x86_64, dont nous avons discut√© dans un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">article pr√©c√©dent</a> . <br><br>  Les adresses sont <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">octales</a> , car chaque caract√®re octal repr√©sente trois bits, ce qui vous permet de s√©parer clairement les index de 9 bits des tables √† diff√©rents niveaux.  Ce n'est pas possible dans le syst√®me hexad√©cimal, o√π chaque caract√®re repr√©sente quatre bits. <br><br><h4>  Code rouille </h4><br>  Vous pouvez construire de telles adresses dans le code Rust √† l'aide d'op√©rations au niveau du bit: <br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// the virtual address whose corresponding page tables you want to access let addr: usize = [‚Ä¶]; let r = 0o777; // recursive index let sign = 0o177777 &lt;&lt; 48; // sign extension // retrieve the page table indices of the address that we want to translate let l4_idx = (addr &gt;&gt; 39) &amp; 0o777; // level 4 index let l3_idx = (addr &gt;&gt; 30) &amp; 0o777; // level 3 index let l2_idx = (addr &gt;&gt; 21) &amp; 0o777; // level 2 index let l1_idx = (addr &gt;&gt; 12) &amp; 0o777; // level 1 index let page_offset = addr &amp; 0o7777; // calculate the table addresses let level_4_table_addr = sign | (r &lt;&lt; 39) | (r &lt;&lt; 30) | (r &lt;&lt; 21) | (r &lt;&lt; 12); let level_3_table_addr = sign | (r &lt;&lt; 39) | (r &lt;&lt; 30) | (r &lt;&lt; 21) | (l4_idx &lt;&lt; 12); let level_2_table_addr = sign | (r &lt;&lt; 39) | (r &lt;&lt; 30) | (l4_idx &lt;&lt; 21) | (l3_idx &lt;&lt; 12); let level_1_table_addr = sign | (r &lt;&lt; 39) | (l4_idx &lt;&lt; 30) | (l3_idx &lt;&lt; 21) | (l2_idx &lt;&lt; 12);</span></span></code> </pre> <br>  Ce code suppose qu'un mappage r√©cursif du dernier enregistrement de niveau 4 avec l'index <code>0o777</code> (511) est r√©cursivement mis en correspondance.  Ce n'est actuellement pas le cas, donc le code ne fonctionnera pas encore.  Voir ci-dessous comment dire au chargeur de configurer un mappage r√©cursif. <br><br>  Au lieu d'effectuer des op√©rations au niveau du bit manuellement, vous pouvez utiliser le type <code>RecursivePageTable</code> de la caisse <code>x86_64</code> , qui fournit des abstractions s√ªres pour diverses op√©rations de table.  Par exemple, le code ci-dessous montre comment convertir une adresse virtuelle en son adresse physique correspondante: <br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// in src/memory.rs use x86_64::structures::paging::{Mapper, Page, PageTable, RecursivePageTable}; use x86_64::{VirtAddr, PhysAddr}; /// Creates a RecursivePageTable instance from the level 4 address. let level_4_table_addr = [‚Ä¶]; let level_4_table_ptr = level_4_table_addr as *mut PageTable; let recursive_page_table = unsafe { let level_4_table = &amp;mut *level_4_table_ptr; RecursivePageTable::new(level_4_table).unwrap(); } /// Retrieve the physical address for the given virtual address let addr: u64 = [‚Ä¶] let addr = VirtAddr::new(addr); let page: Page = Page::containing_address(addr); // perform the translation let frame = recursive_page_table.translate_page(page); frame.map(|frame| frame.start_address() + u64::from(addr.page_offset()))</span></span></code> </pre> <br>  Encore une fois, ce code n√©cessite un mappage r√©cursif correct.  Avec ce mappage, le <code>level_4_table_addr</code> manquant <code>level_4_table_addr</code> calcul√© comme dans le premier exemple de code. <br><br><hr><br>  Le mappage r√©cursif est une m√©thode int√©ressante qui montre √† quel point la correspondance peut √™tre puissante √† travers une seule table.  Il est relativement facile √† impl√©menter et ne n√©cessite qu'une configuration minimale (une seule entr√©e r√©cursive), c'est donc un bon choix pour les premi√®res exp√©riences. <br><br>  Mais cela pr√©sente certains inconv√©nients: <br><br><ul><li>  Une grande quantit√© de m√©moire virtuelle (512 Gio).  Ce n'est pas un probl√®me dans un grand espace d'adressage 48 bits, mais peut conduire √† un comportement de cache sous-optimal. <br></li><li>  Il donne facilement acc√®s uniquement √† l'espace d'adressage actuellement actif.  L'acc√®s √† d'autres espaces d'adressage est toujours possible en modifiant l'entr√©e r√©cursive, mais une correspondance temporaire est requise pour la commutation.  Nous avons d√©crit comment proc√©der dans un article pr√©c√©dent (obsol√®te). <br></li><li>  Cela d√©pend fortement du format de table des pages x86 et peut ne pas fonctionner sur d'autres architectures. </li></ul><br><a name="3"></a><h1>  Prise en charge du chargeur de d√©marrage </h1><br>  Toutes les approches d√©crites ci-dessus n√©cessitent des modifications des tableaux de pages et des param√®tres correspondants.  Par exemple, pour mapper de fa√ßon identique ou r√©cursive la m√©moire physique des enregistrements d'une table de quatri√®me niveau.  Le probl√®me est que nous ne pouvons pas d√©finir ces param√®tres sans acc√©der aux tableaux de pages. <br><br>  J'ai donc besoin de l'aide du chargeur de d√©marrage.  Il a acc√®s aux tableaux de pages, il peut donc cr√©er tous les affichages dont nous avons besoin.  Dans sa mise en ≈ìuvre actuelle, la caisse du <code>bootloader</code> prend en charge les deux approches ci-dessus en utilisant <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">les fonctions de chargement</a> : <br><br><ul><li>  La fonction <code>map_physical_memory</code> mappe la m√©moire physique compl√®te quelque part dans l'espace d'adressage virtuel.  Ainsi, le noyau acc√®de √† toute la m√©moire physique et peut appliquer une approche avec l' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">affichage de la m√©moire physique compl√®te</a> . <br></li><li>  √Ä l'aide de la fonction <code>recursive_page_table</code> , le chargeur affiche r√©cursivement une entr√©e de table de pages de quatri√®me niveau.  Cela permet au noyau de fonctionner selon la m√©thode d√©crite dans la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">section "Tables de pages r√©cursives"</a> . </li></ul><br>       ,    ,        (      ,     ).           <code>map_physical_memory</code> : <br><br><pre> <code class="plaintext hljs">[dependencies] bootloader = { version = "0.4.0", features = ["map_physical_memory"]}</code> </pre> <br>    ,           .      ,    <i> </i> . <br><br><a name="3_1"></a><h3>   </h3><br>  <code>bootloader</code>   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">BootInfo</a>   ,  .   ,         , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">  semver</a> .       : <code>memory_map</code>  <code>physical_memory_offset</code> : <br><br><ul><li>  <code>memory_map</code>     .   ,             ,   VGA.       BIOS  UEFI,       .       ,          .        . <br></li><li> <code>physical_memory_offset</code>       .      ,     .         . </li></ul><br>     <code>BootInfo</code>    <code>&amp;'static BootInfo</code>   <code>_start</code> .  : <br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// in src/main.rs use bootloader::BootInfo; #[cfg(not(test))] #[no_mangle] pub extern "C" fn _start(boot_info: &amp;'static BootInfo) -&gt; ! { // new argument [‚Ä¶] }</span></span></code> </pre> <br>     ,            . <br><br><a name="3_2"></a><h3>    </h3><br>   <code>_start</code>    ,     .  ,           ,           . <br><br>  ,        ,  <code>bootloader</code>   <code>entry_point</code> .       : <br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// in src/main.rs use bootloader::{BootInfo, entry_point}; entry_point!(kernel_main); #[cfg(not(test))] fn kernel_main(boot_info: &amp;'static BootInfo) -&gt; ! { [‚Ä¶] }</span></span></code> </pre> <br>        <code>extern "C"</code>  <code>no_mangle</code> ,            <code>_start</code> .  <code>kernel_main</code>      Rust,        .  ,     ,      , ,       ,     <br><br><a name="4"></a><h1>  </h1><br>          , ,   . -,     ,    .      ,    ,     .       ,    . <br><br>        <code>memory</code> : <br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// in src/lib.rs pub mod memory;</span></span></code> </pre> <br>      <code>src/memory.rs</code> . <br><br><a name="4_1"></a><h3>     </h3><br>   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="> </a>      ,    ,        ,     <code>CR3</code> .       :  <code>active_level_4_table</code>         : <br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// in src/memory.rs use x86_64::structures::paging::PageTable; /// Returns a mutable reference to the active level 4 table. /// /// This function is unsafe because the caller must guarantee that the /// complete physical memory is mapped to virtual memory at the passed /// `physical_memory_offset`. Also, this function must be only called once /// to avoid aliasing `&amp;mut` references (which is undefined behavior). pub unsafe fn active_level_4_table(physical_memory_offset: u64) -&gt; &amp;'static mut PageTable { use x86_64::{registers::control::Cr3, VirtAddr}; let (level_4_table_frame, _) = Cr3::read(); let phys = level_4_table_frame.start_address(); let virt = VirtAddr::new(phys.as_u64() + physical_memory_offset); let page_table_ptr: *mut PageTable = virt.as_mut_ptr(); &amp;mut *page_table_ptr // unsafe }</span></span></code> </pre> <br>       4-    <code>CR3</code> .           ,  <code>physical_memory_offset</code> . ,      <code>*mut PageTable</code>  <code>as_mut_ptr</code> ,        <code>&amp;mut PageTable</code> .    <code>&amp;mut</code>  <code>&amp;</code> ,           . <br><br>      unsafe,   Rust    <code>unsafe fn</code>     .   ,          .       .   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">RFC</a>     Rust. <br><br>           : <br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// in src/main.rs #[cfg(not(test))] fn kernel_main(boot_info: &amp;'static BootInfo) -&gt; ! { [‚Ä¶] // initialize GDT, IDT, PICS use blog_os::memory::active_level_4_table; let l4_table = unsafe { active_level_4_table(boot_info.physical_memory_offset) }; for (i, entry) in l4_table.iter().enumerate() { if !entry.is_unused() { println!("L4 Entry {}: {:?}", i, entry); } } println!("It did not crash!"); blog_os::hlt_loop(); }</span></span></code> </pre> <br>   <code>physical_memory_offset</code>     <code>BootInfo</code> .    <code>iter</code>         <code><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">enumerate</a></code>    <code>i</code>   .    ,    512     . <br><br>    ,    : <br><br><img src="https://habrastorage.org/getpro/habr/post_images/a33/def/50d/a33def50db528880395b665882aabe75.png"><br><br>     ,       .     ,        ,  ,      . <br><br>           ,         : <br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// in the for loop in src/main.rs use x86_64::{structures::paging::PageTable, VirtAddr}; if !entry.is_unused() { println!("L4 Entry {}: {:?}", i, entry); // get the physical address from the entry and convert it let phys = entry.frame().unwrap().start_address(); let virt = phys.as_u64() + boot_info.physical_memory_offset; let ptr = VirtAddr::new(virt).as_mut_ptr(); let l3_table: &amp;PageTable = unsafe { &amp;*ptr }; // print non-empty entries of the level 3 table for (i, entry) in l3_table.iter().enumerate() { if !entry.is_unused() { println!(" L3 Entry {}: {:?}", i, entry); } } }</span></span></code> </pre> <br>          , ,      .     ,     ,      . <br><br>     ,   ,     .             ,       . <br><br><a name="4_2"></a><h3>   </h3><br>            ,     .  ,     : <br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// in src/memory.rs use x86_64::{PhysAddr, VirtAddr}; /// Translates the given virtual address to the mapped physical address, or /// `None` if the address is not mapped. /// /// This function is unsafe because the caller must guarantee that the /// complete physical memory is mapped to virtual memory at the passed /// `physical_memory_offset`. pub unsafe fn translate_addr(addr: VirtAddr, physical_memory_offset: u64) -&gt; Option&lt;PhysAddr&gt; { translate_addr_inner(addr, physical_memory_offset) }</span></span></code> </pre> <br>      <code>translate_addr_inner</code> ,     .   , Rust    <code>unsafe fn</code>    .    ,       <code>unsafe</code> . <br><br>       : <br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// in src/memory.rs /// Private function that is called by `translate_addr`. /// /// This function is safe to limit the scope of `unsafe` because Rust treats /// the whole body of unsafe functions as an unsafe block. This function must /// only be reachable through `unsafe fn` from outside of this module. fn translate_addr_inner(addr: VirtAddr, physical_memory_offset: u64) -&gt; Option&lt;PhysAddr&gt; { use x86_64::structures::paging::page_table::FrameError; use x86_64::registers::control::Cr3; // read the active level 4 frame from the CR3 register let (level_4_table_frame, _) = Cr3::read(); let table_indexes = [ addr.p4_index(), addr.p3_index(), addr.p2_index(), addr.p1_index() ]; let mut frame = level_4_table_frame; // traverse the multi-level page table for &amp;index in &amp;table_indexes { // convert the frame into a page table reference let virt = frame.start_address().as_u64() + physical_memory_offset; let table_ptr: *const PageTable = VirtAddr::new(virt).as_ptr(); let table = unsafe {&amp;*table_ptr}; // read the page table entry and update `frame` let entry = &amp;table[index]; frame = match entry.frame() { Ok(frame) =&gt; frame, Err(FrameError::FrameNotPresent) =&gt; return None, Err(FrameError::HugeFrame) =&gt; panic!("huge pages not supported"), }; } // calculate the physical address by adding the page offset Some(frame.start_address() + u64::from(addr.page_offset())) }</span></span></code> </pre> <br>     <code>active_level_4_table</code>         <code>CR3</code> ,      .  ,    . <br><br>  <code>VirtAddr</code>           .       ,            <code>for</code> .      ,     . <code>frame</code>               , . .     1. <br><br>      <code>physical_memory_offset</code>        .          <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><code>PageTableEntry::frame</code></a>    .      ,  <code>None</code> .      2   1 ,      . <br><br> ,      : <br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// in src/main.rs #[cfg(not(test))] fn kernel_main(boot_info: &amp;'static BootInfo) -&gt; ! { [‚Ä¶] // initialize GDT, IDT, PICS use blog_os::memory::translate_addr; use x86_64::VirtAddr; let addresses = [ // the identity-mapped vga buffer page 0xb8000, // some code page 0x20010a, // some stack page 0x57ac_001f_fe48, // virtual address mapped to physical address 0 boot_info.physical_memory_offset, ]; for &amp;address in &amp;addresses { let virt = VirtAddr::new(address); let phys = unsafe { translate_addr(virt, boot_info.physical_memory_offset) }; println!("{:?} -&gt; {:?}", virt, phys); } println!("It did not crash!"); blog_os::hlt_loop(); }</span></span></code> </pre> <br>    ,   : <br><br><img src="https://habrastorage.org/getpro/habr/post_images/a0b/e32/db8/a0be32db8b6353452f9d40d7b1d350ad.png"><br><br>   ,     <code>0xb8000</code>      .          ,    ,        .  <code>physical_memory_offset</code>      <code>0</code> ,   ,         .             . <br><br><a name="4_3"></a><h3>  MappedPageTable </h3><br>      ‚Äî    ,   <code>x86_64</code>    .         ,  <code>translate_addr</code> ,            . <br><br>   ‚Äî  ,       : <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><code>Mapper</code></a>  ,   . , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><code>translate_page</code></a>         ,   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><code>map_to</code></a>      . <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><code>MapperAllSizes</code></a>   <code>Mapper</code>    .  ,   ,      ,    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><code>translate_addr</code></a>   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><code>translate</code></a> . </li></ul><br>    ,     .   <code>x86_64</code>   ,  : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><code>MappedPageTable</code></a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><code>RecursivePageTable</code></a> .  ,      -  (,  ).    ,      . <br><br>        <code>physical_memory_offset</code> ,     MappedPageTable.   ,    <code>init</code>   <code>memory</code> : <br><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">use</span></span> x86_64::structures::paging::{PhysFrame, MapperAllSizes, MappedPageTable}; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> x86_64::PhysAddr; <span class="hljs-comment"><span class="hljs-comment">/// Initialize a new MappedPageTable. /// /// This function is unsafe because the caller must guarantee that the /// complete physical memory is mapped to virtual memory at the passed /// `physical_memory_offset`. Also, this function must be only called once /// to avoid aliasing `&amp;mut` references (which is undefined behavior). pub unsafe fn init(physical_memory_offset: u64) -&gt; impl MapperAllSizes { let level_4_table = active_level_4_table(physical_memory_offset); let phys_to_virt = move |frame: PhysFrame| -&gt; *mut PageTable { let phys = frame.start_address().as_u64(); let virt = VirtAddr::new(phys + physical_memory_offset); virt.as_mut_ptr() }; MappedPageTable::new(level_4_table, phys_to_virt) } // make private unsafe fn active_level_4_table(physical_memory_offset: u64) -&gt; &amp;'static mut PageTable {‚Ä¶}</span></span></code> </pre> <br>      <code>MappedPageTable</code>  ,       .         <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><code>impl Trait</code></a> .    ,       <code>RecursivePageTable</code>    . <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><code>MappedPageTable::new</code></a>   :       4   <code>phys_to_virt</code> ,         <code>*mut PageTable</code> .         <code>active_level_4_table</code> .    ,   <code>physical_memory_offset</code>   . <br><br>    <code>active_level_4_table</code>  ,         <code>init</code> . <br><br>    <code>MapperAllSizes::translate_addr</code>     <code>memory::translate_addr</code> ,       <code>kernel_main</code> : <br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// in src/main.rs #[cfg(not(test))] fn kernel_main(boot_info: &amp;'static BootInfo) -&gt; ! { [‚Ä¶] // initialize GDT, IDT, PICS // new: different imports use blog_os::memory; use x86_64::{structures::paging::MapperAllSizes, VirtAddr}; // new: initialize a mapper let mapper = unsafe { memory::init(boot_info.physical_memory_offset) }; let addresses = [‚Ä¶]; // same as before for &amp;address in &amp;addresses { let virt = VirtAddr::new(address); // new: use the `mapper.translate_addr` method let phys = mapper.translate_addr(virt); println!("{:?} -&gt; {:?}", virt, phys); } println!("It did not crash!"); blog_os::hlt_loop(); }</span></span></code> </pre> <br>       ,   ,       : <br><br><img src="https://habrastorage.org/getpro/habr/post_images/51d/5ed/d9c/51d5edd9c004e1238b321dee51fdf8b3.png"><br><br>   ,   <code>physical_memory_offset</code>     <code>0x0</code> .      <code>MappedPageTable</code> ,         .         ,   <code>map_to</code> ,       .         <code>memory::translate_addr</code> ,   ,  . <br><br><a name="4_4"></a><h3>    </h3><br>         ,    .         . <br><br>    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><code>map_to</code></a>   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><code>Mapper</code></a> ,     .  ,     : ,    ; ,     ;          <code>frame_allocator</code> .   ,          ,        . <br><br><h4>  <code>create_example_mapping</code> </h4><br>     ‚Äî    <code>create_example_mapping</code> ,      <code>0xb8000</code> ,     VGA.    ,      ,     :           ,     . <br><br>  <code>create_example_mapping</code>  : <br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// in src/memory.rs use x86_64::structures::paging::{Page, Size4KiB, Mapper, FrameAllocator}; /// Creates an example mapping for the given page to frame `0xb8000`. pub fn create_example_mapping( page: Page, mapper: &amp;mut impl Mapper&lt;Size4KiB&gt;, frame_allocator: &amp;mut impl FrameAllocator&lt;Size4KiB&gt;, ) { use x86_64::structures::paging::PageTableFlags as Flags; let frame = PhysFrame::containing_address(PhysAddr::new(0xb8000)); let flags = Flags::PRESENT | Flags::WRITABLE; let map_to_result = unsafe { mapper.map_to(page, frame, flags, frame_allocator) }; map_to_result.expect("map_to failed").flush(); }</span></span></code> </pre> <br>     <code>page</code> ,   ,    <code>mapper</code>  <code>frame_allocator</code> .  <code>mapper</code>   <code>Mapper&lt;Size4KiB&gt;</code> ,    <code>map_to</code> .   <code>Size4KiB</code> ,   <code>Mapper</code>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="></a>   <code><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">PageSize</a></code> ,      4 ,       2   1 .      4 ,    <code>Mapper&lt;Size4KiB&gt;</code>   <code>MapperAllSizes</code> . <br><br>     <code>PRESENT</code> ,       ,   <code>WRITABLE</code> ,       .  <code>map_to</code> :      ,     <code>unsafe</code> .     .   ¬´  ¬ª <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="> </a> . <br><br>  <code>map_to</code>   ,    <code><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Result</a></code> .      ,     ,    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><code>expect</code></a>      .       <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><code>MapperFlush</code></a> ,             (TLB)    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><code>flush</code></a> .   <code>Result</code> ,     [ <code>#[must_use]</code> ]  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="> ,      </a> . <br><br><h4>  <code>FrameAllocator</code> </h4><br>   <code>create_example_mapping</code> ,    <code>FrameAllocator</code> .   ,        ,    .       1    ,       .         ,    3   ,        3, 2  1. <br><br>      ,       .     ,    <code>None</code> .    <code>EmptyFrameAllocator</code>    : <br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// in src/memory.rs /// A FrameAllocator that always returns `None`. pub struct EmptyFrameAllocator; impl FrameAllocator&lt;Size4KiB&gt; for EmptyFrameAllocator { fn allocate_frame(&amp;mut self) -&gt; Option&lt;PhysFrame&gt; { None } }</span></span></code> </pre> <br>    ,        .        ,   ,         1.            , ,    <code>0x1000</code> . <br><br>   ,     <code>0x1000</code> ,       : <br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// in src/main.rs #[cfg(not(test))] fn kernel_main(boot_info: &amp;'static BootInfo) -&gt; ! { [‚Ä¶] // initialize GDT, IDT, PICS use blog_os::memory; use x86_64::{structures::paging::Page, VirtAddr}; let mut mapper = unsafe { memory::init(boot_info.physical_memory_offset) }; let mut frame_allocator = memory::EmptyFrameAllocator; // map a previously unmapped page let page = Page::containing_address(VirtAddr::new(0x1000)); memory::create_example_mapping(page, &amp;mut mapper, &amp;mut frame_allocator); // write the string `New!` to the screen through the new mapping let page_ptr: *mut u64 = page.start_address().as_mut_ptr(); unsafe { page_ptr.offset(400).write_volatile(0x_f021_f077_f065_f04e)}; println!("It did not crash!"); blog_os::hlt_loop(); }</span></span></code> </pre> <br>       <code>0x1000</code> ,   <code>create_example_mapping</code>      <code>mapper</code>  <code>frame_allocator</code> .    <code>0x1000</code>     VGA,       ,   . <br><br>            <code>400</code> .      ,      VGA      <code>println</code> .   <code>0x_f021_f077_f065_f04e</code> ,    <i>‚ÄúNew!‚Äù</i>   .      <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">¬´  VGA¬ª</a> ,    VGA   ,    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><code>write_volatile</code></a> . <br><br>     QEMU,    : <br><br><img src="https://habrastorage.org/getpro/habr/post_images/4cf/248/1a0/4cf2481a07f40c681954ff4954dce866.png"><br><br>     <code>0x1000</code>     <i>‚ÄúNew!‚Äù</i>  . ,        . <br><br>   ,       1   <code>0x1000</code> .     ,        1,  <code>map_to</code>  ,      <code>EmptyFrameAllocator</code>    .  ,   ,     <code>0xdeadbeaf000</code>  <code>0x1000</code> : <br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// in src/main.rs #[cfg(not(test))] fn kernel_main(boot_info: &amp;'static BootInfo) -&gt; ! { [‚Ä¶] let page = Page::containing_address(VirtAddr::new(0xdeadbeaf000)); [‚Ä¶] }</span></span></code> </pre> <br>   ,       : <br><br><pre> <code class="plaintext hljs">panicked at 'map_to failed: FrameAllocationFailed', /‚Ä¶/result.rs:999:5</code> </pre> <br>   ,        1,    <code>FrameAllocator</code> .   ,        ? <br><br><a name="4_5"></a><h3>   </h3><br>         .    : <br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// in src/memory.rs pub struct BootInfoFrameAllocator&lt;I&gt; where I: Iterator&lt;Item = PhysFrame&gt; { frames: I, } impl&lt;I&gt; FrameAllocator&lt;Size4KiB&gt; for BootInfoFrameAllocator&lt;I&gt; where I: Iterator&lt;Item = PhysFrame&gt; { fn allocate_frame(&amp;mut self) -&gt; Option&lt;PhysFrame&gt; { self.frames.next() } }</span></span></code> </pre> <br>  <code>frames</code>      .      <code>alloc</code>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><code>Iterator::next</code></a> . <br><br>   <code>BootInfoFrameAllocator</code>    <code>memory_map</code> ,       <code>BootInfo</code> .     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">¬´ ¬ª</a> ,     BIOS/UEFI.         ,      . <br><br>       <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><code>MemoryRegion</code></a> ,    ,    (, ,   . .)   .  ,      ,     <code>BootInfoFrameAllocator</code> . <br><br>  <code>BootInfoFrameAllocator</code>     <code>init_frame_allocator</code> : <br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// in src/memory.rs use bootloader::bootinfo::{MemoryMap, MemoryRegionType}; /// Create a FrameAllocator from the passed memory map pub fn init_frame_allocator( memory_map: &amp;'static MemoryMap, ) -&gt; BootInfoFrameAllocator&lt;impl Iterator&lt;Item = PhysFrame&gt;&gt; { // get usable regions from memory map let regions = memory_map .iter() .filter(|r| r.region_type == MemoryRegionType::Usable); // map each region to its address range let addr_ranges = regions.map(|r| r.range.start_addr()..r.range.end_addr()); // transform to an iterator of frame start addresses let frame_addresses = addr_ranges.flat_map(|r| r.step_by(4096)); // create `PhysFrame` types from the start addresses let frames = frame_addresses.map(|addr| { PhysFrame::containing_address(PhysAddr::new(addr)) }); BootInfoFrameAllocator { frames } }</span></span></code> </pre> <br>         <code>MemoryMap</code>     : <br><br><ul><li> -,   <code>iter</code>       <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><code>MemoryRegion</code></a> .    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><code>filter</code></a>      .       ,  ,  ,   (,   )      ,    <code>InUse</code>  .  ,    ,   <code>Usable</code>   - . <br></li><li>      <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><code>map</code></a>    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">range</a>  Rust         . <br></li><li>    :         <code>into_iter</code> ,     4096-    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><code>step_by</code></a> .  4096  (= 4 ) ‚Äî   ,      .      ,         .  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><code>flat_map</code></a>  <code>map</code> ,   <code>Iterator&lt;Item = u64&gt;</code>  <code>Iterator&lt;Item = Iterator&lt;Item = u64&gt;&gt;</code> . <br></li><li>         <code>PhysFrame</code> ,    <code>Iterator&lt;Item = PhysFrame&gt;</code> .          <code>BootInfoFrameAllocator</code> . </li></ul><br>      <code>kernel_main</code> ,    <code>BootInfoFrameAllocator</code>  <code>EmptyFrameAllocator</code> : <br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// in src/main.rs #[cfg(not(test))] fn kernel_main(boot_info: &amp;'static BootInfo) -&gt; ! { [‚Ä¶] let mut frame_allocator = memory::init_frame_allocator(&amp;boot_info.memory_map); [‚Ä¶] }</span></span></code> </pre> <br>              -  <i>‚ÄúNew!‚Äù</i>  .    <code>map_to</code>      : <br><br><ul><li>      <code>frame_allocator</code> . <br></li><li>        . <br></li><li>         . <br></li><li>     . </li></ul><br>    <code>create_example_mapping</code> ‚Äî    ,         .            . <br><br><a name="5"></a><h1>  R√©sum√© </h1><br>              ,   ,    ,      .           . <br><br>             ,    .  <code>bootloader</code>       cargo.        <code>&amp;BootInfo</code>    . <br><br>          ,   ,     <code>MappedPageTable</code>  <code>x86_64</code> .   ,           <code>FrameAllocator</code>   ,  . <br><br><a name="6"></a><h1>  ? </h1><br>          ,   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="> </a>    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="> </a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr445618/">https://habr.com/ru/post/fr445618/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr445596/index.html">Trucs et astuces Kubernetes: pages d'erreur personnalis√©es dans NGINX Ingress</a></li>
<li><a href="../fr445600/index.html">[Sondage et mal] H√©bergement, qu'ils se trompent</a></li>
<li><a href="../fr445602/index.html">PHP Russie 2019: son ¬´stade¬ª pour la langue de premi√®re ligue</a></li>
<li><a href="../fr445608/index.html">Game over: les analystes signalent une augmentation du nombre d'attaques DDoS sur le segment des jeux</a></li>
<li><a href="../fr445612/index.html">Stockage en cluster pour les petits clusters Web bas√©s sur drbd + ocfs2</a></li>
<li><a href="../fr445620/index.html">Que fait un √©crivain UX?</a></li>
<li><a href="../fr445622/index.html">Nouveau dans Java 12: The Teeing Collector</a></li>
<li><a href="../fr445626/index.html">Quelle est la profondeur du terrier du lapin? CLRium # 5: Garbage Collector</a></li>
<li><a href="../fr445632/index.html">De l'analyseur de l'affiche du th√©√¢tre Python au bot Telegram. 2e partie</a></li>
<li><a href="../fr445638/index.html">Stage aveugle au Garage Museum of Modern Art</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>