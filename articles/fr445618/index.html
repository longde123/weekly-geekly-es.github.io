<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤲🏾 👩🏾‍🤝‍👩🏻 🏙️ Nous écrivons un système d'exploitation sur Rust. Implémentation de la mémoire de page (nouveau) 🔠 💟 🖋️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dans cet article, nous découvrirons comment implémenter la prise en charge de la mémoire de page dans notre noyau. Tout d'abord, nous étudierons diffé...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Nous écrivons un système d'exploitation sur Rust. Implémentation de la mémoire de page (nouveau)</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/445618/">  Dans cet article, nous découvrirons comment implémenter la prise en charge de la mémoire de page dans notre noyau.  Tout d'abord, nous étudierons différentes méthodes afin que les cadres de la table de pages physiques deviennent disponibles pour le noyau, et discuterons de leurs avantages et inconvénients.  Ensuite, nous implémentons la fonction de traduction d'adresse et la fonction de création d'un nouveau mapping. <br><br>  Cette série d'articles publiée sur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">GitHub</a> .  Si vous avez des questions ou des problèmes, ouvrez-y le ticket correspondant.  Toutes les sources de l'article sont <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">dans ce fil</a> . <br><br>  <i><b>Un autre article sur la pagination?</b></i> <i><br></i>  <i>Si vous suivez ce cycle, vous avez vu l'article <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">«Mémoire de page: niveau avancé»</a> fin janvier.</i>  <i>Mais <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">j'ai été critiqué</a> pour les tableaux de pages récursifs.</i>  <i>Par conséquent, j'ai décidé de réécrire l'article, en utilisant une approche différente pour accéder aux cadres.</i> <br><a name="habracut"></a><br>  <i>Voici une nouvelle option.</i>  <i>L'article explique toujours comment fonctionnent les tableaux de pages récursifs, mais nous utilisons une implémentation plus simple et plus puissante.</i>  <i>Nous ne supprimerons pas l'article précédent, mais le marquerons comme obsolète et ne le mettrons pas à jour.</i> <i><br><br></i>  <i>J'espère que vous apprécierez la nouvelle option!</i> <br><br><h1>  Table des matières </h1><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Présentation</a> <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Mises à jour des dépendances</a> </li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Accès aux tableaux de pages</a> <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Cartographie d'identité</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Carte de décalage fixe</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Mappage complet de la mémoire physique</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Affichage temporaire</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Tables de pages récursives</a> </li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Prise en charge du chargeur de démarrage</a> <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Informations de démarrage</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Macro de point d'entrée</a> </li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Implémentation</a> <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Accès aux tableaux de pages</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Traduction d'adresse</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Utilisation de MappedPageTable</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Créer une nouvelle cartographie</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Sélection du cadre</a> </li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Résumé</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Et ensuite?</a> </li></ul><br><a name="1"></a><h1>  Présentation </h1><br>  Dans le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">dernier article,</a> nous avons découvert les principes de la mémoire de pagination et le fonctionnement des tables de pages à quatre niveaux sur <code>x86_64</code> .  Nous avons également constaté que le chargeur avait déjà configuré la hiérarchie des tables de pages pour notre noyau, donc le noyau s'exécute sur des adresses virtuelles.  Cela augmente la sécurité car l'accès non autorisé à la mémoire provoque une erreur de page au lieu de modifier de façon aléatoire la mémoire physique. <br><br>  L'article a fini par ne pas pouvoir accéder aux tables de pages à partir de notre noyau, car elles sont stockées dans la mémoire physique et le noyau s'exécute déjà sur des adresses virtuelles.  Ici, nous continuons le sujet et explorons différentes options pour accéder aux cadres du tableau des pages à partir du noyau.  Nous discuterons des avantages et des inconvénients de chacun d'eux, puis choisirons l'option appropriée pour notre cœur. <br><br>  La prise en charge du chargeur de démarrage est requise, nous allons donc la configurer en premier.  Ensuite, nous implémentons une fonction qui parcourt toute la hiérarchie des tables de pages afin de traduire les adresses virtuelles en adresses physiques.  Enfin, nous apprendrons comment créer de nouveaux mappages dans des tables de pages et comment trouver des cadres de mémoire inutilisés pour créer de nouvelles tables. <br><br><a name="1_1"></a><h3>  Mises à jour des dépendances </h3><br>  Cet article vous oblige à enregistrer le <code>bootloader</code> version 0.4.0 ou supérieure et <code>x86_64</code> version 0.5.2 ou supérieure dans les dépendances.  Vous pouvez mettre à jour les dépendances dans <code>Cargo.toml</code> : <br><br><pre> <code class="plaintext hljs">[dependencies] bootloader = "0.4.0" x86_64 = "0.5.2"</code> </pre> <br>  Pour les modifications de ces versions, consultez <a href="">le journal du chargeur de démarrage</a> et le <a href="">journal x86_64</a> . <br><br><a name="2"></a><h1>  Accès aux tableaux de pages </h1><br>  Accéder aux tables de pages à partir du noyau n'est pas aussi simple qu'il y paraît.  Pour comprendre le problème, jetez un autre coup d'œil à la hiérarchie des tables à quatre niveaux de l'article précédent: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9c8/5e8/a14/9c85e8a145a9078cfcfd92e204f69a5b.svg"></div><br><br>  L'important est que chaque entrée de page stocke l'adresse <i>physique</i> du tableau suivant.  Cela évite la traduction de ces adresses, ce qui réduit les performances et conduit facilement à des boucles sans fin. <br><br>  Le problème est que nous ne pouvons pas accéder directement aux adresses physiques à partir du noyau, car cela fonctionne également sur les adresses virtuelles.  Par exemple, lorsque nous allons à l'adresse <code>4 KiB</code> , nous avons accès à l'adresse <i>virtuelle</i> <code>4 KiB</code> , et non à l'adresse <i>physique</i> où est stocké le tableau des pages du 4e niveau.  Si nous voulons accéder à l'adresse physique de <code>4 KiB</code> , nous devons utiliser une adresse virtuelle, qui est traduite en elle. <br><br>  Par conséquent, pour accéder aux cadres des tables de pages, vous devez mapper certaines pages virtuelles à ces cadres.  Il existe différentes façons de créer de tels mappages. <br><br><a name="2_1"></a><h3>  Cartographie d'identité </h3><br>  Une solution simple est l' <b>affichage identique de tous les tableaux de pages</b> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8f3/813/916/8f3813916cd0a5b5174c8d14dabedb7a.svg"></div><br><br>  Dans cet exemple, nous voyons l'affichage identique des images.  Les adresses physiques des tables de pages sont en même temps des adresses virtuelles valides, afin que nous puissions facilement accéder aux tables de pages de tous les niveaux, à commencer par le registre CR3. <br><br>  Cependant, cette approche encombre l'espace d'adressage virtuel et rend difficile de trouver de grandes zones contiguës de mémoire libre.  Disons que nous voulons créer une zone de mémoire virtuelle de 1000 Ko dans la figure ci-dessus, par exemple, pour <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">afficher un fichier en mémoire</a> .  Nous ne pouvons pas commencer par la région des <code>28 KiB</code> , car elle repose sur une page déjà occupée à <code>1004  KiB</code> .  Par conséquent, vous devrez regarder plus loin jusqu'à ce que nous trouvions un grand fragment approprié, par exemple, avec <code>1008  KiB</code> .  Il y a le même problème de fragmentation que dans la mémoire segmentée. <br><br>  De plus, la création de nouveaux tableaux de pages est beaucoup plus compliquée, car nous devons trouver des cadres physiques dont les pages correspondantes ne sont pas encore utilisées.  Par exemple, pour notre fichier, nous avons réservé une zone de 1000 Ko de mémoire <i>virtuelle</i> , à partir de l'adresse <code>1008  KiB</code> .  Maintenant, nous ne pouvons plus utiliser de trame avec une adresse physique comprise entre <code>1000  KiB</code> et <code>2008  KiB</code> , car elle ne peut pas être affichée de manière identique. <br><br><a name="2_2"></a><h3>  Carte de décalage fixe </h3><br>  Pour éviter d'encombrer l'espace d'adressage virtuel, vous pouvez afficher les tableaux de pages dans une <b>zone de mémoire distincte</b> .  Par conséquent, au lieu d'identifier le mappage, nous mappons des trames avec un décalage fixe dans l'espace d'adressage virtuel.  Par exemple, le décalage peut être de 10 TiB: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f4a/c8a/5ea/f4ac8a5ea64fd215de176248b5f74e20.svg"><br><br>  En allouant cette plage de mémoire virtuelle uniquement pour l'affichage des tables de pages, nous évitons les problèmes d'affichage identiques.  La réservation d'une si grande zone d'espace d'adressage virtuel n'est possible que si l'espace d'adressage virtuel est beaucoup plus grand que la taille de la mémoire physique.  Sur <code>x86_64</code> ce n'est pas un problème car l'espace d'adressage 48 bits est de 256 TiB. <br><br>  Mais cette approche présente l'inconvénient que lors de la création de chaque table de pages, vous devez créer un nouveau mappage.  De plus, il ne permet pas d'accéder aux tables dans d'autres espaces d'adressage, ce qui serait utile lors de la création d'un nouveau processus. <br><br><a name="2_3"></a><h3>  Mappage complet de la mémoire physique </h3><br>  Nous pouvons résoudre ces problèmes en <b>affichant toute la mémoire physique</b> , et pas seulement les cadres de table de pages: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/c39/3cf/7df/c393cf7df76515739e1d9274160c4b5d.svg"><br><br>  Cette approche permet au noyau d'accéder à la mémoire physique arbitraire, y compris les cadres de table de pages d'autres espaces d'adressage.  Une plage de mémoire virtuelle est réservée de la même taille qu'auparavant, mais seulement il n'y a plus de pages sans correspondance. <br><br>  L'inconvénient de cette approche est que des tables de pages supplémentaires sont nécessaires pour afficher la mémoire physique.  Ces tableaux de pages doivent être stockés quelque part, afin qu'ils utilisent une partie de la mémoire physique, ce qui peut être un problème sur les appareils avec une petite quantité de RAM. <br><br>  Cependant, sur x86_64, nous pouvons utiliser d' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">énormes pages</a> de 2 Mio pour afficher au lieu de la taille par défaut de 4 Ko.  Ainsi, pour afficher 32 Go de mémoire physique, seulement 132 Ko par table de pages sont nécessaires: une seule table de troisième niveau et 32 ​​tables de deuxième niveau.  Les pages volumineuses sont également mises en cache plus efficacement car elles utilisent moins d'entrées dans le tampon de traduction dynamique (TLB). <br><br><a name="2_4"></a><h3>  Affichage temporaire </h3><br>  Pour les appareils avec très peu de mémoire physique, vous ne pouvez <b>afficher les tableaux de pages que temporairement</b> lorsque vous devez y accéder.  Pour les comparaisons temporaires, un affichage identique de la seule table de premier niveau est requis: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/00a/3ab/5ce/00a3ab5ce85057d3679a48379d3d2297.svg"></div><br><br>  Sur cette figure, une table de niveau 1 gère les 2 premiers Mo d'espace d'adressage virtuel.  Cela est possible car l'accès est effectué à partir du registre CR3 via des entrées nulles dans les tableaux des niveaux 4, 3 et 2. L'enregistrement avec index <code>8</code> traduit la page virtuelle à <code>32 KiB</code> en un cadre physique à <code>32 KiB</code> , identifiant ainsi la table de niveau 1 elle-même. Dans la figure, cela est indiqué par une flèche horizontale. <br><br>  En écrivant dans la table de niveau 1 à mappage identique, notre noyau peut créer jusqu'à 511 comparaisons temporelles (512 moins l'enregistrement nécessaire pour le mappage d'identité).  Dans l'exemple ci-dessus, le noyau crée deux comparaisons temporelles: <br><br><ul><li>  Mappage d'une entrée nulle dans une table de niveau 1 à une trame à <code>24 KiB</code> .  Cela crée un mappage temporaire de la page virtuelle à <code>0 KiB</code> au cadre physique du tableau de niveau de page 2 indiqué par la flèche en pointillés. </li><li>  Faites correspondre le 9e enregistrement d'une table de niveau 1 avec un cadre à <code>4 KiB</code> .  Cela crée une correspondance temporaire de la page virtuelle à <code>36 KiB</code> avec le cadre physique de la table de niveau de page 4 indiquée par la flèche en pointillés. </li></ul><br>  Maintenant, le noyau peut accéder à une table de niveau 2 en écrivant sur une page qui commence à <code>0 KiB</code> et à une table de niveau 4 en écrivant sur une page qui commence à <code>33 KiB</code> . <br><br>  Ainsi, l'accès à un cadre arbitraire de la table des pages avec des mappages temporaires comprend les actions suivantes: <br><br><ul><li>  Trouvez une entrée gratuite dans le tableau de niveau 1 affiché de manière identique. <br></li><li>  Mappez cette entrée au cadre physique du tableau de pages auquel nous voulons accéder. <br></li><li>  Accédez à ce cadre via la page virtuelle associée à l'entrée. <br></li><li>  Redéfinissez l'enregistrement sur inutilisé, supprimant ainsi le mappage temporaire. </li></ul><br>  Avec cette approche, l'espace d'adressage virtuel reste propre, car les mêmes 512 pages virtuelles sont constamment utilisées.  L'inconvénient est une certaine lourdeur, d'autant plus qu'une nouvelle comparaison peut nécessiter de modifier plusieurs niveaux de la table, c'est-à-dire que nous devons répéter le processus décrit plusieurs fois. <br><br><a name="2_5"></a><h3>  Tables de pages récursives </h3><br>  Une autre approche intéressante qui ne nécessite pas du tout de tables de pages supplémentaires est la <b>correspondance récursive</b> . <br><br>  L'idée est de traduire certains enregistrements de la table de quatrième niveau en elle-même.  Ainsi, nous réservons en fait une partie de l'espace d'adressage virtuel et mappons tous les cadres de table actuels et futurs à cet espace. <br><br>  Regardons un exemple pour comprendre comment tout cela fonctionne: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/779/ee6/d9b/779ee6d9bf771dec8e6d22c0440e503d.png"></div><br><br>  La seule différence avec l'exemple au début de l'article est un enregistrement supplémentaire avec l'index <code>511</code> dans la table de niveau 4, qui est mappé à la trame physique <code>4 KiB</code> , qui se trouve dans cette table elle-même. <br><br>  Lorsque le processeur va sur cet enregistrement, il ne fait pas référence à la table de niveau 3, mais se réfère à nouveau à la table de niveau 4. Ceci est similaire à une fonction récursive qui s'appelle elle-même.  Il est important que le processeur suppose que chaque entrée de la table de niveau 4 pointe vers une table de niveau 3. Par conséquent, il traite maintenant la table de niveau 4 comme une table de niveau 3. Cela fonctionne car les tables de tous les niveaux dans x86_64 ont la même structure. <br><br>  En suivant une ou plusieurs fois un enregistrement récursif avant de démarrer la conversion réelle, nous pouvons effectivement réduire le nombre de niveaux que le processeur traverse.  Par exemple, si nous suivons une fois l'enregistrement récursif, puis passons à la table de niveau 3, le processeur pense que la table de niveau 3 est une table de niveau 2. En poursuivant, il considère la table de niveau 2 comme une table de niveau 1 et la table de niveau 1 comme mappée trame dans la mémoire physique.  Cela signifie que nous pouvons maintenant lire et écrire dans la table de niveau de page 1 car le processeur pense qu'il s'agit d'un cadre mappé.  La figure ci-dessous montre les cinq étapes d'une telle traduction: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bda/ac7/191/bdaac719103c574c655efa3604d0b842.png"></div><br><br>  De même, nous pouvons suivre une entrée récursive deux fois avant de démarrer la conversion pour réduire le nombre de niveaux passés à deux: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7f4/b9a/c47/7f4b9ac47fce9552dead4e551b804256.png"></div><br><br>  Passons en revue cette procédure étape par étape.  Tout d'abord, le CPU suit une entrée récursive dans la table de niveau 4 et pense qu'il a atteint la table de niveau 3. Ensuite, il suit à nouveau l'enregistrement récursif et pense qu'il a atteint le niveau 2. Mais en réalité, il est toujours au niveau 4. Ensuite, le CPU va à la nouvelle adresse et entre dans la table de niveau 3, mais pense qu'il est déjà dans la table de niveau 1. Enfin, au point d'entrée suivant dans la table de niveau 2, le processeur pense qu'il a accédé à la trame de mémoire physique.  Cela nous permet de lire et d'écrire dans une table de niveau 2. <br><br>  Les tables des niveaux 3 et 4 sont également accessibles. Pour accéder à la table du niveau 3, nous suivons une entrée récursive trois fois: le processeur pense qu'il est déjà dans la table du niveau 1, et à l'étape suivante, nous atteignons le niveau 3, que le CPU considère comme un cadre mappé.  Pour accéder à la table de niveau 4 elle-même, nous suivons simplement l'enregistrement récursif quatre fois jusqu'à ce que le processeur traite la table de niveau 4 elle-même comme un cadre mappé (en bleu dans la figure ci-dessous). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/487/a82/92c/487a8292cf8fe673f1914f5f198c0956.png"></div><br><br>  Le concept est difficile à comprendre au début, mais dans la pratique, il fonctionne plutôt bien. <br><br><h4>  Calcul d'adresse </h4><br>  Ainsi, nous pouvons accéder aux tables de tous les niveaux en suivant une ou plusieurs fois un enregistrement récursif.  Étant donné que les index des tables de quatre niveaux sont dérivés directement de l'adresse virtuelle, des adresses virtuelles spéciales doivent être créées pour cette méthode.  Comme nous le rappelons, les index des tables de pages sont extraits de l'adresse comme suit: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c44/33c/8f9/c4433c8f99b6fcb54d4b79983ca35dbc.svg"></div><br><br>  Supposons que nous voulons accéder à un tableau de niveau 1 qui affiche une page spécifique.  Comme nous l'avons appris ci-dessus, vous devez passer par un enregistrement récursif une fois, puis par les indices des 4e, 3e et 2e niveaux.  Pour ce faire, nous déplaçons tous les blocs d'adresse d'un bloc vers la droite et mettons l'index de l'enregistrement récursif à la place de l'index initial de niveau 4: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/62a/d82/b54/62ad82b54b233a37e40b964953a16bf8.svg"></div><br><br>  Pour accéder au tableau de niveau 2 de cette page, nous déplaçons tous les blocs d'index deux blocs vers la droite et définissons l'index récursif à la place des deux blocs source: niveau 4 et niveau 3: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1d9/ae5/7c8/1d9ae57c8c68a0b239e5b37397a4d0f7.svg"></div><br><br>  Pour accéder au tableau de niveau 3, on fait de même, on décale juste à droite déjà trois blocs d'adresse. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4b8/6ee/c9f/4b86eec9fd1df3445718ed8246fd4473.svg"></div><br><br>  Enfin, pour accéder à la table de niveau 4, déplacez les quatre blocs vers la droite. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/36b/6b0/29b/36b6b029b31578b143ff1e7605e358fb.svg"></div><br><br>  Vous pouvez maintenant calculer des adresses virtuelles pour les tables de pages des quatre niveaux.  Nous pouvons même calculer une adresse qui pointe exactement vers une entrée de table de pages spécifique en multipliant son index par 8, la taille de l'entrée de table de pages. <br><br>  Le tableau ci-dessous montre la structure des adresses pour accéder à différents types de trames: <br><br><table><thead><tr><th>  Adresse virtuelle pour </th><th>  Structure d'adresse ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">octale</a> ) </th></tr></thead><tbody><tr><td>  La page </td><td> <code>0o_SSSSSS_AAA_BBB_CCC_DDD_EEEE</code> </td> </tr><tr><td>  Entrée dans le tableau de niveau 1 </td><td> <code>0o_SSSSSS_RRR_AAA_BBB_CCC_DDDD</code> </td> </tr><tr><td>  Entrée dans une table de niveau 2 </td><td> <code>0o_SSSSSS_RRR_RRR_AAA_BBB_CCCC</code> </td> </tr><tr><td>  Entrée dans une table de niveau 3 </td><td> <code>0o_SSSSSS_RRR_RRR_RRR_AAA_BBBB</code> </td> </tr><tr><td>  Entrée dans le tableau de niveau 4 </td><td> <code>0o_SSSSSS_RRR_RRR_RRR_RRR_AAAA</code> </td> </tr></tbody></table><br>  Ici, <code></code> est l'indice de niveau 4, <code></code> est de niveau 3, <code></code> est de niveau 2 et <code>DDD</code> est l'indice de niveau 1 pour la trame affichée, <code>EEEE</code> est son décalage.  <code>RRR</code> est l'indice de l'enregistrement récursif.  Un index (trois chiffres) est converti en décalage (quatre chiffres) en multipliant par 8 (la taille de l'entrée du tableau de pages).  Avec ce décalage, l'adresse résultante pointe directement vers l'entrée de table de pages correspondante. <br><br>  <code>SSSS</code> sont des bits d'extension du chiffre signé, c'est-à-dire qu'ils sont tous des copies du bit 47. Il s'agit d'une exigence spéciale pour les adresses valides dans l'architecture x86_64, dont nous avons discuté dans un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">article précédent</a> . <br><br>  Les adresses sont <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">octales</a> , car chaque caractère octal représente trois bits, ce qui vous permet de séparer clairement les index de 9 bits des tables à différents niveaux.  Ce n'est pas possible dans le système hexadécimal, où chaque caractère représente quatre bits. <br><br><h4>  Code rouille </h4><br>  Vous pouvez construire de telles adresses dans le code Rust à l'aide d'opérations au niveau du bit: <br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// the virtual address whose corresponding page tables you want to access let addr: usize = […]; let r = 0o777; // recursive index let sign = 0o177777 &lt;&lt; 48; // sign extension // retrieve the page table indices of the address that we want to translate let l4_idx = (addr &gt;&gt; 39) &amp; 0o777; // level 4 index let l3_idx = (addr &gt;&gt; 30) &amp; 0o777; // level 3 index let l2_idx = (addr &gt;&gt; 21) &amp; 0o777; // level 2 index let l1_idx = (addr &gt;&gt; 12) &amp; 0o777; // level 1 index let page_offset = addr &amp; 0o7777; // calculate the table addresses let level_4_table_addr = sign | (r &lt;&lt; 39) | (r &lt;&lt; 30) | (r &lt;&lt; 21) | (r &lt;&lt; 12); let level_3_table_addr = sign | (r &lt;&lt; 39) | (r &lt;&lt; 30) | (r &lt;&lt; 21) | (l4_idx &lt;&lt; 12); let level_2_table_addr = sign | (r &lt;&lt; 39) | (r &lt;&lt; 30) | (l4_idx &lt;&lt; 21) | (l3_idx &lt;&lt; 12); let level_1_table_addr = sign | (r &lt;&lt; 39) | (l4_idx &lt;&lt; 30) | (l3_idx &lt;&lt; 21) | (l2_idx &lt;&lt; 12);</span></span></code> </pre> <br>  Ce code suppose qu'un mappage récursif du dernier enregistrement de niveau 4 avec l'index <code>0o777</code> (511) est récursivement mis en correspondance.  Ce n'est actuellement pas le cas, donc le code ne fonctionnera pas encore.  Voir ci-dessous comment dire au chargeur de configurer un mappage récursif. <br><br>  Au lieu d'effectuer des opérations au niveau du bit manuellement, vous pouvez utiliser le type <code>RecursivePageTable</code> de la caisse <code>x86_64</code> , qui fournit des abstractions sûres pour diverses opérations de table.  Par exemple, le code ci-dessous montre comment convertir une adresse virtuelle en son adresse physique correspondante: <br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// in src/memory.rs use x86_64::structures::paging::{Mapper, Page, PageTable, RecursivePageTable}; use x86_64::{VirtAddr, PhysAddr}; /// Creates a RecursivePageTable instance from the level 4 address. let level_4_table_addr = […]; let level_4_table_ptr = level_4_table_addr as *mut PageTable; let recursive_page_table = unsafe { let level_4_table = &amp;mut *level_4_table_ptr; RecursivePageTable::new(level_4_table).unwrap(); } /// Retrieve the physical address for the given virtual address let addr: u64 = […] let addr = VirtAddr::new(addr); let page: Page = Page::containing_address(addr); // perform the translation let frame = recursive_page_table.translate_page(page); frame.map(|frame| frame.start_address() + u64::from(addr.page_offset()))</span></span></code> </pre> <br>  Encore une fois, ce code nécessite un mappage récursif correct.  Avec ce mappage, le <code>level_4_table_addr</code> manquant <code>level_4_table_addr</code> calculé comme dans le premier exemple de code. <br><br><hr><br>  Le mappage récursif est une méthode intéressante qui montre à quel point la correspondance peut être puissante à travers une seule table.  Il est relativement facile à implémenter et ne nécessite qu'une configuration minimale (une seule entrée récursive), c'est donc un bon choix pour les premières expériences. <br><br>  Mais cela présente certains inconvénients: <br><br><ul><li>  Une grande quantité de mémoire virtuelle (512 Gio).  Ce n'est pas un problème dans un grand espace d'adressage 48 bits, mais peut conduire à un comportement de cache sous-optimal. <br></li><li>  Il donne facilement accès uniquement à l'espace d'adressage actuellement actif.  L'accès à d'autres espaces d'adressage est toujours possible en modifiant l'entrée récursive, mais une correspondance temporaire est requise pour la commutation.  Nous avons décrit comment procéder dans un article précédent (obsolète). <br></li><li>  Cela dépend fortement du format de table des pages x86 et peut ne pas fonctionner sur d'autres architectures. </li></ul><br><a name="3"></a><h1>  Prise en charge du chargeur de démarrage </h1><br>  Toutes les approches décrites ci-dessus nécessitent des modifications des tableaux de pages et des paramètres correspondants.  Par exemple, pour mapper de façon identique ou récursive la mémoire physique des enregistrements d'une table de quatrième niveau.  Le problème est que nous ne pouvons pas définir ces paramètres sans accéder aux tableaux de pages. <br><br>  J'ai donc besoin de l'aide du chargeur de démarrage.  Il a accès aux tableaux de pages, il peut donc créer tous les affichages dont nous avons besoin.  Dans sa mise en œuvre actuelle, la caisse du <code>bootloader</code> prend en charge les deux approches ci-dessus en utilisant <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">les fonctions de chargement</a> : <br><br><ul><li>  La fonction <code>map_physical_memory</code> mappe la mémoire physique complète quelque part dans l'espace d'adressage virtuel.  Ainsi, le noyau accède à toute la mémoire physique et peut appliquer une approche avec l' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">affichage de la mémoire physique complète</a> . <br></li><li>  À l'aide de la fonction <code>recursive_page_table</code> , le chargeur affiche récursivement une entrée de table de pages de quatrième niveau.  Cela permet au noyau de fonctionner selon la méthode décrite dans la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">section "Tables de pages récursives"</a> . </li></ul><br>       ,    ,        (      ,     ).           <code>map_physical_memory</code> : <br><br><pre> <code class="plaintext hljs">[dependencies] bootloader = { version = "0.4.0", features = ["map_physical_memory"]}</code> </pre> <br>    ,           .      ,    <i> </i> . <br><br><a name="3_1"></a><h3>   </h3><br>  <code>bootloader</code>   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">BootInfo</a>   ,  .   ,         , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">  semver</a> .       : <code>memory_map</code>  <code>physical_memory_offset</code> : <br><br><ul><li>  <code>memory_map</code>     .   ,             ,   VGA.       BIOS  UEFI,       .       ,          .        . <br></li><li> <code>physical_memory_offset</code>       .      ,     .         . </li></ul><br>     <code>BootInfo</code>    <code>&amp;'static BootInfo</code>   <code>_start</code> .  : <br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// in src/main.rs use bootloader::BootInfo; #[cfg(not(test))] #[no_mangle] pub extern "C" fn _start(boot_info: &amp;'static BootInfo) -&gt; ! { // new argument […] }</span></span></code> </pre> <br>     ,            . <br><br><a name="3_2"></a><h3>    </h3><br>   <code>_start</code>    ,     .  ,           ,           . <br><br>  ,        ,  <code>bootloader</code>   <code>entry_point</code> .       : <br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// in src/main.rs use bootloader::{BootInfo, entry_point}; entry_point!(kernel_main); #[cfg(not(test))] fn kernel_main(boot_info: &amp;'static BootInfo) -&gt; ! { […] }</span></span></code> </pre> <br>        <code>extern "C"</code>  <code>no_mangle</code> ,            <code>_start</code> .  <code>kernel_main</code>      Rust,        .  ,     ,      , ,       ,     <br><br><a name="4"></a><h1>  </h1><br>          , ,   . -,     ,    .      ,    ,     .       ,    . <br><br>        <code>memory</code> : <br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// in src/lib.rs pub mod memory;</span></span></code> </pre> <br>      <code>src/memory.rs</code> . <br><br><a name="4_1"></a><h3>     </h3><br>   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="> </a>      ,    ,        ,     <code>CR3</code> .       :  <code>active_level_4_table</code>         : <br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// in src/memory.rs use x86_64::structures::paging::PageTable; /// Returns a mutable reference to the active level 4 table. /// /// This function is unsafe because the caller must guarantee that the /// complete physical memory is mapped to virtual memory at the passed /// `physical_memory_offset`. Also, this function must be only called once /// to avoid aliasing `&amp;mut` references (which is undefined behavior). pub unsafe fn active_level_4_table(physical_memory_offset: u64) -&gt; &amp;'static mut PageTable { use x86_64::{registers::control::Cr3, VirtAddr}; let (level_4_table_frame, _) = Cr3::read(); let phys = level_4_table_frame.start_address(); let virt = VirtAddr::new(phys.as_u64() + physical_memory_offset); let page_table_ptr: *mut PageTable = virt.as_mut_ptr(); &amp;mut *page_table_ptr // unsafe }</span></span></code> </pre> <br>       4-    <code>CR3</code> .           ,  <code>physical_memory_offset</code> . ,      <code>*mut PageTable</code>  <code>as_mut_ptr</code> ,        <code>&amp;mut PageTable</code> .    <code>&amp;mut</code>  <code>&amp;</code> ,           . <br><br>      unsafe,   Rust    <code>unsafe fn</code>     .   ,          .       .   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">RFC</a>     Rust. <br><br>           : <br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// in src/main.rs #[cfg(not(test))] fn kernel_main(boot_info: &amp;'static BootInfo) -&gt; ! { […] // initialize GDT, IDT, PICS use blog_os::memory::active_level_4_table; let l4_table = unsafe { active_level_4_table(boot_info.physical_memory_offset) }; for (i, entry) in l4_table.iter().enumerate() { if !entry.is_unused() { println!("L4 Entry {}: {:?}", i, entry); } } println!("It did not crash!"); blog_os::hlt_loop(); }</span></span></code> </pre> <br>   <code>physical_memory_offset</code>     <code>BootInfo</code> .    <code>iter</code>         <code><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">enumerate</a></code>    <code>i</code>   .    ,    512     . <br><br>    ,    : <br><br><img src="https://habrastorage.org/getpro/habr/post_images/a33/def/50d/a33def50db528880395b665882aabe75.png"><br><br>     ,       .     ,        ,  ,      . <br><br>           ,         : <br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// in the for loop in src/main.rs use x86_64::{structures::paging::PageTable, VirtAddr}; if !entry.is_unused() { println!("L4 Entry {}: {:?}", i, entry); // get the physical address from the entry and convert it let phys = entry.frame().unwrap().start_address(); let virt = phys.as_u64() + boot_info.physical_memory_offset; let ptr = VirtAddr::new(virt).as_mut_ptr(); let l3_table: &amp;PageTable = unsafe { &amp;*ptr }; // print non-empty entries of the level 3 table for (i, entry) in l3_table.iter().enumerate() { if !entry.is_unused() { println!(" L3 Entry {}: {:?}", i, entry); } } }</span></span></code> </pre> <br>          , ,      .     ,     ,      . <br><br>     ,   ,     .             ,       . <br><br><a name="4_2"></a><h3>   </h3><br>            ,     .  ,     : <br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// in src/memory.rs use x86_64::{PhysAddr, VirtAddr}; /// Translates the given virtual address to the mapped physical address, or /// `None` if the address is not mapped. /// /// This function is unsafe because the caller must guarantee that the /// complete physical memory is mapped to virtual memory at the passed /// `physical_memory_offset`. pub unsafe fn translate_addr(addr: VirtAddr, physical_memory_offset: u64) -&gt; Option&lt;PhysAddr&gt; { translate_addr_inner(addr, physical_memory_offset) }</span></span></code> </pre> <br>      <code>translate_addr_inner</code> ,     .   , Rust    <code>unsafe fn</code>    .    ,       <code>unsafe</code> . <br><br>       : <br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// in src/memory.rs /// Private function that is called by `translate_addr`. /// /// This function is safe to limit the scope of `unsafe` because Rust treats /// the whole body of unsafe functions as an unsafe block. This function must /// only be reachable through `unsafe fn` from outside of this module. fn translate_addr_inner(addr: VirtAddr, physical_memory_offset: u64) -&gt; Option&lt;PhysAddr&gt; { use x86_64::structures::paging::page_table::FrameError; use x86_64::registers::control::Cr3; // read the active level 4 frame from the CR3 register let (level_4_table_frame, _) = Cr3::read(); let table_indexes = [ addr.p4_index(), addr.p3_index(), addr.p2_index(), addr.p1_index() ]; let mut frame = level_4_table_frame; // traverse the multi-level page table for &amp;index in &amp;table_indexes { // convert the frame into a page table reference let virt = frame.start_address().as_u64() + physical_memory_offset; let table_ptr: *const PageTable = VirtAddr::new(virt).as_ptr(); let table = unsafe {&amp;*table_ptr}; // read the page table entry and update `frame` let entry = &amp;table[index]; frame = match entry.frame() { Ok(frame) =&gt; frame, Err(FrameError::FrameNotPresent) =&gt; return None, Err(FrameError::HugeFrame) =&gt; panic!("huge pages not supported"), }; } // calculate the physical address by adding the page offset Some(frame.start_address() + u64::from(addr.page_offset())) }</span></span></code> </pre> <br>     <code>active_level_4_table</code>         <code>CR3</code> ,      .  ,    . <br><br>  <code>VirtAddr</code>           .       ,            <code>for</code> .      ,     . <code>frame</code>               , . .     1. <br><br>      <code>physical_memory_offset</code>        .          <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><code>PageTableEntry::frame</code></a>    .      ,  <code>None</code> .      2   1 ,      . <br><br> ,      : <br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// in src/main.rs #[cfg(not(test))] fn kernel_main(boot_info: &amp;'static BootInfo) -&gt; ! { […] // initialize GDT, IDT, PICS use blog_os::memory::translate_addr; use x86_64::VirtAddr; let addresses = [ // the identity-mapped vga buffer page 0xb8000, // some code page 0x20010a, // some stack page 0x57ac_001f_fe48, // virtual address mapped to physical address 0 boot_info.physical_memory_offset, ]; for &amp;address in &amp;addresses { let virt = VirtAddr::new(address); let phys = unsafe { translate_addr(virt, boot_info.physical_memory_offset) }; println!("{:?} -&gt; {:?}", virt, phys); } println!("It did not crash!"); blog_os::hlt_loop(); }</span></span></code> </pre> <br>    ,   : <br><br><img src="https://habrastorage.org/getpro/habr/post_images/a0b/e32/db8/a0be32db8b6353452f9d40d7b1d350ad.png"><br><br>   ,     <code>0xb8000</code>      .          ,    ,        .  <code>physical_memory_offset</code>      <code>0</code> ,   ,         .             . <br><br><a name="4_3"></a><h3>  MappedPageTable </h3><br>      —    ,   <code>x86_64</code>    .         ,  <code>translate_addr</code> ,            . <br><br>   —  ,       : <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><code>Mapper</code></a>  ,   . , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><code>translate_page</code></a>         ,   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><code>map_to</code></a>      . <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><code>MapperAllSizes</code></a>   <code>Mapper</code>    .  ,   ,      ,    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><code>translate_addr</code></a>   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><code>translate</code></a> . </li></ul><br>    ,     .   <code>x86_64</code>   ,  : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><code>MappedPageTable</code></a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><code>RecursivePageTable</code></a> .  ,      -  (,  ).    ,      . <br><br>        <code>physical_memory_offset</code> ,     MappedPageTable.   ,    <code>init</code>   <code>memory</code> : <br><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">use</span></span> x86_64::structures::paging::{PhysFrame, MapperAllSizes, MappedPageTable}; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> x86_64::PhysAddr; <span class="hljs-comment"><span class="hljs-comment">/// Initialize a new MappedPageTable. /// /// This function is unsafe because the caller must guarantee that the /// complete physical memory is mapped to virtual memory at the passed /// `physical_memory_offset`. Also, this function must be only called once /// to avoid aliasing `&amp;mut` references (which is undefined behavior). pub unsafe fn init(physical_memory_offset: u64) -&gt; impl MapperAllSizes { let level_4_table = active_level_4_table(physical_memory_offset); let phys_to_virt = move |frame: PhysFrame| -&gt; *mut PageTable { let phys = frame.start_address().as_u64(); let virt = VirtAddr::new(phys + physical_memory_offset); virt.as_mut_ptr() }; MappedPageTable::new(level_4_table, phys_to_virt) } // make private unsafe fn active_level_4_table(physical_memory_offset: u64) -&gt; &amp;'static mut PageTable {…}</span></span></code> </pre> <br>      <code>MappedPageTable</code>  ,       .         <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><code>impl Trait</code></a> .    ,       <code>RecursivePageTable</code>    . <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><code>MappedPageTable::new</code></a>   :       4   <code>phys_to_virt</code> ,         <code>*mut PageTable</code> .         <code>active_level_4_table</code> .    ,   <code>physical_memory_offset</code>   . <br><br>    <code>active_level_4_table</code>  ,         <code>init</code> . <br><br>    <code>MapperAllSizes::translate_addr</code>     <code>memory::translate_addr</code> ,       <code>kernel_main</code> : <br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// in src/main.rs #[cfg(not(test))] fn kernel_main(boot_info: &amp;'static BootInfo) -&gt; ! { […] // initialize GDT, IDT, PICS // new: different imports use blog_os::memory; use x86_64::{structures::paging::MapperAllSizes, VirtAddr}; // new: initialize a mapper let mapper = unsafe { memory::init(boot_info.physical_memory_offset) }; let addresses = […]; // same as before for &amp;address in &amp;addresses { let virt = VirtAddr::new(address); // new: use the `mapper.translate_addr` method let phys = mapper.translate_addr(virt); println!("{:?} -&gt; {:?}", virt, phys); } println!("It did not crash!"); blog_os::hlt_loop(); }</span></span></code> </pre> <br>       ,   ,       : <br><br><img src="https://habrastorage.org/getpro/habr/post_images/51d/5ed/d9c/51d5edd9c004e1238b321dee51fdf8b3.png"><br><br>   ,   <code>physical_memory_offset</code>     <code>0x0</code> .      <code>MappedPageTable</code> ,         .         ,   <code>map_to</code> ,       .         <code>memory::translate_addr</code> ,   ,  . <br><br><a name="4_4"></a><h3>    </h3><br>         ,    .         . <br><br>    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><code>map_to</code></a>   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><code>Mapper</code></a> ,     .  ,     : ,    ; ,     ;          <code>frame_allocator</code> .   ,          ,        . <br><br><h4>  <code>create_example_mapping</code> </h4><br>     —    <code>create_example_mapping</code> ,      <code>0xb8000</code> ,     VGA.    ,      ,     :           ,     . <br><br>  <code>create_example_mapping</code>  : <br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// in src/memory.rs use x86_64::structures::paging::{Page, Size4KiB, Mapper, FrameAllocator}; /// Creates an example mapping for the given page to frame `0xb8000`. pub fn create_example_mapping( page: Page, mapper: &amp;mut impl Mapper&lt;Size4KiB&gt;, frame_allocator: &amp;mut impl FrameAllocator&lt;Size4KiB&gt;, ) { use x86_64::structures::paging::PageTableFlags as Flags; let frame = PhysFrame::containing_address(PhysAddr::new(0xb8000)); let flags = Flags::PRESENT | Flags::WRITABLE; let map_to_result = unsafe { mapper.map_to(page, frame, flags, frame_allocator) }; map_to_result.expect("map_to failed").flush(); }</span></span></code> </pre> <br>     <code>page</code> ,   ,    <code>mapper</code>  <code>frame_allocator</code> .  <code>mapper</code>   <code>Mapper&lt;Size4KiB&gt;</code> ,    <code>map_to</code> .   <code>Size4KiB</code> ,   <code>Mapper</code>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="></a>   <code><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">PageSize</a></code> ,      4 ,       2   1 .      4 ,    <code>Mapper&lt;Size4KiB&gt;</code>   <code>MapperAllSizes</code> . <br><br>     <code>PRESENT</code> ,       ,   <code>WRITABLE</code> ,       .  <code>map_to</code> :      ,     <code>unsafe</code> .     .   «  » <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="> </a> . <br><br>  <code>map_to</code>   ,    <code><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Result</a></code> .      ,     ,    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><code>expect</code></a>      .       <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><code>MapperFlush</code></a> ,             (TLB)    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><code>flush</code></a> .   <code>Result</code> ,     [ <code>#[must_use]</code> ]  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="> ,      </a> . <br><br><h4>  <code>FrameAllocator</code> </h4><br>   <code>create_example_mapping</code> ,    <code>FrameAllocator</code> .   ,        ,    .       1    ,       .         ,    3   ,        3, 2  1. <br><br>      ,       .     ,    <code>None</code> .    <code>EmptyFrameAllocator</code>    : <br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// in src/memory.rs /// A FrameAllocator that always returns `None`. pub struct EmptyFrameAllocator; impl FrameAllocator&lt;Size4KiB&gt; for EmptyFrameAllocator { fn allocate_frame(&amp;mut self) -&gt; Option&lt;PhysFrame&gt; { None } }</span></span></code> </pre> <br>    ,        .        ,   ,         1.            , ,    <code>0x1000</code> . <br><br>   ,     <code>0x1000</code> ,       : <br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// in src/main.rs #[cfg(not(test))] fn kernel_main(boot_info: &amp;'static BootInfo) -&gt; ! { […] // initialize GDT, IDT, PICS use blog_os::memory; use x86_64::{structures::paging::Page, VirtAddr}; let mut mapper = unsafe { memory::init(boot_info.physical_memory_offset) }; let mut frame_allocator = memory::EmptyFrameAllocator; // map a previously unmapped page let page = Page::containing_address(VirtAddr::new(0x1000)); memory::create_example_mapping(page, &amp;mut mapper, &amp;mut frame_allocator); // write the string `New!` to the screen through the new mapping let page_ptr: *mut u64 = page.start_address().as_mut_ptr(); unsafe { page_ptr.offset(400).write_volatile(0x_f021_f077_f065_f04e)}; println!("It did not crash!"); blog_os::hlt_loop(); }</span></span></code> </pre> <br>       <code>0x1000</code> ,   <code>create_example_mapping</code>      <code>mapper</code>  <code>frame_allocator</code> .    <code>0x1000</code>     VGA,       ,   . <br><br>            <code>400</code> .      ,      VGA      <code>println</code> .   <code>0x_f021_f077_f065_f04e</code> ,    <i>“New!”</i>   .      <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">«  VGA»</a> ,    VGA   ,    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><code>write_volatile</code></a> . <br><br>     QEMU,    : <br><br><img src="https://habrastorage.org/getpro/habr/post_images/4cf/248/1a0/4cf2481a07f40c681954ff4954dce866.png"><br><br>     <code>0x1000</code>     <i>“New!”</i>  . ,        . <br><br>   ,       1   <code>0x1000</code> .     ,        1,  <code>map_to</code>  ,      <code>EmptyFrameAllocator</code>    .  ,   ,     <code>0xdeadbeaf000</code>  <code>0x1000</code> : <br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// in src/main.rs #[cfg(not(test))] fn kernel_main(boot_info: &amp;'static BootInfo) -&gt; ! { […] let page = Page::containing_address(VirtAddr::new(0xdeadbeaf000)); […] }</span></span></code> </pre> <br>   ,       : <br><br><pre> <code class="plaintext hljs">panicked at 'map_to failed: FrameAllocationFailed', /…/result.rs:999:5</code> </pre> <br>   ,        1,    <code>FrameAllocator</code> .   ,        ? <br><br><a name="4_5"></a><h3>   </h3><br>         .    : <br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// in src/memory.rs pub struct BootInfoFrameAllocator&lt;I&gt; where I: Iterator&lt;Item = PhysFrame&gt; { frames: I, } impl&lt;I&gt; FrameAllocator&lt;Size4KiB&gt; for BootInfoFrameAllocator&lt;I&gt; where I: Iterator&lt;Item = PhysFrame&gt; { fn allocate_frame(&amp;mut self) -&gt; Option&lt;PhysFrame&gt; { self.frames.next() } }</span></span></code> </pre> <br>  <code>frames</code>      .      <code>alloc</code>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><code>Iterator::next</code></a> . <br><br>   <code>BootInfoFrameAllocator</code>    <code>memory_map</code> ,       <code>BootInfo</code> .     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">« »</a> ,     BIOS/UEFI.         ,      . <br><br>       <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><code>MemoryRegion</code></a> ,    ,    (, ,   . .)   .  ,      ,     <code>BootInfoFrameAllocator</code> . <br><br>  <code>BootInfoFrameAllocator</code>     <code>init_frame_allocator</code> : <br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// in src/memory.rs use bootloader::bootinfo::{MemoryMap, MemoryRegionType}; /// Create a FrameAllocator from the passed memory map pub fn init_frame_allocator( memory_map: &amp;'static MemoryMap, ) -&gt; BootInfoFrameAllocator&lt;impl Iterator&lt;Item = PhysFrame&gt;&gt; { // get usable regions from memory map let regions = memory_map .iter() .filter(|r| r.region_type == MemoryRegionType::Usable); // map each region to its address range let addr_ranges = regions.map(|r| r.range.start_addr()..r.range.end_addr()); // transform to an iterator of frame start addresses let frame_addresses = addr_ranges.flat_map(|r| r.step_by(4096)); // create `PhysFrame` types from the start addresses let frames = frame_addresses.map(|addr| { PhysFrame::containing_address(PhysAddr::new(addr)) }); BootInfoFrameAllocator { frames } }</span></span></code> </pre> <br>         <code>MemoryMap</code>     : <br><br><ul><li> -,   <code>iter</code>       <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><code>MemoryRegion</code></a> .    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><code>filter</code></a>      .       ,  ,  ,   (,   )      ,    <code>InUse</code>  .  ,    ,   <code>Usable</code>   - . <br></li><li>      <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><code>map</code></a>    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">range</a>  Rust         . <br></li><li>    :         <code>into_iter</code> ,     4096-    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><code>step_by</code></a> .  4096  (= 4 ) —   ,      .      ,         .  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><code>flat_map</code></a>  <code>map</code> ,   <code>Iterator&lt;Item = u64&gt;</code>  <code>Iterator&lt;Item = Iterator&lt;Item = u64&gt;&gt;</code> . <br></li><li>         <code>PhysFrame</code> ,    <code>Iterator&lt;Item = PhysFrame&gt;</code> .          <code>BootInfoFrameAllocator</code> . </li></ul><br>      <code>kernel_main</code> ,    <code>BootInfoFrameAllocator</code>  <code>EmptyFrameAllocator</code> : <br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// in src/main.rs #[cfg(not(test))] fn kernel_main(boot_info: &amp;'static BootInfo) -&gt; ! { […] let mut frame_allocator = memory::init_frame_allocator(&amp;boot_info.memory_map); […] }</span></span></code> </pre> <br>              -  <i>“New!”</i>  .    <code>map_to</code>      : <br><br><ul><li>      <code>frame_allocator</code> . <br></li><li>        . <br></li><li>         . <br></li><li>     . </li></ul><br>    <code>create_example_mapping</code> —    ,         .            . <br><br><a name="5"></a><h1>  Résumé </h1><br>              ,   ,    ,      .           . <br><br>             ,    .  <code>bootloader</code>       cargo.        <code>&amp;BootInfo</code>    . <br><br>          ,   ,     <code>MappedPageTable</code>  <code>x86_64</code> .   ,           <code>FrameAllocator</code>   ,  . <br><br><a name="6"></a><h1>  ? </h1><br>          ,   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="> </a>    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="> </a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr445618/">https://habr.com/ru/post/fr445618/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr445596/index.html">Trucs et astuces Kubernetes: pages d'erreur personnalisées dans NGINX Ingress</a></li>
<li><a href="../fr445600/index.html">[Sondage et mal] Hébergement, qu'ils se trompent</a></li>
<li><a href="../fr445602/index.html">PHP Russie 2019: son «stade» pour la langue de première ligue</a></li>
<li><a href="../fr445608/index.html">Game over: les analystes signalent une augmentation du nombre d'attaques DDoS sur le segment des jeux</a></li>
<li><a href="../fr445612/index.html">Stockage en cluster pour les petits clusters Web basés sur drbd + ocfs2</a></li>
<li><a href="../fr445620/index.html">Que fait un écrivain UX?</a></li>
<li><a href="../fr445622/index.html">Nouveau dans Java 12: The Teeing Collector</a></li>
<li><a href="../fr445626/index.html">Quelle est la profondeur du terrier du lapin? CLRium # 5: Garbage Collector</a></li>
<li><a href="../fr445632/index.html">De l'analyseur de l'affiche du théâtre Python au bot Telegram. 2e partie</a></li>
<li><a href="../fr445638/index.html">Stage aveugle au Garage Museum of Modern Art</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>