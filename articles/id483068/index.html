<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üé≤ üõÄüèº üë± Membalikkan rekayasa BattlEye anti-cheat populer üïü üòë üññ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="BattlEye didominasi oleh anti-cheat pihak ketiga Jerman, terutama dikembangkan oleh Bastian Heiko Suter yang berusia 32 tahun. Ini memberikan (atau me...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Membalikkan rekayasa BattlEye anti-cheat populer</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/483068/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/ps/ae/ij/psaeijpcayldgrqiqeiq6l83nue.jpeg"></div><br>  BattlEye didominasi oleh anti-cheat pihak ketiga Jerman, terutama dikembangkan oleh <em>Bastian Heiko Suter yang</em> berusia 32 tahun.  Ini memberikan (atau mencoba untuk memberikan) penerbit game dengan sistem anti-cheat yang mudah digunakan yang menggunakan mekanisme perlindungan umum, serta deteksi cheat untuk game tertentu untuk mengoptimalkan keamanan.  Seperti yang dinyatakan di situs web produk, selalu berada di puncak teknologi modern dan menggunakan metode perlindungan dan deteksi yang inovatif;  jelas ini adalah konsekuensi dari kebangsaan pengembang: <code>QUALITY MADE IN GERMANY</code>  BattlEye terdiri dari banyak elemen yang bekerja sama untuk menemukan curang dalam permainan yang telah membayar untuk penggunaan produk.  Empat elemen utama adalah: <br><br><ul><li>  BEService <ul><li>  Layanan sistem Windows yang berkomunikasi dengan server BattlEye <em>BEServer</em> , yang menyediakan komunikasi client-server dengan <em>BEDaisy</em> dan <em>BEClient</em> . </li></ul></li><li>  BEDaisy <ul><li>  Pengandar kernel Windows yang mencatat mekanisme pemrosesan acara preventif dan filter mini untuk mencegah curang mengubah game secara ilegal </li></ul></li><li>  Menjadi <ul><li>  Pustaka Windows yang terhubung secara dinamis yang bertanggung jawab untuk sebagian besar vektor deteksi, termasuk yang dijelaskan dalam artikel ini.  Setelah inisialisasi, ia menjadi melekat pada proses game. </li></ul></li><li>  Beserver <ul><li>  Server backend milik, yang bertanggung jawab untuk mengumpulkan informasi dan mengambil tindakan spesifik terhadap curang. </li></ul></li></ul><br><h1>  Shellcode </h1><br>  Baru-baru ini, tumpukan kode shell BattlEye muncul di Internet, dan kami memutuskan untuk menulis tentang apa yang sebenarnya dicari versi BattlEye.  Kami tidak menganalisis BattlEye selama enam bulan, jadi dump shellcode terakhir kami kemungkinan besar sudah usang.  Berbagai bagian kode dipulihkan hanya dari memori dari dump terakhir ini, dengan asumsi bahwa BattlEye hanya menyelesaikan kode shell dan tidak menghapus prosedur deteksi sebelumnya. <br><a name="habracut"></a><br><h1>  Bagaimana? </h1><br>  BattlEye diduga melakukan stream shellcode dari servernya ke layanan Windows yang disebut BEService.  Layanan ini berkomunikasi dengan modul BEClient yang terletak di dalam game.  Pertukaran data dilakukan melalui <code>\.namedpipeBattleye</code> dan hingga 2018 tidak dienkripsi.  Sekarang semua data yang dikirim dienkripsi dengan xor-enkripsi dengan kunci yang sangat kecil, yang membuatnya sangat mudah untuk melakukan serangan plaintext yang terkenal.  Ketika kode shell ditransmisikan ke klien, itu terletak dan dieksekusi di luar semua modul yang dikenal, yang membuatnya mudah untuk ditentukan.  Untuk membuat dump shellcode, Anda dapat memproses fungsi Windows API standar seperti CreateFile, ReadFile, dll., Dan membuang area memori yang sesuai dari semua modul panggilan (meminta informasi memori untuk alamat yang dikembalikan) yang berada di luar semua modul yang dikenal, atau memindai ruang memori virtual game secara berkala untuk mencari memori yang dapat dieksekusi di luar semua modul yang diketahui, dan membuangnya ke disk.  Pada saat yang sama, Anda perlu melacak area mana yang sudah dibuang, sehingga Anda tidak akan mendapatkan banyak dump identik. <br><br><h1>  Penjelasan </h1><br>  Potongan-potongan pseudocode yang disajikan dalam artikel <strong>sangat</strong> dimodifikasi demi kecantikan.  Anda tidak akan dapat membuang kode shell BattlEye dan segera mengenali bagian-bagian ini;  shellcode tidak berisi panggilan fungsi, dan banyak algoritma dalam artikel ini digunakan.  Tetapi pada kenyataannya, ini tidak penting, karena ketika Anda selesai membaca tentang zaman kuno yang mengerikan ini, Anda akan memiliki kesempatan untuk mengatasinya (: <br><br><h2>  Penyortiran memori </h2><br>  Mekanisme deteksi yang paling umum dalam anti-cheat adalah enumerasi memori dan pemindaian memori untuk mencari gambar cheat yang <em>diketahui</em> .  Mudah untuk diimplementasikan dan, seperti yang ditunjukkan oleh masa lalu, dengan pendekatan yang tepat, cukup efektif jika Anda tidak melupakan dasar-dasar assembler dan memasukkan prolog fungsi umum dalam daftar hitam. <br><br>  Battleye mengulangi seluruh ruang alamat dari proses game (proses saat ini dalam konteks ini) dan melakukan berbagai pemeriksaan pada kinerja halaman dan menemukan kode shell di luar ruang memori yang sesuai. <br><br>  Inilah cara penerapannya di Battleye: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// MEMORY ENUMERATION for (current_address = 0 // QUERY MEMORY_BASIC_INFORMATION NtQueryVirtualMemory(GetCurrentProcess(), current_address, 0, &amp;memory_information, 0x30, &amp;return_length) &gt;= 0 current_address = memory_information.base_address + memory_information.region_size) { const auto outside_of_shellcode = memory_information.base_address &gt; shellcode_entry || memory_information.base_address + memory_information.region_size &lt;= shellcode_entry const auto executable_memory = memory_information.state == MEM_COMMIT &amp;&amp; (memory_information.protect == PAGE_EXECUTE || memory_information.protect == PAGE_EXECUTE_READ || memory_information.protect == PAGE_EXECUTE_READWRITE const auto unknown_whitelist = memory_information.protect != PAGE_EXECUTE_READWRITE || memory_information.region_size != 100000000 if (!executable_memory || !outside_of_shellcode || !unknown_whitelist) continue // RUN CHECKS memory::anomaly_check(memory_information memory::pattern_check(current_address, memory_information memory::module_specific_check_microsoft(memory_information memory::guard_check(current_address, memory_information memory::module_specific_check_unknown(memory_information }</span></span></code> </pre> <br><h1>  Anomali memori </h1><br>  BattlEye menandai semua anomali di ruang alamat memori, terutama memori modul yang dapat dieksekusi yang tidak sesuai dengan gambar yang dimuat: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> memory::anomaly_check(MEMORY_BASIC_INFORMATION memory_information) { <span class="hljs-comment"><span class="hljs-comment">// REPORT ANY EXECUTABLE PAGE OUTSIDE OF KNOWN MODULES if (memory_information.type == MEM_PRIVATE || memory_information.type == MEM_MAPPED) { if ((memory_information.base_address &amp; 0xFF0000000000) != 0x7F0000000000 &amp;&amp; // UPPER EQUALS 0x7F (memory_information.base_address &amp; 0xFFF000000000) != 0x7F000000000 &amp;&amp; // UPPER EQUALS 0x7F0 (memory_information.base_address &amp; 0xFFFFF0000000) != 0x70000000 &amp;&amp; // UPPER EQUALS 0x70000 memory_information.base_address != 0x3E0000)) { memory_report.unknown = 0 memory_report.report_id = 0x2F memory_report.base_address = memory_information.base_address memory_report.region_size = memory_information.region_size memory_report.memory_info = memory_information.type | memory_information.protect | memory_information.state battleye::report(&amp;memory_report, sizeof(memory_report), 0 } } }</span></span></code> </pre> <br><h1>  Memindai Pola </h1><br>  Seperti disebutkan di atas, BattlEye juga memindai memori proses lokal untuk keberadaan berbagai pola yang jelas, seperti yang dapat dilihat dari implementasi yang ditunjukkan di bawah ini. <br><br>  Saat membaca pseudo-code ini, Anda bisa menebak bahwa <strong>pemeriksaan ini dapat dielakkan dengan</strong> menulis ulang area kode dari setiap modul yang dimuat, karena mereka tidak akan memindai mencari pola dalam gambar yang dikenal.  Agar tidak jatuh ke pemeriksaan integritas, Anda perlu mengunduh semua area yang dikemas dan masuk daftar putih serta menulis ulang area kode yang ditandai sebagai <em>RWX</em> , karena kami tidak dapat melakukan pemeriksaan integritas tanpa meniru pembuat paket.  Dalam versi saat ini dari shelll BattlEye, pola-pola memori ini adalah kode-keras: <br><br><pre> <code class="cpp hljs">[<span class="hljs-number"><span class="hljs-number">05</span></span> <span class="hljs-number"><span class="hljs-number">18</span></span>] ojectsPUBGChinese [<span class="hljs-number"><span class="hljs-number">05</span></span> <span class="hljs-number"><span class="hljs-number">17</span></span>] BattleGroundsPrivate_CheatESP [<span class="hljs-number"><span class="hljs-number">05</span></span> <span class="hljs-number"><span class="hljs-number">17</span></span>] [%<span class="hljs-number"><span class="hljs-number">.0</span></span>fm] %s [<span class="hljs-number"><span class="hljs-number">05</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span>E] <span class="hljs-number"><span class="hljs-number">0000</span></span>Neck0000Chest0000000Mouse <span class="hljs-number"><span class="hljs-number">10</span></span> [<span class="hljs-number"><span class="hljs-number">05</span></span> <span class="hljs-number"><span class="hljs-number">3F</span></span>] PlayerESPColor [<span class="hljs-number"><span class="hljs-number">05</span></span> <span class="hljs-number"><span class="hljs-number">40</span></span>] Aimbot: %d02D3E2041 [<span class="hljs-number"><span class="hljs-number">05</span></span> <span class="hljs-number"><span class="hljs-number">36</span></span>] HackMachine [<span class="hljs-number"><span class="hljs-number">05</span></span> <span class="hljs-number"><span class="hljs-number">4</span></span>A] VisualHacks.net [<span class="hljs-number"><span class="hljs-number">05</span></span> <span class="hljs-number"><span class="hljs-number">50</span></span>] <span class="hljs-number"><span class="hljs-number">3E232</span></span>F653E31314E4E563D4276282A3A2E463F757523286752552E6F30584748 [<span class="hljs-number"><span class="hljs-number">05</span></span> <span class="hljs-number"><span class="hljs-number">4F</span></span>] DLLInjection-master\x64\Release\ [<span class="hljs-number"><span class="hljs-number">05</span></span> <span class="hljs-number"><span class="hljs-number">52</span></span>] NameESP [<span class="hljs-number"><span class="hljs-number">05</span></span> <span class="hljs-number"><span class="hljs-number">48</span></span>] Skullhack [<span class="hljs-number"><span class="hljs-number">05</span></span> <span class="hljs-number"><span class="hljs-number">55</span></span>] .rdata$zzzdbg [<span class="hljs-number"><span class="hljs-number">05</span></span> <span class="hljs-number"><span class="hljs-number">39</span></span>] AimBot [<span class="hljs-number"><span class="hljs-number">05</span></span> <span class="hljs-number"><span class="hljs-number">39</span></span>] EB4941803C123F755C623FEB388D41D0FBEC93C977583E930EB683E1DF [<span class="hljs-number"><span class="hljs-number">05</span></span> <span class="hljs-number"><span class="hljs-number">5F</span></span>] <span class="hljs-number"><span class="hljs-number">55E9</span></span> [<span class="hljs-number"><span class="hljs-number">05</span></span> <span class="hljs-number"><span class="hljs-number">5F</span></span>] <span class="hljs-number"><span class="hljs-number">57E9</span></span> [<span class="hljs-number"><span class="hljs-number">05</span></span> <span class="hljs-number"><span class="hljs-number">5F</span></span>] <span class="hljs-number"><span class="hljs-number">60E9</span></span> [<span class="hljs-number"><span class="hljs-number">05</span></span> <span class="hljs-number"><span class="hljs-number">68</span></span>] D3D11Present initialised [<span class="hljs-number"><span class="hljs-number">05</span></span> <span class="hljs-number"><span class="hljs-number">6</span></span>E] [ %<span class="hljs-number"><span class="hljs-number">.0</span></span>fM ] [<span class="hljs-number"><span class="hljs-number">05</span></span> <span class="hljs-number"><span class="hljs-number">74</span></span>] [hp:%d]%dm [<span class="hljs-number"><span class="hljs-number">05</span></span> <span class="hljs-number"><span class="hljs-number">36</span></span>] <span class="hljs-number"><span class="hljs-number">48836424380488</span></span>D4C2458488B5424504C8BC848894C24304C8BC7488D4C2460 [<span class="hljs-number"><span class="hljs-number">05</span></span> <span class="hljs-number"><span class="hljs-number">36</span></span>] <span class="hljs-number"><span class="hljs-number">741F</span></span>BA80000FF15607E0085C07510F2F1087801008B8788100EB [<span class="hljs-number"><span class="hljs-number">05</span></span> <span class="hljs-number"><span class="hljs-number">36</span></span>] <span class="hljs-number"><span class="hljs-number">40F</span></span>2AA156F8D2894E9AB4489535D34F9CPOSITION0000COL [<span class="hljs-number"><span class="hljs-number">05</span></span> <span class="hljs-number"><span class="hljs-number">7</span></span>A] FFE090 [<span class="hljs-number"><span class="hljs-number">05</span></span> <span class="hljs-number"><span class="hljs-number">79</span></span>] %s00%d00POSITION0000COLOR0000000 [<span class="hljs-number"><span class="hljs-number">05</span></span> <span class="hljs-number"><span class="hljs-number">36</span></span>] <span class="hljs-number"><span class="hljs-number">8E85765</span></span>DCDDA452E75BA12B4C7B94872116DB948A1DAA6B948A7676BB948902C [<span class="hljs-number"><span class="hljs-number">05</span></span> <span class="hljs-number"><span class="hljs-number">8</span></span>A] n&lt;assembly xmlsn=<span class="hljs-string"><span class="hljs-string">'urn:schemas-mi</span></span></code> </pre> <br>  Pola memori ini juga berisi header dua byte, yaitu nilai statis <code>05</code> tidak diketahui dan pengidentifikasi unik. <br><br>  Apa yang tidak akan kita lihat adalah bahwa BattlEye juga secara dinamis mengalirkan pola dari <em>BEServer</em> dan mengirimkannya ke <em>BEClient</em> , tetapi kita tidak akan membahas ini dalam artikel. <br><br>  Mereka dipindai secara iteratif oleh algoritma berikut: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> memory::pattern_check(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>* current_address, MEMORY_BASIC_INFORMATION memory_information) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> is_user32 = memory_information.allocation_base == GetModuleHandleA(<span class="hljs-string"><span class="hljs-string">"user32.dll"</span></span> <span class="hljs-comment"><span class="hljs-comment">// ONLY SCAN PRIVATE MEMORY AND USER32 CODE SECTION if (memory_information.type != MEM_PRIVATE &amp;&amp; !is_user32) continue for (address = current_address address != memory_information.base_address + memory_information.region_size address += PAGE_SIZE) // PAGE_SIZE { // READ ENTIRE PAGE FROM LOCAL PROCESS INTO BUFFER if (NtReadVirtualMemory(GetCurrentProcess(), address, buffer, PAGE_SIZE, 0) &lt; 0) continue for (pattern_index = 0 pattern_index &lt; 0x1C/*PATTERN COUNT*/ ++pattern_index) { if (pattern[pattern_index].header == 0x57A &amp;&amp; !is_user32) // ONLY DO FFE090 SEARCHES WHEN IN USER32 continue for (offset = 0 pattern[pattern_index].length + offset &lt;= PAGE_SIZE ++offset) { const auto pattern_matches = memory::pattern_match(&amp;address[offset], pattern[pattern_index // BASIC PATTERN MATCH if (pattern_matches) { // PATTERN FOUND IN MEMORY pattern_report.unknown = 0 pattern_report.report_id = 0x35 pattern_report.type = pattern[index].header pattern_report.data = &amp;address[offset pattern_report.base_address = memory_information.base_address pattern_report.region_size = memory_information.region_size pattern_report.memory_info = memory_information.type | memory_information.protect | memory_information.state battleye::report(&amp;pattern_report, sizeof(pattern_report), 0 } } } } }</span></span></code> </pre> <br><h1>  Validasi modul tertentu (Microsoft) </h1><br>  Pemeriksaan modul melaporkan keberadaan modul tertentu yang dimuat ke dalam gim: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> memory::module_specific_check_microsoft(MEMORY_BASIC_INFORMATION memory_information) { <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> executable = memory_information.protect == PAGE_EXECUTE || memory_information.protect == PAGE_EXECUTE_READ || memory_information.protect == PAGE_EXECUTE_READWRITE <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> allocated = memory_information.state == MEM_COMMIT <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!allocated || !executable) <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> mmres_handle = GetModuleHandleA(<span class="hljs-string"><span class="hljs-string">"mmres.dll"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> mshtml_handle = GetModuleHandleA(<span class="hljs-string"><span class="hljs-string">"mshtml.dll"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (mmres_handle &amp;&amp; mmres_handle == memory_information.allocation_base) { battleye_module_anomaly_report module_anomaly_report module_anomaly_report.unknown = <span class="hljs-number"><span class="hljs-number">0</span></span> module_anomaly_report.report_id = <span class="hljs-number"><span class="hljs-number">0x5B</span></span> module_anomaly_report.identifier = <span class="hljs-number"><span class="hljs-number">0x3480</span></span> module_anomaly_report.region_size = memory_information.region_size battleye::report(&amp;module_anomaly_report, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(module_anomaly_report), <span class="hljs-number"><span class="hljs-number">0</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (mshtml_handle &amp;&amp; mshtml_handle == memory_information.allocation_base) { battleye_module_anomaly_report module_anomaly_report module_anomaly_report.unknown = <span class="hljs-number"><span class="hljs-number">0</span></span> module_anomaly_report.report_id = <span class="hljs-number"><span class="hljs-number">0x5B</span></span> module_anomaly_report.identifier = <span class="hljs-number"><span class="hljs-number">0xB480</span></span> module_anomaly_report.region_size = memory_information.region_size battleye::report(&amp;module_anomaly_report, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(module_anomaly_report), <span class="hljs-number"><span class="hljs-number">0</span></span> } }</code> </pre> <br><h1>  Memeriksa modul tertentu (tidak diketahui) </h1><br>  Pemeriksaan modul tertentu telah ditambahkan ke sistem, yang memberi sinyal server bahwa Anda telah memuat modul yang memenuhi <em>salah</em> satu kriteria berikut: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> memory::module_specific_check_unknown(MEMORY_BASIC_INFORMATION memory_information) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> dos_header = (DOS_HEADER*)module_handle <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> pe_header = (PE_HEADER*)(module_handle + dos_header-&gt;e_lfanew <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> is_image = memory_information.state == MEM_COMMIT &amp;&amp; memory_information.type == MEM_IMAGE <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!is_image) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> is_base = memory_information.base_address == memory_information.allocation_base <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!is_base) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> match_1 = time_date_stamp == <span class="hljs-number"><span class="hljs-number">0x5B12C900</span></span> &amp;&amp; *(__int8*)(memory_information.base_address + <span class="hljs-number"><span class="hljs-number">0x1000</span></span>) == <span class="hljs-number"><span class="hljs-number">0x00</span></span> &amp;&amp; *(__int32*)(memory_information.base_address + <span class="hljs-number"><span class="hljs-number">0x501000</span></span>) != <span class="hljs-number"><span class="hljs-number">0x353E900</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> match_2 = time_date_stamp == <span class="hljs-number"><span class="hljs-number">0x5A180C35</span></span> &amp;&amp; *(__int8*)(memory_information.base_address + <span class="hljs-number"><span class="hljs-number">0x1000</span></span>) != <span class="hljs-number"><span class="hljs-number">0x00</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> match_2 = time_date_stamp == <span class="hljs-number"><span class="hljs-number">0xFC9B9325</span></span> &amp;&amp; *(__int8*)(memory_information.base_address + <span class="hljs-number"><span class="hljs-number">0x6D3000</span></span>) != <span class="hljs-number"><span class="hljs-number">0x00</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!match_1 &amp;&amp; !match_2 &amp;&amp; !match_3) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> buffer_offset = <span class="hljs-number"><span class="hljs-number">0x00</span></span> <span class="hljs-comment"><span class="hljs-comment">// OFFSET DEPENDS ON WHICH MODULE MATCHES, RESPECTIVELY 0x501000, 0x1000 AND 0x6D3000 unknown_module_report.unknown1 = 0 unknown_module_report.report_id = 0x46 unknown_module_report.unknown2 = 1 unknown_module_report.data = *(__int128*)(memory_information.base_address + buffer_offset battleye::report(&amp;unknown_module_report, sizeof(unknown_module_report), 0 }</span></span></code> </pre> <br>  Kami tidak tahu modul mana yang memenuhi kriteria ini, tetapi kami menduga bahwa ini adalah upaya untuk mendeteksi serangkaian modul cheat spesifik yang sangat terbatas. <br><br>  Tambahan: @ how02 memberi tahu kami bahwa modul <code>action_x64.dll</code> memiliki <code>0x5B12C900</code> waktu <code>0x5B12C900</code> dan berisi area kode yang dapat Anda tulis;  seperti yang disebutkan sebelumnya, ini dapat digunakan untuk mengeksploitasi. <br><br><h1>  Perlindungan memori </h1><br>  BattlEye juga mengimplementasikan prosedur deteksi yang sangat meragukan, yang, menurut pendapat kami, mencari memori dengan <em>set</em> flag <em>PAGE_GUARD</em> , tanpa benar-benar memeriksa apakah flag <em>PAGE_GUARD diatur</em> : <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> memory::guard_check(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>* current_address, MEMORY_BASIC_INFORMATION memory_information) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (memory_information.protect != PAGE_NOACCESS) { <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> bad_ptr = IsBadReadPtr(current_address, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(temporary_buffer <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> read = NtReadVirtualMemory( GetCurrentProcess(), current_address, temporary_buffer, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(temporary_buffer), <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (read &lt; <span class="hljs-number"><span class="hljs-number">0</span></span> || bad_ptr) { <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> query = NtQueryVirtualMemory( GetCurrentProcess(), current_address, <span class="hljs-number"><span class="hljs-number">0</span></span>, &amp;new_memory_information, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(new_memory_information), &amp;return_length memory_guard_report.guard = query &lt; <span class="hljs-number"><span class="hljs-number">0</span></span> || new_memory_information.state != memory_information.state || new_memory_information.protect != memory_information.protect <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (memory_guard_report.guard) { memory_guard_report.unknown = <span class="hljs-number"><span class="hljs-number">0</span></span> memory_guard_report.report_id = <span class="hljs-number"><span class="hljs-number">0x21</span></span> memory_guard_report.base_address = memory_information.base_address memory_guard_report.region_size = (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)memory_information.region_size memory_guard_report.memory_info = memory_information.type | memory_information.protect | memory_information.state battleye::report(&amp;memory_guard_report, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(memory_guard_report), <span class="hljs-number"><span class="hljs-number">0</span></span> } } } }</code> </pre> <br><h2>  Penyortiran Jendela </h2><br>  Kode shell BattlEye beriterasi di atas setiap jendela yang saat ini terlihat selama permainan, melewati jendela dari atas ke bawah (berdasarkan nilai-z).  Gagang jendela di dalam gim dikecualikan dari enumerasi ini, dan ini ditentukan dengan memanggil <code>GetWindowThreadProcessId</code> .  Oleh karena itu, Anda dapat mengikat fungsi yang sesuai ke pemilik jendela yang salah sehingga <strong>BattlEye tidak memeriksa jendela Anda</strong> . <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> window_handler::enumerate() { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> window_handle = GetTopWindow window_handle window_handle = GetWindow(window_handle, GW_HWNDNEXT), <span class="hljs-comment"><span class="hljs-comment">// GET WINDOW BELOW ++window_handler::windows_enumerated) // INCREMENT GLOBAL COUNT FOR LATER USAGE { auto window_process_pid = 0 GetWindowThreadProcessId(window_handle, &amp;window_process_pid if (window_process_pid == GetCurrentProcessId()) continue // APPEND INFORMATION TO THE MISC. REPORT, THIS IS EXPLAINED LATER IN THE ARTICLE window_handler::handle_summary(window_handle constexpr auto max_character_count = 0x80 const auto length = GetWindowTextA(window_handle, window_title_report.window_title, max_character_count // DOES WINDOW TITLE MATCH ANY OF THE BLACKLISTED TITLES? if (!contains(window_title_report.window_title, "CheatAut") &amp;&amp; !contains(window_title_report.window_title, "pubg_kh") &amp;&amp; !contains(window_title_report.window_title, "conl -") &amp;&amp; !contains(window_title_report.window_title, "PerfectA") &amp;&amp; !contains(window_title_report.window_title, "AIMWA") &amp;&amp; !contains(window_title_report.window_title, "PUBG AIM") &amp;&amp; !contains(window_title_report.window_title, "HyperChe")) continue // REPORT WINDOW window_title_report.unknown_1 = 0 window_title_report.report_id = 0x33 battleye::report(&amp;window_title_report, sizeof(window_title_report) + length, 0 } }</span></span></code> </pre> <br><h2>  Cari anomali </h2><br>  Jika kurang dari dua jendela diperiksa, pemberitahuan dikirim ke server.  Ini mungkin dilakukan untuk mencegah penambalan fungsi yang sesuai yang tidak memungkinkan kode shell BattlEye memeriksa jendela apa pun: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> window_handler::check_count() { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (window_handler::windows_enumerated &gt; <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-comment"><span class="hljs-comment">// WINDOW ENUMERATION FAILED, MOST LIKELY DUE TO HOOK window_anomaly_report.unknown_1 = 0 window_anomaly_report.report_id = 0x44 window_anomaly_report.enumerated_windows = windows_enumerated battleye::report(&amp;window_anomaly_report, sizeof(window_anomaly_report), 0 }</span></span></code> </pre> <br><h2>  Proses Penyortiran </h2><br>  Dengan memanggil <code>CreateToolhelp32Snapshot</code> mengulangi semua proses yang sedang berjalan, tetapi <strong>tidak memproses kesalahan</strong> , membuatnya sangat mudah untuk ditambal dan menghindari prosedur deteksi berikut: <br><br><h1>  Pemeriksaan jalur </h1><br>  Jika gambar berada di dalam setidaknya dua subdirektori (dihitung dari akar disk), sistem akan menandai proses jika jalur ke gambar yang sesuai berisi setidaknya satu dari baris berikut: <br><br><pre> <code class="cpp hljs">Desktop Temp FileRec Documents Downloads Roaming tmp.ex notepad. ...\. cmd.ex</code> </pre> <br>  Jika jalur ke file yang dapat dieksekusi sesuai dengan salah satu dari baris ini, server menerima pemberitahuan tentang jalur ke file yang dapat dieksekusi, serta informasi tentang apakah proses induk adalah salah satu dari berikut ini (berisi bit bendera terkait yang dikirim ke server): <br><br><pre> <code class="cpp hljs">steam.exe [<span class="hljs-number"><span class="hljs-number">0x01</span></span>] explorer.exe [<span class="hljs-number"><span class="hljs-number">0x02</span></span>] lsass.exe [<span class="hljs-number"><span class="hljs-number">0x08</span></span>] cmd.exe [<span class="hljs-number"><span class="hljs-number">0x10</span></span>]</code> </pre> <br>  Jika klien tidak dapat membuka deskriptor dengan hak <code>QueryLimitedInformation</code> sesuai, maka itu akan menetapkan bit flag <code>0x04</code> , jika penyebab kesalahan ketika panggilan <code>OpenProcess</code> gagal bukan <code>ERROR_ACCESS_DENIED</code> , yang memberi kami wadah enumerasi terakhir untuk nilai flag yang sesuai: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> BATTLEYE_PROCESS_FLAG { STEAM = <span class="hljs-number"><span class="hljs-number">0x1</span></span>, EXPLORER = <span class="hljs-number"><span class="hljs-number">0x2</span></span>, ERROR = <span class="hljs-number"><span class="hljs-number">0x4</span></span>, LSASS = <span class="hljs-number"><span class="hljs-number">0x8</span></span>, CMD = <span class="hljs-number"><span class="hljs-number">0x10</span></span> }</code> </pre> <br>  Jika proses induk adalah steam, maka flag langsung diatur untuk pengguna dan server diberitahu tentang hal ini dengan notifikasi <code>0x40</code> <br><br><h1>  Nama gambar </h1><br>  Jika proses memenuhi salah satu dari banyak kriteria yang disajikan di bawah ini, maka Anda langsung menetapkan bendera dan ini dilaporkan ke server dengan notifikasi <code>0x38</code> <br><br><pre> <code class="cpp hljs">   <span class="hljs-string"><span class="hljs-string">"Loadlibr"</span></span>    <span class="hljs-string"><span class="hljs-string">"Rng "</span></span>    <span class="hljs-string"><span class="hljs-string">"A0E7FFFFFF81"</span></span>    <span class="hljs-string"><span class="hljs-string">"RNG "</span></span>    <span class="hljs-string"><span class="hljs-string">"90E54355"</span></span>    <span class="hljs-string"><span class="hljs-string">"2.6.ex"</span></span>    <span class="hljs-string"><span class="hljs-string">"TempFile.exe"</span></span></code> </pre> <br><h1>  Hamparan Game Steam </h1><br>  BattlEye memonitor proses overlay permainan Steam, yang bertanggung jawab atas overlay dalam game, yang diketahui oleh sebagian besar pengguna Steam.  Nama host lengkap dari hamparan Steam Games adalah <code>gameoverlayui.exe</code> ;  diketahui bahwa itu sering digunakan untuk merender eksploitasi, karena cukup mudah untuk meretas dan melakukan perenderan ilegal di jendela permainan.  Verifikasi memiliki kondisi berikut: <br><br><pre> <code class="cpp hljs">file size != <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; image name contains (<span class="hljs-keyword"><span class="hljs-keyword">case</span></span> insensitive) gameoverlayu</code> </pre> <br>  Pemeriksaan lebih lanjut khusus untuk overlay game Steam hampir identik dengan prosedur yang dilakukan untuk proses game itu sendiri, oleh karena itu, dihilangkan dalam pseudo-code. <br><br><h1>  Pemindaian memori overlay uap </h1><br>  Proses overlay game Steam dipindai untuk menemukan pola dan anomali.  Kami tidak dapat masuk lebih jauh ke dalam lubang kelinci, dan mencari tahu untuk apa pola-pola ini, karena mereka sangat digeneralisasikan dan kemungkinan besar terkait dengan modul cheat. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> gameoverlay::pattern_scan(MEMORY_BASIC_INFORMATION memory_information) { <span class="hljs-comment"><span class="hljs-comment">// PATTERNS: // Home // F1 // FFFF83C48C30000000000 // \.pipe%s // C760000C64730 // 60C01810033D2 // ... // PATTERN SCAN, ALMOST IDENTICAL CODE TO THE AFOREMENTIONED PATTERN SCANNING ROUTINE gameoverlay_memory_report.unknown_1 = 0 gameoverlay_memory_report.report_id = 0x35 gameoverlay_memory_report.identifier = 0x56C gameoverlay_memory_report.data = &amp;buffer[offset gameoverlay_memory_report.base_address = memory_information.base_address gameoverlay_memory_report.region_size = (int)memory_information.region_size gameoverlay_memory_report.memory_info = memory_information.type | memory_information.protect | memory_information.state battleye::report(&amp;gameoverlay_memory_report, sizeof(gameoverlay_memory_report), 0 }</span></span></code> </pre> <br>  Prosedur pemindaian juga mencari anomali dalam bentuk kode yang dapat dieksekusi di luar gambar yang diunduh, menunjukkan bahwa cracker menyuntikkan kode ke dalam proses overlay: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> gameoverlay::memory_anomaly_scan(MEMORY_BASIC_INFORMATION memory_information) { <span class="hljs-comment"><span class="hljs-comment">// ... // ALMOST IDENTICAL ANOMALY SCAN COMPARED TO MEMORY ENUMERATION ROUTINE OF GAME PROCESS gameoverlay_report.unknown = 0 gameoverlay_report.report_id = 0x3B gameoverlay_report.base_address = memory_information.base_address gameoverlay_report.region_size = memory_information.region_size gameoverlay_report.memory_info = memory_information.type | memory_information.protect | memory_information.state battleye::report(&amp;gameoverlay_report, sizeof(gameoverlay_report), 0 }</span></span></code> </pre> <br><h1>  Perlindungan Hamparan Steam Game </h1><br>  Jika proses overlay game Steam dilindungi oleh beberapa perlindungan terhadap proses Windows seperti <em>Light (WinTcb)</em> , maka server akan menerima pemberitahuan tentang hal itu. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> gameoverlay::protection_check(HANDLE process_handle) { <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> process_protection = <span class="hljs-number"><span class="hljs-number">0</span></span> NtQueryInformationProcess( process_handle, ProcessProtectionInformation, &amp;process_protection, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(process_protection), <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (process_protection == <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-comment"><span class="hljs-comment">// NO PROTECTION return gameoverlay_protected_report.unknown = 0 gameoverlay_protected_report.report_id = 0x35 gameoverlay_protected_report.identifier = 0x5B1 gameoverlay_protected_report.data = process_protection battleye::report(&amp;gameoverlay_protected_report, sizeof(gameoverlay_protected_report), 0 }</span></span></code> </pre> <br>  Selain itu, jika panggilan <em>OpenProcess yang</em> sesuai mengembalikan <em>ERROR_ACCESS_DENIED</em> ke proses overlay, pemberitahuan dikirimkan tentang pengguna dengan id <code>3B</code> . <br><br><h1>  Modul Penyortiran </h1><br>  Modul proses overlay permainan uap juga dicari, khususnya, <code>vgui2_s.dll</code> dan <code>gameoverlayui.dll</code> .  Beberapa pemeriksaan dilakukan untuk modul-modul ini, dimulai dengan <code>gameoverlayui.dll</code> . <br><br>  Jika kondisi ini terpenuhi: <code>[gameoverlayui.dll+6C779] == 08BE55DC3CCCCB8????????C3CCCCCC</code> , maka <code>[gameoverlayui.dll+6C779] == 08BE55DC3CCCCB8????????C3CCCCCC</code> memindai <code>[gameoverlayui.dll+6C779] == 08BE55DC3CCCCB8????????C3CCCCCC</code> vtable pada alamat yang disimpan dalam byte <code>????????</code>  .  Jika salah satu dari elemen vtable ini berada di luar modul sumber gameoverlayui.dll atau menunjuk ke instruksi <code>int 3</code> , maka pengguna dilaporkan ke server dengan id pemberitahuan <code>3B</code> . <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> gameoverlay::scan_vtable(HANDLE process_handle, <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>* buffer, MODULEENTRY32 module_entry) { <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> function_buffer[<span class="hljs-number"><span class="hljs-number">16</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (vtable_index = <span class="hljs-number"><span class="hljs-number">0</span></span> vtable_index &lt; <span class="hljs-number"><span class="hljs-number">20</span></span> vtable_index += <span class="hljs-number"><span class="hljs-number">4</span></span>) { NtReadVirtualMemory( process_handle, *(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>*)&amp;buffer[vtable_index], &amp;function_buffer, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(function_buffer), <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (*(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>*)&amp;buffer[vtable_index] &lt; module_entry.modBaseAddr || *(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>*)&amp;buffer[vtable_index] &gt;= module_entry.modBaseAddr + module_entry.modBaseSize || function_buffer[<span class="hljs-number"><span class="hljs-number">0</span></span>] == <span class="hljs-number"><span class="hljs-number">0xCC</span></span> ) <span class="hljs-comment"><span class="hljs-comment">// FUNCTION PADDING { gameoverlay_vtable_report.report_id = 0x3B gameoverlay_vtable_report.vtable_index = vtable_index gameoverlay_vtable_report.address = buffer[vtable_index battleye::report(&amp;gameoverlay_vtable_report, sizeof(gameoverlay_vtable_report), 0 } } }</span></span></code> </pre> <br>  Prosedur verifikasi khusus juga dilakukan untuk modul <code>vgui2_s.dll</code> : <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> vgui::scan() { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!equals(vgui_buffer, <span class="hljs-string"><span class="hljs-string">"6A08B31FF561C8BD??????????FF96????????8BD????????8B1FF90"</span></span>)) { <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> could_read = NtReadVirtualMemory( process_handle, module_entry.modBaseAddr + <span class="hljs-number"><span class="hljs-number">0x48338</span></span>, vgui_buffer, <span class="hljs-number"><span class="hljs-number">8</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>) &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> pattern_offset = <span class="hljs-number"><span class="hljs-number">0x48378</span></span> <span class="hljs-comment"><span class="hljs-comment">// IF READ DID NOT FAIL AND PATTERN IS FOUND if (could_read &amp;&amp; equals(vgui_buffer, "6A46A06A26A")) { vgui_report.unknown_1 = 0 vgui_report.report_id = 0x3B vgui_report.unknown_2 = 0 vgui_report.address = LODWORD(module_entry.modBaseAddr) + pattern_offset // READ TARGET BUFFER INTO REPORT NtReadVirtualMemory( process_handle, module_entry.modBaseAddr + pattern_offset, vgui_report.buffer, sizeof(vgui_report.buffer), 0 battleye::report(&amp;vgui_report, sizeof(vgui_report), 0 } } else if ( // READ ADDRESS FROM CODE NtReadVirtualMemory(process_handle, *(int*)&amp;vgui_buffer[9], vgui_buffer, 4, 0) &gt;= 0 &amp;&amp; // READ POINTER TO CLASS NtReadVirtualMemory(process_handle, *(int*)vgui_buffer, vgui_buffer, 4, 0) &gt;= 0 &amp;&amp; // READ POINTER TO VIRTUAL TABLE NtReadVirtualMemory(process_handle, *(int*)vgui_buffer, vgui_buffer, sizeof(vgui_buffer), 0) &gt;= 0) { for (vtable_index = 0 vtable_index &lt; 984 vtable_index += 4 ) // 984/4 VTABLE ENTRY COUNT { NtReadVirtualMemory(process_handle, *(int*)&amp;vgui_buffer[vtable_index], &amp;vtable_entry, sizeof(vtable_entry), 0 if (*(int*)&amp;vgui_buffer[vtable_index] &lt; module_entry.modBaseAddr || *(int*)&amp;vgui_buffer[vtable_index] &gt;= module_entry.modBaseAddr + module_entry.modBaseSize || vtable_entry == 0xCC ) { vgui_vtable_report.unknown = 0 vgui_vtable_report.report_id = 0x3B vgui_vtable_report.vtable_index = vtable_index vgui_vtable_report.address = *(int*)&amp;vgui_buffer[vtable_index battleye::report(&amp;vgui_vtable_report, sizeof(vgui_vtable_report), 0 } } }</span></span></code> </pre> <br>        <code>48378</code> ,     : <br><br><pre> <code class="cpp hljs">push <span class="hljs-number"><span class="hljs-number">04</span></span> push offset aCBuildslaveSte_4 ; <span class="hljs-string"><span class="hljs-string">"c:\buildslave\steam_rel_client_win32"</span></span>... push offset aAssertionFaile_7 ; <span class="hljs-string"><span class="hljs-string">"Assertion Failed: IsValidIndex(elem)"</span></span></code> </pre> <br>          : <br><br><pre> <code class="cpp hljs">push <span class="hljs-number"><span class="hljs-number">04</span></span> push <span class="hljs-number"><span class="hljs-number">00</span></span> push <span class="hljs-number"><span class="hljs-number">02</span></span> push ??</code> </pre> <br>      vgui2_s.dll,       ,    ,  vtable  . <br><br><h1>    Steam </h1><br>      Steam  : <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> gameoverlay::check_thread(THREADENTRY32 thread_entry) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> tread_handle = OpenThread(THREAD_SUSPEND_RESUME|THREAD_GET_CONTEXT, <span class="hljs-number"><span class="hljs-number">0</span></span>, thread_entry.th32ThreadID <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (thread_handle) { suspend_count = ResumeThread(thread_handle <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (suspend_count &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { SuspendThread(thread_handle gameoverlay_thread_report.unknown = <span class="hljs-number"><span class="hljs-number">0</span></span> gameoverlay_thread_report.report_id = <span class="hljs-number"><span class="hljs-number">0x3B</span></span> gameoverlay_thread_report.suspend_count = suspend_count battleye::report(&amp;gameoverlay_thread_report, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(gameoverlay_thread_report), <span class="hljs-number"><span class="hljs-number">0</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (GetThreadContext(thread_handle, &amp;context) &amp;&amp; context.Dr7) { gameoverlay_debug_report.unknown = <span class="hljs-number"><span class="hljs-number">0</span></span> gameoverlay_debug_report.report_id = <span class="hljs-number"><span class="hljs-number">0x3B</span></span> gameoverlay_debug_report.debug_register = context.Dr0 battleye::report(&amp;gameoverlay_debug_report, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(gameoverlay_debug_report), <span class="hljs-number"><span class="hljs-number">0</span></span> } } }</code> </pre> <br><h1> LSASS </h1><br>     Windows <em>lsass.exe</em> ,     Local Security Authority,        ,       : <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (equals(process_entry.executable_path, <span class="hljs-string"><span class="hljs-string">"lsass.exe"</span></span>)) { <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> lsass_handle = OpenProcess(QueryInformation, <span class="hljs-number"><span class="hljs-number">0</span></span>, (<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)process_entry.th32ProcessID <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (lsass_handle) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (address = <span class="hljs-number"><span class="hljs-number">0</span></span> NtQueryVirtualMemory(lsass_handle, address, <span class="hljs-number"><span class="hljs-number">0</span></span>, &amp;lsass_memory_info, <span class="hljs-number"><span class="hljs-number">0x30</span></span>, &amp;bytes_needed) &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span> address = lsass_memory_info.base_address + lsass_memory_info.region_size) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (lsass_memory_info.state == MEM_COMMIT &amp;&amp; lsass_memory_info.type == MEM_PRIVATE &amp;&amp; (lsass_memory_info.protect == PAGE_EXECUTE || lsass_memory_info.protect == PAGE_EXECUTE_READ || lsass_memory_info.protect == PAGE_EXECUTE_READWRITE)) { <span class="hljs-comment"><span class="hljs-comment">// FOUND EXECUTABLE MEMORY OUTSIDE OF MODULES lsass_report.unknown = 0 lsass_report.report_id = 0x42 lsass_report.base_address = lsass_memory_info.base_address lsass_report.region_size = lsass_memory_info.region_size lsass_report.memory_info = lsass_memory_info.type | lsass_memory_info.protect | lsass_memory_info.state battleye::report(&amp;lsass_report, sizeof(lsass_report), 0 } } CloseHandle(lsass_handle } }</span></span></code> </pre> <br> LSASS         ,    ,   -,      LSASS.    BattlEye    ,       /,    <code>ReadProcessMemory</code> / <code>WriteProcessMemory</code> ,      BEDaisy.  BEDaisy ,      .   ,   ,    ,         . <br><br><h2>   </h2><br> BattlEye         id  <code>3C</code> .      : <br><br><ul><li>     <em>WS_EX_TOPMOST</em>   : <ul><li>   (Unicode) </li><li>    (Unicode) </li><li> Window style </li><li> Window extended style </li><li>   </li><li>    - </li><li>   - </li></ul></li><li>        (VM_WRITE|VM_READ) <ul><li>   </li><li>    </li><li>   </li><li>    </li></ul></li><li>    : <br><ul><li> ‚Ä¶.ContentPaksTslGame-WindowsNoEditor_assets_world.pak </li><li> ‚Ä¶.ContentPaksTslGame-WindowsNoEditor_ui.pak </li><li> ‚Ä¶.ContentPaksTslGame-WindowsNoEditor_sound.pak </li></ul><br></li><li>    : <br><ul><li> ‚Ä¶.BLGameCookedContentScriptBLGame.u </li></ul></li><li>    NtGetContextThread <br><ul><li>     (E9),       </li></ul></li></ul><br><h2> NoEye </h2><br>  BattlEye               NoEye:    <em>GetFileAttributesExA</em>    <code>BE_DLL.dll</code> ,      . <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> noeye::detect() { <span class="hljs-function"><span class="hljs-function">WIN32_FILE_ATTRIBUTE_DATA file_information </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">if</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(GetFileAttributesExA(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"BE_DLL.dll"</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0</span></span></span></span><span class="hljs-function"><span class="hljs-params">, &amp;file_information))</span></span></span><span class="hljs-function"> </span></span>{ noeye_report.unknown = <span class="hljs-number"><span class="hljs-number">0</span></span> noeye_report.report_id = <span class="hljs-number"><span class="hljs-number">0x3D</span></span> noeye_report.file_size = file_information.nFileSizeLow battleye::report(&amp;noeye_report, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(noeye_report), <span class="hljs-number"><span class="hljs-number">0</span></span> } }</code> </pre> <br><h2>   </h2><br>    Beep  Null;      .          ,      ,  -   .    driver device hijacking.    ,     IOCTL           . <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> driver::check_beep() { <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> handle = CreateFileA(<span class="hljs-string"><span class="hljs-string">"\\.\Beep"</span></span>, GENERIC_READ, FILE_SHARE_READ | FILE_SHARE_WRITE, <span class="hljs-number"><span class="hljs-number">0</span></span>, OPEN_EXISTING, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (handle != INVALID_HANDLE_VALUE) { beep_report.unknown = <span class="hljs-number"><span class="hljs-number">0</span></span> beep_report.report_id = <span class="hljs-number"><span class="hljs-number">0x3E</span></span> battleye::report(&amp;beep_report, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(beep_report), <span class="hljs-number"><span class="hljs-number">0</span></span> CloseHandle(handle } }</code> </pre> <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> driver::check_null() { <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> handle = CreateFileA(<span class="hljs-string"><span class="hljs-string">"\\.\Null"</span></span>, GENERIC_READ, FILE_SHARE_READ | FILE_SHARE_WRITE, <span class="hljs-number"><span class="hljs-number">0</span></span>, OPEN_EXISTING, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (handle != INVALID_HANDLE_VALUE) { null_report.unknown = <span class="hljs-number"><span class="hljs-number">0</span></span> null_report.report_id = <span class="hljs-number"><span class="hljs-number">0x3E</span></span> battleye::report(&amp;null_report, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(null_report), <span class="hljs-number"><span class="hljs-number">0</span></span> CloseHandle(handle } }</code> </pre> <br><h2> Sleep delta </h2><br>  , BattlEye                  (sleep): <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> sleep::check_delta() { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> tick_count = GetTickCount Sleep(<span class="hljs-number"><span class="hljs-number">1000</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> tick_delta = GetTickCount() - tick_count <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (tick_delta &gt;= <span class="hljs-number"><span class="hljs-number">1200</span></span>) { sleep_report.unknown = <span class="hljs-number"><span class="hljs-number">0</span></span> sleep_report.report_id = <span class="hljs-number"><span class="hljs-number">0x45</span></span> sleep_report.delta = tick_delta battleye::report(&amp;sleep_report, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(sleep_report), <span class="hljs-number"><span class="hljs-number">0</span></span> } }</code> </pre> <br><h2> 7zip </h2><br>  BattlEye     ,       7zip      .   ,          .  BattlEye          7zip. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> <span class="hljs-keyword"><span class="hljs-keyword">module</span></span>::check_7zip() { <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> sz_7zipdll = <span class="hljs-string"><span class="hljs-string">"..\..\Plugins\ZipUtility\ThirdParty\7zpp\dll\Win64\7z.dll"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> module_handle = GetModuleHandleA(sz_7zipdll <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (module_handle &amp;&amp; *(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>*)(module_handle + <span class="hljs-number"><span class="hljs-number">0x1000</span></span>) != <span class="hljs-number"><span class="hljs-number">0xFF1441C7</span></span>) { sevenzip_report.unknown_1 = <span class="hljs-number"><span class="hljs-number">0</span></span> sevenzip_report.report_id = <span class="hljs-number"><span class="hljs-number">0x46</span></span> sevenzip_report.unknown_2 = <span class="hljs-number"><span class="hljs-number">0</span></span> sevenzip_report.data1 = *(__int64*)(module_handle + <span class="hljs-number"><span class="hljs-number">0x1000</span></span> sevenzip_report.data2 = *(__int64*)(module_handle + <span class="hljs-number"><span class="hljs-number">0x1008</span></span> battleye::report(&amp;sevenzip_report, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(sevenzip_report), <span class="hljs-number"><span class="hljs-number">0</span></span> } }</code> </pre> <br><h2>    </h2><br> BattlEye         Windows (hal.dll),   ,      . <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> <span class="hljs-keyword"><span class="hljs-keyword">module</span></span>::check_hal() { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> module_handle = GetModuleHandleA(<span class="hljs-string"><span class="hljs-string">"hal.dll"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (module_handle) { hal_report.unknown_1 = <span class="hljs-number"><span class="hljs-number">0</span></span> hal_report.report_id = <span class="hljs-number"><span class="hljs-number">0x46</span></span> hal_report.unknown_2 = <span class="hljs-number"><span class="hljs-number">2</span></span> hal_report.data1 = *(__int64*)(module_handle + <span class="hljs-number"><span class="hljs-number">0x1000</span></span> hal_report.data2 = *(__int64*)(module_handle + <span class="hljs-number"><span class="hljs-number">0x1008</span></span> battleye::report(&amp;hal_report, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(hal_report), <span class="hljs-number"><span class="hljs-number">0</span></span> } }</code> </pre> <br><h2>   </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">BattlEye juga memeriksa berbagai gambar yang dimuat ke dalam game. </font><font style="vertical-align: inherit;">Modul-modul ini seharusnya merupakan gambar yang ditandatangani yang entah bagaimana dimanipulasi, mengubah perilakunya menjadi jahat, tetapi kami tidak bisa mengatakan apa-apa lagi tentang mereka, hanya tentang pendeteksian mereka:</font></font><br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> nvToolsExt64_1 </font></font></h1><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> <span class="hljs-keyword"><span class="hljs-keyword">module</span></span>::check_nvtoolsext64_1 { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> module_handle = GetModuleHandleA(<span class="hljs-string"><span class="hljs-string">"nvToolsExt64_1.dll"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (module_handle) { nvtools_report.unknown = <span class="hljs-number"><span class="hljs-number">0</span></span> nvtools_report.report_id = <span class="hljs-number"><span class="hljs-number">0x48</span></span> nvtools_report.module_id = <span class="hljs-number"><span class="hljs-number">0x5A8</span></span> nvtools_report.size_of_image = (PE_HEADER*)(module_handle + (DOS_HEADER*)(module_handle)-&gt;e_lfanew))-&gt;SizeOfImage battleye::report(&amp;nvtools_report, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(nvtools_report), <span class="hljs-number"><span class="hljs-number">0</span></span> } }</code> </pre> <br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ws2detour_x96 </font></font></h1><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> <span class="hljs-keyword"><span class="hljs-keyword">module</span></span>::check_ws2detour_x96 { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> module_handle = GetModuleHandleA(<span class="hljs-string"><span class="hljs-string">"ws2detour_x96.dll"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (module_handle) { ws2detour_report.unknown = <span class="hljs-number"><span class="hljs-number">0</span></span> ws2detour_report.report_id = <span class="hljs-number"><span class="hljs-number">0x48</span></span> ws2detour_report.module_id = <span class="hljs-number"><span class="hljs-number">0x5B5</span></span> ws2detour_report.size_of_image = (PE_HEADER*)(module_handle + (DOS_HEADER*)(module_handle)-&gt;e_lfanew))-&gt;SizeOfImage battleye::report(&amp;ws2detour_report, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(ws2detour_report), <span class="hljs-number"><span class="hljs-number">0</span></span> } }</code> </pre> <br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> networkdllx64 </font></font></h1><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> <span class="hljs-keyword"><span class="hljs-keyword">module</span></span>::check_networkdllx64 { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> module_handle = GetModuleHandleA(<span class="hljs-string"><span class="hljs-string">"networkdllx64.dll"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (module_handle) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> dos_header = (DOS_HEADER*)module_handle <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> pe_header = (PE_HEADER*)(module_handle + dos_header-&gt;e_lfanew <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> size_of_image = pe_header-&gt;SizeOfImage <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (size_of_image &lt; <span class="hljs-number"><span class="hljs-number">0x200000</span></span> || size_of_image &gt;= <span class="hljs-number"><span class="hljs-number">0x400000</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (pe_header-&gt;sections[DEBUG_DIRECTORY].size == <span class="hljs-number"><span class="hljs-number">0x1B20</span></span>) { networkdll64_report.unknown = <span class="hljs-number"><span class="hljs-number">0</span></span> networkdll64_report.report_id = <span class="hljs-number"><span class="hljs-number">0x48</span></span> networkdll64_report.module_id = <span class="hljs-number"><span class="hljs-number">0x5B7</span></span> networkdll64_report.data = pe_header-&gt;TimeDatestamp battleye::report(&amp;networkdll64_report, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(networkdll64_report), <span class="hljs-number"><span class="hljs-number">0</span></span> } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { networkdll64_report.unknown = <span class="hljs-number"><span class="hljs-number">0</span></span> networkdll64_report.report_id = <span class="hljs-number"><span class="hljs-number">0x48</span></span> networkdll64_report.module_id = <span class="hljs-number"><span class="hljs-number">0x5B7</span></span> networkdll64_report.data = pe_header-&gt;sections[DEBUG_DIRECTORY].size battleye::report(&amp;networkdll64_report, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(networkdll64_report), <span class="hljs-number"><span class="hljs-number">0</span></span> } } }</code> </pre> <br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> nxdetours_64 </font></font></h1><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> <span class="hljs-keyword"><span class="hljs-keyword">module</span></span>::check_nxdetours_64 { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> module_handle = GetModuleHandleA(<span class="hljs-string"><span class="hljs-string">"nxdetours_64.dll"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (module_handle) { nxdetours64_report.unknown = <span class="hljs-number"><span class="hljs-number">0</span></span> nxdetours64_report.report_id = <span class="hljs-number"><span class="hljs-number">0x48</span></span> nxdetours64_report.module_id = <span class="hljs-number"><span class="hljs-number">0x5B8</span></span> nxdetours64_report.size_of_image = (PE_HEADER*)(module_handle + (DOS_HEADER*)(module_handle)-&gt;e_lfanew))-&gt;SizeOfImage battleye::report(&amp;nxdetours64_report, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(nxdetours64_report), <span class="hljs-number"><span class="hljs-number">0</span></span> } }</code> </pre> <br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> nvcompiler </font></font></h1><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> <span class="hljs-keyword"><span class="hljs-keyword">module</span></span>::check_nvcompiler { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> module_handle = GetModuleHandleA(<span class="hljs-string"><span class="hljs-string">"nvcompiler.dll"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (module_handle) { nvcompiler_report.unknown = <span class="hljs-number"><span class="hljs-number">0</span></span> nvcompiler_report.report_id = <span class="hljs-number"><span class="hljs-number">0x48</span></span> nvcompiler_report.module_id = <span class="hljs-number"><span class="hljs-number">0x5BC</span></span> nvcompiler_report.data = *(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>*)(module_handle + <span class="hljs-number"><span class="hljs-number">0x1000</span></span> battleye::report(&amp;nvcompiler_report, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(nvcompiler_report), <span class="hljs-number"><span class="hljs-number">0</span></span> } }</code> </pre> <br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> wmp </font></font></h1><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> <span class="hljs-keyword"><span class="hljs-keyword">module</span></span>::check_wmp { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> module_handle = GetModuleHandleA(<span class="hljs-string"><span class="hljs-string">"wmp.dll"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (module_handle) { wmp_report.unknown = <span class="hljs-number"><span class="hljs-number">0</span></span> wmp_report.report_id = <span class="hljs-number"><span class="hljs-number">0x48</span></span> wmp_report.module_id = <span class="hljs-number"><span class="hljs-number">0x5BE</span></span> wmp_report.data = *(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>*)(module_handle + <span class="hljs-number"><span class="hljs-number">0x1000</span></span> battleye::report(&amp;wmp_report, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(wmp_report), <span class="hljs-number"><span class="hljs-number">0</span></span> } }</code> </pre> <br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Pengidentifikasi enumerasi modul </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Untuk referensi, kami memberikan id enumerasi untuk modul: </font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> module_id { nvtoolsext64 = <span class="hljs-number"><span class="hljs-number">0x5A8</span></span>, ws2detour_x96 = <span class="hljs-number"><span class="hljs-number">0x5B5</span></span>, networkdll64 = <span class="hljs-number"><span class="hljs-number">0x5B7</span></span>, nxdetours_64 = <span class="hljs-number"><span class="hljs-number">0x5B8</span></span>, nvcompiler = <span class="hljs-number"><span class="hljs-number">0x5BC</span></span>, wmp = <span class="hljs-number"><span class="hljs-number">0x5BE</span></span></code> </pre> <br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Pindai tabel TCP </font></font></h2><br> - BattlEye    TCP-   (   ¬´ TCP¬ª, TCP table)  ,         IP- Cloudflare-,   - pay-to-cheat   <a href="https://xera.ph/">xera.ph</a> .      -   ,       launcher,     .       ,  IP- Cloudflare-    .        ,       ,         . <br><br>    pay-to-cheat <em>xera.ph</em>      ,   ,        .     <em>xera.ph</em> ,       ,          ,  ,       .    , , ,         ,  -,  ,    . <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> network::scan_tcp_table { <span class="hljs-built_in"><span class="hljs-built_in">memset</span></span>(local_port_buffer, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(local_port_buffer <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (iteration_index = <span class="hljs-number"><span class="hljs-number">0</span></span> iteration_index &lt; <span class="hljs-number"><span class="hljs-number">500</span></span> ++iteration_index) { <span class="hljs-comment"><span class="hljs-comment">// GET NECESSARY SIZE OF TCP TABLE auto table_size = 0 GetExtendedTcpTable(0, &amp;table_size, false, AF_INET, TCP_TABLE_OWNER_MODULE_ALL, 0 // ALLOCATE BUFFER OF PROPER SIZE FOR TCP TABLE auto allocated_ip_table = (MIB_TCPTABLE_OWNER_MODULE*)malloc(table_size if (GetExtendedTcpTable(allocated_ip_table, &amp;table_size, false, AF_INET, TCP_TABLE_OWNER_MODULE_ALL, 0) != NO_ERROR) goto cleanup for (entry_index = 0 entry_index &lt; allocated_ip_table-&gt;dwNumEntries ++entry_index) { const auto ip_address_match_1 = allocated_ip_table-&gt;table[entry_index].dwRemoteAddr == 0x656B1468 // 104.20.107.101 const auto ip_address_match_2 = allocated_ip_table-&gt;table[entry_index].dwRemoteAddr == 0x656C1468 // 104.20.108.101 const auto port_match = allocated_ip_table-&gt;table[entry_index].dwRemotePort == 20480 if ( (!ip_address_match_1 &amp;&amp; !ip_address_match_2) || !port_match) continue for (port_index = 0 port_index &lt; 10 &amp;&amp; allocated_ip_table-&gt;table[entry_index].dwLocalPort != local_port_buffer[port_index ++port_index) { if (local_port_buffer[port_index]) continue tcp_table_report.unknown = 0 tcp_table_report.report_id = 0x48 tcp_table_report.module_id = 0x5B9 tcp_table_report.data = BYTE1(allocated_ip_table-&gt;table[entry_index].dwLocalPort) | (LOBYTE(allocated_ip_table-&gt;table[entry_index.dwLocalPort) &lt;&lt; 8 battleye::report(&amp;tcp_table_report, sizeof(tcp_table_report), 0 local_port_buffer[port_index] = allocated_ip_table-&gt;table[entry_index].dwLocalPort break } } cleanup: // FREE TABLE AND SLEEP free(allocated_ip_table Sleep(10 } }</span></span></code> </pre> <br><h2>   </h2><br>         -: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> BATTLEYE_REPORT_ID { MEMORY_GUARD = <span class="hljs-number"><span class="hljs-number">0x21</span></span>, MEMORY_SUSPICIOUS = <span class="hljs-number"><span class="hljs-number">0x2F</span></span>, WINDOW_TITLE = <span class="hljs-number"><span class="hljs-number">0x33</span></span>, MEMORY = <span class="hljs-number"><span class="hljs-number">0x35</span></span>, PROCESS_ANOMALY = <span class="hljs-number"><span class="hljs-number">0x38</span></span>, DRIVER_BEEP_PRESENCE = <span class="hljs-number"><span class="hljs-number">0x3E</span></span>, DRIVER_NULL_PRESENCE = <span class="hljs-number"><span class="hljs-number">0x3F</span></span>, MISCELLANEOUS_ANOMALY = <span class="hljs-number"><span class="hljs-number">0x3B</span></span>, PROCESS_SUSPICIOUS = <span class="hljs-number"><span class="hljs-number">0x40</span></span>, LSASS_MEMORY = <span class="hljs-number"><span class="hljs-number">0x42</span></span>, SLEEP_ANOMALY = <span class="hljs-number"><span class="hljs-number">0x45</span></span>, MEMORY_MODULE_SPECIFIC = <span class="hljs-number"><span class="hljs-number">0x46</span></span>, GENERIC_ANOMALY = <span class="hljs-number"><span class="hljs-number">0x48</span></span>, MEMORY_MODULE_SPECIFIC2 = <span class="hljs-number"><span class="hljs-number">0x5B</span></span>, }</code> </pre> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id483068/">https://habr.com/ru/post/id483068/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id483054/index.html">‚ÄúThere Will Be No No Massacre‚Äù - kisah terjemahan The Worm</a></li>
<li><a href="../id483056/index.html">Bidang logis dalam database, apakah ada penangkal?</a></li>
<li><a href="../id483058/index.html">Hasil Survei Liburan</a></li>
<li><a href="../id483064/index.html">Vue untuk blog kecil alias terkecil di semua kanon</a></li>
<li><a href="../id483066/index.html">The 5 Buku Tradisional oleh Bill Gates</a></li>
<li><a href="../id483074/index.html">TensorRT 6.xxx - inferensi kinerja tinggi untuk model pembelajaran dalam (Deteksi Objek dan Segmentasi)</a></li>
<li><a href="../id483076/index.html">Bahasa pemrograman teratas untuk pengembangan Aplikasi Android pada tahun 2020</a></li>
<li><a href="../id483078/index.html">Pembelajaran Penguatan Mendalam: Cara Mengajari Laba-laba Berjalan</a></li>
<li><a href="../id483082/index.html">Perburuan Kerentanan 7% Lebih Efektif</a></li>
<li><a href="../id483084/index.html">Kamera dengan fungsi pelacakan</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>