<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üò© ü§º üéÄ Coordenador de aplicativos em aplicativos iOS üë©‚Äçüë©‚Äçüëß‚Äçüë¶ ü¶å ‚èπÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Todos os anos, a plataforma iOS sofre muitas altera√ß√µes. Al√©m disso, as bibliotecas de terceiros trabalham regularmente no trabalho com a rede, no cac...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Coordenador de aplicativos em aplicativos iOS</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/oleg-bunin/blog/423299/">  Todos os anos, a plataforma iOS sofre muitas altera√ß√µes. Al√©m disso, as bibliotecas de terceiros trabalham regularmente no trabalho com a rede, no cache de dados, na renderiza√ß√£o da interface do usu√°rio via JavaScript e muito mais.  Em contraste com todas essas tend√™ncias, <strong>Pavel Gurov</strong> falou sobre a solu√ß√£o arquitetural, que ser√° relevante, independentemente de quais tecnologias voc√™ estiver usando agora ou em alguns anos. <br><br>  O ApplicationCoordinator pode ser usado para criar navega√ß√£o entre telas e, ao mesmo tempo, resolver v√°rios problemas.  Sob a demonstra√ß√£o do gato e instru√ß√µes para a implementa√ß√£o mais r√°pida dessa abordagem. <br><br><img src="https://habrastorage.org/webt/xx/ok/ti/xxoktiysvlvnzl1zbhvivxccrry.jpeg"><br><br>  <strong>Sobre o palestrante:</strong> Pavel Gurov est√° desenvolvendo aplicativos iOS no Avito. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/Pt9TGFzLVzc" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><a name="habracut"></a><br><h2>  Navega√ß√£o <br></h2><br><br><img src="https://habrastorage.org/webt/9d/dp/od/9ddpodzty4uclncm046g1ms9nvy.jpeg"><br><br>  Navegar entre telas √© uma tarefa que 100% de voc√™s enfrentam, n√£o importa o que fa√ßam - uma rede social, uma chamada de t√°xi ou um banco on-line.  √â assim que o aplicativo come√ßa, mesmo no est√°gio do prot√≥tipo, quando voc√™ nem sabe totalmente como ser√£o as telas, que tipo de anima√ß√£o ser√£o, se os dados ser√£o armazenados em cache.  As telas podem ser imagens em branco ou est√°ticas, mas <strong>a tarefa de navega√ß√£o aparece no aplicativo assim que houver mais de uma dessas telas</strong> .  Ou seja, quase imediatamente. <br><br><img src="https://habrastorage.org/webt/um/r-/qo/umr-qogrmhhn58yvlaseyxqyrre.jpeg"><br><br>  Os m√©todos mais comuns para construir a arquitetura de aplicativos iOS: MVc, MVVm e MVp, descrevem como construir um m√≥dulo de tela √∫nica.  Tamb√©m diz que os m√≥dulos podem se conhecer, se comunicar, etc.  Mas pouca aten√ß√£o √© dada √†s quest√µes de como s√£o feitas as transi√ß√µes entre esses m√≥dulos, quem decide essas transi√ß√µes e como os dados s√£o transmitidos. <br><br><h2>  UlStoryboard + segues <br></h2><br>  O iOS pronto para uso fornece v√°rias maneiras de mostrar o seguinte cen√°rio de tela: <br><br><ol><li>  O conhecido <strong>UlStoryboard + segue</strong> , quando designamos todas as transi√ß√µes entre telas em um meta-arquivo e as chamamos.  Tudo √© muito conveniente e √≥timo. </li><li>  Cont√™ineres - como o UINavigationController.  UITabBarController, UIPageController ou, possivelmente, cont√™ineres auto-escritos que podem ser usados ‚Äã‚Äãtanto programaticamente quanto em conjunto com o StoryBoards. </li><li>  M√©todo presente (_: animado: conclus√£o :).  Este √© apenas um m√©todo da classe UIController. </li></ol><br>  N√£o h√° problemas com essas ferramentas em si.  O problema √© exatamente como eles s√£o comumente usados.  O m√©todo UINavigationController, performSegue, prepareForSegue, presentViewController s√£o todos os m√©todos de propriedade da classe UIViewController.  A Apple sugere o uso dessas ferramentas dentro do pr√≥prio UIViewController. <br><br><img src="https://habrastorage.org/webt/gy/_n/vb/gy_nvb7uettqb7xdoillr3ud3m4.jpeg"><br><br>  Prova disso √© a seguinte. <br><br><img src="https://habrastorage.org/webt/hv/cq/6p/hvcq6prwv2si1cyrpqkiwchlwds.jpeg"><br><br>  Esses s√£o os coment√°rios que aparecem no seu projeto se voc√™ criar uma nova subclasse de UIViewController usando um modelo padr√£o.  Ele √© gravado diretamente - se voc√™ usa segues e precisa transferir dados para a pr√≥xima tela de acordo com o cen√°rio, voc√™ deve: obter este ViewController a partir de segue;  sabe que tipo ser√°;  fa√ßa a transmiss√£o para esse tipo e passe seus dados para l√°. <br><br>  Esta abordagem aos problemas na constru√ß√£o da navega√ß√£o. <br><br>  <strong>1. Conectividade r√≠gida de telas</strong> <br><br>  Isso significa que a tela 1 sabe sobre a exist√™ncia da tela 2. Ele n√£o apenas sabe sobre sua exist√™ncia, como tamb√©m potencialmente a cria, ou retira-a, sabendo que tipo √© e transfere alguns dados para ela. <br><br>  Se, em algumas circunst√¢ncias, precisarmos exibir a tela 3 em vez da tela 2, teremos que conhecer a nova tela 3 da mesma maneira que ser costurada no controlador de tela 1. Tudo se torna ainda mais dif√≠cil se os controladores 2 e 3 puderem ser chamados de v√°rios outros lugares, n√£o apenas da tela 1. Acontece que o conhecimento das telas 2 e 3 ter√° que ser costurado em cada um desses lugares. <br><br>  Para fazer isso √© outra metade do problema, os principais problemas come√ßar√£o quando for necess√°rio fazer altera√ß√µes nessas transi√ß√µes ou apoiar tudo isso. <br><br><img src="https://habrastorage.org/webt/nx/34/yw/nx34ywvotea8yovx9xuuaxp2lro.jpeg"><br><br>  <strong>2. Reordene os controladores de script</strong> <br><br>  Isso tamb√©m n√£o √© t√£o simples por causa da conex√£o.  Para trocar dois ViewControllers, n√£o ser√° suficiente entrar no UlStoryboard e trocar duas fotos.  Voc√™ precisar√° abrir o c√≥digo para cada uma dessas telas, transferi-lo para as configura√ß√µes da pr√≥xima e alterar seus locais, o que n√£o √© muito conveniente. <br><br><img src="https://habrastorage.org/webt/lz/_g/n6/lz_gn6x_emphixjobmg-cezayqa.jpeg"><br><br>  <strong>3. Transfer√™ncia de dados de acordo com o cen√°rio</strong> <br><br>  Por exemplo, ao escolher algo na tela 3, precisamos atualizar o modo de exibi√ß√£o na tela 1. Como inicialmente n√£o temos nada al√©m de um ViewController, teremos que conectar de alguma forma os dois ViewControllers - n√£o importa como - atrav√©s da delega√ß√£o ou de alguma forma ainda.  Ser√° ainda mais dif√≠cil se, de acordo com a a√ß√£o na tela 3, for necess√°rio atualizar n√£o uma tela, mas v√°rias ao mesmo tempo, por exemplo, a primeira e a segunda. <br><br><img src="https://habrastorage.org/webt/wy/gz/gr/wygzgrppqbr4dc6tszklinog714.jpeg"><br><br>  Nesse caso, a delega√ß√£o n√£o pode ser dispensada, porque a delega√ß√£o √© um relacionamento individual.  Algu√©m dir√°, vamos usar a notifica√ß√£o, algu√©m - atrav√©s de um estado compartilhado.  Tudo isso dificulta a depura√ß√£o e o rastreamento de fluxos de dados em nosso aplicativo. <br><br>  Como se costuma dizer, √© melhor ver uma vez do que ouvir 100 vezes.  Vejamos um exemplo espec√≠fico desse aplicativo Avito Services Pro.  Esta aplica√ß√£o √© para profissionais do setor de servi√ßos, nos quais √© conveniente rastrear seus pedidos, comunicar-se com os clientes, procurar novos pedidos. <br><br>  Cen√°rio - escolhendo uma cidade na edi√ß√£o de um perfil de usu√°rio. <br><br><img src="https://habrastorage.org/webt/0j/cd/zn/0jcdznc3-8b7fy9lliaairh1s_u.jpeg"><br><br>  Aqui est√° uma tela de edi√ß√£o de perfil, como em muitos aplicativos.  Estamos interessados ‚Äã‚Äãem escolher uma cidade. <br><br>  O que est√° acontecendo aqui? <br><br><ul><li>  O usu√°rio clica na c√©lula com a cidade e a primeira tela decide que √© hora de adicionar a seguinte tela √† pilha de navega√ß√£o.  Esta √© uma tela com uma lista de cidades federais (Moscou e S√£o Petersburgo) e uma lista de regi√µes. </li><li>  Se o usu√°rio selecionar uma cidade federal na segunda tela, a segunda tela entender√° que o script foi conclu√≠do, encaminhar√° a cidade selecionada para a primeira e a pilha Navega√ß√£o voltar√° para a primeira tela.  O script √© considerado completo. </li><li>  Se o usu√°rio seleciona uma √°rea na segunda tela, a segunda tela decide que uma terceira tela deve ser preparada, na qual vemos uma lista de cidades nessa √°rea.  Se o usu√°rio seleciona uma cidade, essa cidade √© enviada para a primeira tela, rola a pilha de Navega√ß√£o e o script √© considerado completo. </li></ul><br>  Neste diagrama, os problemas de conectividade que mencionei anteriormente s√£o mostrados como setas entre o ViewController.  Vamos nos livrar desses problemas agora. <br><br>  <strong>Como fazemos isso?</strong> <br><br><ol><li>  N√≥s <strong>nos proibimos dentro do UIViewController de acessar cont√™ineres</strong> , ou seja, self.navigationController, self.tabBarController ou alguns outros cont√™ineres personalizados que voc√™ criou como extens√£o de propriedade.  Agora n√£o podemos pegar nosso cont√™iner do c√≥digo da tela e pedir para ele fazer alguma coisa. <br><br><img src="https://habrastorage.org/webt/av/ci/0x/avci0xx4juu-sitqkcidwmo5woi.jpeg"><br></li><li>  <strong>N√≥s nos proibimos dentro do UIViewController de chamar o m√©todo performSegue</strong> e escrever c√≥digo no m√©todo prepareForSegue, que pegaria a tela que segue o script e a configuraria.  Ou seja, n√£o trabalhamos mais com segue (com transi√ß√µes entre telas) dentro do UIViewController. <br><br><img src="https://habrastorage.org/webt/xp/lh/kq/xplhkqdhp61csbpdmvaulmonqra.jpeg"><br></li><li>  Tamb√©m <strong>proibimos qualquer men√ß√£o de outros controladores dentro de nosso controlador espec√≠fico</strong> : sem inicializa√ß√µes, transfer√™ncias de dados e isso √© tudo. <br><br><img src="https://habrastorage.org/webt/cr/0_/j9/cr0_j999w13tkk8szf2wh1xbjsm.jpeg"><br></li></ol><br><br><h2>  Coordenador <br></h2><br>  Como removemos todas essas responsabilidades do UIViewController, precisamos de uma nova entidade que as cumpra.  Crie uma nova classe de objetos e chame-a de coordenadora. <br><br><img src="https://habrastorage.org/webt/ta/ub/t6/taubt6cqzz4_lviz88jbgih3jf4.jpeg"><br><br>  O coordenador √© apenas um objeto comum para o qual passamos no in√≠cio do NavigationController e chamamos o m√©todo Start.  Agora, n√£o pense em como ela √© implementada; basta ver como o cen√°rio para escolher uma cidade mudar√° nesse caso. <br><br>  Agora, n√£o come√ßa com o fato de estarmos preparando a transi√ß√£o para qualquer tela NavigationController espec√≠fica, mas chamamos o m√©todo Start no coordenador, passando-o antes disso no inicializador NavigationController.  O coordenador entende que √© hora do NavigationController iniciar a primeira tela, o que ele faz. <br><br>  Al√©m disso, quando o usu√°rio seleciona uma c√©lula com uma cidade, esse evento √© passado para o coordenador.  Ou seja, a pr√≥pria tela n√£o sabe de nada - depois, como dizem, pelo menos uma inunda√ß√£o.  Ele envia essa mensagem ao coordenador e, em seguida, o coordenador reage a isso (j√° que ele tem um NavigationController), que envia o pr√≥ximo passo para isso - essa √© a escolha das regi√µes. <br><br>  Em seguida, o usu√°rio clica em "Regi√£o" - exatamente a mesma imagem - a tela em si n√£o resolve nada, apenas informa ao coordenador que a pr√≥xima tela ser√° aberta. <br><br>  Quando o usu√°rio seleciona uma cidade espec√≠fica na terceira tela, essa cidade tamb√©m √© transferida para a primeira tela atrav√©s do coordenador.  Ou seja, uma mensagem √© enviada ao coordenador de que uma cidade foi selecionada.  O coordenador envia essa mensagem para a primeira tela e rola a pilha de Navega√ß√£o para a primeira tela. <br><br>  Observe que os <strong>controladores n√£o se comunicam mais</strong> , decidindo quem ser√° o pr√≥ximo e n√£o transmitem nenhum dado um ao outro.  Al√©m disso, eles n√£o sabem nada sobre o ambiente. <br><br><img src="https://habrastorage.org/webt/uz/sy/uo/uzsyuorkw837chi1zn8s39hdkw0.jpeg"><br><br>  Se considerarmos o aplicativo dentro da estrutura de uma arquitetura de tr√™s camadas, o ViewController deve idealmente se encaixar completamente na camada Presentation e transportar o m√≠nimo poss√≠vel a l√≥gica do aplicativo. <br><br>  Nesse caso, usamos o coordenador para extrair a l√≥gica das transi√ß√µes para a camada acima e remover esse conhecimento do ViewController. <br><br><h2>  Demo <br></h2><br>  Um <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">projeto de</a> apresenta√ß√£o e demonstra√ß√£o est√° dispon√≠vel no Github; abaixo, uma demonstra√ß√£o durante a palestra. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/Pt9TGFzLVzc" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Este √© o mesmo cen√°rio: editar um perfil e escolher uma cidade nele. <br><br>  A primeira tela √© a tela de edi√ß√£o do usu√°rio.  Ele mostra informa√ß√µes sobre o usu√°rio atual: nome e cidade selecionada.  H√° um bot√£o "Escolha uma cidade".  Quando clicamos nele, chegamos √† tela com uma lista de cidades.  Se selecionarmos uma cidade l√°, a primeira tela exibir√° essa cidade. <br><br>  Vamos ver agora como isso funciona no c√≥digo.  Vamos come√ßar com o modelo. <br><br><pre><code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">City</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> name: <span class="hljs-type"><span class="hljs-type">String</span></span> } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">User</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> name: <span class="hljs-type"><span class="hljs-type">String</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> city: <span class="hljs-type"><span class="hljs-type">City?</span></span> }</code> </pre> <br>  <strong>Os modelos s√£o</strong> simples: <br><br><ol><li>  Uma estrutura de cidade que possui um nome de campo, sequ√™ncia; </li><li>  Um usu√°rio que tamb√©m possui um nome e uma cidade de propriedade. </li></ol><br>  O pr√≥ximo √© o <strong>StoryBoard</strong> .  Come√ßa com um NavigationController.  Em princ√≠pio, aqui est√£o as mesmas telas que estavam no simulador: uma tela de edi√ß√£o do usu√°rio com um r√≥tulo e um bot√£o e uma tela com uma lista de cidades, que mostra um tablet com cidades. <br><br><h4>  Tela de edi√ß√£o do usu√°rio <br></h4><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> UIKit final <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> UserEditViewController: UIViewController, UpdateableWithUser { // MARK: - <span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> - var <span class="hljs-keyword"><span class="hljs-keyword">user</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">User</span></span>? { didSet { updateView() } } // MARK: - Output - var onSelectCity: (() -&gt; <span class="hljs-type"><span class="hljs-type">Void</span></span>)? @IBOutlet private weak var userLabel: UILabel? @IBAction private func selectCityTap(_ sender: UIButton) { onSelectCity?() } override func viewWillAppear(_ animated: <span class="hljs-type"><span class="hljs-type">Bool</span></span>) { super.viewWillAppear(animated) updateView() } private func updateView() { userLabel?.text = "User: \(user?.name ?? ""), \n" + "City: \(user?.city?.name ?? "")" } }</code> </pre><br>  Aqui existe uma propriedade User - este √© o usu√°rio que √© transmitido para fora - o usu√°rio que editaremos.  Definir usu√°rio aqui faz com que o bloco didSet seja chamado, o que leva a uma chamada para o m√©todo local updateView ().  Tudo o que esse m√©todo faz √© simplesmente colocar informa√ß√µes sobre o usu√°rio no r√≥tulo, ou seja, mostrar seu nome e o nome da cidade em que esse usu√°rio vive. <br><br>  O mesmo acontece no m√©todo viewWillAppear (). <br><br>  O local mais interessante √© o manipulador para clicar no bot√£o de sele√ß√£o da cidade, selecionar CityTap ().  <strong>Aqui, o pr√≥prio controlador n√£o resolve nada</strong> : n√£o cria nenhum controlador, n√£o chama segue.  Tudo o que ele faz √© o retorno de chamada - esta √© a segunda propriedade do nosso ViewController.  O retorno de chamada onSelectCity n√£o possui par√¢metros.  Quando o usu√°rio clica no bot√£o, isso faz com que esse retorno de chamada seja chamado. <br><br><h4>  Tela de sele√ß√£o da cidade <br></h4><br><pre> <code class="hljs powershell">import UIKit final <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CitiesViewController</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UITableViewController</span></span></span></span> { // MARK: - Output - var onCitySelected: ((City) -&gt; Void)? // MARK: - Private variables - private let cities: [<span class="hljs-type"><span class="hljs-type">City</span></span>] = [<span class="hljs-type"><span class="hljs-type">City</span></span>(<span class="hljs-type"><span class="hljs-type">name</span></span>: <span class="hljs-string"><span class="hljs-string">"Moscow"</span></span>), <span class="hljs-type"><span class="hljs-type">City</span></span>(<span class="hljs-type"><span class="hljs-type">name</span></span>: <span class="hljs-string"><span class="hljs-string">"Ulyanovsk"</span></span>), <span class="hljs-type"><span class="hljs-type">City</span></span>(<span class="hljs-type"><span class="hljs-type">name</span></span>: <span class="hljs-string"><span class="hljs-string">"New York"</span></span>), <span class="hljs-type"><span class="hljs-type">City</span></span>(<span class="hljs-type"><span class="hljs-type">name</span></span>: <span class="hljs-string"><span class="hljs-string">"Tokyo"</span></span>)] // MARK: - Table - override func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -&gt; Int { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> cities.count } override func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&gt; UITableViewCell { let cell = tableView.dequeueReusableCell(withIdentifier: <span class="hljs-string"><span class="hljs-string">"cell"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>: indexPath) cell.textLabel?.text = cities[<span class="hljs-type"><span class="hljs-type">indexPath.row</span></span>].name <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> cell } override func tableView(_ tableView: UITableView, didSelectRowAt indexPath: IndexPath) { onCitySelected?(cities[<span class="hljs-type"><span class="hljs-type">indexPath.row</span></span>]) } }</code> </pre><br>  Essa tela √© um UITableViewController.  A lista de cidades aqui √© fixa, mas pode vir de outro lugar.  Al√©m disso (// MARCA: - Tabela -) √© um c√≥digo de tabela bastante trivial que exibe uma lista de cidades nas c√©lulas. <br><br>  O lugar mais interessante aqui √© o manipulador didSelectRowAt IndexPath, um m√©todo conhecido para todos.  Aqui, a pr√≥pria tela novamente n√£o resolve nada.  O que acontece depois que a cidade √© selecionada?  Simplesmente chama um retorno de chamada com um √∫nico par√¢metro "cidade". <br><br>  Isso termina o c√≥digo para as pr√≥prias telas.  Como vemos, eles n√£o sabem nada sobre o ambiente. <br><br><h4>  Coordenador <br></h4><br>  Vamos para o link entre essas telas. <br><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> UIKit protocol UpdateableWithUser: <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> { var <span class="hljs-keyword"><span class="hljs-keyword">user</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">User</span></span>? { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> } } final <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> UserEditCoordinator { // MARK: - Properties private var <span class="hljs-keyword"><span class="hljs-keyword">user</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">User</span></span> { didSet { updateInterfaces() } } private weak var navigationController: UINavigationController? // MARK: - Init init(<span class="hljs-keyword"><span class="hljs-keyword">user</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">User</span></span>, navigationController: UINavigationController) { self.<span class="hljs-keyword"><span class="hljs-keyword">user</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">user</span></span> self.navigationController = navigationController } func <span class="hljs-keyword"><span class="hljs-keyword">start</span></span>() { showUserEditScreen() } // MARK: - Private implementation private func showUserEditScreen() { let controller = UIStoryboard.makeUserEditController() controller.<span class="hljs-keyword"><span class="hljs-keyword">user</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">user</span></span> controller.onSelectCity = { [weak self] <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> self?.showCitiesScreen() } navigationController?.pushViewController(controller, animated: <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>) } private func showCitiesScreen() { let controller = UIStoryboard.makeCitiesController() controller.onCitySelected = { [weak self] city <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> self?.<span class="hljs-keyword"><span class="hljs-keyword">user</span></span>.city = city _ = self?.navigationController?.popViewController(animated: <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>) } navigationController?.pushViewController(controller, animated: <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>) } private func updateInterfaces() { navigationController?.viewControllers.<span class="hljs-keyword"><span class="hljs-keyword">forEach</span></span> { (<span class="hljs-meta"><span class="hljs-meta">$0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">as</span></span>? UpdateableWithUser)?.<span class="hljs-keyword"><span class="hljs-keyword">user</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">user</span></span> } } }</code> </pre><br>  O coordenador tem duas propriedades: <br><br><ol><li>  Usu√°rio - o usu√°rio que editaremos; </li><li>  O NavigationController ao qual passar na inicializa√ß√£o. </li></ol><br>  Existe um init () simples que preenche essas propriedades. <br><br>  A seguir, √© apresentado o m√©todo start (), que faz com que o m√©todo <strong>ShowUserEditScreen ()</strong> seja <strong>chamado</strong> .  Vamos insistir nisso com mais detalhes.  Este m√©todo retira o controlador do UIStoryboard, passa-o para o usu√°rio local.  Em seguida, ele coloca o retorno de chamada SelectSity e coloca esse controlador na pilha de navega√ß√£o. <br><br>  Depois que o usu√°rio clica no bot√£o, o retorno de chamada onSelectCity √© acionado e isso faz com que o seguinte m√©todo <strong>ShowCitiesScreen ()</strong> privado seja <strong>chamado</strong> . <br><br>  Na verdade, ele faz quase a mesma coisa - levanta um controlador ligeiramente diferente do UIStoryboard, coloca o retorno de chamada onCitySelected nele e o empurra para a pilha de Navega√ß√£o - √© tudo o que acontece.  Quando o usu√°rio seleciona uma cidade espec√≠fica, esse retorno de chamada √© acionado, o coordenador atualiza o campo "cidade" do usu√°rio local e rola a pilha de Navega√ß√£o para a primeira tela. <br><br>  Como o usu√°rio √© uma estrutura, a atualiza√ß√£o do campo "cidade" leva ao fato de que o bloco didSet √© chamado, respectivamente, o m√©todo privado <strong>updateInterfaces ()</strong> .  Esse m√©todo percorre toda a pilha de navega√ß√£o e tenta implantar cada ViewController como o protocolo UpdateableWithUser.  Este √© o protocolo mais simples, que possui apenas uma propriedade - usu√°rio.  Se isso der certo, ele o envia ao usu√°rio atualizado.  Assim, acontece que nosso usu√°rio selecionado na segunda tela passa automaticamente para a primeira tela. <br><br>  Tudo est√° claro com o coordenador, e a √∫nica coisa a ser mostrada aqui √© o ponto de entrada para o nosso aplicativo.  √â aqui que tudo come√ßa.  Nesse caso, esse √© o m√©todo didFinishLaunchingWithOptions do nosso AppDelegate. <br><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> UIKit @UIApplicationMain <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> AppDelegate: UIResponder, UIApplicationDelegate { var <span class="hljs-keyword"><span class="hljs-keyword">window</span></span>: UIWindow? var coordinator: UserEditCoordinator! func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplicationLaunchOptionsKey: <span class="hljs-keyword"><span class="hljs-keyword">Any</span></span>]?) -&gt; <span class="hljs-type"><span class="hljs-type">Bool</span></span> { guard let navigationController = <span class="hljs-keyword"><span class="hljs-keyword">window</span></span>?.rootViewController <span class="hljs-keyword"><span class="hljs-keyword">as</span></span>? UINavigationController <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">true</span></span> } let <span class="hljs-keyword"><span class="hljs-keyword">user</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">User</span></span>(<span class="hljs-type"><span class="hljs-type">name</span></span>: "Pavel Gurov", city: City(<span class="hljs-type"><span class="hljs-type">name</span></span>: "Moscow")) coordinator = UserEditCoordinator(<span class="hljs-keyword"><span class="hljs-keyword">user</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">user</span></span>, navigationController: navigationController) coordinator.<span class="hljs-keyword"><span class="hljs-keyword">start</span></span>() <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">true</span></span> } }</code> </pre><br>  Aqui, o navigationController √© retirado do UIStoryboard, um usu√°rio √© criado, o qual editaremos, com um nome e uma cidade espec√≠fica.  Em seguida, criamos nosso coordenador com User e navigationController.  Ele chama o m√©todo start ().  O coordenador √© transferido para a propriedade local - isso √© basicamente tudo.  O esquema √© bastante simples. <br><br><h4>  Entradas e sa√≠das <br></h4><br>  H√° v√°rios pontos em que gostaria de me aprofundar em mais detalhes.  Voc√™ provavelmente notou que a propriedade no userEditViewController est√° marcada com um coment√°rio como Entrada e os retornos de chamada desses controladores est√£o marcados como Sa√≠da. <br><br><img src="https://habrastorage.org/webt/xs/_v/kr/xs_vkrwlnwgvdyneeeijb2xsrm0.jpeg"><br><br>  <strong>Uma entrada</strong> √© qualquer dado que possa sofrer altera√ß√µes ao longo do tempo, bem como alguns m√©todos ViewController que podem ser chamados de fora.  Por exemplo, em UserEditViewController, essa √© uma propriedade User - o pr√≥prio usu√°rio ou seu par√¢metro City podem ser alterados. <br><br>  <strong>Uma sa√≠da</strong> √© qualquer evento que o controlador queira se comunicar com o mundo externo.  No UserEditViewController, √© um clique no bot√£o onSelectCity e, na tela de sele√ß√£o da cidade, √© um clique em uma c√©lula com uma cidade espec√≠fica.  A principal id√©ia aqui √©, repito, que o controlador n√£o sabe nada e n√£o faz nada sobre esses eventos.  Ele delega para decidir o que fazer, para outra pessoa. <br><br>  No Objective-C, n√£o gostei muito de escrever callbacks salvos por causa de sua terr√≠vel sintaxe.  Mas em Swift, isso √© muito mais simples.  O uso de retornos de chamada nesse caso √© uma alternativa ao padr√£o de delega√ß√£o conhecido no iOS.  Somente aqui, em vez de designar m√©todos no protocolo e dizer que o coordenador corresponde a esse protocolo e, em seguida, escrever esses m√©todos em algum lugar separadamente, podemos imediatamente criar uma entidade de maneira conveniente e conveniente, colocar um retorno de chamada e fazer tudo. <br><br>  √â verdade que, com essa abordagem, diferentemente da delega√ß√£o, h√° uma conex√£o estreita entre a ess√™ncia do coordenador e a tela, porque o coordenador sabe que existe uma ess√™ncia espec√≠fica da tela. <br><br>  Voc√™ pode se livrar disso da mesma maneira que na delega√ß√£o, usando protocolos. <br><br><img src="https://habrastorage.org/webt/a-/nm/aa/a-nmaaf8uwdvujtzcvhjmfz0k2c.jpeg"><br><br>  Para evitar a conectividade, podemos <strong>fechar a</strong> <strong>entrada e a</strong> <strong>sa√≠da do nosso controlador com um protocolo</strong> . <br><br>  Acima est√° o protocolo CitiesOutput, que tem exatamente um requisito - o retorno de chamada onCitySelected.  √Ä esquerda, √© um an√°logo desse esquema no Swift.  Nosso controlador est√° em conformidade com este protocolo, determinando o retorno de chamada necess√°rio.  Fazemos isso para que o coordenador n√£o saiba sobre a exist√™ncia da classe CitiesViewController.  Mas em algum momento ele precisar√° configurar a sa√≠da desse controlador.  Para aumentar tudo, adicionamos uma f√°brica ao coordenador. <br><br><img src="https://habrastorage.org/webt/vx/hl/0v/vxhl0vp5g0pybl5_6pbasirpfby.jpeg"><br><br>  A f√°brica possui um m√©todo cityOutput ().  Acontece que nosso coordenador n√£o cria um controlador e n√£o o obt√©m de algum lugar.  Uma f√°brica lan√ßa para ele, que retorna um objeto fechado pelo protocolo no m√©todo, e ele n√£o sabe nada sobre qual classe esse objeto √©. <br><br>  Agora, a coisa mais importante - por que tudo isso?  <strong>Por que precisamos construir em outro n√≠vel adicional quando n√£o havia problemas?</strong> <br><br>  Pode-se imaginar esta situa√ß√£o: um gerente nos procurar√° e pedir√° que voc√™ fa√ßa um teste A / B do fato de que, em vez de uma lista de cidades, ter√≠amos a op√ß√£o de escolher uma cidade no mapa.  Se em nossa aplica√ß√£o a escolha da cidade n√£o estava em um lugar, mas em coordenadores diferentes, em diferentes cen√°rios, tivemos que costurar uma bandeira em cada lugar, jog√°-la para fora, nessa bandeira, levantar um ou outro ViewController.  Isso n√£o √© muito conveniente. <br><br>  Queremos remover esse conhecimento do coordenador.  Portanto, algu√©m poderia fazer isso em um s√≥ lugar.  Na pr√≥pria f√°brica, criar√≠amos um par√¢metro pelo qual a f√°brica retornasse um ou outro controlador fechado pelo protocolo.  Ambos teriam um retorno de chamada em CitySelected, e o coordenador, em princ√≠pio, n√£o se importaria com qual dessas telas trabalhar - um mapa ou uma lista. <br><br><h2>  Composi√ß√£o VS Heran√ßa <br></h2><br>  O pr√≥ximo ponto em que eu queria me concentrar √© a composi√ß√£o contra heran√ßa. <br><br><img src="https://habrastorage.org/webt/l5/9m/qg/l59mqgla1anz9rqv3sla16adtiw.jpeg"><br><br><ol><li>  O primeiro m√©todo de como nosso coordenador pode ser feito √© <strong>fazer a composi√ß√£o</strong> quando o NavigationController for passado a ele de fora e armazenado localmente como propriedade.  √â como uma composi√ß√£o - adicionamos um NavigationController como uma propriedade. </li><li>  Por outro lado, existe uma opini√£o de que tudo est√° presente no Kit da interface do usu√°rio e n√£o precisamos reinventar a roda.  Voc√™ pode simplesmente pegar e <strong>herdar o UI</strong> <strong>NavigationController</strong> . </li></ol><br>  Cada op√ß√£o tem seus pr√≥s e contras, mas, pessoalmente, parece-me que a <strong>composi√ß√£o nesse caso √© mais adequada do</strong> que a heran√ßa.  A heran√ßa geralmente √© um esquema menos flex√≠vel.  Se precisarmos, por exemplo, alterar o Navigation para, digamos, UIPageController, ent√£o, no primeiro caso, podemos simplesmente fech√°-los com um protocolo comum, como ‚ÄúMostrar a pr√≥xima tela‚Äù e substituir convenientemente o cont√™iner de que precisamos. <br><br>  Do meu ponto de vista, o argumento mais importante √© que voc√™ oculte do usu√°rio final na composi√ß√£o todos os m√©todos desnecess√°rios.  Acontece que ele √© menos propenso a trope√ßar.  Voc√™ deixa <strong>apenas a</strong> <strong>API necess√°ria</strong> , por exemplo, o m√©todo Start - e √© tudo.  Ele n√£o tem como chamar o m√©todo PushViewController, PopViewController, ou seja, interferir de alguma forma nas atividades do coordenador.  Todos os m√©todos da classe pai est√£o ocultos. <br><br><h2>  Storyboards <br></h2><br>  Acredito que eles merecem aten√ß√£o especial junto com os seguidores.  Pessoalmente, <strong>apoio os</strong> <strong>seguidores</strong> , pois eles permitem que voc√™ se familiarize rapidamente com o script.  Quando um novo desenvolvedor chega, ele n√£o precisa escalar o c√≥digo, os Storyboards ajudam nisso.  Mesmo se voc√™ criar uma interface com o c√≥digo, poder√° deixar o ViewController vazio e criar a interface com o c√≥digo, mas deixe pelo menos as transi√ß√µes e o ponto inteiro.  Toda a ess√™ncia do Storyboards est√° nas pr√≥prias transi√ß√µes e n√£o no layout da interface do usu√°rio. <br><br>  Felizmente, a <strong>abordagem</strong> do <strong>coordenador n√£o limita a escolha das ferramentas</strong> .  Podemos usar com seguran√ßa coordenadores junto com segues.  Mas devemos lembrar que agora n√£o podemos trabalhar com segues dentro do UIViewController. <br><br><img src="https://habrastorage.org/webt/hp/sl/qp/hpslqpf2-het-coms7wczezguo8.jpeg"><br><br>  Portanto, devemos substituir o m√©todo onPrepareForSegue em nossa classe.  Em vez de fazer algo dentro do controlador, delegaremos essas tarefas novamente ao coordenador, atrav√©s do retorno de chamada.  O m√©todo onPrepareForSegue √© chamado, voc√™ n√£o faz nada por conta pr√≥pria - voc√™ n√£o sabe que tipo de acompanhamento √© esse, que controlador de destino √© - n√£o importa para voc√™.  Voc√™ simplesmente joga tudo em um retorno de chamada, e o coordenador descobrir√°.  Ele tem esse conhecimento, voc√™ n√£o precisa desse conhecimento. <br><br>  Para simplificar tudo, voc√™ pode fazer isso em uma determinada classe Base para n√£o substitu√≠-lo em cada controlador tomado separadamente.  Nesse caso, ser√° mais conveniente para o coordenador trabalhar com seus seguidores. <br><br>  Outra coisa que acho conveniente com o Storyboard √© aderir √† regra de que <strong>um</strong> <strong>Storyboard √© igual a um coordenador</strong> .  Depois, voc√™ pode simplificar bastante tudo, criar uma classe em geral - o StoryboardCoordinator e gerar o par√¢metro RootType nele, criar o controlador de Navega√ß√£o inicial no Storyboard e agrupar todo o script nele. <br><br><img src="https://habrastorage.org/webt/sm/v2/wz/smv2wzspn7ykrajsui8npmfvcls.jpeg"><br><br>  Como voc√™ pode ver, aqui o coordenador possui 2 propriedades: navigationController;  O rootViewController do nosso RootType √© gen√©rico.  Durante a inicializa√ß√£o, passamos para ele n√£o um navigationController espec√≠fico, mas um Storyboard, do qual nossa Navega√ß√£o raiz e seu primeiro controlador obt√™m.  Dessa forma, nem precisamos chamar nenhum m√©todo Start.  Ou seja, voc√™ criou um coordenador, ele imediatamente tem Navega√ß√£o e imediatamente Raiz.  Voc√™ pode mostrar a navega√ß√£o modalmente ou pegar o Root e acessar a navega√ß√£o existente e continuar trabalhando. <br><br>  Nosso UserEditCoordinator nesse caso simplesmente se tornaria tipealias, substituindo o tipo de seu RootViewController no par√¢metro gen√©rico. <br><br><h2>  Transfer√™ncia de dados de script de volta <br></h2><br>  Vamos falar sobre a solu√ß√£o do √∫ltimo problema, que descrevi no in√≠cio.  Essa √© a transfer√™ncia de dados de volta para o script. <br><br><img src="https://habrastorage.org/webt/i6/i9/el/i6i9el9jdxqnjqp2pe80epk27iy.jpeg"><br><br>  Considere o mesmo cen√°rio para escolher uma cidade, mas agora ser√° poss√≠vel escolher n√£o uma cidade, mas v√°rias.  Para mostrar ao usu√°rio que ele selecionou v√°rias cidades da mesma regi√£o, mostraremos na tela com uma lista de regi√µes um pequeno n√∫mero ao lado do nome da regi√£o, mostrando o n√∫mero de cidades selecionadas nessa regi√£o. <br><br>  Acontece que a a√ß√£o em um controlador (no terceiro) deve levar a uma mudan√ßa na apar√™ncia de v√°rios outros ao mesmo tempo.  Ou seja, no primeiro devemos mostrar na c√©lula com a cidade e no segundo devemos atualizar todos os n√∫meros nas regi√µes selecionadas. <br><br>  O coordenador simplifica essa tarefa transferindo dados de volta para o script - agora √© uma tarefa t√£o simples quanto transferir dados para frente de acordo com o script. <br><br>  O que est√° acontecendo aqui?  O usu√°rio seleciona uma cidade.  Esta mensagem √© enviada ao coordenador.  O coordenador, como j√° mostrei na demonstra√ß√£o, percorre toda a pilha de navega√ß√£o e envia dados atualizados para todas as partes interessadas.  Consequentemente, o ViewController pode atualizar sua visualiza√ß√£o com esses dados. <br><br><h2>  Refatorando o c√≥digo existente <br></h2><br>  Como refatorar o c√≥digo existente, se voc√™ deseja incorporar essa abordagem em um aplicativo existente que possui MVc, MVVm ou MVp? <br><br><img src="https://habrastorage.org/webt/dd/_h/ss/dd_hssepys-qb1ybs9tg6qhnlqo.jpeg"><br><br>  Voc√™ tem um monte de ViewController.  A primeira coisa a fazer √© dividi-los em cen√°rios em que participam.  No nosso exemplo, existem tr√™s cen√°rios: autoriza√ß√£o, edi√ß√£o de perfil, fita. <br><br><img src="https://habrastorage.org/webt/nb/gy/yq/nbgyyqm1qsj1jb_nasqr5wdtdnk.jpeg"><br><br>  Agora, agrupamos cada cen√°rio dentro de nosso coordenador.  De fato, devemos poder iniciar esses scripts de qualquer lugar em nosso aplicativo.  Isso deve ser flex√≠vel - o <strong>coordenador deve ser completamente auto-suficiente</strong> . <br><br>  Essa abordagem de desenvolvimento oferece maior comodidade.  Consiste no fato de que, se voc√™ estiver trabalhando atualmente com um cen√°rio espec√≠fico, n√£o precisar√° clicar nele toda vez que o iniciar.  Voc√™ pode inici√°-lo rapidamente no in√≠cio, editar algo nele e remover essa inicializa√ß√£o tempor√°ria. <br><br>  Depois de decidirmos sobre nossos coordenadores, precisamos determinar qual cen√°rio pode levar ao in√≠cio de outro e criar uma √°rvore a partir desses cen√°rios. <br><br><img src="https://habrastorage.org/webt/ya/y0/dn/yay0dneeqirzezm667lwklnkux0.jpeg"><br><br>  No nosso caso, a √°rvore √© simples: o LoginCoordinator pode iniciar o coordenador de edi√ß√£o de perfis.  Aqui, quase tudo se encaixa, mas um detalhe muito importante permanece - nosso esquema carece de um ponto de entrada. <br><br><img src="https://habrastorage.org/webt/38/-0/no/38-0nolfpsqej62yytkzqp-ux6s.jpeg"><br><br>  Este ponto de entrada ser√° um coordenador especial - <strong>ApplicationCoordinator</strong> .  Ele √© criado e iniciado pelo <strong>AppDelegate</strong> e, em seguida, j√° controla a l√≥gica no n√≠vel do aplicativo, ou seja, qual coordenador inicia agora. <br><br>  Acabamos de analisar um circuito muito semelhante, mas ele tinha o ViewController em vez de coordenadores, e fizemos com que o ViewController n√£o soubesse nada um do outro e n√£o passasse dados entre si.  Em princ√≠pio, o mesmo pode ser feito com os coordenadores.  Podemos designar uma determinada entrada (m√©todo Start) e Output (retorno de chamada onFinish) nelas.  <strong>Os coordenadores se tornam independentes, reutiliz√°veis ‚Äã‚Äãe facilmente test√°veis</strong> .  Os coordenadores deixam de se conhecer e se comunicam, por exemplo, apenas com o ApplicationCoordinator. <br><br>  Voc√™ precisa ter cuidado, porque se o seu aplicativo tiver o suficiente desses scripts, o ApplicationCoordinator poder√° se transformar em um grande objeto divino, ele saber√° sobre todos os scripts existentes - isso tamb√©m n√£o √© muito legal.  Aqui j√° devemos procurar - talvez dividir os coordenadores em sub-coordenadores, ou seja, pensar em uma arquitetura como essa para que esses objetos n√£o atinjam tamanhos incr√≠veis.  <strong>Embora o tamanho nem sempre seja um motivo para refatora√ß√£o</strong> . <br><br><h3>  Por onde come√ßar <br></h3><br>  Aconselho come√ßar de baixo para cima - primeiro implemente scripts individuais. <br><br><img src="https://habrastorage.org/webt/rw/tw/al/rwtwalrny6uxjzbpfhcjzxybzse.jpeg"><br><br>  Como solu√ß√£o alternativa, eles podem ser iniciados dentro do UIViewController.  Ou seja, desde que voc√™ n√£o tenha o Root ou outros coordenadores, voc√™ pode criar um coordenador e, como solu√ß√£o tempor√°ria, inici√°-lo no UIViewController, salvando-o localmente na propriedade (como o nextCoordinator est√° acima).  Quando um evento ocorre, voc√™, como mostrei na demonstra√ß√£o, cria uma propriedade local, coloca o coordenador l√° e chama o m√©todo Start nela.  Tudo √© muito simples. <br><br>  Ent√£o, quando todos esses coordenadores j√° tiverem feito, o in√≠cio de um dentro do outro ser√° exatamente o mesmo.  Voc√™ tem uma propriedade local ou algum tipo de matriz de depend√™ncias, como coordenador, coloca tudo isso l√° para que ele n√£o fuja e chama o m√©todo Start. <br><br><h2>  Sum√°rio <br></h2><br><ul><li>  <strong>Telas e scripts independentes</strong> que n√£o sabem nada um do outro n√£o se comunicam.  Tentamos conseguir isso. <br></li><li>  <strong>√â f√°cil alterar a ordem das</strong> telas no aplicativo sem alterar os c√≥digos de tela.  Se tudo for feito como deveria, a √∫nica coisa que deve mudar no aplicativo quando o script muda n√£o √© o c√≥digo da tela, mas o c√≥digo do coordenador. <br></li><li>  <strong>Transfer√™ncia de dados simplificada entre telas</strong> e outras tarefas que implicam uma conex√£o entre telas. <br></li><li>      ‚Äî    ,       <strong>  </strong>     . <br></li></ul><br><blockquote> AppsConf 2018  8  9  ‚Äî  !   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="></a> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="></a>  )  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="></a> .      ‚Äî iOS  Android,      ,       ,     ,      . <br></blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt423299/">https://habr.com/ru/post/pt423299/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt423285/index.html">Engenharia social: o inimigo ilus√≥rio no mundo da seguran√ßa cibern√©tica</a></li>
<li><a href="../pt423291/index.html">Russos estabelecem um recorde: 110 filmes piratas por pessoa</a></li>
<li><a href="../pt423293/index.html">Como n√£o dar um tiro na perna com uma m√°quina de estado</a></li>
<li><a href="../pt423295/index.html">Confer√™ncia de Desenvolvimento M√≥vel Mais √ötil</a></li>
<li><a href="../pt423297/index.html">Do desenvolvedor Android ao DevOps</a></li>
<li><a href="../pt423303/index.html">AI, curso pr√°tico. Transforma√ß√£o da M√∫sica Baseada na Emo√ß√£o</a></li>
<li><a href="../pt423305/index.html">Arruinar o desempenho</a></li>
<li><a href="../pt423307/index.html">Solicita√ß√µes pull do GitHub no c√≥digo do Visual Studio</a></li>
<li><a href="../pt423309/index.html">Transa√ß√µes DBMS</a></li>
<li><a href="../pt423311/index.html">Naviaddress de parceria e ACTUM</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>