<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üöµüèΩ ü¶ç üëáüèº Filsuf cukup makan atau pemrograman .NET kompetitif ü§™ üóùÔ∏è üåè</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Mari kita lihat bagaimana pemrograman paralel dan paralel dalam. Net bekerja, menggunakan masalah filsuf makan sebagai contoh. Rencana semacam itu, da...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Filsuf cukup makan atau pemrograman .NET kompetitif</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/447898/"><p><img src="https://habrastorage.org/webt/ox/lr/6d/oxlr6dmndsfjh_zjsowzpozt-30.png"></p><br><p>  Mari kita lihat bagaimana pemrograman paralel dan paralel dalam. Net bekerja, menggunakan masalah filsuf makan sebagai contoh.  Rencana semacam itu, dari sinkronisasi utas / proses, hingga model aktor (di bagian berikut).  Artikel ini mungkin berguna untuk kenalan pertama atau untuk menyegarkan kembali pengetahuan Anda. </p><br><p>  Mengapa bisa melakukan ini?  Transistor mencapai ukuran minimumnya, hukum Moore bertumpu pada batasan kecepatan cahaya, dan oleh karena itu pertumbuhan diamati dalam kuantitas, lebih banyak transistor dapat dilakukan.  Pada saat yang sama, jumlah data bertambah, dan pengguna mengharapkan reaksi langsung dari sistem.  Dalam situasi seperti itu, pemrograman "normal", ketika kita memiliki satu utas pelaksana, tidak lagi efektif.  Penting untuk entah bagaimana menyelesaikan masalah eksekusi simultan atau kompetitif.  Selain itu, masalah ini ada pada tingkat yang berbeda: pada tingkat aliran, pada tingkat proses, pada tingkat mesin dalam jaringan (sistem terdistribusi).  .NET memiliki teknologi berkualitas tinggi yang telah teruji oleh waktu untuk menyelesaikan masalah tersebut dengan cepat dan efektif. </p><a name="habracut"></a><br><br><h2 id="anchorproblemanchor-zadacha"><a name="problem"></a>  Tantangan </h2><br><p>  Edsger Dijkstra mengajukan masalah ini kepada murid-muridnya pada awal 1965. Kata-kata yang digunakan adalah ini.  Ada beberapa (biasanya lima) jumlah filsuf dan sebanyak garpu.  Mereka duduk di meja bundar, bercabang di antaranya.  Para filsuf dapat makan dari piring mereka dengan makanan tanpa akhir, berpikir atau menunggu.  Untuk makan filsuf, Anda perlu mengambil dua garpu (yang terakhir berbagi garpu dengan yang pertama).  Untuk mengambil dan meletakkan garpu - dua tindakan terpisah.  Semua filsuf diam.  Tugasnya adalah menemukan algoritma yang sedemikian rupa sehingga mereka semua berpikir dan muak bahkan setelah 54 tahun. </p><br><p>  Pertama, mari kita coba selesaikan masalah ini dengan menggunakan ruang bersama.  Garpu ada di atas meja dan filsuf hanya mengambil mereka ketika mereka dan meletakkannya kembali.  Ada masalah dengan sinkronisasi, kapan tepatnya mengambil colokan?  Apa yang harus dilakukan jika tidak ada plug?  dan lainnya, tetapi pertama-tama, mari kita luncurkan para filsuf. </p><br><p> Untuk memulai utas, gunakan kumpulan utas melalui metode <code>Task.Run</code> : </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> cancelTokenSource = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CancellationTokenSource(); Action&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; create = (i) =&gt; RunPhilosopher(i, cancelTokenSource.Token); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; philosophersAmount; i++) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> icopy = i; <span class="hljs-comment"><span class="hljs-comment">//      .  RunDeadlock   // ,    .  . philosophers[i] = Task.Run(() =&gt; create(icopy), cancelTokenSource.Token); }</span></span></code> </pre> <br><p>  Kumpulan utas dibuat untuk mengoptimalkan pembuatan dan penghapusan utas.  Kelompok ini memiliki antrian tugas dan CLR membuat atau menghapus utas tergantung pada jumlah tugas ini.  Satu kumpulan untuk semua AppDomains.  Kolam ini harus digunakan hampir selalu, karena  Anda tidak perlu repot-repot membuat, menghapus utas, antriannya, dll. Ini dimungkinkan tanpa kumpulan, tetapi kemudian Anda harus menggunakan <code>Thread</code> secara langsung, disarankan untuk kasus-kasus ketika Anda perlu mengubah prioritas utas, saat kami memiliki operasi yang panjang, untuk Latar depan utas, dll. </p><br><p>  Dan kelas <code>System.Threading.Tasks.Task</code> membuatnya mudah untuk bekerja dengan kumpulan utas ini (atau bahkan melakukannya tanpa itu).  Ini adalah operasi asinkron.  Secara kasar, ini adalah <code>Thread</code> sama, tetapi dengan segala macam kemudahan: kemampuan untuk meluncurkan tugas setelah satu blok tugas lain, mengembalikannya dari fungsi, mudah untuk menginterupsi mereka, dan banyak lagi.  dll. Mereka diperlukan untuk mendukung konstruksi asinkron / menunggu (Pola Asinkron berbasis Tugas, gula sintaksis untuk menunggu operasi IO).  Kami akan membicarakan ini lagi. </p><br><p>  <code>CancelationTokenSource</code> diperlukan di sini agar utas itu sendiri dapat diakhiri oleh sinyal utas panggilan. </p><br><h2 id="problemy-s-sinhronizaciey">  Sinkronkan Masalah </h2><br><h3 id="blokirovannye-filosofy">  Filsuf yang diblokir </h3><br><p>  Oke, kita bisa buat utas, mari kita coba makan siang: </p><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">//    .  : 1 1 3 3 - 1  3    . private int[] forks = Enumerable.Repeat(0, philosophersAmount).ToArray(); //  ,  RunPhilosopher() private void RunDeadlock(int i, CancellationToken token) { //  ,  . : // while(true) // if forks[fork] == 0 // forks[fork] = i+1 // break // Thread.Sleep()  Yield()  SpinWait() void TakeFork(int fork) =&gt; SpinWait.SpinUntil(() =&gt; Interlocked.CompareExchange(ref forks[fork], i+1, 0) == 0); //  ,    Interlocked.Exchange: void PutFork(int fork) =&gt; forks[fork] = 0; while (true) { TakeFork(Left(i)); TakeFork(Right(i)); eatenFood[i] = (eatenFood[i] + 1) % (int.MaxValue - 1); PutFork(Left(i)); PutFork(Right(i)); Think(i); //   -. token.ThrowIfCancellationRequested(); } }</span></span></code> </pre> <br><p>  Di sini kita pertama-tama mencoba untuk mengambil garpu kiri dan kanan, dan jika berhasil, maka kita makan dan mengembalikannya.  Mengambil satu garpu adalah atom, mis.  dua aliran tidak dapat mengambil satu pada saat yang sama (salah: yang pertama membaca bahwa steker bebas, yang kedua juga, yang pertama, yang kedua).  Untuk melakukan ini, <code>Interlocked.CompareExchange</code> , yang harus diimplementasikan menggunakan instruksi prosesor ( <code>TSL</code> , <code>XCHG</code> ), yang memblokir sepotong memori untuk membaca dan menulis sekuensial atom.  Dan SpinWait setara dengan konstruksi <code>while(true)</code> dengan hanya sedikit "keajaiban" - utas mengambil prosesor ( <code>Thread.SpinWait</code> ), tetapi kadang-kadang mentransfer kontrol ke utas lain ( <code>Thread.Yeild</code> ) atau tertidur ( <code>Thread.Sleep</code> ). </p><br><p>  Tetapi solusi ini tidak berhasil, karena  aliran akan segera diblokir (untuk saya dalam satu detik): semua filsuf mengambil garpu kiri mereka, tetapi bukan yang benar.  Array fork kemudian memiliki nilai: 1 2 3 4 5. </p><br><p><img src="https://habrastorage.org/webt/4l/0x/h9/4l0xh9rwiyjh1l8u2z2szlnv--o.png" alt="Livelock"></p><br><p>  Dalam gambar, memblokir benang (kebuntuan).  Hijau menunjukkan eksekusi, merah menunjukkan sinkronisasi, dan abu-abu menunjukkan tidur.  Berlian menunjukkan waktu mulai dari Tugas. </p><br><h3 id="golod-filosofov">  Kelaparan para filsuf </h3><br><p>  Meskipun tidak perlu terlalu banyak memikirkan makanan, tetapi Anda harus memaksa siapa pun untuk menyerah pada filosofi.  Mari kita coba mensimulasikan situasi aliran puasa dalam masalah kita.  Kelaparan adalah ketika sungai bekerja, tetapi tanpa kerja yang signifikan, dengan kata lain, itu adalah jalan buntu yang sama, hanya sekarang sungai tidak tidur, tetapi secara aktif mencari sesuatu untuk dimakan, tetapi tidak ada makanan.  Untuk menghindari pemblokiran yang sering, kami akan memasang kembali steker jika kami tidak dapat mengambil yang lain. </p><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">//      RunDeadlock,         . private void RunStarvation(int i, CancellationToken token) { while (true) { bool hasTwoForks = false; var waitTime = TimeSpan.FromMilliseconds(50); //      : bool hasLeft = forks[Left(i)] == i + 1; if (hasLeft || TakeFork(Left(i), i + 1, waitTime)) { if (TakeFork(Right(i), i + 1, TimeSpan.Zero)) hasTwoForks = true; else PutFork(Left(i)); //      . } if (!hasTwoForks) { if (token.IsCancellationRequested) break; continue; } eatenFood[i] = (eatenFood[i] + 1) % (int.MaxValue - 1); bool goodPhilosopher = i % 2 == 0; //        : if (goodPhilosopher) PutFork(Left(i)); //      ,      . PutFork(Right(i)); Think(i); if (token.IsCancellationRequested) break; } } //     . bool TakeFork(int fork, int philosopher, TimeSpan? waitTime = null) { return SpinWait.SpinUntil( () =&gt; Interlocked.CompareExchange(ref forks[fork], philosopher, 0) == 0, waitTime ?? TimeSpan.FromMilliseconds(-1) ); }</span></span></code> </pre> <br><p>  Dalam kode ini, penting bahwa dua dari empat filsuf lupa untuk meletakkan garpu kiri mereka.  Dan ternyata mereka makan lebih banyak, sementara yang lain mulai kelaparan, meskipun arusnya memiliki prioritas yang sama.  Di sini mereka tidak benar-benar kelaparan, karena  filsuf yang buruk kadang-kadang mengembalikan garpu mereka.  Ternyata yang baik makan sekitar 5 kali lebih sedikit dari yang buruk.  Jadi kesalahan kecil dalam kode menyebabkan penurunan kinerja.  Di sini perlu dicatat bahwa situasi yang langka mungkin terjadi ketika semua filsuf mengambil garpu kiri, tidak ada hak, mereka meletakkan kiri, menunggu, mengambil kiri lagi, dll.  Situasi ini juga kelaparan, lebih seperti jalan buntu.  Saya tidak bisa mengulanginya.  Di bawah ini adalah gambaran untuk situasi di mana dua filsuf jahat mengambil garpu dan dua filsuf baik kelaparan. </p><br><p><img src="https://habrastorage.org/webt/2v/iw/b_/2viwb_qgxqznj1timeklnwscluw.png" alt="Kelaparan"></p><br><p>  Di sini Anda dapat melihat bahwa utas terkadang bangun dan mencoba mendapatkan sumber daya.  Dua dari empat core tidak melakukan apa-apa (grafik hijau di atas). </p><br><h3 id="smert-filosofa">  Kematian sang filsuf </h3><br><p>  Nah, masalah lain yang dapat mengganggu jamuan makan malam para filsuf adalah jika salah satu dari mereka tiba-tiba mati dengan garpu di tangannya (dan mereka akan menguburnya seperti itu).  Maka tetangga akan dibiarkan tanpa makan siang.  Anda dapat <code>NullReferenceException</code> kode contoh untuk kasus ini sendiri, misalnya, <code>NullReferenceException</code> dilemparkan setelah filsuf mengambil garpu.  Dan, omong-omong, pengecualian tidak akan diproses dan kode panggilan tidak akan menangkapnya (untuk ini, <code>AppDomain.CurrentDomain.UnhandledException</code> , dll.).  Oleh karena itu, penangan kesalahan diperlukan di utas sendiri dan dengan terminasi yang benar. </p><br><h2 id="oficiant">  Pelayan </h2><br><p>  Nah, bagaimana kita mengatasi masalah ini dengan kebuntuan, kelaparan, dan kematian?  Kami hanya akan mengizinkan satu filsuf untuk bercabang, menambahkan saling pengecualian aliran untuk tempat ini.  Bagaimana cara melakukannya?  Misalkan seorang pelayan berdiri di sebelah para filsuf yang memberikan izin kepada seorang filsuf untuk mengambil garpu.  Bagaimana kita membuat pelayan ini dan bagaimana para filsuf bertanya kepadanya, pertanyaan-pertanyaan menarik. </p><br><p>  Cara paling sederhana adalah ketika para filsuf terus-menerus meminta pelayan untuk akses ke garpu.  Yaitu  sekarang para filsuf tidak akan menunggu untuk plug di dekatnya, tetapi menunggu atau meminta pelayan.  Pertama, kami hanya menggunakan Ruang Pengguna untuk ini, di dalamnya kami tidak menggunakan interupsi untuk memanggil prosedur apa pun dari kernel (tentang mereka di bawah). </p><br><h3 id="resheniya-v-prostranstve-polzovatelya">  Solusi Ruang Pengguna </h3><br><p>  Di sini kita akan melakukan hal yang sama seperti dulu dengan satu garpu dan dua filsuf, kita akan berputar dalam satu siklus dan menunggu.  Tapi sekarang semua filsuf dan seolah-olah hanya satu garpu, yaitu.  kita bisa mengatakan hanya akan ada filsuf yang mengambil "garpu emas" dari pelayan.  Untuk ini kami menggunakan SpinLock. </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> SpinLock spinLock = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SpinLock(); <span class="hljs-comment"><span class="hljs-comment">//  "" private void RunSpinLock(int i, CancellationToken token) { while (true) { //    busy waiting.   try,  //        SpinLock. bool hasLock = false; spinLock.Enter(ref hasLock); try { //       (mutual exclusion). forks[Left(i)] = i + 1; //   ,  . forks[Right(i)] = i + 1; eatenFood[i] = (eatenFood[i] + 1) % (int.MaxValue - 1); forks[Left(i)] = 0; forks[Right(i)] = 0; } finally { if(hasLock) spinLock.Exit(); //     . } Think(i); if (token.IsCancellationRequested) break; } }</span></span></code> </pre> <br><p>  <code>SpinLock</code> adalah pemblokir, dengan, secara kasar, <code>while(true) { if (!lock) break; }</code>  <code>while(true) { if (!lock) break; }</code> , tetapi dengan lebih banyak "sihir" daripada di <code>SpinWait</code> (yang digunakan di sana).  Sekarang dia tahu bagaimana cara menghitung mereka yang menunggu, untuk membuat mereka sedikit tidur, dan banyak lagi.  dll. Secara umum, melakukan segala yang mungkin untuk mengoptimalkan.  Tetapi kita harus ingat bahwa ini masih merupakan siklus aktif yang sama yang memakan sumber daya prosesor dan membuat utas yang dapat menyebabkan kelaparan jika salah satu filsuf menjadi prioritas di atas yang lain, tetapi tidak memiliki garpu emas (masalah Prioritas Pembalikan).  Oleh karena itu, kami menggunakannya hanya untuk perubahan yang sangat singkat dalam memori bersama, tanpa panggilan pihak ketiga, kunci bersarang, dll. Kejutan. </p><br><p><img src="https://habrastorage.org/webt/ev/wu/kk/evwukkxrcgfutky1cihoe5dns0e.png" alt="Spinlock"></p><br><p>  Gambar untuk <code>SpinLock</code> .  Aliran terus-menerus "berjuang" untuk garpu emas.  Kegagalan terjadi - pada gambar, area yang dipilih.  Inti tidak sepenuhnya digunakan: hanya sekitar 2/3 dari empat utas ini. </p><br><p>  Solusi lain di sini adalah dengan menggunakan hanya <code>Interlocked.CompareExchange</code> dengan harapan aktif yang sama, seperti yang ditunjukkan dalam kode di atas (dalam filsuf yang kelaparan), tetapi ini, sebagaimana telah disebutkan, secara teoritis dapat menyebabkan pemblokiran. </p><br><p>  Tentang <code>Interlocked</code> perlu dikatakan bahwa tidak hanya <code>CompareExchange</code> , tetapi juga metode lain untuk membaca atom DAN menulis.  Dan dengan mengulangi perubahan seandainya thread lain berhasil membuat perubahannya (baca 1, baca 2, tulis 2, tulis 1 buruk), itu dapat digunakan untuk perubahan kompleks dari satu nilai (pola Apa Saja yang Terkunci). </p><br><h3 id="resheniya-v-rezhime-yadra">  Solusi mode kernel </h3><br><p>  Untuk menghindari kehilangan sumber daya dalam satu lingkaran, mari kita lihat bagaimana Anda dapat memblokir aliran.  Dengan kata lain, melanjutkan contoh kita, kita akan melihat bagaimana pelayan menempatkan filsuf untuk tidur dan membangunkannya hanya jika diperlukan.  Pertama, mari kita lihat bagaimana melakukan ini melalui mode kernel dari sistem operasi.  Semua struktur di sana sering kali ternyata lebih lambat daripada yang ada di ruang pengguna.  Beberapa kali lebih lambat, misalnya <code>AutoResetEvent</code> bisa 53 kali lebih lambat daripada <code>SpinLock</code> [Richter].  Tetapi dengan bantuan mereka, Anda dapat menyinkronkan proses di seluruh sistem, dikelola atau tidak. </p><br><p>  Konstruksi utama di sini adalah semafor yang diusulkan oleh Dijkstroy lebih dari setengah abad yang lalu.  Semafor adalah, secara sederhana, bilangan bulat positif yang dikendalikan oleh suatu sistem, dan dua operasi di atasnya - bertambah dan berkurang.  Jika reduksi tidak bekerja, nol, maka utas panggilan diblokir.  Ketika jumlah bertambah oleh beberapa thread / proses aktif lainnya, maka utas dilewati, dan semaphore kembali berkurang dengan jumlah yang dilewati.  Anda bisa membayangkan kereta dalam kemacetan dengan semaphore.  .NET menawarkan beberapa desain dengan fitur serupa: <code>AutoResetEvent</code> , <code>ManualResetEvent</code> , <code>Mutex</code> dan <code>Semaphore</code> itu sendiri.  Kami akan menggunakan <code>AutoResetEvent</code> , ini adalah yang paling sederhana dari konstruksi ini: hanya dua nilai 0 dan 1 (false, true).  Metode <code>WaitOne()</code> memblokir utas panggilan jika nilainya 0, dan jika 1, lalu turun menjadi 0 dan melompatinya.  Dan metode <code>Set()</code> meningkat menjadi 1 dan melompati satu menunggu, yang lagi-lagi turun menjadi 0. Bertindak seperti pintu putar di kereta bawah tanah. </p><br><p>  Kami akan mempersulit solusi dan akan menggunakan kunci untuk setiap filsuf, dan tidak untuk semua orang sekaligus.  Yaitu  sekarang ada beberapa filsuf sekaligus, dan bukan satu.  Tapi sekali lagi kami memblokir akses ke meja untuk mengambil garpu dengan benar, menghindari balapan (kondisi balapan). </p><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">//    . // : new AutoResetEvent(true)  . private AutoResetEvent[] philosopherEvents; //     /   . private AutoResetEvent tableEvent = new AutoResetEvent(true); //  . public void Run(int i, CancellationToken token) { while (true) { TakeForks(i); //  . // .    . eatenFood[i] = (eatenFood[i] + 1) % (int.MaxValue - 1); PutForks(i); //     . Think(i); if (token.IsCancellationRequested) break; } } //    . void TakeForks(int i) { bool hasForks = false; while (!hasForks) //    (  ). { //    ,    . tableEvent.WaitOne(); if (forks[Left(i)] == 0 &amp;&amp; forks[Right(i)] == 0) forks[Left(i)] = forks[Right(i)] = i + 1; hasForks = forks[Left(i)] == i + 1 &amp;&amp; forks[Right(i)] == i + 1; if (hasForks) //   ,   .  Set //  ,   true. philosopherEvents[i].Set(); //   .    tableEvent  false. tableEvent.Set(); //   true,  ,   false,    Set  . philosopherEvents[i].WaitOne(); } } //     . void PutForks(int i) { tableEvent.WaitOne(); //    . forks[Left(i)] = 0; //  ,     ,  AutoResetEvent  true. philosopherEvents[LeftPhilosopher(i)].Set(); forks[Right(i)] = 0; philosopherEvents[RightPhilosopher(i)].Set(); tableEvent.Set(); }</span></span></code> </pre> <br><p>  Untuk memahami apa yang terjadi di sini, perhatikan kasus ketika filsuf gagal mengambil percabangan, maka tindakannya akan seperti itu.  Dia sedang menunggu akses ke meja.  Setelah menerimanya, ia mencoba mengambil garpu.  Itu tidak berhasil.  Dia memberi akses ke meja (saling pengecualian).  Dan itu melewati "turnstile" ( <code>AutoResetEvent</code> ) (pada awalnya mereka terbuka).  Memasuki siklus lagi, karena  dia tidak punya garpu.  Mencoba untuk mengambilnya dan berhenti di pintu putar nya.  Beberapa tetangga yang lebih beruntung di kanan atau di kiri, setelah selesai makan, membuka kunci filsuf kita, "membuka pintu putar-nya."  Filsuf kita melewatinya (dan dia menutup di belakangnya) untuk kedua kalinya.  Mencoba untuk ketiga kalinya untuk mengambil garpu.  Semoga beruntung  Dan melewati pintu putar untuk makan. </p><br><p>  Ketika ada kesalahan acak dalam kode tersebut (selalu ada), misalnya, tetangga tidak ditentukan dengan benar atau objek <code>AutoResetEvent</code> sama <code>AutoResetEvent</code> untuk semua orang ( <code>Enumerable.Repeat</code> ), maka filsuf akan menunggu pengembang, karena  menemukan kesalahan dalam kode semacam itu adalah tugas yang agak sulit.  Masalah lain dengan solusi ini adalah tidak menjamin bahwa filsuf mana pun tidak akan kelaparan. </p><br><h3 id="gibridnye-resheniya">  Solusi hibrida </h3><br><p>  Kami memeriksa dua pendekatan untuk sinkronisasi ketika kami tetap dalam mode pengguna dan berputar dalam satu lingkaran dan ketika kami memblokir utas melalui kernel.  Metode pertama baik untuk kunci pendek, yang kedua untuk yang panjang.  Seringkali, pertama-tama Anda perlu secara singkat mengharapkan variabel untuk berubah dalam loop, dan kemudian memblokir utas ketika menunggu lama.  Pendekatan ini diimplementasikan dalam apa yang disebut  desain hibrida.  Di sini ada konstruksi yang sama untuk mode kernel, tetapi sekarang dengan loop dalam mode pengguna: <code>SemaphorSlim</code> , <code>ManualResetEventSlim</code> , dll. Konstruksi yang paling populer di sini adalah <code>Monitor</code> , karena  C # memiliki sintaks <code>lock</code> terkenal.  <code>Monitor</code> adalah semaphore yang sama dengan nilai maksimum 1 (mutex), tetapi dengan dukungan untuk menunggu dalam satu lingkaran, rekursi, pola Variabel Kondisi (tentangnya di bawah), dll. Mari kita lihat solusi dengan itu. </p><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">//      ,   . private readonly object _lock = new object(); //   . private DateTime?[] _waitTimes = new DateTime?[philosophersAmount]; public void Run(int i, CancellationToken token) { while (true) { TakeForks(i); eatenFood[i] = (eatenFood[i] + 1) % (int.MaxValue - 1); PutForks(i); Think(i); if (token.IsCancellationRequested) break; } } //     Condition Variable . bool CanIEat(int i) { //   : if (forks[Left(i)] != 0 &amp;&amp; forks[Right(i)] != 0) return false; var now = DateTime.Now; // ,     ,  . foreach(var p in new int[] {LeftPhilosopher(i), RightPhilosopher(i)}) if (_waitTimes[p] != null &amp;&amp; now - _waitTimes[p] &gt; now - _waitTimes[i]) return false; return true; } void TakeForks(int i) { //   .   : lock(_lock) {..}. //   try,     . bool lockTaken = false; Monitor.Enter(_lock, ref lockTaken); try { _waitTimes[i] = DateTime.Now; // Condition Variable .  ,    //  .    -  Pulse / PulseAll. while (!CanIEat(i)) Monitor.Wait(_lock); forks[Left(i)] = i + 1; forks[Right(i)] = i + 1; _waitTimes[i] = null; } finally { if (lockTaken) Monitor.Exit(_lock); } } void PutForks(int i) { //   : lock (_lock) {..}. bool lockTaken = false; Monitor.Enter(_lock, ref lockTaken); try { forks[Left(i)] = 0; forks[Right(i)] = 0; //        Monitor.Exit. Monitor.PulseAll(_lock); } finally { if (lockTaken) Monitor.Exit(_lock); } }</span></span></code> </pre> <br><p>  Di sini kita lagi mengunci seluruh meja untuk akses ke garpu, tetapi sekarang kita membuka semua aliran sekaligus, dan bukan tetangga ketika seseorang selesai makan.  Yaitu  pertama, seseorang makan dan memblokir tetangga, dan ketika seseorang ini selesai, tetapi ingin makan lagi segera, dia masuk ke kunci dan membangunkan tetangganya, karena  waktu tunggunya lebih pendek. </p><br><p>  Jadi kita menghindari kebuntuan dan kelaparan beberapa filsuf.  Kami menggunakan loop untuk menunggu sebentar dan memblokir aliran untuk yang lama.  Membuka kunci sekaligus bekerja lebih lambat daripada jika hanya tetangga yang dibuka, seperti dalam solusi dengan <code>AutoResetEvent</code> , tetapi perbedaannya tidak boleh besar, karena  utas harus tetap dalam mode pengguna terlebih dahulu. </p><br><p>  <code>lock</code> sintaksis memiliki kejutan yang tidak menyenangkan.  Mereka merekomendasikan menggunakan <code>Monitor</code> secara langsung [Richter] [Eric Lippert].  Salah satunya adalah <code>lock</code> selalu keluar dari <code>Monitor</code> , bahkan jika ada pengecualian, dan utas lainnya dapat mengubah status memori bersama.  Dalam kasus seperti itu, seringkali lebih baik pergi ke jalan buntu atau menyelesaikan program dengan aman.  Kejutan lainnya adalah Monitor menggunakan blok sinkronisasi ( <code>SyncBlock</code> ), yang ada di semua objek.  Oleh karena itu, jika Anda memilih objek yang salah, Anda dapat dengan mudah mendapatkan kebuntuan (misalnya, jika Anda membuat kunci pada string yang diinternir).  Kami selalu menggunakan objek tersembunyi untuk ini. </p><br><p>  Pola Variabel Kondisi memungkinkan Anda untuk lebih menerapkan ekspektasi kondisi yang kompleks.  Dalam. NET, itu tidak lengkap, menurut pendapat saya, karena  dalam teori harus ada beberapa antrian pada beberapa variabel (seperti pada Thread Posix), dan tidak pada satu kunci.  Maka orang dapat membuat mereka untuk semua filsuf.  Tetapi bahkan dalam formulir ini, ini memungkinkan Anda untuk mengurangi kode. </p><br><h3 id="mnogo-filosofov-ili-async--await">  Banyak filsuf atau <code>async</code> / <code>await</code> </h3><br><p>  Oke, sekarang kita dapat secara efektif memblokir utas.  Tetapi, bagaimana jika kita mendapatkan banyak filsuf?  100?  10000?  Misalnya, kami menerima 100.000 permintaan ke server web.  Membuat aliran untuk setiap permintaan akan menjadi overhead, karena  begitu banyak utas tidak akan dieksekusi secara paralel.  Hanya sebanyak core logis yang akan dieksekusi (saya punya 4).  Dan semua orang hanya akan mengambil sumber daya.  Salah satu solusi untuk masalah ini adalah pola async / await.  Idenya adalah bahwa suatu fungsi tidak menahan aliran, jika Anda perlu menunggu untuk melanjutkan.  Dan ketika dia melakukan ini sesuatu terjadi, dia melanjutkan eksekusinya (tetapi tidak harus di utas yang sama!).  Dalam kasus kami, kami akan menunggu colokannya. </p><br><p>  <code>SemaphoreSlim</code> memiliki metode <code>WaitAsync()</code> untuk ini.  Berikut ini adalah implementasi menggunakan pola ini. </p><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">//   ,  . -  : Task.Run(() =&gt; Run(i, cancelTokenSource.Token)); //  . //   async --      . public async Task Run(int i, CancellationToken token) { while (true) { // await --   - . await TakeForks(i); //  await,     . eatenFood[i] = (eatenFood[i] + 1) % (int.MaxValue - 1); //      . await PutForks(i); Think(i); if (token.IsCancellationRequested) break; } } async Task TakeForks(int i) { bool hasForks = false; while (!hasForks) { //    : await _tableSemaphore.WaitAsync(); if (forks[Left(i)] == 0 &amp;&amp; forks[Right(i)] == 0) { forks[Left(i)] = i+1; forks[Right(i)] = i+1; hasForks = true; } _tableSemaphore.Release(); //  ,    : if (!hasForks) await _philosopherSemaphores[i].WaitAsync(); } } //       . async Task PutForks(int i) { await _tableSemaphore.WaitAsync(); forks[Left(i)] = 0; // "" ,   "". _philosopherSemaphores[LeftPhilosopher(i)].Release(); forks[Right(i)] = 0; _philosopherSemaphores[RightPhilosopher(i)].Release(); _tableSemaphore.Release(); }</span></span></code> </pre> <br><p>   <code>async</code> / <code>await</code>     ,      <code>Task</code> .      ,     ,     Task.  ,  ,  .   ,    ,   ,   ,   .         .      <code>async</code> / <code>await</code> . </p><br><p> .  100     4  , 8 .    Monitor   4  ,     .    4    2.    async / await   100,       6.8 . ,      6         .    Monitor    . </p><br><h2 id="zaklyuchenie">  Kesimpulan </h2><br><p>      , .NET    .  , , ,   .     .    ,     ,   , TPL Dataflow, Reactive , Software Transaction   . </p><br><h2 id="istochniki">  Sumber </h2><br><ul><li>  : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Concurrency Visualizer</a> </li><li> MSDN: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Threading</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Asynchronous programming patterns</a>  . . </li><li> [] ‚Äî CLR via C#, Jeffrey Richter </li><li> [ ] ‚Äî <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="> lock</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="> </a> </li><li>  ‚Äî "  ", .  </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id447898/">https://habr.com/ru/post/id447898/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id447886/index.html">Analisis log Nginx menggunakan Amazon Athena dan Cube.js</a></li>
<li><a href="../id447890/index.html">Terima kasih Tuhan aku bukan manajer</a></li>
<li><a href="../id447892/index.html">Dua kontes PHDays baru: bypass IDS dan peretasan pabrik</a></li>
<li><a href="../id447894/index.html">MODX Digest # 3 (25 Maret - 8 April 2019)</a></li>
<li><a href="../id447896/index.html">Gambar dari sketsa kasar: bagaimana tepatnya jaringan saraf NVIDIA GauGAN bekerja</a></li>
<li><a href="../id447900/index.html">Tutup kontak ADL</a></li>
<li><a href="../id447902/index.html">GitHub sepenuhnya "menghapus" repositori utilitas kunci dan seluruh akun pembuat</a></li>
<li><a href="../id447904/index.html">Pakar Teknologi Positif mengidentifikasi upaya untuk mengeksploitasi kerentanan kritis dalam Confluence secara massal</a></li>
<li><a href="../id447906/index.html">Inovasi aktual: apa yang diharapkan dari pasar pusat data pada tahun 2019?</a></li>
<li><a href="../id447908/index.html">Dua cara untuk mengumpulkan hadiah untuk beriklan di game mobile, atau robot harus bekerja</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>