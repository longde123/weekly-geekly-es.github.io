<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>☝🏾 💉 🥌 Erstellen des Vuex Undo / Redo Plugins für VueJS 👩🏾‍💼 🤚🏻 😫</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Die Zentralisierung des Status Ihrer Anwendung im Vuex Store bietet viele Vorteile. Ein Vorteil ist, dass alle Transaktionen erfasst werden. Auf diese...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Erstellen des Vuex Undo / Redo Plugins für VueJS</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/433986/"><p><img src="https://habrastorage.org/getpro/habr/post_images/1f1/ebf/e6f/1f1ebfe6f5ebbea55a11f845d21f5a3e.jpg" alt="Bild"></p><br><p>  Die Zentralisierung des Status Ihrer Anwendung im Vuex Store bietet viele Vorteile.  Ein Vorteil ist, dass alle Transaktionen erfasst werden.  Auf diese Weise können Sie praktische Funktionen wie das <em>Laufzeit-Debugging verwenden</em> , mit denen Sie zwischen vorherigen Status wechseln können, um Aufgaben von der Ausführung zu trennen. </p><br><p>  In diesem Artikel werde ich zeigen, wie Sie die Funktion "Rückgängig / Wiederherstellen" mit Vuex für Rollback / Return erstellen. Dies funktioniert ähnlich wie das Debuggen während des Debuggens.  Diese Funktion kann in einer Vielzahl von Szenarien verwendet werden, von komplexen Formen bis zu browserbasierten Spielen. </p><br><p>  Sie können den <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">fertigen Code</a> hier <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">auf Github</a> überprüfen und die Demo in diesem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Codepen ausprobieren</a> .  Ich habe auch ein Plugin als NPM-Modul namens <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">vuex-undo-redo erstellt,</a> wenn Sie es in einem Projekt verwenden möchten. </p><a name="habracut"></a><br><blockquote>  Hinweis: Dieser Artikel wurde ursprünglich hier <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">im Entwicklerblog von</a> Vue.js 2017/11/13 veröffentlicht. </blockquote><br><h2 id="nastroyka-plagina">  Plugin Konfiguration </h2><br><p>  Um diese Funktion wiederverwendbar zu machen, erstellen wir sie als Vue-Plugin.  Für diese Funktion müssen wir der Vue-Instanz einige Methoden und Daten hinzufügen, damit wir das Plugin als Mixin strukturieren können. </p><br><pre><code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">module</span></span>.exports = { install(Vue) { Vue.mixin({ <span class="hljs-comment"><span class="hljs-comment">// Code goes here }); } };</span></span></code> </pre> <br><p>  Um es in einem Projekt zu verwenden, können wir einfach das Plugin importieren und verbinden: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> VuexUndoRedo <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'./plugin.js'</span></span>; Vue.use(VuexUndoRedo);</code> </pre> <br><h2 id="ideya">  Idee </h2><br><p>  Die Funktion funktioniert, indem die letzte Mutation zurückgesetzt wird, wenn der Benutzer sie abbrechen möchte, und sie dann erneut angewendet wird, wenn er sie wiederholen möchte.  Wie machen wir das? </p><br><h2 id="podhod--1">  Ansatz Nr. 1 </h2><br><p>  Der erste mögliche Ansatz besteht darin, nach jeder Mutation „Snapshots“ des Status des Repositorys zu erstellen und den Snapshot in einem Array zu platzieren.  Zum Rückgängigmachen / Wiederherstellen können wir den richtigen Snapshot abrufen und durch den Speicherstatus ersetzen. </p><br><p>  Das Problem bei diesem Ansatz ist, dass der Status des Repositorys ein JavaScript-Objekt ist.  Wenn Sie ein JavaScript-Objekt in ein Array einfügen, geben Sie einfach einen Verweis auf das Objekt ein.  Eine naive Implementierung wie die folgende funktioniert nicht: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> state = { ... }; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> snapshot = []; <span class="hljs-comment"><span class="hljs-comment">// Push the first state snapshot.push(state); // Push the second state state.val = "new val"; snapshot.push(state); // Both snapshots are simply a reference to state console.log(snapshot[0] === snapshot[1]); // true</span></span></code> </pre> <br><p>  Für den Snapshot-Ansatz müssen Sie vor dem Push zunächst einen Statusklon erstellen.  Da der Status von Vue durch automatisches Hinzufügen der Funktionen get und set reaktiv wird, funktioniert das Klonen nicht besonders gut. </p><br><h3 id="podhod--2">  Ansatz Nr. 2 </h3><br><p>  Ein anderer möglicher Ansatz besteht darin, jede feste Mutation zu registrieren.  Zum Abbrechen setzen wir den Speicher auf den Ausgangszustand zurück und führen die Mutationen erneut aus.  alle bis auf den letzten.  Rückerstattung ähnliches Konzept. </p><br><p>  Angesichts der Prinzipien von Flux sollte ein Neustart von Mutationen aus demselben Ausgangszustand den Zustand idealerweise wiederherstellen.  Da dies ein sauberer Ansatz als der erste ist, fahren wir fort. </p><br><h2 id="registraciya-mutaciy">  Registrierung von Mutationen </h2><br><p>  Vuex bietet eine API-Methode zum Abonnieren von Mutationen an, mit der wir sie registrieren können.  Wir werden dies auf den <code>created</code> Hook setzen.  Im Rückruf fügen wir die Mutation einfach in ein Array ein, das später erneut ausgeführt werden kann. </p><br><pre> <code class="javascript hljs">Vue.mixin({ data() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { <span class="hljs-attr"><span class="hljs-attr">done</span></span>: [] } }, created() { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.$store.subscribe(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">mutation</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.done.push(mutation); } } });</code> </pre> <br><h2 id="metod-otkata">  Rollback-Methode </h2><br><p>  Um die Mutation abzubrechen, löschen wir das Repository und führen dann alle Mutationen außer der letzten erneut aus.  So funktioniert der Code: </p><br><ol><li>  Verwenden Sie die <code>pop</code> Array-Methode, um die letzte Mutation zu entfernen. </li><li>  Löschen Sie den Speicherstatus mit der speziellen Mutation <code>EMPTY_STATE</code> ( <code>EMPTY_STATE</code> unten). </li><li>  Wiederholen Sie jede verbleibende Mutation und korrigieren Sie sie erneut im neuen Speicher.  Bitte beachten Sie, dass die Abonnementmethode während dieses Vorgangs noch aktiv ist, dh jede Mutation wird erneut hinzugefügt.  Löschen Sie es sofort mit <code>pop</code> . </li></ol><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> EMPTY_STATE = <span class="hljs-string"><span class="hljs-string">'emptyState'</span></span>; Vue.mixin({ data() { ... }, created() { ... }, methods() { undo() { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.done.pop(); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.$store.commit(EMPTY_STATE); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.done.forEach(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">mutation</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.$store.commit(<span class="hljs-string"><span class="hljs-string">`</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${mutation.type}</span></span></span><span class="hljs-string">`</span></span>, mutation.payload); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.done.pop(); }); } } });</code> </pre> <br><h3 id="ochistka-store">  Reinigungsgeschäft </h3><br><p>  Wann immer dieses Plugin verwendet wird, muss der Entwickler eine Mutation in seinem Repository namens emptyState implementieren.  Die Herausforderung besteht darin, den Speicher wieder in seinen ursprünglichen Zustand zu versetzen, damit er von Grund auf wiederhergestellt werden kann. </p><br><p>  Der Entwickler muss dies selbst tun, da das von uns erstellte Plugin keinen Zugriff auf den Store hat, sondern nur auf die Vue-Instanz.  Hier ist eine Beispielimplementierung: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vuex.Store({ <span class="hljs-attr"><span class="hljs-attr">state</span></span>: { <span class="hljs-attr"><span class="hljs-attr">myVal</span></span>: <span class="hljs-literal"><span class="hljs-literal">null</span></span> }, <span class="hljs-attr"><span class="hljs-attr">mutations</span></span>: { emptyState() { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.replaceState({ <span class="hljs-attr"><span class="hljs-attr">myval</span></span>: <span class="hljs-literal"><span class="hljs-literal">null</span></span> }); } } });</code> </pre> <br><p>  Zurück zu unserem Plugin sollte die <code>emptyState</code> Mutation nicht zu unserer Liste " <code>emptyState</code> hinzugefügt werden, da wir dies während des Rollback-Prozesses nicht erneut <code>emptyState</code> möchten.  Verhindern Sie dies mit der folgenden Logik: </p><br><pre> <code class="javascript hljs">Vue.mixin({ data() { ... }, created() { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.$store.subscribe(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">mutation</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (mutation.type !== EMPTY_STATE) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.done.push(mutation); } }); }, methods() { ... } });</code> </pre> <br><h2 id="metod-vozvrata">  Rückgabemethode </h2><br><p>  Erstellen wir eine neue Dateneigenschaft, die <code>undone</code> wird und ein Array ist.  Wenn wir die letzte Mutation entfernen, die während des Rollback-Prozesses ausgeführt wurde, fügen wir sie in dieses Array ein: </p><br><pre> <code class="javascript hljs">Vue.mixin({ data() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { <span class="hljs-attr"><span class="hljs-attr">done</span></span>: [], <span class="hljs-attr"><span class="hljs-attr">undone</span></span>: [] } }, <span class="hljs-attr"><span class="hljs-attr">methods</span></span>: { undo() { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.undone.push(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.done.pop()); ... } } });</code> </pre> <br><p>  Jetzt können wir eine <code>redo</code> erstellen, die einfach die zuletzt hinzugefügte <code>undone</code> Mutation nimmt und sie erneut festschreibt. </p><br><pre> <code class="javascript hljs">methods: { undo() { ... }, redo() { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> commit = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.undone.pop(); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.$store.commit(<span class="hljs-string"><span class="hljs-string">`</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${commit.type}</span></span></span><span class="hljs-string">`</span></span>, commit.payload); } }</code> </pre> <br><h3 id="vozvrat-dalshe-ne-vozmozhen">  Keine Rückgabe möglich </h3><br><p>  Wenn der Benutzer die Stornierung ein- oder mehrmals initiiert und dann ein neues Commit ausführt, wird der Inhalt von <code>undone</code> ungültig.  In diesem Fall müssen wir das <code>undone</code> leeren. </p><br><p>  Beim Hinzufügen eines Commits können wir neue Commits aus unserem Abonnement-Rückruf ermitteln.  Die Logik ist jedoch schwierig, da der Rückruf keine offensichtliche Möglichkeit bietet, herauszufinden, was ein neues Commit ist und was Rückgängig / Wiederherstellen ist. </p><br><p>  Am einfachsten ist es, das Flag newMutation zu setzen.  Es ist standardmäßig true, aber Rollback- und Return-Methoden setzen es vorübergehend auf false.  Wenn die Mutation auf true gesetzt ist, löscht der <code>subscribe</code> Rückruf das <code>undone</code> Array. </p><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">module</span></span>.exports = { install(Vue) { Vue.mixin({ data() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { <span class="hljs-attr"><span class="hljs-attr">done</span></span>: [], <span class="hljs-attr"><span class="hljs-attr">undone</span></span>: [], <span class="hljs-attr"><span class="hljs-attr">newMutation</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span> }; }, created() { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.$store.subscribe(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">mutation</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (mutation.type !== EMPTY_STATE) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.done.push(mutation); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.newMutation) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.undone = []; } }); }, <span class="hljs-attr"><span class="hljs-attr">methods</span></span>: { redo() { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> commit = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.undone.pop(); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.newMutation = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.$store.commit(<span class="hljs-string"><span class="hljs-string">`</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${commit.type}</span></span></span><span class="hljs-string">`</span></span>, commit.payload); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.newMutation = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }, undo() { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.undone.push(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.done.pop()); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.newMutation = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.$store.commit(EMPTY_STATE); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.done.forEach(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">mutation</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.$store.commit(<span class="hljs-string"><span class="hljs-string">`</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${mutation.type}</span></span></span><span class="hljs-string">`</span></span>, mutation.payload); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.done.pop(); }); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.newMutation = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } } }); }, }</code> </pre> <br><p>  Die Hauptfunktionalität ist jetzt abgeschlossen!  Fügen Sie das Plugin Ihrem eigenen Projekt oder <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">meiner Demo hinzu</a> , um es zu testen. </p><br><h3 id="publichnyy-api">  Öffentliche API </h3><br><p>  In meiner Demo werden Sie feststellen, dass die Schaltflächen Abbrechen und Zurück deaktiviert sind, wenn ihre Funktionalität derzeit nicht möglich ist.  Wenn beispielsweise noch keine Commits vorhanden waren, können Sie diese offensichtlich nicht abbrechen oder wiederholen.  Ein Entwickler, der dieses Plugin verwendet, möchte möglicherweise ähnliche Funktionen implementieren. </p><br><p>  Um dies zu aktivieren, kann das Plugin zwei berechnete Eigenschaften, <code>canUndo</code> und <code>canRedo</code> als Teil der öffentlichen API bereitstellen.  Dies ist trivial zu implementieren: </p><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">module</span></span>.exports = { install(Vue) { Vue.mixin({ data() { ... }, created() { ... }, <span class="hljs-attr"><span class="hljs-attr">methods</span></span>: { ... }, <span class="hljs-attr"><span class="hljs-attr">computed</span></span>: {}, <span class="hljs-attr"><span class="hljs-attr">computed</span></span>: { canRedo() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.undone.length; }, canUndo() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.done.length; } }, }); }, }</code> </pre> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de433986/">https://habr.com/ru/post/de433986/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de433972/index.html">HolyJS 2018 Moskau mit den Augen des Teilnehmers</a></li>
<li><a href="../de433974/index.html">Chatbot bekommt Gehör oder Amateurleiden</a></li>
<li><a href="../de433980/index.html">China startete 2018 mehr Raketen in die Umlaufbahn als jedes andere Land</a></li>
<li><a href="../de433982/index.html">Künstliche Intelligenz denkt als eine Gruppe von Menschen, die Anlass zur Sorge gibt</a></li>
<li><a href="../de433984/index.html">Russische Studenten erwarteten den internationalen KI-Wettbewerb von Microsoft</a></li>
<li><a href="../de433992/index.html">Out-of-Process-Debugger für C ++ in Visual Studio 2019</a></li>
<li><a href="../de433994/index.html">Automatisierungswerkzeug für die Versionskontrolle</a></li>
<li><a href="../de433996/index.html">Überlegungen zum Manifest für Entwickler intelligenter Systeme</a></li>
<li><a href="../de433998/index.html">Investitionsauswahl: 4 größte Börsengänge von Einhorn-Technologieunternehmen im Jahr 2019</a></li>
<li><a href="../de434000/index.html">Die wichtigsten Datenlecks im Jahr 2018. Zweiter Teil (Juli-Dezember)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>