<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🎟️ 🚈 🚎 Struktur data di Jawa. Metode kelas pembantu yang berguna ⏪ 😘 🧚🏿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hai habr! 

 Saya seorang Insinyur Perangkat Lunak di EPAM. Selama lebih dari 8 tahun saya telah bekerja dengan kode warisan yang ditulis di Jawa (men...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Struktur data di Jawa. Metode kelas pembantu yang berguna</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/epam_systems/blog/476098/">  Hai habr! <br><br>  Saya seorang Insinyur Perangkat Lunak di EPAM.  Selama lebih dari 8 tahun saya telah bekerja dengan kode warisan yang ditulis di Jawa (mengantisipasi komentar, saya perhatikan bahwa pemahaman dan toleransi untuk warisan dimulai jauh sebelum EPAM, sebagai kesimpulan Anda akan menemukan jawabannya mengapa).  Seringkali dalam pekerjaan saya menemukan kesalahan berulang yang sama.  Ini mendorong saya untuk menulis catatan, dan saya ingin memulai dengan struktur data dan kelas pembantu <em>Koleksi</em> dan <em>Array</em> .  Untuk beberapa alasan, beberapa pengembang mengabaikan penggunaannya, dan sia-sia <br><br>  Pengembang Java sering harus berurusan dengan berbagai struktur data.  Ini bisa berupa array, semua jenis koleksi atau implementasi <em>Peta</em> .  Tampaknya segala sesuatu dengan mereka jelas dan dapat dimengerti, tetapi ada beberapa hal kecil yang mudah tersandung. <br><br>  Catatan ini mungkin berguna untuk pemula yang belum tahu nuansa ini, dan pengembang berpengalaman yang mungkin melupakan sebagian dari ini. <br><br><img src="https://habrastorage.org/webt/5h/9_/k5/5h9_k5vuwkzxsydyntq7eb8yrf4.jpeg" alt="gambar"><br>  <sup>Foto oleh ammiel jr di Unsplash</sup> <br><br><h1>  CAT </h1><br>  Saya ingin segera memesan bahwa materi ini relevan untuk Java 8. Jelas bahwa beberapa hal telah dilakukan dengan lebih baik di Java 9+, tetapi sebagian besar proyek besar paling sering menggunakan versi Java 8 (dan kadang-kadang Java 6). <br><a name="habracut"></a><br><h2>  Apa cara terbaik untuk mendapatkan koleksi berbasis array? </h2><br>  Saya sarankan mulai dengan pembentukan koleksi berdasarkan array. <br><br>  Paling sering, metode ini terjadi: <br><br><pre><code class="java hljs">Integer[] someArray = {<span class="hljs-number"><span class="hljs-number">9</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>, <span class="hljs-number"><span class="hljs-number">11</span></span>, <span class="hljs-number"><span class="hljs-number">12</span></span>}; List&lt;Integer&gt; list = Arrays.asList(someArray);</code> </pre> <br>  Ini memang berhasil, tetapi apakah semuanya baik-baik saja dengan itu?  Dan adakah solusi alternatif? <br><br>  Dua minus dari pendekatan ini muncul sekaligus: <br><br><ul><li>  Pertama, metode <em>Arrays.asList</em> mengembalikan <em>Daftar</em> .  Tetapi bagaimana jika kita membutuhkan implementasi <em>Collection yang lain?</em>  <em>Arrays.asList</em> tidak akan mengizinkan ini, tetapi suatu alternatif akan dipertimbangkan sedikit lebih jauh. </li><li>  Kedua, <em>Daftar</em> diperoleh dengan memanggil <em>Arrays.asList</em> tidak mendukung pengubahan ukuran.  Saya pikir banyak yang datang dengan pengecualian yang timbul dari bekerja dengan daftar seperti itu. </li></ul><br>  Di antarmuka <em>Koleksi</em> , Anda dapat menemukan alternatif metode <em>Arrays.asList</em> - metode <em>Collections.addAll</em> .  Berikut cara menggunakannya: <br><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">//      (List, Set, ...) Collection&lt;Integer&gt; collection = ...; Integer[] someArray = {9, 10, 8, 7}; Collections.addAll(collection, someArray);</span></span></code> </pre><br>  Atau sederhananya: <br><br><pre> <code class="java hljs">Collections.addAll(collection, <span class="hljs-number"><span class="hljs-number">11</span></span>, <span class="hljs-number"><span class="hljs-number">12</span></span>, <span class="hljs-number"><span class="hljs-number">13</span></span>, <span class="hljs-number"><span class="hljs-number">14</span></span>);</code> </pre><br>  Metode <em>Collections.addAll</em> menerima objek <em>Koleksi</em> dan array di input.  Alih-alih array, Anda juga bisa menentukan elemen yang dipisahkan oleh koma. <br><br>  Apa manfaat dari <em>Collections.addAll</em> over <em>Arrays.asList</em> ? <br><br><ul><li>  Untuk mulai dengan, ketika membuat koleksi berdasarkan array <em>Collections.addAll</em> , ia bekerja jauh lebih cepat daripada metode <em>addAll</em> koleksi dengan input dari <em>Array.asList</em> .  Ini dapat ditemukan di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">JavaDoc dari</a> metode ini: <br><blockquote>  Perilaku metode kenyamanan ini identik dengan perilaku c.addAll (Arrays.asList (elemen)), tetapi metode ini cenderung berjalan secara signifikan lebih cepat di sebagian besar </blockquote></li><li>  Selain itu, <em>Collections.addAll</em> bekerja tidak hanya dengan <em>Daftar</em> , tetapi dengan koleksi lainnya. </li><li>  Dan saat menggunakan metode ini, tidak ada masalah mengubah ukuran. </li></ul><br><h2>  Apa cara termudah untuk mencetak array, array multidimensi, atau koleksi? </h2><br>  Mari kita beralih ke masalah mendapatkan representasi cetak dari array dan koleksi. <br><br>  Jika kita hanya membuat <em>System.out.println (someArray)</em> , kita mendapatkan sesuatu seperti ini: <br>  <em>[Ljava.lang.Integer; @ 6d06d69c.</em> <br>  Hasil serupa diharapkan ketika menggunakan metode <em>toString ()</em> pada array. <br>  Untuk menampilkan array, metode <em>Arrays.toString (...)</em> datang untuk <em>menyelamatkan</em> . <br><br><pre> <code class="java hljs">Integer[] someArray = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Integer[]{<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>}; System.out.println(Arrays.toString(someArray));</code> </pre><br>  Output untuk baris ini adalah: <br><br><pre> [1, 2, 3] 
</pre><br>  Jika kita berbicara tentang array multidimensi, maka Anda dapat menggunakan metode: <em>Arrays.deeptoString</em> . <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[][] a = { {<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>}, {<span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>} }; System.out.println(Arrays.deepToString(a));</code> </pre><br>  Output dari cuplikan ini adalah: <br><br><pre>  [[1, 2, 3], [4, 5, 6]] </pre><br><br>  Jadi, tidak perlu menyortir array melalui loop apa pun secara manual untuk menampilkan elemen-elemennya, cukup menggunakan metode ini. <br><br>  Sedangkan untuk koleksi atau implementasi <em>Peta</em> , tidak ada masalah.  Semua struktur data kecuali array biasanya adalah output. <br><br>  Misalkan ada contoh: <br><br><pre> <code class="java hljs">Collection&lt;Integer&gt; someCollection = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HashSet&lt;&gt;(); someCollection.add(<span class="hljs-number"><span class="hljs-number">1</span></span>); someCollection.add(<span class="hljs-number"><span class="hljs-number">2</span></span>); System.out.println(someCollection); Map&lt;Integer, String&gt; someMap = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HashMap&lt;&gt;(); someMap.put(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">"Some 1"</span></span>); someMap.put(<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-string"><span class="hljs-string">"Some 2"</span></span>); System.out.println(someMap);</code> </pre><br>  Perhatikan dalam output di bawah ini bahwa set dan <em>Peta</em> ditampilkan dalam format yang mudah dibaca: <br><br><pre> [1, 2] 
 {1 = Beberapa 1, 2 = Beberapa 2} 
</pre><br><br><h2>  Seberapa mudah membandingkan array satu sama lain? </h2><br>  Ada beberapa situasi ketika Anda perlu membandingkan array.  Ada metode di kelas <em>Array</em> yang memungkinkan perbandingan seperti itu.  Metode <em>Arrays.equals</em> membandingkan jumlah elemen dan memeriksa kesetaraan elemen yang sesuai. <br><br>  Katakanlah kita memiliki kelas <em>Elemen</em> dengan satu bidang dan sederajat tertentu <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Element</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> String name; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Element</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String name)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.name = name; } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">equals</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Object o)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span> == o) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (o == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> || getClass() != o.getClass()) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; Element element = (Element) o; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Objects.equals(name, element.name); } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">hashCode</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Objects.hash(name); } }</code> </pre><br>  Tentukan tiga array: <br><br><pre> <code class="java hljs">Element[] firstElementArray = { <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Element(<span class="hljs-string"><span class="hljs-string">"a"</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Element(<span class="hljs-string"><span class="hljs-string">"b"</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Element(<span class="hljs-string"><span class="hljs-string">"c"</span></span>) }; Element[] secondElementArray = {<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Element(<span class="hljs-string"><span class="hljs-string">"c"</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Element(<span class="hljs-string"><span class="hljs-string">"b"</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Element(<span class="hljs-string"><span class="hljs-string">"a"</span></span>) }; Element[] thirdElementArray = { <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Element(<span class="hljs-string"><span class="hljs-string">"a"</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Element(<span class="hljs-string"><span class="hljs-string">"b"</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Element(<span class="hljs-string"><span class="hljs-string">"c"</span></span>) };</code> </pre><br>  Perhatikan bahwa array pertama dan ketiga memiliki elemen dalam urutan yang sama. <br>  Sekarang Anda dapat melakukan perbandingan menggunakan metode <em>Arrays.equals</em> . <br><br><pre> <code class="java hljs">System.out.println(<span class="hljs-string"><span class="hljs-string">"first equals to second? "</span></span> + Arrays.equals(firstElementArray, secondElementArray)); System.out.println(<span class="hljs-string"><span class="hljs-string">"second equals to third? "</span></span> + Arrays.equals(secondElementArray, thirdElementArray)); System.out.println(<span class="hljs-string"><span class="hljs-string">"first equals to third? "</span></span> + Arrays.equals(firstElementArray, thirdElementArray));</code> </pre><br>  Hasilnya adalah sebagai berikut: <br><br><pre> pertama sama dengan kedua?  salah 
 kedua sama dengan ketiga?  salah 
 pertama sama dengan ketiga?  benar 
</pre><br><br><h2>  Bagaimana cara menyalin array secara efisien? </h2><br>  Seringkali Anda dapat melihat dalam kode menyalin array secara manual menggunakan loop.  Namun, ada metode <em>System.arraycopy</em> yang akan menyalin lebih cepat. <br><br>  Saya sarankan lihat contoh sederhana seperti ini: <br><br><pre> <code class="java hljs">Element[] elements = { <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Element(<span class="hljs-string"><span class="hljs-string">"a"</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Element(<span class="hljs-string"><span class="hljs-string">"b"</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Element(<span class="hljs-string"><span class="hljs-string">"c"</span></span>) }; Element[] copyOfElements = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Element[elements.length]; System.arraycopy(elements, <span class="hljs-number"><span class="hljs-number">0</span></span>, copyOfElements, <span class="hljs-number"><span class="hljs-number">0</span></span>, elements.length); System.out.println(Arrays.toString(copyOfElements));</code> </pre><br>  Kami memiliki berbagai elemen.  Kami membuat array kosong dengan panjang yang sama dan menyalin semua elemen dari yang pertama ke yang kedua.  Hasilnya, kami memperoleh kesimpulan berikut: <br><br><pre> [Elemen {name = 'a'}, Elemen {name = 'b'}, Elemen {name = 'c'}] 
</pre><br><br><h2>  Bagaimana cara mengurutkan array atau koleksi dengan cara yang berbeda? </h2><br>  Array dapat diurutkan menggunakan metode <em>Arrays.sort (someArray)</em> .  Jika Anda ingin mengurutkan array dalam urutan terbalik, Anda dapat meneruskan <em>Collections.reverseOrder ()</em> sebagai parameter kedua ke input ke metode ini. <br><br>  Misalnya, ada array yang kami sortir langsung dan kemudian dalam urutan terbalik: <br><br><pre> <code class="java hljs">String[] someArray = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> String[]{<span class="hljs-string"><span class="hljs-string">"b"</span></span>, <span class="hljs-string"><span class="hljs-string">"a"</span></span>, <span class="hljs-string"><span class="hljs-string">"c"</span></span>}; Arrays.sort(someArray); System.out.println(Arrays.toString(someArray)); Arrays.sort(someArray, Collections.reverseOrder()); System.out.println(Arrays.toString(someArray));</code> </pre><br>  Kesimpulannya adalah sebagai berikut: <br><br><pre> [a, b, c] 
 [c, b, a] 
</pre><br><br>  Selain pengurutan langsung dan mundur, kadang-kadang terjadi bahwa Anda perlu mengurutkan array string terlepas dari kasus.  Ini mudah dilakukan dengan meneruskan <em>String.CASE_INSENSITIVE_ORDER</em> sebagai parameter kedua ke <em>Arrays.sort</em> . <br><br>  Sayangnya, <em>Collections.sort</em> hanya memungkinkan implementasi <em>Daftar</em> untuk diurutkan. <br><br><h2>  Algoritma apa yang memilah Java? </h2><br>  Hal terakhir yang disebutkan ketika berbicara tentang pengurutan di Jawa adalah bahwa di Jawa, "pengurutan sederhana" digunakan untuk jenis yang paling sederhana, dan "stabil gabungan" digunakan untuk objek.  Jadi Anda tidak boleh menghabiskan sumber daya untuk mengembangkan implementasi Anda sendiri dari metode penyortiran sampai profiler menunjukkan bahwa itu perlu. <br><br><h2>  Bagaimana jika kita memiliki array dan metode menerima Iterable? </h2><br>  Saya mengusulkan sekarang untuk beralih ke pertanyaan seperti melewati array ke metode yang membutuhkan <em>Iterable</em> .  Biarkan saya mengingatkan Anda bahwa <em>Iterable</em> adalah antarmuka yang berisi metode <em>iterator ()</em> , yang harus dikembalikan oleh Iterator. <br><br>  Jika ada metode yang menerima Iterable di input, maka array tidak dapat ditransfer begitu saja.  Meskipun Anda bisa mengulangi lebih dari satu array dalam <em>for for</em> loop, itu bukan <em>Iterable</em> . <br><br><pre> <code class="java hljs">String[] someArray = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> String[]{<span class="hljs-string"><span class="hljs-string">"a"</span></span>, <span class="hljs-string"><span class="hljs-string">"b"</span></span>, <span class="hljs-string"><span class="hljs-string">"c"</span></span>}; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (String currentString : someArray) { ... }</code> </pre><br>  Dalam contoh ini, semuanya baik-baik saja.  Tetapi jika ada metode: <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">someIteration</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Iterable&lt;String&gt; iterable)</span></span></span><span class="hljs-function"> </span></span>{ ... }</code> </pre><br>  Baris itu tidak akan dikompilasi: <br><br><pre> <code class="java hljs">someIteration(someArray);</code> </pre><br>  Satu-satunya jalan keluar dalam situasi ini adalah dengan mengubah array ke koleksi dan sudah mengumpankannya ke metode seperti itu. <br><br><h2>  Secara singkat tentang beberapa metode Koleksi yang berguna </h2><br><div class="scrollable-table"><table><tbody><tr><th>  Metode </th><th>  Komentar </th></tr><tr><td>  <em>maks (Koleksi)</em> dan <em>maks (Koleksi, Pembanding)</em> <br>  <em>min (Koleksi)</em> dan <em>min (Koleksi, Pembanding)</em> <br></td><td>  Harap dicatat bahwa Anda dapat menerapkan input <em>Pembanding</em> <br></td></tr><tr><td>  <em>indexOfSubList (Daftar, Daftar)</em> <br></td><td>  Menemukan indeks kemunculan pertama dari satu daftar (argumen kedua) di daftar lain (argumen pertama) <br></td></tr><tr><td>  <em>lastIndexOfSubList (Daftar, Daftar)</em> <br></td><td>  Menemukan indeks kemunculan terakhir dari satu daftar (argumen kedua) di daftar lainnya (argumen pertama) <br></td></tr><tr><td>  <em>membalikkan (Daftar)</em> <br></td><td>  Susun ulang item dalam urutan terbalik <br></td></tr></tbody></table></div><br><h2>  Apa yang layak dibaca? </h2><br>  Ini hanya sebagian kecil dari alat yang dapat membuat hidup lebih mudah bagi pengembang ketika bekerja dengan struktur data.  Banyak poin menarik dalam karya koleksi itu sendiri dan alat yang mudah untuk bekerja dengannya dapat ditemukan dalam buku Bruce Eckel “Java Philosophy” (edisi penuh ke-4).  Namun, Anda harus berhati-hati, karena menghadapi situasi yang tidak lagi dapat dimainkan di Java 7, Java 8 dan lebih tinggi.  Meskipun Java 6 dijelaskan dalam buku ini, materinya tetap relevan hingga saat ini. <br><br>  Tentu saja, “Filosofi Jawa” tidak boleh dibatasi.  Membaca salah satu buku ini tidak akan merugikan pengembang Java mana pun: <br><br><ul><li>  "Jawa.  Pemrograman yang Efektif, ”Joshua Bloch. </li><li>  “Refactoring.  Meningkatkan Desain Kode yang Ada, ”Martin Fowler. </li><li>  “Kode bersih.  Penciptaan, analisis, dan refactoring ”, Robert Martin. </li><li>  Spring 5 untuk Profesional, Julian Kozmin dan lainnya. </li><li>  “Pengembangan Java Berbasis Tes”, Viktor Farcic, Alex Garcia (belum dirilis dalam bahasa Rusia). </li></ul><br><h2>  Apa hasilnya? </h2><br>  Jika Anda menemukan ide-ide menarik yang dapat melengkapi apa yang ditulis dalam artikel ini, bagikan dalam komentar. <br><br>  Saya juga ingin mengucapkan semoga sukses dan kesabaran kepada mereka yang bekerja dengan kode lama yang lama.  Sebagian besar proyek besar adalah warisan.  Dan signifikansi mereka bagi pelanggan sulit ditaksir terlalu tinggi.  Dan perasaan kemenangan dari menghilangkan bug, yang membutuhkan waktu lebih dari seminggu untuk menemukan alasannya, tidak kalah dengan perasaan pada akhir penerapan fitur baru. <br><br>  Terima kasih atas perhatian anda  Saya akan senang jika ada yang disajikan akan bermanfaat. <br>  Semua sukses! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id476098/">https://habr.com/ru/post/id476098/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id476088/index.html">Konferensi BLACK HAT USA. Kaya atau mati: hasilkan uang di Internet menggunakan Black Hat. Bagian 1</a></li>
<li><a href="../id476090/index.html">Pergi untuk mengamankan 2FA di blockchain</a></li>
<li><a href="../id476092/index.html">Tentang arahan “Photonics”, “Programming and IT” dan “Information and Cybersecurity” dari Olimpiade “I am a Professional”</a></li>
<li><a href="../id476094/index.html">Kembalinya Zaman Kerajaan: Segala Tentang Zaman Kerajaan IV</a></li>
<li><a href="../id476096/index.html">Persediaan dari I hingga Z. Kami mempertimbangkan aset TI</a></li>
<li><a href="../id476100/index.html">Arsitektur sistem komputer 1 bagian. Gerbang logika</a></li>
<li><a href="../id476102/index.html">Ketik aman bekerja dengan array PHP</a></li>
<li><a href="../id476104/index.html">Jangan gunakan MTProxy gratis dan jenis proxy gratis lainnya ...</a></li>
<li><a href="../id476106/index.html">"Cryptosystems Protocols": Diffie - Hellman, El-Gamal, MTI / A (0), STS</a></li>
<li><a href="../id476108/index.html">Otak yang bisa berubah</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>