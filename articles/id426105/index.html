<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üêé üò¨ üëÅ‚Äçüó® Tangkapan saya dalam seminggu üïµüèª ‚úåüèΩ üë®‚Äçüî¨</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Semakin banyak pengembang mengerjakan aplikasi dalam tim dan semakin baik tahu kodenya, semakin sering ia terlibat dalam proofreading karya rekan-reka...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Tangkapan saya dalam seminggu</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/426105/"><p>  Semakin banyak pengembang mengerjakan aplikasi dalam tim dan semakin baik tahu kodenya, semakin sering ia terlibat dalam proofreading karya rekan-rekannya.  Hari ini saya akan menunjukkan apa yang bisa ditangkap dalam satu minggu dalam kode yang ditulis oleh pengembang yang sangat baik.  Di bawah potongan adalah koleksi artefak yang jelas dari kreativitas kita (dan sedikit dari pikiranku). </p><a name="habracut"></a><br><h3 id="komparatory">  Pembanding </h3><br><p>  Ada kode: </p><br><pre><code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Getter</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Dto</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Long id; } <span class="hljs-comment"><span class="hljs-comment">// another class List&lt;Long&gt; readSortedIds(List&lt;Dto&gt; list) { List&lt;Long&gt; ids = list.stream().map(Dto::getId).collect(Collectors.toList()); ids.sort(new Comparator&lt;Long&gt;() { public int compare(Long o1, Long o2) { if (o1 &lt; o2) return -1; if (o1 &gt; o2) return 1; return 0; } }); return ids; }</span></span></code> </pre> <br><p>  Seseorang mencatat bahwa Anda dapat mengurutkan aliran secara langsung, tetapi saya ingin menarik perhatian Anda ke pembanding.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Dokumentasi</a> untuk metode <code>Comparator::compare</code> mengatakan dalam bahasa Inggris dengan warna putih: </p><br><blockquote>  Membandingkan dua argumennya untuk pesanan.  Mengembalikan bilangan bulat negatif, nol, atau bilangan bulat positif karena argumen pertama kurang dari, sama dengan, atau lebih besar dari yang kedua. </blockquote><p>  Perilaku inilah yang diterapkan dalam kode kita.  Apa yang salah  Faktanya adalah bahwa pencipta Jawa sangat jauh-jauh hari menyarankan bahwa banyak yang akan membutuhkan pembanding dan membuatnya untuk kita.  Kita dapat menggunakannya dengan menyederhanakan kode kami: </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-function">List&lt;Long&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">readSortedIds</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(List&lt;Dto&gt; list)</span></span></span><span class="hljs-function"> </span></span>{ List&lt;Long&gt; ids = list.stream().map(Dto::getId).collect(Collectors.toList()); ids.sort(Comparator.naturalOrder()); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ids; }</code> </pre> <br><p>  Demikian pula kode ini </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-function">List&lt;Dto&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sortDtosById</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(List&lt;Dto&gt; list)</span></span></span><span class="hljs-function"> </span></span>{ list.sort(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Comparator&lt;Dto&gt;() { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">compare</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Dto o1, Dto o2)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (o1.getId() &lt; o2.getId()) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> -<span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (o1.getId() &gt; o2.getId()) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; } }); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> list; }</code> </pre> <br><p>  dengan sentakan pergelangan tangan berubah menjadi </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-function">List&lt;Dto&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sortDtosById</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(List&lt;Dto&gt; list)</span></span></span><span class="hljs-function"> </span></span>{ list.sort(Comparator.comparing(Dto::getId)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> list; }</code> </pre> <br><p>  Ngomong-ngomong, di "Ideas" versi baru, Anda dapat melakukan seperti ini: </p><br><div class="spoiler">  <b class="spoiler_title">Sihir</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/b_/om/ki/b_omkixybpa-jvxblirsruyvglo.gif"></p></div></div><br><h3 id="zloupotreblenie-optional-ami">  Pelecehan opsional </h3><br><p>  Mungkin kita masing-masing melihat sesuatu seperti ini: </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-function">List&lt;UserEntity&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getUsersForGroup</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Long groupId)</span></span></span><span class="hljs-function"> </span></span>{ Optional&lt;Long&gt; optional = Optional.ofNullable(groupId); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (optional.isPresent()) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> userRepository.findUsersByGroup(optional.get()); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Collections.emptyList(); }</code> </pre> <br><p>  Seringkali <code>Optional</code> digunakan untuk memeriksa ada / tidaknya nilai, meskipun itu tidak dibuat untuk ini.  Mengikat penyalahgunaan dan menulis lebih mudah: </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-function">List&lt;UserEntity&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getUsersForGroup</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Long groupId)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (groupId == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Collections.emptyList(); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> userRepository.findUsersByGroup(groupId); }</code> </pre> <br><p>  Ingat bahwa <code>Optional</code> bukan tentang argumen metode atau bidang, tetapi tentang nilai pengembalian.  Itu sebabnya dirancang tanpa dukungan serialisasi. </p><br><h3 id="void-metody-menyayuschie-sostoyanie-argumenta">  membatalkan metode yang mengubah keadaan argumen </h3><br><p>  Bayangkan metode seperti ini: </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Component</span></span> <span class="hljs-meta"><span class="hljs-meta">@RequiredArgsConstructor</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ContractUpdater</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> ContractRepository repository; <span class="hljs-meta"><span class="hljs-meta">@Transactional</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">updateContractById</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Long contractId, Dto contractDto)</span></span></span><span class="hljs-function"> </span></span>{ Contract contract = repository.findOne(contractId); contract.setValue(contractDto.getValue()); repository.save(contract); } }</code> </pre> <br><p>  Tentunya Anda telah melihat dan menulis sesuatu yang serupa berkali-kali.  Di sini saya tidak suka bahwa metode mengubah keadaan entitas, tetapi tidak mengembalikannya.  Bagaimana cara kerja metode kerangka kerja yang serupa?  Misalnya, <code>org.springframework.data.jpa.repository.JpaRepository::save</code> dan <code>javax.persistence.EntityManager::merge</code> mengembalikan nilai.  Misalkan setelah memperbarui kontrak kita harus mendapatkannya di luar metode <code>update</code> .  Ternyata sesuatu seperti ini: </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Transactional</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">anotherMethod</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Long contractId, Dto contractDto)</span></span></span><span class="hljs-function"> </span></span>{ updateService.updateContractById(contractId, contractDto); Contract contract = repositoroty.findOne(contractId); doSmth(contract); }</code> </pre> <br><p>  Ya, kami dapat mengirimkan entitas secara langsung ke metode <code>UpdateService::updateContract</code> dengan mengubah tanda tangannya, tetapi lebih baik melakukannya seperti ini: </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Component</span></span> <span class="hljs-meta"><span class="hljs-meta">@RequiredArgsConstructor</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ContractUpdater</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> ContractRepository repository; <span class="hljs-meta"><span class="hljs-meta">@Transactional</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Contract </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">updateContractById</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Long contractId, Dto contractDto)</span></span></span><span class="hljs-function"> </span></span>{ Contract contract = repository.findOne(contractId); contract.setValue(contractDto.getValue()); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> repository.save(contract); } } <span class="hljs-comment"><span class="hljs-comment">// @Transactional public void anotherMethod(Long contractId, Dto contractDto) { Contract contract = updateService.updateContractById(contractId, contractDto); doSmth(contract); }</span></span></code> </pre> <br><p>  Di satu sisi, ini membantu menyederhanakan kode, di sisi lain, ini membantu dengan pengujian.  Secara umum, pengujian metode <code>void</code> adalah tugas yang sangat suram, yang akan saya tunjukkan menggunakan contoh yang sama: </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@RunWith</span></span>(MockitoJUnitRunner.class) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ContractUpdaterTest</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Mock</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> ContractRepository repository; <span class="hljs-meta"><span class="hljs-meta">@InjectMocks</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> ContractUpdater updater; <span class="hljs-meta"><span class="hljs-meta">@Test</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">updateContractById</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ Dto dto = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Dto(); dto.setValue(<span class="hljs-string"><span class="hljs-string">"- "</span></span>); Long contractId = <span class="hljs-number"><span class="hljs-number">1L</span></span>; when(repository.findOne(contractId)).thenReturn(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Contract()); updater.updateContractById(contractId, contractDto); <span class="hljs-comment"><span class="hljs-comment">//void // ,       dto? -  : ArgumentCaptor&lt;Contract&gt; captor = ArgumentCaptor.forClass(Contract.class); verify(repository).save(captor.capture()); Contract updated = captor.getValue(); assertEquals(dto.getValue(), updated.getValue()); } }</span></span></code> </pre> <br><p>  Tapi semuanya bisa dibuat lebih sederhana jika metode mengembalikan nilai: </p><br><div class="spoiler">  <b class="spoiler_title">Pastikan</b> <div class="spoiler_text"><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@RunWith</span></span>(MockitoJUnitRunner.class) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ContractUpdaterTest</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Mock</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> ContractRepository repository; <span class="hljs-meta"><span class="hljs-meta">@InjectMocks</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> ContractUpdater updater; <span class="hljs-meta"><span class="hljs-meta">@Test</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">updateContractById</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ Dto dto = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Dto(); dto.setValue(<span class="hljs-string"><span class="hljs-string">"- "</span></span>); Long contractId = <span class="hljs-number"><span class="hljs-number">1L</span></span>; when(repository.findOne(contractId)).thenReturn(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Contract()); Contract updated = updater.updateContractById(contractId, contractDto); assertEquals(dto.getValue(), updated.getValue()); } }</code> </pre> </div></div><br><p>  Dalam sekali tegukan, tidak hanya panggilan ke <code>ContractRepository::save</code> diperiksa, tetapi juga kebenaran dari nilai yang disimpan. </p><br><h3 id="velosipedostroenie">  Konstruksi sepeda </h3><br><p>  Untuk bersenang-senang, buka proyek Anda dan cari ini: </p><br><pre> <code class="java hljs">lastIndexOf(<span class="hljs-string"><span class="hljs-string">'.'</span></span>)</code> </pre> <br><p>  Dengan probabilitas tinggi, seluruh ekspresi terlihat seperti ini: </p><br><pre> <code class="java hljs">String fileExtension = fileName.subString(fileName.lastIndexOf(<span class="hljs-string"><span class="hljs-string">'.'</span></span>));</code> </pre> <br><p>  Itulah yang tidak dapat diperingatkan oleh penganalisa statis, ini tentang sepeda yang baru ditemukan.  Tuan-tuan, jika Anda memecahkan masalah tertentu yang terkait dengan nama file / ekstensi atau jalan untuk itu, seperti membaca / menulis / menyalin, maka dalam 9 kasus dari 10 tugas telah diselesaikan sebelum Anda.  Karena itu, ikat dengan konstruksi sepeda dan ambil solusi yang siap pakai (dan terbukti): </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> org.apache.commons.io.FilenameUtils; <span class="hljs-comment"><span class="hljs-comment">//... String fileExtension = FilenameUtils.getExtension(fileName);</span></span></code> </pre> <br><p>  Dalam hal ini, Anda menghemat waktu yang akan dihabiskan untuk memeriksa kesesuaian sepeda, dan juga mendapatkan fungsionalitas yang lebih maju (lihat dokumentasi <code>FilenameUtils::getExtension</code> ). </p><br><p>  Atau di sini adalah kode yang menyalin isi dari satu file ke file lain: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { FileChannel sc = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FileInputStream(src).getChannel(); FileChannel dc = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FileOutputStream(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> File(targetName)).getChannel(); sc.transferTo(<span class="hljs-number"><span class="hljs-number">0</span></span>, sc.size(), dc); dc.close(); sc.close(); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (IOException ex) { log.error(<span class="hljs-string"><span class="hljs-string">""</span></span>, ex); }</code> </pre> <br><p>  Keadaan apa yang bisa mencegah kita?  Ribuan dari mereka: </p><br><ul><li>  tujuan mungkin folder, bukan file sama sekali </li><li>  sumbernya mungkin folder </li><li>  sumber dan tujuan mungkin file yang sama </li><li>  tujuan tidak dapat dibuat </li><li>  dll dan seterusnya. </li></ul><br><p>  Yang menyedihkan adalah bahwa menggunakan self-recording tentang semua itu sudah kita pelajari selama menyalin. <br>  Jika kita melakukannya dengan bijak </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> org.apache.commons.io.FileUtils; <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { FileUtils.copyFile(src, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> File(targetName)); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (IOException ex) { log.error(<span class="hljs-string"><span class="hljs-string">""</span></span>, ex); }</code> </pre> <br><p>  kemudian bagian dari pemeriksaan akan dilakukan sebelum mulai menyalin, dan pengecualian yang mungkin akan lebih informatif (lihat sumber <code>FileUtils::copyFile</code> ). </p><br><h3 id="prenebrezhenie-nullablenotnull">  Mengabaikan @ Nullable / @ NotNull </h3><br><p>  Misalkan kita memiliki entitas: </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Entity</span></span> <span class="hljs-meta"><span class="hljs-meta">@Getter</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UserEntity</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Id</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Long id; <span class="hljs-meta"><span class="hljs-meta">@Column</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> String email; <span class="hljs-meta"><span class="hljs-meta">@Column</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> String petName; }</code> </pre> <br><p>  Dalam kasus kami, kolom <code>email</code> dalam tabel dijelaskan sebagai <code>not null</code> , tidak seperti petName.  Artinya, kita dapat menandai bidang dengan anotasi yang sesuai: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> javax.annotation.Nullable; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> javax.annotation.NotNull; <span class="hljs-comment"><span class="hljs-comment">//... @Column @NotNull private String email; @Column @Nullable private String petName;</span></span></code> </pre> <br><p>  Sekilas, ini seperti petunjuk bagi pengembang, dan memang benar.  Pada saat yang sama, anotasi ini adalah alat yang jauh lebih kuat daripada label biasa. </p><br><p>  Misalnya, lingkungan pengembangan memahaminya, dan jika, setelah menambahkan anotasi, kami mencoba melakukannya seperti ini: </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">checkIfPetBelongsToUser</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(UserEnity user, String lostPetName)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> user.getPetName().equals(lostPetName); }</code> </pre> <br><p>  maka "Ide" akan memperingatkan kita tentang bahaya dengan pesan ini: </p><br><blockquote>  Metode doa 'sama dengan' dapat menghasilkan 'NullPointerException' </blockquote><p>  Dalam kode </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">hasEmail</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(UserEnity user)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">boolean</span></span> hasEmail = user.getEmail() == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> hasEmail; }</code> </pre> <br><p>  akan ada peringatan lain: </p><br><blockquote>  Syarat 'user.getEmail () == null' selalu 'salah' </blockquote><p>  Ini membantu sensor bawaan menemukan kemungkinan kesalahan dan membantu kami lebih memahami eksekusi kode.  Untuk tujuan yang sama, penjelasan berguna untuk menempatkan metode yang mengembalikan nilai dan argumennya. </p><br><p>  Jika argumen saya tampaknya tidak dapat disimpulkan, maka lihatlah kode sumber dari setiap proyek serius, "Musim Semi" yang sama - mereka digantung dengan anotasi seperti pohon Natal.  Dan ini bukan kemauan, tetapi kebutuhan yang parah. </p><br><p>  Satu-satunya kelemahan, menurut saya, adalah kebutuhan untuk terus memelihara anotasi dalam keadaan modern.  Meskipun, jika Anda melihatnya, ini merupakan berkah, karena kembali ke kode berulang-ulang kami memahaminya dengan lebih baik dan lebih baik. </p><br><h3 id="nevnimatelnost">  Kecerobohan </h3><br><p>  Tidak ada kesalahan dalam kode ini, tetapi ada kelebihan: </p><br><pre> <code class="java hljs">Collection&lt;Dto&gt; dtos = getDtos(); Stream.of(<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>,<span class="hljs-number"><span class="hljs-number">4</span></span>,<span class="hljs-number"><span class="hljs-number">5</span></span>) .filter(id -&gt; { List&lt;Integer&gt; ids = dtos.stream().map(Dto::getId).collect(toList()); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ids.contains(id); }) .collect(toList());</code> </pre> <br><p>  Tidak jelas mengapa membuat daftar kunci baru yang dengannya pencarian dilakukan, jika itu tidak berubah ketika melewati aliran.  Bagus hanya ada 5 elemen, dan jika ada 100500?  Dan jika metode <code>getDtos</code> mengembalikan 100500 objek (dalam daftar!), Lalu seperti apa kinerja kode ini?  Tidak ada, jadi lebih baik seperti ini: </p><br><pre> <code class="java hljs">Collection&lt;Dto&gt; dtos = getDtos(); Set&lt;Integer&gt; ids = dtos.stream().map(Dto::getId).collect(toSet()); Stream.of(<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>,<span class="hljs-number"><span class="hljs-number">4</span></span>,<span class="hljs-number"><span class="hljs-number">5</span></span>) .filter(ids::contains) .collect(toList());</code> </pre> <br><p>  Juga di sini: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> &lt;T, Q extends Query&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setParams</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( Map&lt;String, Collection&lt;T&gt;&gt; paramMap, Set&lt;String&gt; notReplacedParams, Q query)</span></span></span><span class="hljs-function"> </span></span>{ notReplacedParams.stream() .filter(param -&gt; paramMap.keySet().contains(param)) .forEach(param -&gt; query.setParameter(param, paramMap.get(param))); }</code> </pre> <br><p>  Jelas, nilai yang dikembalikan oleh ekspresi <code>inParameterMap.keySet()</code> tidak berubah, sehingga dapat dipindahkan ke variabel: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> &lt;T, Q extends Query&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setParams</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( Map&lt;String, Collection&lt;T&gt;&gt; paramMap, Set&lt;String&gt; notReplacedParams, Q query)</span></span></span><span class="hljs-function"> </span></span>{ Set&lt;String&gt; params = paramMap.keySet(); notReplacedParams.stream() .filter(params::contains) .forEach(param -&gt; query.setParameter(param, paramMap.get(param))); }</code> </pre> <br><p>  Ngomong-ngomong, bagian tersebut dapat dihitung menggunakan cek 'Alokasi objek dalam satu lingkaran'. </p><br><h3 id="kogda-staticheskiy-analiz-bessilen">  Ketika analisis statis tidak berdaya </h3><br><p>  Jawa kedelapan sudah lama mati, tapi kita semua suka aliran.  Beberapa dari kita sangat mencintai mereka sehingga kita menggunakannya di mana-mana: </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Optional&lt;EmailAdresses&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getUserEmails</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ Stream&lt;UserEntity&gt; users = getUsers().stream(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (users.count() == <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Optional.empty(); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> users.findAny(); }</code> </pre> <br><p>  Aliran, seperti yang Anda ketahui, baru sebelum penghentian dipanggil, jadi mengakses kembali variabel <code>users</code> dalam kode kami akan menghasilkan <code>IllegalStateException</code> . </p><br><p>  Analis statis belum tahu bagaimana melaporkan kesalahan tersebut, oleh karena itu, tanggung jawab untuk menangkap tepat waktu berada di tangan pengulas. </p><br><p>  Tampak bagi saya bahwa menggunakan variabel tipe <code>Stream</code> , serta melewatkannya sebagai argumen dan kembali dari metode, seperti berjalan di ladang ranjau.  Mungkin beruntung, mungkin tidak.  Karenanya aturan sederhana: setiap tampilan <code>Stream&lt;T&gt;</code> dalam kode harus diperiksa (tetapi dengan cara yang baik segera dipotong). </p><br><h3 id="prostye-tipy">  Tipe sederhana </h3><br><p>  Banyak yang yakin bahwa <code>boolean</code> , <code>int</code> , dll., Hanya tentang kinerja.  Ini sebagian benar, tetapi di samping itu, tipe sederhana <code>not null</code> secara default.  Jika bidang bilangan bulat dari entitas mengacu pada kolom yang dinyatakan dalam tabel sebagai <code>not null</code> , maka masuk akal untuk menggunakan <code>int</code> daripada bilangan bulat.  Ini adalah semacam kombo - dan konsumsi memori lebih rendah, dan kode disederhanakan karena pemeriksaan yang tidak perlu untuk <code>null</code> . </p><br><p>  Itu saja.  Ingatlah bahwa semua hal di atas bukanlah kebenaran tertinggi, pikirkan dengan kepala Anda sendiri dan secara bermakna mendekati penerapan saran apa pun. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id426105/">https://habr.com/ru/post/id426105/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id426095/index.html">Buka webinar "Bagaimana tidak menulis dengan Python"</a></li>
<li><a href="../id426097/index.html">Arduino Proyek "Mesin Robot RoboCar4W"</a></li>
<li><a href="../id426099/index.html">Berita Typegram</a></li>
<li><a href="../id426101/index.html">Integritas Data dalam Arsitektur Layanan Mikro - Cara Memastikannya Tanpa Transaksi Terdistribusi dan Konektivitas yang Kuat</a></li>
<li><a href="../id426103/index.html">Webinar "Apakah Anda Membutuhkan Kubernetes" 15 Oktober pukul 19:00</a></li>
<li><a href="../id426111/index.html">Google masih akan meluncurkan layanan pencarian yang disensor di Cina</a></li>
<li><a href="../id426113/index.html">Google News dan Leo Tolstoy: Visualisasi Representasi Vektor Kata-kata dengan t-SNE</a></li>
<li><a href="../id426115/index.html">Praktek menggunakan model aktor di platform backend dari Quake Champions</a></li>
<li><a href="../id426117/index.html">Ombudsman mengusulkan untuk memblokir iklan dengan produk bayi yang berpotensi berbahaya</a></li>
<li><a href="../id426119/index.html">Barang Antik: Cryptonomicon Iron</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>