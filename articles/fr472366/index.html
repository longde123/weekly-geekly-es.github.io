<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë©‚Äçüöí üè´ üêò Nouvel algorithme de recherche de chemin dans Factorio üëäüèª ‚ôéÔ∏è üò†</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="La semaine derni√®re, nous avons parl√© dans notre blog de changements qui permettront aux ennemis (mordeurs) de ne pas se croiser, mais ce n'√©tait pas ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Nouvel algorithme de recherche de chemin dans Factorio</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/472366/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/l5/gr/ba/l5grba862hfltsqu-mpyjafuui0.gif"></div><br>  La semaine derni√®re, nous avons parl√© dans notre blog de changements qui permettront aux ennemis (mordeurs) de ne pas se croiser, mais ce n'√©tait pas la seule mise √† jour li√©e aux mordeurs.  Par co√Øncidence, les mises √† jour de cette semaine comprenaient ce sur quoi nous avons travaill√© au cours des derni√®res semaines - la mise √† jour du syst√®me de recherche d'ennemis. <br><br><h4>  Rechercher un moyen </h4><br>  Lorsqu'une unit√© veut se d√©placer quelque part, elle doit d'abord comprendre comment s'y rendre.  Dans le cas le plus simple, vous pouvez vous rendre directement au but, mais parfois des obstacles surgissent sur le chemin - rochers, arbres, nids ennemis (reproducteurs), unit√©s de joueurs.  Afin d'ouvrir la voie, nous devons indiquer √† la fonction Pathfinder la position actuelle et finale, et Pathfinder nous renverra (peut-√™tre apr√®s de nombreuses mesures) un <i>chemin</i> qui est simplement un ensemble de points de cheminement que l'unit√© doit se d√©placer pour se rendre. destination <br><br>  Pour accomplir son travail, pathfinder utilise un algorithme appel√© A * (prononc√© "A star").  Un exemple simple de trouver un chemin en utilisant A * est montr√© dans la vid√©o: mordeur veut trouver un chemin autour des rochers.  La fonction de recherche de chemin commence √† explorer la carte autour du mordeur (l'√©tude est indiqu√©e par des points blancs).  Au d√©but, elle essaie d'aller directement au but, mais d√®s qu'elle atteint les falaises, elle ¬´se renverse¬ª dans les deux sens, essayant de trouver une position √† partir de laquelle il sera possible de se d√©placer vers le but. <br><a name="habracut"></a><br><iframe width="560" height="315" src="https://www.youtube.com/embed/9URl7E2OYjw" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  <i>L'algorithme de cette vid√©o est ralenti afin que vous puissiez mieux voir comment il fonctionne.</i> <br><br>  Chaque point de l'animation repr√©sente un <i>n≈ìud</i> .  Chaque n≈ìud se souvient de la distance entre le d√©but de la recherche et une estimation de la distance de ce n≈ìud √† la cible (cette estimation est calcul√©e par la <i>fonction heuristique</i> ).  C'est gr√¢ce √† la fonction heuristique que A * fonctionne - il oriente l'algorithme dans la bonne direction. <br><br>  Dans le cas le plus simple, cette fonction calcule simplement la distance en ligne droite du n≈ìud √† la position cible - c'est l'approche que nous avons utilis√©e dans Factorio depuis le tout d√©but du d√©veloppement, et gr√¢ce √† elle, l'algorithme se d√©place initialement en ligne droite.  Cependant, ce n'est pas la seule option - si la fonction heuristique connaissait certains des obstacles, elle pourrait diriger l'algorithme autour d'elle, ce qui acc√©l√©rerait la recherche, car elle n'aurait pas √† examiner les n≈ìuds suppl√©mentaires.  De toute √©vidence, plus l'heuristique est intelligente, plus elle est difficile √† mettre en ≈ìuvre. <br><br>  Une simple fonction heuristique d'estimation de distance en ligne droite est utile pour trouver des chemins sur des distances relativement courtes.  Cela nous convenait dans les versions pr√©c√©dentes de Factorio - presque toujours les mordeurs se d√©pla√ßaient sur de longues distances uniquement parce qu'ils √©taient en col√®re par la pollution, et cela ne se produisait pas tr√®s souvent.  Cependant, nous avons maintenant de l'artillerie.  L'artillerie peut facilement tirer sur un grand nombre de mordeurs de l'autre c√¥t√© d'un grand lac (et les ¬´agrifier¬ª), apr√®s quoi ils essaient d'ouvrir la voie autour du lac.  La vid√©o ci-dessous montre comment le simple algorithme A * que nous avons utilis√© pr√©c√©demment tente de contourner le lac. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/giqW-sdGbhY" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  <i>Cette vid√©o montre la vitesse de l'algorithme en r√©alit√©;</i>  <i>il n'est pas ralenti.</i> <br><br><h4>  R√©duction de bloc </h4><br>  Trouver un chemin est une t√¢che longue et il existe de nombreuses techniques pour l'am√©liorer.  Certaines de ces techniques appartiennent √† la cat√©gorie de la <i>recherche de chemin hi√©rarchique</i> : dans ce cas, la carte est d'abord simplifi√©e, le chemin se trouve sur cette carte simplifi√©e, qui est ensuite utilis√©e pour trouver le vrai chemin.  Je le r√©p√®te, il existe plusieurs impl√©mentations sp√©cifiques d'une telle technique, mais toutes n√©cessitent une simplification de l'espace de recherche. <br><br>  Comment pouvez-vous simplifier le monde de Factorio?  Nos cartes sont g√©n√©r√©es de mani√®re al√©atoire et changent constamment: placer et supprimer des entit√©s (par exemple, des collectionneurs, des murs ou des tourelles) - c'est probablement la m√©canique la plus √©l√©mentaire de tout le jeu.  Nous ne voulons pas recompter l'int√©gralit√© de la carte simplifi√©e chaque fois que nous ajoutons ou supprimons une entit√©.  Dans le m√™me temps, si nous simplifions √† nouveau la carte chaque fois que nous avons besoin de trouver un moyen, nous pouvons facilement perdre tout le gain de performances. <br><br>  L'une des personnes ayant acc√®s au code source du jeu (Allaizn) a eu une id√©e.  que j'ai mis en ≈ìuvre en cons√©quence.  Maintenant, cette id√©e semble √©vidente. <br><br>  Le jeu est bas√© sur des blocs de tuiles 32x32.  Le processus de simplification remplace chaque bloc par un ou plusieurs <i>n≈ìuds abstraits</i> .  Puisque notre objectif est d'am√©liorer la recherche d'un chemin autour des lacs, nous pouvons ignorer toutes les entit√©s et ne consid√©rer que les tuiles: vous ne pouvez pas vous d√©placer sur l'eau, sur la terre, vous le pouvez.  Nous s√©parons chaque bloc en <i>composants</i> s√©par√©s.  Un composant est une zone de tuile dans laquelle une unit√© peut passer d'une tuile √† l'int√©rieur d'un composant √† n'importe quelle autre tuile du m√™me composant.  Dans l'image ci-dessous, le bloc est divis√© en deux composants distincts, rouge et vert.  Chacun de ces composants deviendra un n≈ìud abstrait - en fait, le bloc entier est r√©duit √† deux ¬´points¬ª. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/584/afe/ca9/584afeca9174cd544118ac41ea737c33.png"></div><br>  La pens√©e la plus importante d'Allaizn √©tait que nous n'avons pas besoin de stocker un composant pour chaque tuile de carte - rappelez-vous simplement les composants de tuile le long du p√©rim√®tre de chaque bloc, car nous ne sommes int√©ress√©s que par quels autres composants sont connect√©s (dans les blocs voisins) de chaque composant, et cela d√©pend uniquement des tuiles qui sont √† la fronti√®re m√™me du bloc. <br><br><h4>  Recherche de chemin hi√©rarchique </h4><br>  Nous avons donc compris comment simplifier la carte, mais comment l'utiliser pour trouver des chemins?  Comme je l'ai dit, il existe de nombreuses techniques de recherche de chemin hi√©rarchique.  L'id√©e la plus simple est de trouver le chemin √† l'aide de n≈ìuds abstraits du d√©but √† l'objectif, c'est-√†-dire que le chemin sera une liste des composants des blocs que vous devez visiter.  Ensuite, nous utilisons la s√©rie de bonnes vieilles recherches A * pour comprendre sp√©cifiquement comment passer d'un composant du bloc √† un autre. <br><br>  Le probl√®me ici est que nous avons trop simplifi√© la carte: que se passe-t-il s'il est impossible de passer d'un bloc √† un autre, car certaines entit√©s (par exemple, les roches) bloquent le chemin?  Lors de la r√©duction des blocs, nous ignorons toutes les entit√©s, donc nous savons seulement que les carreaux entre les blocs sont en quelque sorte connect√©s, mais nous ne savons absolument pas s'il est possible de passer de l'un √† l'autre. <br><br>  La solution est d'utiliser la simplification simplement comme une ¬´recommandation¬ª pour une vraie recherche.  En particulier, nous l'utiliserons pour cr√©er une version intelligente de la fonction de recherche heuristique. <br><br>  En cons√©quence, nous avons obtenu le sch√©ma suivant: nous avons deux pathfinder: le <i>pathfinder de base</i> , qui trouve le path r√©el, et le <i>pathfinder abstrait</i> , qui fournit la fonction heuristique au pathfinder de base.  Chaque fois que le pathfinder de base cr√©e un nouveau n≈ìud de base, il appelle un pathfinder abstrait pour obtenir une estimation de la distance jusqu'√† la cible.  Le pathfinder abstrait agit dans l'ordre oppos√© - il commence par la cible de recherche et ouvre la voie au d√©but, passant d'un composant du bloc √† un autre.  Lorsqu'une recherche abstraite trouve le bloc et le composant dans lesquels un nouveau n≈ìud de base est cr√©√©, elle utilise la distance depuis le d√©but de la recherche abstraite (qui, comme je l'ai dit, est la position cible de toute la recherche) pour calculer une estimation de la distance entre le nouveau n≈ìud de base et la cible g√©n√©rale. <br><br>  Cependant, l'ex√©cution de l'ensemble du pathfinder pour chaque n≈ìud individuel sera loin d'√™tre rapide, m√™me si le pathfinder abstrait se d√©place d'un bloc √† l'autre.  Par cons√©quent, √† la place, nous utilisons un sch√©ma appel√© ¬´Reverse Resumable A *¬ª.  ¬´Inverse¬ª signifie que, comme je l'ai dit ci-dessus, est effectu√© du but au d√©but.  ¬´Renouvelable¬ª signifie qu'apr√®s avoir trouv√© un bloc int√©ressant pour le pathfinder de base, nous sauvegardons tous ses n≈ìuds en m√©moire.  La prochaine fois que le pathfinder de base cr√©e un nouveau n≈ìud et a besoin d'une estimation de distance, nous regardons simplement les n≈ìuds abstraits enregistr√©s √† partir de la recherche pr√©c√©dente.  Dans le m√™me temps, il existe une forte probabilit√© que le n≈ìud abstrait requis soit toujours en m√©moire (au final, un n≈ìud abstrait couvre la majeure partie du bloc, et souvent le bloc entier). <br><br>  M√™me si le pathfinder de base cr√©e un n≈ìud situ√© dans un bloc qui n'est couvert par aucun des n≈ìuds abstraits, nous n'avons pas besoin d'effectuer √† nouveau l'int√©gralit√© de la recherche abstraite.  Une caract√©ristique pratique de l'algorithme A * est que m√™me apr√®s avoir ¬´fini de travailler¬ª et trouv√© un chemin, il continue son ex√©cution, explorant les n≈ìuds autour des n≈ìuds d√©j√† √©tudi√©s.  Et c'est exactement ce que nous faisons si nous avons besoin d'une estimation de distance pour un n≈ìud de base situ√© dans un bloc non encore couvert par la recherche abstraite: nous reprenons la recherche abstraite √† partir des n≈ìuds stock√©s en m√©moire jusqu'√† ce qu'elle se d√©veloppe jusqu'au n≈ìud dont nous avons besoin. <br><br>  La vid√©o ci-dessous montre un nouveau syst√®me d'orientation en action.  Les cercles bleus sont des n≈ìuds abstraits;  points blancs - recherche de base.  Le pathfinder dans la vid√©o est beaucoup plus lent que le jeu pour montrer comment cela fonctionne.  √Ä vitesse normale, la recherche enti√®re ne prend que quelques ticks.  Notez que la recherche de base, qui utilise toujours l'ancien algorithme que nous avons toujours utilis√©, ¬´sait¬ª tout simplement magiquement comment se d√©placer autour du lac. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/YHfoatMhvA0" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Puisque le pathfinder abstrait est utilis√© uniquement pour obtenir une estimation heuristique de la distance, la recherche de base peut assez facilement s'√©carter du chemin propos√© par la recherche abstraite.  Cela signifie que m√™me si le sch√©ma de r√©duction de bloc ignore toutes les entit√©s, le pathfinder de base peut les contourner presque sans probl√®me.  En raison de l'ignorance des entit√©s dans le processus de simplification de la carte, nous n'avons pas besoin de la r√©p√©ter √† chaque fois qu'une entit√© est ajout√©e ou supprim√©e, il suffit de couvrir uniquement les tuiles qui ont √©t√© modifi√©es (par exemple, comme dans le cas d'une d√©charge d'ordures), ce qui se produit beaucoup moins souvent que de placer des entit√©s. <br><br>  De plus, cela signifie que nous utilisons essentiellement le m√™me pathfinder que nous utilisons depuis des ann√©es, seule la fonction heuristique a √©t√© mise √† jour.  Autrement dit, ce changement n'affectera pas de nombreux autres syst√®mes et n'affectera que la vitesse de recherche. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr472366/">https://habr.com/ru/post/fr472366/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr472356/index.html">Microsoft vs IBM: changements majeurs dans la prise en charge de Java</a></li>
<li><a href="../fr472358/index.html">30 octobre √† 17h00 webinaire ¬´D√©ployer le cluster Kubernetes en une heure dans le cloud CROC¬ª</a></li>
<li><a href="../fr472360/index.html">Analyse du code d'Orchard CMS pour les bogues</a></li>
<li><a href="../fr472362/index.html">Nous recherchons et analysons les erreurs dans le code CMS Orchard</a></li>
<li><a href="../fr472364/index.html">PostgreSQL et les param√®tres de coh√©rence des enregistrements pour chaque connexion particuli√®re</a></li>
<li><a href="../fr472368/index.html">P√™che vocale: nous analysons les m√©thodes d'attaque et les m√©thodes de protection contre celles-ci</a></li>
<li><a href="../fr472372/index.html">Automatisation Android Guide super simple pour cr√©er votre premier test Espresso</a></li>
<li><a href="../fr472374/index.html">Pourquoi nous avons d√©plac√© des serveurs en Islande</a></li>
<li><a href="../fr472378/index.html">Fiabilit√© du flash: attendue et inattendue. Partie 2. XIV conf√©rence de l'association USENIX. Technologies de stockage de fichiers</a></li>
<li><a href="../fr472380/index.html">MIRO - une plateforme robotique int√©rieure ouverte</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>