<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ’ªğŸ½ â›ªï¸ ğŸ¦“ Kombinasi dari cross-platform dan pendekatan asli dalam pengembangan aplikasi mobile ğŸ›¥ï¸ ğŸ¥€ ğŸ§–ğŸ¼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Untuk merilis aplikasi hanya untuk satu platform seluler tidak relevan dan Anda perlu mengembangkan dua versi sekaligus, untuk iOS dan Android. Dan di...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Kombinasi dari cross-platform dan pendekatan asli dalam pengembangan aplikasi mobile</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/430892/">  Untuk merilis aplikasi hanya untuk satu platform seluler tidak relevan dan Anda perlu mengembangkan dua versi sekaligus, untuk iOS dan Android.  Dan di sini Anda dapat memilih dua cara: bekerja dalam bahasa pemrograman "asli" untuk setiap sistem operasi atau menggunakan kerangka kerja lintas platform. <br><br>  Ketika mengembangkan salah satu proyek di DD Planet, saya mengandalkan opsi terakhir.  Dan dalam artikel ini saya akan berbicara tentang pengalaman mengembangkan aplikasi lintas platform, masalah yang kami temui, dan solusi yang ditemukan. <br><a name="habracut"></a><br><h2>  Tiga pendekatan untuk mengembangkan aplikasi seluler lintas platform </h2><br>  Untuk memulai, pertimbangkan pendekatan apa yang digunakan ketika Anda perlu mendapatkan dua aplikasi sekaligus: untuk iOS dan Android. <br><br>  Yang pertama adalah yang paling mahal, baik dalam waktu maupun sumber daya: mengembangkan aplikasi terpisah untuk setiap platform.  Kompleksitas dari pendekatan ini terletak pada kenyataan bahwa setiap sistem operasi memerlukan pendekatan sendiri: ini dinyatakan baik dalam bahasa di mana pengembangan sedang dilakukan (untuk Android - Java atau Kotlin, untuk iOS - Objective-C atau Swift), dan metode untuk menggambarkan bagian UI aplikasi (file axml dan xib atau storyboard, masing-masing). <br><br>  Fakta ini sendiri membawa kita pada fakta bahwa untuk pendekatan ini perlu membentuk dua tim pengembangan.  Selain itu, Anda harus menduplikasi logika untuk setiap platform: interaksi dengan api dan logika bisnis. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/-j/pl/52/-jpl52-jwex193hykedjtv569to.png" alt="gambar"></div><br>  Tetapi bagaimana jika jumlah API yang digunakan bertambah? <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/pt/kl/zc/ptklzcfkjzn5zxmgqjuyxkhvtyq.png" alt="gambar"></div><br>  Ini menimbulkan pertanyaan: bagaimana cara mengurangi jumlah sumber daya manusia yang dibutuhkan?  Singkirkan kebutuhan untuk menggandakan kode untuk setiap platform.  Ada cukup banyak kerangka kerja dan teknologi yang memecahkan masalah ini. <br><br>  Menggunakan kerangka kerja lintas platform (Xamarin.Forms, misalnya) memungkinkan untuk menulis kode dalam satu bahasa pemrograman dan menjelaskan logika data dan logika UI satu kali, di satu tempat.  Karena itu, kebutuhan untuk menggunakan dua tim pengembangan menghilang.  Dan sebagai hasil kompilasi proyek, kami mendapatkan dua aplikasi asli pada output.  Dan ini adalah pendekatan kedua. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/sc/si/v4/scsiv4dfupwnvimrp1507onobfa.png" alt="gambar"></div><br>  Saya pikir, banyak yang tahu apa itu Xamarin, atau paling tidak pernah mendengarnya, tetapi bagaimana cara kerjanya?  Xamarin didasarkan pada implementasi open-source platform .NET - Mono.  Mono menyertakan kompiler C # sendiri, runtime, serta sejumlah pustaka, termasuk implementasi WinForms dan ASP.Net. <br><br>  Tujuan dari proyek ini adalah untuk memungkinkan program yang ditulis dalam C # dijalankan pada sistem operasi selain sistem Windows - Unix, Mac OS, dan lainnya.  Kerangka kerja Xamarin sendiri, pada dasarnya, adalah pustaka kelas yang memberi para pengembang akses ke SDK platform dan kompiler untuk ini.  Xamarin.Forms, pada gilirannya, memungkinkan Anda untuk tidak hanya menulis untuk kedua platform dalam bahasa yang sama, tetapi juga mendesain layar menggunakan markup XAML, yang akrab bagi mereka yang sudah memiliki pengalaman dengan aplikasi WPF.  Sebagai hasil dari perakitan proyek, kami mendapatkan tampilan yang hampir identik pada semua platform, karena pada tahap kompilasi semua kontrol XF dikonversi ke asli untuk setiap platform. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/w4/ft/fs/w4ftfsahuvg63dn2ugjfugnp6_8.png" alt="gambar"></div><br>  Pengembang dipaksa untuk menulis kode untuk setiap platform hanya jika akses ke fitur platform apa saja diperlukan (misalnya, pemindai sidik jari atau tingkat baterai) atau perlu untuk menyempurnakan perilaku kontrol.  Dalam beberapa kasus, ketika mengembangkan aplikasi, mungkin perlu untuk menulis kode yang tergantung platform, tetapi bahkan dalam kasus ini, tidak ada yang melarang mengambil fungsi platform ke antarmuka dan berinteraksi dengannya dari proyek umum. <br><br>  Satu bahasa pemrograman, kode kecil, dan sebagainya.  Semuanya terdengar indah tapi, Xamarin. Badai bukanlah peluru perak, dan semua keindahannya pecah menjadi batu kenyataan.  Segera setelah situasi muncul ketika kontrol XF bawaan tidak lagi memenuhi persyaratan untuk mereka, struktur layar dan kontrol menjadi semakin rumit.  Untuk memastikan pekerjaan yang nyaman dengan layar dari proyek umum, Anda harus menulis semakin banyak render khusus. <br><br>  Ini akan beralih ke pendekatan ketiga, yang kami gunakan saat mengembangkan aplikasi. <br><br>  Kami telah menemukan bahwa menggunakan Formulir Xamarin dapat menyulitkan pekerjaan, daripada menyederhanakannya.  Oleh karena itu, untuk mengimplementasikan layar yang kompleks secara arsitektur, elemen desain dan kontrol yang secara fundamental berbeda dari yang asli, kompromi dan kemungkinan menggabungkan pendekatan pertama dan kedua ditemukan. <br><br>  Kami memiliki semua tiga proyek yang sama: proyek PCL biasa, tetapi tanpa Formulir Xamarin, dan dua proyek Xamarin Android dan Xamarin iOS.  Masih ada kesempatan untuk menulis semuanya dalam satu bahasa, logika umum antara dua proyek, tetapi tidak ada batasan satu markup XAML.  Komponen UI dikendalikan oleh setiap platform dan menggunakan alat asli, pada Android - AXML asli, pada file iOS - XIB.  Setiap platform memiliki kemampuan untuk mematuhi pedomannya, karena koneksi antara Core dan proyek platform diatur hanya pada tingkat data. <br><br>  Untuk mengatur hubungan seperti itu, Anda dapat menggunakan pola desain MVVM dan implementasinya yang cukup populer untuk Xamarin - MVVMCross.  Penggunaannya memungkinkan Anda menyimpan ViewModel yang umum untuk setiap layar, yang menggambarkan seluruh "logika bisnis" dari pekerjaan, dan percayakan renderingnya ke platform.  Ini juga memungkinkan dua pengembang untuk bekerja dengan layar yang sama (satu dengan logika - yang lain dengan UI) dan tidak saling mengganggu.  Selain penerapan pola, kami mendapatkan sejumlah alat untuk bekerja: penerapan DI dan IoC.  Untuk meningkatkan interaksi dengan platform ke tingkat kode umum, pengembang hanya perlu mendeklarasikan antarmuka dan mengimplementasikannya pada platform.  Untuk hal-hal yang khas, MvvmCross sudah menyediakan satu set plugin sendiri.  Dalam tim, kami menggunakan plugin messenger untuk bertukar pesan antara platform dan kode umum dan plugin untuk bekerja dengan file (memilih gambar dari galeri, dll.). <br><br><h2>  Kami memecahkan masalah desain kompleks dan navigasi multi-level </h2><br>  Seperti yang disebutkan sebelumnya, ketika menggunakan representasi kompleks di layar, kerangka kerja dapat menyulitkan kehidupan daripada membuatnya lebih mudah.  Tetapi apa yang disebut elemen kompleks?  Karena saya terutama terlibat dalam pengembangan iOS, contoh platform ini akan dipertimbangkan.  Misalnya, hal sepele seperti bidang input dapat memiliki beberapa status dan logika yang cukup untuk beralih dan visualisasi. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/an/fw/vf/anfwvfodqmfoui_0u2i6k52g_s4.png" alt="gambar"></div><br>  Selama bekerja dengan input pengguna, kontrol input seperti itu dikembangkan di sini.  Dia dapat menaikkan namanya di atas bidang input, bekerja dengan topeng, mengatur awalan, postfix, memberi tahu ketika CapsLock ditekan, memvalidasi informasi dalam dua mode: larangan input dan output informasi kesalahan.  Logika di dalam kontrol membutuhkan sekitar ~ 1000 baris.  Dan, tampaknya: apa yang bisa rumit dalam desain bidang input? <br><br>  Contoh sederhana dari kontrol kompleks yang kami lihat.  Bagaimana dengan layar? <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/cz/dq/ul/czdqulhcq0x1trskfg4j9szemd0.png" alt="gambar"></div><br>  Untuk mulai dengan, saya akan mengklarifikasi bahwa dalam kebanyakan kasus satu layar aplikasi adalah satu kelas - UIViewController, menjelaskan perilakunya.  Selama pengembangan, penciptaan navigasi multi-level diperlukan.  Konsep aplikasi yang dikembangkan datang ke mengelola real estat Anda dan berinteraksi dengan tetangga dan organisasi kota.  Oleh karena itu, dibangun tiga tingkat navigasi: properti, tingkat presentasi (rumah, kota, wilayah) dan jenis konten.  Semua switching dilakukan dalam satu layar. <br><br>  Ini dilakukan agar pengguna, di mana pun dia berada, memahami jenis konten apa yang dia lihat.  Untuk mengatur navigasi seperti itu, layar utama aplikasi tidak hanya terdiri dari satu pengontrol.  Secara visual, ini dapat dibagi menjadi 3 bagian, tetapi adakah yang bisa menebak berapa banyak pengontrol yang digunakan di sini? <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/tz/od/9h/tzod9hfhgm2r4fcebdz0pbhg06y.png" alt="gambar"></div><br>  Lima belas pengendali utama.  Dan ini hanya untuk konten. <br><br>  Di sini monster seperti itu hidup di layar utama dan terasa cukup baik.  Lima belas pengendali untuk satu layar, tentu saja, sangat banyak.  Ini memengaruhi kecepatan seluruh aplikasi, dan Anda perlu mengoptimalkannya entah bagaimana. <br><br>  Kami menolak inisialisasi sinkron: semua model tampilan diinisialisasi di latar belakang dan hanya jika perlu.  Untuk mengurangi waktu rendering, kami juga meninggalkan file xib untuk layar ini: penentuan posisi absolut dan matematika selalu lebih cepat daripada menghitung dependensi antar elemen. <br><br>  Untuk melacak begitu banyak pengontrol yang perlu Anda pahami: <br><br><ul><li>  Dalam kondisi apa mereka masing-masing; </li><li>  Di mana pengguna; </li><li>  Apa yang dia harapkan untuk dilihat saat pindah ke controller lain. </li></ul><br>  Untuk melakukan ini, saya menulis prosesor navigasi terpisah yang menyimpan informasi tentang lokasi pengguna, jenis konten yang dia lihat, riwayat navigasi, dll.  Ia mengontrol urutan dan kebutuhan inisialisasi. <br><br>  Karena setiap tab adalah pengontrol slider (untuk membuat transisi gesek pada mereka), Anda perlu memahami: masing-masing bisa dalam keadaan sendiri (misalnya, "Berita" terbuka di satu, dan "Voting" di yang lain).  Ini diikuti oleh prosesor navigasi yang sama.  Bahkan mengubah tingkat presentasi dari rumah ke wilayah, kami akan tetap pada jenis konten yang sama. <br><br><h2>  Kami mengontrol aliran data secara real time </h2><br>  Bekerja dengan begitu banyak data dalam aplikasi, Anda perlu mengatur pengiriman informasi yang relevan di semua bagian secara real time.  Untuk mengatasi masalah ini, 3 metode dapat dibedakan: <br><br><ol><li>  Akses API Dengan pengatur waktu atau pemicu dan minta kembali konten yang relevan di layar; </li><li>  Memiliki koneksi permanen ke server dan menerima perubahan secara real time; </li><li>  Terima dorongan dengan perubahan konten. </li></ol><br>  Setiap pendekatan memiliki pro dan kontra, jadi lebih baik menggunakan ketiganya, hanya memilih kekuatan masing-masing.  Kami membagi konten di dalam aplikasi menjadi beberapa jenis: panas, reguler, dan layanan.  Ini dilakukan untuk menentukan waktu yang dapat diterima antara acara dan pemberitahuan pengguna.  Misalnya, kami ingin melihat pesan obrolan segera setelah mereka mengirimkannya kepada kami - ini adalah konten yang panas.  Pilihan lain: jajak pendapat dari tetangga.  Tidak ada bedanya ketika kita melihatnya, sekarang atau dalam satu menit, karena ini adalah konten biasa.  Notifikasi kecil di dalam aplikasi (pesan yang belum dibaca, perintah, dll.) Adalah konten layanan yang perlu pengiriman segera, tetapi tidak memakan banyak data. <br><br>  Ternyata: <br><br><ul><li>  Konten panas - koneksi permanen dengan API; </li><li>  Konten normal - http-permintaan ke API; </li><li>  Konten sistem - pemberitahuan push. </li></ul><br>  Yang paling menarik adalah menjaga koneksi yang konstan.  Menulis klien Anda sendiri untuk bekerja dengan soket web adalah langkah di lubang kelinci, jadi Anda perlu mencari solusi lain.  Akibatnya, kami berhenti di perpustakaan SignalR.  Mari kita lihat apa itu. <br><br>  ASP.Net SignalR adalah perpustakaan dari Microsoft yang menyederhanakan interaksi client-server secara real time, menyediakan komunikasi dua arah antara klien dan server.  Server mencakup API lengkap untuk mengelola koneksi, peristiwa koneksi-pemutusan, mekanisme untuk menggabungkan klien yang terhubung ke dalam grup, dan otorisasi. <br><br>  SignalR dapat menggunakan soket web, LongPolling, dan permintaan http sebagai transportasi.  Anda dapat menentukan jenis transportasi secara paksa atau mempercayai perpustakaan: jika websocket dapat digunakan, itu akan bekerja melalui websocket, jika ini tidak mungkin, maka ia akan turun sampai menemukan transportasi yang dapat diterima.  Fakta ini ternyata sangat praktis, mengingat fakta bahwa ia direncanakan untuk menggunakannya pada perangkat seluler. <br><br>  Total, manfaat apa yang kita dapatkan: <br><br><ul><li>  Kemampuan untuk bertukar pesan dalam jenis apa pun antara klien dan server; </li><li>  Mekanisme untuk beralih secara otomatis antara soket web, Long Pooling, dan permintaan Http; </li><li>  Informasi tentang status koneksi saat ini; </li><li>  Kesempatan untuk menyatukan klien dalam kelompok; </li><li>  Metode praktis untuk memanipulasi logika pengiriman pesan dalam grup; </li><li>  Kemampuan untuk skala server. </li></ul><br>  Ini, tentu saja, tidak memuaskan semua kebutuhan, tetapi terasa membuat hidup lebih mudah. <br><br>  Di dalam proyek, pembungkus digunakan di perpustakaan SignalR, yang selanjutnya menyederhanakan bekerja dengannya, yaitu: <br><br><ul><li>  Monitor status koneksi, sambungkan kembali sesuai dengan kondisi yang ditentukan dan dalam hal terjadi putus; </li><li>  Dapat dengan cepat mengganti atau membuka kembali koneksi, membunuh yang lama secara tidak serempak dan memberikannya ke pemulung untuk merobek - ternyata, metode koneksi bekerja sepuluh kali lebih cepat daripada metode penutupan (Buang atau Berhenti), dan ini adalah satu-satunya cara untuk menutupnya; </li><li>  Mengatur antrian untuk mengirim pesan sehingga koneksi ulang atau pembukaan kembali koneksi tidak mengganggu pengiriman; </li><li>  Kontrol transfer ke delegasi yang sesuai jika terjadi kesalahan yang tidak terduga. </li></ul><br>  Masing-masing pembungkus ini (kami menyebutnya klien) bekerja bersama dengan sistem caching, dan, jika terjadi pemutusan, hanya dapat meminta data yang mungkin terlewatkan selama waktu ini.  "Masing-masing" karena beberapa senyawa aktif ditahan secara bersamaan.  Di dalam aplikasi ada messenger lengkap, dan klien terpisah digunakan untuk melayaninya. <br><br>  Klien kedua bertanggung jawab untuk menerima pemberitahuan.  Seperti yang sudah saya katakan, jenis konten yang biasa diperoleh melalui permintaan http, di masa depan pembaruannya jatuh pada klien ini, yang melaporkan semua perubahan penting di dalamnya (misalnya, pemungutan suara telah berpindah dari satu status ke status lainnya, publikasi berita baru). <br><br><h2>  Visualisasikan data dalam aplikasi </h2><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/01/ne/xn/01nexnxh3zdp2j3cizlcx2lxuhc.png" alt="gambar"></div><br>  Mendapatkan data adalah satu hal, menunjukkan hal lain.  Pembaruan data waktu nyata memiliki kesulitannya sendiri.  Minimal, Anda harus memutuskan bagaimana menyajikan pembaruan ini kepada pengguna.  Dalam aplikasi kami menggunakan tiga jenis pemberitahuan: <br><br><ol><li>  Pemberitahuan konten yang belum dibaca; </li><li>  Pembaruan otomatis data di layar; </li><li>  Penawaran konten. </li></ol><br>  Cara yang paling akrab dan biasa untuk menunjukkan bahwa di suatu tempat ada konten baru adalah dengan menyorot ikon bagian.  Dengan demikian, hampir semua ikon memiliki kemampuan untuk menampilkan notifier konten yang belum dibaca sebagai titik merah.  Yang lebih menarik adalah dengan pembaruan otomatis. <br><br>  Secara otomatis memperbarui data hanya mungkin ketika konten baru tidak mengatur ulang layar dan tidak mengubah ukuran kontrol.  Misalnya, pada layar survei: informasi tentang suara hanya akan mengubah nilai bilah kemajuan dan persentase.  Perubahan seperti itu tidak akan menyebabkan perubahan ukuran, mereka dapat diterapkan secara instan tanpa masalah. <br><br>  Kesulitan muncul ketika Anda perlu menambahkan konten baru ke daftar.  Semua daftar dalam aplikasi, sebenarnya, adalah ScrollView dan memiliki beberapa karakteristik: ukuran jendela, ukuran konten, dan posisi gulir.  Semuanya memiliki awal yang statis (di atas layar dengan koordinat 0; 0) dan dapat meluas ke bawah.  Tambahkan konten baru di daftar, pada akhirnya, tidak ada masalah, daftar akan bertahan.  Tetapi konten baru akan muncul di bagian atas, dan ini gambarnya: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/rh/ve/am/rhveamjeqsuityqnk3_io3njrxy.png" alt="gambar"></div><br>  Berada di 3 elemen, kita akan berada di 2 - gulir akan memantul.  Dan karena konten baru dapat tiba secara konstan, pengguna tidak akan dapat menggulir secara normal.  Anda mungkin berkata: mengapa tidak menghitung ukuran konten baru dan menggeser gulir ke bawah ke nilai ini?  Ya, itu bisa dilakukan.  Tetapi kemudian Anda harus mengontrol posisi gulir secara manual, dan jika pada saat itu pengguna menggulir ke arah mana pun, tindakannya akan terganggu.  Itulah sebabnya layar seperti itu tidak dapat diperbarui secara waktu nyata tanpa persetujuan pengguna. <br><br>  Solusi terbaik dalam situasi ini adalah memberi tahu pengguna bahwa ketika ia menggulir umpan, seseorang memposting konten baru.  Dalam desain kami, itu terlihat seperti lingkaran merah di sudut layar.  Dengan mengkliknya, pengguna memberikan persetujuan bersyarat kepada kami untuk mengembalikannya ke bagian atas layar dan menampilkan konten segar. <br><br>  Dengan pendekatan ini, kami, tentu saja, menghindari masalah "juggling" konten, tetapi mereka masih harus dipecahkan.  Yaitu, di layar obrolan, karena selama komunikasi dan interaksi dengan layar, konten baru harus ditampilkan di tempat yang berbeda. <br><br>  Perbedaan antara obrolan dan daftar reguler adalah bahwa konten baru ada di bagian bawah layar.  Karena ini adalah "ekor", Anda dapat menambahkan konten di sana tanpa banyak kesulitan.  Pengguna menghabiskan 90% dari waktu di sini, yang berarti Anda harus terus menjaga posisi gulir dan menggesernya ke bawah saat menerima dan mengirim pesan.  Dalam percakapan langsung, tindakan seperti itu harus dilakukan cukup sering. <br><br>  Poin kedua: memuat riwayat saat menggulir ke atas.  Tepat ketika memuat cerita, kita menemukan diri kita dalam situasi di mana perlu untuk menempatkan pesan di atas tingkat ulasan (yang akan memerlukan bias), sehingga gulir itu lancar dan berkelanjutan.  Dan seperti yang sudah kita ketahui, agar tidak mengganggu pengguna, tidak mungkin mengontrol posisi gulir secara manual. <br><br>  Dan kami menemukan solusi: kami membaliknya.  Balik layar memecahkan dua masalah sekaligus: <br><br><ol><li>  Ekor daftar ada di bagian atas, jadi kami dapat menambahkan cerita tanpa hambatan dengan mengganggu gulungan pengguna; </li><li>  Pesan terakhir selalu di bagian atas daftar dan kami tidak perlu menggulir layar sebelumnya. </li></ol><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/0n/hx/zf/0nhxzfnj9mhuofyu4bkr1epdtlw.png" alt="gambar"></div><br>  Solusi ini juga membantu mempercepat rendering, menghilangkan operasi yang tidak perlu dengan kontrol gulir. <br><br>  Berbicara tentang kinerja.  Di versi pertama layar, drawdown yang terlihat terdeteksi saat menggulir pesan.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Karena konten dalam "uang" adalah beragam - teks, file, foto - Anda harus terus menghitung ulang ukuran sel, menambah dan menghapus elemen dalam uang. </font><font style="vertical-align: inherit;">Oleh karena itu, optimasi gelembung diperlukan. </font><font style="vertical-align: inherit;">Kami melakukan hal yang sama seperti pada layar utama, merender sebagian adonan dengan posisi absolut. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Saat bekerja dengan daftar di iOS, sebelum menggambar sel, Anda harus mengetahui tingginya. </font><font style="vertical-align: inherit;">Karena itu, sebelum menambahkan pesan baru ke daftar, Anda perlu menyiapkan semua informasi yang diperlukan untuk ditampilkan dalam aliran terpisah, menghitung ketinggian sel, memproses data pengguna, dan hanya setelah kami mengetahui dan menyimpan semua yang diperlukan, tambahkan sel ke daftar. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hasilnya, kami mendapatkan gulir yang lancar dan tidak aliran UI yang kelebihan beban.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Untuk meringkas: </font></font></h2><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Pengembangan lintas platform menghemat waktu dan uang; </font></font></li><li>      ,    ,     ; </li><li>           ,      ; </li><li>           ; </li><li> SignalR â€“     -    ; </li><li>            ; </li><li>         ,    , ; </li><li>      ,   SignalR-,  ,  , , . </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id430892/">https://habr.com/ru/post/id430892/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id430882/index.html">Xiaomi Aqara Beralih redo dari ZigBee ke Z-Wave</a></li>
<li><a href="../id430884/index.html">Pabrik percetakan: mengapa "LANIT-Integration" membuka "percetakan" sendiri</a></li>
<li><a href="../id430886/index.html">Perbarui perpustakaan dan pembenci SPPermission</a></li>
<li><a href="../id430888/index.html">Seberapa aman menggunakan paket R untuk bekerja dengan API sistem periklanan</a></li>
<li><a href="../id430890/index.html">Di mana lincah itu mengerikan, terutama scrum</a></li>
<li><a href="../id430894/index.html">Situasi: merek semakin banyak menghabiskan uang untuk beriklan di podcast - kami mengerti mengapa</a></li>
<li><a href="../id430896/index.html">Linux Foundation telah membentuk dana untuk GraphQL dan Ceph - mengapa mereka dibutuhkan dan apa yang diharapkan dari mereka</a></li>
<li><a href="../id430900/index.html">Laser pertama dalam sejarah: apa itu</a></li>
<li><a href="../id430902/index.html">Elf dalam memori. Menjalankan ELF di Linux RAM</a></li>
<li><a href="../id430906/index.html">Ibu tidur dengan tenang di malam hari - kami mengumpulkan OpenCV untuk Raspbian'a</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>