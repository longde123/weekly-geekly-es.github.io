<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üçè ‚úäüèΩ üë®‚Äçüç≥ Shades Pembubaran dan Eksplorasi Dunia üë®üèª‚Äçüöí üßëüèæ‚Äçü§ù‚Äçüßëüèæ üë©üèø‚Äçü§ù‚Äçüë©üèº</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Bagian 1: Pembubaran Shader 
 Shader pembubaran mengembalikan efek yang indah, apalagi, mudah dibuat dan dipahami; Hari ini kita akan membuatnya dalam...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Shades Pembubaran dan Eksplorasi Dunia</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/427401/"><h1>  Bagian 1: Pembubaran Shader </h1><br>  <strong>Shader pembubaran</strong> mengembalikan efek yang indah, apalagi, mudah dibuat dan dipahami;  Hari ini kita akan membuatnya dalam <strong>Unity Shader Graph</strong> , dan juga menulis di <strong>HLSL</strong> . <br><br>  Berikut ini contoh yang akan kami buat: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ce4/46c/b99/ce446cb9949fdee3ed4b29d121aa1c89.gif"></div><br><br><h1>  Bagaimana cara kerjanya </h1><br>  Untuk membuat shader <strong>terlarut</strong> , kita harus <strong>bekerja</strong> dengan nilai <strong>AlphaClipThreshold</strong> di shader "Shader Graph" atau menggunakan fungsi HLSL yang disebut <strong>clip</strong> . <br><br>  Pada dasarnya, kami memberi tahu shader <strong>untuk tidak merender piksel</strong> berdasarkan <strong>tekstur</strong> dan <strong>nilai yang</strong> diteruskan.  Kita perlu mengetahui hal berikut: bagian <strong>putih larut lebih cepat</strong> . <br><a name="habracut"></a><br>  Kami akan menggunakan tekstur berikut: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1cc/f52/1cd/1ccf521cdd1ba16cdaa45b33ae50fec4.png"></div><br>  Anda dapat membuat sendiri - garis lurus, segitiga, tetapi apa saja!  Ingatlah bahwa bagian <strong>putih larut lebih cepat</strong> . <br><br>  Saya membuat tekstur ini di Photoshop menggunakan filter Clouds. <br><br>  Bahkan jika Anda hanya tertarik pada Grafik Shader dan Anda tidak tahu apa-apa tentang HLSL, saya masih merekomendasikan membaca bagian ini, karena berguna untuk memahami bagaimana Unity Shader Graph bekerja di dalam. <br><br><hr><br><h1>  Hlsl </h1><br>  Dalam HLSL, kami menggunakan fungsi <strong>klip (x)</strong> .  Fungsi <strong>klip (x)</strong> membuang semua piksel dengan nilai kurang dari <strong>nol</strong> .  Karena itu, jika kita memanggil <strong>klip (-1)</strong> , kita akan yakin bahwa shader tidak akan pernah merender piksel ini.  Anda dapat membaca lebih lanjut tentang <strong>klip</strong> di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Microsoft Documents</a> . <br><br><h4>  Sifat-sifat </h4><br>  Shader memerlukan dua properti, <strong>Dissolve Texture</strong> and <strong>Amount</strong> (yang akan menunjukkan proses eksekusi keseluruhan).  Seperti halnya properti dan variabel lain, Anda dapat menyebutnya apa saja yang Anda suka. <br><br><pre><code class="hljs powershell">Properties { //Your other properties //[<span class="hljs-type"><span class="hljs-type">...</span></span>] //Dissolve shader properties _DissolveTexture(<span class="hljs-string"><span class="hljs-string">"Dissolve Texture"</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>D) = <span class="hljs-string"><span class="hljs-string">"white"</span></span> {} _Amount(<span class="hljs-string"><span class="hljs-string">"Amount"</span></span>, Range(<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>)) = <span class="hljs-number"><span class="hljs-number">0</span></span> }</code> </pre> <br>  Pastikan untuk menambahkan yang berikut setelah CGPROGRAM SubShader (dengan kata lain, mendeklarasikan variabel): <br><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">sampler2D</span></span> _DissolveTexture; <span class="hljs-attribute"><span class="hljs-attribute">half</span></span> _Amount;</code> </pre> <br>  Juga, jangan lupa.  bahwa nama mereka harus cocok dengan nama di bagian Properties. <br><br><h4>  Fungsi </h4><br>  Kami memulai fungsi <strong>Permukaan</strong> atau <strong>Fragmen</strong> dengan mengambil sampel <strong>tekstur pembubaran</strong> dan mendapatkan <strong>nilai merah</strong> .  PS Tekstur kami disimpan dalam <strong>skala abu-abu</strong> , yaitu nilainya <strong>R</strong> , <strong>G</strong> dan <strong>B</strong> sama, dan Anda dapat <strong>memilih salah satunya</strong> .  Misalnya, <strong>putih</strong> adalah <strong>(1,1,1)</strong> , <strong>hitam</strong> adalah <strong>(0,0,0)</strong> . <br><br>  Dalam contoh saya, saya menggunakan shader permukaan: <br><br><pre> <code class="hljs objectivec"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> surf (Input IN, <span class="hljs-keyword"><span class="hljs-keyword">inout</span></span> SurfaceOutputStandard o) { half dissolve_value = tex2D(_DissolveTexture, IN.uv_MainTex).r; <span class="hljs-comment"><span class="hljs-comment">//Get how much we have to dissolve based on our dissolve texture clip(dissolve_value - _Amount); //Dissolve! //Your shader body, you can set the Albedo etc. //[...] }</span></span></code> </pre> <br>  <strong>Dan itu dia!</strong>  Kita dapat menerapkan proses ini untuk shader yang ada dan mengubahnya menjadi <strong>shader pembubaran</strong> ! <br><br>  Ini adalah Surface Shader standar dari mesin Unity, yang diubah menjadi <strong>shader pembubaran</strong> <strong>dua sisi</strong> <strong>:</strong> <br><br><pre> <code class="hljs pgsql">Shader "Custom/DissolveSurface" { Properties { _Color ("Color", Color) = (<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>) _MainTex ("Albedo (RGB)", <span class="hljs-number"><span class="hljs-number">2</span></span>D) = "white" {} _Glossiness ("Smoothness", Range(<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>)) = <span class="hljs-number"><span class="hljs-number">0.5</span></span> _Metallic ("Metallic", Range(<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>)) = <span class="hljs-number"><span class="hljs-number">0.0</span></span> //Dissolve properties _DissolveTexture("Dissolve Texutre", <span class="hljs-number"><span class="hljs-number">2</span></span>D) = "white" {} _Amount("Amount", Range(<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>)) = <span class="hljs-number"><span class="hljs-number">0</span></span> } SubShader { Tags { "RenderType"="Opaque" } LOD <span class="hljs-number"><span class="hljs-number">200</span></span> Cull <span class="hljs-keyword"><span class="hljs-keyword">Off</span></span> //Fast way <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> turn your material <span class="hljs-type"><span class="hljs-type">double</span></span>-sided CGPROGRAM #pragma surface surf Standard fullforwardshadows #pragma target <span class="hljs-number"><span class="hljs-number">3.0</span></span> sampler2D _MainTex; struct <span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> { float2 uv_MainTex; }; half _Glossiness; half _Metallic; fixed4 _Color; //Dissolve properties sampler2D _DissolveTexture; half _Amount; <span class="hljs-type"><span class="hljs-type">void</span></span> surf (<span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">inout</span></span> SurfaceOutputStandard o) { //Dissolve <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> half dissolve_value = tex2D(_DissolveTexture, <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.uv_MainTex).r; clip(dissolve_value - _Amount); //Basic shader <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> fixed4 c = tex2D (_MainTex, <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.uv_MainTex) * _Color; o.Albedo = c.rgb; o.Metallic = _Metallic; o.Smoothness = _Glossiness; o.Alpha = ca; } ENDCG } FallBack "Diffuse" }</code> </pre> <br><hr><br><h1>  Grafik shader </h1><br>  Jika kita perlu membuat efek ini menggunakan Unity <strong>Shader Graph</strong> , maka kita harus menggunakan nilai <strong>AlphaClipThreshold</strong> (yang bekerja secara berbeda dari <strong>klip (x)</strong> dari HLSL).  Dalam contoh ini, saya membuat shader PBR. <br><br>  Fungsi <strong>AlphaClipThreshold</strong> menginstruksikan shader untuk membuang semua piksel yang nilainya kurang dari nilai <strong>Alpha</strong> -nya.  Misalnya, jika <strong>0.3f</strong> , dan nilai alfa kami adalah <strong>0.2f</strong> , maka shader <strong>tidak akan membuat</strong> piksel ini.  Fungsi <strong>AlphaClipThreshold</strong> dapat ditemukan di <strong>dokumentasi Unity</strong> : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">PBR Master Node</a> dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Unlit Master Node</a> . <br><br>  Ini shader yang sudah jadi: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1b9/368/ede/1b9368ede92dad1544f3ca702a2924ad.png"></div><br>  Kami sampel <strong>tekstur pembubaran</strong> dan mendapatkan <strong>nilai merah</strong> , dan kemudian menambahkannya ke nilai <strong>Jumlah</strong> (yang merupakan properti yang saya tambahkan untuk menunjukkan proses eksekusi keseluruhan, nilai 1 berarti pembubaran lengkap) dan hubungkan ke <strong>AlphaClipThreshold</strong> .  <strong>Selesai!</strong> <br><br>  Jika Anda ingin menerapkannya pada shader yang ada, maka cukup <strong>salin</strong> <strong>koneksi node</strong> ke <strong>AlphaClipThreshold</strong> (jangan lewatkan properti yang diperlukan!).  Anda juga dapat membuatnya <strong>dua sisi</strong> dan mendapatkan hasil yang lebih indah! <br><br><hr><br><h1>  Pengurai kontur kontur </h1><br>  Dan jika Anda mencoba menambahkan <strong>kontur</strong> ke dalamnya?  Ayo lakukan! <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c59/0db/e64/c590dbe64e954bdc6c7ce1154726e80b.gif"></div><br>  Kami tidak dapat bekerja dengan piksel yang sudah terlarut, karena setelah menjatuhkannya, piksel tersebut <em>menghilang selamanya</em> .  Sebagai gantinya, kita dapat bekerja dengan nilai-nilai "hampir larut"! <br><br>  Di <strong>HLSL,</strong> ini sangat sederhana, cukup tambahkan beberapa baris kode setelah menghitung <strong>klip</strong> : <br><br><pre> <code class="hljs powershell">void surf (Input <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>, inout SurfaceOutputStandard o) { //[<span class="hljs-type"><span class="hljs-type">...</span></span>] //After our clip calculations <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (dissolve_value - _Amount &lt; .<span class="hljs-number"><span class="hljs-number">05</span></span>f) //outline width = .<span class="hljs-number"><span class="hljs-number">05</span></span>f o.Emission = fixed3(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>); //emits white color //Your shader body, you can set the Albedo etc. //[<span class="hljs-type"><span class="hljs-type">...</span></span>] }</code> </pre> <br>  <strong>Selesai!</strong> <br><br>  Saat bekerja dengan <strong>Grafik Shader,</strong> logikanya sedikit berbeda.  Inilah shader yang sudah jadi: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e26/288/1ef/e262881ef6ad042856b345ba2d9f2765.png"></div><br><hr><br>  Kita dapat membuat <strong>efek yang</strong> sangat <strong>keren</strong> dengan <strong>shader disolusi</strong> sederhana;  Anda dapat bereksperimen dengan <strong>berbagai tekstur</strong> dan <strong>nilai</strong> , serta menghasilkan sesuatu yang lain! <br><br><h1>  Bagian 2: Dunia eksplorasi shader </h1><br>  Sebuah shader <strong>penjelajahan dunia</strong> (atau " <strong>shader pembubaran dunia</strong> , atau <strong>pembubaran global</strong> ") memungkinkan kita untuk sama-sama menyembunyikan semua objek dalam adegan berdasarkan jaraknya ke posisi; sekarang kita akan membuat shader seperti itu dalam <strong>Unity Shader Graph</strong> dan menuliskannya dalam <strong>HLSL</strong> . <br><br>  Berikut ini contoh yang akan kami buat: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/228/7bb/169/2287bb1692d36eae92224f36359648a3.gif"></div><br><hr><br><h2>  Jarak sebagai parameter </h2><br>  Misalkan kita perlu <strong>membubarkan sebuah objek</strong> dalam sebuah adegan jika <strong>terlalu jauh dari pemain</strong> .  Kami telah mengumumkan parameter <strong>_Amount</strong> , yang mengontrol hilangnya / pembubaran objek, jadi kami harus menggantinya dengan jarak antara objek dan pemain. <br><br>  Untuk melakukan ini, kita perlu mengambil posisi <strong>Player</strong> dan <strong>Object</strong> . <br><br><h3>  Posisi Pemain </h3><br>  <strong>Prosesnya</strong> akan serupa untuk <strong>Unity Shader Graph</strong> dan <strong>HLSL</strong> : kita perlu mentransfer posisi pemain dalam kode. <br><br><pre> <code class="hljs cs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Update</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-comment"><span class="hljs-comment">//Updates the _PlayerPos variable in all the shaders //Be aware that the parameter name has to match the one in your shaders or it wont' work Shader.SetGlobalVector("_PlayerPos", transform.position); //"transform" is the transform of the Player }</span></span></code> </pre> <br><hr><br><h2>  Grafik shader </h2><br><h4>  Posisi objek dan jarak ke sana </h4><br>  Menggunakan Grafik Shader, kita dapat menggunakan node Posisi dan Jarak. <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dokumentasi untuk simpul Posisi</a> . </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dokumentasi untuk simpul Jarak</a> . </li></ul><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7b1/cdb/078/7b1cdb078a844a10451317e40a14df7c.png"></div><br>  PS Agar sistem ini berfungsi dengan Sprite Renderers, Anda perlu menambahkan properti _MainTex, sampel dan sambungkan ke albedo.  Anda dapat membaca tutorial <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Spader shader difus</a> saya sebelumnya (yang menggunakan grafik shader). <br><br><hr><br><h2>  HLSL (permukaan) </h2><br><h4>  Posisi Obyek </h4><br>  Dalam HLSL, kita dapat menambahkan variabel <strong>worldPos</strong> ke struktur <strong>Input</strong> kami untuk mendapatkan posisi simpul objek. <br><br><pre> <code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Input</span></span></span><span class="hljs-class"> </span></span>{ float2 uv_MainTex; float3 worldPos; <span class="hljs-comment"><span class="hljs-comment">//add this and Unity will set it automatically };</span></span></code> </pre> <br>  Pada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">halaman dokumentasi Unity,</a> Anda dapat mengetahui parameter bawaan apa yang diizinkan untuk ditambahkan ke struktur input. <br><br><h4>  Terapkan jarak </h4><br>  Kita perlu menggunakan jarak antara objek dan pemain sebagai jumlah pembubaran.  Untuk melakukan ini, Anda dapat menggunakan fungsi <strong>jarak</strong> built-in ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dokumentasi Microsoft</a> ). <br><br><pre> <code class="hljs objectivec"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> surf (Input IN, <span class="hljs-keyword"><span class="hljs-keyword">inout</span></span> SurfaceOutputStandard o) { half dissolve_value = tex2D(_DissolveTexture, IN.uv_MainTex).x; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> dist = distance(_PlayerPos, IN.worldPos); clip(dissolve_value - dist/ <span class="hljs-number"><span class="hljs-number">6</span></span>f); <span class="hljs-comment"><span class="hljs-comment">//"6" is the maximum distance where your object will start showing //Set albedo, alpha, smoothness etc[...] }</span></span></code> </pre> <br><h3>  Hasil (3D) </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/868/f5c/2e8/868f5c2e803708138c71f84c95e3390c.gif"></div><br><h3>  Hasil (2D) </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/289/380/e2b/289380e2ba53cbe569621821affc7009.gif"></div><br>  Seperti yang Anda lihat, objek larut "lokal", kami tidak mendapatkan efek homogen, karena kami mendapatkan "nilai disolusi" dari tekstur sampel menggunakan UV dari masing-masing objek.  (Dalam 2D, ini kurang terlihat). <br><br><hr><br><h3>  3D LocalUV Melarutkan Shader di HLSL </h3><br><pre> <code class="hljs pgsql">Shader "Custom/GlobalDissolveSurface" { Properties { _Color ("Color", Color) = (<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>) _MainTex ("Albedo (RGB)", <span class="hljs-number"><span class="hljs-number">2</span></span>D) = "white" {} _Glossiness("Smoothness", Range(<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>)) = <span class="hljs-number"><span class="hljs-number">0.5</span></span> _Metallic("Metallic", Range(<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>)) = <span class="hljs-number"><span class="hljs-number">0.0</span></span> _DissolveTexture("Dissolve texture", <span class="hljs-number"><span class="hljs-number">2</span></span>D) = "white" {} _Radius("Distance", <span class="hljs-type"><span class="hljs-type">Float</span></span>) = <span class="hljs-number"><span class="hljs-number">1</span></span> //distance <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> we <span class="hljs-keyword"><span class="hljs-keyword">start</span></span> <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> reveal the objects } SubShader{ Tags { "RenderType" = "Opaque" } LOD <span class="hljs-number"><span class="hljs-number">200</span></span> Cull <span class="hljs-keyword"><span class="hljs-keyword">off</span></span> //material <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> two sided CGPROGRAM #pragma surface surf Standard fullforwardshadows #pragma target <span class="hljs-number"><span class="hljs-number">3.0</span></span> sampler2D _MainTex; sampler2D _DissolveTexture; //texture <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> we <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> the dissolve <span class="hljs-keyword"><span class="hljs-keyword">value</span></span> struct <span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> { float2 uv_MainTex; float3 worldPos; //Built-<span class="hljs-keyword"><span class="hljs-keyword">in</span></span> world position }; half _Glossiness; half _Metallic; fixed4 _Color; float3 _PlayerPos; //"Global Shader Variable", contains the Player Position <span class="hljs-type"><span class="hljs-type">float</span></span> _Radius; <span class="hljs-type"><span class="hljs-type">void</span></span> surf (<span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">inout</span></span> SurfaceOutputStandard o) { half dissolve_value = tex2D(_DissolveTexture, <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.uv_MainTex).x; <span class="hljs-type"><span class="hljs-type">float</span></span> dist = distance(_PlayerPos, <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.worldPos); clip(dissolve_value - dist/ _Radius); fixed4 c = tex2D (_MainTex, <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.uv_MainTex) * _Color; o.Albedo = c.rgb; o.Metallic = _Metallic; o.Smoothness = _Glossiness; o.Alpha = ca; } ENDCG } FallBack "Diffuse" }</code> </pre> <br><h3>  Sprite Diffuse - LocalUV Melarutkan Shader di HLSL </h3><br><pre> <code class="hljs pgsql">Shader "Custom/GlobalDissolveSprites" { Properties { [PerRendererData] _MainTex("Sprite Texture", <span class="hljs-number"><span class="hljs-number">2</span></span>D) = "white" {} _Color("Tint", Color) = (<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>) [MaterialToggle] PixelSnap("Pixel snap", <span class="hljs-type"><span class="hljs-type">Float</span></span>) = <span class="hljs-number"><span class="hljs-number">0</span></span> [HideInInspector] _RendererColor("RendererColor", Color) = (<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>) [HideInInspector] _Flip("Flip", Vector) = (<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>) [PerRendererData] _AlphaTex("External Alpha", <span class="hljs-number"><span class="hljs-number">2</span></span>D) = "white" {} [PerRendererData] _EnableExternalAlpha("Enable External Alpha", <span class="hljs-type"><span class="hljs-type">Float</span></span>) = <span class="hljs-number"><span class="hljs-number">0</span></span> _DissolveTexture("Dissolve texture", <span class="hljs-number"><span class="hljs-number">2</span></span>D) = "white" {} _Radius("Distance", <span class="hljs-type"><span class="hljs-type">Float</span></span>) = <span class="hljs-number"><span class="hljs-number">1</span></span> //distance <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> we <span class="hljs-keyword"><span class="hljs-keyword">start</span></span> <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> reveal the objects } SubShader { Tags { "Queue" = "Transparent" "IgnoreProjector" = "True" "RenderType" = "Transparent" "PreviewType" = "Plane" "CanUseSpriteAtlas" = "True" } Cull <span class="hljs-keyword"><span class="hljs-keyword">Off</span></span> Lighting <span class="hljs-keyword"><span class="hljs-keyword">Off</span></span> ZWrite <span class="hljs-keyword"><span class="hljs-keyword">Off</span></span> Blend One OneMinusSrcAlpha CGPROGRAM #pragma surface surf Lambert vertex:vert nofog nolightmap nodynlightmap keepalpha noinstancing #pragma multi_compile _ PIXELSNAP_ON #pragma multi_compile _ ETC1_EXTERNAL_ALPHA #<span class="hljs-keyword"><span class="hljs-keyword">include</span></span> "UnitySprites.cginc" struct <span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> { float2 uv_MainTex; fixed4 color; float3 worldPos; //Built-<span class="hljs-keyword"><span class="hljs-keyword">in</span></span> world position }; sampler2D _DissolveTexture; //texture <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> we <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> the dissolve <span class="hljs-keyword"><span class="hljs-keyword">value</span></span> float3 _PlayerPos; //"Global Shader Variable", contains the Player Position <span class="hljs-type"><span class="hljs-type">float</span></span> _Radius; <span class="hljs-type"><span class="hljs-type">void</span></span> vert(<span class="hljs-keyword"><span class="hljs-keyword">inout</span></span> appdata_full v, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> o) { v.vertex = UnityFlipSprite(v.vertex, _Flip); #<span class="hljs-keyword"><span class="hljs-keyword">if</span></span> defined(PIXELSNAP_ON) v.vertex = UnityPixelSnap(v.vertex); #endif UNITY_INITIALIZE_OUTPUT(<span class="hljs-keyword"><span class="hljs-keyword">Input</span></span>, o); o.color = v.color * _Color * _RendererColor; } <span class="hljs-type"><span class="hljs-type">void</span></span> surf(<span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">inout</span></span> SurfaceOutput o) { half dissolve_value = tex2D(_DissolveTexture, <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.uv_MainTex).x; <span class="hljs-type"><span class="hljs-type">float</span></span> dist = distance(_PlayerPos, <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.worldPos); clip(dissolve_value - dist / _Radius); fixed4 c = SampleSpriteTexture(<span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.uv_MainTex) * <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.color; o.Albedo = c.rgb * ca; o.Alpha = ca; } ENDCG } Fallback "Transparent/VertexLit" }</code> </pre> <br>  PS Untuk membuat shader terakhir, saya menyalin standar Unity Sprite-Diffuse shader dan menambahkan bagian "larut" yang dijelaskan sebelumnya di bagian artikel ini.  Semua shader standar dapat ditemukan di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> . <br><br><hr><br><h2>  Membuat efeknya homogen </h2><br>  Untuk membuat efek homogen, kita dapat menggunakan koordinat global (posisi di dunia) sebagai koordinat UV dari tekstur disolusi.  Penting juga untuk mengatur <strong>Wrap = Ulangi</strong> dalam parameter tekstur pembubaran sehingga kita dapat mengulangi tekstur tanpa menyadarinya (pastikan teksturnya mulus dan diulang dengan baik!) <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7db/b9f/e0e/7dbb9fe0e582bf7a63b2dccfb43a9b9b.png"></div><br><h4>  HLSL (permukaan) </h4><br><pre> <code class="hljs delphi">half dissolve_value = tex2D(_DissolveTexture, <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.worldPos / <span class="hljs-number"><span class="hljs-number">4</span></span>).x; <span class="hljs-comment"><span class="hljs-comment">//I modified the worldPos to reduce the texture size</span></span></code> </pre> <br><h4>  Grafik shader </h4><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/787/167/9c6/7871679c66cab1c842fe02c5ce523884.png"></div><br><h3>  Hasil (2D) </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/428/b34/425/428b344254f3e80ef68b63ba8754dfa2.gif"></div><br>  Inilah hasilnya: kita dapat melihat bahwa tekstur pembubaran sekarang seragam untuk seluruh dunia. <br><br>  Shader ini sudah <strong>ideal untuk gim 2D</strong> , tetapi untuk <strong>objek 3D</strong> perlu <strong>ditingkatkan</strong> . <br><br><h3>  Masalah dengan objek 3D </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/231/1f4/09b/2311f409be1ca990c276895eb8e49695.png"></div><br>  Seperti yang Anda lihat, shader tidak berfungsi untuk wajah "non-vertikal", dan sangat merusak tekstur.  Inilah sebabnya mengapa itu terjadi.  bahwa koordinat UV memerlukan nilai float2, dan jika kita melewati worldPos, maka hanya menerima X dan Y. <br><br>  Jika kami memperbaiki masalah ini dengan menerapkan perhitungan untuk menampilkan tekstur pada semua wajah, kami akan menemukan masalah baru: ketika gelap, objek akan saling bersilangan, dan tidak akan tetap homogen. <br><br>  Akan sulit bagi pemula untuk memahami solusinya: perlu untuk menghilangkan tekstur, menghasilkan suara tiga dimensi di dunia dan mendapatkan "nilai pembubaran" dari itu.  Dalam posting ini saya tidak akan menjelaskan generasi noise 3D, tetapi Anda dapat menemukan banyak fungsi yang siap digunakan! <br><br>  Berikut ini contoh noise shader: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://github.com/keijiro/NoiseShader</a> .  Anda juga dapat mempelajari cara menghasilkan noise di sini: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://thebookofshaders.com/11/</a> dan di sini: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://catlikecoding.com/unity/tutorials/noise/</a> <br><br>  Saya akan mengatur fungsi permukaan saya dengan cara ini (dengan asumsi Anda sudah menulis bagian noise): <br><br><pre> <code class="hljs powershell">void surf (Input <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>, inout SurfaceOutputStandard o) { float dist = distance(_PlayerPos, IN.worldPos); //<span class="hljs-string"><span class="hljs-string">"abs"</span></span> because you have to make sure that the noise is between the range [<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>] //you can remove <span class="hljs-string"><span class="hljs-string">"abs"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> your noise <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">returns</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">a</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">value</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">between</span></span></span><span class="hljs-function"> [</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">0</span></span></span><span class="hljs-function">,</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">1</span></span></span><span class="hljs-function">] //</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">also</span></span></span><span class="hljs-function">, </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">replace</span></span></span><span class="hljs-function"> "</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">NOISE_FUNCTION_HERE</span></span></span><span class="hljs-function">" </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">with</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">your</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">3D</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">noise</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">. </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">half</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">dissolve_value</span></span></span><span class="hljs-function"> = </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">abs</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(NOISE_FUNCTION_HERE(IN.worldPos)</span></span></span><span class="hljs-function">); </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">if</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(dist &gt; _Radius)</span></span></span></span> { float clip_value = dissolve_value - ((dist - _Radius) / _Radius); clip(clip_value); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (clip_value &lt; <span class="hljs-number"><span class="hljs-number">0.05</span></span>f) o.Emission = float3(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>); } fixed4 c = tex2D (_MainTex, IN.uv_MainTex) * _Color; o.Albedo = c.rgb; o.Metallic = _Metallic; o.Smoothness = _Glossiness; o.Alpha = ca; }</code> </pre> <br>  Pengingat singkat HLSL: sebelum menggunakan / memanggil fungsi, itu harus ditulis / dideklarasikan. <br><br>  PS Jika Anda ingin membuat shader menggunakan Unity Shader Graph, Anda perlu menggunakan Custom Nodes (dan menghasilkan noise dengan menuliskan kode HLSL di dalamnya).  Saya akan berbicara tentang Custom Nodes dalam tutorial mendatang. <br><br><h3>  Hasil (3D) </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ce6/a89/ad3/ce6a89ad324ff4a03d4bfabf1a694024.gif"></div><br><hr><br><h2>  Menambahkan Kontur </h2><br>  Untuk menambahkan kontur, Anda perlu mengulangi proses dari bagian sebelumnya dari tutorial. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/228/7bb/169/2287bb1692d36eae92224f36359648a3.gif"></div><br><hr><br><h2>  Efek terbalik </h2><br>  Dan jika kita ingin membalikkan efek ini?  (Benda akan hilang jika pemain ada di dekatnya) <br><br>  Cukup bagi kita untuk mengubah satu baris: <br><br><pre> <code class="hljs pgsql"><span class="hljs-type"><span class="hljs-type">float</span></span> dist = _Radius - distance(_PlayerPos, <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.worldPos);</code> </pre> <br>  (Proses yang sama berlaku untuk Grafik Shader). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/579/86c/1f9/57986c1f96a56f1ec478b64c89be3eba.gif"></div></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id427401/">https://habr.com/ru/post/id427401/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id427391/index.html">Tips untuk Junior: Membangun Kebiasaan Baik</a></li>
<li><a href="../id427393/index.html">Analisis Keamanan Nirkabel Perusahaan</a></li>
<li><a href="../id427395/index.html">"Mari kita jelaskan: atau mengapa harus seorang programmer matematika." Sebuah buku tentang bagaimana tidak ketinggalan kuliah matematika</a></li>
<li><a href="../id427397/index.html">Pengembangan dataset akustik untuk pelatihan jaringan saraf</a></li>
<li><a href="../id427399/index.html">Bekerja dengan data saat membangun API berdasarkan GraphQL</a></li>
<li><a href="../id427403/index.html">API ReportingObserver: lihat kode halaman web dari perspektif baru</a></li>
<li><a href="../id427405/index.html">ES2018 - metode akhirnya menjanjikan</a></li>
<li><a href="../id427407/index.html">Meta-clustering dengan minimisasi kesalahan, dan mengapa saya pikir otak bekerja seperti ini</a></li>
<li><a href="../id427409/index.html">Buku "The Brilliant Agile. Manajemen proyek yang fleksibel dengan Agile, Scrum dan Kanban ¬ª</a></li>
<li><a href="../id427413/index.html">Berjuang untuk sumber daya, bagian 4: Hebat</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>