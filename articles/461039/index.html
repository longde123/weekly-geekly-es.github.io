<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚úàÔ∏è üéë üíó El libro "Algoritmo perfecto. Algoritmos gr√°ficos y estructuras de datos " üòæ üóº üôéüèº</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hola habrozhiteli! Los algoritmos son el coraz√≥n y el alma de la inform√°tica. No puede prescindir de ellos, est√°n en todas partes, desde el enrutamien...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>El libro "Algoritmo perfecto. Algoritmos gr√°ficos y estructuras de datos "</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/piter/blog/461039/"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><img src="https://habrastorage.org/webt/e5/2z/76/e52z769bpr1nib4vz_bij_xvkgo.jpeg" align="left" alt="imagen"></a>  Hola habrozhiteli!  Los algoritmos son el coraz√≥n y el alma de la inform√°tica.  No puede prescindir de ellos, est√°n en todas partes, desde el enrutamiento de la red y los c√°lculos gen√≥micos hasta la criptograf√≠a y el aprendizaje autom√°tico.  El "Algoritmo perfecto" lo convertir√° en un verdadero profesional que establecer√° tareas y las resolver√° magistralmente tanto en la vida como en una entrevista al contratar cualquier empresa de TI. <br><br>  En el segundo libro, Tim Rafgarden, el gur√∫ de los algoritmos, habla sobre la b√∫squeda de gr√°ficos y su aplicaci√≥n, el algoritmo de b√∫squeda de la ruta m√°s corta y el uso e implementaci√≥n de algunas estructuras de datos: montones, √°rboles de b√∫squeda, tablas hash y el filtro Bloom. <br><br>  Esta publicaci√≥n presenta un extracto de Bloom Filters: The Basics. <br><a name="habracut"></a><br><h3>  ¬øDe qu√© trata este libro? </h3><br>  La segunda parte del libro "Algoritmo perfecto" es un curso introductorio sobre los conceptos b√°sicos de alfabetizaci√≥n sobre los siguientes tres temas. <br><br>  <b>B√∫squeda gr√°fica y aplicaciones</b> .  Los gr√°ficos modelan varios tipos diferentes de redes, incluyendo carreteras, comunicaci√≥n, redes sociales y redes de dependencias entre tareas.  Los gr√°ficos pueden ser complejos, pero hay algunas primitivas incre√≠blemente r√°pidas para hablar sobre la estructura de los gr√°ficos.  Comenzaremos con algoritmos de b√∫squeda de gr√°ficos de tiempo lineal, desde aplicaciones que van desde el an√°lisis de redes hasta la construcci√≥n de una secuencia de operaciones. <br><br>  <b>Los caminos m√°s cortos</b> .  En el problema de la ruta m√°s corta, el objetivo es calcular la mejor ruta en la red desde el punto A hasta el punto B. Esta tarea tiene aplicaciones obvias, como el c√°lculo de rutas de tr√°fico, y tambi√©n ocurre en forma encubierta en muchas otras tareas universales.  Vamos a generalizar uno de nuestros algoritmos de b√∫squeda de gr√°ficos y llegaremos al famoso algoritmo de b√∫squeda de ruta m√°s corta de Dijkstra. <br><br>  <b>Estructuras de datos</b> .  Este libro lo convertir√° en un usuario altamente educado de varias estructuras de datos diferentes dise√±adas para admitir un conjunto de objetos en evoluci√≥n con sus claves asociadas.  El objetivo principal es desarrollar una intuici√≥n sobre qu√© estructura de datos es adecuada para su aplicaci√≥n.  Secciones adicionales proporcionan pautas para implementar estas estructuras de datos desde cero. <br><br>  Primero, discutimos los montones que pueden identificar r√°pidamente el objeto almacenado con la clave m√°s peque√±a, y tambi√©n son √∫tiles para ordenar, implementar una cola prioritaria e implementar el algoritmo casi lineal-temporal de Dijkstra.  Los √°rboles de b√∫squeda mantienen el orden completo de las claves en los objetos almacenados y admiten una gama a√∫n m√°s amplia de operaciones.  Las tablas hash est√°n optimizadas para operaciones de b√∫squeda ultrarr√°pidas y est√°n muy extendidas en los programas modernos.  Tambi√©n observamos el filtro Bloom, un pariente cercano de la tabla hash, que usa menos espacio debido a errores aleatorios. <br><br>  Puede familiarizarse con el contenido del libro con m√°s detalle en las secciones "Conclusiones", que completan cada cap√≠tulo e identifican los puntos m√°s importantes.  Las secciones del libro, marcadas con un asterisco, son las m√°s avanzadas en t√©rminos del nivel de informaci√≥n presentada.  Si el libro est√° dise√±ado para una familiarizaci√≥n superficial con el tema, entonces el lector puede omitirlos sin perder la integridad de lo escrito. <br><br>  <b>Temas cubiertos en otras tres partes</b> .  La primera parte del libro "Algoritmo perfecto.  Fundamentos "cubre las notaciones asint√≥ticas (la notaci√≥n O-large y sus parientes cercanos), los algoritmos de" divide y vencer√°s "y el teorema principal de relaci√≥n de recurrencia: el m√©todo principal, la clasificaci√≥n r√°pida aleatoria y su an√°lisis, y los algoritmos de selecci√≥n lineal-temporal.  La tercera parte se ocupa de algoritmos codiciosos (planificaci√≥n, √°rboles de expansi√≥n m√≠nima, agrupaci√≥n, c√≥digos Huffman) y programaci√≥n din√°mica (problema de mochila, alineaci√≥n de secuencias, caminos m√°s cortos, √°rboles de b√∫squeda √≥ptimos).  La cuarta parte est√° dedicada a la integridad de NP, lo que significa para un dise√±ador de algoritmos y estrategias para resolver problemas computacionalmente insolubles, incluido el an√°lisis heur√≠stico y la b√∫squeda local. <br><br><h3>  12.5  Bloom Filters: The Basics </h3><br>  Los filtros Bloom son parientes cercanos de las tablas hash.  Son muy compactos, pero peri√≥dicamente cometen errores.  Esta secci√≥n describe c√≥mo los filtros Bloom son buenos y c√≥mo se implementan, mientras que la secci√≥n 12.6 establece una curva de compromiso entre la cantidad de espacio utilizado por el filtro y su tasa de error. <br><br><h3>  12.5.1.  Operaciones soportadas </h3><br>  La raz√≥n de la existencia de los filtros Bloom es esencialmente la misma que la de una tabla hash: operaciones de inserci√≥n y visualizaci√≥n s√∫per r√°pidas, gracias a las cuales puede recordar r√°pidamente lo que vio y lo que no.  ¬øPor qu√© deber√≠a molestarnos una estructura de datos diferente con el mismo conjunto de operaciones?  Debido a que los filtros Bloom son preferibles a las tablas hash en aplicaciones en las que el espacio vale su peso en oro, y un error aleatorio no es un obst√°culo para la transacci√≥n. <br><br>  Al igual que las tablas hash con direccionamiento abierto, los filtros Bloom son mucho m√°s f√°ciles de implementar e imaginar en su mente cuando solo admiten operaciones Insertar y Ver (y sin la operaci√≥n Eliminar).  Nos centraremos en este caso. <br><br><blockquote>  FILTROS DE FLUJO: OPERACIONES COMPATIBLES <br><br>  Vista: con la tecla k, devuelve "s√≠" si k se insert√≥ previamente en el filtro Bloom, y "no" en caso contrario. <br>  Pegar: agregue una nueva clave k al filtro Bloom. </blockquote><br>  Los filtros Bloom son muy eficientes espacialmente;  normalmente, pueden requerir solo 8 bits por inserto.  ¬°Esto es incre√≠ble, ya que 8 bits son completamente insuficientes para recordar incluso una clave de 32 bits o un puntero a un objeto!  Por esta raz√≥n, la operaci√≥n Ver en el filtro Bloom devuelve solo la respuesta "s√≠" / "no", mientras que en la tabla hash, esta operaci√≥n devuelve un puntero al objeto deseado (si se encuentra).  Es por eso que la operaci√≥n Insertar ahora solo acepta la clave, y no el (puntero) del objeto. <br><br>  A diferencia de todas las otras estructuras de datos que estudiamos, los filtros de Bloom pueden estar equivocados.  Hay dos tipos de errores: falsos negativos cuando la operaci√≥n Ver devuelve "falso" incluso si la clave solicitada ya se ha insertado anteriormente, y declaraciones falsas (o positivas) cuando la operaci√≥n Ver devuelve "verdadero", aunque la clave solicitada a√∫n no se ha insertado en el pasado .  En la secci√≥n 12.5.3 veremos que los filtros Bloom b√°sicos nunca sufren falsos negativos, pero pueden tener "elementos fantasmas" en forma de declaraciones falsas.  La Secci√≥n 12.6 muestra que la frecuencia de las declaraciones falsas se puede controlar ajustando adecuadamente el uso del espacio.  Una implementaci√≥n t√≠pica de un filtro Bloom puede tener una tasa de error de aproximadamente 1% o 0.1%. <br><br>  Los tiempos de ejecuci√≥n para las operaciones Insertar y Ver son tan r√°pidos como en la tabla hash.  Y a√∫n mejor, se garantiza que estas operaciones se realizar√°n en tiempo constante, independientemente de la implementaci√≥n del filtro Bloom y el conjunto de datos1.  Sin embargo, la implementaci√≥n y el conjunto de datos afectan la tasa de error del filtro. <br><br>  Para resumir las ventajas y desventajas de los filtros Bloom sobre las tablas hash: <br><br><blockquote>  FILTRO DE FLUJO CONTRA LAS TABLAS DE HASH <br><br>  1. Pros: m√°s espacialmente efectivo. <br><br>  2. Pros: operaciones garantizadas de tiempo permanente para cada conjunto de datos. <br><br>  3. Contras: no puede almacenar punteros a objetos. <br><br>  4. Contras: eliminaciones m√°s complejas en comparaci√≥n con una tabla hash con un embrague. <br><br>  5. Contras: probabilidad distinta de cero de una declaraci√≥n falsa. </blockquote><br>  La lista de indicadores para los filtros b√°sicos de Bloom es la siguiente. <br><br>  Tabla 12.4.  Filtros b√°sicos de Bloom: operaciones compatibles y su tiempo de ejecuci√≥n.  El signo de la daga (‚Ä†) indica que la operaci√≥n Ver tiene una probabilidad controlable pero no nula de afirmaciones falsas <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/j2/s0/bc/j2s0bcwhevqsy2-scnfyznyywpi.png" alt="imagen"></div><br>  Los filtros Bloom deben usarse en lugar de tablas hash en aplicaciones en las que sus ventajas son importantes y sus desventajas no son un obst√°culo para la transacci√≥n. <br><br><blockquote>  CUANDO UTILIZAR EL FILTRO DE FLORACI√ìN <br><br>  Si una aplicaci√≥n requiere una b√∫squeda r√°pida con un conjunto de objetos en evoluci√≥n din√°mica, el espacio vale su peso en oro y una peque√±a cantidad aceptable de afirmaciones falsas, entonces el filtro Bloom suele ser la estructura de datos preferida. </blockquote><br><h3>  12.5.2.  Aplicaciones </h3><br>  A continuaci√≥n, hay tres usos con escaneos repetidos, donde ahorrar espacio puede ser importante, y las declaraciones falsas no son un obst√°culo para la transacci√≥n. <br><br>  Correctores de ortograf√≠a.  En la d√©cada de 1970, los filtros Bloom se usaban para implementar correctores ortogr√°ficos, correctores ortogr√°ficos.  En la etapa de preprocesamiento, cada palabra del diccionario se inserta en el filtro Bloom.  La ortograf√≠a de un documento se reduce a una sola operaci√≥n: observe una palabra en un documento y marque las palabras para las que esta operaci√≥n devuelve "no". <br><br>  En este ap√©ndice, una declaraci√≥n falsa corresponde a una palabra no v√°lida que el corrector ortogr√°fico acepta sin darse cuenta.  Tales errores no hicieron que los correctores ortogr√°ficos fueran ideales.  Sin embargo, a principios de la d√©cada de 1970, el espacio val√≠a su peso en oro, por lo que usar filtros Bloom en ese momento era una estrategia de ganar-ganar. <br><br>  <b>Contrase√±as prohibidas</b>  Una aplicaci√≥n antigua que sigue siendo v√°lida hasta el d√≠a de hoy rastrea las contrase√±as prohibidas, contrase√±as que son demasiado comunes o demasiado f√°ciles de adivinar.  Inicialmente, todas las contrase√±as prohibidas se insertan en el filtro Bloom;  se pueden insertar contrase√±as prohibidas adicionales m√°s adelante, seg√∫n sea necesario.  Cuando un usuario intenta establecer o restablecer su contrase√±a, el sistema busca la contrase√±a propuesta en el filtro Bloom.  Si la b√∫squeda devuelve "s√≠", se le solicita al usuario que intente nuevamente con una contrase√±a diferente.  Aqu√≠, una declaraci√≥n falsa se traduce en una contrase√±a segura, que el sistema rechaza. <br><br>  Siempre que la tasa de error no sea demasiado alta, digamos no m√°s de 1% o 0.1%, esto no importa mucho.  De vez en cuando, algunos usuarios necesitar√°n un intento adicional para encontrar una contrase√±a aceptable para el sistema. <br><br>  <b>Enrutadores de internet</b> .  Varias de las impresionantes aplicaciones actuales de los filtros Bloom tienen lugar en lo profundo de Internet, donde los paquetes de datos pasan a trav√©s de enrutadores con velocidad de transmisi√≥n.  Hay muchas razones por las que un enrutador puede querer recordar r√°pidamente lo que vio en el pasado.  Por ejemplo, un enrutador puede querer encontrar la direcci√≥n IP de origen de un paquete en la lista de direcciones IP bloqueadas, rastrear el contenido de la memoria cach√© para evitar vistas falsas de la memoria cach√© o mantener estad√≠sticas que ayuden a identificar un ataque de red de denegaci√≥n de servicio.  La velocidad de llegada de paquetes requiere vistas s√∫per r√°pidas, y la memoria limitada del enrutador hace que el espacio valga su peso en oro.  Estas aplicaciones son administradas directamente por el filtro Bloom. <br><br><h3>  12.5.3.  Implementaci√≥n </h3><br>  Mirando dentro del filtro Bloom, puede ver una implementaci√≥n elegante.  La estructura de datos admite una cadena de n bits o, del mismo modo, una matriz A de longitud n en la que cada elemento es 0 o 1. (Todos los elementos se inicializan a cero). Esta estructura tambi√©n utiliza m funciones hash h1, h2, ..., hm , mientras que cada uno asigna el universo U de todas las claves posibles al conjunto {0, 1, 2, ..., n - 1} de posiciones en la matriz.  El par√°metro m es proporcional al n√∫mero de bits utilizados por el filtro Bloom para la inserci√≥n y, como regla, es una peque√±a constante (por ejemplo, 5). <br><br>  Cada vez que se inserta una clave en un filtro Bloom, cada una de las funciones m hash establece un indicador y establece el bit correspondiente de la matriz A en 1. <br><br><blockquote>  FILTRO DE BLOOM: INSERTAR (EN LLAVE) <br><br><pre><code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i = <span class="hljs-number"><span class="hljs-number">1</span></span> to m <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> A[hi(k)] := <span class="hljs-number"><span class="hljs-number">1</span></span></code> </pre> </blockquote><br>  Por ejemplo, si m = 3 y h1 (k) = 23, h2 (k) = 17 y h3 (k) = 5, la inserci√≥n de k hace que los bits 5, 17 y 23 de la matriz se establezcan iguales 1 (Fig. 12.5). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ma/-d/zf/ma-dzftjbgtmytk1uoelbb0q17o.png" alt="imagen"></div><br>  En la operaci√≥n Ver, el filtro Bloom busca la huella digital que podr√≠a haber quedado en la inserci√≥n k. <br><br><blockquote>  FILTRO DE BLOOM: VER (TECLA CLAVE) <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i = <span class="hljs-number"><span class="hljs-number">1</span></span> to m <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> A [hi (k)] = <span class="hljs-number"><span class="hljs-number">0</span></span> then <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ¬´¬ª <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ¬´¬ª</code> </pre> </blockquote><br>  Ahora podemos ver por qu√© los filtros Bloom no pueden sufrir falsos negativos.  Cuando se inserta la clave k, los m bits correspondientes se establecen en 1. Durante la vida √∫til del filtro Bloom, los bits pueden cambiar su valor de 0 a 1, pero no al rev√©s.  Por lo tanto, estos m bits permanecen 1 para siempre.  Se garantiza que cada operaci√≥n View k posterior devolver√° la respuesta correcta de yes. <br><br>  Tambi√©n podemos ver c√≥mo surgen declaraciones falsas.  Suponga que m = 3 y las cuatro teclas k1, k2, k3, k4 tienen los siguientes valores hash: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/m0/uo/7r/m0uo7rbq7ewvpqhhmpvdmx8pfs4.png" alt="imagen"></div><br>  Supongamos que insertamos k1, k2, k3 y k4 en un filtro Bloom (Figura 12.6).  Estas tres inserciones conducen a un total de nueve bits a 1, incluidos tres bits en la huella digital de la clave k1 (5, 17 y 23).  En este punto, el filtro Bloom ya no puede distinguir si se insert√≥ o no la clave k1.  Incluso si k1 no se insert√≥ en el filtro, la b√∫squeda devolver√° "s√≠", que es una declaraci√≥n falsa. <br><br>  Intuitivamente, podemos suponer que con un aumento en el tama√±o n del filtro Bloom, el n√∫mero de superposiciones entre las huellas digitales de diferentes teclas deber√≠a disminuir, lo que, a su vez, conduce a un menor n√∫mero de declaraciones falsas.  Pero el objetivo principal del filtro Bloom es ahorrar espacio.  ¬øHay un t√©rmino medio donde tanto n como la frecuencia de las declaraciones falsas son simult√°neamente peque√±as?  La respuesta no es obvia y requiere un an√°lisis matem√°tico realizado en la siguiente secci√≥n. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/gz/ib/_o/gzib_oomyz17bbrtney0kyxiru4.png" alt="imagen"></div><br><br>  ¬ªSe puede encontrar m√°s informaci√≥n sobre el libro en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">el sitio web del editor</a> <br>  ¬ª <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Contenidos</a> <br>  ¬ª <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Extracto</a> <br><br>  Para Khabrozhiteley 20% de descuento en el cup√≥n - <b>Algoritmos</b> <br>  Tras el pago de la versi√≥n en papel del libro, se env√≠a un libro electr√≥nico por correo electr√≥nico. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/461039/">https://habr.com/ru/post/461039/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../461029/index.html">Un lago de datos de marketing: desde tablas monstruosas hasta informes y visualizaciones</a></li>
<li><a href="../461031/index.html">Conectamos mapas en l√≠nea al navegador en el tel√©fono inteligente. Parte 1 - mapas r√°ster est√°ndar</a></li>
<li><a href="../461033/index.html">¬øDe d√≥nde viene esta configuraci√≥n? [Debian / Ubuntu]</a></li>
<li><a href="../461035/index.html">Episodios instructivos de la serie Silicon Valley (Temporada 1)</a></li>
<li><a href="../461037/index.html">Y aqu√≠ estoy "real"</a></li>
<li><a href="../461041/index.html">¬øRedondeado o de √°ngulo agudo?</a></li>
<li><a href="../461043/index.html">Gesti√≥n de conflictos en un equipo: ¬øun acto de equilibrio o una necesidad vital?</a></li>
<li><a href="../461045/index.html">Obtenga un extracto de Rosreestr a trav√©s de FSIS USRN y python. Parte 1</a></li>
<li><a href="../461047/index.html">Escribir o no escribir. Cartas a las autoridades durante los eventos.</a></li>
<li><a href="../461049/index.html">ONYX BOOX Faust - El que busca no est√° obligado a vagar</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>