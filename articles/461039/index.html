<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>✈️ 🎑 💗 El libro "Algoritmo perfecto. Algoritmos gráficos y estructuras de datos " 😾 🗼 🙎🏼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hola habrozhiteli! Los algoritmos son el corazón y el alma de la informática. No puede prescindir de ellos, están en todas partes, desde el enrutamien...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>El libro "Algoritmo perfecto. Algoritmos gráficos y estructuras de datos "</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/piter/blog/461039/"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><img src="https://habrastorage.org/webt/e5/2z/76/e52z769bpr1nib4vz_bij_xvkgo.jpeg" align="left" alt="imagen"></a>  Hola habrozhiteli!  Los algoritmos son el corazón y el alma de la informática.  No puede prescindir de ellos, están en todas partes, desde el enrutamiento de la red y los cálculos genómicos hasta la criptografía y el aprendizaje automático.  El "Algoritmo perfecto" lo convertirá en un verdadero profesional que establecerá tareas y las resolverá magistralmente tanto en la vida como en una entrevista al contratar cualquier empresa de TI. <br><br>  En el segundo libro, Tim Rafgarden, el gurú de los algoritmos, habla sobre la búsqueda de gráficos y su aplicación, el algoritmo de búsqueda de la ruta más corta y el uso e implementación de algunas estructuras de datos: montones, árboles de búsqueda, tablas hash y el filtro Bloom. <br><br>  Esta publicación presenta un extracto de Bloom Filters: The Basics. <br><a name="habracut"></a><br><h3>  ¿De qué trata este libro? </h3><br>  La segunda parte del libro "Algoritmo perfecto" es un curso introductorio sobre los conceptos básicos de alfabetización sobre los siguientes tres temas. <br><br>  <b>Búsqueda gráfica y aplicaciones</b> .  Los gráficos modelan varios tipos diferentes de redes, incluyendo carreteras, comunicación, redes sociales y redes de dependencias entre tareas.  Los gráficos pueden ser complejos, pero hay algunas primitivas increíblemente rápidas para hablar sobre la estructura de los gráficos.  Comenzaremos con algoritmos de búsqueda de gráficos de tiempo lineal, desde aplicaciones que van desde el análisis de redes hasta la construcción de una secuencia de operaciones. <br><br>  <b>Los caminos más cortos</b> .  En el problema de la ruta más corta, el objetivo es calcular la mejor ruta en la red desde el punto A hasta el punto B. Esta tarea tiene aplicaciones obvias, como el cálculo de rutas de tráfico, y también ocurre en forma encubierta en muchas otras tareas universales.  Vamos a generalizar uno de nuestros algoritmos de búsqueda de gráficos y llegaremos al famoso algoritmo de búsqueda de ruta más corta de Dijkstra. <br><br>  <b>Estructuras de datos</b> .  Este libro lo convertirá en un usuario altamente educado de varias estructuras de datos diferentes diseñadas para admitir un conjunto de objetos en evolución con sus claves asociadas.  El objetivo principal es desarrollar una intuición sobre qué estructura de datos es adecuada para su aplicación.  Secciones adicionales proporcionan pautas para implementar estas estructuras de datos desde cero. <br><br>  Primero, discutimos los montones que pueden identificar rápidamente el objeto almacenado con la clave más pequeña, y también son útiles para ordenar, implementar una cola prioritaria e implementar el algoritmo casi lineal-temporal de Dijkstra.  Los árboles de búsqueda mantienen el orden completo de las claves en los objetos almacenados y admiten una gama aún más amplia de operaciones.  Las tablas hash están optimizadas para operaciones de búsqueda ultrarrápidas y están muy extendidas en los programas modernos.  También observamos el filtro Bloom, un pariente cercano de la tabla hash, que usa menos espacio debido a errores aleatorios. <br><br>  Puede familiarizarse con el contenido del libro con más detalle en las secciones "Conclusiones", que completan cada capítulo e identifican los puntos más importantes.  Las secciones del libro, marcadas con un asterisco, son las más avanzadas en términos del nivel de información presentada.  Si el libro está diseñado para una familiarización superficial con el tema, entonces el lector puede omitirlos sin perder la integridad de lo escrito. <br><br>  <b>Temas cubiertos en otras tres partes</b> .  La primera parte del libro "Algoritmo perfecto.  Fundamentos "cubre las notaciones asintóticas (la notación O-large y sus parientes cercanos), los algoritmos de" divide y vencerás "y el teorema principal de relación de recurrencia: el método principal, la clasificación rápida aleatoria y su análisis, y los algoritmos de selección lineal-temporal.  La tercera parte se ocupa de algoritmos codiciosos (planificación, árboles de expansión mínima, agrupación, códigos Huffman) y programación dinámica (problema de mochila, alineación de secuencias, caminos más cortos, árboles de búsqueda óptimos).  La cuarta parte está dedicada a la integridad de NP, lo que significa para un diseñador de algoritmos y estrategias para resolver problemas computacionalmente insolubles, incluido el análisis heurístico y la búsqueda local. <br><br><h3>  12.5  Bloom Filters: The Basics </h3><br>  Los filtros Bloom son parientes cercanos de las tablas hash.  Son muy compactos, pero periódicamente cometen errores.  Esta sección describe cómo los filtros Bloom son buenos y cómo se implementan, mientras que la sección 12.6 establece una curva de compromiso entre la cantidad de espacio utilizado por el filtro y su tasa de error. <br><br><h3>  12.5.1.  Operaciones soportadas </h3><br>  La razón de la existencia de los filtros Bloom es esencialmente la misma que la de una tabla hash: operaciones de inserción y visualización súper rápidas, gracias a las cuales puede recordar rápidamente lo que vio y lo que no.  ¿Por qué debería molestarnos una estructura de datos diferente con el mismo conjunto de operaciones?  Debido a que los filtros Bloom son preferibles a las tablas hash en aplicaciones en las que el espacio vale su peso en oro, y un error aleatorio no es un obstáculo para la transacción. <br><br>  Al igual que las tablas hash con direccionamiento abierto, los filtros Bloom son mucho más fáciles de implementar e imaginar en su mente cuando solo admiten operaciones Insertar y Ver (y sin la operación Eliminar).  Nos centraremos en este caso. <br><br><blockquote>  FILTROS DE FLUJO: OPERACIONES COMPATIBLES <br><br>  Vista: con la tecla k, devuelve "sí" si k se insertó previamente en el filtro Bloom, y "no" en caso contrario. <br>  Pegar: agregue una nueva clave k al filtro Bloom. </blockquote><br>  Los filtros Bloom son muy eficientes espacialmente;  normalmente, pueden requerir solo 8 bits por inserto.  ¡Esto es increíble, ya que 8 bits son completamente insuficientes para recordar incluso una clave de 32 bits o un puntero a un objeto!  Por esta razón, la operación Ver en el filtro Bloom devuelve solo la respuesta "sí" / "no", mientras que en la tabla hash, esta operación devuelve un puntero al objeto deseado (si se encuentra).  Es por eso que la operación Insertar ahora solo acepta la clave, y no el (puntero) del objeto. <br><br>  A diferencia de todas las otras estructuras de datos que estudiamos, los filtros de Bloom pueden estar equivocados.  Hay dos tipos de errores: falsos negativos cuando la operación Ver devuelve "falso" incluso si la clave solicitada ya se ha insertado anteriormente, y declaraciones falsas (o positivas) cuando la operación Ver devuelve "verdadero", aunque la clave solicitada aún no se ha insertado en el pasado .  En la sección 12.5.3 veremos que los filtros Bloom básicos nunca sufren falsos negativos, pero pueden tener "elementos fantasmas" en forma de declaraciones falsas.  La Sección 12.6 muestra que la frecuencia de las declaraciones falsas se puede controlar ajustando adecuadamente el uso del espacio.  Una implementación típica de un filtro Bloom puede tener una tasa de error de aproximadamente 1% o 0.1%. <br><br>  Los tiempos de ejecución para las operaciones Insertar y Ver son tan rápidos como en la tabla hash.  Y aún mejor, se garantiza que estas operaciones se realizarán en tiempo constante, independientemente de la implementación del filtro Bloom y el conjunto de datos1.  Sin embargo, la implementación y el conjunto de datos afectan la tasa de error del filtro. <br><br>  Para resumir las ventajas y desventajas de los filtros Bloom sobre las tablas hash: <br><br><blockquote>  FILTRO DE FLUJO CONTRA LAS TABLAS DE HASH <br><br>  1. Pros: más espacialmente efectivo. <br><br>  2. Pros: operaciones garantizadas de tiempo permanente para cada conjunto de datos. <br><br>  3. Contras: no puede almacenar punteros a objetos. <br><br>  4. Contras: eliminaciones más complejas en comparación con una tabla hash con un embrague. <br><br>  5. Contras: probabilidad distinta de cero de una declaración falsa. </blockquote><br>  La lista de indicadores para los filtros básicos de Bloom es la siguiente. <br><br>  Tabla 12.4.  Filtros básicos de Bloom: operaciones compatibles y su tiempo de ejecución.  El signo de la daga (†) indica que la operación Ver tiene una probabilidad controlable pero no nula de afirmaciones falsas <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/j2/s0/bc/j2s0bcwhevqsy2-scnfyznyywpi.png" alt="imagen"></div><br>  Los filtros Bloom deben usarse en lugar de tablas hash en aplicaciones en las que sus ventajas son importantes y sus desventajas no son un obstáculo para la transacción. <br><br><blockquote>  CUANDO UTILIZAR EL FILTRO DE FLORACIÓN <br><br>  Si una aplicación requiere una búsqueda rápida con un conjunto de objetos en evolución dinámica, el espacio vale su peso en oro y una pequeña cantidad aceptable de afirmaciones falsas, entonces el filtro Bloom suele ser la estructura de datos preferida. </blockquote><br><h3>  12.5.2.  Aplicaciones </h3><br>  A continuación, hay tres usos con escaneos repetidos, donde ahorrar espacio puede ser importante, y las declaraciones falsas no son un obstáculo para la transacción. <br><br>  Correctores de ortografía.  En la década de 1970, los filtros Bloom se usaban para implementar correctores ortográficos, correctores ortográficos.  En la etapa de preprocesamiento, cada palabra del diccionario se inserta en el filtro Bloom.  La ortografía de un documento se reduce a una sola operación: observe una palabra en un documento y marque las palabras para las que esta operación devuelve "no". <br><br>  En este apéndice, una declaración falsa corresponde a una palabra no válida que el corrector ortográfico acepta sin darse cuenta.  Tales errores no hicieron que los correctores ortográficos fueran ideales.  Sin embargo, a principios de la década de 1970, el espacio valía su peso en oro, por lo que usar filtros Bloom en ese momento era una estrategia de ganar-ganar. <br><br>  <b>Contraseñas prohibidas</b>  Una aplicación antigua que sigue siendo válida hasta el día de hoy rastrea las contraseñas prohibidas, contraseñas que son demasiado comunes o demasiado fáciles de adivinar.  Inicialmente, todas las contraseñas prohibidas se insertan en el filtro Bloom;  se pueden insertar contraseñas prohibidas adicionales más adelante, según sea necesario.  Cuando un usuario intenta establecer o restablecer su contraseña, el sistema busca la contraseña propuesta en el filtro Bloom.  Si la búsqueda devuelve "sí", se le solicita al usuario que intente nuevamente con una contraseña diferente.  Aquí, una declaración falsa se traduce en una contraseña segura, que el sistema rechaza. <br><br>  Siempre que la tasa de error no sea demasiado alta, digamos no más de 1% o 0.1%, esto no importa mucho.  De vez en cuando, algunos usuarios necesitarán un intento adicional para encontrar una contraseña aceptable para el sistema. <br><br>  <b>Enrutadores de internet</b> .  Varias de las impresionantes aplicaciones actuales de los filtros Bloom tienen lugar en lo profundo de Internet, donde los paquetes de datos pasan a través de enrutadores con velocidad de transmisión.  Hay muchas razones por las que un enrutador puede querer recordar rápidamente lo que vio en el pasado.  Por ejemplo, un enrutador puede querer encontrar la dirección IP de origen de un paquete en la lista de direcciones IP bloqueadas, rastrear el contenido de la memoria caché para evitar vistas falsas de la memoria caché o mantener estadísticas que ayuden a identificar un ataque de red de denegación de servicio.  La velocidad de llegada de paquetes requiere vistas súper rápidas, y la memoria limitada del enrutador hace que el espacio valga su peso en oro.  Estas aplicaciones son administradas directamente por el filtro Bloom. <br><br><h3>  12.5.3.  Implementación </h3><br>  Mirando dentro del filtro Bloom, puede ver una implementación elegante.  La estructura de datos admite una cadena de n bits o, del mismo modo, una matriz A de longitud n en la que cada elemento es 0 o 1. (Todos los elementos se inicializan a cero). Esta estructura también utiliza m funciones hash h1, h2, ..., hm , mientras que cada uno asigna el universo U de todas las claves posibles al conjunto {0, 1, 2, ..., n - 1} de posiciones en la matriz.  El parámetro m es proporcional al número de bits utilizados por el filtro Bloom para la inserción y, como regla, es una pequeña constante (por ejemplo, 5). <br><br>  Cada vez que se inserta una clave en un filtro Bloom, cada una de las funciones m hash establece un indicador y establece el bit correspondiente de la matriz A en 1. <br><br><blockquote>  FILTRO DE BLOOM: INSERTAR (EN LLAVE) <br><br><pre><code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i = <span class="hljs-number"><span class="hljs-number">1</span></span> to m <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> A[hi(k)] := <span class="hljs-number"><span class="hljs-number">1</span></span></code> </pre> </blockquote><br>  Por ejemplo, si m = 3 y h1 (k) = 23, h2 (k) = 17 y h3 (k) = 5, la inserción de k hace que los bits 5, 17 y 23 de la matriz se establezcan iguales 1 (Fig. 12.5). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ma/-d/zf/ma-dzftjbgtmytk1uoelbb0q17o.png" alt="imagen"></div><br>  En la operación Ver, el filtro Bloom busca la huella digital que podría haber quedado en la inserción k. <br><br><blockquote>  FILTRO DE BLOOM: VER (TECLA CLAVE) <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i = <span class="hljs-number"><span class="hljs-number">1</span></span> to m <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> A [hi (k)] = <span class="hljs-number"><span class="hljs-number">0</span></span> then <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> «» <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> «»</code> </pre> </blockquote><br>  Ahora podemos ver por qué los filtros Bloom no pueden sufrir falsos negativos.  Cuando se inserta la clave k, los m bits correspondientes se establecen en 1. Durante la vida útil del filtro Bloom, los bits pueden cambiar su valor de 0 a 1, pero no al revés.  Por lo tanto, estos m bits permanecen 1 para siempre.  Se garantiza que cada operación View k posterior devolverá la respuesta correcta de yes. <br><br>  También podemos ver cómo surgen declaraciones falsas.  Suponga que m = 3 y las cuatro teclas k1, k2, k3, k4 tienen los siguientes valores hash: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/m0/uo/7r/m0uo7rbq7ewvpqhhmpvdmx8pfs4.png" alt="imagen"></div><br>  Supongamos que insertamos k1, k2, k3 y k4 en un filtro Bloom (Figura 12.6).  Estas tres inserciones conducen a un total de nueve bits a 1, incluidos tres bits en la huella digital de la clave k1 (5, 17 y 23).  En este punto, el filtro Bloom ya no puede distinguir si se insertó o no la clave k1.  Incluso si k1 no se insertó en el filtro, la búsqueda devolverá "sí", que es una declaración falsa. <br><br>  Intuitivamente, podemos suponer que con un aumento en el tamaño n del filtro Bloom, el número de superposiciones entre las huellas digitales de diferentes teclas debería disminuir, lo que, a su vez, conduce a un menor número de declaraciones falsas.  Pero el objetivo principal del filtro Bloom es ahorrar espacio.  ¿Hay un término medio donde tanto n como la frecuencia de las declaraciones falsas son simultáneamente pequeñas?  La respuesta no es obvia y requiere un análisis matemático realizado en la siguiente sección. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/gz/ib/_o/gzib_oomyz17bbrtney0kyxiru4.png" alt="imagen"></div><br><br>  »Se puede encontrar más información sobre el libro en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">el sitio web del editor</a> <br>  » <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Contenidos</a> <br>  » <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Extracto</a> <br><br>  Para Khabrozhiteley 20% de descuento en el cupón - <b>Algoritmos</b> <br>  Tras el pago de la versión en papel del libro, se envía un libro electrónico por correo electrónico. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/461039/">https://habr.com/ru/post/461039/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../461029/index.html">Un lago de datos de marketing: desde tablas monstruosas hasta informes y visualizaciones</a></li>
<li><a href="../461031/index.html">Conectamos mapas en línea al navegador en el teléfono inteligente. Parte 1 - mapas ráster estándar</a></li>
<li><a href="../461033/index.html">¿De dónde viene esta configuración? [Debian / Ubuntu]</a></li>
<li><a href="../461035/index.html">Episodios instructivos de la serie Silicon Valley (Temporada 1)</a></li>
<li><a href="../461037/index.html">Y aquí estoy "real"</a></li>
<li><a href="../461041/index.html">¿Redondeado o de ángulo agudo?</a></li>
<li><a href="../461043/index.html">Gestión de conflictos en un equipo: ¿un acto de equilibrio o una necesidad vital?</a></li>
<li><a href="../461045/index.html">Obtenga un extracto de Rosreestr a través de FSIS USRN y python. Parte 1</a></li>
<li><a href="../461047/index.html">Escribir o no escribir. Cartas a las autoridades durante los eventos.</a></li>
<li><a href="../461049/index.html">ONYX BOOX Faust - El que busca no está obligado a vagar</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>