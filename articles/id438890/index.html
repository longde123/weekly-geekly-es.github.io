<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🌊 👩🏿‍🤝‍👩🏽 👩‍👩‍👧‍👦 Postgres dalam retrospeksi 🚊 👨‍👨‍👦‍👦 🔦</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Kami memberi perhatian Anda terjemahan dari artikel Joseph Hellerstein "Melihat Kembali di Postgres" , yang diterbitkan di bawah Creative Commons, afi...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Postgres dalam retrospeksi</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/postgrespro/blog/438890/">  <em>Kami memberi perhatian Anda terjemahan dari artikel <strong>Joseph Hellerstein "Melihat Kembali di Postgres"</strong> , yang diterbitkan di bawah Creative Commons, <strong>afirmasi hak cipta</strong> internasional versi 4.0 (CC-BY 4.0).</em>  <em>Penulis berhak untuk mendistribusikan karya ini di situs web pribadi dan perusahaan dengan tautan yang sesuai ke sumbernya.</em> <br><br>  <em>Terjemahan dibuat oleh Elena Indrupskaya.</em>  <em>Saya akan menambahkan dari diri saya bahwa "seorang programmer yang sangat ingin membangun sistem dengan multi-versi" tampaknya adalah Vadim Mikheev, tetapi kita semua tahu "sukarelawan dari Rusia" yang menulis ulang GiST.</em> <br><br><h1>  Anotasi </h1><br>  Ini adalah ingatan akan proyek Postgres, dijalankan di University of California di Berkeley dan dipimpin oleh Mike Stonebraker dari pertengahan 1980-an hingga pertengahan 1990-an.  Sebagai salah satu dari banyak kenangan pribadi dan sejarah, artikel ini diminta untuk buku [ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bro19</a> ] tentang Penghargaan Turing Stonebreaker.  Oleh karena itu, fokus artikel adalah pada peran utama Stonebreaker dan pemikirannya tentang desain.  Tetapi Stonebreaker tidak pernah menjadi programmer dan tidak mengganggu tim pengembangannya.  Basis kode Postgres adalah hasil kerja tim mahasiswa yang brilian dan kadang-kadang programmer universitas penuh waktu yang memiliki pengalaman sedikit lebih banyak (dan hanya gaji yang sedikit lebih besar) daripada mahasiswa.  Saya cukup beruntung untuk bergabung dengan tim ini sebagai siswa di tahun-tahun terakhir proyek ini.  Saya menerima bahan yang berguna untuk artikel ini dari beberapa siswa yang lebih tua yang terlibat dalam proyek, tetapi kesalahan atau kelalaian adalah milik saya.  Jika Anda melihat ada di antara mereka, silakan hubungi saya dan saya akan mencoba memperbaikinya. <br><a name="habracut"></a><br><h1>  1. Pendahuluan </h1><br>  Postgres adalah proyek paling ambisius Michael Stonebreaker - upayanya yang serius untuk menciptakan sistem basis data universal.  Selama satu dekade, proyek ini telah melahirkan lebih banyak artikel, PhD, profesor, dan perusahaan daripada aktivitas Stonebreaker lainnya.  Proyek ini juga mencakup lebih banyak bidang teknis daripada sistem lain yang ia bangun.  Terlepas dari risiko inheren sebesar ini, Postgres juga menjadi artefak perangkat lunak paling sukses yang keluar dari tim peneliti Stonebreaker, dan kontribusinya yang utama pada open source.  Ini adalah contoh dari "sistem kedua" [ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bro75</a> ] yang telah berhasil.  Pada saat penulisan, lebih dari tiga puluh tahun sejak awal proyek, sistem open source PostgreSQL adalah sistem basis data sumber terbuka independen paling populer di dunia dan sistem basis data keempat yang paling populer.  Sementara itu, perusahaan yang dibuat dari Postgres menghasilkan total lebih dari $ 2,6 miliar (biaya perolehan).  Dengan ukuran apa pun, visi Postgres Stonebreaker memiliki resonansi abadi yang besar. <br><br><h2>  1.1.  Latar belakang </h2><br>  Stonebreaker adalah sukses besar di awal karirnya dengan proyek penelitian Ingres Berkeley [ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">SHWK76</a> ] dan startup berikutnya, yang ia dirikan bersama Larry Rowe dan Eugene Wong: Relational Technology, Inc.  (RTI). <br><br>  Ketika RTI dikembangkan pada awal 1980-an, Stonebreaker mulai bekerja untuk mendukung tipe data dalam DBMS yang melampaui baris dan kolom tradisional model relasional Codd (Edgar Frank Codd).  Contoh yang memotivasi pada waktu itu adalah kebutuhan akan basis data untuk mendukung perangkat desain berbantuan komputer (CAD) untuk industri mikroelektronika.  Dalam artikel 1983 oleh Stonebreaker dan mahasiswa, Brad Rubenstein dan Antonin Guttman menjelaskan betapa industri ini perlu mendukung "tipe data baru seperti poligon, persegi panjang, string teks, dll.", " pencarian spasial yang efektif "," kendala integritas kompleks ", serta" desain hierarki dan representasi ganda "dalam struktur fisik yang sama [ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">SRG83</a> ].  Dengan motivasi ini, kelompok mulai bekerja pada pengindeksan (termasuk menggunakan Guttman R-tree untuk pengindeksan spasial [ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Gut84</a> ]) dan tentang menambahkan tipe data abstrak (ADT) ke sistem database relasional.  Pada saat itu, ADT adalah konstruksi bahasa pemrograman baru yang populer, yang pertama kali diperkenalkan oleh Barbara Liskov, kemudian penerima hadiah Turing, dan diteliti dalam pemrograman aplikasi basis data oleh kolaborator Stonebreaker baru, Larry Rowe.  Sebuah artikel dalam Catatan SIGMOD 1983 [ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">OFS83</a> ] Stonebreaker dan siswa James Ong dan Dennis Fogg menggambarkan studi konsep ini dalam ekstensi Ingres yang disebut ADT-Ingres, yang menggabungkan banyak konsep presentasi yang dipelajari lebih dalam dan dengan dukungan sistem yang lebih baik di Postgres. <br><br><h1>  2. Postgres: informasi umum </h1><br>  Seperti namanya, Postgres adalah Post-Ingres: sistem yang dirancang untuk mengambil apa yang bisa dilakukan Ingres dan melampauinya.  Ciri khas Postgres adalah pengenalan apa yang pada akhirnya disebut sebagai objek-relasional dari basis data: dukungan untuk konsep pemrograman berorientasi objek dalam model data dan bahasa query deklaratif dari sistem basis data.  Tetapi Stonebreaker juga berencana untuk memecahkan sejumlah masalah teknologi lain yang tidak bergantung pada dukungan berorientasi objek di Postgres, seperti aturan basis data aktif, data berversi, penyimpanan tersier, dan konkurensi. <br><br>  Dua artikel ditulis pada desain Postgres: deskripsi desain awal pada tahun 1986 SIGMOD [ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">SR86</a> ] dan deskripsi antara dalam CACM 1991 [ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">SK91</a> ].  Proyek penelitian Postgres secara bertahap menjadi sia-sia pada tahun 1992 dengan fondasi Illustra, sebuah startup startup yang melibatkan Stonebreaker, mahasiswa pascasarjana Wei Hong dan kemudian menjadi ketua programer Jeff Meredith.  Dalam daftar di bawah ini, peluang yang disebutkan dalam artikel 1986 ditandai dengan tanda bintang *, dan peluang dari artikel 1991, yang tidak ada dalam artikel 1986, ditandai dengan belati <sup>†</sup> .  Tugas-tugas lain yang tercantum di bawah ini diambil dalam sistem dan literatur penelitian, tetapi mereka tidak ditemukan dalam spesifikasi desain.  Banyak dari topik ini dibahas di Postgres jauh sebelum dipelajari atau diciptakan kembali oleh orang lain.  Dalam banyak kasus, Postgres terlalu maju dari masanya, dan minat pada topik semakin meluas, dari perspektif modern. <br><br><ol><li>  Dukungan ADT dalam sistem basis data <br><ul><li>  Objek kompleks (mis., Data bersarang atau data formulir non-pertama-normal (bentuk non-pertama-normal - NF2)) * </li><li>  Jenis dan Fungsi Data Abstrak Kustom * </li><li>  Metode akses yang dapat diperluas untuk tipe data baru * </li><li>  Pemrosesan query yang dioptimalkan dengan fitur yang ditentukan pengguna yang mahal </li></ul></li><li>  Database aktif dan sistem aturan (pemicu, peringatan) * <br><ul><li>  Aturan diterapkan sebagai permintaan penulisan ulang <sup>†</sup> </li><li>  Aturan diterapkan sebagai pemicu tingkat perekaman <sup>†</sup> </li></ul></li><li>  Penyimpanan dan Pemulihan Berbasis Log <br><ul><li>  Kode pemulihan kompleksitas yang berkurang yang memperlakukan log sebagai data *, menggunakan memori yang tidak mudah menguap untuk status komit <sup>†</sup> </li><li>  Penyimpanan non-ditulis ulang dan pertanyaan temporal <sup>†</sup> </li></ul></li><li>  Dukungan untuk teknologi penyimpanan dalam yang baru, terutama disk optik * </li><li>  Dukungan untuk multiprosesor dan prosesor khusus * </li><li>  Dukungan untuk berbagai model bahasa <br><ul><li>  Perubahan minimal pada model relasional dan dukungan untuk pertanyaan deklaratif * </li><li>  Akses ke "jalur cepat" dari API internal yang melewati bahasa permintaan <sup>†</sup> </li><li>  Multilingualisme <sup>†</sup> </li></ul></li></ol><br>  Kami akan membahas secara singkat kontribusi Postgres untuk setiap item ini sehubungan dengan pekerjaan selanjutnya di bidang komputasi. <br><br><h2>  2.1.  Dukungan ADT dalam sistem basis data </h2><br>  Tujuan Postgres yang jelas adalah untuk mendukung properti-objek relasional baru: memperluas teknologi database untuk memberikan manfaat dari pemrosesan query relasional dan pemrograman berorientasi objek.  Seiring waktu, konsep objek-relasional yang pertama kali muncul di Postgres menjadi fungsionalitas standar di sebagian besar sistem database modern. <br><br><h3>  2.1.1.  Benda kompleks </h3><br>  Cukup sering, data direpresentasikan sebagai entitas bersarang atau "objek".  Contoh klasik adalah pesanan pembelian, yang memiliki serangkaian produk tertanam, jumlah dan harganya.  Agama pemodelan relasional menentukan bahwa data tersebut harus direstrukturisasi dan disimpan dalam format tanpa bersarang, menggunakan beberapa tabel objek datar (pesanan, produk) dengan menghubungkan tabel relasi datar (product_in_order).  Alasan khas untuk perataan ini adalah mengurangi duplikasi data (karena produk dijelaskan secara berlebihan dalam banyak pesanan pembelian), yang, pada gilirannya, menghindari kompleksitas atau kesalahan saat memperbarui semua salinan yang berlebihan.  Tetapi dalam beberapa kasus, Anda ingin menyimpan subview, karena itu wajar untuk aplikasi (misalnya, mekanisme tata letak sirkuit dalam CAD), dan pembaruan jarang terjadi.  Debat tentang pemodelan data ini setidaknya setua model relasional. <br><br>  Pendekatan utama Postgres adalah “duduk di dua kursi” dalam hal pemodelan data: Postgres menyimpan tabel sebagai tipe data “paling eksternal”, tetapi memungkinkan kolom memiliki tipe “kompleks”, termasuk tupel atau tabel bersarang.  Salah satu implementasi yang kurang umum, pertama kali diselidiki dalam prototipe ADT-Ingres, adalah untuk memungkinkan kolom tipe tabel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dideklarasikan secara</a> deklaratif sebagai definisi kueri: "Quel sebagai tipe data" [ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">SAHR84</a> ] <em>(Quel - bahasa permintaan Ingres. - Approx. Per. .)</em> . <br><br>  Topik dukungan "pasca-relasional" untuk pertanyaan deklaratif dan data yang disematkan telah muncul kembali selama bertahun-tahun, sering kali dihasilkan oleh perselisihan tentang mana yang lebih baik.  Selama masa Postgres pada 1980-an dan 1990-an, beberapa kelompok yang terlibat dalam database berorientasi objek mengambil ide ini dan mengembangkannya ke dalam bahasa OQL standar, yang kemudian tidak lagi digunakan. <br><br>  Pada pergantian milenium, pertanyaan deklaratif pada objek bersarang menjadi obsesi dengan penelitian untuk segmen komunitas pengembang basis data dalam bentuk basis data XML.  Bahasa XQuery yang dihasilkan (dipimpin oleh Don Chamberlin, persona dari SQL) diperlukan untuk mendukung objek kompleks dalam bahasa Postgel Postgres.  XQuery banyak digunakan dan banyak digunakan dalam industri, tetapi tidak pernah populer dengan pengguna.  Saat ini, konsep-konsep ini sedang diperiksa ulang dalam proyek bahasa query untuk model data JSON, populer di aplikasi berbasis browser.  Seperti OQL, dalam kelompok yang awalnya menolak permintaan deklaratif yang mendukung pemrograman berorientasi pengembang (gerakan "NoSQL"), bahasa-bahasa ini sering muncul sebagai tambahan terlambat hanya dari keinginan untuk menambahkan pertanyaan kembali ke sistem.  Pada saat yang sama, ketika Postgres tumbuh selama bertahun-tahun (dan pindah dari bahasa query Postquel ke versi SQL yang memenuhi banyak tujuan yang dipertimbangkan), itu termasuk dukungan untuk data yang disematkan, seperti XML dan JSON, dalam DBMS tujuan umum, tanpa memerlukan atau desain ulang yang signifikan.  Kontroversi berjalan dengan berbagai tingkat keberhasilan, dan pendekatan Postgres untuk memperluas struktur relasional menggunakan ekstensi untuk data bersarang telah berulang kali membuktikan dirinya sebagai keadaan akhir alami bagi semua pihak setelah argumen mereda. <br><br><h3>  2.1.2.  Jenis dan Fungsi Data Abstrak Kustom </h3><br>  Selain menyarankan tipe bersarang, Postgres mengajukan gagasan untuk memperkenalkan ADT yang buram dan dapat diperluas yang disimpan dalam database tetapi tidak diinterpretasikan oleh kernel.  Pada dasarnya, ini selalu menjadi bagian dari model relasional Codd: bilangan bulat dan string bersifat tradisional, tetapi pada kenyataannya model relasional mencakup semua tipe data atom dengan predikat.  Tugasnya adalah untuk menyediakan fleksibilitas matematis dalam perangkat lunak.  Untuk menggunakan kueri yang menafsirkan objek-objek ini dan memanipulasinya, seorang programmer aplikasi harus dapat mendaftarkan fungsi-fungsi yang didefinisikan pengguna (UDF) untuk tipe-tipe ini dalam sistem dan memanggil fungsi-fungsi ini dalam kueri.  Juga diinginkan bahwa fungsi agregat yang ditentukan pengguna (UDA) merangkum koleksi objek-objek ini dalam query.  Sistem database Postgres telah inovatif, secara komprehensif mendukung fitur-fitur ini. <br><br>  Mengapa menempatkan fungsi seperti itu dalam DBMS, daripada di aplikasi tingkat tinggi?  Jawaban khas untuk pertanyaan ini adalah keuntungan yang signifikan dalam kinerja kode yang ditempatkan pada data daripada "menarik" data ke kode.  Postgres menunjukkan bahwa ini cukup alami dalam lingkungan relasional: hanya perubahan kecil yang diperlukan dalam katalog metadata relasional dan mekanisme panggilan kode pihak ketiga yang dibuat, tetapi sintaks kueri, semantik, dan arsitektur sistem bekerja dengan sederhana dan elegan. <br><br>  Postgres sedikit lebih maju dalam mengeksplorasi fungsi ini.  Secara khusus, pada saat itu, komunitas riset basis data tidak terlalu khawatir tentang implikasi keamanan mengunduh kode tidak aman ke server.  Ini mulai dianggap sebagai masalah ketika teknologi diperhatikan dalam industri.  Stonebreaker membawa Postgres ke pasaran dalam startupnya Illustra, yang diperoleh Informix sebagian besar karena kemampuannya untuk mendukung paket ekstensi DataBlade, termasuk UDF.  Informix, dengan teknologi berbasis Postgres dan penawaran basis data paralel yang kuat, telah menjadi ancaman signifikan bagi Oracle.  Oracle telah banyak berinvestasi dalam pemasaran negatif risiko yang terkait dengan kemampuan Informix untuk menjalankan kode C pengguna yang "tidak aman".  Beberapa atribut kematian Informix untuk kampanye ini, meskipun penipuan keuangan Informix (dan penuntutan federal berikutnya CEO saat itu) tentu menghadirkan masalah yang lebih serius.  Sekarang, beberapa dekade kemudian, semua penyedia basis data utama mendukung fungsi kustom dalam satu atau beberapa bahasa, menggunakan teknologi baru untuk melindungi dari kerusakan server atau kerusakan data. <br><br>  Sementara itu, tumpukan teknologi dari data besar tahun 2000-an, termasuk fenomena MapReduce, yang “banyak sekali darahnya” oleh Stonebreaker dan David DeWitt [ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">DS08</a> ], adalah implementasi ulang gagasan Postgres - kode pengguna yang diposting sebagai bagian dari permintaan.  Tampaknya MapReduce sebagian besar menggabungkan ide pengembangan perangkat lunak Postgres dengan ide konkurensi dari sistem seperti Gamma dan Teradata, dengan beberapa inovasi kecil seputar memulai kembali proses permintaan beban kerja dengan skalabilitas yang ekstrem.  Startup berdasarkan Postgres, Greenplum dan Aster, sekitar 2007, menunjukkan bahwa paralelisasi Postgres dapat mengarah pada sesuatu yang jauh lebih fungsional dan praktis daripada MapReduce untuk sebagian besar pelanggan, tetapi pada tahun 2008 pasar masih belum siap untuk teknologi ini. .  Sekarang, pada tahun 2018, hampir setiap tumpukan data besar pada dasarnya menangani beban kerja SQL paralel dengan UDF, yang sangat mirip dengan desain yang pertama kali digunakan oleh Stonebreaker dan tim di Postgres. <br><br><h3>  2.1.3.  Metode Akses yang Dapat Diperpanjang untuk Jenis Data Baru </h3><br>  Database relasional dikembangkan sekitar waktu yang sama dengan pohon B pada awal 1970-an, dan pohon B membantu memberi Codd mimpi "kebebasan dari penyimpanan data fisik": pengindeksan dengan pohon B memberikan tingkat tipuan yang Adaptasi menata ulang penyimpanan fisik tanpa memerlukan perubahan aplikasi.  Keterbatasan utama B-tree dan struktur yang terkait adalah bahwa mereka hanya mendukung pencarian kesetaraan dan pertanyaan dalam rentang satu dimensi.  Tetapi bagaimana jika Anda memiliki kueri rentang 2 dimensi yang khas untuk aplikasi pemetaan dan CAD?  Masalah ini diketahui selama Postgres, dan R-tree [ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Gut84</a> ], yang dikembangkan oleh Antonin Guttman dalam kelompok Stonebreaker, adalah salah satu indeks baru paling sukses yang dirancang untuk memecahkan masalah ini dalam praktiknya.  Namun, penemuan struktur indeks tidak memecahkan masalah mendukung rentang multidimensi dalam DBMS untuk sistem yang kompleks.  Ada banyak pertanyaan.  Bisakah Anda dengan mudah menambahkan metode akses, seperti R-tree, ke DBMS Anda?  Bisakah Anda mengajarkan pengoptimal untuk memahami bahwa metode akses yang ditentukan akan berguna untuk pertanyaan tertentu?  Bisakah Anda mencapai pemulihan yang benar dan akses simultan?  Ini adalah titik yang sangat berani dalam rencana aksi Postgres: masalah arsitektur perangkat lunak yang mempengaruhi sebagian besar mesin basis data, dari pengoptimal ke tingkat penyimpanan, serta sistem penjurnalan dan pemulihan.  Postgres R-tree telah menjadi kekuatan pendorong yang kuat dan contoh utama dari ekstensibilitas yang elegan dari lapisan metode akses dan integrasinya ke dalam optimizer permintaan.  Postgres menunjukkan, menggunakan ADT buram, bagaimana mendaftarkan metode akses yang dijelaskan secara abstrak (dalam hal ini pohon-R), dan bagaimana pengoptimal query dapat mengenali predikat seleksi abstrak (dalam hal ini, pilihan rentang) dan mencocokkannya dengan metode akses yang dijelaskan secara abstrak ini.  Kurang perhatian diberikan untuk kontrol akses bersamaan dalam pekerjaan awal: kurangnya pemesanan satu dimensi kunci membuat kunci yang digunakan dalam B-tree dalam kasus ini tidak dapat diterapkan. <br><br>  <em>Fitur yang menjanjikan dari metode akses extensible Postgres menginspirasi salah satu proyek penelitian pertama saya di akhir sekolah pascasarjana: Generalized Search Trees - GiST [ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">HNP95</a> ] dan konsep selanjutnya dari teori pengindeksan [ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">HKM <sup>+</sup> 02</a> ].</em>  <em>Saya menerapkan GiST di Postgres selama satu semester setelah menyelesaikan gelar doktor saya, yang membuat menambahkan logika pengindeksan baru untuk Postgres lebih mudah.</em>  <em>Disertasi Marcel Kornacker dari Berkeley (Marcel Kornacker) memecahkan masalah kompleks pemulihan dan akses simultan, yang ditimbulkan oleh tipe "templat" indeks GiST [ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">KMH97</a> ] yang dapat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">diperluas</a> .</em> <br><br>  Hari ini, PostgreSQL menggabungkan arsitektur perangkat lunak asli dari metode akses yang dapat diperluas (memiliki indeks B-tree, GiST, SP-GiST, dan Gin) dengan ekstensibilitas dan akses kompetitif yang intens dari antarmuka Generalized Search Tree (GiST).  Indeks GiST mendukung sistem geo-informasi PostGIS yang populer berdasarkan PostgreSQL.  Indeks Gin menyediakan dukungan pengindeksan teks internal di PostgreSQL. <br><br><h3>  2.1.4.  Pengoptimal Permintaan dengan UDF Mahal </h3><br>  Dalam optimisasi kueri tradisional, tugasnya adalah meminimalkan jumlah aliran tuple (dan karenanya operasi I / O) yang dibuat saat memproses permintaan.  Ini berarti bahwa pernyataan yang memfilter tupel (fetch) bagus di awal rencana kueri, sedangkan pernyataan yang dapat menghasilkan tupel baru (gabung) perlu dieksekusi nanti.  Akibatnya, pengoptimal permintaan akan "mendorong" operator pengambilan di bawah koneksi dan mengaturnya secara acak, sebagai gantinya berfokus pada optimasi koneksi dan akses disk yang cerdas.  UDF telah mengubah pendekatan: jika Anda memiliki UDF mahal dalam laporan sampel Anda, urutan pelaksanaan UDF dapat menjadi penting untuk mengoptimalkan kinerja.  Selain itu, jika UDF dalam operator seleksi benar-benar membutuhkan banyak waktu, ada kemungkinan bahwa pemilihan harus dilakukan setelah koneksi (yaitu, pemilihan harus "menarik" - pemilihan "menarik").  Mempertimbangkan faktor-faktor ini telah mempersulit ruang pencarian pengoptimal.  Saya menganggap masalah ini sebagai tugas sulit pertama di sekolah pascasarjana, dan akhirnya menjadi subjek pekerjaan master saya dengan Stonebreaker di Berkeley dan gelar Ph.D saya di Wisconsin di bawah arahan Jeff Naughton, tetapi dengan bantuan terus-menerus dari Stonebreaker.  Postgres adalah DBMS pertama yang menyimpan biaya dan selektivitas fungsi yang ditentukan pengguna dalam direktori basis data.  Kami mendekati masalah pengoptimalan, setelah menghasilkan urutan operasi pengambilan sampel yang optimal, dan kemudian pergantian operasi pengambilan sampel yang optimal di sepanjang cabang masing-masing pohon koneksi yang dipertimbangkan dalam pencarian rencana.         System R           . <br><br> <em>    ,      ,               . ,     ,     .</em> <br><br>          PostgreSQL       ,            . ,   ,     , ,  2018       . , ,         ,      ,   ,       .    ,  Postgres    . <br><br> <em>  , ,    ,        PostgreSQL       (Neil Conway),                      « » .</em> <br><br><h2>  2.2.       </h2><br>  Postgres                   .       :  ,      «  »,     1990- . <br><br>              .  —         Datalog.   «  »  : , ,                . <br><br> <em>Datalog                ,  -   . Datalog —     « »     .        ,     ,             .</em> <br><br>   ,     ,     ,             ,       .             . <br><br>             (Eric Hanson),     Ingres,       Postgres.         (Spyros Potamianos)  PRS2: Postgres Rules System 2.           .    —     .      ,      Ingres.      «   »   «       ». ,   «      »     «    10%».     ,     «   »,           .         (     ),    . <br><br> <em>      PRS2 ,   , .     Postgres       (,  )    Postgres  3.1  1991  (  ):</em> <br><br><pre> <em><font></font>
*        :<font></font>
*     .        <font></font>
*  (. .        <font></font>
* "" )    .   -  <font></font>
*   () .        .<font></font>
*   .    .     <font></font>
*   .  ...<font></font>
* ,  , ? ,    ,  .<font></font>
*         , <font></font>
*  ...</em> </pre><br>       Postgres    ,          «» —      .            PostgreSQL,     -           . <br><br>   Postgres          «  »     IBM Starburst  MCC HiPAC.      SQL        .      .      ,  ,   ,      ,    «  »:        ,      .  ,   -       ,    ,    ,  ,   .       ,     ,      ,         ,     Postgres. <br><br><h2> 2.3. X      </h2><br>       Postgres  : <br><blockquote>    Postgres,      - .            (write-ahead log — WAL),   ,     .  ,   Ingres 1970-     ,         . [ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">SK91</a> ] <br></blockquote>   ,    ,       .               ,    IBM  Tandem    .           :      -  ,   ,      ,    . <br><br> X Postgres             .       ,           ,   , —     «  »  «  »      .   ,  , —         .     ,    «»       .      :                ,      .     Postgres,   ,           ,             ,      [ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Sto87</a> ].    Postgres   . <br><br>    « »           ,      ,        .                    .  ,        ,      ,        ,      Postgres.     Postgres      .         PostgreSQL      . <br><br> <em> , PostgreSQL       :        .   ,  PostgreSQL    ,      Postgres,   ,       Postgres  .    ,      (snapshot isolation) Oracle       -,             .</em> <br><br> <em>  (Mike Olson) ,       ,    B- Postgres    B-   Berkeley DB,       Postgres.         .    Berkeley DB     Sleepycat Corp.,    ()  PostgreSQL       « ».  :    ,        (MVCC),       ,   .</em> <br><br> <em>   PostgreSQL     .  Greenplum  PostgreSQL        .      (Matt McCline)—    (Jim Gray)   Tandem.      .</em> <br><br>         .  ,                   NoSQL (  ,   WAL),        (MMDB — main memory databases,        ).              ,            .  ,             . <br><br><h2> 2.4.           </h2><br>  Di tengah-tengah proyek Postgres, Stonebreaker mendaftar sebagai salah satu eksekutif untuk hibah ilmu tanah digital besar yang disebut Project Sequoia.  Bagian dari proposal hibah adalah pemrosesan jumlah citra satelit digital yang belum pernah terjadi sebelumnya, yang membutuhkan memori hingga 100 terabyte, yaitu jumlah data yang jauh lebih besar daripada yang sebaiknya disimpan pada disk magnetik pada waktu itu.  Dasar dari solusi yang diusulkan adalah untuk menyelidiki ide untuk menciptakan DBMS (yaitu Postgres), yang memfasilitasi akses ke penyimpanan "tersier" semi-otonom yang disediakan oleh drive robot dengan penggantian disk otomatis untuk mengelola disk optik atau tape library. <br><br>  Ini menyebabkan beberapa penelitian berbeda.  Salah satunya adalah sistem file Inversion - upaya untuk memberikan abstraksi dari sistem file UNIX melalui DBMS relasional.  Dalam sebuah artikel ulasan untuk Sequoia, Stonebreaker menggambarkannya dalam gaya yang biasa digunakannya untuk “latihan sederhana” [ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Sto95</a> ].  Bahkan, Mike Olson, seorang siswa di Stonebreaker (dan pendiri Cloudera berikutnya), telah sibuk dengan hal ini selama beberapa tahun, dan hasil akhirnya tidak terlalu mudah [ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Ols93</a> ] dan tidak bertahan dalam praktik. <br><br>  <em>Beberapa tahun kemudian, Inversion Bill Gates "bertarung melawan kincir angin yang sama" di WinFS - sebuah upaya untuk menciptakan kembali sistem file yang paling banyak digunakan di dunia di bagian belakang database relasional.</em>  <em>WinFS dikirim dalam versi pengembangan Windows, tetapi tidak pernah masuk pasar.</em>  <em>Gates kemudian menyebutnya kekecewaan terbesarnya pada Microsoft.</em> <br><br>  Bidang utama lain dari penelitian pada bagian depan ini adalah dimasukkannya repositori tersier pada tumpukan database relasional yang lebih tipikal, yang merupakan subjek dari tesis PhD oleh Sunita Sarawagi.  Topik utama adalah mengubah skala di mana Anda berpikir tentang mengelola ruang (mis., Data dalam penyimpanan dan hierarki memori) dan waktu (mengoordinasikan penjadwalan kueri dan cache untuk meminimalkan I / O yang tidak diinginkan).  Salah satu masalah utama dalam pekerjaan ini adalah menyimpan array multidimensi besar dalam penyimpanan tersier dan mengambilnya, yang menggemakan pekerjaan di bidang pengindeksan multidimensi.  Ide-ide kunci termasuk membagi array menjadi bagian-bagian dan menyimpan bersama bagian-bagian yang dipilih bersama, serta mereplikasi bagian-bagian sehingga bagian data dapat memiliki beberapa "tetangga" fisik.  Masalah kedua adalah memikirkan bagaimana disk menjadi cache untuk penyimpanan tersier.  Akhirnya, optimisasi dan penjadwalan kueri harus memperhitungkan waktu pengambilan data yang lama dari penyimpanan tersier dan pentingnya klik (hit) dari cache disk.  Ini memengaruhi paket yang dipilih oleh pengoptimal kueri dan waktu yang diperlukan untuk menyelesaikan paket. <br><br>  Robot pada kaset dan disk optik saat ini tidak banyak digunakan.  Tetapi masalah penyimpanan tersier sangat umum di cloud, yang pada tahun 2018 memiliki hierarki penyimpanan yang dalam: dari SSD yang terpasang ke layanan penyimpanan seperti disk yang dapat diandalkan (misalnya, AWS EBS), ke penyimpanan arsip (misalnya, dalam AWS S3), ke penyimpanan dalam (misalnya, di AWS S3), ke penyimpanan dalam (misalnya, di AWS S3). , Gletser AWS).  Saat ini, tingkatan penyimpanan ini masih relatif terpisah, dan alasan tentang penyimpanan ujung ke ujung yang mencakup tingkatan ini secara praktis tidak didukung oleh basis data.  Saya tidak akan terkejut jika pertanyaan yang diselidiki di bagian depan Postgres ini akan segera ditinjau. <br><br><h2>  2.5.  Dukungan Banyak Prosesor: XPRS </h2><br>  Stonebreaker tidak pernah menciptakan sistem database paralel besar, tetapi dia memimpin banyak diskusi yang menantang di bidang ini.  Artikelnya "Case for Shared Nothing" [ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Sto86</a> ] mendokumentasikan solusi arsitektur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">modular</a> besar di bidang ini.  Dia mempopulerkan terminologi yang digunakan dalam industri dan membingungkan dukungan arsitektur tanpa sumber daya bersama, seperti Gamma dan Teradata, yang ditemukan kembali pada tahun 2000 oleh komunitas big data. <br><br>  Ironisnya, kontribusi Stonebreaker yang paling signifikan terhadap bidang database paralel adalah arsitektur "memori bersama" yang disebut XPRS, yang berarti "Postgres eXtended pada RAID dan Sprite".  Pada awal 1990-an, XPRS adalah "liga keadilan" untuk sistem Berkeley: ia menggabungkan sistem Postgres Stonebreaker yang disingkat, John Ousterhout, OS Sprite yang didistribusikan, dan arsitektur Dave Patterson dan Randy Katz RAID )  Seperti banyak pekerjaan antar fakultas, implementasi proyek XPRS sebenarnya ditentukan oleh mahasiswa pascasarjana yang bekerja di sana.  Ternyata kontribusi utama dibuat oleh Wei Hong, yang menulis tesis Ph.D tentang optimasi kueri paralel di XPRS.  Dengan demikian, kontribusi utama XPRS untuk literatur dan industri adalah untuk mengoptimalkan permintaan bersamaan tanpa secara signifikan mengatasi masalah yang terkait dengan RAID atau Sprite. <br><br>  <em>Dari ketiga proyek ini, Postgres dan RAID memiliki dampak besar di masa depan.</em>  <em>Sprite paling diingat oleh disertasi Mendel Rosenblum Ph.D tentang Log Structured File Systems (LFS), yang tidak ada hubungannya dengan sistem operasi terdistribusi.</em>  <em>Ketiga proyek berisi ide-ide baru untuk penyimpanan disk, selain memodifikasi salinan individual di tempat.</em>  <em>LFS dan manajer repositori Postgres sangat mirip dalam perlakuan baru mereka terhadap jurnal sebagai repositori utama dan kebutuhan untuk reorganisasi latar belakang yang mahal.</em>  <em>Suatu kali, saya dengan hati-hati memeriksa Stonebreaker tentang persaingan antara LFS dan Postgres atau "fakta-fakta goreng" akademik tentang hubungan mereka, tetapi saya tidak pernah belajar sesuatu yang menarik darinya.</em>  <em>Mungkin pada waktu itu di Berkeley seseorang "sedang mengaduk air."</em> <br><br>  Pada prinsipnya, concurrency “meledak” ruang dari rencana optimizer kueri, mengalikan pilihan tradisional yang dibuat selama optimasi kueri (akses data, algoritma koneksi, urutan koneksi) dengan semua cara yang memungkinkan untuk memparalelkan setiap pilihan.  Gagasan utama dari "pengoptimal Wei Hong" yang disebut oleh Stonebreaker adalah untuk membagi masalah menjadi dua: meluncurkan pengoptimal permintaan tradisional dalam semangat Sistem R untuk satu node, dan kemudian "memparalelkan" rencana yang dihasilkan, merencanakan tingkat paralelisme dan penempatan masing-masing operator berdasarkan pada representasi konfigurasi data dan sistem.  Pendekatan ini heuristik, tetapi di dalamnya konkurensi meningkatkan biaya optimisasi kueri tradisional, daripada multiplikatif. <br><br>  Meskipun pengoptimal Wei Hong dikembangkan dalam konteks Postgres, ini telah menjadi pendekatan standar bagi banyak pengoptimal permintaan bersamaan di industri. <br><br><h2>  2.6.  Dukungan untuk berbagai model bahasa </h2><br>  Di antara kepentingan Stonebreaker, berulang kali diperbarui sejak zaman Ingres, adalah antarmuka pemrograman aplikasi sistem basis data (API).  Dalam kuliahnya di seri Sistem Basis Data, ia sering memasukkan bahasa GEM, Carlo Zaniolo sebagai topik yang penting untuk dipahami oleh para pendukung sistem basis data.  Ketertarikan pada bahasa ini tidak diragukan lagi membawanya ke bermitra dengan Larry Rowe di Postgres, yang pada gilirannya sangat mempengaruhi desain model data Postgres dan pendekatan objek-relasionalnya.  Pekerjaan mereka terutama difokuskan pada aplikasi untuk bekerja dengan volume data yang besar dari ruang komersial, termasuk memproses informasi bisnis dan aplikasi baru seperti CAD / CAM dan GIS. <br><br>  Salah satu masalah yang dikenakan pada Stonebreaker pada waktu itu adalah gagasan "menyembunyikan" batas-batas antara konstruksi bahasa pemrograman dan repositori basis data.  Berbagai proyek penelitian yang bersaing dan perusahaan yang meneliti Object-Oriented Databases (OODBs) telah menargetkan apa yang disebut "hilangnya kesesuaian" antara bahasa pemrograman berorientasi objek yang penting seperti Smalltalk, C ++, dan Java, dan relasional deklaratif model.  Gagasan OODB adalah untuk membuat objek dari bahasa pemrograman, jika diinginkan, ditandai sebagai "permanen" dan diproses secara otomatis oleh DBMS bawaan.  Postgres mendukung penyimpanan objek bersarang dan tipe data abstrak, tetapi interface-nya, berdasarkan permintaan deklaratif dalam gaya relasional, mengasumsikan akses basis data yang tidak wajar untuk programmer (diperlukan penggunaan query deklaratif), yang juga mahal (mereka membutuhkan parsing dan optimasi).  Untuk bersaing dengan penyedia OODB, Postgres menyediakan apa yang disebut antarmuka Jalur Cepat: intinya C / C ++ API untuk penyimpanan basis data internal.  Hal ini memungkinkan Postgres untuk memiliki kinerja tolok ukur akademik OODB rata-rata, tetapi tidak pernah memecahkan masalah membiarkan programmer dalam bahasa yang berbeda menghindari masalah kehilangan kepatuhan.  Sebagai gantinya, Stonebreaker memberi label Postgres sebagai label "objek-relasional" dan hanya memotong penggunaan database berorientasi objek sebagai pasar nol-miliar dolar.  Saat ini, hampir semua sistem basis data relasional komersial adalah sistem basis data "objek-relasional". <br><br>  Ini ternyata menjadi solusi yang masuk akal.  Saat ini, tidak ada produk OODB yang ada dalam bentuk yang dimaksudkan, dan gagasan "objek persisten" dalam bahasa pemrograman sebagian besar telah dibuang.  Sebaliknya, penggunaan layer object-relational mapping (ORM) tersebar luas, didorong oleh pekerjaan awal seperti Java Hibernate dan Ruby on Rails, yang memungkinkan untuk "menyesuaikan" database deklaratif dengan hampir semua objek imperatif bahasa pemrograman berorientasi sebagai perpustakaan.  Pendekatan tingkat aplikasi ini berbeda dari database objek-relasional OODB dan Stonebreaker.  Selain itu, penyimpanan nilai kunci yang ringan juga digunakan dengan sukses dalam bentuk non-transaksional dan transaksional.  Penemu mereka adalah mahasiswa pascasarjana Stonebreaker Margo Seltzer, yang bekerja pada database Berkeley DB sebagai bagian dari disertasi Ph.D-nya pada saat yang sama dengan kelompok Postgres, yang mengantisipasi pertumbuhan repositori nilai kunci NoSQL yang didistribusikan seperti Dynamo , MongoDB dan Cassandra. <br><br><h1>  3. Dampak pada perangkat lunak </h1><br><h2>  3.1.  Sumber terbuka </h2><br>  Postgres selalu menjadi proyek sumber terbuka dengan rilis yang konsisten, tetapi pada awalnya itu dimaksudkan untuk digunakan untuk penelitian daripada produksi. <br><br>  Karena proyek penelitian Postgres dibatasi, dua siswa Stonebreaker Andrew Yu dan Jolly Chen memodifikasi parser sistem untuk menggantikan bahasa Postquel asli dengan varian SQL yang dapat diperluas.  Rilis Postgres pertama yang mendukung SQL adalah Postgres95, dan selanjutnya disebut PostgreSQL. <br><br>  Tim pengembangan sumber terbuka menjadi tertarik pada PostgreSQL dan “menerimanya” bahkan ketika minat dari tim Berkeley lainnya berubah.  Tim inti PostgreSQL tetap relatif stabil dari waktu ke waktu, dan proyek open source telah menjadi sangat berkembang.  Awalnya, upaya difokuskan pada stabilitas kode dan fungsionalitas yang terlihat oleh pengguna, tetapi seiring waktu, komunitas perangkat lunak sumber terbuka telah secara signifikan mengubah dan meningkatkan inti sistem, dari pengoptimal ke metode akses dan sistem transaksi dan penyimpanan utama.  Sejak pertengahan 1990-an, sebagian kecil dari komponen internal PostgreSQL berasal dari tim akademik Berkeley.  Kontribusi terakhirnya mungkin adalah implementasi GiST saya pada paruh kedua tahun 1990-an, tetapi bahkan secara substansial ditulis ulang dan dibersihkan oleh sukarelawan dari komunitas open source (dalam hal ini, Rusia).  Bagian dari komunitas open source yang bekerja pada PostgreSQL layak mendapatkan pujian terbesar untuk prosesnya yang efisien, yang selama beberapa dekade telah berperan menciptakan proyek yang sangat efisien dan jangka panjang. <br><br>  Meskipun banyak yang telah berubah selama 25 tahun, arsitektur PostgreSQL yang mendasarinya tetap sangat mirip dengan rilis universitas Postgres pada awal 1990-an, dan pengembang yang akrab dengan kode sumber PostgreSQL saat ini akan merasa mudah untuk membaca kode sumber Postgres 3.1 (1991).  Segala sesuatu dari struktur direktori kode sumber ke struktur proses dan struktur data tetap sangat mirip.  Kode dari tim Postgres di Berkeley memiliki tulang punggung yang bagus. <br><br>  Hari ini, PostgreSQL tidak diragukan lagi merupakan sistem manajemen basis data open source dengan kinerja tertinggi, dan mendukung fungsionalitas yang sering tidak ditemukan dalam produk komersial.  Ini juga (menurut salah satu situs peringkat berpengaruh) DBMS open source independen paling populer di dunia, dan pengaruhnya terus bertambah: pada 2017 dan 2018, itu adalah basis data dengan popularitas yang tumbuh paling cepat di dunia [ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">DE19c</a> ].  PostgreSQL digunakan dalam berbagai industri dan tugas, yang tidak mengejutkan, mengingat fokusnya pada banyak peluang. <br><br>  <em>Menurut DB-Engine, PostgreSQL hari ini adalah DBMS paling populer keempat di dunia, setelah Oracle, MySQL dan MS SQL Server, ketiganya ditawarkan oleh perusahaan tertentu (MySQL diakuisisi oleh Oracle bertahun-tahun yang lalu) [ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">DE19a</a> ].</em>  <em>Aturan pemeringkatan dibahas dalam deskripsi metodologi pemeringkatan DB-Engine [ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">DE19b</a> ].</em> <br><br>  Heroku adalah penyedia cloud SaaS yang sekarang menjadi bagian dari Salesforce.  Postgres diperkenalkan di Heroku pada 2010 sebagai database default untuk platformnya.  Heroku memilih Postgres untuk keandalan.  Dengan dukungan Heroku, platform pengembangan aplikasi yang lebih besar seperti Ruby on Rails dan Python untuk Django mulai merekomendasikan Postgres sebagai database default. <br><br>  Hari ini, PostgreSQL mendukung infrastruktur ekstensi yang membuatnya mudah untuk menambahkan fitur tambahan ke sistem melalui fungsi yang ditentukan pengguna dan modifikasi terkait.  Sekarang ada ekosistem ekstensi PostgreSQL, mirip dengan konsep llustra paket ekstensi DataBlade, tetapi dengan kode sumber terbuka.  Ekstensi yang paling menarik termasuk, misalnya, pustaka Apache MADlib untuk pembelajaran mesin di antarmuka SQL dan pustaka Citus untuk eksekusi permintaan paralel. <br><br>  Salah satu aplikasi open source paling menarik yang dibangun di Postgres adalah sistem informasi geografis PostGIS, menggunakan banyak fitur Postgres yang awalnya menginspirasi Stonebreaker untuk memulai proyek. <br><br><h2>  3.2.  Implementasi komersial </h2><br>  PostgreSQL telah lama menjadi titik awal yang menarik untuk menciptakan sistem basis data komersial, mengingat penggunaannya di bawah lisensi perangkat lunak sumber terbuka "semua diizinkan", kode yang dapat diandalkan, fleksibilitas, dan fungsionalitas yang luas.  Merangkum biaya akuisisi yang tercantum di bawah ini, kita melihat bahwa Postgres menerima lebih dari $ 2,6 miliar biaya akuisisi. <br><br>  <em>Harap dicatat bahwa ini adalah ukuran dalam dolar dari transaksi keuangan nyata dan jauh lebih signifikan daripada nilai-nilai yang sering digunakan dalam teknologi tinggi.</em>  <em>Angka dalam miliaran sering digunakan untuk menggambarkan nilai estimasi blok saham, tetapi sering dibesar-besarkan 10 kali atau lebih dibandingkan dengan nilai sekarang dengan harapan signifikansi di masa depan.</em>  <em>Dolar transaksi akuisisi perusahaan mengukur nilai pasar aktualnya pada saat akuisisi.</em>  <em>Adalah adil untuk mengatakan bahwa Postgres telah menciptakan lebih dari $ 2,6 miliar nilai komersial nyata.</em> <br><br>  Banyak upaya komersial yang terkait dengan PostgreSQL berfokus pada apa yang mungkin menjadi batasan utamanya: kemampuan untuk menskala arsitektur paralel tanpa berbagi sumber daya. <br><br>  <em>Paralelisasi PostgreSQL membutuhkan banyak pekerjaan, tetapi sangat layak dilakukan oleh tim kecil yang berpengalaman.</em>  <em>Hari ini, cabang-cabang industri open source PostgreSQL seperti Greenplum dan CitusDB memberikan kesempatan seperti itu.</em>  <em>Sangat disayangkan bahwa PostgreSQL tidak diparalelkan dengan benar dalam open source jauh lebih awal.</em>  <em>Jika PostgreSQL telah diperluas di open source dengan dukungan untuk arsitektur tanpa berbagi sumber daya di awal 2000-an, mungkin saja arah big data open source akan dikembangkan dengan cara yang benar-benar berbeda dan lebih efisien.</em> <br><br><ol><li>  Illustra adalah startup Stonebreaker terbesar kedua, yang didirikan pada tahun 1992 untuk mengkomersialkan Postgres, ketika RTI meluncurkan Ingres di pasar. <br><br>  <em>Illustra sebenarnya adalah nama ketiga yang diusulkan untuk perusahaan.</em>  <em>Melanjutkan tema melukis, diberi nama Ingres, Illustra awalnya disebut Miro.</em>  <em>Karena masalah merek dagang, nama diubah menjadi Montage, tetapi juga mengalami masalah merek dagang.</em> <br><br>  Tim pendiri termasuk beberapa inti dari tim Postgres, termasuk mahasiswa pascasarjana baru-baru ini Wei Hong dan kemudian ketua programer Jeff Meredith, serta lulusan dari Ingres Paula Hawthorn dan Michael Ubell.  Mahasiswa pascasarjana Postgres, Mike Olson, bergabung tidak lama setelah didirikan, dan saya bekerja di Illustra untuk mengoptimalkan fitur-fitur mahal sebagai bagian dari Ph.D.  Illustra    :  SQL92      ,    Postquel,    Postgres               DataBlade —       . Illustra   Informix  1997     400 . .  [ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Mon96</a> ],    DataBlade         Informix  Informix Universal Server. <br></li><li> Netezza  ,   1999 ,    PostgreSQL             FPGA. Netezza     ,        2007 .       IBM  1,7 . .  [ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">IBM10</a> ]. <br></li><li> Greenplum         PostgreSQL   .   2003 , Greenplum     PostgreSQL,      API PostgreSQL,  API   .    , Greenplum  PostgreSQL         ,   ,   Orca. Greenplum   EMC  2010   300 . . [ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Mal10</a> ],   2012  EMC  Greenplum     Pivotal.  2015  Pivotal    Greenplum  Orca    .    Greenplum   Postgres API   MADlib     SQL [ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">HRS+12</a> ]. MADlib     Apache.        ,   Greenplum,  Apache HAWQ,   Pivotal,   « » Greenplum (. .         PostgreSQL)    ,     Hadoop. <br></li><li> EnterpriseDB    2004   ,          PostgreSQL   ,             .    EnterpriseDB Advanced Server      Oracle,     Oracle. <br></li><li>  Aster Data    2005    ,      .        PostgreSQL. Aster             ,        SQL  MapReduce. Aster Data    Teradata  2011   263 . . [ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Sho11</a> ].  Teradata    Aster       ,  -  Aster             Teradata. <br></li><li>  ParAccel    2006 ,    PostgreSQL      . ParAccel   Postgres        .  2011  Amazon   ParAccel,   2012   AWS Redshift —             ParAccel.  2013  ParAccel    Actian (   Ingres)    ,  ,        Actian.    AWS Redshift     Amazon —            Amazon,   ,            ,   Teradata  Oracle Exadata.    Postgres       . <br></li><li>  CitusDB <em>(CitusDB —  ;   Citus Data. — . .)</em>    2010 ,     PostgreSQL   .      PostgreSQL,  2016  CitusDB    API  PostgreSQL        PostgreSQL.  2016   CitusDB     . <br></li></ol><br><h1> 4.  </h1><br>        Postgres,       . <br><br>   ,   ,   ,  Postgres   «  » (Second System Effect)    (Fred Brooks) [ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bro75</a> ].  ,          ,    -    . Postgres    ,  , ,     .      ,     ,       .     —    Postgres     ,      .               :     ,    .  , « »  .    ,    ,      .       «-»    ,      «-»    . <br><br>     ,    , «   »,       ,    .     <em>( 2001           (). — . .)</em>          2000-   «    ».          ,         Postgres. ,            ,       . <br><br> <em>   (Ralph Waldo Emerson), «  —   ».</em> <br><br> ,     «    » (       ),   ,      ,      , ,               .  ,           .   ,        ,       - .    ,   .          ,     . <br><br>  ,     Postgres, —   ,          .        « »  PostgreSQL,       ,        .  ,    : <br><blockquote>  ,  ,            ,          1995 .  Postgres,     ,     .       ,     ,            ,       . [ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Sto14</a> ] <br></blockquote>  ,   ,     ,  ,   « »   .      « ».   , ,  ,         ,       Postgres.     - ,    : « -      ».   (  ),         . <br><br><h1> 5.  </h1><br>       Postgres  ,          ,     (Craig Kerstiens)      PostgreSQL. <br><br><h1>  Sastra </h1><br><ul><li><a name="Bro75"></a> [Bro75] Frederick P Brooks. The mythical man-month, 1975. </li><li><a name="Bro19"></a> [Bro19] Michael L. Brodie, editor. Making Databases Work. Morgan &amp; Claypool, 2019. </li><li><a name="DE19a"></a> [DE19a] DB-Engines. DB-Engines ranking, 2019. <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">db-engines.com/en/ranking</a> . (Last accessed January 4, 2019). </li><li><a name="DE19b"></a> [DE19b] DB-Engines. Method of calculating the scores of the DB-Engines ranking, 2019. <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">db-engines.com/en/ranking_definition</a> (Last accessed January 4, 2019). </li><li><a name="DE19c"></a> [DE19c] DB-Engines. PostgreSQL is the DBMS of the year 2018, January 2019. <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">db-engines.com/en/blog_post/79</a> (Last accessed January 4, 2019). </li><li><a name="DS08"></a> [DS08] David DeWitt and Michael Stonebraker. Mapreduce: A major step backwards. The Database Column, 1:23, 2008. </li><li><a name="Gut84"></a> [Gut84] Antonin Guttman. R-trees: A dynamic index structure for spatial searching. In Proceedings of the 1984 ACM SIGMOD International Conference on Management of Data, SIGMOD '84, pages 47–57, New York, NY, USA, 1984. ACM. </li><li><a name="HKM02"></a> [HKM <sup>+</sup> 02] Joseph M. Hellerstein, Elias Koutsoupias, Daniel P. Miranker, Christos H. Papadimitriou, and Vasilis Samoladas. On a model of indexability and its bounds for range queries. J. ACM, 49(1):35–55, January 2002. </li><li><a name="HNP95"></a> [HNP95] Joseph M. Hellerstein, Jeffrey F. Naughton, and Avi Pfeffer. Generalized search trees for database systems. In Proceedings of the 21th International Conference on Very Large Data Bases, VLDB '95, pages 562–573, San Francisco, CA, USA, 1995. Morgan Kaufmann Publishers Inc. </li><li><a name="HRS12"></a> [HRS <sup>+</sup> 12] Joseph M Hellerstein, Christoper Re, Florian Schoppmann, Daisy Zhe Wang, Eugene Fratkin, Aleksander Gorajek, Kee Siong Ng, Caleb Welton, Xixuan Feng, Kun Li, et al. The MADlib analytics library: or MAD skills, the SQL. Proceedings of the VLDB Endowment, 5(12):1700–1711, 2012. </li><li><a name="IBM10"></a> [IBM10] IBM to acquire Netezza, September 2010. <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">www-03.ibm.com/press/us/en/pressrelease/32514.wss#release</a> (Last accessed January 22, 2018). </li><li><a name="KMH97"></a> [KMH97] Marcel Kornacker, C. Mohan, and Joseph M. Hellerstein. Concurrency and recovery in generalized search trees. In Proceedings of the 1997 ACM SIGMOD International Conference on Management of Data, SIGMOD '97, pages 62–72, New York, NY, USA, 1997. ACM. </li><li><a name="Mal10"></a> [Mal10] Om Malik. Big Data = Big Money: EMC Buys Greenplum. In GigaOm, July 2010. <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">gigaom.com/2010/07/06/emc-buys-greenplum</a> . </li><li><a name="Mon96"></a> [Mon96] John Monroe. Informix acquires illustra for complex data management. In Federal Computer Week, January 1996. </li><li><a name="OFS83"></a> [OFS83] James Ong, Dennis Fogg, and Michael Stonebraker. Implementation of data abstraction in the relational database system ingres. ACM Sigmod Record, 14(1):1–14, 1983. </li><li><a name="Ols93"></a> [Ols93] Michael A. Olson. The design and implementation of the inversion file system. 1993. </li><li><a name="SAHR84"></a> [SAHR84] Michael Stonebraker, Erika Anderson, Eric Hanson, and Brad Rubenstein. Quel as a data type. In Proceedings of the 1984 ACM SIGMOD International Conference on Management of Data, SIGMOD '84, pages 208–214, New York, NY, USA, 1984. ACM. </li><li><a name="Sho11"></a> [Sho11] Erick Shonfeld. Big pay day for big data. teradata buys aster data for $263 million. In TechCrunch, May 2011. <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">techcrunch.com/2011/03/03/teradata-buys-aster-data-263-million</a> (Last accessed January 22, 2018). </li><li><a name="SHWK76"></a> [SHWK76] Michael Stonebraker, Gerald Held, Eugene Wong, and Peter Kreps. The design and implementation of ingres. ACM Transactions on Database Systems (TODS), 1(3):189–222, 1976. </li><li><a name="SK91"></a> [SK91] Michael Stonebraker and Greg Kemnitz. The postgres next generation database management system. Commun. ACM, 34(10):78–92, October 1991. </li><li><a name="SR86"></a> [SR86] Michael Stonebraker and Lawrence A. Rowe. The design of postgres. In Proceedings of the 1986 ACM SIGMOD International Conference on Management of Data, SIGMOD '86, pages 340–355, New York, NY, USA, 1986. ACM. </li><li><a name="SRG83"></a> [SRG83] M Stonebraker, B Rubenstein, and A Guttman. Application of abstract data types and abstract indices to cad bases. IEEE Trans, on Software Engineering, 1983. </li><li><a name="Sto86"></a> [Sto86] Michael Stonebraker. The case for shared nothing. IEEE Database Eng. Bull., 9(1):4–9, 1986. </li><li><a name="Sto87"></a> [Sto87] Michael Stonebraker. The design of the postgres storage system. In Proceedings of the 13th International Conference on Very Large Data Bases, VLDB '87, pages 289–300, San Francisco, CA, USA, 1987. Morgan Kaufmann Publishers Inc. </li><li><a name="Sto95"></a> [Sto95] Michael Stonebraker. An overview of the sequoia 2000 project. Digital Technical Journal, 7(3):39–49, 1995. </li><li><a name="Sto14"></a> [Sto14] Michael Stonebraker. The land sharks are on the squawk box, 2014. <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">www.acm.org/turing-lecture-stonebraker</a> (Last accessed January 4, 2019). </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id438890/">https://habr.com/ru/post/id438890/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id438878/index.html">Kemunculan film di torrent setelah pemutaran perdana meningkatkan box office sebesar 3%</a></li>
<li><a href="../id438880/index.html">Kapan menggunakan var, biarkan dan const dalam Javascript [terjemahan dari artikel Tyler McGinnis]</a></li>
<li><a href="../id438882/index.html">Probabilitas memenangkan pertandingan dengan probabilitas yang diketahui untuk memenangkan poin</a></li>
<li><a href="../id438884/index.html">Kisah nyata dari agen periklanan pedalaman: naik, turun dan implementasi CRM</a></li>
<li><a href="../id438886/index.html">Morty, kami di UltraHD! Cara menonton film apa pun dalam 4K, menyelesaikannya melalui jaringan saraf yang sedikit diketahui</a></li>
<li><a href="../id438892/index.html">Apa itu blockchain perusahaan?</a></li>
<li><a href="../id438894/index.html">Mengapa pengembangan web di Go lebih baik daripada di PHP</a></li>
<li><a href="../id438896/index.html">Jangan Menangis Bisnis</a></li>
<li><a href="../id438898/index.html">Chrome terbalik dan pemasangan ekstensi</a></li>
<li><a href="../id438900/index.html">Dalam perjalanan ke prinsip fisik evolusi biologis. Akhiri + teks lengkap terjemahan</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>