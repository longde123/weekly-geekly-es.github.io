<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>📩 🧕🏼 🏭 Bereaksi Token Auth 🧕🏾 👏🏿 🍘</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Problemm 


 Otorisasi adalah salah satu masalah pertama yang dihadapi pengembang saat memulai proyek baru. Dan salah satu jenis otorisasi yang paling...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Bereaksi Token Auth</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/485764/"><p><img src="https://habrastorage.org/webt/v-/ss/kz/v-sskznfybocplele4iiabbdl44.png"></p><br><h2 id="problem">  Problemm </h2><br><p> Otorisasi adalah salah satu masalah pertama yang dihadapi pengembang saat memulai proyek baru.  Dan salah satu jenis otorisasi yang paling umum (dari pengalaman saya) adalah otorisasi berbasis token (biasanya menggunakan JWT). </p><br><p>  Dari sudut pandang saya, artikel ini seperti "apa yang ingin saya baca dua minggu lalu".  Tujuan saya adalah menulis kode minimalis dan dapat digunakan kembali dengan antarmuka yang bersih dan mudah.  Saya memiliki persyaratan berikutnya untuk implementasi manajemen auth: </p><br><ul><li>  Token harus disimpan di penyimpanan lokal </li><li>  Token harus dikembalikan pada pemuatan ulang halaman </li><li>  Token akses harus diteruskan dalam permintaan jaringan </li><li>  Setelah kedaluwarsa, token akses harus diperbarui dengan menyegarkan token jika yang terakhir disajikan </li><li>  Komponen yang bereaksi harus memiliki akses ke informasi autentikasi untuk membuat UI yang sesuai </li><li>  Solusinya harus dibuat dengan Bereaksi murni (tanpa Redux, thunk, dll.) </li></ul><a name="habracut"></a><br><p>  Bagi saya salah satu pertanyaan yang paling menantang adalah: </p><br><ul><li>  Bagaimana cara menyinkronkan React state status dan data penyimpanan lokal? </li><li>  Cara mendapatkan token di dalam mengambil tanpa melewati seluruh pohon elemen (terutama jika kita ingin menggunakan mengambil ini dalam tindakan thunk nanti misalnya) </li></ul><br><p> Tapi mari kita selesaikan masalah itu selangkah demi selangkah.  Pertama, kami akan membuat <code>token provider</code> untuk menyimpan token dan memberikan kemungkinan untuk mendengarkan perubahan.  Setelah itu, kami akan membuat <code>auth provider</code> , sebenarnya membungkus <code>token provider</code> untuk membuat kait untuk komponen Bereaksi, mengambil steroid dan beberapa metode tambahan.  Dan pada akhirnya, kita akan melihat bagaimana menggunakan solusi ini dalam proyek. </p><br><h2 id="i-just-wanna-npm-install--and-go-production">  Saya hanya ingin <code>npm install ...</code> dan mulai berproduksi </h2><br><p>  Saya sudah mengumpulkan paket yang berisi semua yang dijelaskan di bawah ini (dan sedikit lebih banyak).  Anda hanya perlu menginstalnya dengan perintah: </p><br><pre> <code class="plaintext hljs">npm install react-token-auth</code> </pre> <br><p>  Dan ikuti contoh dalam repositori GitHub <a href="https://github.com/obabichev/react-token-auth" rel="nofollow">react-token-auth</a> . </p><br><h2 id="solution">  Solusi </h2><br><p>  Sebelum menyelesaikan masalah, saya akan membuat asumsi bahwa kita memiliki backend yang mengembalikan objek dengan token akses dan refresh.  Setiap token memiliki format <code>JWT</code> .  Objek seperti itu mungkin terlihat seperti: </p><br><pre> <code class="json hljs">{ <span class="hljs-attr"><span class="hljs-attr">"accessToken"</span></span>: <span class="hljs-string"><span class="hljs-string">"..."</span></span>, <span class="hljs-attr"><span class="hljs-attr">"refreshToken"</span></span>: <span class="hljs-string"><span class="hljs-string">"..."</span></span> }</code> </pre> <br><p>  Sebenarnya, struktur objek token tidak penting bagi kami.  Dalam kasus yang paling sederhana, mungkin string dengan token akses tak terbatas.  Tetapi kami ingin melihat bagaimana mengelola suatu situasi ketika kami memiliki dua token, salah satunya token, dan yang kedua mungkin digunakan untuk memperbarui yang pertama. </p><br><h3 id="jwt">  Jwt </h3><br><p>  Jika Anda tidak tahu apa token JWT, pilihan terbaik adalah pergi ke <a href="https://jwt.io/" rel="nofollow">jwt.io</a> dan lihat bagaimana cara kerjanya.  Sekarang penting bahwa token JWT berisi informasi yang disandikan (dalam format <code>Base64</code> ) tentang pengguna yang memungkinkan otentikasi dia di server. </p><br><p>  Biasanya token JWT berisi 3 bagian dibagi dengan titik-titik dan terlihat seperti: </p><br><p> <code>eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJuYW1lIjoiSm9obiBEb2UiLCJpYXQiOjE1MTYyMzkwMjIsImV4cCI6MTUxNjIzOTAyMn0.yOZC0rjfSopcpJ-d3BWE8-BkoLR_SCqPdJpq8Wn-1Mc</code> </p> <br><p>  Jika kita mendekode bagian tengah ( <code>eyJu...Mn0</code> ) dari token ini, kita akan mendapatkan JSON berikutnya: </p><br><pre> <code class="json hljs">{ <span class="hljs-attr"><span class="hljs-attr">"name"</span></span>: <span class="hljs-string"><span class="hljs-string">"John Doe"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"iat"</span></span>: <span class="hljs-number"><span class="hljs-number">1516239022</span></span>, <span class="hljs-attr"><span class="hljs-attr">"exp"</span></span>: <span class="hljs-number"><span class="hljs-number">1516239022</span></span> }</code> </pre> <br><p>  Dengan informasi ini, kita akan dapat memperoleh tanggal kedaluwarsa dari token. </p><br><h3 id="token-provider">  Penyedia token </h3><br><p>  Seperti yang saya sebutkan sebelumnya, langkah pertama kami adalah menciptakan penyedia token.  Penyedia token akan bekerja langsung dengan penyimpanan lokal dan semua perubahan token akan kami lakukan melaluinya.  Ini akan memungkinkan kami untuk mendengarkan perubahan dari mana saja dan segera memberi tahu pendengar tentang perubahan (tetapi sedikit tentangnya nanti).  Antarmuka penyedia akan memiliki metode berikut: </p><br><ul><li>  <code>getToken()</code> untuk mendapatkan token saat ini (ini akan digunakan dalam pengambilan) </li><li>  <code>setToken()</code> untuk mengatur token setelah login, logout atau registrasi </li><li>  <code>isLoggedIn()</code> untuk memeriksa apakah pengguna masuk </li><li>  <code>subscribe()</code> untuk memberi penyedia fungsi yang harus dipanggil setelah perubahan token apa pun </li><li>  <code>unsubscribe()</code> untuk menghapus pelanggan </li></ul><br><p>  Fungsi <code>createTokenProvider()</code> akan membuat instance penyedia token dengan antarmuka yang dijelaskan: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> createTokenProvider = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-comment"><span class="hljs-comment">/* Implementation */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { getToken, isLoggedIn, setToken, subscribe, unsubscribe, }; };</code> </pre> <br><p>  Semua kode selanjutnya harus berada di dalam fungsi createTokenProvider. </p><br><p>  Mari kita mulai dengan membuat variabel untuk menyimpan token dan mengembalikan data dari penyimpanan lokal (untuk memastikan bahwa sesi tidak akan hilang setelah pemuatan ulang halaman): </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> _token: { <span class="hljs-attr"><span class="hljs-attr">accessToken</span></span>: string, <span class="hljs-attr"><span class="hljs-attr">refreshToken</span></span>: string } = <span class="hljs-built_in"><span class="hljs-built_in">JSON</span></span>.parse(localStorage.getItem(<span class="hljs-string"><span class="hljs-string">'REACT_TOKEN_AUTH'</span></span>) || <span class="hljs-string"><span class="hljs-string">''</span></span>) || <span class="hljs-literal"><span class="hljs-literal">null</span></span>;</code> </pre> <br><p>  Sekarang kita perlu membuat beberapa fungsi tambahan untuk bekerja dengan token JWT.  Pada saat ini, token JWT terlihat seperti string ajaib, tetapi itu bukan masalah besar untuk menguraikannya dan mencoba untuk mengekstrak tanggal kedaluwarsa.  Fungsi <code>getExpirationDate()</code> akan mengambil token JWT sebagai parameter dan mengembalikan timestamp tanggal kedaluwarsa jika berhasil (atau <code>null</code> gagal): </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> getExpirationDate = (jwtToken?: string): number | <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">null</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!jwtToken) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> jwt = <span class="hljs-built_in"><span class="hljs-built_in">JSON</span></span>.parse(atob(jwtToken.split(<span class="hljs-string"><span class="hljs-string">'.'</span></span>)[<span class="hljs-number"><span class="hljs-number">1</span></span>])); <span class="hljs-comment"><span class="hljs-comment">// multiply by 1000 to convert seconds into milliseconds return jwt &amp;&amp; jwt.exp &amp;&amp; jwt.exp * 1000 || null; };</span></span></code> </pre> <br><p>  Dan satu lagi fungsi util <code>isExpired()</code> untuk memeriksa apakah timestamp kadaluarsa.  Fungsi ini mengembalikan true jika stempel waktu kedaluwarsa disajikan dan jika kurang dari <code>Date.now()</code> . </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> isExpired = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">exp?: number</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!exp) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Date</span></span>.now() &gt; exp; };</code> </pre> <br><p>  Saatnya membuat fungsi pertama antarmuka penyedia token.  Fungsi <code>getToken()</code> harus mengembalikan token dan memperbaruinya jika perlu.  Fungsi ini harus <code>async</code> karena mungkin membuat permintaan jaringan untuk memperbarui token. </p><br><p>  Dengan menggunakan fungsi-fungsi yang dibuat sebelumnya, kita dapat memeriksa apakah token akses telah kedaluwarsa atau tidak ( <code>isExpired(getExpirationDate(_token.accessToken))</code> )).  Dan dalam kasus pertama membuat permintaan untuk memperbarui token.  Setelah itu, kita dapat menyimpan token (dengan fungsi <code>setToken()</code> belum diimplementasikan).  Dan akhirnya, kita dapat mengembalikan token akses: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> getToken = <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> () =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!_token) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (isExpired(getExpirationDate(_token.accessToken))) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> updatedToken = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> fetch(<span class="hljs-string"><span class="hljs-string">'/update-token'</span></span>, { <span class="hljs-attr"><span class="hljs-attr">method</span></span>: <span class="hljs-string"><span class="hljs-string">'POST'</span></span>, <span class="hljs-attr"><span class="hljs-attr">body</span></span>: _token.refreshToken }) .then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">r</span></span></span><span class="hljs-function"> =&gt;</span></span> r.json()); setToken(updatedToken); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _token &amp;&amp; _token.accessToken; };</code> </pre> <br><p>  Fungsi <code>isLoggedIn()</code> akan menjadi sederhana: itu akan mengembalikan true jika <code>_tokens</code> tidak <code>null</code> dan tidak akan memeriksa akses token kedaluwarsa (dalam hal ini kita tidak akan tahu tentang akses token kadaluarsa sampai kita gagal mendapatkan token, tetapi biasanya itu sudah cukup) , dan biarkan kami menjaga fungsinyaLoggedIn sinkron): </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> isLoggedIn = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> !!_token; };</code> </pre> <br><p>  Saya pikir ini saat yang tepat untuk membuat fungsionalitas untuk mengelola pengamat.  Kami akan menerapkan sesuatu yang mirip dengan <a href="https://en.wikipedia.org/wiki/Observer_pattern" rel="nofollow">pola Observer</a> , dan pertama-tama, akan membuat array untuk menyimpan semua pengamat kami.  Kami akan berharap bahwa setiap elemen dalam array ini adalah fungsi yang harus kita panggil setelah setiap perubahan token: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> observers: <span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>&lt;<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">isLogged: boolean</span></span></span><span class="hljs-function">) =&gt;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span>&gt; = [];</code> </pre> <br><p>  Sekarang kita dapat membuat metode <code>subscribe()</code> dan <code>unsubscribe()</code> .  Yang pertama akan menambahkan pengamat baru ke array yang dibuat sebelumnya sedikit, yang kedua akan menghapus pengamat dari daftar. </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> subscribe = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">observer: (isLogged: boolean</span></span></span><span class="hljs-function">) =&gt;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span>) =&gt; { observers.push(observer); }; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> unsubscribe = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">observer: (isLogged: boolean</span></span></span><span class="hljs-function">) =&gt;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span>) =&gt; { observers = observers.filter(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">_observer</span></span></span><span class="hljs-function"> =&gt;</span></span> _observer !== observer); };</code> </pre> <br><p>  Anda sudah dapat melihat dari antarmuka fungsi <code>subscribe()</code> dan <code>unsubscribe()</code> yang akan kami kirim ke pengamat hanya faktanya adalah pengguna yang masuk.  Tetapi secara umum, Anda dapat mengirim semua yang Anda inginkan (seluruh token, waktu kedaluwarsa, dll ...).  Tetapi untuk tujuan kita, itu akan cukup untuk mengirim bendera boolean. </p><br><p>  Mari kita buat fungsi util kecil <code>notify()</code> yang akan mengambil flag ini dan mengirim ke semua pengamat: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> notify = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> isLogged = isLoggedIn(); observers.forEach(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">observer</span></span></span><span class="hljs-function"> =&gt;</span></span> observer(isLogged)); };</code> </pre> <br><p>  Dan fungsi terakhir yang tidak kalah penting yang perlu kita terapkan adalah <code>setToken()</code> .  Tujuan dari fungsi ini adalah menyimpan token di penyimpanan lokal (atau membersihkan penyimpanan lokal jika token kosong) dan memberi tahu pengamat tentang perubahan.  Jadi, saya melihat tujuannya, saya pergi ke tujuan. </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> setToken = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">token: </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">typeof</span></span></span></span><span class="hljs-function"><span class="hljs-params"> _token</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (token) { localStorage.setItem(<span class="hljs-string"><span class="hljs-string">'REACT_TOKEN_AUTH'</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">JSON</span></span>.stringify(token)); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { localStorage.removeItem(<span class="hljs-string"><span class="hljs-string">'REACT_TOKEN_AUTH'</span></span>); } _token = token; notify(); };</code> </pre> <br><p>  Pastikan, jika Anda sampai pada titik ini dalam artikel dan merasa bermanfaat, Anda sudah membuat saya lebih bahagia.  Di sini kita selesai dengan penyedia token.  Anda dapat melihat kode Anda, bermain dengannya dan memeriksa apakah itu berfungsi.  Pada bagian selanjutnya di atas ini, kami akan membuat fungsionalitas yang lebih abstrak yang akan berguna dalam aplikasi Bereaksi apa pun. </p><br><h3 id="auth-provider">  Penyedia auth </h3><br><p>  Mari kita buat kelas objek baru yang akan kita sebut sebagai penyedia Auth.  Antarmuka akan berisi 4 metode: hook <code>useAuth()</code> untuk mendapatkan status baru dari komponen Bereaksi, <code>authFetch()</code> untuk membuat permintaan ke jaringan dengan token dan <code>login()</code> sebenarnya <code>login()</code> , <code>logout()</code> metode yang akan proksi panggilan ke metode <code>setToken()</code> dari penyedia token (dalam hal ini, kami hanya akan memiliki satu titik masuk ke seluruh fungsi yang dibuat, dan sisa kode tidak perlu tahu tentang keberadaan penyedia token).  Seperti sebelumnya kita akan mulai dari pencipta fungsi: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> createAuthProvider = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-comment"><span class="hljs-comment">/* Implementation */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { useAuth, authFetch, login, logout } };</code> </pre> <br><p>  Pertama-tama, jika kita ingin menggunakan penyedia token kita perlu membuat instance darinya: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> tokenProvider = createTokenProvider();</code> </pre> <br><p>  Metode <code>login()</code> dan <code>logout()</code> cukup meneruskan token ke penyedia token.  Saya memisahkan metode ini hanya untuk makna eksplisit (sebenarnya lewat token kosong / nol menghapus data dari penyimpanan lokal): </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> login: <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span> tokenProvider.setToken = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">newTokens</span></span></span><span class="hljs-function">) =&gt;</span></span> { tokenProvider.setToken(newTokens); }; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> logout = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { tokenProvider.setToken(<span class="hljs-literal"><span class="hljs-literal">null</span></span>); };</code> </pre> <br><p>  Langkah selanjutnya adalah fungsi ambil.  Menurut ide saya, fungsi ini harus memiliki antarmuka yang sama persis seperti pengambilan asli dan mengembalikan format yang sama tetapi harus menyuntikkan token akses ke setiap permintaan. </p><br><p>  Fungsi pengambilan harus mengambil dua argumen: info permintaan (biasanya URL) dan permintaan init (objek dengan metode, isi. Header, dan sebagainya);  dan mengembalikan janji untuk respons: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> authFetch = <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> (input: RequestInfo, init?: RequestInit): <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>&lt;Response&gt; =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> token = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> tokenProvider.getToken(); init = init || {}; init.headers = { ...init.headers, <span class="hljs-attr"><span class="hljs-attr">Authorization</span></span>: <span class="hljs-string"><span class="hljs-string">`Bearer </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${token}</span></span></span><span class="hljs-string">`</span></span>, }; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> fetch(input, init); };</code> </pre> <br><p>  Di dalam fungsi kami membuat dua hal: mengambil token dari penyedia token dengan pernyataan <code>await tokenProvider.getToken();</code>  ( <code>getToken</code> sudah berisi logika memperbarui token setelah kedaluwarsa) dan menyuntikkan token ini ke header <code>Authorization</code> oleh <code>Authorization: 'Bearer ${token}'</code> baris <code>Authorization: 'Bearer ${token}'</code> .  Setelah itu, kami cukup mengembalikan pengambilan dengan argumen yang diperbarui. </p><br><p>  Jadi, kita sudah bisa menggunakan penyedia auth untuk menyimpan token dan menggunakannya dari mengambil.  Masalah terakhir adalah kita tidak bisa bereaksi terhadap perubahan token dari komponen kita.  Saatnya untuk menyelesaikannya. </p><br><p>  Seperti yang saya katakan sebelumnya kita akan membuat hook <code>useAuth()</code> yang akan memberikan informasi kepada komponen apakah pengguna login atau tidak.  Untuk dapat melakukan itu kita akan menggunakan hook <code>useState()</code> untuk menyimpan informasi ini.  Ini berguna karena setiap perubahan dalam status ini akan menyebabkan rerender komponen yang menggunakan kait ini. </p><br><p>  Dan kami sudah menyiapkan segalanya untuk dapat mendengarkan perubahan penyimpanan lokal.  Cara umum untuk mendengarkan setiap perubahan dalam sistem dengan kait adalah menggunakan hook <code>useEffect()</code> .  Hook ini mengambil dua argumen: fungsi dan daftar dependensi.  Fungsi ini akan diaktifkan setelah panggilan pertama <code>useEffect</code> dan kemudian diluncurkan kembali setelah ada perubahan dalam daftar dependensi.  Dalam fungsi ini, kita dapat mulai mendengarkan perubahan dalam penyimpanan lokal.  Tetapi yang penting kita dapat kembali dari fungsi ini ... fungsi baru dan, fungsi baru ini akan diaktifkan baik sebelum meluncurkan kembali yang pertama atau setelah melepas komponen.  Dalam fungsi baru, kita dapat berhenti mendengarkan perubahan dan Bereaksi jaminan, bahwa fungsi ini akan diaktifkan (setidaknya jika tidak ada pengecualian terjadi selama proses ini).  Kedengarannya agak rumit tetapi lihat saja kodenya: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> useAuth = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> [isLogged, setIsLogged] = useState(tokenProvider.isLoggedIn()); useEffect(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> listener = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">newIsLogged: boolean</span></span></span><span class="hljs-function">) =&gt;</span></span> { setIsLogged(newIsLogged); }; tokenProvider.subscribe(listener); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { tokenProvider.unsubscribe(listener); }; }, []); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [isLogged] <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> [<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span> isLogged]; };</code> </pre> <br><p>  Dan itu saja.  Kami baru saja membuat penyimpanan token autentik dan dapat digunakan kembali dengan API yang jelas.  Pada bagian selanjutnya, kita akan melihat beberapa contoh penggunaan. </p><br><h2 id="usage">  Penggunaan </h2><br><p>  Untuk mulai menggunakan apa yang kami terapkan di atas, kita perlu membuat instance dari penyedia auth.  Ini akan memberi kami akses ke fungsi <code>useAuth()</code> , <code>authFetch()</code> , <code>login()</code> , <code>logout()</code> terkait dengan token yang sama di penyimpanan lokal (secara umum, tidak ada yang mencegah Anda untuk membuat contoh berbeda penyedia auth untuk token yang berbeda, tetapi Anda perlu parametrize kunci yang Anda gunakan untuk menyimpan data di penyimpanan lokal): </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> {useAuth, authFetch, login, logout} = createAuthProvider();</code> </pre> <br><h3 id="login-form">  Formulir masuk </h3><br><p>  Sekarang kita bisa mulai menggunakan fungsi yang kita dapatkan.  Mari kita mulai dengan komponen formulir login.  Komponen ini harus memberikan input untuk kredensial pengguna dan menyimpannya dalam kondisi internal.  Saat kirim, kami perlu mengirim permintaan dengan kredensial untuk mendapatkan token dan di sini kami dapat menggunakan fungsi <code>login()</code> untuk menyimpan token yang diterima: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> LoginComponent = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> [credentials, setCredentials] = useState({ <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">''</span></span>, <span class="hljs-attr"><span class="hljs-attr">password</span></span>: <span class="hljs-string"><span class="hljs-string">''</span></span> }); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> onChange = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">{target: {name, value}}: ChangeEvent&lt;HTMLInputElement&gt;</span></span></span><span class="hljs-function">) =&gt;</span></span> { setCredentials({...credentials, [name]: value}) }; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> onSubmit = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">event?: React.FormEvent</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (event) { event.preventDefault(); } fetch(<span class="hljs-string"><span class="hljs-string">'/login'</span></span>, { <span class="hljs-attr"><span class="hljs-attr">method</span></span>: <span class="hljs-string"><span class="hljs-string">'POST'</span></span>, <span class="hljs-attr"><span class="hljs-attr">body</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">JSON</span></span>.stringify(credentials) }) .then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">r</span></span></span><span class="hljs-function"> =&gt;</span></span> r.json()) .then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">token</span></span></span><span class="hljs-function"> =&gt;</span></span> login(token)) }; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> &lt;form onSubmit={onSubmit}&gt; &lt;input name="name" value={credentials.name} onChange={onChange}/&gt; &lt;input name="password" value={credentials.password} onChange={onChange}/&gt; &lt;/form&gt; };</code> </pre> <br><p>  Dan itu saja, itu semua yang kita butuhkan untuk menyimpan token.  Setelah itu, ketika token diterima, kita tidak perlu melakukan upaya ekstra untuk membawanya untuk mengambil atau dalam komponen, karena sudah diterapkan di dalam penyedia auth. </p><br><p>  Formulir pendaftaran serupa, hanya ada perbedaan dalam jumlah dan nama bidang input, jadi saya akan menghilangkannya di sini. </p><br><h3 id="router">  Router </h3><br><p>  Selain itu, kami dapat mengimplementasikan perutean menggunakan penyedia auth.  Mari kita asumsikan bahwa kita memiliki dua paket rute: satu untuk pengguna terdaftar dan satu untuk tidak terdaftar.  Untuk membaginya kita perlu memeriksa apakah kita memiliki token di penyimpanan lokal atau tidak, dan di sini kita dapat menggunakan hook <code>useAuth()</code> : </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Router = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> [logged] = useAuth(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> &lt;BrowserRouter&gt; &lt;Switch&gt; {!logged &amp;&amp; &lt;&gt; &lt;Route path="/register" component={Register}/&gt; &lt;Route path="/login" component={Login}/&gt; &lt;Redirect to="/login"/&gt; &lt;/&gt;} {logged &amp;&amp; &lt;&gt; &lt;Route path="/dashboard" component={Dashboard} exact/&gt; &lt;Redirect to="/dashboard"/&gt; &lt;/&gt;} &lt;/Switch&gt; &lt;/BrowserRouter&gt;; };</code> </pre> <br><p>  Dan hal yang baik bahwa itu akan dirender ulang setelah ada perubahan dalam penyimpanan lokal, karena <code>useAuth</code> memiliki berlangganan perubahan ini. </p><br><h3 id="fetch-requests">  Ambil permintaan </h3><br><p>  Dan kemudian kita bisa mendapatkan data yang dilindungi oleh token menggunakan <code>authFetch</code> .  Ini memiliki antarmuka yang sama dengan fetch, jadi jika Anda sudah menggunakan fetch dalam kode, Anda cukup menggantinya dengan <code>authFetch</code> : </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Dashboard = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> [posts, setPosts] = useState([]); useEffect(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { authFetch(<span class="hljs-string"><span class="hljs-string">'/posts'</span></span>) .then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">r</span></span></span><span class="hljs-function"> =&gt;</span></span> r.json()) .then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">_posts</span></span></span><span class="hljs-function"> =&gt;</span></span> setPosts(_posts)) }, []); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> {posts.map(post =&gt; </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">key</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">{post.id}</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> {post.message} </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">)} </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span> };</code> </pre> <br><h2 id="summary">  Ringkasan </h2><br><p>  Kami berhasil.  Itu adalah perjalanan yang menarik, tetapi juga memiliki akhir (bahkan mungkin bahagia). </p><br><p>  Kami mulai dengan pemahaman tentang masalah dengan menyimpan token otorisasi.  Kemudian kami mengimplementasikan solusi dan akhirnya melihat contoh bagaimana mungkin digunakan dalam aplikasi Bereaksi. </p><br><p>  Seperti yang saya katakan sebelumnya, Anda dapat menemukan implementasi saya di GitHub di perpustakaan.  Ini memecahkan masalah yang sedikit lebih umum dan tidak membuat asumsi tentang struktur objek dengan token atau cara memperbarui token, jadi Anda perlu memberikan beberapa argumen tambahan.  Tetapi ide solusinya sama dan repositori juga berisi instruksi tentang cara menggunakannya. </p><br><p>  Di sini saya dapat mengucapkan Terima kasih atas membaca artikel dan saya harap ini membantu Anda. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id485764/">https://habr.com/ru/post/id485764/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id485746/index.html">Platform ke-4 berangkat dari server yang digunakan</a></li>
<li><a href="../id485748/index.html">Rantai opsional, penyatuan dengan nol, dan bagaimana mereka mengubah pendekatan kami dalam menulis kode</a></li>
<li><a href="../id485750/index.html">API yang akhirnya layak ditingkatkan dari Java 8. Bagian 1</a></li>
<li><a href="../id485758/index.html">Raksasa modular dengan kontrol online, serta tekstil dan keyboard rajutan Joe Paradiso</a></li>
<li><a href="../id485760/index.html">Ekstensi di Kotlin. Atavisme berbahaya atau alat yang berguna?</a></li>
<li><a href="../id485766/index.html">Aturan makan</a></li>
<li><a href="../id485768/index.html">Tren Web 2020 Layak Dicoba</a></li>
<li><a href="../id485770/index.html">Polemik salah</a></li>
<li><a href="../id485772/index.html">Dari desktop ke pusat data virtual - bagaimana kami menuju virtualisasi</a></li>
<li><a href="../id485776/index.html">Seluruh geografi: tugas navigasi dan geodetik dalam berbagai bahasa</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>