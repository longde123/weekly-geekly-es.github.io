<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üíí üö∞ üë©üèø‚Äçüíª Initialisation en C ++ moderne üõéÔ∏è ‚úçüèº üåÆ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Il est bien connu que la s√©mantique d'initialisation est l'une des parties les plus complexes du C ++. Il existe de nombreux types d'initialisation, d...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Initialisation en C ++ moderne</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/jugru/blog/469465/"><p><img src="https://habrastorage.org/webt/fy/g7/eb/fyg7ebgmdmbykh6evie2r7gx-zc.jpeg"></p><br><p>  Il est bien connu que la s√©mantique d'initialisation est l'une des parties les plus complexes du C ++.  Il existe de nombreux types d'initialisation, d√©crits par diff√©rentes syntaxes, et ils interagissent tous de mani√®re complexe et difficile.  C ++ 11 a apport√© le concept de "l'initialisation universelle".  Malheureusement, elle a introduit des r√®gles encore plus complexes, et √† leur tour, elles ont √©t√© bloqu√©es en C ++ 14, C ++ 17 et modifi√©es √† nouveau en C ++ 20. </p><br><p>  Under the cut - vid√©o et traduction du rapport de Timur Doumler de la conf√©rence <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">C ++ Russia</a> .  Timur r√©sume d'abord les r√©sultats historiques de l'√©volution de l'initialisation en C ++, donne un aper√ßu syst√©matique de la version actuelle de la r√®gle d'initialisation, des probl√®mes typiques et des surprises, explique comment utiliser efficacement toutes ces r√®gles, et parle enfin de nouvelles propositions dans la norme qui peuvent faire de la s√©mantique d'initialisation C ++ 20 est un peu plus pratique.  De plus, l'histoire est en son nom. </p><a name="habracut"></a><br><iframe width="560" height="315" src="https://www.youtube.com/embed/2jJumNzcp6Y" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><p>  <strong>Table des mati√®res</strong> </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Initialisation par d√©faut (C)</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Initialisation de la copie (C)</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Initialisation d'agr√©gat (C)</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Initialisation statique (C)</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Initialisation directe (C ++ 98)</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Initialisation de la valeur (C ++ 03)</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Initialisation universelle (C ++ 11)</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Am√©liorations dans C ++ 14</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Comment initialiser correctement en C ++</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Initialisation affect√©e (C ++ 20)</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Corrections en C ++ 20</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Initialisation directe des types d'agr√©gats (C ++ 20)</a> </li></ul><br><p><img src="https://habrastorage.org/webt/bp/rd/ow/bprdow1rk6jtw5fzpm3bffzirps.gif"></p><br><p>  Le gif que vous voyez maintenant transmet tr√®s bien le message principal du rapport.  Je l'ai trouv√© sur Internet il y a environ six mois et je l'ai <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">affich√©</a> sur mon Twitter.  Dans ses commentaires, quelqu'un a dit qu'il manquait trois autres types d'initialisation.  Une discussion a commenc√©, au cours de laquelle j'ai √©t√© invit√©e √† faire rapport √† ce sujet.  Et donc tout a commenc√©. </p><br><p>  √Ä propos de l'initialisation, Nikolay Yossutis l'a d√©j√† <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">dit</a> .  Son rapport comprenait une diapositive √©num√©rant 19 fa√ßons diff√©rentes d'initialiser un entier: </p><br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i1; <span class="hljs-comment"><span class="hljs-comment">//undefined value int i2 = 42; //note: inits with 42 int i3(42); //inits with 42 int i4 = int(); //inits with 42 int i5{42}; //inits with 42 int i6 = {42}; //inits with 42 int i7{}; //inits with 0 int i8 = {}; //inits with 0 auto i9 = 42; //inits with 42 auto i10{42}; //C++11: std::initializer_list&lt;int&gt;, C++14: int auto i11 = {42}; //inits std::initializer_list&lt;int&gt; with 42 auto i12 = int{42}; //inits int with 42 int i13(); //declares a function int i14(7, 9); //compile-time error int i15 = (7, 9); //OK, inits int with 9 (comma operator) int i16 = int(7, 9); //compile-time error int i17(7, 9); //compile-time error auto i18 = (7, 9); //OK, inits int with 9 (comma operator) auto i19 = int(7, 9); //compile-time error</span></span></code> </pre> <br><p>  Il me semble que c'est une situation unique pour un langage de programmation.  L'initialisation d'une variable est l'une des actions les plus simples, mais en C ++ ce n'est pas du tout facile √† faire.  Il est peu probable que cette langue ait un autre domaine dans lequel, au cours des derni√®res ann√©es, il y aurait eu autant de rapports d'√©carts par rapport √† la norme, de corrections et de changements.  Les r√®gles d'initialisation changent de standard en standard, et il existe d'innombrables publications sur Internet sur la fa√ßon d'initialiser en C ++.  Par cons√©quent, en faire une revue syst√©matique est une t√¢che non triviale. </p><br><p>  Je pr√©senterai le mat√©riel par ordre chronologique: nous parlerons d'abord de ce qui a √©t√© h√©rit√© de C, puis de C ++ 98, puis de C ++ 03, C ++ 11, C ++ 14 et C ++ 17.  Nous discuterons des erreurs courantes et je ferai mes recommandations concernant l'initialisation correcte.  Je parlerai √©galement des innovations en C ++ 20.  Un tableau r√©capitulatif sera pr√©sent√© √† la toute fin du rapport. </p><br><a name="a1"></a><br><h1 id="inicializaciya-po-umolchaniyu-s">  Initialisation par d√©faut (C) </h1><br><p>  En C ++, beaucoup de choses sont h√©rit√©es de C, c'est pourquoi nous allons commencer avec.  Il existe plusieurs fa√ßons d'initialiser des variables en C.  Ils peuvent ne pas √™tre initialis√©s du tout, et cela s'appelle l' <em>initialisation par d√©faut</em> .  √Ä mon avis, c'est un nom malheureux.  Le fait est qu'aucune variable ne re√ßoit de valeur par d√©faut, elle n'est tout simplement pas initialis√©e.  Si vous vous tournez vers une variable non initialis√©e en C ++ et C, vous obtenez un comportement non d√©fini: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> i; <span class="hljs-comment"><span class="hljs-comment">// undefined behaviour }</span></span></code> </pre> <br><p>  La m√™me chose s'applique aux types personnalis√©s: si dans certaines <code>struct</code> il y a des champs non initialis√©s, alors lors de leur acc√®s, un comportement non d√©fini se produit √©galement: </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Widget</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> j; }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ Widget widget; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> widget.i; <span class="hljs-comment"><span class="hljs-comment">//   }</span></span></code> </pre> <br><p>  De nombreuses nouvelles constructions ont √©t√© ajout√©es √† C ++: classes, constructeurs, m√©thodes publiques, priv√©es, mais rien de tout cela n'affecte le comportement qui vient d'√™tre d√©crit.  Si un √©l√©ment n'est pas initialis√© dans la classe, alors lors de l'acc√®s, un comportement ind√©fini se produit: </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Widget</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: Widget() {} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_i</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">noexcept</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> i; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_j</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">noexcept</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> j; } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> j; }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ Widget widget; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> widget.get_i(); <span class="hljs-comment"><span class="hljs-comment">// Undefined behaviour! }</span></span></code> </pre> <br><p>  Il n'y a aucun moyen magique d'initialiser un √©l√©ment de classe en C ++ par d√©faut.  C'est un point int√©ressant, et pendant les premi√®res ann√©es de ma carri√®re avec C ++, je ne le savais pas.  Ni le compilateur ni l'IDE, que j'ai utilis√© √† l'√©poque, ne me l'ont rappel√© en aucune fa√ßon.  Mes coll√®gues n'ont pas fait attention √† cette fonctionnalit√© lors de la v√©rification du code.  Je suis presque s√ªr qu'√† cause d'elle, il y a des bugs assez √©tranges dans mon code √©crits pendant ces ann√©es.  Il me semblait √©vident que les classes devraient initialiser leurs variables. </p><br><p>  En C ++ 98, vous pouvez initialiser des variables √† l'aide de la liste d'initialisation des membres.  Mais une telle solution au probl√®me n'est pas optimale, car elle doit √™tre effectu√©e dans chaque constructeur, et c'est facile √† oublier.  De plus, l'initialisation se d√©roule dans l'ordre dans lequel les variables sont d√©clar√©es et non dans l'ordre de la liste d'initialisation des membres: </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// C++98: member initialiser list class Widget { public: Widget() : i(0), j(0) {} // member initialiser list int get_i() const noexcept { return i; } int get_j() const noexcept { return j; } private: int i; int j; }; int main() { Widget widget; return widget.get_i(); }</span></span></code> </pre> <br><p>  En C ++ 11, des initialiseurs de membres directs ont √©t√© ajout√©s, ce qui est beaucoup plus pratique √† utiliser.  Ils vous permettent d'initialiser toutes les variables en m√™me temps, ce qui donne l'assurance que tous les √©l√©ments sont initialis√©s: </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// C++11: default member initialisers class Widget { public: Widget() {} int get_i() const noexcept { return i; } int get_j() const noexcept { return j; } private: int i = 0; // default member initialisers int j = 0; }; int main() { Widget widget; return widget.get_i(); }</span></span></code> </pre> <br><p>  Ma premi√®re recommandation: chaque fois que vous le pouvez, utilisez toujours les DMI (initialiseurs de membres directs).  Ils peuvent √™tre utilis√©s √† la fois avec des types int√©gr√©s ( <code>float</code> et <code>int</code> ) et avec des objets.  L'habitude d'initialiser des √©l√©ments nous fait aborder cette question plus consciemment. </p><br><a name="a2"></a><br><h1 id="kopiruyuschaya-inicializaciya-s">  Initialisation de la copie (C) </h1><br><p>  Ainsi, la premi√®re m√©thode d'initialisation h√©rit√©e de C est l'initialisation par d√©faut, et elle ne doit pas √™tre utilis√©e.  La deuxi√®me m√©thode consiste √† <em>initialiser la copie</em> .  Dans ce cas, nous indiquons la variable et par le signe √©gal - sa valeur: </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// copy initialization int main() { int i = 2; }</span></span></code> </pre> <br><p>  L'initialisation de copie est √©galement utilis√©e lorsqu'un argument est pass√© √† une fonction par valeur, ou lorsqu'un objet est renvoy√© d'une fonction par valeur: </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// copy initialization int square(int i) { return i * i; }</span></span></code> </pre> <br><p>  Un signe √©gal peut donner l'impression qu'une valeur est affect√©e, mais ce n'est pas le cas.  L'initialisation de la copie n'est pas une affectation de valeur.  Il n'y aura rien sur l'appropriation dans ce rapport. </p><br><p>  Autre propri√©t√© importante de l'initialisation de la copie: si les types de valeurs ne correspondent pas, une s√©quence de conversion est ex√©cut√©e.  Une s√©quence de conversion a certaines r√®gles, par exemple, elle n'appelle pas de constructeurs explicites, car ils ne transforment pas de constructeurs.  Par cons√©quent, si vous effectuez une initialisation de copie pour un objet dont le constructeur est marqu√© comme explicite, une erreur de compilation se produit: </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Widget</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">explicit</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Widget</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{} }; Widget w1 = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-comment"><span class="hljs-comment">// ERROR</span></span></code> </pre> <br><p>  De plus, s'il existe un autre constructeur qui n'est pas explicite, mais dont le type est pire, alors l'initialisation de la copie l'appellera, en ignorant le constructeur explicite: </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Widget</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">explicit</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Widget</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{} Widget(<span class="hljs-keyword"><span class="hljs-keyword">double</span></span>) {} }; Widget w1 = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-comment"><span class="hljs-comment">//  Widget(double)</span></span></code> </pre> <br><a name="a3"></a><br><h1 id="agregatnaya-inicializaciya-s">  Initialisation d'agr√©gat (C) </h1><br><p>  Le troisi√®me type d'initialisation dont je voudrais parler est <em>l'initialisation agr√©g√©e</em> .  Il est ex√©cut√© lorsque le tableau est initialis√© avec une s√©rie de valeurs entre accolades: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i[<span class="hljs-number"><span class="hljs-number">4</span></span>] = {<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>};</code> </pre> <br><p>  Si vous ne sp√©cifiez pas la taille du tableau, il est d√©riv√© du nombre de valeurs entre parenth√®ses: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> j[] = {<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>}; <span class="hljs-comment"><span class="hljs-comment">// array size deduction</span></span></code> </pre> <br><p>  La m√™me initialisation est utilis√©e pour les classes agr√©g√©es, c'est-√†-dire les classes qui ne sont qu'une collection d'√©l√©ments publics (il y a quelques r√®gles de plus dans la d√©finition des classes agr√©g√©es, mais maintenant nous ne nous attarderons pas sur elles): </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Widget</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> j; }; Widget widget = {<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">3.14159</span></span>};</code> </pre> <br><p>  Cette syntaxe a fonctionn√© m√™me en C et C ++ 98, et, √† partir de C ++ 11, vous pouvez ignorer le signe √©gal: </p><br><pre> <code class="cpp hljs">Widget widget{<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">3.14159</span></span>};</code> </pre> <br><p>  L'initialisation agr√©g√©e utilise en fait l'initialisation de la copie pour chaque √©l√©ment.  Par cons√©quent, si vous essayez d'utiliser l'initialisation agr√©g√©e (√† la fois avec un signe √©gal et sans lui) pour plusieurs objets avec des constructeurs explicites, une initialisation de copie est effectu√©e pour chaque objet et une erreur de compilation se produit: </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Widget</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">explicit</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Widget</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{} }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Thingy</span></span></span><span class="hljs-class"> {</span></span> Widget w1, w2; }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ Thingy thingy = {<span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>}; <span class="hljs-comment"><span class="hljs-comment">// ERROR Thingy thingy {3, 4}; // ERROR }</span></span></code> </pre> <br><p>  Et s'il existe un autre constructeur pour ces objets, non explicite, alors il est appel√©, m√™me s'il est plus mal adapt√© √† taper: </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Widget</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">explicit</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Widget</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{} Widget(<span class="hljs-keyword"><span class="hljs-keyword">double</span></span>) {} }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Thingy</span></span></span><span class="hljs-class"> {</span></span> Widget w1, w2; }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ Thingy thingy = {<span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>}; <span class="hljs-comment"><span class="hljs-comment">//  Widget(double) Thingy thingy {3, 4}; //  Widget(double) }</span></span></code> </pre> <br><p>  Consid√©rons une autre propri√©t√© d'initialisation agr√©g√©e.  Question: quelle valeur ce programme renvoie-t-il? </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Widget</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> j; }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ Widget widget = {<span class="hljs-number"><span class="hljs-number">1</span></span>}; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> widget.j; }</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Texte masqu√©</b> <div class="spoiler_text"><p>  C'est vrai, z√©ro.  Si vous ignorez certains √©l√©ments dans un tableau de valeurs lors de l'initialisation agr√©g√©e, les variables correspondantes sont d√©finies sur z√©ro.  C'est une propri√©t√© tr√®s utile, car gr√¢ce √† elle, il ne peut jamais y avoir d'√©l√©ments non initialis√©s.  Il fonctionne avec des classes agr√©g√©es et avec des tableaux: </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//     int[100] = {};</span></span></code> </pre> </div></div><br><p>  Une autre propri√©t√© importante de l'initialisation d'agr√©gat est l'omission des crochets (accolade √©lision).  Quelle valeur pensez-vous que ce programme rapporte?  Il a un <code>Widget</code> , qui est un agr√©gat de deux valeurs <code>int</code> , et <code>Thingy</code> , un agr√©gat de <code>Widget</code> et <code>int</code> .  Qu'obtenons-nous si nous lui transmettons deux valeurs d'initialisation: <code>{1, 2}</code> ? </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Widget</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> j; }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Thingy</span></span></span><span class="hljs-class"> {</span></span> Widget w; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> k; }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ Thingy t = {<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>}; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> tk; <span class="hljs-comment"><span class="hljs-comment">//   ? }</span></span></code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Texte masqu√©</b> <div class="spoiler_text"><p>  La r√©ponse est z√©ro.  Ici, nous avons affaire √† un sous-agr√©gat, c'est-√†-dire √† une classe d'agr√©gats imbriqu√©e.  Ces classes peuvent √™tre initialis√©es √† l'aide de crochets imbriqu√©s, mais vous pouvez ignorer l'une de ces paires de crochets.  Dans ce cas, une travers√©e r√©cursive du sous-agr√©gat est effectu√©e et <code>{1, 2}</code> s'av√®re √™tre √©quivalent √† <code>{{1, 2}, 0}</code> .  Certes, cette propri√©t√© n'est pas tout √† fait √©vidente. </p></div></div><br><a name="a4"></a><br><h1 id="staticheskaya-inicializaciya-s">  Initialisation statique (C) </h1><br><p>  Enfin, <em>l'initialisation statique est</em> √©galement h√©rit√©e de C: les variables statiques sont toujours initialis√©es.  Cela peut se faire de plusieurs mani√®res.  Une variable statique peut √™tre initialis√©e avec une expression constante.  Dans ce cas, l'initialisation se produit au moment de la compilation.  Si vous n'affectez aucune valeur √† la variable, elle est initialis√©e √† z√©ro: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">3</span></span>; <span class="hljs-comment"><span class="hljs-comment">//   statit int j; //   int main() { return i + j; }</span></span></code> </pre> <br><p>  Ce programme renvoie 3 m√™me si <code>j</code> pas initialis√©.  Si la variable est initialis√©e non pas par une constante, mais par un objet, des probl√®mes peuvent survenir. </p><br><p>  Voici un exemple d'une vraie biblioth√®que sur laquelle je travaillais: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> Colour red = {<span class="hljs-number"><span class="hljs-number">255</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>};</code> </pre> <br><p>  Il y avait une classe Color et les couleurs primaires (rouge, vert, bleu) √©taient d√©finies comme des objets statiques.  C'est une action valide, mais d√®s qu'un autre objet statique appara√Æt dans l'initialiseur dont le <code>red</code> est utilis√©, l'incertitude appara√Æt car il n'y a pas d'ordre rigide dans lequel les variables sont initialis√©es.  Votre application peut acc√©der √† une variable non initialis√©e, puis elle se bloque.  Heureusement, en C ++ 11, il est devenu possible d'utiliser le constructeur <code>constexpr</code> , puis nous avons affaire √† une initialisation constante.  Dans ce cas, il n'y a aucun probl√®me avec l'ordre d'initialisation. </p><br><p>  Ainsi, quatre types d'initialisation sont h√©rit√©s du langage C: initialisation par d√©faut, copie, initialisation agr√©g√©e et statique. </p><br><a name="a5"></a><br><h1 id="pryamaya-inicializaciya-s98">  Initialisation directe (C ++ 98) </h1><br><p>  Passons au C ++ 98.  Peut-√™tre la caract√©ristique la plus importante qui distingue C ++ de C est les constructeurs.  Voici un exemple d'appel de constructeur: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">Widget </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">widget</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">1</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">2</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>(<span class="hljs-number"><span class="hljs-number">3</span></span>);</code> </pre> <br><p>  En utilisant la m√™me syntaxe, vous pouvez initialiser des types int√©gr√©s comme <code>int</code> et <code>float</code> .  Cette syntaxe est appel√©e <em>initialisation directe</em> .  Il est toujours ex√©cut√© lorsque nous avons un argument entre parenth√®ses. </p><br><p>  Pour les types int√©gr√©s ( <code>int</code> , <code>bool</code> , <code>float</code> ), il n'y a pas de diff√©rence ici avec l'initialisation de la copie.  Si nous parlons de types d'utilisateurs, alors, contrairement √† l'initialisation de copie, avec l'initialisation directe, vous pouvez passer plusieurs arguments.  En fait, pour cela, l'initialisation directe a √©t√© invent√©e. </p><br><p>  De plus, une initialisation directe n'ex√©cute pas de s√©quence de conversion.  Au lieu de cela, le constructeur est appel√© √† l'aide de la r√©solution de surcharge.  L'initialisation directe a la m√™me syntaxe qu'un appel de fonction et utilise la m√™me logique que les autres fonctions C ++. </p><br><p>  Par cons√©quent, dans la situation avec un constructeur explicite, l'initialisation directe fonctionne correctement, bien que l'initialisation de la copie g√©n√®re une erreur: </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Widget</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">explicit</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Widget</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{} }; Widget w1 = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-comment"><span class="hljs-comment">//  Widget w2(1); //   </span></span></code> </pre> <br><p>  Dans une situation avec deux constructeurs, dont l'un est explicite et le second est de type moins appropri√©, le premier est appel√© avec initialisation directe et le second est appel√© avec la copie.  Dans cette situation, la modification de la syntaxe entra√Ænera un appel √† un autre constructeur - cela est souvent oubli√©: </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Widget</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">explicit</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Widget</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{} Widget(<span class="hljs-keyword"><span class="hljs-keyword">double</span></span>) {} }; Widget w1 = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-comment"><span class="hljs-comment">//  Widget(double) Widget w2(1); //  Widget(int)</span></span></code> </pre> <br><p>  L'initialisation directe est toujours utilis√©e lorsque des parenth√®ses sont utilis√©es, y compris lorsque la notation d'invocation de constructeur est utilis√©e pour initialiser un objet temporaire, ainsi que dans les <code>new</code> expressions avec un initialiseur entre crochets et dans <code>cast</code> expressions <code>cast</code> : </p><br><pre> <code class="cpp hljs">useWidget(Widget(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>)); <span class="hljs-comment"><span class="hljs-comment">//   auto* widget_ptr = new Widget(2, 3); // new-expression with (args) static_cast&lt;Widget&gt;(thingy); // cast</span></span></code> </pre> <br><p>  Cette syntaxe existe aussi longtemps que C ++ existe, et elle a un d√©faut important que Nikolai a mentionn√© dans son discours d'ouverture: <em>l'analyse la plus contrariante</em> .  Cela signifie que tout ce que le compilateur peut lire comme une d√©claration (d√©claration), il se lit exactement comme une d√©claration. </p><br><p>  Prenons un exemple dans lequel il existe une classe <code>Widget</code> et une classe <code>Thingy</code> , et un constructeur <code>Thingy</code> qui re√ßoit un <code>Widget</code> : </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Widget</span></span></span><span class="hljs-class"> {</span></span>}; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Thingy</span></span></span><span class="hljs-class"> {</span></span> Thingy(Widget) {} }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-function"><span class="hljs-function">Thingy </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">thingy</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Widget())</span></span></span></span>; }</code> </pre> <br><p>  √Ä premi√®re vue, il semble qu'√† l'initialisation de <code>Thingy</code> , le <code>Widget</code> par d√©faut cr√©√© lui soit transmis, mais en fait, la fonction est d√©clar√©e ici.  Ce code d√©clare une fonction qui re√ßoit une autre fonction en entr√©e, qui ne re√ßoit rien en entr√©e et renvoie un <code>Widget</code> , et la premi√®re fonction renvoie <code>Thingy</code> .  Le code se compile sans erreur, mais il est peu probable que nous recherchions un tel comportement. </p><br><a name="a6"></a><br><h1 id="inicializaciya-znacheniem-c03">  Initialisation de la valeur (C ++ 03) </h1><br><p>  Passons √† la prochaine version - C ++ 03.  Il est g√©n√©ralement admis qu'il n'y a eu aucun changement significatif dans cette version, mais ce n'est pas le cas.  En C ++ 03, une initialisation de valeur est apparue, dans laquelle des parenth√®ses vides sont √©crites: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>(); <span class="hljs-comment"><span class="hljs-comment">// UB  C++98, 0   C++03 }</span></span></code> </pre> <br><p>  En C ++ 98, un comportement ind√©fini se produit ici car l'initialisation a lieu par d√©faut et √† partir de C ++ 03, ce programme renvoie z√©ro. </p><br><p>  La r√®gle est la suivante: s'il existe un constructeur par d√©faut d√©fini par l'utilisateur, l'initialisation avec une valeur appelle ce constructeur, sinon z√©ro est renvoy√©. </p><br><p>  Examinons plus en d√©tail la situation avec le constructeur personnalis√©: </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Widget</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i; }; <span class="hljs-function"><span class="hljs-function">Widget </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_widget</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Widget(); <span class="hljs-comment"><span class="hljs-comment">// value initialization } int main() { return get_widget().i; }</span></span></code> </pre> <br><p>  Dans ce programme, la fonction initialise la valeur du nouveau <code>Widget</code> et la renvoie.  Nous appelons cette fonction et acc√©dons √† l'√©l√©ment <code>i</code> de l'objet <code>Widget</code> .  Depuis C ++ 03, la valeur de retour ici est z√©ro, car il n'y a pas de constructeur par d√©faut d√©fini par l'utilisateur.  Et si un tel constructeur existe, mais n'initialise pas <code>i</code> , alors nous obtenons un comportement ind√©fini: </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Widget</span></span></span><span class="hljs-class"> {</span></span> Widget() {} <span class="hljs-comment"><span class="hljs-comment">//   int i; }; Widget get_widget() { return Widget(); // value initialization } int main() { return get_widget().i; //   ,  UB }</span></span></code> </pre> <br><p>  Il convient de noter que ¬´d√©fini par l'utilisateur¬ª ne signifie pas ¬´d√©fini par l'utilisateur¬ª.  Cela signifie que l'utilisateur doit fournir le corps du constructeur, c'est-√†-dire des accolades.  Si dans l'exemple ci-dessus, remplacez le corps du constructeur par <code>= default</code> (cette fonctionnalit√© a √©t√© ajout√©e en C ++ 11), la signification du programme change.  Maintenant, nous avons un constructeur d√©fini par l'utilisateur (d√©fini par l'utilisateur), mais non fourni par l'utilisateur (fourni par l'utilisateur), donc le programme renvoie z√©ro: </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Widget</span></span></span><span class="hljs-class"> {</span></span> Widget() = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; <span class="hljs-comment"><span class="hljs-comment">// user-defined,   user-provided int i; }; Widget get_widget() { return Widget(); // value initialization } int main() { return get_widget().i; //  0 }</span></span></code> </pre> <br><p>  Essayons maintenant de <code>Widget() = default</code> hors de la classe.  La signification du programme a encore chang√©: <code>Widget() = default</code> est consid√©r√© comme un constructeur fourni par l'utilisateur s'il est en dehors de la classe.  Le programme renvoie √† nouveau un comportement ind√©fini. </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Widget</span></span></span><span class="hljs-class"> {</span></span> Widget(); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i; }; Widget::Widget() = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; <span class="hljs-comment"><span class="hljs-comment">//  ,  user-provided Widget get_widget() { return Widget(); // value initialization } int main() { return get_widget().i; //    , UB }</span></span></code> </pre> <br><p>  Il y a une certaine logique: un constructeur d√©fini en dehors d'une classe peut √™tre √† l'int√©rieur d'une autre unit√© de traduction.  Le compilateur peut ne pas voir ce constructeur, car il peut se trouver dans un autre fichier <code>.cpp</code> .  Par cons√©quent, le compilateur ne peut tirer aucune conclusion sur un tel constructeur, et il ne peut pas distinguer un constructeur avec un corps d'un constructeur avec <code>= default</code> . </p><br><a name="a7"></a><br><h1 id="universalnaya-inicializaciya-c11">  Initialisation universelle (C ++ 11) </h1><br><p>  Il y a eu de nombreux changements tr√®s importants en C ++ 11.  En particulier, une uniformisation universelle a √©t√© introduite, que je pr√©f√®re appeler ¬´initialisation de la licorne¬ª car elle est juste magique.  Voyons pourquoi elle est apparue. </p><br><p>  Comme vous l'avez d√©j√† remarqu√©, en C ++, il existe de nombreuses syntaxes d'initialisation diff√©rentes avec des comportements diff√©rents.  L'analysante contrariante avec des parenth√®ses a caus√© beaucoup d'inconv√©nients.  Les d√©veloppeurs n'aimaient pas non plus que l'initialisation d'agr√©gat puisse √™tre utilis√©e uniquement avec des tableaux, mais pas avec des conteneurs comme <code>std::vector</code> .  Au lieu de cela, vous avez d√ª ex√©cuter <code>.reserve</code> et <code>.push_back</code> , ou utiliser toutes sortes de biblioth√®ques effrayantes: </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//    ,  : std::vector&lt;int&gt; vec = {0, 1, 2, 3, 4}; //   : std::vector&lt;int&gt; vec; vec.reserve(5); vec.push_back(0); vec.push_back(1); vec.push_back(2); vec.push_back(3); vec.push_back(4);</span></span></code> </pre> <br><p>  Les cr√©ateurs de la langue ont essay√© de r√©soudre tous ces probl√®mes en introduisant une syntaxe avec des accolades mais sans signe √©gal.  Il a √©t√© suppos√© que ce serait une seule syntaxe pour tous les types, dans laquelle des accolades sont utilis√©es et il n'y a pas de probl√®me d'analyse vexing.  Dans la plupart des cas, cette syntaxe fait son travail. </p><br><p>  Cette nouvelle initialisation est appel√©e <em>initialisation de liste</em> , et elle se d√©cline en deux types: direct et copie.  Dans le premier cas, seuls les accolades sont utilis√©es, dans le second - accolades avec un signe √©gal: </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// direct-list-initialization Widget widget{1, 2}; // copy-list-initialization Widget widget = {1, 2};</span></span></code> </pre> <br><p>  La liste utilis√©e pour l'initialisation est appel√©e <em>braced-init-list</em> .  Il est important que cette liste ne soit pas un objet, elle n'a pas de type.  Le passage √† C ++ 11 √† partir de versions ant√©rieures ne cr√©e aucun probl√®me avec les types d'agr√©gats, donc cette modification n'est pas critique.  Mais maintenant, la liste entre accolades a de nouvelles fonctionnalit√©s.  Bien qu'il n'ait pas de type, il peut √™tre cach√© converti en <code>std::initializer_list</code> , c'est un nouveau type sp√©cial.  Et s'il y a un constructeur qui accepte <code>std::initializer_list</code> en entr√©e, alors ce constructeur est appel√©: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">vector</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-comment"><span class="hljs-comment">//... vector(std::initializer_list&lt;T&gt; init); //   initializer_list }; std::vector&lt;int&gt; vec{0, 1, 2, 3, 4}; //  ^ </span></span></code> </pre> <br><p>  Il me semble que du c√¥t√© du comit√© C ++, <code>std::initializer_list</code> n'√©tait pas la solution la plus r√©ussie.  De lui plus de mal que de bien. </p><br><p>  Pour commencer, <code>std::initializer_list</code> est un vecteur de taille fixe avec des √©l√©ments <code>const</code> .  Autrement dit, c'est un type, il a des fonctions de <code>begin</code> et de <code>end</code> que les it√©rateurs retournent, il a son propre type d'it√©rateur, et pour l'utiliser, vous devez inclure un en-t√™te sp√©cial.  Puisque les √©l√©ments <code>std::initializer_list</code> sont <code>const</code> , il ne peut pas √™tre d√©plac√©, donc si <code>T</code> dans le code ci-dessus est de type move-only, le code ne sera pas ex√©cut√©. </p><br><p>  Ensuite, <code>std::initializer_list</code> est un objet.  En l'utilisant, nous cr√©ons et transf√©rons des objets.  En r√®gle g√©n√©rale, le compilateur peut optimiser cela, mais du point de vue de la s√©mantique, nous traitons toujours des objets inutiles. </p><br><p>  Il y a quelques mois, il y avait un sondage sur Twitter: si vous pouviez remonter le temps et supprimer quelque chose de C ++, que supprimeriez-vous?  La plupart de tous les votes ont re√ßu exactement <code>initializer_list</code> . </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">https://twitter.com/shafikyaghmour/status/1058031143935561728</a> </p><br><p>         , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><code>   initializer_list</code></a> .         ,     . </p><br><p>  ,    .   ,     <code>initializer_list</code> ,              .    : </p><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; v(<span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-comment"><span class="hljs-comment">//   0, 0, 0 std::vector&lt;int&gt; v{3, 0}; //   3, 0</span></span></code> </pre> <br><p>   <code>vector</code>    <code>int</code>    ,    ,      ,   ‚Äî  .       .       ,   <code>initializer_list</code>        , 3  0. </p><br><p>        : </p><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-function"><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">s</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">48</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">'a'</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; <span class="hljs-comment"><span class="hljs-comment">// "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa" std::string s{48, 'a'}; // "0a"</span></span></code> </pre> <br><p>       48  ¬´¬ª,     ¬´0¬ª.   ,   <code>string</code>    <code>initializer_list</code>  . 48   ,     .  ASCII  48 ‚Äî   ¬´0¬ª.   ,    ,    , <code>int</code>  <code>char</code> .         .    ,       ,   . </p><br><p>       .   ,    ?    ? </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T, <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> N&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">auto</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;T&gt;{N}; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> test&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>&gt;().size(); }</code> </pre> <br><div class="spoiler"> <b class="spoiler_title"> </b> <div class="spoiler_text"><p>      ,    ‚Äî 3.   <code>string</code>   <code>int</code> ,   1,    <code>std::vector&lt;std::int&gt;</code>   <code>initializer_list</code> .         <code>initializer_list</code> ,   .    <code>string</code>  <code>int</code>  <code>float</code> ,     ,  .      ,     . ,     emplace ,          .  ,     <code>{}</code>    . </p></div></div><br><p>   ,     . </p><br><p>         <br> . <br>    ‚Äî   ( <code>{a}</code> )  <br>   ( <code>= {a}</code> ); <br>      : </p><br><ol><li>  ¬´¬ª   ,   <code>std::initializer_list</code> . <br>         ‚Äî  . </li><li>    ,   <br>   <code>()</code>    . </li></ol><br><p>      . </p><br><p>  1:   <code>= {a}</code> ,      <code>a</code> , <br>     . </p><br><p>  2:   , <code>{}</code> . <br>           ,   <code>initializer_list</code> . <br>     <code>Widget&lt;int&gt; widget{}\</code> ? </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> Typename&lt;T&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Widget</span></span></span><span class="hljs-class"> {</span></span> Widget(); Widget(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">initializer_list</span></span>&lt;T&gt;); }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ Widget&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; widget{}; <span class="hljs-comment"><span class="hljs-comment">//    ? }</span></span></code> </pre> <br><p>  ,    ,  <code>initializer_list</code> ,      <code>initializer_list</code>   .        .      ,  ,  <code>initializer_list</code> .     ,   .  ,     . </p><br><p>       <code>{}</code> . , -,  ,   <code>Widget() = default</code>  <code>Widget() {}</code>    ‚Äî     . </p><br><p> <code>Widget() = default</code> : </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Widget</span></span></span><span class="hljs-class"> {</span></span> Widget() = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i; }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ Widget widget{}; <span class="hljs-comment"><span class="hljs-comment">//   (),   vexing parse return widget.i; //  0 }</span></span></code> </pre> <br><p> <code>Widget() {}</code> : </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Widget</span></span></span><span class="hljs-class"> {</span></span> Widget() {}; <span class="hljs-comment"><span class="hljs-comment">// user-provided  int i; }; int main() { Widget widget{}; //  ,    return widget.i; //  ,  UB }</span></span></code> </pre> <br><p>      :   ,    (narrowing conversions).    <code>int</code>  <code>double</code> ,    ,     : </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i{<span class="hljs-number"><span class="hljs-number">2.0</span></span>}; <span class="hljs-comment"><span class="hljs-comment">// ! }</span></span></code> </pre> <br><p>    ,       <code>double</code> .   C++11,         ,      .          : </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Widget</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> j; }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ Widget widget = {<span class="hljs-number"><span class="hljs-number">1.0</span></span>, <span class="hljs-number"><span class="hljs-number">0.0</span></span>}; <span class="hljs-comment"><span class="hljs-comment">//   ++11    C++98/03 }</span></span></code> </pre> <br><p> ,        , ,     ,       (brace elision).   ,       ,   . ,    <code>map</code> .       <code>map</code> ,     ‚Äî  : </p><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">map</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; my_map {{<span class="hljs-string"><span class="hljs-string">"abc"</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>}, {<span class="hljs-string"><span class="hljs-string">"def"</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>}};</code> </pre> <br><p>   ,      .    : </p><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&gt; v1 {<span class="hljs-string"><span class="hljs-string">"abc"</span></span>, <span class="hljs-string"><span class="hljs-string">"def"</span></span>}; <span class="hljs-comment"><span class="hljs-comment">// OK std::vector&lt;std::string&gt; v2 {{"abc", "def"}}; // ??</span></span></code> </pre> <br><p> ,    ,     <code>initializer_list</code> .      <code>initializer_list</code>   ,   , ,     .           ,   .  , . </p><br><p>  <code>initializer_list</code>     ‚Äî  <code>initializer_list</code> ,        .     ,    <code>const char*</code> . ,  <code>string</code>  ,     <code>char</code>    .        .     ,     ,   . </p><br><p> : </p><br><ul><li>       ; </li><li>       . </li></ul><br><p>  .    braced-init-list     .    : </p><br><pre> <code class="cpp hljs">Widget&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; f1() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> {<span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>}; <span class="hljs-comment"><span class="hljs-comment">// copy-list    } void f2(Widget); f2({3, 0}); // copy-list  </span></span></code> </pre> <br><p>     ,    ,    braced-init-list    .    braced-init-list ,       . </p><br><p> ,          .  StackOverflow   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="> </a> ,             . ,      .      ,      ,     : </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;iostream&gt; struct A { A() {} A(const A&amp;) {} }; struct B { B(const A&amp;) {} }; void f(const A&amp;) { std::cout &lt;&lt; "A" &lt;&lt; std::endl; } void f(const B&amp;) { std::cout &lt;&lt; "B" &lt;&lt; std::endl; } int main() { A a; f( {a} ); // A f( {{a}} ); // ambiguous f( {{{a}}} ); // B f({{{{a}}}}); // no matching function }</span></span></span></span></code> </pre> <br><a name="a8"></a><br><h1 id="uluchsheniya-v-s14">   ++14 </h1><br><p> ,      C++11 .      ,   ,        .    C++14.      ,    . </p><br><p> ,  ++11       direct member initializers,     .      ,  direct member initializers  .   ++14,      direct member initializers: </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Widget</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> j = <span class="hljs-number"><span class="hljs-number">0</span></span>; }; Widget widget{<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>}; <span class="hljs-comment"><span class="hljs-comment">//    C++14</span></span></code> </pre> <br><p>        ,    <code>auto</code> .   ++11  <code>auto</code>  braced-init-list,       <code>std::initializer_list</code> : </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">3</span></span>; <span class="hljs-comment"><span class="hljs-comment">// int int i(3); // int int i{3}; // int int i = {3}; // int auto i = 3; // int auto i(3); // int auto i{3}; //  ++11 ‚Äî std::initializer_list&lt;int&gt; auto i = {3}; //  ++11 ‚Äî std::initializer_list&lt;int&gt;</span></span></code> </pre> <br><p>   :   <code>auto i{3}</code> ,     <code>int</code> ,   <code>std::initializer_list&lt;int&gt;</code> .  ++14   ,  <code>auto i{3}</code>    <code>int</code> .          ,     . , <code>auto i = {3}</code>    <code>std::initializer_list&lt;int&gt;</code> .  ,     :      <code>int</code> ,     ‚Äî <code>initializer_list</code> . </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> i = <span class="hljs-number"><span class="hljs-number">3</span></span>; <span class="hljs-comment"><span class="hljs-comment">// int auto i(3); // int auto i{3}; //  ++14 ‚Äî int,         auto i = {3}; //    std::initializer_list&lt;int&gt;</span></span></code> </pre> <br><p> ,  C++14      ,      ,  ,     ,       .   ,     . </p><br><p>     ,  ++14      : </p><br><ul><li><p>   ,   ,  <code>std::initializer_list</code> . </p><br></li><li><p>  <code>std::initializer_list</code>    move-only . </p><br></li><li><p>  c   ,  <code>emplace</code>  <code>make_unique</code>     . </p><br></li><li><p>    ,     : </p><br><ul><li>      ,  -; </li><li>       ; </li><li> auto     . </li></ul><br></li><li><p> ,    ,        . </p><br></li></ul><br><p>   : <code>assert(Widget(2,3))</code> ,  <code>assert(Widget{2,3})</code>  .   ,      ,       ,        .           ,     .    . </p><br><a name="a9"></a><br><h1 id="kak-pravilno-inicializirovat-v-c">     C++ </h1><br><p>       ,      ++. </p><br><p>     <code>int</code>   , . .     ‚Äî      ,          . </p><br><p>      :   ,   ,  <code>std::initializer_list</code> ,   direct member initializers.          ,       . </p><br><p>  ,         √© .             . </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Point</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> y = <span class="hljs-number"><span class="hljs-number">0</span></span>; }; setPosition(Point{<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>}); takeWidget(Widget{});</code> </pre> <br><p>        braced-init-list ‚Äî      . </p><br><pre> <code class="cpp hljs">setPosition({<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>}); takeWidget({});</code> </pre> <br><p>      ,       ,    .   ,         ‚Äî  ,       .  ,     ,     ,    ,   ,    .    ,   ,     <code>initializer_list</code> .        :     ,  ,   . </p><br><p>   : </p><br><ul><li><p> <code>= value</code>    </p><br></li><li><p> <code>= {args}</code>  <code>= {}</code> : </p><br><ul><li>    </li><li>    <code>std::initializer_list</code> </li><li>  direct member initialisation (    <code>(args)</code> ) </li></ul><br></li><li><p> <code>{args}</code>  <code>{}</code>     √©  </p><br></li><li><p> <code>(args)</code>    </p><br></li></ul><br><p> ,   <code>(args)</code>     vexing parse.        .    2013  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="> </a> ,   ,          <code>auto</code> .     ,        :   <code>auto i;</code> ‚Äî    .     ,       : </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> widget = Widget(<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>);</code> </pre> <br><p>   ,        .  ,           ,     vexing parse: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> thingy = Thingy();</code> </pre> <br><p>      ¬´  auto¬ª (¬´almost always auto¬ª, AAA),   ++11  ++14       , , ,     <code>std::atomic&lt;int&gt;</code> : </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> count = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::atomic&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;(<span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-comment"><span class="hljs-comment">// C++11/14:  // std::atomic is neither copyable nor movable</span></span></code> </pre> <br><p>   ,  atomic    .   ,          ,    ,    ,       .  ++17    ,    ,      (guaranteed copy elision): </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> count = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::atomic&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;(<span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-comment"><span class="hljs-comment">// C++17: OK, guaranteed copy elision</span></span></code> </pre> <br><p>        <code>auto</code> .   ‚Äî  direct member initializers.     <code>auto</code>  . </p><br><p>  ++17    CTAD (class template argument deduction). ,              .        .  ,       <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">  CppCon,   CTAD</a> ,       .   ,  ++17   ,    ++11  ++14,   ,       .     ,    , ,   ,      . </p><br><a name="a10"></a><br><h1 id="naznachennaya-inicializaciya-s20">   (++20) </h1><br><p>     ++20,     .  ,  ,          : <em> </em> (designated initialization): </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Widget</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> a; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> b; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> c; }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ Widget widget{.a = <span class="hljs-number"><span class="hljs-number">3</span></span>, .c = <span class="hljs-number"><span class="hljs-number">7</span></span>}; };</code> </pre> <br><p>  ,      .         ,      ,      .        ,       .      <code></code>  <code></code> ,  <code>b</code>  . </p><br><p>      ,  ,     ,     .       ,         . </p><br><p>       ,    ,   99,   : </p><br><ul><li><p>       ,         ,   .  ++   ,     ,    .  : </p><br><pre> <code class="cpp hljs">Widget widget{.c = <span class="hljs-number"><span class="hljs-number">7</span></span>, .a = <span class="hljs-number"><span class="hljs-number">3</span></span>}; <span class="hljs-comment"><span class="hljs-comment">// </span></span></code> </pre> <br><p>  ,     . </p><br></li><li><p>  ++      ,     <code>{.ce = 7};</code> ,    <code>{.c{.e = 7}}</code> : </p><br><pre> <code class="cpp hljs">Widget widget{.ce = <span class="hljs-number"><span class="hljs-number">7</span></span>}; <span class="hljs-comment"><span class="hljs-comment">// </span></span></code> </pre> <br></li><li><p>  ++       ,      ,      : </p><br><pre> <code class="cpp hljs">Widget widget{.a = <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">7</span></span>}; <span class="hljs-comment"><span class="hljs-comment">// </span></span></code> </pre> <br></li><li><p>  ++       . , -,   ,     . </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> arr[<span class="hljs-number"><span class="hljs-number">3</span></span>]{.[<span class="hljs-number"><span class="hljs-number">1</span></span>] = <span class="hljs-number"><span class="hljs-number">7</span></span>}; <span class="hljs-comment"><span class="hljs-comment">// </span></span></code> </pre> <br></li></ul><br><a name="a11"></a><br><h1 id="ispravleniya-v-c20">   C++20 </h1><br><p>      ++20       ,        .     ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">wg21.link/p1008</a> ). </p><br><p>   ++17    ,    ,        .             ,    ,      ,   : </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Widget</span></span></span><span class="hljs-class"> {</span></span> Widget() = <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> j; }; Widget widget1; <span class="hljs-comment"><span class="hljs-comment">//  Widget widget2{}; //   C++17,     C++20</span></span></code> </pre> <br><p>    ,       ,      .  ++20   .        ,              .  ,   .       ,    ,     ,   . </p><br><p>         ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">wg21.link/p1009</a> ). Braced-init-list     <code>new</code> ,   :        ,    ?  ‚Äî ,    : braced-init-list      <code>new</code> : </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">double</span></span> a[]{<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>}; <span class="hljs-comment"><span class="hljs-comment">// OK double* p = new double[]{1, 2, 3}; //   C++17,   C++20</span></span></code> </pre> <br><p>    ,   ++11  braced-init-list.  ++   .        ,       . </p><br><a name="a12"></a><br><h1 id="pryamaya-inicializaciya-agregatnyh-tipov-c20">     (C++20) </h1><br><p> ,  ++20      .       ,             .  ++20  :         ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">wg21.link/p0960</a> ). </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Widget</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> j; }; <span class="hljs-function"><span class="hljs-function">Widget </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">widget</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">1</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">2</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; <span class="hljs-comment"><span class="hljs-comment">//   C++20</span></span></code> </pre> <br><p>            .   ,        <code>emplace</code>  <code>make_unique</code> .      .  :   <code>auto</code> ,          : <em>58.11</em> . </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Widget</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> j; }; <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> widget = Widget(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>);</code> </pre> <br><p>  ,       : </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> arr[<span class="hljs-number"><span class="hljs-number">3</span></span>](<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>);</code> </pre> <br><p>   ,   :   uniform  2.0.     .         ,    , ,  ,           .  ‚Äî  <code>initializer_list</code> :    ,    ,   ‚Äî .    ,    .  ,   -     ,   ‚Äî .       . </p><br><p> ,    .   direct member initializers.   <code>auto</code> .      direct member initializers ‚Äî  ,    .   ,        .         ‚Äî ,     . </p><br><p>    ,    ,  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="></a> .     ‚Äî  ,   ‚Äî  .     ,    . </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/b8d/8a2/229/b8d8a2229e93baf65b78f738750ac635.png"></p><br><blockquote>   ,   ,    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">C++ Russia 2019 Piter</a>     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">¬´Type punning in modern C++¬ª</a> .     ,   ++20,  ,    ,    ¬´¬ª  ++  ,    . </blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr469465/">https://habr.com/ru/post/fr469465/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr469455/index.html">Migration de Nginx vers Envoy Proxy</a></li>
<li><a href="../fr469457/index.html">O√π Extravaganza m√®ne</a></li>
<li><a href="../fr469459/index.html">Connecter des appareils IoT dans la Smart City</a></li>
<li><a href="../fr469461/index.html">¬´Vers les √©toiles¬ª: ¬´Apocalypse aujourd'hui¬ª anti-cosmique</a></li>
<li><a href="../fr469463/index.html">Tendances et pr√©visions dans le traitement du langage naturel</a></li>
<li><a href="../fr469467/index.html">C ++ vs C #</a></li>
<li><a href="../fr469471/index.html">"5 cents" pour parler de Sorts</a></li>
<li><a href="../fr469475/index.html">L'ascension et la chute de Flash, le plugin ennuyeux qui a fa√ßonn√© le web moderne</a></li>
<li><a href="../fr469477/index.html">Il est temps pour Apple d'arr√™ter de comparer l'iPad au PC</a></li>
<li><a href="../fr469479/index.html">D'o√π vient la probabilit√© quantique</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>