<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üïë üé¶ üç∂ Limitar la velocidad de procesamiento de solicitudes o c√≥mo no organizar un ataque DDoS en su cliente üòõ üêæ üëàüèΩ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="A veces, cuando se desarrolla un producto de alta carga, surge una situaci√≥n en la que es necesario procesar no tantas solicitudes como sea posible, s...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Limitar la velocidad de procesamiento de solicitudes o c√≥mo no organizar un ataque DDoS en su cliente</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/448438/"><p> A veces, cuando se desarrolla un producto de alta carga, surge una situaci√≥n en la que es necesario procesar no tantas solicitudes como sea posible, sino limitar el n√∫mero de solicitudes por unidad de tiempo.  En nuestro caso, este es el n√∫mero de notificaciones push enviadas a los usuarios finales.  Lea m√°s sobre algoritmos de limitaci√≥n de velocidad, sus ventajas y desventajas, debajo del corte. </p><br><a name="habracut"></a><br><p>  Primero, un poco sobre nosotros.  Pushwoosh es un servicio b2b para la comunicaci√≥n entre nuestros clientes y sus usuarios.  Brindamos a las empresas soluciones integrales para comunicarse con los usuarios a trav√©s de notificaciones push, correo electr√≥nico y otros canales de comunicaci√≥n.  Adem√°s de enviar mensajes, ofrecemos herramientas para segmentar la audiencia, recopilar y procesar estad√≠sticas y mucho m√°s.  Para hacer esto, desde cero creamos un producto de alta carga en la uni√≥n de muchas tecnolog√≠as, de las cuales solo una peque√±a parte son PHP, Golang, PostgreSQL, MongoDB, Apache Kafka.  Muchas de nuestras soluciones son √∫nicas, por ejemplo, notificaciones de alta velocidad.  Procesamos m√°s de 2 mil millones de solicitudes de API por d√≠a, tenemos m√°s de 3 mil millones de dispositivos en nuestra base de datos y, durante todo el tiempo, enviamos m√°s de 500 mil millones de notificaciones a estos dispositivos. </p><br><p>  Y aqu√≠ llegamos a una situaci√≥n en la que las notificaciones deben enviarse a millones de dispositivos no tan r√°pido como sea posible (como en la alta velocidad ya mencionada), pero limitando artificialmente la velocidad para que los servidores de nuestros clientes a los que ir√°n los usuarios cuando abran la notificaci√≥n no caigan al mismo tiempo carga <br></p><br><p>  Aqu√≠, varios algoritmos de limitaci√≥n de velocidad nos ayudan, lo que nos permite limitar el n√∫mero de solicitudes por unidad de tiempo.  Como regla general, esto se usa, por ejemplo, al dise√±ar una API, ya que de esta manera podemos proteger el sistema del exceso accidental o malicioso de solicitudes, como resultado de lo cual se produce un retraso o denegaci√≥n de servicio a otros clientes.  Si se implementa la limitaci√≥n de velocidad, todos los clientes est√°n limitados a un n√∫mero fijo de solicitudes por unidad de tiempo.  Adem√°s, la limitaci√≥n de velocidad se puede utilizar al acceder a partes del sistema asociadas con datos confidenciales;  Por lo tanto, si un atacante obtiene acceso a ellos, entonces no podr√° acceder r√°pidamente a todos los datos. <br></p><br><p>  Hay muchas formas diferentes de implementar la limitaci√≥n de velocidad.  En este art√≠culo, consideraremos los pros y los contras de varios algoritmos, as√≠ como los problemas que pueden surgir al escalar estas soluciones. <br></p><br><h2>  Algoritmos de l√≠mite de velocidad de procesamiento de solicitudes </h2><br><h3>  Cubo con fugas (Cubo con fugas) </h3><br><p>  <i>Leaky Bucket</i> es un algoritmo que proporciona el enfoque m√°s simple e intuitivo para limitar la velocidad de procesamiento mediante una cola, que puede representarse como un "bucket" que contiene solicitudes.  Cuando se recibe una solicitud, se agrega al final de la cola.  A intervalos regulares, se procesa el primer elemento de la cola.  Esto tambi√©n se conoce como la cola <abbr title="Primero en entrar - Primero en salir">FIFO</abbr> .  Si la cola est√° llena, se descartan las solicitudes adicionales (o "fuga"). <br></p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/fo/jw/hy/fojwhyst1w3e6fij2eh6lsb04y8.gif" alt="Renderizar cubo de fichas"></div><br><p>  La ventaja de este algoritmo es que suaviza los arrebatos y procesa las solicitudes a aproximadamente la misma velocidad, es f√°cil de implementar en un solo servidor o equilibrador de carga, es eficiente en el uso de la memoria, ya que el tama√±o de la cola para cada usuario es limitado. <br>  Sin embargo, con un fuerte aumento en el tr√°fico, la cola puede llenarse con solicitudes antiguas y privar al sistema de la capacidad de procesar solicitudes m√°s recientes.  Tampoco garantiza que las solicitudes se procesen en un tiempo fijo.  Adem√°s, si carga equilibradores para proporcionar tolerancia a fallas o aumentar el rendimiento, debe implementar una pol√≠tica de coordinaci√≥n y garantizar la restricci√≥n global entre ellos. <br></p><br><p>  Existe una variaci√≥n de este algoritmo: <i>Token Bucket</i> ("cubo con tokens" o "algoritmo de cesta de marcadores"). <br></p><br><p>  En tal implementaci√≥n, los tokens se agregan al "dep√≥sito" a una velocidad constante, y cuando se procesa la solicitud, el token del "dep√≥sito" se elimina;  Si no hay suficientes tokens, la solicitud se descarta.  Simplemente puede usar la marca de tiempo como tokens. <br></p><br><p>  Existen variaciones utilizando varios "cubos", mientras que tanto los tama√±os como la tasa de recepci√≥n de tokens en ellos pueden ser diferentes para "cubos" individuales.  Si no hay suficientes tokens en el primer "dep√≥sito" para procesar la solicitud, entonces se verifica su presencia en el segundo, etc., pero la prioridad del procesamiento de la solicitud se reduce (como regla, esto se usa en el dise√±o de interfaces de red cuando, por ejemplo, puede cambiar el valor del campo Paquete procesado <abbr title="Punto de c√≥digo de servicios diferenciados">DSCP</abbr> ). <br></p><br><p>  La diferencia clave con la implementaci√≥n de <i>Leaky Bucket</i> es que los tokens pueden acumularse cuando el sistema est√° inactivo y las r√°fagas pueden suceder m√°s tarde, mientras que las solicitudes se procesar√°n (ya que hay suficientes tokens), mientras que <i>Leaky Bucket</i> garantiza la suavizaci√≥n de la carga. incluso en caso de inactividad. <br></p><br><h3>  Ventana fija </h3><br><p>  Este algoritmo utiliza una ventana de n segundos para rastrear solicitudes.  Por lo general, se utilizan valores como 60 segundos (minuto) o 3600 segundos (hora).  Cada solicitud entrante aumenta el contador de esta ventana.  Si el contador excede un cierto valor umbral, la solicitud se descarta.  T√≠picamente, la ventana est√° determinada por el l√≠mite inferior del intervalo de tiempo actual, es decir, cuando la ventana tiene 60 segundos de ancho, la solicitud que llega a las 12:00:03 ir√° a la ventana 12:00:00. <br></p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/w3/lz/di/w3lzdijb2gk80a6rltf7rs2ejz8.gif" alt="Renderizar ventana fija"></div><br><p>  La ventaja de este algoritmo es que proporciona el procesamiento de solicitudes m√°s recientes, sin depender del procesamiento de las solicitudes anteriores.  Sin embargo, una sola r√°faga de tr√°fico cerca del borde de la ventana puede duplicar el n√∫mero de solicitudes procesadas, ya que permite solicitudes tanto para la ventana actual como para la siguiente por un corto per√≠odo de tiempo.  Adem√°s, si muchos usuarios est√°n esperando que se restablezca el contador de la ventana, por ejemplo, al final de la hora, pueden provocar un aumento en la carga en este momento debido al hecho de que acceder√°n a la API al mismo tiempo. <br></p><br><h3>  Registro deslizante </h3><br><p>  Este algoritmo implica el seguimiento de las marcas de tiempo de cada solicitud de usuario.  Estos registros se almacenan, por ejemplo, en un conjunto o tabla hash y se ordenan por hora;  los registros fuera del intervalo monitoreado se descartan.  Cuando llega una nueva solicitud, calculamos el n√∫mero de registros para determinar la frecuencia de las solicitudes.  Si la solicitud est√° fuera de la cantidad permitida, se descarta. <br></p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/nv/8a/9z/nv8a9zz0_ycg7sm4htfair2fk44.gif" alt="Registro deslizante de visualizaci√≥n"></div><br><p>  La ventaja de este algoritmo es que no est√° sujeto a los problemas que surgen en los bordes de la <i>ventana fija</i> , es decir, se observar√° estrictamente el l√≠mite de velocidad.  Adem√°s, dado que las solicitudes de cada cliente se monitorean individualmente, no hay crecimiento de carga m√°xima en ciertos puntos, lo cual es otro problema del algoritmo anterior. <br></p><br><p>  Sin embargo, almacenar informaci√≥n sobre cada solicitud puede ser costoso, adem√°s, cada solicitud requiere calcular el n√∫mero de solicitudes anteriores, potencialmente en todo el cl√∫ster, como resultado de lo cual este enfoque no se adapta bien para manejar grandes r√°fagas de tr√°fico y ataques de denegaci√≥n de servicio. <br></p><br><h3>  Ventana corredera </h3><br><p>  Este es un enfoque h√≠brido que combina el bajo costo de procesamiento de una <i>ventana fija</i> y el manejo avanzado de situaciones l√≠mite. <i>Registro deslizante</i> .  Al igual que en la <i>ventana fija</i> simple, rastreamos el contador de cada ventana y luego tomamos en cuenta el valor ponderado de la frecuencia de solicitud de la ventana anterior en funci√≥n de la marca de tiempo actual para suavizar las r√°fagas de tr√°fico.  Por ejemplo, si ha pasado el 25% del tiempo de la ventana actual, tenemos en cuenta el 75% de las solicitudes de la ventana anterior.  La cantidad relativamente peque√±a de datos necesarios para rastrear cada clave nos permite escalar y trabajar en un grupo grande. <br></p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/jx/yz/ps/jxyzpszmkozfruckcg2s5lhsmd0.gif" alt="Ventana deslizante de visualizaci√≥n"></div><br><p>  Este algoritmo le permite escalar la limitaci√≥n de velocidad, mientras mantiene un buen rendimiento.  Adem√°s, esta es una forma comprensible de transmitir informaci√≥n sobre la limitaci√≥n del n√∫mero de solicitudes a los clientes, y tambi√©n evita los problemas que surgen al implementar otros algoritmos de limitaci√≥n de velocidad. <br></p><br><h2>  Limitaci√≥n de velocidad en sistemas distribuidos </h2><br><h3>  Pol√≠ticas de sincronizaci√≥n </h3><br><p>  Si desea establecer la limitaci√≥n de velocidad global al acceder a un cl√∫ster que consta de varios nodos, debe implementar una pol√≠tica de restricci√≥n.  Si cada nodo rastreaba solo su propia restricci√≥n, entonces el usuario podr√≠a evitarla simplemente enviando solicitudes a diferentes nodos.  De hecho, cuanto mayor sea el n√∫mero de nodos, mayor ser√° la probabilidad de que el usuario pueda superar el l√≠mite global. <br></p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/nb/iq/30/nbiq30phqg_b0zibtuoagajyl50.gif" alt="Falta de visualizaci√≥n"></div><br><p>  La forma m√°s f√°cil de establecer l√≠mites es configurar una "sesi√≥n fija" en el equilibrador para que el usuario se dirija al mismo nodo.  Las desventajas de este m√©todo son la falta de tolerancia a fallas y problemas de escala cuando los nodos del cl√∫ster est√°n sobrecargados. <br></p><br><p>  La mejor soluci√≥n, que permite reglas m√°s flexibles para el equilibrio de carga, es utilizar un almac√©n de datos centralizado (de su elecci√≥n).  Puede almacenar contadores de la cantidad de solicitudes para cada ventana y usuario.  Los principales problemas de este enfoque son el aumento del tiempo de respuesta debido a las solicitudes de almacenamiento y las condiciones de carrera. <br></p><br><h3>  Condiciones de carrera </h3><br><p>  Uno de los mayores problemas con un almac√©n de datos centralizado es la posibilidad de condiciones de carrera al competir.  Esto sucede cuando utiliza el enfoque natural de obtener y establecer, en el que extrae el contador actual, lo incrementa y luego env√≠a el valor resultante de vuelta a la tienda.  El problema con este modelo es que durante el tiempo requerido para completar el ciclo completo de estas operaciones (es decir, leer, incrementar y escribir), pueden ingresar otras solicitudes, en cada una de las cuales el contador se almacenar√° con un valor no v√°lido (inferior).  Esto permite al usuario enviar m√°s solicitudes de las que proporciona el algoritmo de limitaci√≥n de velocidad. <br></p><br><p>  Una forma de evitar este problema es establecer un bloqueo alrededor de la tecla en cuesti√≥n, evitando el acceso para leer o escribir cualquier otro proceso en el contador.  Sin embargo, esto puede convertirse r√°pidamente en un cuello de botella de rendimiento y no se escala bien, especialmente cuando se utilizan servidores remotos, como Redis, como un almac√©n de datos adicional. <br></p><br><p>  Un enfoque mucho mejor es "establecer - luego - obtener", basado en operadores at√≥micos, lo que le permite aumentar y verificar r√°pidamente los valores del contador sin interferir con las operaciones at√≥micas. <br></p><br><h3>  Optimizaci√≥n del rendimiento </h3><br><p>  Otra desventaja de usar un almac√©n de datos centralizado es el aumento en el tiempo de respuesta debido al retraso en la verificaci√≥n de los contadores utilizados para implementar la limitaci√≥n de velocidad (tiempo de <i>ida y vuelta</i> o "retraso de <i>ida y vuelta</i> ").  Desafortunadamente, incluso verificar un almacenamiento r√°pido como Redis resultar√° en demoras adicionales de unos pocos milisegundos por solicitud. <br></p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/vn/y_/oc/vny_ocyqyqddljb5lbqnd5wlrgw.gif" alt="Visualizaci√≥n del tiempo de ida y vuelta"></div><br><p>  Para definir una restricci√≥n con un retraso m√≠nimo, es necesario realizar verificaciones en la memoria local.  Esto se puede hacer relajando las condiciones para verificar la velocidad y eventualmente usando un modelo consistente. <br></p><br><p>  Por ejemplo, cada nodo puede crear un ciclo de sincronizaci√≥n de datos en el que se sincronizar√° con el repositorio.  Cada nodo transmite peri√≥dicamente el valor del contador para cada usuario y la ventana que afect√≥, a la tienda, que actualizar√° at√≥micamente los valores.  Entonces el nodo puede recibir nuevos valores y actualizar datos en la memoria local.  Este ciclo eventualmente permitir√° que todos los nodos en el cl√∫ster est√©n actualizados. <br></p><br><p>  El per√≠odo durante el cual los nodos est√°n sincronizados debe ser personalizable.  Los intervalos de sincronizaci√≥n m√°s cortos conducir√°n a una menor discrepancia de datos cuando la carga se distribuya de manera uniforme en varios nodos del cl√∫ster (por ejemplo, en el caso en que el equilibrador determine los nodos de acuerdo con el principio de "round-robin"), mientras que los intervalos m√°s largos crean menos carga de lectura / escritura para el almacenamiento y reduzca el costo en cada nodo para recibir datos sincronizados. <br></p><br><h2>  Comparaci√≥n de algoritmos de limitaci√≥n de velocidad </h2><br><p>  Espec√≠ficamente, en nuestro caso, no debemos rechazar las solicitudes de los clientes para la API, sino que sobre la base de los datos, por el contrario, no las creemos;  sin embargo, no tenemos derecho a "perder" solicitudes.  Para hacer esto, al enviar una notificaci√≥n, utilizamos el par√°metro send_rate, que indica el n√∫mero m√°ximo de notificaciones que enviaremos por segundo al enviar. <br></p><br><p>  Por lo tanto, tenemos un cierto trabajador que realiza el trabajo en el tiempo asignado (en mi ejemplo, leyendo un archivo), que recibe la interfaz RateLimitingInterface como entrada, indicando si es posible ejecutar una solicitud en un momento dado y cu√°nto tiempo se ejecutar√°. <br></p><br><pre><code class="php hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">RateLimitingInterface</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/** * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@param</span></span></span><span class="hljs-comment"> int $rate Expected send rate */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__construct</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(int $rate)</span></span></span></span>; <span class="hljs-comment"><span class="hljs-comment">/** * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@param</span></span></span><span class="hljs-comment"> float $currentTime Current timestamp in microseconds * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@return</span></span></span><span class="hljs-comment"> bool */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">canDoWork</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(float $currentTime)</span></span></span><span class="hljs-function">: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bool</span></span></span></span>; }</code> </pre> <br><p>  Todos los ejemplos de c√≥digo se pueden encontrar en GitHub <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aqu√≠</a> . <br></p><br><p>  Explicar√© de inmediato por qu√© necesita transferir un intervalo de tiempo a Worker.  El hecho es que es demasiado costoso ejecutar un demonio separado para procesar el env√≠o de un mensaje con un l√≠mite de velocidad, por lo que send_rate se usa realmente como par√°metro "n√∫mero de notificaciones por unidad de tiempo", que es 0.01 - 1 segundo dependiendo de la carga. <br></p><br><p>  De hecho, procesamos hasta 100 solicitudes diferentes con send_rate por segundo, asignando 1 / N segundos para cada cantidad de tiempo, donde N es el n√∫mero de empujones procesados ‚Äã‚Äãpor este demonio.  El par√°metro que m√°s nos interesa durante el procesamiento es si se respetar√° send_rate (se permiten peque√±os errores en una direcci√≥n u otra) y la carga en nuestro hardware (n√∫mero m√≠nimo de accesos al almacenamiento, consumo de CPU y memoria). <br></p><br><p>  Para comenzar, averig√ºemos en qu√© momentos el trabajador realmente funciona.  Para simplificar, este ejemplo proces√≥ un archivo de 10,000 l√≠neas con send_rate = 1000 (es decir, leemos 1000 l√≠neas por segundo del archivo). <br></p><br>  En las capturas de pantalla, los marcadores marcan los momentos y la cantidad de llamadas fgets para todos los algoritmos.  En realidad, esto puede ser una apelaci√≥n a una base de datos, un recurso de terceros o cualquier otra consulta, cuyo n√∫mero queremos limitar por unidad de tiempo. <br><br><p>  En la escala X: el tiempo desde el inicio del procesamiento, de 0 a 10 segundos, cada segundo se divide en d√©cimas, por lo que el horario es de 0 a 100). <br></p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/tb/vk/9u/tbvk9usi0mai17koyki16flm6im.png" alt="Operaci√≥n de cubo de fichas"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/77/t0/av/77t0avq7kqwhkm_4tqlcurek4qc.png" alt="Operaci√≥n de algoritmo de ventana fija"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/w9/xo/yi/w9xoyihrbuezu0exbewj8mru9mm.png" alt="El funcionamiento del algoritmo de registro deslizante"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/et/ye/u0/etyeu0hvzzd4hygu8outelbr2ru.png" alt="Operaci√≥n del algoritmo de ventana deslizante"></div><br><p>  Vemos que a pesar del hecho de que todos los algoritmos hacen frente a la observancia de send_rate (para esto est√°n destinados), la <i>ventana fija</i> y el <i>registro deslizante</i> "entregan" toda la carga casi simult√°neamente, lo que no nos conviene mucho, mientras que <i>Token Bucket</i> y <i>Sliding Windows lo</i> distribuye uniformemente por unidad de tiempo (con la excepci√≥n de la carga m√°xima en el momento del inicio, debido a la falta de datos sobre la carga en momentos anteriores). <br></p><br><p>  Debido al hecho de que, en realidad, el c√≥digo generalmente no funciona con el sistema de archivos local, pero con un almacenamiento de terceros, la respuesta puede demorarse, puede haber problemas de red y muchos otros problemas, intentaremos verificar c√≥mo se comportar√° este o aquel algoritmo cuando las solicitudes tarden un tiempo no fue  Por ejemplo, despu√©s de 4 y 6 segundos. <br></p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/fj/lj/gg/fjljggb06hkp7yannsyvtt3b_rw.png" alt="Operaci√≥n de dep√≥sito de token de retraso"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/qq/jp/nw/qqjpnw6rtcp7wmgmnsu3omlqkrw.png" alt="Operaci√≥n de ventana fija con retraso"></div><br><p>  Aqu√≠, puede parecer que la <i>ventana fija</i> no funcion√≥ correctamente y se proces√≥ 2 veces m√°s que las solicitudes esperadas en el primero y de 7 a 8 segundos, pero en realidad no es as√≠, ya que el tiempo se cuenta desde el momento del lanzamiento en el gr√°fico, y el algoritmo usa la marca de tiempo de Unix actual . <br></p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/yh/0k/-k/yh0k-ko8ragfy0mb1n4vcjj8c2o.png" alt="Operaci√≥n de registro retrasado"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/wh/jx/ww/whjxwwdpzkgxx1hikrb2ogpag-o.png" alt="Operaci√≥n de ventana deslizante con retraso"></div><br><p>  En general, nada ha cambiado fundamentalmente, pero vemos que <i>Token Bucket</i> suaviza la carga m√°s suavemente y nunca excede el l√≠mite de velocidad especificado, pero el <i>registro deslizante</i> en caso de tiempo de inactividad puede exceder el valor permitido. <br></p><br><h2>  Conclusi√≥n </h2><br><p>  Examinamos todos los algoritmos b√°sicos para implementar la limitaci√≥n de velocidad, cada uno de los cuales tiene sus pros y sus contras y es adecuado para diversas tareas.  Esperamos que despu√©s de leer este art√≠culo, elija el algoritmo m√°s adecuado para resolver su problema. <br></p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/448438/">https://habr.com/ru/post/448438/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../448424/index.html">55 a√±os despu√©s: ic√≥nicas consolas de culto de sistema principal IBM System / 360</a></li>
<li><a href="../448430/index.html">Pro Content 2019: tres informes duros y ditty</a></li>
<li><a href="../448432/index.html">Radiaci√≥n adhesiva: radiactividad inducida, contaminaci√≥n radiactiva, descontaminaci√≥n ...</a></li>
<li><a href="../448434/index.html">Principales empresas de desarrollo de aplicaciones m√≥viles</a></li>
<li><a href="../448436/index.html">Capa de convoluci√≥n: t√©cnicas de optimizaci√≥n de multiplicaci√≥n matricial</a></li>
<li><a href="../448440/index.html">Cientos de miles de pagos realizados por ciudadanos al STSI y al FSSP eran de dominio p√∫blico.</a></li>
<li><a href="../448442/index.html">SSD GIGABYTE Aorus RGB M.2: peque√±o, incluso remoto para LED RGB (1 parte)</a></li>
<li><a href="../448444/index.html">Deshacerse del miedo al primer empleo</a></li>
<li><a href="../448448/index.html">Informe SWIFT: el volumen de fondos robados por los piratas inform√°ticos de los bancos disminuy√≥ diez veces tres a√±os despu√©s del ataque en $ 100 millones</a></li>
<li><a href="../448450/index.html">Herramientas de an√°lisis web para un vendedor novato, comercializador de productos y an√°lisis.</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>