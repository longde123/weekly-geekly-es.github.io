<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>⏯️ 👩‍🎓 👧🏽 Comment fonctionne un messager décentralisé sur la blockchain 😇 🚑 💂</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Début 2017, nous avons commencé à créer un messager sur la blockchain [le nom et le lien sont dans le profil] en discutant des avantages par rapport a...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Comment fonctionne un messager décentralisé sur la blockchain</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/467751/"> Début 2017, nous avons commencé à créer un messager sur la blockchain [le nom et le lien sont dans le profil] en discutant des avantages par rapport aux messagers P2P classiques. <br><br>  <code>2.5</code> ans se sont écoulés et nous avons pu confirmer notre concept: des applications messenger pour iOS, Web PWA, Windows, GNU / Linux, Mac OS et Android sont désormais disponibles. <br><br>  Aujourd'hui, nous vous expliquerons comment le messager est organisé sur la blockchain et comment les applications clientes peuvent fonctionner avec son API. <br><img src="https://habrastorage.org/webt/x9/zr/gs/x9zrgsw1wkkm1856yssejnfg5gs.jpeg"><br><a name="habracut"></a><br>  Nous voulions que la blockchain résolve les problèmes de sécurité et de confidentialité des messagers P2P classiques: <br><br><ul><li>  Un clic pour créer un compte - pas de téléphones et de courriels, pas d'accès aux carnets d'adresses et aux géolocalisations. </li><li>  Les interlocuteurs n'établissent jamais de connexions directes, toutes les communications passent par un système distribué de nœuds.  Les adresses IP des utilisateurs ne sont pas accessibles les unes aux autres. </li><li>  Tous les messages sont cryptés End-to-End curve25519xsalsa20poly1305.  Il semble que vous ne surprendrez personne, mais nous avons du code open source. </li><li>  L'attaque MITM est exclue - chaque message est une transaction et est signé par Ed25519 EdDSA. </li><li>  Le message tombe dans son bloc.  La séquence et l' <code>timestamp</code> blocs ne peuvent pas être fixés, et donc l'ordre des messages. </li><li>  "Je n'ai pas dit cela" ne fonctionnera pas avec les messages sur la blockchain. </li><li>  Il n'y a pas de structure centrale qui vérifie «l'authenticité» d'un message.  Cela se fait par un système de nœuds distribués consensuel et appartient aux utilisateurs. </li><li>  Impossibilité de censure - les comptes ne peuvent pas être bloqués et les messages supprimés. </li><li>  La blockchain 2FA est une alternative à la 2FA infernale par SMS, qui a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">brisé beaucoup de santé.</a> </li><li>  La possibilité d'obtenir à tout moment toutes vos boîtes de dialogue depuis n'importe quel appareil est la possibilité de ne pas stocker de boîtes de dialogue localement. </li><li>  Confirmation de remise du message.  Pas à l'appareil de l'utilisateur, mais au réseau.  En fait, c'est une confirmation de la capacité du destinataire à lire votre message.  Il s'agit d'une fonctionnalité utile pour l'envoi de notifications critiques. </li></ul><br>  Parmi les brioches de la blockchain, il existe également une intégration étroite avec les crypto-monnaies Ethereum, Dogecoin, Lisk, Dash, Bitcoin (cela est toujours en cours) et la possibilité d'envoyer des jetons dans les chats.  Nous avons même fabriqué un crypto-échangeur intégré. <br><br>  Et puis - comment tout cela fonctionne. <br><br><h2>  Le message est une transaction </h2><br>  Tout le monde est déjà habitué au fait que les transactions dans la blockchain transfèrent des jetons (pièces) d'un utilisateur à un autre.  Comme le bitcoin.  Nous avons créé un type spécial de transaction pour l'envoi de messages. <br><br>  Pour envoyer un message dans le messager sur la blockchain, vous devez passer par plusieurs étapes: <br><br><ol><li>  Crypter le texte du message </li><li>  Mettre un texte chiffré en transaction </li><li>  Signez la transaction </li><li>  Envoyer une transaction à n'importe quel hôte </li><li>  Un système distribué de nœuds détermine la «fiabilité» d'un message </li><li>  Si tout va bien, la transaction avec le message est incluse dans le bloc suivant. </li><li>  Le destinataire récupère la transaction de message et déchiffre </li></ol><br>  Les étapes 1-3 et 7 sont exécutées localement sur le client et 5-6 sur les nœuds du réseau. <br><br><h2>  Cryptage des messages </h2><br>  Le message est crypté avec la clé privée de l'expéditeur et la clé publique du destinataire.  Nous prendrons la clé publique du réseau, mais pour cela, le compte du destinataire doit être initialisé, c'est-à-dire avoir au moins une transaction.  Vous pouvez utiliser la demande REST <code>GET /api/accounts/getPublicKey?address={ADAMANT address}</code> , et lorsque vous téléchargez des chats, les clés publiques des interlocuteurs seront déjà disponibles. <br><br><img src="https://habrastorage.org/webt/gk/km/ky/gkkmkyvasb6jzq_pgs1zq9w7fi0.png"><br><br>  Le messager crypte les messages avec l'algorithme curve25519xsalsa20poly1305 ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">NaCl Box</a> ).  Étant donné que le compte contient des clés Ed25519, afin de former une boîte, les clés doivent d'abord être converties en Curve25519 Diffie-Hellman. <br><br>  Voici un exemple en JavaScript: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">/** * Encodes a text message for sending to ADM * @param {string} msg message to encode * @param {*} recipientPublicKey recipient's public key * @param {*} privateKey our private key * @returns {{message: string, nonce: string}} */</span></span> adamant.encodeMessage = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">msg, recipientPublicKey, privateKey</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> nonce = Buffer.allocUnsafe(<span class="hljs-number"><span class="hljs-number">24</span></span>) sodium.randombytes(nonce) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span> recipientPublicKey === <span class="hljs-string"><span class="hljs-string">'string'</span></span>) { recipientPublicKey = hexToBytes(recipientPublicKey) } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> plainText = Buffer.from(msg) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> DHPublicKey = ed2curve.convertPublicKey(recipientPublicKey) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> DHSecretKey = ed2curve.convertSecretKey(privateKey) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> encrypted = nacl.box(plainText, nonce, DHPublicKey, DHSecretKey) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { <span class="hljs-attr"><span class="hljs-attr">message</span></span>: bytesToHex(encrypted), <span class="hljs-attr"><span class="hljs-attr">nonce</span></span>: bytesToHex(nonce) } }</code> </pre> <br><h2>  Formation d'une transaction avec un message </h2><br>  Une transaction a la structure générale suivante: <br><br><pre> <code class="javascript hljs">{ <span class="hljs-string"><span class="hljs-string">"id"</span></span>: <span class="hljs-string"><span class="hljs-string">"15161295239237781653"</span></span>, <span class="hljs-string"><span class="hljs-string">"height"</span></span>: <span class="hljs-number"><span class="hljs-number">7585271</span></span>, <span class="hljs-string"><span class="hljs-string">"blockId"</span></span>: <span class="hljs-string"><span class="hljs-string">"16391508373936326027"</span></span>, <span class="hljs-string"><span class="hljs-string">"type"</span></span>: <span class="hljs-number"><span class="hljs-number">8</span></span>, <span class="hljs-string"><span class="hljs-string">"block_timestamp"</span></span>: <span class="hljs-number"><span class="hljs-number">45182260</span></span>, <span class="hljs-string"><span class="hljs-string">"timestamp"</span></span>: <span class="hljs-number"><span class="hljs-number">45182254</span></span>, <span class="hljs-string"><span class="hljs-string">"senderPublicKey"</span></span>: <span class="hljs-string"><span class="hljs-string">"bd39cc708499ae91b937083463fce5e0668c2b37e78df28f69d132fce51d49ed"</span></span>, <span class="hljs-string"><span class="hljs-string">"senderId"</span></span>: <span class="hljs-string"><span class="hljs-string">"U16023712506749300952"</span></span>, <span class="hljs-string"><span class="hljs-string">"recipientId"</span></span>: <span class="hljs-string"><span class="hljs-string">"U17653312780572073341"</span></span>, <span class="hljs-string"><span class="hljs-string">"recipientPublicKey"</span></span>: <span class="hljs-string"><span class="hljs-string">"23d27f616e304ef2046a60b762683b8dabebe0d8fc26e5ecdb1d5f3d291dbe21"</span></span>, <span class="hljs-string"><span class="hljs-string">"amount"</span></span>: <span class="hljs-number"><span class="hljs-number">204921300000000</span></span>, <span class="hljs-string"><span class="hljs-string">"fee"</span></span>: <span class="hljs-number"><span class="hljs-number">50000000</span></span>, <span class="hljs-string"><span class="hljs-string">"signature"</span></span>: <span class="hljs-string"><span class="hljs-string">"3c8e551f60fedb81e52835c69e8b158eb1b8b3c89a04d3df5adc0d99017ffbcb06a7b16ad76d519f80df019c930960317a67e8d18ab1e85e575c9470000cf607"</span></span>, <span class="hljs-string"><span class="hljs-string">"signatures"</span></span>: [], <span class="hljs-string"><span class="hljs-string">"confirmations"</span></span>: <span class="hljs-number"><span class="hljs-number">3660548</span></span>, <span class="hljs-string"><span class="hljs-string">"asset"</span></span>: {} }</code> </pre> <br>  Pour le message de transaction, l' <code>asset</code> est le plus important - vous devez y placer le message dans l'objet de <code>chat</code> avec la structure: <br><br><ul><li>  <code>message</code> - enregistrez le message crypté </li><li>  <code>own_message</code> - nonce </li><li>  <code>type</code> - type de message </li></ul><br>  Les messages sont également divisés en types.  Essentiellement, le paramètre <code>type</code> indique comment comprendre le <code>message</code> .  Vous pouvez envoyer uniquement du texte, ou vous pouvez envoyer un objet avec des intérêts à l'intérieur - par exemple, c'est ainsi que le messager effectue des transferts de crypto-monnaies dans les salles de chat. <br><br>  En conséquence, nous formons la transaction: <br><br><pre> <code class="javascript hljs">{ <span class="hljs-string"><span class="hljs-string">"transaction"</span></span>: { <span class="hljs-string"><span class="hljs-string">"type"</span></span>: <span class="hljs-number"><span class="hljs-number">8</span></span>, <span class="hljs-string"><span class="hljs-string">"amount"</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-string"><span class="hljs-string">"senderId"</span></span>: <span class="hljs-string"><span class="hljs-string">"U12499126640447739963"</span></span>, <span class="hljs-string"><span class="hljs-string">"senderPublicKey"</span></span>: <span class="hljs-string"><span class="hljs-string">"e9cafb1e7b403c4cf247c94f73ee4cada367fcc130cb3888219a0ba0633230b6"</span></span>, <span class="hljs-string"><span class="hljs-string">"asset"</span></span>: { <span class="hljs-string"><span class="hljs-string">"chat"</span></span>: { <span class="hljs-string"><span class="hljs-string">"message"</span></span>: <span class="hljs-string"><span class="hljs-string">"cb682accceef92d7cddaaddb787d1184ab5428"</span></span>, <span class="hljs-string"><span class="hljs-string">"own_message"</span></span>: <span class="hljs-string"><span class="hljs-string">"e7d8f90ddf7d70efe359c3e4ecfb5ed3802297b248eacbd6"</span></span>, <span class="hljs-string"><span class="hljs-string">"type"</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span> } }, <span class="hljs-string"><span class="hljs-string">"recipientId"</span></span>: <span class="hljs-string"><span class="hljs-string">"U15677078342684640219"</span></span>, <span class="hljs-string"><span class="hljs-string">"timestamp"</span></span>: <span class="hljs-number"><span class="hljs-number">63228087</span></span>, <span class="hljs-string"><span class="hljs-string">"signature"</span></span>: <span class="hljs-string"><span class="hljs-string">"  "</span></span> } }</code> </pre> <br><h2>  Signature de la transaction </h2><br>  Afin que chacun soit sûr de l'authenticité de l'expéditeur et du destinataire, au moment de l'envoi et du contenu du message, la transaction est signée.  Une signature numérique vous permet de vérifier l'authenticité d'une transaction à l'aide d'une clé publique - une clé privée n'est pas nécessaire pour cela. <br><br>  Mais la signature elle-même n'est effectuée que par la clé privée: <br><br><img src="https://habrastorage.org/webt/y_/bk/6k/y_bk6k_7ayzma1-ndyhur2xcaok.png"><br><br>  Le diagramme montre que nous avons d'abord haché la transaction avec SHA-256, puis signé <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Ed25519 EdDSA</a> et obtenu la signature de <code>signature</code> , et l'identifiant de transaction fait partie du hachage SHA-256. <br><br><h3>  Exemple d'implémentation: </h3><br>  1 - Nous formons un bloc de données, comprenant un message <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">/** * Calls `getBytes` based on transaction type * @see privateTypes * @implements {ByteBuffer} * @param {transaction} trs * @param {boolean} skipSignature * @param {boolean} skipSecondSignature * @return {!Array} Contents as an ArrayBuffer. * @throws {error} If buffer fails. */</span></span> adamant.getBytes = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">transaction</span></span></span><span class="hljs-function">) </span></span>{ ... switch (transaction.type) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> constants.Transactions.SEND: <span class="hljs-keyword"><span class="hljs-keyword">break</span></span> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> constants.Transactions.CHAT_MESSAGE: assetBytes = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.chatGetBytes(transaction) assetSize = assetBytes.length <span class="hljs-keyword"><span class="hljs-keyword">break</span></span> … <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: alert(<span class="hljs-string"><span class="hljs-string">'Not supported yet'</span></span>) } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> bb = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ByteBuffer(<span class="hljs-number"><span class="hljs-number">1</span></span> + <span class="hljs-number"><span class="hljs-number">4</span></span> + <span class="hljs-number"><span class="hljs-number">32</span></span> + <span class="hljs-number"><span class="hljs-number">8</span></span> + <span class="hljs-number"><span class="hljs-number">8</span></span> + <span class="hljs-number"><span class="hljs-number">64</span></span> + <span class="hljs-number"><span class="hljs-number">64</span></span> + assetSize, <span class="hljs-literal"><span class="hljs-literal">true</span></span>) bb.writeByte(transaction.type) bb.writeInt(transaction.timestamp) ... bb.flip() <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> arrayBuffer = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Uint8Array</span></span>(bb.toArrayBuffer()) <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> buffer = [] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; arrayBuffer.length; i++) { buffer[i] = arrayBuffer[i] } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Buffer.from(buffer) }</code> </pre><br>  2 - Nous considérons SHA-256 du bloc de données <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">/** * Creates hash based on transaction bytes. * @implements {getBytes} * @implements {crypto.createHash} * @param {transaction} trs * @return {hash} sha256 crypto hash */</span></span> adamant.getHash = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">trs</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> crypto.createHash(<span class="hljs-string"><span class="hljs-string">'sha256'</span></span>).update(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.getBytes(trs)).digest() }</code> </pre> <br>  3 - Nous signons la transaction <br><br><pre> <code class="javascript hljs">adamant.transactionSign = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">trs, keypair</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> hash = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.getHash(trs) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.sign(hash, keypair).toString(<span class="hljs-string"><span class="hljs-string">'hex'</span></span>) } <span class="hljs-comment"><span class="hljs-comment">/** * Creates a signature based on a hash and a keypair. * @implements {sodium} * @param {hash} hash * @param {keypair} keypair * @return {signature} signature */</span></span> adamant.sign = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">hash, keypair</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> sodium.crypto_sign_detached(hash, Buffer.from(keypair.privateKey, <span class="hljs-string"><span class="hljs-string">'hex'</span></span>)) }</code> </pre> <br><h2>  Envoi d'une transaction avec un message à un hôte </h2><br>  Puisque le réseau est décentralisé, n'importe lequel des nœuds avec une API ouverte fera l'affaire.  Nous faisons une demande POST pour le point final <code>api/transactions</code> : <br><br><pre> <code class="javascript hljs">curl <span class="hljs-string"><span class="hljs-string">'api/transactions'</span></span> -X POST \ -d <span class="hljs-string"><span class="hljs-string">'TX_DATA'</span></span></code> </pre> <br>  En réponse, nous obtenons un ID de transaction de type <br><br><pre> <code class="javascript hljs">{ <span class="hljs-string"><span class="hljs-string">"success"</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-string"><span class="hljs-string">"nodeTimestamp"</span></span>: <span class="hljs-number"><span class="hljs-number">63228852</span></span>, <span class="hljs-string"><span class="hljs-string">"transactionId"</span></span>: <span class="hljs-string"><span class="hljs-string">"6146865104403680934"</span></span> }</code> </pre> <br><h2>  Validation de transaction </h2><br>  Un système distribué de nœuds basé sur le consensus détermine la «fiabilité» d'une transaction de message.  De qui et à qui, quand, si le message a été remplacé par un autre et si l'heure d'envoi a été indiquée correctement.  C'est un avantage très important de la blockchain - il n'y a pas de structure centrale responsable des contrôles, et la séquence des messages et leur contenu ne peuvent pas être falsifiés. <br><br>  D'abord, un nœud vérifie la fiabilité, puis l'envoie aux autres - si la plupart disent que tout est en ordre, la transaction sera incluse dans le bloc suivant de la chaîne - c'est un consensus. <br><br><img src="https://habrastorage.org/webt/4h/qe/to/4hqetosedsbnm1qnu-pir3jjj4k.gif"><br><br>  La partie du code hôte responsable de la validation peut être consultée sur GitHub - <a href="">validator.js</a> et <a href="">verify.js</a> .  Oui, le nœud fonctionne sur Node.js. <br><br><h2>  Inclure la transaction avec le message dans le bloc </h2><br>  Si un consensus est atteint, la transaction avec notre message tombera dans le bloc suivant, avec d'autres transactions fiables. <br><br>  Les blocs ont une séquence stricte et chaque bloc suivant est formé sur la base des hachages des blocs précédents. <br><br><img src="https://habrastorage.org/webt/es/cf/kt/escfktkasqdtkv2hxs5me6urmmm.png"><br><br>  L'essentiel est que notre message est également inclus dans cette séquence et ne peut pas être «réorganisé».  Si plusieurs messages tombent dans le bloc, leur ordre sera déterminé par l' <code>timestamp</code> messages. <br><br><h2>  Lire des messages </h2><br>  L'application de messagerie récupère les transactions de la blockchain qui sont envoyées au destinataire.  Pour ce faire, nous avons créé le point de terminaison <code>api/chatrooms</code> . <br><br>  Toutes les transactions sont accessibles à tous - vous pouvez recevoir des messages cryptés.  Mais seul le destinataire peut décrypter avec sa clé privée et la clé publique de l'expéditeur: <br><br><pre> <code class="javascript hljs">** * Decodes the incoming message * @param {any} msg encoded message * @param {string} senderPublicKey sender public key * @param {string} privateKey our private key * @param {any} nonce nonce * @returns {string} *<span class="hljs-regexp"><span class="hljs-regexp">/ adamant.decodeMessage = function (msg, senderPublicKey, privateKey, nonce) { if (typeof msg === 'string') { msg = hexToBytes(msg) } if (typeof nonce === 'string') { nonce = hexToBytes(nonce) } if (typeof senderPublicKey === 'string') { senderPublicKey = hexToBytes(senderPublicKey) } if (typeof privateKey === 'string') { privateKey = hexToBytes(privateKey) } const DHPublicKey = ed2curve.convertPublicKey(senderPublicKey) const DHSecretKey = ed2curve.convertSecretKey(privateKey) const decrypted = nacl.box.open(msg, nonce, DHPublicKey, DHSecretKey) return decrypted ? decode(decrypted) : '' }</span></span></code> </pre> <br><h2>  Quoi d'autre? </h2><br>  Puisque les messages sont livrés de cette manière pendant environ 5 secondes - c'est le moment où un nouveau bloc réseau est apparu - nous avons proposé une connexion de socket client-nœud et nœud à nœud.  Lorsqu'un nœud reçoit une nouvelle transaction, il vérifie sa validité et la transfère vers d'autres nœuds.  La transaction est disponible pour les clients de messagerie avant même le début du consensus et l'inclusion dans le bloc.  Nous allons donc livrer des messages instantanément, ainsi que les messagers habituels. <br><br>  Pour stocker le carnet d'adresses, nous avons fait de KVS - Key-Value Storage est un autre type de transaction dans lequel un <code>asset</code> est crypté non pas avec NaCl-box, mais avec <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">NaCl-secretbox</a> .  Le messager stocke donc d'autres données. <br><br>  Le transfert de fichiers / images et les discussions de groupe nécessitent encore beaucoup de travail.  Bien sûr, dans le format tyap-bloop, cela peut être fixé rapidement, mais nous voulons maintenir le même niveau de confidentialité. <br><br>  Oui, il y a encore du travail à faire - idéalement, une réelle confidentialité implique que les utilisateurs ne se connecteront pas aux nœuds du réseau public, mais augmenteront les leurs.  Que pensez-vous, combien de pour cent des utilisateurs font cela?  C'est vrai, 0. En partie, nous avons réussi à résoudre ce problème avec la version Tor du messager. <br><br>  Nous avons prouvé qu'un messager sur la blockchain peut exister.  Auparavant, il n'y avait eu qu'une seule tentative en 2012 - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">bitmessage</a> , qui avait échoué en raison du long délai de livraison des messages, de la charge du processeur et du manque d'applications mobiles. <br><br>  Mais le scepticisme est lié au fait que les messagers sur la blockchain sont en avance - les gens ne sont pas prêts à assumer la responsabilité de leur compte eux-mêmes, la propriété des informations personnelles n'est pas encore une tendance et la technologie ne permet pas d'assurer des vitesses élevées sur la blockchain.  Ci-dessous apparaîtront plus d'analogues technologiques de notre projet.  Tu verras. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr467751/">https://habr.com/ru/post/fr467751/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr467741/index.html">Introduction aux assemblages déterministes en C / C ++. partie 1</a></li>
<li><a href="../fr467743/index.html">SamsPcbGuide, partie 11: Technologie - Boîtiers de type BGA, plastique et espace</a></li>
<li><a href="../fr467745/index.html">Cluster mieux que la «méthode du coude»</a></li>
<li><a href="../fr467747/index.html">Test psychologique: comment passer d'un psychologue certifié à un testeur</a></li>
<li><a href="../fr467749/index.html">GCP: analyse de la pile informatique de Google Cloud Platform</a></li>
<li><a href="../fr467753/index.html">Record du monde pour la transmission de données sans fil: 40 Gb / s par 11 kilomètres</a></li>
<li><a href="../fr467755/index.html">Prions, calcium, microbiote, hormones alimentaires et Alzheimer</a></li>
<li><a href="../fr467759/index.html">Conception de système d'exploitation de type Unix - Espace d'adressage virtuel (6)</a></li>
<li><a href="../fr467761/index.html">Énergie, chaleur et eau, troisième partie: allez à la radio</a></li>
<li><a href="../fr467763/index.html">Toute la vérité sur RTOS. Article # 33. Utilisation du système d'exploitation en temps réel Nucleus SE</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>