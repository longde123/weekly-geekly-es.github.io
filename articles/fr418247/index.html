<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë¢ üîõ ‚òùüèø Acc√©l√©rez la multiplication de la matrice flottante 4x4 avec SIMD üçé üêê üßöüèΩ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="De nombreuses ann√©es se sont √©coul√©es depuis que je me suis familiaris√© avec les instructions MMX, SSE et plus tard AVX sur les processeurs Intel. √Ä u...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Acc√©l√©rez la multiplication de la matrice flottante 4x4 avec SIMD</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/418247/">  De nombreuses ann√©es se sont √©coul√©es depuis que je me suis familiaris√© avec les instructions MMX, SSE et plus tard AVX sur les processeurs Intel.  √Ä un moment donn√©, ils semblaient √™tre une sorte de magie dans le contexte de l'assembleur x86, qui avait longtemps √©t√© quelque chose de banal.  Ils m'ont tellement accroch√© qu'il y a quelques ann√©es, j'ai eu l'id√©e d'√©crire mon propre logiciel de rendu pour un jeu c√©l√®bre.  La chose qui a promis ces instructions m'a promis ceci.  √Ä un moment donn√©, j'ai m√™me pens√© √† l'√©crire.  Mais l'√©criture de texte s'est av√©r√©e beaucoup plus compliqu√©e que le code. <br><br>  √Ä cette √©poque, je voulais √©viter les probl√®mes de support sur diff√©rents processeurs.  Je voulais pouvoir v√©rifier mon rendu sur le montant maximum disponible.  J'ai toujours des amis avec d'anciens processeurs AMD, et leur plafond √©tait SSE3.  Par cons√©quent, √† ce moment-l√†, j'ai d√©cid√© de me limiter √† un maximum de SSE3.  Il y avait donc une biblioth√®que math√©matique vectorielle, un peu moins compl√®tement impl√©ment√©e sur SSE, avec une inclusion rare avant SSE3.  Cependant, √† un moment donn√©, je me suis demand√© quelles performances maximales je pouvais retirer du processeur pour un certain nombre d'op√©rations math√©matiques vectorielles critiques.  Une telle op√©ration consiste √† multiplier 4 matrices flottantes par 4. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/kg/ii/cq/kgiicqemuc5agmypikedjioaogc.jpeg"></div><a name="habracut"></a><br>  En fait, j'ai d√©cid√© de faire cette affaire davantage pour le plaisir.  J'ai d√©j√† √©crit et j'utilise la multiplication matricielle pour mon rendu logiciel sur SSE et cela me semble suffisant.  Mais j'ai alors d√©cid√© de voir combien de mesures je pouvais retirer en principe en multipliant 2 matrices float4x4.  Sur mon SSE actuel, ce sont 16 cycles d'horloge.  Certes, la transition r√©cente vers <abbr title="Analyseur de code d'architecture Intel">IACA</abbr> 3 a commenc√© √† afficher 19, car j'ai commenc√© √† √©crire 1 * pour certaines instructions au lieu de 0 *.  Apparemment plus t√¥t, ce n'√©tait qu'un d√©faut dans l'analyseur. <br><br><h3>  En bref sur les utilitaires utilis√©s </h3><br>  Pour l'analyse de code, j'ai utilis√© le c√©l√®bre utilitaire <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Intel Architecture Code Analyzer</a> .  Pour l'analyse, j'utilise l'architecture Haswell (HSW), au minimum avec le support d'AVX2.  Pour √©crire du code est √©galement tr√®s pratique √† utiliser: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Intel Intrinsics Guide</a> et <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Intel optimization manual</a> . <br><br>  Pour l'assemblage, j'utilise la communaut√© MSVS 2017 √† partir de la console.  J'√©cris le code dans la version avec intrins√®ques.  Vous √©crivez une fois, et g√©n√©ralement cela fonctionne imm√©diatement sur diff√©rentes plateformes.  De plus, le compilateur x64 VC ++ ne prend pas en charge l'assembleur en ligne, mais je veux qu'il fonctionne √©galement sous x64. <br><br>  √âtant donn√© que cet article est d√©j√† un peu au-del√† du niveau d√©butant en programmation SIMD, je ne d√©crirai pas les registres, les instructions, dessiner (ou raser) de belles images et essayer d'apprendre la programmation en utilisant les instructions SIMD.  Le site Web d'Intel regorge d'une documentation excellente, claire et d√©taill√©e. <br><br><h2>  Je voulais tout rendre plus facile ... Mais il s'est av√©r√© comme toujours </h2><br>  C'est l√† que le moment commence, ce qui complique beaucoup la mise en ≈ìuvre et l'article.  Je m'y attarderai donc un peu.  Ce n'est pas int√©ressant pour moi d'√©crire une multiplication matricielle avec une disposition standard des √©l√©ments en ligne.  Qui en avait besoin, et donc ils ont √©tudi√© dans les universit√©s ou seuls.  Notre objectif est la productivit√©.  Tout d'abord, je suis pass√© √† la disposition des colonnes il y a longtemps.  Mon logiciel de rendu est bas√© sur l'API OpenGL et donc, afin d'√©viter des transpositions inutiles, j'ai commenc√© √† stocker des √©l√©ments dans des colonnes.  Ceci est √©galement important car la multiplication matricielle n'est pas si critique.  Matrices 2-5-10 bien multipli√©es.  Et c'est tout.  Et puis nous multiplions la matrice finie par des milliers ou des millions de sommets.  Et cette op√©ration est beaucoup plus critique.  Vous pouvez bien s√ªr transposer √† chaque fois.  Mais pourquoi, si cela peut √™tre √©vit√©. <br><br>  Mais revenons aux matrices exclusivement.  Nous avons d√©termin√© le stockage en colonnes.  Cependant, cela peut √™tre encore plus compliqu√©.  Il est plus pratique pour moi de stocker les √©l√©ments sup√©rieurs des vecteurs et des lignes de matrice dans les registres SIMD afin que <strong>x soit</strong> dans le flottant le plus √©lev√© (index 3) et <strong>w</strong> dans le mineur (index 0).  Ici, apparemment, nous devrons retraiter √† nouveau sur pourquoi. <br><br>  Le fait est que dans un logiciel de rendu dans un vecteur, vous devez manipuler le composant <strong>w</strong> plus souvent ( <strong>1 / z y</strong> est stock√©), et il est tr√®s pratique de le faire via la version <strong>_ss</strong> de l'op√©ration (op√©rations exclusivement avec le composant dans le flotteur inf√©rieur du registre <em>xmm</em> ), sans toucher <strong><nobr>x, y, z</nobr></strong> .  Par cons√©quent, dans le registre SSE, le vecteur est stock√© dans un ordre compr√©hensible <strong><nobr>x, y, z, w</nobr></strong> et en m√©moire dans le sens inverse <strong><nobr>w, z, y, x</nobr></strong> . <br><br>  De plus, toutes les options de multiplication sont √©galement impl√©ment√©es par des fonctions individuelles.  Cela se fait parce que je les utilise pour remplacer l'option souhait√©e en fonction du type d'instructions prises en charge.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Bien d√©crit ici.</a> <br><br><h2>  Nous impl√©mentons la fonctionnalit√© de base </h2><br><h3>  Multiplication avec boucles, rang√©e ordonn√©e </h3><br><div class="spoiler">  <b class="spoiler_title">Option pour la disposition des √©l√©ments en ligne</b> <div class="spoiler_text"><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">4</span></span>; ++i) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> j = <span class="hljs-number"><span class="hljs-number">0</span></span>; j &lt; <span class="hljs-number"><span class="hljs-number">4</span></span>; ++j) { r[i][j] = <span class="hljs-number"><span class="hljs-number">0.f</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> k = <span class="hljs-number"><span class="hljs-number">0</span></span>; k &lt; <span class="hljs-number"><span class="hljs-number">4</span></span>; ++k) { r[i][j] += m[i][k] * n[k][j]; } } }</code> </pre> <br></div></div><br>  Ici, tout est simple et clair.  Pour chaque √©l√©ment, nous faisons 4 multiplications et 3 additions.  Au total, ce sont 64 multiplications et 48 additions.  Et cela sans tenir compte de la lecture des √©l√©ments d'enregistrement. <br><br>  Tout est triste, bref.  Pour cette option, pour le cycle interne, l'IACA a √©mis: <em>3,65 cycles d'horloge pour l'assemblage x86 et 2,97 horloges pour l'assemblage x64</em> .  Ne demandez pas pourquoi les nombres fractionnaires.  Je ne sais pas.  IACA 2.1 n'en a pas souffert.  Dans tous les cas, ces nombres doivent √™tre multipli√©s par environ 4 * 4 * 4 = 64. M√™me si vous prenez x64, le r√©sultat est d'environ 192 mesures.  Il est clair qu'il s'agit d'une estimation approximative.  Je ne vois pas l'int√©r√™t d'√©valuer plus pr√©cis√©ment les performances de cette option. <br><br><h3>  Impl√©mentation en boucle, colonne ordonn√©e </h3><br><div class="spoiler">  <b class="spoiler_title">matrice transpos√©e, r√©organiser les indices de ligne et de colonne</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">4</span></span>; ++i) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> j = <span class="hljs-number"><span class="hljs-number">0</span></span>; j &lt; <span class="hljs-number"><span class="hljs-number">4</span></span>; ++j) { r[j][i] = <span class="hljs-number"><span class="hljs-number">0.f</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> k = <span class="hljs-number"><span class="hljs-number">0</span></span>; k &lt; <span class="hljs-number"><span class="hljs-number">4</span></span>; ++k) { r[j][i] += m[k][i] * n[j][k]; } } }</code> </pre><br></div></div><br><h3>  Multiplication de cycle, stockage orient√© SIMD </h3><br><div class="spoiler">  <b class="spoiler_title">le stockage des lignes dans l'ordre inverse en m√©moire est ajout√©</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">4</span></span>; ++i) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> j = <span class="hljs-number"><span class="hljs-number">0</span></span>; j &lt; <span class="hljs-number"><span class="hljs-number">4</span></span>; ++j) { r[j][<span class="hljs-number"><span class="hljs-number">3</span></span>-i] = <span class="hljs-number"><span class="hljs-number">0.f</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> k = <span class="hljs-number"><span class="hljs-number">0</span></span>; k &lt; <span class="hljs-number"><span class="hljs-number">4</span></span>; ++k) { r[j][<span class="hljs-number"><span class="hljs-number">3</span></span>-i] += m[k][<span class="hljs-number"><span class="hljs-number">3</span></span>-i] * n[j][<span class="hljs-number"><span class="hljs-number">3</span></span>-k]; } } }</code> </pre><br></div></div><br>  Cette impl√©mentation simplifie quelque peu la compr√©hension de ce qui se passe √† l'int√©rieur, mais n'est clairement pas suffisante. <br><br><h3>  Classes d'assistance </h3><br>  Pour faciliter la compr√©hension et l'√©criture de code de r√©f√©rence et de d√©bogage, il est pratique d'impl√©menter quelques classes auxiliaires.  Rien de plus, tout n'est que pour comprendre.  Je note que la mise en ≈ìuvre de classes vectorielles et matricielles √† part enti√®re est une question difficile distincte, et n'est pas incluse dans le sujet de cet article. <br><br><div class="spoiler">  <b class="spoiler_title">Classes vectorielles et matricielles</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">struct </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">alignas</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">sizeof</span></span></span></span><span class="hljs-function"><span class="hljs-params">(__m128))</span></span></span><span class="hljs-function"> vec4 </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">union</span></span> { <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> w, z, y, x; }; __m128 fmm; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> arr[<span class="hljs-number"><span class="hljs-number">4</span></span>]; }; vec4() {} vec4(<span class="hljs-keyword"><span class="hljs-keyword">float</span></span> a, <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> b, <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> c, <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> d) : w(d), z(c), y(b), x(a) {} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">equ</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> a, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> b, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> t = </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">.00001</span></span></span></span><span class="hljs-function"><span class="hljs-params">f)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">fabs</span></span>(ab) &lt; t; } <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> == (vec4 <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>&amp; v) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> equ(x, vx) &amp;&amp; equ(y, vy) &amp;&amp; equ(z, vz) &amp;&amp; equ(w, vw); } }; <span class="hljs-function"><span class="hljs-function">struct </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">alignas</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">sizeof</span></span></span></span><span class="hljs-function"><span class="hljs-params">(__m256))</span></span></span><span class="hljs-function"> mtx4 </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//           union { struct { float _30, _20, _10, _00, _31, _21, _11, _01, _32, _22, _12, _02, _33, _23, _13, _03; }; __m128 r[4]; __m256 s[2]; vec4 v[4]; }; //    mtx4() {} mtx4( float i00, float i01, float i02, float i03, float i10, float i11, float i12, float i13, float i20, float i21, float i22, float i23, float i30, float i31, float i32, float i33) : _00(i00), _01(i01), _02(i02), _03(i03) , _10(i10), _11(i11), _12(i12), _13(i13) , _20(i20), _21(i21), _22(i22), _23(i23) , _30(i30), _31(i31), _32(i32), _33(i33) {} //      operator __m128 const* () const { return r; } operator __m128* () { return r; } //   bool operator == (mtx4 const&amp; m) const { return v[0]==mv[0] &amp;&amp; v[1]==mv[1] &amp;&amp; v[2]==mv[2] &amp;&amp; v[3]==mv[3]; } //  static mtx4 identity() { return mtx4( 1.f, 0.f, 0.f, 0.f, 0.f, 1.f, 0.f, 0.f, 0.f, 0.f, 1.f, 0.f, 0.f, 0.f, 0.f, 1.f); } static mtx4 zero() { return mtx4( 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f); } };</span></span></code> </pre><br></div></div><br><h3>  Fonction de r√©f√©rence pour les tests </h3><br>  √âtant donn√© que l'ordre accept√© des √©l√©ments dans la matrice complique beaucoup la compr√©hension, nous ne serons pas non plus d√©rang√©s par la fonction de r√©f√©rence <em>claire</em> , qui montrera dans les futures impl√©mentations que tout fonctionne correctement.  Nous comparerons avec lui les r√©sultats ult√©rieurs. <br><br><div class="spoiler">  <b class="spoiler_title">Pour le cr√©er, il suffit de prendre et d'√©tendre le cycle</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mul_mtx4_mtx4_unroll</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(__m128* </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> _r, __m128 </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params">* </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> _m, __m128 </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params">* </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> _n)</span></span></span><span class="hljs-function"> </span></span>{ mtx4 <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>&amp; m = **<span class="hljs-keyword"><span class="hljs-keyword">reinterpret_cast</span></span>&lt;mtx4 <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>* <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>*&gt;(&amp;_m); mtx4 <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>&amp; n = **<span class="hljs-keyword"><span class="hljs-keyword">reinterpret_cast</span></span>&lt;mtx4 <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>* <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>*&gt;(&amp;_n); mtx4&amp; r = **<span class="hljs-keyword"><span class="hljs-keyword">reinterpret_cast</span></span>&lt;mtx4* <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>*&gt;(&amp;_r); r._00 = m._00*n._00 + m._01*n._10 + m._02*n._20 + m._03*n._30; r._01 = m._00*n._01 + m._01*n._11 + m._02*n._21 + m._03*n._31; r._02 = m._00*n._02 + m._01*n._12 + m._02*n._22 + m._03*n._32; r._03 = m._00*n._03 + m._01*n._13 + m._02*n._23 + m._03*n._33; r._10 = m._10*n._00 + m._11*n._10 + m._12*n._20 + m._13*n._30; r._11 = m._10*n._01 + m._11*n._11 + m._12*n._21 + m._13*n._31; r._12 = m._10*n._02 + m._11*n._12 + m._12*n._22 + m._13*n._32; r._13 = m._10*n._03 + m._11*n._13 + m._12*n._23 + m._13*n._33; r._20 = m._20*n._00 + m._21*n._10 + m._22*n._20 + m._23*n._30; r._21 = m._20*n._01 + m._21*n._11 + m._22*n._21 + m._23*n._31; r._22 = m._20*n._02 + m._21*n._12 + m._22*n._22 + m._23*n._32; r._23 = m._20*n._03 + m._21*n._13 + m._22*n._23 + m._23*n._33; r._30 = m._30*n._00 + m._31*n._10 + m._32*n._20 + m._33*n._30; r._31 = m._30*n._01 + m._31*n._11 + m._32*n._21 + m._33*n._31; r._32 = m._30*n._02 + m._31*n._12 + m._32*n._22 + m._33*n._32; r._33 = m._30*n._03 + m._31*n._13 + m._32*n._23 + m._33*n._33; }</code> </pre><br></div></div><br>  L'algorithme classique est clairement peint ici, il est difficile de se tromper (mais vous pouvez :-)).  √Ä ce sujet, l'IACA a publi√©: <em>x86 - 69,95 mesures, x64 - 64 mesures</em> .  Voici environ 64 cycles et nous verrons l'acc√©l√©ration de cette op√©ration dans le futur. <br><br><h2>  Impl√©mentation SSE </h2><br><h3>  Algorithme SSE classique </h3><br>  Pourquoi classique?  Parce qu'il fait depuis longtemps partie de l'impl√©mentation de <em>FVec</em> dans le cadre de MSVS.  Pour commencer, nous allons √©crire comment nous pr√©sentons les √©l√©ments de matrice dans les registres SSE.  Cela semble d√©j√† plus simple ici.  Juste une matrice transpos√©e. <br><br><pre> <code class="plaintext hljs">//     00, 10, 20, 30 // m[0] -  SIMD /   01, 11, 21, 31 // m[1] 02, 12, 22, 32 // m[2] 03, 13, 23, 33 // m[3]</code> </pre><br>  Nous prenons le code de <em>d√©roulement</em> de la variante ci-dessus.  D'une certaine mani√®re, il est hostile √† SSE.  Le premier groupe de lignes comprend les r√©sultats de la colonne de la matrice r√©sultante: <em><nobr>r._00, r._01, r._02, r._03</nobr></em> .  Nous avons cette colonne, mais nous avons besoin d'une ligne.  Oui, et <strong>m</strong> , <strong>n ne</strong> semblent pas pratiques pour les calculs.  Par cons√©quent, nous r√©organisons les lignes de l'algorithme de sorte que le r√©sultat <strong>r soit</strong> rang√©. <br><br><pre> <code class="plaintext hljs">//  ,     r[0] r00 = m00*n00 + m01*n10 + m02*n20 + m03*n30; r10 = m10*n00 + m11*n10 + m12*n20 + m13*n30; r20 = m20*n00 + m21*n10 + m22*n20 + m23*n30; r30 = m30*n00 + m31*n10 + m32*n20 + m33*n30; //  ,     r[1] r01 = m00*n01 + m01*n11 + m02*n21 + m03*n31; r11 = m10*n01 + m11*n11 + m12*n21 + m13*n31; r21 = m20*n01 + m21*n11 + m22*n21 + m23*n31; r31 = m30*n01 + m31*n11 + m32*n21 + m33*n31; //  ,     r[2] r02 = m00*n02 + m01*n12 + m02*n22 + m03*n32; r12 = m10*n02 + m11*n12 + m12*n22 + m13*n32; r22 = m20*n02 + m21*n12 + m22*n22 + m23*n32; r32 = m30*n02 + m31*n12 + m32*n22 + m33*n32; //  ,     r[3] r03 = m00*n03 + m01*n13 + m02*n23 + m03*n33; r13 = m10*n03 + m11*n13 + m12*n23 + m13*n33; r23 = m20*n03 + m21*n13 + m22*n23 + m23*n33; r33 = m30*n03 + m31*n13 + m32*n23 + m33*n33;</code> </pre><br>  Mais c'est d√©j√† beaucoup mieux.  Que voit-on en fait?  Selon les colonnes de l'algorithme dans chaque groupe, nous avons les lignes de la matrice <strong>m</strong> impliqu√©es: <br><pre> m [0] = {00,10,20,30}, m [1] = {01,11,21,31}, m [2] = {02,12,22,32}, m [3] = {03,13,23,33},
</pre>  qui sont multipli√©s par le m√™me √©l√©ment de la matrice <strong>n</strong> .  Par exemple, pour le premier groupe, c'est: <em>n._00, n._10, n._20, n._30</em> .  Et les √©l√©ments de la matrice <strong>n</strong> pour chaque groupe de lignes de l'algorithme se trouvent √† nouveau dans une ligne de la matrice. <br><br>  Alors tout est simple: on prend simplement les lignes de la matrice <strong>m</strong> par index, mais comme pour les √©l√©ments <strong>n</strong> , on prend sa ligne et on la <em>m√©lange</em> √† travers les 4 √©l√©ments du registre via l'instruction <em>shuffle</em> , pour multiplier par la ligne de la matrice <strong>m</strong> dans le registre.  Par exemple, pour l'√©l√©ment <em>n._00</em> (rappelez-vous que son d√©calage dans le registre a l'index 3), ce sera: <pre>  _mm_shuffle_ps (n [0], n [0], _MM_SHUFFLE (3,3,3,3)) </pre><br>  Dans une forme simplifi√©e, l'algorithme ressemble √† ceci: <br><br><pre> <code class="plaintext hljs">//   n[0]={00,10,20,30} r[0] = m[0] * n00 + m[1] * n10 + m[2] * n20 + m[3] * n30; //   n[1]={01,11,21,31} r[1] = m[0] * n01 + m[1] * n11 + m[2] * n21 + m[3] * n31; //   n[2]={02,12,22,32} r[2] = m[0] * n02 + m[1] * n12 + m[2] * n22 + m[3] * n32; //   n[3]={03,13,23,33} r[3] = m[0] * n03 + m[1] * n13 + m[2] * n23 + m[3] * n33;</code> </pre><br><div class="spoiler">  <b class="spoiler_title">Impl√©mentation SSE de base</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mul_mtx4_mtx4_sse_v1</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(__m128* </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> r, __m128 </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params">* </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> m, __m128 </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params">* </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> n)</span></span></span><span class="hljs-function"> </span></span>{ r[<span class="hljs-number"><span class="hljs-number">0</span></span>] = _mm_add_ps( _mm_add_ps( _mm_mul_ps(m[<span class="hljs-number"><span class="hljs-number">0</span></span>], _mm_shuffle_ps(n[<span class="hljs-number"><span class="hljs-number">0</span></span>], n[<span class="hljs-number"><span class="hljs-number">0</span></span>], _MM_SHUFFLE(<span class="hljs-number"><span class="hljs-number">3</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>))), _mm_mul_ps(m[<span class="hljs-number"><span class="hljs-number">1</span></span>], _mm_shuffle_ps(n[<span class="hljs-number"><span class="hljs-number">0</span></span>], n[<span class="hljs-number"><span class="hljs-number">0</span></span>], _MM_SHUFFLE(<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>)))), _mm_add_ps( _mm_mul_ps(m[<span class="hljs-number"><span class="hljs-number">2</span></span>], _mm_shuffle_ps(n[<span class="hljs-number"><span class="hljs-number">0</span></span>], n[<span class="hljs-number"><span class="hljs-number">0</span></span>], _MM_SHUFFLE(<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>))), _mm_mul_ps(m[<span class="hljs-number"><span class="hljs-number">3</span></span>], _mm_shuffle_ps(n[<span class="hljs-number"><span class="hljs-number">0</span></span>], n[<span class="hljs-number"><span class="hljs-number">0</span></span>], _MM_SHUFFLE(<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>))))); r[<span class="hljs-number"><span class="hljs-number">1</span></span>] = _mm_add_ps( _mm_add_ps( _mm_mul_ps(m[<span class="hljs-number"><span class="hljs-number">0</span></span>], _mm_shuffle_ps(n[<span class="hljs-number"><span class="hljs-number">1</span></span>], n[<span class="hljs-number"><span class="hljs-number">1</span></span>], _MM_SHUFFLE(<span class="hljs-number"><span class="hljs-number">3</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>))), _mm_mul_ps(m[<span class="hljs-number"><span class="hljs-number">1</span></span>], _mm_shuffle_ps(n[<span class="hljs-number"><span class="hljs-number">1</span></span>], n[<span class="hljs-number"><span class="hljs-number">1</span></span>], _MM_SHUFFLE(<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>)))), _mm_add_ps( _mm_mul_ps(m[<span class="hljs-number"><span class="hljs-number">2</span></span>], _mm_shuffle_ps(n[<span class="hljs-number"><span class="hljs-number">1</span></span>], n[<span class="hljs-number"><span class="hljs-number">1</span></span>], _MM_SHUFFLE(<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>))), _mm_mul_ps(m[<span class="hljs-number"><span class="hljs-number">3</span></span>], _mm_shuffle_ps(n[<span class="hljs-number"><span class="hljs-number">1</span></span>], n[<span class="hljs-number"><span class="hljs-number">1</span></span>], _MM_SHUFFLE(<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>))))); r[<span class="hljs-number"><span class="hljs-number">2</span></span>] = _mm_add_ps( _mm_add_ps( _mm_mul_ps(m[<span class="hljs-number"><span class="hljs-number">0</span></span>], _mm_shuffle_ps(n[<span class="hljs-number"><span class="hljs-number">2</span></span>], n[<span class="hljs-number"><span class="hljs-number">2</span></span>], _MM_SHUFFLE(<span class="hljs-number"><span class="hljs-number">3</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>))), _mm_mul_ps(m[<span class="hljs-number"><span class="hljs-number">1</span></span>], _mm_shuffle_ps(n[<span class="hljs-number"><span class="hljs-number">2</span></span>], n[<span class="hljs-number"><span class="hljs-number">2</span></span>], _MM_SHUFFLE(<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>)))), _mm_add_ps( _mm_mul_ps(m[<span class="hljs-number"><span class="hljs-number">2</span></span>], _mm_shuffle_ps(n[<span class="hljs-number"><span class="hljs-number">2</span></span>], n[<span class="hljs-number"><span class="hljs-number">2</span></span>], _MM_SHUFFLE(<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>))), _mm_mul_ps(m[<span class="hljs-number"><span class="hljs-number">3</span></span>], _mm_shuffle_ps(n[<span class="hljs-number"><span class="hljs-number">2</span></span>], n[<span class="hljs-number"><span class="hljs-number">2</span></span>], _MM_SHUFFLE(<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>))))); r[<span class="hljs-number"><span class="hljs-number">3</span></span>] = _mm_add_ps( _mm_add_ps( _mm_mul_ps(m[<span class="hljs-number"><span class="hljs-number">0</span></span>], _mm_shuffle_ps(n[<span class="hljs-number"><span class="hljs-number">3</span></span>], n[<span class="hljs-number"><span class="hljs-number">3</span></span>], _MM_SHUFFLE(<span class="hljs-number"><span class="hljs-number">3</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>))), _mm_mul_ps(m[<span class="hljs-number"><span class="hljs-number">1</span></span>], _mm_shuffle_ps(n[<span class="hljs-number"><span class="hljs-number">3</span></span>], n[<span class="hljs-number"><span class="hljs-number">3</span></span>], _MM_SHUFFLE(<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>)))), _mm_add_ps( _mm_mul_ps(m[<span class="hljs-number"><span class="hljs-number">2</span></span>], _mm_shuffle_ps(n[<span class="hljs-number"><span class="hljs-number">3</span></span>], n[<span class="hljs-number"><span class="hljs-number">3</span></span>], _MM_SHUFFLE(<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>))), _mm_mul_ps(m[<span class="hljs-number"><span class="hljs-number">3</span></span>], _mm_shuffle_ps(n[<span class="hljs-number"><span class="hljs-number">3</span></span>], n[<span class="hljs-number"><span class="hljs-number">3</span></span>], _MM_SHUFFLE(<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>))))); }</code> </pre><br></div></div><br>  Maintenant, nous changeons les √©l√©ments <strong>n</strong> de l'algorithme en <em>shuffle</em> correspondant, multiplication par <em>_mm_mul_ps</em> , la somme par <em>_mm_add_ps</em> , et vous avez termin√©.  √áa marche.  Le code semble cependant bien pire que l'algorithme lui-m√™me.  Pour ce code, l'IACA a √©mis: <em>x86 - 18.89, x64 - 16 cycles</em> .  C'est 4 fois plus rapide que le pr√©c√©dent.  Dans le registre SSE, le quatri√®me flotteur.  Relation presque lin√©aire. <br><br><h4>  D√©corer la mise en ≈ìuvre de SSE </h4><br>  Pourtant, dans le code, cela a l'air horrible.  Nous allons essayer d'am√©liorer cela en √©crivant un peu de sucre syntaxique. <br><br><div class="spoiler">  <b class="spoiler_title">Op√©rateurs et am√©liorateurs</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//        ( -    namespace) __m128 operator + (__m128 const a, __m128 const b) { return _mm_add_ps(a, b); } __m128 operator - (__m128 const a, __m128 const b) { return _mm_sub_ps(a, b); } __m128 operator * (__m128 const a, __m128 const b) { return _mm_mul_ps(a, b); } __m128 operator / (__m128 const a, __m128 const b) { return _mm_div_ps(a, b); } //_mm_shuffle_ps(u, v, _MM_SHUFFLE(3,2,1,0))   shuf&lt;3,2,1,0&gt;(u, v) template &lt;int a, int b, int c, int d&gt; __m128 shuf(__m128 const u, __m128 const v) { return _mm_shuffle_ps(u, v, _MM_SHUFFLE(a, b, c, d)); } template &lt;int a, int b, int c, int d&gt; __m128 shuf(__m128 const v) { return _mm_shuffle_ps(v, v, _MM_SHUFFLE(a, b, c, d)); } //    template &lt;int i&gt; __m128 shuf(__m128 const u, __m128 const v) { return _mm_shuffle_ps(u, v, _MM_SHUFFLE(i, i, i, i)); } template &lt;int i&gt; __m128 shuf(__m128 const v) { return _mm_shuffle_ps(v, v, _MM_SHUFFLE(i, i, i, i)); } //  float       , //    ,    template &lt;int a, int b, int c, int d&gt; __m128 shufd(__m128 const v) { return _mm_castsi128_ps(_mm_shuffle_epi32(_mm_castps_si128(v), _MM_SHUFFLE(a, b, c, d))); } template &lt;int i&gt; __m128 shufd(__m128 const v) { return _mm_castsi128_ps(_mm_shuffle_epi32(_mm_castps_si128(v), _MM_SHUFFLE(i, i, i, i))); }</span></span></code> </pre><br></div></div><br>  Le compilateur peut parfaitement int√©grer ces fonctions (bien que parfois sans __forceinline en aucune fa√ßon). <br><br><div class="spoiler">  <b class="spoiler_title">Donc le code tourne ...</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mul_mtx4_mtx4_sse_v2</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(__m128* </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> r, __m128 </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params">* </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> m, __m128 </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params">* </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> n)</span></span></span><span class="hljs-function"> </span></span>{ r[<span class="hljs-number"><span class="hljs-number">0</span></span>] = m[<span class="hljs-number"><span class="hljs-number">0</span></span>]*shuf&lt;<span class="hljs-number"><span class="hljs-number">3</span></span>&gt;(n[<span class="hljs-number"><span class="hljs-number">0</span></span>]) + m[<span class="hljs-number"><span class="hljs-number">1</span></span>]*shuf&lt;<span class="hljs-number"><span class="hljs-number">2</span></span>&gt;(n[<span class="hljs-number"><span class="hljs-number">0</span></span>]) + m[<span class="hljs-number"><span class="hljs-number">2</span></span>]*shuf&lt;<span class="hljs-number"><span class="hljs-number">1</span></span>&gt;(n[<span class="hljs-number"><span class="hljs-number">0</span></span>]) + m[<span class="hljs-number"><span class="hljs-number">3</span></span>]*shuf&lt;<span class="hljs-number"><span class="hljs-number">0</span></span>&gt;(n[<span class="hljs-number"><span class="hljs-number">0</span></span>]); r[<span class="hljs-number"><span class="hljs-number">1</span></span>] = m[<span class="hljs-number"><span class="hljs-number">0</span></span>]*shuf&lt;<span class="hljs-number"><span class="hljs-number">3</span></span>&gt;(n[<span class="hljs-number"><span class="hljs-number">1</span></span>]) + m[<span class="hljs-number"><span class="hljs-number">1</span></span>]*shuf&lt;<span class="hljs-number"><span class="hljs-number">2</span></span>&gt;(n[<span class="hljs-number"><span class="hljs-number">1</span></span>]) + m[<span class="hljs-number"><span class="hljs-number">2</span></span>]*shuf&lt;<span class="hljs-number"><span class="hljs-number">1</span></span>&gt;(n[<span class="hljs-number"><span class="hljs-number">1</span></span>]) + m[<span class="hljs-number"><span class="hljs-number">3</span></span>]*shuf&lt;<span class="hljs-number"><span class="hljs-number">0</span></span>&gt;(n[<span class="hljs-number"><span class="hljs-number">1</span></span>]); r[<span class="hljs-number"><span class="hljs-number">2</span></span>] = m[<span class="hljs-number"><span class="hljs-number">0</span></span>]*shuf&lt;<span class="hljs-number"><span class="hljs-number">3</span></span>&gt;(n[<span class="hljs-number"><span class="hljs-number">2</span></span>]) + m[<span class="hljs-number"><span class="hljs-number">1</span></span>]*shuf&lt;<span class="hljs-number"><span class="hljs-number">2</span></span>&gt;(n[<span class="hljs-number"><span class="hljs-number">2</span></span>]) + m[<span class="hljs-number"><span class="hljs-number">2</span></span>]*shuf&lt;<span class="hljs-number"><span class="hljs-number">1</span></span>&gt;(n[<span class="hljs-number"><span class="hljs-number">2</span></span>]) + m[<span class="hljs-number"><span class="hljs-number">3</span></span>]*shuf&lt;<span class="hljs-number"><span class="hljs-number">0</span></span>&gt;(n[<span class="hljs-number"><span class="hljs-number">2</span></span>]); r[<span class="hljs-number"><span class="hljs-number">3</span></span>] = m[<span class="hljs-number"><span class="hljs-number">0</span></span>]*shuf&lt;<span class="hljs-number"><span class="hljs-number">3</span></span>&gt;(n[<span class="hljs-number"><span class="hljs-number">3</span></span>]) + m[<span class="hljs-number"><span class="hljs-number">1</span></span>]*shuf&lt;<span class="hljs-number"><span class="hljs-number">2</span></span>&gt;(n[<span class="hljs-number"><span class="hljs-number">3</span></span>]) + m[<span class="hljs-number"><span class="hljs-number">2</span></span>]*shuf&lt;<span class="hljs-number"><span class="hljs-number">1</span></span>&gt;(n[<span class="hljs-number"><span class="hljs-number">3</span></span>]) + m[<span class="hljs-number"><span class="hljs-number">3</span></span>]*shuf&lt;<span class="hljs-number"><span class="hljs-number">0</span></span>&gt;(n[<span class="hljs-number"><span class="hljs-number">3</span></span>]); }</code> </pre><br></div></div><br>  Et donc c'est d√©j√† beaucoup mieux et plus lisible.  Pour cela, IACA a produit environ le r√©sultat attendu: <em>x86 - 19 (et pourquoi pas fractionnaire?), X64 - 16</em> .  En fait, les performances n'ont pas chang√©, mais le code est beaucoup plus beau et compr√©hensible. <br><br><h4>  Peu de contribution √† l'optimisation future </h4><br>  Introduisons encore une am√©lioration au niveau d'une fonction apparue r√©cemment dans la version iron.  Op√©ration <em>d'ajout multiple (fma)</em> .  <em><nobr>fma (a, b, c) = a * b + c</nobr></em> . <br><br><div class="spoiler">  <b class="spoiler_title">Impl√©mentation d'ajout multiple</b> <div class="spoiler_text"><pre> <code class="cpp hljs">__<span class="hljs-function"><span class="hljs-function">m128 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mad</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(__m128 </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> a, __m128 </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> b, __m128 </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> c)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _mm_add_ps(_mm_mul_ps(a, b), c); }</code> </pre><br></div></div><br>  Pourquoi est-ce n√©cessaire?  Tout d'abord, pour une optimisation future.  Par exemple, vous pouvez simplement remplacer <em>mad</em> par <em>fma</em> dans le code fini via les m√™mes macros que vous le souhaitez.  Mais nous allons jeter les bases de l'optimisation maintenant: <br><br><div class="spoiler">  <b class="spoiler_title">Variante avec ajout multiple</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mul_mtx4_mtx4_sse_v3</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(__m128* </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> r, __m128 </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params">* </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> m, __m128 </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params">* </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> n)</span></span></span><span class="hljs-function"> </span></span>{ r[<span class="hljs-number"><span class="hljs-number">0</span></span>] = mad(m[<span class="hljs-number"><span class="hljs-number">0</span></span>], shuf&lt;<span class="hljs-number"><span class="hljs-number">3</span></span>&gt;(n[<span class="hljs-number"><span class="hljs-number">0</span></span>]), m[<span class="hljs-number"><span class="hljs-number">1</span></span>]*shuf&lt;<span class="hljs-number"><span class="hljs-number">2</span></span>&gt;(n[<span class="hljs-number"><span class="hljs-number">0</span></span>])) + mad(m[<span class="hljs-number"><span class="hljs-number">2</span></span>], shuf&lt;<span class="hljs-number"><span class="hljs-number">1</span></span>&gt;(n[<span class="hljs-number"><span class="hljs-number">0</span></span>]), m[<span class="hljs-number"><span class="hljs-number">3</span></span>]*shuf&lt;<span class="hljs-number"><span class="hljs-number">0</span></span>&gt;(n[<span class="hljs-number"><span class="hljs-number">0</span></span>])); r[<span class="hljs-number"><span class="hljs-number">1</span></span>] = mad(m[<span class="hljs-number"><span class="hljs-number">0</span></span>], shuf&lt;<span class="hljs-number"><span class="hljs-number">3</span></span>&gt;(n[<span class="hljs-number"><span class="hljs-number">1</span></span>]), m[<span class="hljs-number"><span class="hljs-number">1</span></span>]*shuf&lt;<span class="hljs-number"><span class="hljs-number">2</span></span>&gt;(n[<span class="hljs-number"><span class="hljs-number">1</span></span>]) + mad(m[<span class="hljs-number"><span class="hljs-number">2</span></span>], shuf&lt;<span class="hljs-number"><span class="hljs-number">1</span></span>&gt;(n[<span class="hljs-number"><span class="hljs-number">1</span></span>]), m[<span class="hljs-number"><span class="hljs-number">3</span></span>]*shuf&lt;<span class="hljs-number"><span class="hljs-number">0</span></span>&gt;(n[<span class="hljs-number"><span class="hljs-number">1</span></span>])); r[<span class="hljs-number"><span class="hljs-number">2</span></span>] = mad(m[<span class="hljs-number"><span class="hljs-number">0</span></span>], shuf&lt;<span class="hljs-number"><span class="hljs-number">3</span></span>&gt;(n[<span class="hljs-number"><span class="hljs-number">2</span></span>]), m[<span class="hljs-number"><span class="hljs-number">1</span></span>]*shuf&lt;<span class="hljs-number"><span class="hljs-number">2</span></span>&gt;(n[<span class="hljs-number"><span class="hljs-number">2</span></span>])) + mad(m[<span class="hljs-number"><span class="hljs-number">2</span></span>], shuf&lt;<span class="hljs-number"><span class="hljs-number">1</span></span>&gt;(n[<span class="hljs-number"><span class="hljs-number">2</span></span>]), m[<span class="hljs-number"><span class="hljs-number">3</span></span>]*shuf&lt;<span class="hljs-number"><span class="hljs-number">0</span></span>&gt;(n[<span class="hljs-number"><span class="hljs-number">2</span></span>])); r[<span class="hljs-number"><span class="hljs-number">3</span></span>] = mad(m[<span class="hljs-number"><span class="hljs-number">0</span></span>], shuf&lt;<span class="hljs-number"><span class="hljs-number">3</span></span>&gt;(n[<span class="hljs-number"><span class="hljs-number">3</span></span>]), m[<span class="hljs-number"><span class="hljs-number">1</span></span>]*shuf&lt;<span class="hljs-number"><span class="hljs-number">2</span></span>&gt;(n[<span class="hljs-number"><span class="hljs-number">3</span></span>])) + mad(m[<span class="hljs-number"><span class="hljs-number">2</span></span>], shuf&lt;<span class="hljs-number"><span class="hljs-number">1</span></span>&gt;(n[<span class="hljs-number"><span class="hljs-number">3</span></span>]), m[<span class="hljs-number"><span class="hljs-number">3</span></span>]*shuf&lt;<span class="hljs-number"><span class="hljs-number">0</span></span>&gt;(n[<span class="hljs-number"><span class="hljs-number">3</span></span>])); }</code> </pre><br></div></div><br>  IACA: <em>x86 - 18,89, x64 - 16</em> .  Encore une fois fractionnaire.  Pourtant, IACA produit parfois des r√©sultats √©tranges.  Le code n'a pas tellement chang√©.  Probablement m√™me un peu pire.  Mais l'optimisation n√©cessite parfois de tels sacrifices. <br><br><h4>  Nous passons √† l'√©pargne via _mm_stream </h4><br>  Divers guides d'optimisation recommandent √† nouveau de ne pas extraire le cache pour les op√©rations de sauvegarde en bloc.  Cela est g√©n√©ralement justifi√© lorsque vous traitez des sommets qui sont des milliers ou plus.  Mais pour les matrices, ce n'est peut-√™tre pas si important.  Cependant, je vais l'ajouter quand m√™me. <br><br><div class="spoiler">  <b class="spoiler_title">Option d'√©conomie de flux</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mul_mtx4_mtx4_sse_v4</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(__m128* </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> r, __m128 </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params">* </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> m, __m128 </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params">* </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> n)</span></span></span><span class="hljs-function"> </span></span>{ _mm_stream_ps(&amp;r[<span class="hljs-number"><span class="hljs-number">0</span></span>].m128_f32[<span class="hljs-number"><span class="hljs-number">0</span></span>], mad(m[<span class="hljs-number"><span class="hljs-number">0</span></span>], shuf&lt;<span class="hljs-number"><span class="hljs-number">3</span></span>&gt;(n[<span class="hljs-number"><span class="hljs-number">0</span></span>]), m[<span class="hljs-number"><span class="hljs-number">1</span></span>]*shuf&lt;<span class="hljs-number"><span class="hljs-number">2</span></span>&gt;(n[<span class="hljs-number"><span class="hljs-number">0</span></span>])) + mad(m[<span class="hljs-number"><span class="hljs-number">2</span></span>], shuf&lt;<span class="hljs-number"><span class="hljs-number">1</span></span>&gt;(n[<span class="hljs-number"><span class="hljs-number">0</span></span>]), m[<span class="hljs-number"><span class="hljs-number">3</span></span>]*shuf&lt;<span class="hljs-number"><span class="hljs-number">0</span></span>&gt;(n[<span class="hljs-number"><span class="hljs-number">0</span></span>]))); _mm_stream_ps(&amp;r[<span class="hljs-number"><span class="hljs-number">1</span></span>].m128_f32[<span class="hljs-number"><span class="hljs-number">0</span></span>], mad(m[<span class="hljs-number"><span class="hljs-number">0</span></span>], shuf&lt;<span class="hljs-number"><span class="hljs-number">3</span></span>&gt;(n[<span class="hljs-number"><span class="hljs-number">1</span></span>]), m[<span class="hljs-number"><span class="hljs-number">1</span></span>]*shuf&lt;<span class="hljs-number"><span class="hljs-number">2</span></span>&gt;(n[<span class="hljs-number"><span class="hljs-number">1</span></span>])) + mad(m[<span class="hljs-number"><span class="hljs-number">2</span></span>], shuf&lt;<span class="hljs-number"><span class="hljs-number">1</span></span>&gt;(n[<span class="hljs-number"><span class="hljs-number">1</span></span>]), m[<span class="hljs-number"><span class="hljs-number">3</span></span>]*shuf&lt;<span class="hljs-number"><span class="hljs-number">0</span></span>&gt;(n[<span class="hljs-number"><span class="hljs-number">1</span></span>]))); _mm_stream_ps(&amp;r[<span class="hljs-number"><span class="hljs-number">2</span></span>].m128_f32[<span class="hljs-number"><span class="hljs-number">0</span></span>], mad(m[<span class="hljs-number"><span class="hljs-number">0</span></span>], shuf&lt;<span class="hljs-number"><span class="hljs-number">3</span></span>&gt;(n[<span class="hljs-number"><span class="hljs-number">2</span></span>]), m[<span class="hljs-number"><span class="hljs-number">1</span></span>]*shuf&lt;<span class="hljs-number"><span class="hljs-number">2</span></span>&gt;(n[<span class="hljs-number"><span class="hljs-number">2</span></span>])) + mad(m[<span class="hljs-number"><span class="hljs-number">2</span></span>], shuf&lt;<span class="hljs-number"><span class="hljs-number">1</span></span>&gt;(n[<span class="hljs-number"><span class="hljs-number">2</span></span>]), m[<span class="hljs-number"><span class="hljs-number">3</span></span>]*shuf&lt;<span class="hljs-number"><span class="hljs-number">0</span></span>&gt;(n[<span class="hljs-number"><span class="hljs-number">2</span></span>]))); _mm_stream_ps(&amp;r[<span class="hljs-number"><span class="hljs-number">3</span></span>].m128_f32[<span class="hljs-number"><span class="hljs-number">0</span></span>], mad(m[<span class="hljs-number"><span class="hljs-number">0</span></span>], shuf&lt;<span class="hljs-number"><span class="hljs-number">3</span></span>&gt;(n[<span class="hljs-number"><span class="hljs-number">3</span></span>]), m[<span class="hljs-number"><span class="hljs-number">1</span></span>]*shuf&lt;<span class="hljs-number"><span class="hljs-number">2</span></span>&gt;(n[<span class="hljs-number"><span class="hljs-number">3</span></span>])) + mad(m[<span class="hljs-number"><span class="hljs-number">2</span></span>], shuf&lt;<span class="hljs-number"><span class="hljs-number">1</span></span>&gt;(n[<span class="hljs-number"><span class="hljs-number">3</span></span>]), m[<span class="hljs-number"><span class="hljs-number">3</span></span>]*shuf&lt;<span class="hljs-number"><span class="hljs-number">0</span></span>&gt;(n[<span class="hljs-number"><span class="hljs-number">3</span></span>]))); }</code> </pre><br></div></div><br>  Rien n'a chang√© dans le temps ici, du mot du tout.  Mais, selon les recommandations, nous ne touchons plus au cache. <br><br><h2>  Impl√©mentation AVX </h2><br><h3>  Option AVX de base </h3><br><img src="https://habrastorage.org/webt/8d/l-/1r/8dl-1rgisfl2sqr0dhzmizkmawg.jpeg" align="right"><br>  Ensuite, nous passons √† la prochaine √©tape d'optimisation.  Le 4√®me flotteur est inclus dans le registre SSE, et dans l'AVX il est d√©j√† 8. Autrement dit, il y a une chance th√©orique de r√©duire le nombre d'op√©rations effectu√©es et d'augmenter la productivit√© sinon de moiti√©, puis au moins 1,5 fois.  Mais quelque chose me dit que tout ne sera pas aussi simple avec la transition vers AVX.  Pouvons-nous obtenir les donn√©es n√©cessaires √† partir de registres doubles? <br><br>  Essayons de le comprendre.  Encore une fois, nous √©crivons notre algorithme de multiplication utilis√© ci-dessus.  Vous ne pouvez pas faire cela, mais il est plus pratique de traiter le code lorsque tout est √† proximit√© et que vous n'avez pas √† faire d√©filer une demi-page. <br><br><pre> <code class="plaintext hljs">//    : 00, 10, 20, 30, 01, 11, 21, 31, 02, 12, 22, 32, 03, 13, 23, 33 //   SSE: r0 = m0*n00 + m1*n10 + m2*n20 + m3*n30 r1 = m0*n01 + m1*n11 + m2*n21 + m3*n31 r2 = m0*n02 + m1*n12 + m2*n22 + m3*n32 r3 = m0*n03 + m1*n13 + m2*n23 + m3*n33</code> </pre><br>  En sortie, nous nous attendons √† obtenir le r√©sultat en <em><nobr>ymm = {r0: r1}</nobr></em> et <em><nobr>ymm = {r2: r3}</nobr></em> .  Si dans la version SSE notre algorithme √©tait g√©n√©ralis√© aux colonnes, nous devons maintenant le g√©n√©raliser aux lignes.  Donc, agir comme dans le cas de l'option SSE ne fonctionnera pas. <br><br>  Si l'on consid√®re la matrice <strong>m</strong> dans les registres <em>ymm</em> , on obtient respectivement <em><nobr>ymm = {m0: m1}</nobr></em> et <em><nobr>ymm = {m2: m3}</nobr></em> .  Auparavant, nous n'avions que des colonnes matricielles dans le registre, et maintenant des colonnes et des lignes. <br><br>  Si vous essayez d'agir comme auparavant, vous devez multiplier <em><nobr>ymm = {m0: m1}</nobr></em> par le registre <em><nobr>ymm = {n00, n00, n00, n00}: {n10, n10, n10, n10}</nobr></em> .  √âtant donn√© que <em>n00</em> et <em>n01</em> <em>sont</em> dans la m√™me ligne de la matrice <strong>n</strong> , √† en juger par l'ensemble d'instructions AVX disponibles, les disperser par <em>ymm</em> sera co√ªteux.  La <em>lecture al√©atoire</em> et la <em>permutation</em> fonctionnent s√©par√©ment pour chacun des deux fours d'un flotteur (haut et bas <em>xmm</em> ) √† l'int√©rieur des registres <em>ymm</em> . <br><br>  Si nous prenons <em>ymm</em> de la matrice <strong>n</strong> , alors nous obtenons les deux √©l√©ments <em>n00</em> et <em>n10</em> au plus haut de 2 <em>xmm</em> √† l'int√©rieur du registre <em>ymm</em> .  <em><nobr>{n00, n10, n20, n30}: {n01, n11, n21, n31}</nobr></em> .  Habituellement, l'index pour les instructions existantes est de 0 √† 3. Et il ne flotte que dans un registre <em>xmm</em> sur deux dans le registre <em>ymm</em> .  Il n'est pas possible de transf√©rer le <em>n10</em> de l'ancien <em>xmm</em> vers le plus jeune √† <em>moindre co√ªt</em> .  Et puis cet objectif doit √™tre r√©p√©t√© plusieurs fois.  Nous ne pouvons pas supporter une telle perte de mesures.  Il faut trouver autre chose. <br><br>  Nous g√©n√©ralisions les colonnes, mais maintenant les lignes.  Par cons√©quent, nous essaierons d'aller d'une mani√®re un peu diff√©rente.  Nous devons obtenir le r√©sultat dans <em>{r0: r1}</em> .  Cela signifie que l'algorithme doit √™tre am√©lior√© non pas sur des lignes distinctes de l'algorithme, mais sur deux √† la fois.  Et ici, ce qui √©tait un inconv√©nient dans le travail de <em>m√©lange</em> et de <em>permutation</em> , sera un plus pour nous.  Nous regardons ce que nous aurons dans les registres <em>ymm</em> lorsque nous consid√©rons la matrice <strong>n</strong> . <br><br><pre> <code class="plaintext hljs">n0n1 = {00, 10, 20, 30} : {01, 11, 21, 31} n2n3 = {02, 12, 22, 32} : {03, 13, 23, 33}</code> </pre><br>  Oui, nous remarquons que dans diff√©rentes parties <em>xmm du</em> registre <em>ymm,</em> nous avons les √©l√©ments <em>00</em> et <em>01</em> .  Ils peuvent √™tre multipli√©s en casse par registre via la commande permute dans <em><nobr>{_00, _00, _00, _00}: {_ 01, _01, _01, _01}</nobr></em> , indiquant un seul index 3 pour les deux parties <em>xmm</em> .  C'est exactement ce dont nous avons besoin.  En effet, les coefficients sont √©galement utilis√©s sur diff√©rentes lignes.  Seulement maintenant dans le registre <em>ymm</em> correspondant pour la multiplication, il sera n√©cessaire de conserver <em>{m0: m0}</em> , c'est-√†-dire la premi√®re ligne dupliqu√©e de la matrice <strong>m</strong> . <br><br>  Donc, nous peignons l'algorithme plus en d√©tail.  Nous lisons les doubles rang√©es de la matrice <strong>m</strong> dans les registres <em>ymm</em> : <br><br><pre> <code class="plaintext hljs">mm[0] = {m0:m0} mm[1] = {m1:m1} mm[2] = {m2:m2} mm[3] = {m3:m3}</code> </pre><br>  Et puis nous calculerons la multiplication comme: <br><br><pre> <code class="plaintext hljs">r0r1 = mm[0] * {n00,n00,n00,n00:n01,n01,n01,n01} + // permute&lt;3,3,3,3&gt;(n0n1) mm[1] * {n10,n10,n10,n10:n11,n11,n11,n11} + // permute&lt;2,2,2,2&gt;(n0n1) mm[2] * {n20,n20,n20,n20:n21,n21,n21,n21} + // permute&lt;1,1,1,1&gt;(n0n1) mm[3] * {n30,n30,n30,n30:n31,n31,n31,n31} // permute&lt;0,0,0,0&gt;(n0n1) r2r3 = mm[0] * {n02,n02,n02,n02:n03,n03,n03,n03} + // permute&lt;3,3,3,3&gt;(n2n3) mm[1] * {n12,n12,n12,n12:n13,n13,n13,n13} + // permute&lt;2,2,2,2&gt;(n2n3) mm[2] * {n22,n22,n22,n22:n23,n23,n23,n23} + // permute&lt;1,1,1,1&gt;(n2n3) mm[3] * {n32,n32,n32,n32:n33,n33,n33,n33} // permute&lt;0,0,0,0&gt;(n2n3)</code> </pre><br>  Nous r√©√©crivons plus clairement: <br><br><pre> <code class="plaintext hljs">r0r1 = mm[0]*n0n1&lt;3,3,3,3&gt;+mm[1]*n0n1&lt;2,2,2,2&gt;+mm[2]*n0n1&lt;1,1,1,1&gt;+mm[3]*n0n1&lt;0,0,0,0&gt; r2r3 = mm[0]*n2n3&lt;3,3,3,3&gt;+mm[1]*n2n3&lt;2,2,2,2&gt;+mm[2]*n2n3&lt;1,1,1,1&gt;+mm[3]*n2n3&lt;0,0,0,0&gt;</code> </pre><br>  Ou sous une forme simplifi√©e: <br><br><pre> <code class="plaintext hljs">r0r1 = mm[0]*n0n1&lt;3&gt; + mm[1]*n0n1&lt;2&gt; + mm[2]*n0n1&lt;1&gt; + mm[3]*n0n1&lt;0&gt; r2r3 = mm[0]*n2n3&lt;3&gt; + mm[1]*n2n3&lt;2&gt; + mm[2]*n2n3&lt;1&gt; + mm[3]*n2n3&lt;0&gt;</code> </pre><br>  Tout semble clair. <br><br><div class="spoiler">  <b class="spoiler_title">Il ne reste plus qu'√† √©crire une impl√©mentation</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mul_mtx4_mtx4_avx_v1</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(__m128* </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> r, __m128 </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params">* </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> m, __m128 </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params">* </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> n)</span></span></span><span class="hljs-function"> </span></span>{ __m256 mm0 = _mm256_set_m128(m[<span class="hljs-number"><span class="hljs-number">0</span></span>], m[<span class="hljs-number"><span class="hljs-number">0</span></span>]); __m256 mm1 = _mm256_set_m128(m[<span class="hljs-number"><span class="hljs-number">1</span></span>], m[<span class="hljs-number"><span class="hljs-number">1</span></span>]); __m256 mm2 = _mm256_set_m128(m[<span class="hljs-number"><span class="hljs-number">2</span></span>], m[<span class="hljs-number"><span class="hljs-number">2</span></span>]); __m256 mm3 = _mm256_set_m128(m[<span class="hljs-number"><span class="hljs-number">3</span></span>], m[<span class="hljs-number"><span class="hljs-number">3</span></span>]); __m256 n0n1 = _mm256_load_ps(&amp;n[<span class="hljs-number"><span class="hljs-number">0</span></span>].m128_f32[<span class="hljs-number"><span class="hljs-number">0</span></span>]); __m256 y1 = _mm256_permute_ps(n0n1, <span class="hljs-number"><span class="hljs-number">0xFF</span></span>);<span class="hljs-comment"><span class="hljs-comment">//3,3,3,3 __m256 y2 = _mm256_permute_ps(n0n1, 0xAA);//2,2,2,2 __m256 y3 = _mm256_permute_ps(n0n1, 0x55);//1,1,1,1 __m256 y4 = _mm256_permute_ps(n0n1, 0x00);//0,0,0,0 y1 = _mm256_mul_ps(y1, mm0); y2 = _mm256_mul_ps(y2, mm1); y3 = _mm256_mul_ps(y3, mm2); y4 = _mm256_mul_ps(y4, mm3); y1 = _mm256_add_ps(y1, y2); y3 = _mm256_add_ps(y3, y4); y1 = _mm256_add_ps(y1, y3); __m256 n2n3 = _mm256_load_ps(&amp;n[2].m128_f32[0]); __m256 y5 = _mm256_permute_ps(n2n3, 0xFF); __m256 y6 = _mm256_permute_ps(n2n3, 0xAA); __m256 y7 = _mm256_permute_ps(n2n3, 0x55); __m256 y8 = _mm256_permute_ps(n2n3, 0x00); y5 = _mm256_mul_ps(y5, mm0); y6 = _mm256_mul_ps(y6, mm1); y7 = _mm256_mul_ps(y7, mm2); y8 = _mm256_mul_ps(y8, mm3); y5 = _mm256_add_ps(y5, y6); y7 = _mm256_add_ps(y7, y8); y5 = _mm256_add_ps(y5, y7); _mm256_stream_ps(&amp;r[0].m128_f32[0], y1); _mm256_stream_ps(&amp;r[2].m128_f32[0], y5); }</span></span></code> </pre><br></div></div><br>  Voici les chiffres int√©ressants de l'IACA: <em>x86 - 12,53, x64 - 12</em> .  Bien s√ªr, je voulais mieux.  J'ai rat√© quelque chose. <br><br><h3>  Optimisation AVX plus sucre syntaxique </h3><br>  Il semble que dans le code ci-dessus, AVX n'ait pas √©t√© utilis√© √† son plein potentiel.  Nous constatons qu'au lieu de d√©finir deux lignes identiques dans le registre <strong>ymm</strong> , nous pouvons utiliser la <em>diffusion</em> , qui peut remplir le registre <em>ymm</em> avec deux valeurs <em>xmm</em> identiques.  En cours de route, ajoutez √©galement du ¬´sucre syntaxique¬ª pour les fonctions AVX. <br><br><div class="spoiler">  <b class="spoiler_title">Impl√©mentation AVX am√©lior√©e</b> <div class="spoiler_text"><pre> <code class="cpp hljs">__m256 <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> + (__m256 <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> a, __m256 <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> b) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _mm256_add_ps(a, b); } __m256 <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> - (__m256 <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> a, __m256 <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> b) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _mm256_sub_ps(a, b); } __m256 <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> * (__m256 <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> a, __m256 <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> b) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _mm256_mul_ps(a, b); } __m256 <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> / (__m256 <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> a, __m256 <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> b) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _mm256_div_ps(a, b); } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i&gt; __<span class="hljs-function"><span class="hljs-function">m256 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">perm</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(__m256 </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> v)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _mm256_permute_ps(v, _MM_SHUFFLE(i, i, i, i)); } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> a, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> b, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> c, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> d&gt; __<span class="hljs-function"><span class="hljs-function">m256 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">perm</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(__m256 </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> v)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _mm256_permute_ps(v, _MM_SHUFFLE(a, b, c, d)); } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> j&gt; __<span class="hljs-function"><span class="hljs-function">m256 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">perm</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(__m256 </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> v)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _mm256_permutevar_ps(v, _mm256_set_epi32(i, i, i, i, j, j, j, j)); } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> a, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> b, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> c, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> d, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> e, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> f, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> g, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> h&gt; __<span class="hljs-function"><span class="hljs-function">m256 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">perm</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(__m256 </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> v)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _mm256_permutevar_ps(v, _mm256_set_epi32(a, b, c, d, e, f, g, h)); } __<span class="hljs-function"><span class="hljs-function">m256 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mad</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(__m256 </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> a, __m256 </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> b, __m256 </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> c)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _mm256_add_ps(_mm256_mul_ps(a, b), c); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mul_mtx4_mtx4_avx_v2</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(__m128* </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> r, __m128 </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params">* </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> m, __m128 </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params">* </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> n)</span></span></span><span class="hljs-function"> </span></span>{ __m256 <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> mm[] { _mm256_broadcast_ps(m+<span class="hljs-number"><span class="hljs-number">0</span></span>), _mm256_broadcast_ps(m+<span class="hljs-number"><span class="hljs-number">1</span></span>), _mm256_broadcast_ps(m+<span class="hljs-number"><span class="hljs-number">2</span></span>), _mm256_broadcast_ps(m+<span class="hljs-number"><span class="hljs-number">3</span></span>) }; __m256 <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> n0n1 = _mm256_load_ps(&amp;n[<span class="hljs-number"><span class="hljs-number">0</span></span>].m128_f32[<span class="hljs-number"><span class="hljs-number">0</span></span>]); _mm256_stream_ps(&amp;r[<span class="hljs-number"><span class="hljs-number">0</span></span>].m128_f32[<span class="hljs-number"><span class="hljs-number">0</span></span>], mad(perm&lt;<span class="hljs-number"><span class="hljs-number">3</span></span>&gt;(n0n1), mm[<span class="hljs-number"><span class="hljs-number">0</span></span>], perm&lt;<span class="hljs-number"><span class="hljs-number">2</span></span>&gt;(n0n1)*mm[<span class="hljs-number"><span class="hljs-number">1</span></span>])+ mad(perm&lt;<span class="hljs-number"><span class="hljs-number">1</span></span>&gt;(n0n1), mm[<span class="hljs-number"><span class="hljs-number">2</span></span>], perm&lt;<span class="hljs-number"><span class="hljs-number">0</span></span>&gt;(n0n1)*mm[<span class="hljs-number"><span class="hljs-number">3</span></span>])); __m256 <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> n2n3 = _mm256_load_ps(&amp;n[<span class="hljs-number"><span class="hljs-number">2</span></span>].m128_f32[<span class="hljs-number"><span class="hljs-number">0</span></span>]); _mm256_stream_ps(&amp;r[<span class="hljs-number"><span class="hljs-number">2</span></span>].m128_f32[<span class="hljs-number"><span class="hljs-number">0</span></span>], mad(perm&lt;<span class="hljs-number"><span class="hljs-number">3</span></span>&gt;(n2n3), mm[<span class="hljs-number"><span class="hljs-number">0</span></span>], perm&lt;<span class="hljs-number"><span class="hljs-number">2</span></span>&gt;(n2n3)*mm[<span class="hljs-number"><span class="hljs-number">1</span></span>])+ mad(perm&lt;<span class="hljs-number"><span class="hljs-number">1</span></span>&gt;(n2n3), mm[<span class="hljs-number"><span class="hljs-number">2</span></span>], perm&lt;<span class="hljs-number"><span class="hljs-number">0</span></span>&gt;(n2n3)*mm[<span class="hljs-number"><span class="hljs-number">3</span></span>])); }</code> </pre><br></div></div><br>  Et ici, les r√©sultats sont d√©j√† plus int√©ressants.  IACA produit des nombres: <em>x86 - 10, x64 - 8,58</em> , ce qui semble beaucoup mieux, mais toujours pas 2 fois. <br><br><h3>  Option AVX + FMA (finale) </h3><br>  Faisons une autre tentative.  Il serait maintenant logique de rappeler √† nouveau le jeu d'instructions FMA, car il a √©t√© ajout√© aux processeurs apr√®s AVX.  Il suffit de changer individuellement <em>mul + add</em> pour une seule op√©ration.  Bien que nous utilisions toujours l'instruction de multiplication pour donner au compilateur plus de possibilit√©s d'optimisation et le processeur pour l'ex√©cution parall√®le de multiplications.  Habituellement, je regarde le code g√©n√©r√© dans l'assembleur pour m'assurer quelle option est meilleure. <br><br>  Dans ce cas, nous devons calculer <em><nobr>a * b + c * d + e * f + g * h</nobr></em> .  Vous pouvez faire ce front: <em><nobr>fma (a, b, fma (c, d, fma (e, f, g * h)))</nobr></em> .  Mais, comme nous le voyons, il est impossible d'effectuer une op√©ration ici sans terminer la pr√©c√©dente.  Et cela signifie que nous ne pourrons pas utiliser la possibilit√© de faire des multiplications par paires, comme le permet le pipeline SIMD.  Si nous transformons l√©g√®rement les calculs <em><nobr>fma (a, b, c * d) + fma (e, f, g * h)</nobr></em> , nous verrons que nous pouvons parall√©liser les calculs.  Faites d'abord deux multiplications ind√©pendantes, puis deux op√©rations <em>fma</em> ind√©pendantes. <br><br><div class="spoiler">  <b class="spoiler_title">Impl√©mentation AVX + FMA</b> <div class="spoiler_text"><pre> <code class="cpp hljs">__<span class="hljs-function"><span class="hljs-function">m256 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fma</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(__m256 </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> a, __m256 </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> b, __m256 </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> c)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _mm256_fmadd_ps(a, b, c); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mul_mtx4_mtx4_avx_fma</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(__m128* </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> r, __m128 </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params">* </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> m, __m128 </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params">* </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> n)</span></span></span><span class="hljs-function"> </span></span>{ __m256 <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> mm[]{ _mm256_broadcast_ps(m + <span class="hljs-number"><span class="hljs-number">0</span></span>), _mm256_broadcast_ps(m + <span class="hljs-number"><span class="hljs-number">1</span></span>), _mm256_broadcast_ps(m + <span class="hljs-number"><span class="hljs-number">2</span></span>), _mm256_broadcast_ps(m + <span class="hljs-number"><span class="hljs-number">3</span></span>) }; __m256 <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> n0n1 = _mm256_load_ps(&amp;n[<span class="hljs-number"><span class="hljs-number">0</span></span>].m128_f32[<span class="hljs-number"><span class="hljs-number">0</span></span>]); _mm256_stream_ps(&amp;r[<span class="hljs-number"><span class="hljs-number">0</span></span>].m128_f32[<span class="hljs-number"><span class="hljs-number">0</span></span>], fma(perm&lt;<span class="hljs-number"><span class="hljs-number">3</span></span>&gt;(n0n1), mm[<span class="hljs-number"><span class="hljs-number">0</span></span>], perm&lt;<span class="hljs-number"><span class="hljs-number">2</span></span>&gt;(n0n1)*mm[<span class="hljs-number"><span class="hljs-number">1</span></span>])+ fma(perm&lt;<span class="hljs-number"><span class="hljs-number">1</span></span>&gt;(n0n1), mm[<span class="hljs-number"><span class="hljs-number">2</span></span>], perm&lt;<span class="hljs-number"><span class="hljs-number">0</span></span>&gt;(n0n1)*mm[<span class="hljs-number"><span class="hljs-number">3</span></span>])); __m256 <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> n2n3 = _mm256_load_ps(&amp;n[<span class="hljs-number"><span class="hljs-number">2</span></span>].m128_f32[<span class="hljs-number"><span class="hljs-number">0</span></span>]); _mm256_stream_ps(&amp;r[<span class="hljs-number"><span class="hljs-number">2</span></span>].m128_f32[<span class="hljs-number"><span class="hljs-number">0</span></span>], fma(perm&lt;<span class="hljs-number"><span class="hljs-number">3</span></span>&gt;(n2n3), mm[<span class="hljs-number"><span class="hljs-number">0</span></span>], perm&lt;<span class="hljs-number"><span class="hljs-number">2</span></span>&gt;(n2n3)*mm[<span class="hljs-number"><span class="hljs-number">1</span></span>])+ fma(perm&lt;<span class="hljs-number"><span class="hljs-number">1</span></span>&gt;(n2n3), mm[<span class="hljs-number"><span class="hljs-number">2</span></span>], perm&lt;<span class="hljs-number"><span class="hljs-number">0</span></span>&gt;(n2n3)*mm[<span class="hljs-number"><span class="hljs-number">3</span></span>])); }</code> </pre><br></div></div><br>  IACA: <em>x86 - 9.21, x64 - 8</em> .  Maintenant c'est tr√®s bien.  Quelqu'un dira probablement ce qui peut √™tre fait encore mieux, mais je ne sais pas comment. <br><br><h2>  Rep√®res </h2><br>  Je constate tout de suite que ces chiffres ne doivent pas √™tre consid√©r√©s comme la v√©rit√© ultime.  M√™me avec un test fixe, ils nagent dans certaines limites.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Et plus encore, ils se comportent diff√©remment sur diff√©rentes plateformes. </font><font style="vertical-align: inherit;">Avec toute optimisation, prenez des mesures sp√©cifiquement pour votre cas.</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Table des mati√®res </font></font></h4><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fonction: nom de la fonction. </font><font style="vertical-align: inherit;">La fin sur </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">s</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - fonctionne avec un streaming, mov autrement normal (sans streaming). </font><font style="vertical-align: inherit;">Ajout√© pour plus de clart√©, car c'est assez important.</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Cycles IACA: nombre de ticks par fonction calcul√© par IACA </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Cycles mesur√©s: nombre mesur√© de mesures (moins c'est plus) </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Acc√©l√©ration IACA: nombre de mesures sur une ligne z√©ro / nombre de mesures sur une ligne </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Acc√©l√©ration mesur√©e: nombre de mesures dans la ligne z√©ro / nombre de mesures dans la ligne (plus c'est mieux) </font></font></li></ul><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pour loop_m, les graduations de l'article ont √©t√© multipli√©es par 64. Autrement dit, il s'agit d'une valeur tr√®s approximative. </font><font style="vertical-align: inherit;">En fait, cela s'est av√©r√© ainsi.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> i3-3770: </font></font></h3><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">x86</font></font></b> <div class="spoiler_text"><div class="scrollable-table"><table><tbody><tr><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Fonction </font></font></th><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Cycles IACA </font></font></th><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Cycles mesur√©s </font></font></th><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Acc√©l√©ration IACA </font></font></th><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Acc√©l√©ration mesur√©e </font></font></th></tr><tr><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> d√©rouler_m </font></font></th><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 70,00 </font></font></th><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 50,75 </font></font></th><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 1,00 </font></font></th><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 1,00 </font></font></th></tr><tr><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> loop_m </font></font></th><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 233,60 </font></font></th><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 119,21 </font></font></th><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0,30 </font></font></th><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0,43 </font></font></th></tr><tr><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> sse_v1m </font></font></th><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 18,89 </font></font></th><th> 27.51 </th><th> 3.70 </th><th> 1.84 </th></tr><tr><th> sse_v2m </th><th> 19.00 </th><th> 27.61 </th><th> 3.68 </th><th> 1.84 </th></tr><tr><th> sse_v3m </th><th> 18.89 </th><th> 27.22 </th><th> 3.70 </th><th> 1.86 </th></tr><tr><th> sse_v4s </th><th> 18.89 </th><th> 27.18 </th><th> 3.70 </th><th> 1.87 </th></tr><tr><th> avx_v1m </th><th> 13.00 </th><th> 19.21 </th><th> 5.38 </th><th> 2.64 </th></tr><tr><th> avx_v1s </th><th> 13.00 </th><th> 20.03 </th><th> 5.38 </th><th> 2.53 </th></tr><tr><th> avx_v2m </th><th> 10.00 </th><th> 12.91 </th><th> 6.99 </th><th> 3.93 </th></tr><tr><th> avx_v2s </th><th> 10.00 </th><th> 17.34 </th><th> 6.99 </th><th> 2.93 </th></tr></tbody></table></div></div></div><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">x64</font></font></b> <div class="spoiler_text"><div class="scrollable-table"><table><tbody><tr><th> Function </th><th> IACA cycles </th><th> Measured cycles </th><th> IACA speedup </th><th> Measured speedup </th></tr><tr><th> unroll_m </th><th>  70 </th><th> 68.60 </th><th> 1.00 </th><th> 1.00 </th></tr><tr><th> loop_m </th><th> 233.60 </th><th> 119.37 </th><th> 0.30 </th><th> 0.57 </th></tr><tr><th> sse_v1m </th><th> 18.89 </th><th> 21.98 </th><th> 3.70 </th><th> 3.12 </th></tr><tr><th> sse_v2m </th><th> 19.00 </th><th> 21.09 </th><th> 3.68 </th><th> 3.25 </th></tr><tr><th> sse_v3m </th><th> 18.89 </th><th> 22.19 </th><th> 3.70 </th><th> 3.09 </th></tr><tr><th> sse_v4s </th><th> 18.89 </th><th> 22.39 </th><th> 3.70 </th><th> 3.06 </th></tr><tr><th> avx_v1m </th><th> 13.00 </th><th> 9.61 </th><th> 5.38 </th><th> 7.13 </th></tr><tr><th> avx_v1s </th><th> 13.00 </th><th> 16.90 </th><th> 5.38 </th><th> 4.06 </th></tr><tr><th> avx_v2m </th><th> 10.00 </th><th> 9.20 </th><th> 6.99 </th><th> 7.45 </th></tr><tr><th> avx_v2s </th><th> 10.00 </th><th> 14.64 </th><th> 6.99 </th><th> 4.68 </th></tr></tbody></table></div></div></div><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> i7-8700K: </font></font></h3><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">x86</font></font></b> <div class="spoiler_text"><div class="scrollable-table"><table><tbody><tr><th> Function </th><th> IACA cycles </th><th> Measured cycles </th><th> IACA speedup </th><th> Measured speedup </th></tr><tr><th> unroll_m </th><th> 69.95 </th><th> 40.25 </th><th> 1.00 </th><th> 1.00 </th></tr><tr><th> loop_m </th><th> 233.60 </th><th> 79.49 </th><th> 0.30 </th><th> 0.51 </th></tr><tr><th> sse_v1m </th><th> 18.89 </th><th> 19.31 </th><th> 3.70 </th><th> 2.09 </th></tr><tr><th> sse_v2m </th><th> 19.00 </th><th> 19.98 </th><th> 3.68 </th><th> 2.01 </th></tr><tr><th> sse_v3m </th><th> 18.89 </th><th> 19.69 </th><th> 3.70 </th><th> 2.04 </th></tr><tr><th> sse_v4s </th><th> 18.89 </th><th> 19.67 </th><th> 3.70 </th><th> 2.05 </th></tr><tr><th> avx_v1m </th><th> 13.00 </th><th> 14.22 </th><th> 5.38 </th><th> 2.83 </th></tr><tr><th> avx_v1s </th><th> 13.00 </th><th> 14.13 </th><th> 5.38 </th><th> 2.85 </th></tr><tr><th> avx_v2m </th><th> 10.00 </th><th> 11.73 </th><th> 6.99 </th><th> 3.43 </th></tr><tr><th> avx_v2s </th><th> 10.00 </th><th> 11.81 </th><th> 6.99 </th><th> 3.41 </th></tr><tr><th> AVX+FMAm </th><th> 9.21 </th><th> 10.38 </th><th> 7.60 </th><th> 3.88 </th></tr><tr><th> AVX+FMAs </th><th> 9.21 </th><th> 10.32 </th><th> 7.60 </th><th> 3.90 </th></tr></tbody></table></div></div></div><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">x64</font></font></b> <div class="spoiler_text"><div class="scrollable-table"><table><tbody><tr><th> Function </th><th> IACA cycles </th><th> Measured cycles </th><th> IACA speedup </th><th> Measured speedup </th></tr><tr><th> unroll_m </th><th> 69.95 </th><th> 57.11 </th><th> 1.00 </th><th> 1.00 </th></tr><tr><th> loop_m </th><th> 233.60 </th><th> 75.73 </th><th> 0.30 </th><th> 0.75 </th></tr><tr><th> sse_v1m </th><th> 18.89 </th><th> 15.83 </th><th> 3.70 </th><th> 3.61 </th></tr><tr><th> sse_v2m </th><th> 19.00 </th><th> 17.22 </th><th> 3.68 </th><th> 3.32 </th></tr><tr><th> sse_v3m </th><th> 18.89 </th><th> 15.92 </th><th> 3.70 </th><th> 3.59 </th></tr><tr><th> sse_v4s </th><th> 18.89 </th><th> 16.18 </th><th> 3.70 </th><th> 3.53 </th></tr><tr><th> avx_v1m </th><th> 13.00 </th><th> 7.03 </th><th> 5.38 </th><th> 8.12 </th></tr><tr><th> avx_v1s </th><th> 13.00 </th><th> 12.98 </th><th> 5.38 </th><th> 4.40 </th></tr><tr><th> avx_v2m </th><th> 10.00 </th><th> 5.40 </th><th> 6.99 </th><th> 10.57 </th></tr><tr><th> avx_v2s </th><th> 10.00 </th><th> 11.39 </th><th> 6.99 </th><th> 5.01 </th></tr><tr><th> AVX+FMAm </th><th> 9.21 </th><th> 9.73 </th><th> 7.60 </th><th> 5.87 </th></tr><tr><th> AVX+FMAs </th><th> 9.21 </th><th> 9.81 </th><th> 7.60 </th><th> 5.82 </th></tr></tbody></table></div></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Testez le code dans la source. </font><font style="vertical-align: inherit;">S'il existe des suggestions raisonnables sur la fa√ßon de les am√©liorer, √©crivez dans les commentaires.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> BONUS du royaume de la fiction </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En fait, c'est du domaine de la fiction parce que si je voyais des processeurs prenant en charge AVX512, alors peut-√™tre sur les photos. </font><font style="vertical-align: inherit;">Cependant, j'ai essay√© d'impl√©menter l'algorithme. </font><font style="vertical-align: inherit;">Ici, je ne vais rien expliquer, une analogie compl√®te avec AVX + FMA. </font><font style="vertical-align: inherit;">L'algorithme est le m√™me, seulement moins d'op√©rations.</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Comme on dit, je vais le laisser ici</font></font></b> <div class="spoiler_text"><pre> <code class="cpp hljs">__m512 <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> + (__m512 <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> a, __m512 <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> b) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _mm512_add_ps(a, b); } __m512 <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> - (__m512 <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> a, __m512 <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> b) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _mm512_sub_ps(a, b); } __m512 <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> * (__m512 <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> a, __m512 <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> b) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _mm512_mul_ps(a, b); } __m512 <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> / (__m512 <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> a, __m512 <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> b) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _mm512_div_ps(a, b); } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i&gt; __<span class="hljs-function"><span class="hljs-function">m512 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">perm</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(__m512 </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> v)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _mm512_permute_ps(v, _MM_SHUFFLE(i, i, i, i)); } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> a, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> b, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> c, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> d&gt; __<span class="hljs-function"><span class="hljs-function">m512 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">perm</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(__m512 </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> v)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _mm512_permute_ps(v, _MM_SHUFFLE(a, b, c, d)); } __<span class="hljs-function"><span class="hljs-function">m512 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fma</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(__m512 </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> a, __m512 </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> b, __m512 </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> c)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _mm512_fmadd_ps(a, b, c); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mul_mtx4_mtx4_avx512</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(__m128* </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> r, __m128 </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params">* </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> m, __m128 </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params">* </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> _n)</span></span></span><span class="hljs-function"> </span></span>{ __m512 <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> mm[]{ _mm512_broadcast_f32x4(m[<span class="hljs-number"><span class="hljs-number">0</span></span>]), _mm512_broadcast_f32x4(m[<span class="hljs-number"><span class="hljs-number">1</span></span>]), _mm512_broadcast_f32x4(m[<span class="hljs-number"><span class="hljs-number">2</span></span>]), _mm512_broadcast_f32x4(m[<span class="hljs-number"><span class="hljs-number">3</span></span>]) }; __m512 <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> n = _mm512_load_ps(&amp;_n[<span class="hljs-number"><span class="hljs-number">0</span></span>].m128_f32[<span class="hljs-number"><span class="hljs-number">0</span></span>]); _mm512_stream_ps(&amp;r[<span class="hljs-number"><span class="hljs-number">0</span></span>].m128_f32[<span class="hljs-number"><span class="hljs-number">0</span></span>], fma(perm&lt;<span class="hljs-number"><span class="hljs-number">3</span></span>&gt;(n), mm[<span class="hljs-number"><span class="hljs-number">0</span></span>], perm&lt;<span class="hljs-number"><span class="hljs-number">2</span></span>&gt;(n)*mm[<span class="hljs-number"><span class="hljs-number">1</span></span>])+ fma(perm&lt;<span class="hljs-number"><span class="hljs-number">1</span></span>&gt;(n), mm[<span class="hljs-number"><span class="hljs-number">2</span></span>], perm&lt;<span class="hljs-number"><span class="hljs-number">0</span></span>&gt;(n)*mm[<span class="hljs-number"><span class="hljs-number">3</span></span>])); }</code> </pre><br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Les chiffres sont fantastiques: </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">x86 - 4,79, x64 - 5,42</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (IACA avec architecture SKX). </font><font style="vertical-align: inherit;">Ceci malgr√© le fait que l'algorithme a 64 multiplications et 48 additions.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Code PS de l'article </font></font></h2><br><div class="oembed"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">https://github.com/truthfinder/mul_m4_m4</font></font></a> </div><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ceci est ma premi√®re exp√©rience en √©crivant un article. </font><font style="vertical-align: inherit;">Merci √† tous pour vos commentaires. </font><font style="vertical-align: inherit;">Ils aident √† am√©liorer le code et l'article.</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr418247/">https://habr.com/ru/post/fr418247/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr418237/index.html">D√©veloppement d'applications multi-locataires sur la plateforme cloud SAP dans Neo, partie 2: autorisation et authentification</a></li>
<li><a href="../fr418239/index.html">48 m√©gapixels pour smartphone</a></li>
<li><a href="../fr418241/index.html">Pourquoi Gauss? (100 fa√ßons de r√©soudre le syst√®me d'√©quations)</a></li>
<li><a href="../fr418243/index.html">L'histoire populaire de l'astronomie est fausse</a></li>
<li><a href="../fr418245/index.html">Comment ne pas d√©velopper un projet sur Bitrix</a></li>
<li><a href="../fr418249/index.html">Nouvelles images de machine virtuelle Google Compute Engine pour le Deep Learning</a></li>
<li><a href="../fr418251/index.html">Vision par ordinateur: comment l'IA nous regarde</a></li>
<li><a href="../fr418253/index.html">La premi√®re lune pourrait avoir de l'eau, de l'atmosph√®re et de la vie</a></li>
<li><a href="../fr418255/index.html">Comment les √©changes de trafic revendent l'autosurfing et d'o√π viennent des millions de bots en ligne</a></li>
<li><a href="../fr418257/index.html">Github.com refuse d'utiliser jQuery et passe en JavaScript pur</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>