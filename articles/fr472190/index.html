<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🚵 👈🏽 🤕 Exécutez des scripts PHP via php-fpm sans serveur Web. Ou votre client FastCGI (sous le capot) 🐿️ 🤾🏾 🙌🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Je souhaite la bienvenue à tous les lecteurs de "Habr". 
 Clause de non-responsabilité 


 L'article s'est avéré assez long et pour ceux qui ne veulen...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Exécutez des scripts PHP via php-fpm sans serveur Web. Ou votre client FastCGI (sous le capot)</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/472190/"><p>  Je souhaite la bienvenue à tous les lecteurs de "Habr". </p><br><h4 id="diskleymer">  Clause de non-responsabilité </h4><br><p>  L'article s'est avéré assez long et pour ceux qui ne veulent pas lire le fond, mais veulent aller droit au but, je vous pose directement le chapitre "Solution". </p><br><h3 id="vstuplenie">  Entrée </h3><br><p>  Dans cet article, je voudrais parler de la résolution d'un problème plutôt non standard auquel j'ai dû faire face pendant le processus de travail.  À savoir, nous devions exécuter un tas de scripts php en boucle.  Je ne discuterai pas des raisons et de la controverse d'une telle solution architecturale dans cet article, car  en fait, il ne s’agissait pas du tout de ça, c’était juste une tâche, il fallait la résoudre et la solution me semblait suffisamment intéressante pour que je puisse la partager avec vous, d’autant plus que je n’ai trouvé aucun mana sur cette question sur Internet (enfin, bien sûr, sauf les spécifications officielles).  Speck, bien sûr, est bon, et bien sûr tout y est, mais je pense que vous conviendrez que si vous n'êtes pas particulièrement familier avec le sujet, et même limité dans le temps, alors les comprendre est toujours un plaisir. </p><a name="habracut"></a><br><h3 id="dlya-kogo-eta-statya">  À qui s'adresse cet article? </h3><br><p>  Pour tous ceux qui travaillent avec le Web et le protocole <strong>FastCgi</strong> sait <strong>seulement</strong> que c'est le protocole selon lequel le serveur Web exécute des scripts PHP, mais veut l'étudier plus en détail et regarder sous le capot. </p><br><h3 id="obosnovanie-zachem-eta-statya">  Justification (pourquoi cet article) </h3><br><p>  En général, comme je l'ai écrit ci-dessus, lorsque nous avons été confrontés à la nécessité d'exécuter de nombreux scripts php sans la participation d'un serveur Web (en gros, à partir d'un autre script php), la première chose qui m'est venue à l'esprit est ... </p><br><pre><code class="php hljs">shell_exec(<span class="hljs-string"><span class="hljs-string">'php \path\to\script.php'</span></span>)</code> </pre> <br><p>  Mais au début de chaque script, un environnement sera créé, un processus séparé sera lancé, en général, cela semblait en quelque sorte coûteux pour les ressources.  Cette implémentation a été rejetée.  La deuxième chose qui m'est venue à l'esprit est bien sûr <strong>php-fpm</strong> , c'est tellement cool, il ne démarre l'environnement qu'une seule fois, surveille la mémoire, y enregistre tout correctement, démarre et arrête les scripts, en général tout se refroidit, et bien sûr nous avons aimé cette façon plus. </p><br><p>  Mais c'est de la malchance, en théorie, nous savions comment cela fonctionne, en termes généraux (car il s'est avéré très général), mais il s'est avéré assez difficile de mettre en œuvre ce protocole dans la pratique sans la participation d'un serveur Web.  La lecture des spécifications et quelques heures de tentatives infructueuses ont montré que la mise en œuvre prendrait du temps, ce que nous n'avions pas à l'époque.  Il n'y a pas de mana pour la mise en œuvre de cette entreprise dans laquelle cette interaction pourrait être décrite simplement et clairement, nous ne pouvions pas non plus prendre de spécifications, à partir des solutions prêtes à l'emploi, nous avons trouvé un script Python et une bibliothèque Pykhov sur le github, qui au final ne voulait pas être traîné dans mon projet (peut-être ce n'est pas correct, mais pas vraiment, nous aimons toutes sortes de bibliothèques tierces et même pas très populaires, et donc non testées).  En général, à la suite de cette idée, nous avons refusé et mis en œuvre tout cela à travers le bon vieux rabbitmq. </p><br><p>  Bien que le problème ait finalement été résolu, j'ai quand même décidé de comprendre FastCgi en détail, et en plus j'ai décidé d'écrire un article à ce sujet, qui décrira simplement et en détail comment obtenir <strong>php-fpm</strong> pour exécuter un script php sans serveur web, ou plutôt, comme le serveur web aura un script différent, alors je l'appellerai le client Fcgi.  En général, j'espère que cet article aidera ceux qui sont confrontés à la même tâche que nous et après avoir lu, il pourra écrire rapidement tout ce dont il a besoin. </p><br><h3 id="tvorcheskiy-poisk-lozhnyy-put">  Recherche créative (faux chemin) </h3><br><p>  Donc, le problème est indiqué, nous devons procéder à la solution.  Naturellement, comme tout programmeur "normal", pour résoudre un problème sur lequel il n'est écrit nulle part quoi faire et quoi entrer dans la console, je n'ai pas lu et traduit la spécification, mais j'ai immédiatement trouvé ma propre solution "géniale".  Son essence est la suivante, je sais que <strong>nginx</strong> (nous utilisons nginx et pour ne pas écrire plus de <strong>bêtises</strong> - un serveur web, j'écrirai nginx, car il est plus sympathique) transfère quelque chose à <strong>php-fpm</strong> , il traite <strong>également php-fpm</strong> à il exécute un script sur la base de celui-ci, eh bien, tout semble être simple, je vais le prendre et le promettre de transmettre <strong>nginx</strong> et je passerai la même chose. </p><br><p>  Un grand <strong>netcat vous</strong> aidera ici (utilitaire UNIX pour travailler avec le trafic réseau, qui à mon avis peut faire presque n'importe quoi).  Donc, nous configurons <strong>netcat</strong> pour écouter sur le port local, et configurons <strong>nginx</strong> pour fonctionner avec les fichiers php via le socket (naturellement, le socket sur le même port que <strong>netcat</strong> écoute) </p><br><p>  écoute du port 9000 </p><br><pre> <code class="plaintext hljs">nc -l 9000</code> </pre> <br><p>  Vous pouvez vérifier que tout va bien, vous pouvez contacter l'adresse 127.0.0.1:9000 via un navigateur et l'image suivante doit être </p><br><img src="https://habrastorage.org/webt/ux/9s/_f/ux9s_fkir12e0yn3arj010nnezw.png"><br><p>  configurer <strong>nginx</strong> pour qu'il traite les scripts php via une socket sur le port 9000 (dans les paramètres '/ etc / nginx / sites-available / default', bien sûr, ils peuvent différer) </p><br><pre> <code class="plaintext hljs">location ~ \.php$ { include snippets/fastcgi-php.conf; fastcgi_pass 127.0.0.1:9000; }</code> </pre><br><p>  Après ces manipulations, nous vérifierons ce qui s'est passé en contactant le script php via le navigateur </p><br><img src="https://habrastorage.org/webt/u_/hf/j1/u_hfj1xa4tnqyb35rdmfu5nf-na.png"><br><p>  On peut voir que <strong>nginx a</strong> envoyé des variables d'environnement, ainsi que des caractères non imprimables, c'est-à-dire que les données ont été transmises en encodage binaire, ce qui signifie qu'elles ne peuvent pas être copiées si facilement et envoyées au <strong>socket php-fpm</strong> .  Si vous les enregistrez dans un fichier, par exemple, puis ils sont enregistrés dans le codage hexadécimal, il semblera que cela s'applique </p><br><img src="https://habrastorage.org/webt/le/7e/9y/le7e9ycpkn8n3mezj7ksa9xhkki.png"><br><p>  Mais cela ne nous donne pas grand-chose non plus, probablement purement théoriquement, ils peuvent être convertis en encodage binaire, d'une manière ou d'une autre (je ne peux même pas imaginer comment) pour les envoyer à la prise fpm, et il y a même une chance que cette moto entière fonctionne d'une manière ou d'une autre et même démarre une sorte de un script, mais en quelque sorte tout est laid et maladroit. </p><br><p>  Il est devenu clair que ce chemin était complètement faux, vous pouvez voir par vous-même à quel point tout cela semble misérable, et plus encore, toutes ces actions ne nous permettront pas de contrôler la connexion, ni de nous rapprocher de la compréhension de l'interaction entre <strong>php-fpm</strong> et <strong>nginx</strong> . </p><br><p>  Tout est parti, la spécification ne peut être évitée! </p><br><h3 id="reshenie-tut-sobstvenno-nachinaetsya-vsya-sol-dannoy-stati">  Solution (ici commence tout le sel de cet article) </h3><br><h4 id="teoreticheskaya-podgotovka">  Formation théorique </h4><br><p>  Voyons maintenant comment il existe tout de même une connexion et un échange de données entre <strong>nginx</strong> et <strong>php-fpm</strong> .  Un peu de théorie, toutes les communications s'effectuent comme cela est déjà clair à travers les sockets, nous considérerons plus spécifiquement une connexion via une socket TCP. </p><br><p>  L'unité d'informations dans le protocole <strong>FastCgi</strong> est un <strong>enregistrement cgi</strong> .  Le serveur envoie ces enregistrements à l'application et reçoit exactement les mêmes enregistrements en réponse. </p><br><h5 id="nemnogo-teorii-struktury">  Un peu de théorie (structure) </h5><br><p>  Ensuite, considérez la structure de l'enregistrement.  Pour comprendre en quoi consiste un enregistrement, vous devez comprendre à quoi ressemblent les structures C et comprendre leurs désignations.  Pour ceux qui ne savent pas plus, ce sera brièvement (mais suffisant pour comprendre) décrit.  Je vais essayer de le décrire aussi simple que possible, il est inutile d’entrer dans les détails, et je crains de me perdre dans les détails, l’essentiel est d’avoir une compréhension commune. </p><br><p>  Les structures sont simplement une collection d'octets et leur notation permet de les interpréter.  Autrement dit, vous avez juste une séquence de zéros et de uns, et certaines données sont cryptées dans cette séquence, mais jusqu'à présent, vous n'avez aucune annotation pour cette séquence, alors ces données ne représentent aucune valeur pour vous, car  vous ne pouvez pas les interpréter. </p><br><pre> <code class="plaintext hljs">//     1101111000000010010110000010011100010000</code> </pre> <br><p>  Ce qui est visible ici, nous avons quelques bits, quel genre de bits nous n'avons aucune idée.  Eh bien, essayons par exemple de les diviser en octets et de les représenter en système décimal </p><br><pre> <code class="plaintext hljs">//   5  11011110 00000010 01011000 00100111 00010000 //    222 2 88 39 16</code> </pre> <br><p>  Eh bien, nous les avons interprétés et avons obtenu des résultats, disons que ces données sont responsables de la quantité d'électricité qu'un appartement doit.  Il s'avère que dans la maison 222 l'appartement numéro 2 doit payer 88 roubles.  Et quoi d'autre pour deux chiffres, que faire avec juste pour laisser tomber?  Bien sûr que non!  le fait est que nous n'avions pas de notation (format) qui nous dirait comment interpréter les données, et les interpréter à notre manière, à cet égard, nous avons reçu non seulement des résultats inutiles, mais aussi nuisibles.  En conséquence, l'appartement 2 n'a absolument pas payé ce qu'il aurait dû.  (les exemples sont certainement farfelus et ne servent qu'à expliquer plus clairement la situation) </p><br><p>  Voyons maintenant comment interpréter correctement ces données, en ayant une notation (format).  De plus, j'appellerai un chat un chat, à savoir notation = format ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici les formats</a> ). </p><br><pre> <code class="plaintext hljs">//  "Cnn" //  //C -   (char) (8 ) //n -  short (16 ) //      11011110 0000001001011000 0010011100010000 //    222 600 10000</code> </pre> <br><p>  Maintenant, tout converge dans la maison n ° 222 appartement 600 pour l'électricité devrait être de 1000 roubles. Je pense que maintenant l'importance du format est claire, et maintenant il est clair à quoi ressemble à peu près une structure similaire.  (veuillez faire attention, ici le but n'est pas d'expliquer en détail ce que sont ces structures, mais de donner une compréhension générale de ce que c'est et comment cela fonctionne) </p><br><p>  Le symbole de cette structure sera </p><br><pre> <code class="plaintext hljs">struct { unsigned char houseNumber; unsigned char flatNumperA1; unsigned char flatNumperA2; unsigned char summB1; unsigned char summB2; }; // ,           // houseNumber -  // flatNumperA1 &amp;&amp; flatNumperA2 -  // summB1 &amp;&amp; summB2 -  </code> </pre> <br><h5 id="esche-nemnogo-teorii-fastcgi-zapisi">  Un peu plus de théorie (entrées FastCgi) </h5><br><p>  Comme je l'ai dit ci-dessus, l'unité d'information dans le protocole FastCgi est les enregistrements.  Le serveur envoie les enregistrements à l'application et reçoit les mêmes enregistrements en réponse.  Un enregistrement se compose d'un en-tête et d'un corps contenant des données. </p><br><p>  Structure d'en-tête: </p><br><ol><li>  la version du protocole (toujours 1) est indiquée par 1 octet ('C') </li><li>  type d'enregistrement.  Pour ouvrir, fermer la connexion, etc. Je ne considérerai pas tout, alors je ne considérerai que ce qui est nécessaire pour une tâche spécifique, si d'autres sont nécessaires, accueillez la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">spécification</a> ici.  Il est indiqué par 1 octet («C»). </li><li>  L'ID de la demande, un nombre arbitraire, est désigné par 2 octets ('n') </li><li>  la longueur du corps de l'enregistrement (données), indiquée par 2 octets ('n') </li><li>  la longueur des données d'alignement et des données réservées, un octet chacune (il n'est pas nécessaire de porter une attention particulière pour ne pas être distrait de la principale dans notre cas il y aura toujours 0) </li></ol><br><p>  Vient ensuite le corps du dossier: </p><br><ol><li>  les données elles-mêmes (ici ce sont précisément les variables qui sont transférées) peuvent être assez volumineuses (jusqu'à 65 535 octets) </li></ol><br><p>  Voici un exemple de l'enregistrement binaire FastCgi le plus simple au format </p><br><pre> <code class="plaintext hljs">struct { // unsigned char version; unsigned char type; unsigned char idA1; unsigned char idA2; unsigned char bodyLengthB1; unsigned char bodyLengthB2; unsigned char paddingLength; unsigned char reserved; //  unsigned char contentData; // 65535  unsigned char paddingData; };</code> </pre> <br><h4 id="praktika">  Pratique </h4><br><h5 id="skript-klient-i-peredayuschiy-soket">  Client de script et socket de transmission </h5><br><p>  Pour le transfert de données, nous utiliserons l'extension de socket php standard.  Et la première chose à faire est de configurer <strong>php-fpm</strong> pour écouter sur le port de l'hôte local, par exemple 9000. Cela se fait dans la plupart des cas dans le fichier '/etc/php/7.3/fpm/pool.d/www.conf', le chemin bien sûr Dépend de vos paramètres système.  Là, vous devez enregistrer quelque chose comme le suivant (j'apporte tout le footcloth pour que vous puissiez naviguer, la section principale est écouter ici) </p><br><pre> <code class="plaintext hljs">; The address on which to accept FastCGI requests. ; Valid syntaxes are: ; 'ip.add.re.ss:port' - to listen on a TCP socket to a specific IPv4 address on ; a specific port; ; '[ip:6:addr:ess]:port' - to listen on a TCP socket to a specific IPv6 address on ; a specific port; ; 'port' - to listen on a TCP socket to all addresses ; (IPv6 and IPv4-mapped) on a specific port; ; '/path/to/unix/socket' - to listen on a unix socket. ; Note: This value is mandatory. ;listen = /run/php/php7.3-fpm.sock listen = 127.0.0.1:9002</code> </pre> <br><p>  Après avoir configuré fpm, l'étape suivante consiste à se connecter à la prise </p><br><pre> <code class="php hljs">$service_port = <span class="hljs-number"><span class="hljs-number">9000</span></span>; $address = <span class="hljs-string"><span class="hljs-string">'127.0.0.1'</span></span>; $socket = socket_create(AF_INET, SOCK_STREAM, SOL_TCP); $result = socket_connect($socket, $address, $service_port);</code> </pre> <br><h4 id="nachalo-zaprosa-fcgi_begin_request">  Début de la demande FCGI_BEGIN_REQUEST </h4><br><p>  Pour ouvrir une connexion, nous devons envoyer une entrée de type FCGI_BEGIN_REQUEST = 1 Le titre de l'entrée sera comme ceci (pour convertir les valeurs numériques en une chaîne binaire au format spécifié, le pack fonction php () sera utilisé) </p><br><pre> <code class="php hljs">socket_write($socket, pack(<span class="hljs-string"><span class="hljs-string">'CCnnCx'</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">8</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>)); <span class="hljs-comment"><span class="hljs-comment">//  - 1 //  - 1 - FCGI_BEGIN_REQUEST //id - 1 //   - 8  // - 0</span></span></code> </pre> <br><p>  Le corps d'enregistrement pour ouvrir une connexion doit contenir un rôle d'enregistrement et un indicateur contrôlant la connexion </p><br><pre> <code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">//      //struct { // unsigned char roleB1; // unsigned char roleB0; // unsigned char flags; // unsigned char reserved[5]; //}; //php  socket_write($socket, pack('nCxxxxx', 1, 0)); // - 1 -  // - 1 -    1   </span></span></code> </pre> <br><p>  Ainsi, l'enregistrement pour l'ouverture de la connexion a été envoyé avec succès, <strong>php-fpm</strong> l'acceptera et continuera à attendre de nous un autre enregistrement dans lequel nous devons transférer des données pour déployer l'environnement et exécuter le script. </p><br><h4 id="peredacha-parametrov-okruzheniya-fcgi_params">  Passage des paramètres d'environnement FCGI_PARAMS </h4><br><p>  Dans cet enregistrement, nous transmettrons tous les paramètres nécessaires au déploiement de l'environnement, ainsi que le nom du script à exécuter. </p><br><p>  Paramètres d'environnement minimum requis </p><br><pre> <code class="php hljs">$url = <span class="hljs-string"><span class="hljs-string">'/path/to/script.php'</span></span> $env = [ <span class="hljs-string"><span class="hljs-string">'REQUEST_METHOD'</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">'GET'</span></span>, <span class="hljs-string"><span class="hljs-string">'SCRIPT_FILENAME'</span></span> =&gt; $url, ];</code> </pre> <br><p>  La première chose que nous devons faire ici est de préparer les variables nécessaires, c'est-à-dire les paires nom =&gt; valeur que nous transmettrons à l'application. </p><br><p>  La structure de la valeur du nom des paires sera telle </p><br><pre> <code class="plaintext hljs">//          128  typedef struct { unsigned char nameLength; unsigned char valueLength; unsigned char nameData unsigned char valueData; }; //    1 </code> </pre> <br><p>  Il y a 1 octet en premier - le nom est long, puis 1 octet est la valeur </p><br><pre> <code class="plaintext hljs">//         128  typedef struct { unsigned char nameLengthA1; unsigned char nameLengthA2; unsigned char nameLengthA3; unsigned char nameLengthA4; unsigned char valueLengthB1; unsigned char valueLengthB2; unsigned char valueLengthB3; unsigned char valueLengthB4; unsigned char nameData unsigned char valueData; }; //    4 </code> </pre> <br><p>  Dans notre cas, le nom et les significations sont courts et correspondent à la première option, nous allons donc l'examiner. </p><br><p>  Encodez nos variables selon le format </p><br><pre> <code class="php hljs">$keyValueFcgiString = <span class="hljs-string"><span class="hljs-string">''</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> ($env <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> $key =&gt; $value) { <span class="hljs-comment"><span class="hljs-comment">//        //  128         $keyLen = strlen($key); $lenKeyChar = $keyLen &lt; 128 ? chr($keyLen) : pack('N', $keyLen); $valLen = strlen($value); $valLenChar = $valLen &lt; 128 ? chr($valLen) : pack('N', $valLen); $keyValueFcgiString .= $lenKeyChar . $valLenChar . $key . $value; }</span></span></code> </pre> <br><p>  Ici, les valeurs inférieures à 128 bits sont codées par la fonction <em>chr ($ keyLen)</em> , plus que <em>pack ('N', $ valLen)</em> , où 'N' représente 4 octets.  Et puis tout cela est collé sur une seule ligne conformément au format de la structure.  Le corps de l'enregistrement est prêt. </p><br><p>  Dans l'en-tête de l'enregistrement, nous transférons tout de la même manière que dans l'enregistrement précédent, à l'exception du type (ce sera FCGI_PARAMS = 4) et de la longueur des données (elle sera égale à la longueur des paires nom =&gt; valeur, ou à la longueur de la chaîne $ keyValueFcgiString que nous avons formée plus tôt). </p><br><pre> <code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">//  socket_write($socket, pack('CCnnCx', 1, 4, 1, strlen($keyValueFcgiString), 0)); // body socket_write($socket, $keyValueFcgiString); //             //  body socket_write($socket, pack('CCnnCx', 1, 4, 1, 0, 0));</span></span></code> </pre> <br><h4 id="poluchenie-otveta-fcgi_params">  Obtenir une réponse de FCGI_PARAMS </h4><br><p>  En fait, après que tout ce qui précède a été fait, et que tout ce qu'il attend a été envoyé à l'application, il commence à fonctionner et nous ne pouvons prendre le résultat de ce travail que depuis le socket. <br>  N'oubliez pas qu'en réponse, nous obtenons les mêmes notes et nous devons également les interpréter. </p><br><p>  Nous obtenons l'en-tête, c'est toujours 8 octets (nous recevrons les données par octet) </p><br><pre> <code class="php hljs">$buf = <span class="hljs-string"><span class="hljs-string">''</span></span>; $arrData = []; $len = <span class="hljs-number"><span class="hljs-number">8</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> ($len) { socket_recv($socket, $buf, <span class="hljs-number"><span class="hljs-number">1</span></span>, MSG_WAITALL); <span class="hljs-comment"><span class="hljs-comment">//   1       $arrData[] = $buf; $len--; } //      'CCnnCx' $protocol = unpack('C', $arrData[0]); $type = unpack('C', $arrData[1]); $id = unpack('n', $arrData[2] . $arrData[3]); $dataLen = unpack('n', $arrData[4] . $arrData[5])[1]; //   ,        (unpack  ,    ) $foo = unpack('C', $arrData[6]); var_dump($dataLen); //     </span></span></code> </pre> <br><p>  Maintenant, conformément à la longueur du corps de la réponse reçue, nous ferons une autre lecture à partir de la prise </p><br><pre> <code class="php hljs">$buf2 = <span class="hljs-string"><span class="hljs-string">''</span></span>; $result = []; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> ($dataLen) { socket_recv($socket, $buf2, <span class="hljs-number"><span class="hljs-number">1</span></span>, MSG_WAITALL); $result[] = $buf2; $dataLen--; } var_dump(implode(<span class="hljs-string"><span class="hljs-string">''</span></span>, $result)); <span class="hljs-comment"><span class="hljs-comment">//       socket_close($socket);</span></span></code> </pre> <br><p>  Hourra, ça a marché!  Enfin ça! <br>  Qu'avons-nous dans la réponse, si par exemple dans ce fichier </p><br><pre> <code class="php hljs">$url = <span class="hljs-string"><span class="hljs-string">'/path/to/script.php'</span></span> <span class="hljs-comment"><span class="hljs-comment">//    </span></span></code> </pre> <br><p>  nous écrirons </p><br><pre> <code class="php hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?php</span></span> <span class="hljs-keyword"><span class="hljs-keyword">echo</span></span> <span class="hljs-string"><span class="hljs-string">"My fcgi script"</span></span>;</code> </pre> <br><p>  puis dans la réponse que nous obtenons à la suite </p><br><p><img src="https://habrastorage.org/webt/dq/pc/ox/dqpcox1zbmcutdzxxeh69i_hbsc.png" alt="image"></p><br><h3 id="itogi">  Résumé </h3><br><p>  Je n’écrirai pas beaucoup ici, alors le long article s’est avéré.  J'espère qu'elle aide quelqu'un.  Et je vais donner le script final lui-même, il s'est avéré être assez petit.  Bien sûr, il peut faire beaucoup de choses sous cette forme, et il ne gère pas les erreurs et tout cela, mais il n'en a pas besoin, il a besoin de lui comme exemple pour montrer les bases. </p><br><div class="spoiler">  <b class="spoiler_title">Version complète du script</b> <div class="spoiler_text"><pre> <code class="php hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?php</span></span> $url = <span class="hljs-string"><span class="hljs-string">'/path/to/script.php'</span></span>; $env = [ <span class="hljs-string"><span class="hljs-string">'REQUEST_METHOD'</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">'GET'</span></span>, <span class="hljs-string"><span class="hljs-string">'SCRIPT_FILENAME'</span></span> =&gt; $url, ]; $service_port = <span class="hljs-number"><span class="hljs-number">9000</span></span>; $address = <span class="hljs-string"><span class="hljs-string">'127.0.0.1'</span></span>; $socket = socket_create(AF_INET, SOCK_STREAM, SOL_TCP); $result = socket_connect($socket, $address, $service_port); <span class="hljs-comment"><span class="hljs-comment">//  //     php-fpm //    ,   (    ), id ,   ,     socket_write($socket, pack('CCnnCx', 1, 1, 1, 8, 0)); //     // ,     socket_write($socket, pack('nCxxxxx', 1, 0)); $keyValueFcgiString = ''; foreach ($env as $key =&gt; $value) { //        //  128         $keyLen = strlen($key); $lenKeyChar = $keyLen &lt; 128 ? chr($keyLen) : pack('N', $keyLen); $valLen = strlen($value); $valLenChar = $valLen &lt; 128 ? chr($valLen) : pack('N', $valLen); $keyValueFcgiString .= $lenKeyChar . $valLenChar . $key . $value; } // ,      php-fpm           //      //1- ( ), 4-  (,    - FCGI_PARAMS), id  ( ),    (   -),     socket_write($socket, pack('CCnnCx', 1, 4, 1, strlen($keyValueFcgiString), 0)); //      socket_write($socket, $keyValueFcgiString); //  socket_write($socket, pack('CCnnCx', 1, 4, 1, 0, 0)); $buf = ''; $arrData = []; $len = 8; while ($len) { socket_recv($socket, $buf, 1, MSG_WAITALL); //   1       $arrData[] = $buf; $len--; } //      'CCnnCx' $protocol = unpack('C', $arrData[0]); $type = unpack('C', $arrData[1]); $id = unpack('n', $arrData[2] . $arrData[3]); $dataLen = unpack('n', $arrData[4] . $arrData[5])[1]; //   ,        (unpack  ,    ) $foo = unpack('C', $arrData[6]); $buf2 = ''; $result = []; while ($dataLen) { socket_recv($socket, $buf2, 1, MSG_WAITALL); $result[] = $buf2; $dataLen--; } var_dump(implode('', $result)); //       socket_close($socket);</span></span></code> </pre></div></div></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr472190/">https://habr.com/ru/post/fr472190/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr472178/index.html">Holivar. Histoire de Runet. Partie 7. YouTube: comédiens, couinements et Silicon Valley</a></li>
<li><a href="../fr472182/index.html">Annonce de l'aperçu 1 de .NET Core 3.1</a></li>
<li><a href="../fr472184/index.html">SSH à distance: trucs et astuces</a></li>
<li><a href="../fr472186/index.html">Principe ouvert-fermé</a></li>
<li><a href="../fr472188/index.html">Ce que vous devez savoir sur la vérification des chèques sur l'App Store (reçu de l'App Store)</a></li>
<li><a href="../fr472196/index.html">Du «sucre» fait maison pour un projet Android ou «Comment ne pas le faire»</a></li>
<li><a href="../fr472198/index.html">Localisation des messages push dans les applications mobiles</a></li>
<li><a href="../fr472200/index.html">Modernisation du cours d'informatique dans une école russe sur une framboise: pas cher et gai</a></li>
<li><a href="../fr472202/index.html">Windows 10 + Python = VS Code + WSL</a></li>
<li><a href="../fr472204/index.html">Expériences simples avec le microcontrôleur STM32F103 (Blue Tablet)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>