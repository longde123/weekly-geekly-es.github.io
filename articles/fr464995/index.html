<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë® üìò üññüèº Envelopper des s√©quences dans Swift üéôÔ∏è „ÄΩÔ∏è ü§º</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Bonjour √† tous. Aujourd'hui, nous voulons partager la traduction pr√©par√©e √† la veille du lancement du cours ¬´D√©veloppeur iOS. Cours avanc√© . " C'est p...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Envelopper des s√©quences dans Swift</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/otus/blog/464995/"><p>  <em>Bonjour √† tous.</em>  <em>Aujourd'hui, nous voulons partager la traduction pr√©par√©e √† la veille du lancement du cours <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">¬´D√©veloppeur iOS.</a></em>  <em><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Cours avanc√©</a> . <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">"</a></em>  <em>C'est parti!</em> </p><br><p><img src="https://habrastorage.org/webt/sk/fh/uc/skfhuco7bg9_mhjmpvov6ie9qao.png"></p><br><p>  L'un des principaux avantages de la conception bas√©e sur le protocole de Swift est qu'il nous permet d'√©crire du code g√©n√©rique compatible avec un large √©ventail de types et non sp√©cifiquement impl√©ment√© pour tout le monde.  Surtout si un tel code g√©n√©ral est destin√© √† l'un des protocoles, qui peut √™tre trouv√© dans la biblioth√®que standard, ce qui permettra de l'utiliser √† la fois avec les types int√©gr√©s et ceux d√©finis par l'utilisateur. </p><a name="habracut"></a><br><p>  Un exemple d'un tel protocole est Sequence, qui est accept√© par tous les types de biblioth√®ques standard qui peuvent √™tre it√©r√©es, comme Array, Dictionary, Set et bien d'autres.  Cette semaine, voyons comment nous pouvons encapsuler Sequence dans des conteneurs universels, ce qui nous permettra d'encapsuler divers algorithmes au c≈ìur des API faciles √† utiliser. </p><br><h3 id="iskusstvo-byt-lenivym">  L'art d'√™tre paresseux </h3><br><p>  Il est assez facile de se perdre en pensant que toutes les s√©quences sont similaires √† Array, car tous les √©l√©ments sont instantan√©ment charg√©s en m√©moire lorsque la s√©quence est cr√©√©e.  √âtant donn√© que la seule exigence du protocole de s√©quence est que les r√©cepteurs doivent √™tre capables d'it√©rer, nous ne pouvons faire aucune hypoth√®se sur la fa√ßon dont les √©l√©ments d'une s√©quence inconnue sont charg√©s ou stock√©s. <br>  Par exemple, comme nous l'avons vu dans <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">S√©quences rapides: l'art d'√™tre paresseux</a> , les s√©quences peuvent parfois charger leurs √©l√©ments paresseusement - soit pour des raisons de performances, soit parce qu'il n'est pas garanti que la s√©quence enti√®re puisse tenir en m√©moire.  Voici quelques exemples de telles s√©quences: </p><br><pre><code class="swift hljs"><span class="hljs-comment"><span class="hljs-comment">//   ,          ,           . let records = database.records(matching: searchQuery) //     ,       ,      . let folders = folder.subfolders //   ,     ,            . let nodes = node.children</span></span></code> </pre> <br><p>  √âtant donn√© que toutes les s√©quences ci-dessus sont paresseuses pour une raison quelconque, nous ne voudrions pas les forcer dans un tableau, par exemple, en appelant Array (folder.subfolders).  Mais nous pouvons toujours vouloir les modifier et les utiliser de diff√©rentes mani√®res, alors regardons comment nous pouvons le faire en cr√©ant un type d'encapsuleur de s√©quence. </p><br><h3 id="sozdanie-osnovy">  Cr√©ation de fondation </h3><br><p>  Commen√ßons par cr√©er un type de base que nous pouvons utiliser pour cr√©er toutes sortes d'API pratiques au-dessus de n'importe quelle s√©quence.  Nous l'appellerons WrappedSequence, et ce sera un type universel contenant √† la fois le type de la s√©quence que nous encapsulons et le type d'√©l√©ment que nous voulons que notre nouvelle s√©quence cr√©e. <br>  La principale caract√©ristique de notre wrapper sera sa fonction IteratorFunction, qui nous permettra de prendre le contr√¥le de la recherche de la s√©quence de base - en changeant l'it√©rateur utilis√© pour chaque it√©ration: </p><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">WrappedSequence</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Wrapped</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Sequence</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Element</span></span></span><span class="hljs-class">&gt;: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Sequence</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">typealias</span></span> <span class="hljs-type"><span class="hljs-type">IteratorFunction</span></span> = (<span class="hljs-keyword"><span class="hljs-keyword">inout</span></span> <span class="hljs-type"><span class="hljs-type">Wrapped</span></span>.<span class="hljs-type"><span class="hljs-type">Iterator</span></span>) -&gt; <span class="hljs-type"><span class="hljs-type">Element?</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> wrapped: <span class="hljs-type"><span class="hljs-type">Wrapped</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> iterator: <span class="hljs-type"><span class="hljs-type">IteratorFunction</span></span> <span class="hljs-keyword"><span class="hljs-keyword">init</span></span>(wrapping wrapped: <span class="hljs-type"><span class="hljs-type">Wrapped</span></span>, iterator: @escaping <span class="hljs-type"><span class="hljs-type">IteratorFunction</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.wrapped = wrapped <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.iterator = iterator } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">makeIterator</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">AnyIterator</span></span>&lt;<span class="hljs-type"><span class="hljs-type">Element</span></span>&gt; { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> wrappedIterator = wrapped.makeIterator() <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-type"><span class="hljs-type">AnyIterator</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.iterator(&amp;wrappedIterator) } } }</code> </pre> <br><p>  <em>Comme vous pouvez le voir ci-dessus, Sequence utilise un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">mod√®le d'usine de</a> sorte que chaque s√©quence cr√©e une nouvelle instance d'it√©rateur pour chaque it√©ration - en utilisant la m√©thode makeIterator ().</em> </p><br><p>  Ci-dessus, nous utilisons le type AnyIterator de la biblioth√®que standard, qui est un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">it√©rateur d'effacement de type</a> qui peut utiliser n'importe quelle impl√©mentation IteratorProtocol de base pour obtenir les valeurs des √©l√©ments.  Dans notre cas, nous allons cr√©er un √©l√©ment en appelant notre IteratorFunction, en passant comme argument notre propre it√©rateur de la s√©quence encapsul√©e, et puisque cet argument est marqu√© comme inout, nous pouvons changer l'it√©rateur de base en place √† l'int√©rieur de notre fonction. </p><br><p>  √âtant donn√© que WrappedSequence est √©galement une s√©quence, nous pouvons utiliser toutes les fonctionnalit√©s de la biblioth√®que standard qui lui sont associ√©es, telles que l'it√©rer dessus ou transformer ses valeurs √† l'aide de la carte: </p><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> folderNames = <span class="hljs-type"><span class="hljs-type">WrappedSequence</span></span>(wrapping: folders) { iterator <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> iterator.next()?.name } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> name <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> folderNames { ... } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> uppercasedNames = folderNames.<span class="hljs-built_in"><span class="hljs-built_in">map</span></span> { $<span class="hljs-number"><span class="hljs-number">0</span></span>.uppercased() }</code> </pre> <br><p>  Commen√ßons maintenant avec notre nouvelle WrappedSequence! </p><br><h3 id="prefiksy-i-suffiksy">  Pr√©fixes et suffixes </h3><br><p>  Lorsque vous travaillez tr√®s souvent avec des s√©quences, vous souhaitez ins√©rer un pr√©fixe ou un suffixe dans la s√©quence avec laquelle nous travaillons - mais ne serait-il pas formidable de pouvoir le faire sans changer la s√©quence principale?  Cela peut conduire √† de meilleures performances et nous permet d'ajouter des pr√©fixes et suffixes √† n'importe quelle s√©quence, et pas seulement des types g√©n√©raux tels que Array. </p><br><p>  En utilisant WrappedSequence, nous pouvons le faire assez facilement.  Tout ce que nous devons faire est d'√©tendre Sequence avec une m√©thode qui cr√©e une s√©quence encapsul√©e √† partir d'un tableau d'√©l√©ments √† ins√©rer comme pr√©fixe.  Ensuite, lorsque nous r√©p√©tons, nous commen√ßons √† it√©rer sur tous les √©l√©ments de pr√©fixe avant de continuer avec la s√©quence de base - comme ceci: </p><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extension</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Sequence</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">prefixed</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( with prefixElements: Element... )</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">WrappedSequence</span></span>&lt;<span class="hljs-type"><span class="hljs-type">Self</span></span>, <span class="hljs-type"><span class="hljs-type">Element</span></span>&gt; { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> prefixIndex = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-type"><span class="hljs-type">WrappedSequence</span></span>(wrapping: <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) { iterator <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-comment"><span class="hljs-comment">//        ,   ,   ,   : guard prefixIndex &gt;= prefixElements.count else { let element = prefixElements[prefixIndex] prefixIndex += 1 return element } //           : return iterator.next() } } }</span></span></code> </pre> <br><p>  <em>Ci-dessus, nous utilisons un param√®tre avec un nombre variable d'arguments (en ajoutant ... √† son type) pour permettre la transmission d'un ou plusieurs √©l√©ments √† la m√™me m√©thode.</em> <br>  De la m√™me mani√®re, nous pouvons cr√©er une m√©thode qui ajoute un ensemble donn√© de suffixes √† la fin de la s√©quence - d'abord en effectuant notre propre it√©ration de la s√©quence de base, puis en it√©rant sur les √©l√©ments suffix√©s: </p><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extension</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Sequence</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">suffixed</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( with suffixElements: Element... )</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">WrappedSequence</span></span>&lt;<span class="hljs-type"><span class="hljs-type">Self</span></span>, <span class="hljs-type"><span class="hljs-type">Element</span></span>&gt; { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> suffixIndex = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-type"><span class="hljs-type">WrappedSequence</span></span>(wrapping: <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) { iterator <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">guard</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> next = iterator.next() <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-comment"><span class="hljs-comment">//    ,     nil      : guard suffixIndex &lt; suffixElements.count else { return nil } let element = suffixElements[suffixIndex] suffixIndex += 1 return element } return next } } }</span></span></code> </pre> <br><p>  Avec les deux m√©thodes mentionn√©es ci-dessus, nous pouvons maintenant ajouter des pr√©fixes et des suffixes √† n'importe quelle s√©quence que nous voulons.  Voici quelques exemples d'utilisation de nos nouvelles API: </p><br><pre> <code class="swift hljs"><span class="hljs-comment"><span class="hljs-comment">//      : let allFolders = rootFolder.subfolders.prefixed(with: rootFolder) //       : let messages = inbox.messages.suffixed(with: composer.message) //       ,      : let characters = code.prefixed(with: "{").suffixed(with: "}")</span></span></code> </pre> <br><p>  Bien que tous les exemples ci-dessus puissent √™tre impl√©ment√©s √† l'aide de types sp√©cifiques (tels que Array et String), l'avantage d'utiliser notre type WrappedSequence est que tout peut √™tre fait paresseusement - nous n'effectuons aucune mutation ni n'√©valuons aucune s√©quence pour ajouter notre pr√©fixes ou suffixes - qui peuvent √™tre tr√®s utiles dans des situations critiques pour les performances ou lorsque vous travaillez avec de grands ensembles de donn√©es. </p><br><h3 id="cegmentaciya">  Segmentation </h3><br><p>  Ensuite, voyons comment nous pouvons encapsuler des s√©quences pour en cr√©er des versions segment√©es.  Dans certaines it√©rations, il ne suffit pas de savoir ce qu'est l'√©l√©ment actuel - nous pouvons √©galement avoir besoin d'informations sur les √©l√©ments suivants et pr√©c√©dents. <br>  Lorsque vous travaillez avec des s√©quences index√©es, nous pouvons souvent y parvenir en utilisant l'API √©num√©r√©e (), qui utilise √©galement un wrapper de s√©quence pour nous donner acc√®s √† la fois √† l'√©l√©ment actuel et √† son index: </p><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (index, current) <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> list.items.enumerated() { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> previous = (index &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) ? list.items[index - <span class="hljs-number"><span class="hljs-number">1</span></span>] : <span class="hljs-literal"><span class="hljs-literal">nil</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> next = (index &lt; list.items.<span class="hljs-built_in"><span class="hljs-built_in">count</span></span> - <span class="hljs-number"><span class="hljs-number">1</span></span>) ? list.items[index + <span class="hljs-number"><span class="hljs-number">1</span></span>] : <span class="hljs-literal"><span class="hljs-literal">nil</span></span> ... }</code> </pre> <br><p>  Cependant, la technique ci-dessus n'est pas seulement assez verbeuse en termes d'invocation, elle repose √©galement sur l'utilisation de tableaux √† nouveau - ou au moins d'une forme de s√©quence qui nous donne un acc√®s al√©atoire √† ses √©l√©ments - que de nombreuses s√©quences, en particulier les paresseuses pas la bienvenue. <br>  √Ä la place, utilisons √† nouveau notre WrappedSequence - pour cr√©er un encapsuleur de s√©quence qui fournit paresseusement des vues segment√©es dans sa s√©quence de base, en suivant les √©l√©ments pr√©c√©dents et actuels et en les mettant √† jour au fur et √† mesure de son it√©ration: </p><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extension</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Sequence</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">typealias</span></span> <span class="hljs-type"><span class="hljs-type">Segment</span></span> = ( previous: <span class="hljs-type"><span class="hljs-type">Element?</span></span>, current: <span class="hljs-type"><span class="hljs-type">Element</span></span>, next: <span class="hljs-type"><span class="hljs-type">Element?</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> segmented: <span class="hljs-type"><span class="hljs-type">WrappedSequence</span></span>&lt;<span class="hljs-type"><span class="hljs-type">Self</span></span>, <span class="hljs-type"><span class="hljs-type">Segment</span></span>&gt; { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> previous: <span class="hljs-type"><span class="hljs-type">Element?</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> current: <span class="hljs-type"><span class="hljs-type">Element?</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> endReached = <span class="hljs-literal"><span class="hljs-literal">false</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-type"><span class="hljs-type">WrappedSequence</span></span>(wrapping: <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) { iterator <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-comment"><span class="hljs-comment">//        ,      ,   ,        ,     . guard !endReached, let element = current ?? iterator.next() else { return nil } let next = iterator.next() let segment = (previous, element, next) //     ,    ,      : previous = element current = next endReached = (next == nil) return segment } } }</span></span></code> </pre> <br><p>  Maintenant, nous pouvons utiliser l'API ci-dessus pour cr√©er une version segment√©e de n'importe quelle s√©quence chaque fois que nous devons regarder en avant ou en arri√®re lors d'une it√©ration.  Par exemple, voici comment nous pouvons utiliser la segmentation afin que nous puissions facilement d√©terminer quand nous avons atteint la fin de la liste: </p><br><pre> <code class="plaintext hljs">for segment in list.items.segmented { addTopBorder() addView(for: segment.current) if segment.next == nil { //   ,     addBottomBorder() } } ```swift        ,   .    ,               : ```swift for segment in path.nodes.segmented { let directions = ( enter: segment.previous?.direction(to: segment.current), exit: segment.next.map(segment.current.direction) ) let nodeView = NodeView(directions: directions) nodeView.center = segment.current.position.cgPoint view.addSubview(nodeView) }</code> </pre> <br><p>  Nous commen√ßons maintenant √† voir la v√©ritable puissance des s√©quences d'encapsulation - en ce sens qu'elles nous permettent de masquer des algorithmes de plus en plus complexes dans une API vraiment simple.  Tout ce dont l'appelant a besoin pour segmenter la s√©quence, c'est acc√©der √† la propri√©t√© segment√©e dans n'importe quelle s√©quence, et notre impl√©mentation de base se chargera du reste. </p><br><h3 id="rekursiya">  R√©cursivit√© </h3><br><p>  Enfin, regardons comment m√™me les it√©rations r√©cursives peuvent √™tre mod√©lis√©es √† l'aide d'encapsuleurs de s√©quence.  Supposons que nous voulions fournir un moyen simple d'it√©rer r√©cursivement une hi√©rarchie de valeurs dans laquelle chaque √©l√©ment de la hi√©rarchie contient une s√©quence d'√©l√©ments enfants.  Il peut √™tre assez difficile de le faire correctement, donc ce serait g√©nial si nous pouvions utiliser une impl√©mentation pour effectuer toutes ces it√©rations dans notre base de code. <br>  En utilisant WrappedSequence, nous pouvons y parvenir en √©tendant Sequence avec une m√©thode qui utilise la m√™me contrainte de type g√©n√©rique pour garantir que chaque √©l√©ment peut fournir une s√©quence imbriqu√©e qui a le m√™me type d'it√©rateur que notre original.  Pour pouvoir acc√©der dynamiquement √† chaque s√©quence imbriqu√©e, nous demanderons √©galement √† l'appelant de sp√©cifier KeyPath pour la propri√©t√© qui doit √™tre utilis√©e pour la r√©cursivit√©, ce qui nous donnera une impl√©mentation qui ressemble √† ceci: </p><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extension</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Sequence</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">recursive</span></span></span><span class="hljs-function">&lt;S: Sequence&gt;</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">for</span></span></span></span><span class="hljs-function"><span class="hljs-params"> keyPath: KeyPath&lt;Element, S&gt; )</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">WrappedSequence</span></span>&lt;<span class="hljs-type"><span class="hljs-type">Self</span></span>, <span class="hljs-type"><span class="hljs-type">Element</span></span>&gt; <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> <span class="hljs-type"><span class="hljs-type">S</span></span>.<span class="hljs-type"><span class="hljs-type">Iterator</span></span> == <span class="hljs-type"><span class="hljs-type">Iterator</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> parentIterators = [<span class="hljs-type"><span class="hljs-type">Iterator</span></span>]() <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">moveUp</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> -&gt; (iterator: <span class="hljs-type"><span class="hljs-type">Iterator</span></span>, element: <span class="hljs-type"><span class="hljs-type">Element</span></span>)? { <span class="hljs-keyword"><span class="hljs-keyword">guard</span></span> !parentIterators.isEmpty <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> iterator = parentIterators.removeLast() <span class="hljs-keyword"><span class="hljs-keyword">guard</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> element = iterator.next() <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-comment"><span class="hljs-comment">//          ,    ,      : return moveUp() } return (iterator, element) } return WrappedSequence(wrapping: self) { iterator in //       ,      ,      : let element = iterator.next() ?? { return moveUp().map { iterator = $0 return $1 } }() //       ,  ,         ,         . if let nested = element?[keyPath: keyPath].makeIterator() { let parent = iterator parentIterators.append(parent) iterator = nested } return element } } }</span></span></code> </pre> <br><p>  En utilisant ce qui pr√©c√®de, nous pouvons maintenant it√©rer r√©cursivement sur n'importe quelle s√©quence, quelle que soit la fa√ßon dont elle est construite √† l'int√©rieur, et sans avoir √† charger la hi√©rarchie enti√®re √† l'avance.  Par exemple, voici comment nous pourrions utiliser cette nouvelle API pour parcourir r√©cursivement une hi√©rarchie de dossiers: </p><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> allFolders = folder.subfolders.recursive(<span class="hljs-keyword"><span class="hljs-keyword">for</span></span>: \.subfolders) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> folder <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> allFolders { <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> loadContent(from: folder) }</code> </pre> <br><p>  Nous pouvons √©galement l'utiliser pour it√©rer sur tous les n≈ìuds de l'arborescence ou pour parcourir r√©cursivement un ensemble d'enregistrements de base de donn√©es - par exemple, pour r√©pertorier tous les groupes d'utilisateurs dans une organisation: </p><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> allNodes = tree.recursive(<span class="hljs-keyword"><span class="hljs-keyword">for</span></span>: \.children) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> allGroups = database.groups.recusive(<span class="hljs-keyword"><span class="hljs-keyword">for</span></span>: \.subgroups)</code> </pre> <br><p>  Une chose que nous devons √™tre prudents lorsqu'il s'agit d'it√©rations r√©cursives est d'emp√™cher les r√©f√©rences circulaires - lorsqu'un certain chemin nous ram√®ne √† un √©l√©ment que nous avons d√©j√† rencontr√© - qui nous m√®nera √† une boucle infinie. <br>  Une fa√ßon de r√©soudre ce probl√®me est de garder une trace de tous les √©l√©ments qui se produisent (mais cela peut √™tre probl√©matique d'un point de vue m√©moire), de s'assurer qu'il n'y a pas de r√©f√©rences circulaires dans notre ensemble de donn√©es, ou de g√©rer de tels cas √† chaque fois du c√¥t√© de l'appel (en utilisant break, continue ou return pour terminer tout it√©rations cycliques). </p><br><h3 id="zaklyuchenie">  Conclusion </h3><br><p>  La s√©quence est l'un des protocoles les plus simples de la biblioth√®que standard - elle ne n√©cessite qu'une seule m√©thode - mais elle est toujours l'une des plus puissantes, en particulier en ce qui concerne la quantit√© de fonctionnalit√©s que nous pouvons cr√©er en fonction de celle-ci.  Tout comme la biblioth√®que standard contient des s√©quences d'encapsuleur pour des choses comme les √©num√©rations, nous pouvons √©galement cr√©er nos propres encapsuleurs - qui nous permettent de masquer des fonctionnalit√©s avanc√©es avec des API vraiment simples. </p><br><p>  Bien que les abstractions aient toujours un prix, il est important de consid√©rer quand cela vaut la peine (et peut-√™tre plus important encore quand elles n'en valent pas la peine) de les introduire, si nous pouvons construire nos abstractions directement en plus de ce que la biblioth√®que standard fournit - en utilisant les m√™mes conventions - alors ces les abstractions sont g√©n√©ralement plus susceptibles de r√©sister √† l'√©preuve du temps. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr464995/">https://habr.com/ru/post/fr464995/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr464985/index.html">L'Internet des objets (IoT) va changer le monde. L'avenir de l'IoT</a></li>
<li><a href="../fr464987/index.html">D√©p√¥ts √† Kubernetes: OpenEBS vs Rook (Ceph) vs Rancher Longhorn vs StorageOS vs Robin vs Portworx vs Linstor</a></li>
<li><a href="../fr464989/index.html">Contexte de l'extravagance</a></li>
<li><a href="../fr464991/index.html">Des projets qui n'ont pas d√©coll√©</a></li>
<li><a href="../fr464993/index.html">Construire un package RPM pour Rosa Linux en pratique</a></li>
<li><a href="../fr464997/index.html">√Ä propos du d√©veloppement des technologies VR: o√π les utilisent-elles, pourquoi les entreprises VR et quels appareils utilisent</a></li>
<li><a href="../fr464999/index.html">Comment les sp√©cificit√©s du travail avec les serveurs d'applications changent √† l'aide de l'exemple OpenLiberty</a></li>
<li><a href="../fr465001/index.html">Amazon Prime Day 2019 - Propuls√© par AWS</a></li>
<li><a href="../fr465003/index.html">Int√©r√™ts pour le genre ARPG</a></li>
<li><a href="../fr465007/index.html">V√©rification typographique de Django et DRF</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>