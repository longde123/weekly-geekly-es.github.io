<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🏂🏼 🏳️‍🌈 🚠 Bahaya desainer ☝🏼 👎🏻 ✊🏼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Halo, Habr! Saya mempersembahkan kepada Anda terjemahan artikel "Perils of Constructors" oleh Aleksey Kladov. 


 Salah satu posting blog Rust favorit...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Bahaya desainer</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/460831/"><p>  Halo, Habr!  Saya mempersembahkan kepada Anda terjemahan artikel "Perils of Constructors" oleh Aleksey Kladov. </p><br><p>  Salah satu posting blog Rust favorit saya adalah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Things Rust Shipped Without oleh Graydon Hoare</a> .  Bagi saya, kurangnya fitur dalam bahasa yang dapat menembak di kaki biasanya lebih penting daripada ekspresif.  Dalam esai yang sedikit filosofis ini, saya ingin berbicara tentang fitur favorit saya yang hilang dari Rust - tentang konstruktor. </p><br><h1 id="chto-takoe-konstruktor">  Apa itu konstruktor? </h1><br><p>  Konstruktor biasanya digunakan dalam bahasa OO.  Tugas konstruktor adalah menginisialisasi objek secara penuh sebelum seluruh dunia melihatnya.  Sekilas, ini sepertinya ide yang sangat bagus: </p><br><ol><li>  Anda <strong>mengatur invarian</strong> di konstruktor. </li><li>  Setiap metode menjaga <strong>konservasi</strong> invarian. </li><li>  Bersama-sama, kedua properti ini berarti bahwa Anda dapat menganggap objek sebagai invarian, dan bukan sebagai kondisi internal tertentu. </li></ol><br><p>  Konstruktor di sini memainkan peran sebagai basis induksi, menjadi satu-satunya cara untuk membuat objek baru. </p><br><p>  Sayangnya, ada lubang dalam argumen ini: perancang sendiri mengamati objek dalam keadaan yang belum selesai, yang menciptakan banyak masalah. <a name="habracut"></a></p><br><h1 id="znachenie-this">  Nilai ini </h1><br><p>  Ketika konstruktor menginisialisasi objek, itu dimulai dengan keadaan kosong.  Tetapi bagaimana Anda mendefinisikan keadaan kosong ini untuk objek yang arbitrer? </p><br><p>  Cara termudah untuk melakukan ini adalah dengan mengatur semua bidang ke nilai default: false untuk bool, 0 untuk angka, null untuk semua tautan.  Namun pendekatan ini mengharuskan semua jenis memiliki nilai default, dan memperkenalkan null yang terkenal ke dalam bahasa.  Ini adalah jalan yang diambil Java: pada awal penciptaan objek, semua bidang adalah 0 atau nol. </p><br><p>  Dengan pendekatan ini, akan sangat sulit untuk menghilangkan nol setelahnya.  Contoh yang baik untuk dipelajari adalah Kotlin.  Kotlin menggunakan tipe yang tidak dapat dibatalkan secara default, tetapi terpaksa bekerja dengan semantik JVM yang sudah ada.  Desain bahasanya menyembunyikan fakta ini dan bisa diterapkan dalam praktiknya, tetapi <strong>tidak</strong> bisa <strong>dipertahankan</strong> .  Dengan kata lain, menggunakan konstruktor, dimungkinkan untuk melewati pemeriksaan nol di Kotlin. </p><br><p>  Fitur utama Kotlin adalah dorongan untuk menciptakan apa yang disebut "konstruktor primer" yang <strong>secara bersamaan</strong> mendeklarasikan sebuah bidang dan memberikan nilai padanya sebelum kode kustom dijalankan: </p><br><pre><code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Person</span></span></span></span>( <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> firstName: String, <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> lastName: String ) { ... }</code> </pre> <br><p>  Pilihan lain: jika bidang tidak dinyatakan dalam konstruktor, programmer harus segera menginisialisasi: </p><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Person</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">val</span></span> firstName: String, <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> lastName: String) { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> fullName: String = <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$firstName</span></span></span><span class="hljs-string"> </span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$lastName</span></span></span><span class="hljs-string">"</span></span> }</code> </pre> <br><p>  Mencoba menggunakan bidang sebelum inisialisasi ditolak secara statis: </p><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Person</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">val</span></span> firstName: String, <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> lastName: String) { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> fullName: String <span class="hljs-keyword"><span class="hljs-keyword">init</span></span> { println(fullName) <span class="hljs-comment"><span class="hljs-comment">// :     fullName = "$firstName $lastName" } }</span></span></code> </pre> <br><p>  Tetapi dengan sedikit kreativitas, siapa pun dapat menghindari cek ini.  Misalnya, pemanggilan metode cocok untuk ini: </p><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> x: Any <span class="hljs-keyword"><span class="hljs-keyword">init</span></span> { observeNull() x = <span class="hljs-number"><span class="hljs-number">92</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">observeNull</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> = println(x) <span class="hljs-comment"><span class="hljs-comment">//  null } fun main() { A() }</span></span></code> </pre> <br><p>  Juga mengambil ini dengan lambda (yang dibuat di Kotlin sebagai berikut: {args -&gt; body}) juga cocok: </p><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">B</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> x: Any = { y }() <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> y: Any = x } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { println(B().x) <span class="hljs-comment"><span class="hljs-comment">//  null }</span></span></code> </pre> <br><p>  Contoh-contoh seperti ini tampak tidak realistis dalam kenyataan (dan memang demikian), tetapi saya menemukan kesalahan serupa dalam kode nyata (aturan probabilitas Kolmogorov 0-1 dalam pengembangan perangkat lunak: dalam basis data yang cukup besar, setiap bagian kode hampir dijamin ada, setidaknya jika tidak dilarang secara statis oleh kompiler; dalam hal ini, hampir pasti tidak ada). </p><br><p>  Alasan Kotlin mungkin ada dengan kegagalan ini sama dengan array kovarian di Jawa: pemeriksaan masih terjadi di runtime.  Pada akhirnya, saya tidak ingin menyulitkan sistem jenis Kotlin untuk membuat kasus-kasus di atas salah pada tahap kompilasi: mengingat keterbatasan yang ada (semantik JVM), rasio harga / manfaat validasi dalam runtime jauh lebih baik daripada yang statis. </p><br><p>  Tetapi bagaimana jika bahasa tersebut tidak memiliki nilai default yang masuk akal untuk setiap jenis?  Misalnya, dalam C ++, di mana tipe yang ditentukan pengguna tidak harus referensi, Anda tidak bisa hanya menetapkan null untuk setiap bidang dan mengatakan bahwa ini akan berhasil!  Alih-alih, C ++ menggunakan sintaks khusus untuk menetapkan nilai awal untuk bidang: daftar inisialisasi: </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;string&gt; #include &lt;utility&gt; class person { person(std::string first_name, std::string last_name) : first_name(std::move(first_name)) , last_name(std::move(last_name)) {} std::string first_name; std::string last_name; };</span></span></span></span></code> </pre> <br><p>  Karena ini adalah sintaks khusus, seluruh bahasa tidak berfungsi dengan sempurna.  Sebagai contoh, sulit untuk menempatkan operasi arbitrer ke dalam daftar inisialisasi, karena C ++ bukan bahasa yang berorientasi ekspresi (yang itu sendiri normal).  Untuk bekerja dengan pengecualian yang terjadi dalam daftar inisialisasi, Anda perlu menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">fitur lain dari bahasa tersebut</a> . </p><br><h1 id="vyzov-metodov-iz-konstruktora">  Metode Memanggil dari Konstruktor </h1><br><p>  Sebagai contoh dari Kotlin memberi petunjuk, semuanya hancur menjadi chip segera setelah kami mencoba memanggil metode dari konstruktor.  Pada dasarnya, metode berharap bahwa objek yang dapat diakses melalui ini sudah sepenuhnya dibangun dan benar (konsisten dengan invarian).  Tetapi di Kotlin atau Jawa, tidak ada yang mencegah Anda dari memanggil metode dari konstruktor, dan dengan cara ini kita dapat secara tidak sengaja beroperasi pada objek semi-konstruksi.  Perancang berjanji untuk membuat invarian, tetapi pada saat yang sama ini adalah tempat termudah untuk kemungkinan pelanggaran mereka. </p><br><p>  Terutama hal-hal aneh terjadi ketika konstruktor kelas dasar memanggil metode yang ditimpa dalam kelas turunan: </p><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">abstract</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Base</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">init</span></span> { initialize() } <span class="hljs-keyword"><span class="hljs-keyword">abstract</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">initialize</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Derived</span></span></span><span class="hljs-class">: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Base</span></span></span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> x: Any = <span class="hljs-number"><span class="hljs-number">92</span></span> <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">initialize</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> = println(x) <span class="hljs-comment"><span class="hljs-comment">//  null! }</span></span></code> </pre> <br><p>  Coba pikirkan: kode kelas arbitrer dieksekusi <strong>sebelum</strong> memanggil konstruktornya!  Kode C ++ yang serupa akan menghasilkan hasil yang lebih menarik.  Alih-alih memanggil fungsi kelas turunan, fungsi kelas dasar akan dipanggil.  Ini tidak masuk akal karena kelas turunan belum diinisialisasi (ingat, kita tidak bisa hanya mengatakan bahwa semua bidang adalah nol).  Namun, jika fungsi di kelas dasar adalah virtual murni, panggilannya akan mengarah ke UB. </p><br><h1 id="signatura-konstruktora">  Tanda Tangan Desainer </h1><br><p>  Pelanggaran invarian bukan satu-satunya masalah bagi desainer.  Mereka memiliki tanda tangan dengan nama tetap (kosong) dan tipe kembali (kelas itu sendiri).  Hal ini membuat kelebihan desain sulit untuk dipahami orang. </p><br><blockquote>  Mengisi pertanyaan: apa yang berhubungan dengan std :: vector &lt;int&gt; xs (92, 2)? <br><br>  a.  Vektor dua panjang 92 <br><br>  b.  [92, 92] <br><br>  c.  [92, 2] </blockquote><p>  Masalah dengan nilai pengembalian muncul, sebagai suatu peraturan, ketika tidak mungkin untuk membuat objek.  Anda tidak bisa hanya mengembalikan Hasil &lt;MyClass, io :: Error&gt; atau null dari konstruktor! </p><br><p>  Ini sering digunakan sebagai argumen yang mendukung fakta bahwa menggunakan C ++ tanpa pengecualian adalah sulit, dan bahwa menggunakan konstruktor juga memaksa Anda untuk menggunakan pengecualian.  Namun, saya tidak berpikir argumen ini benar: metode pabrik menyelesaikan kedua masalah ini, karena mereka dapat memiliki nama arbitrer dan mengembalikan tipe arbitrer.  Saya percaya bahwa pola berikut kadang-kadang dapat berguna dalam bahasa OO: </p><br><ul><li><p>  Buat satu konstruktor <strong>pribadi</strong> yang mengambil nilai-nilai semua bidang sebagai argumen dan hanya menetapkannya.  Dengan demikian, konstruktor seperti itu akan berfungsi sebagai struktur literal di Rust.  Itu juga dapat memeriksa setiap invarian, tetapi seharusnya tidak melakukan hal lain dengan argumen atau bidang. </p><br></li><li><p>  metode pabrik publik disediakan untuk API publik dengan nama dan tipe pengembalian yang sesuai. </p><br></li></ul><br><p>  Masalah serupa dengan konstruktor adalah konstruktornya spesifik dan karenanya tidak dapat digeneralisasi.  Dalam C ++, "ada konstruktor default" atau "ada konstruktor salin" tidak dapat diekspresikan lebih dari " <em>sintaks</em> tertentu".  Bandingkan ini dengan Rust, di mana konsep-konsep ini memiliki tanda tangan yang sesuai: </p><br><pre> <code class="rust hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">trait</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Default</span></span></span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">default</span></span></span></span>() -&gt; <span class="hljs-keyword"><span class="hljs-keyword">Self</span></span>; } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">trait</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Clone</span></span></span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">clone</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) -&gt; <span class="hljs-keyword"><span class="hljs-keyword">Self</span></span>; }</code> </pre> <br><h1 id="zhizn-bez-konstruktorov">  Hidup tanpa desainer </h1><br><p>  Karat hanya memiliki satu cara untuk membuat struktur: untuk memberikan nilai untuk semua bidang.  Fungsi pabrik, seperti baru yang diterima secara umum, memainkan peran konstruktor, tetapi, yang paling penting, mereka tidak memungkinkan Anda untuk memanggil metode apa pun sampai Anda memiliki setidaknya contoh bangunan yang kurang lebih benar. </p><br><p>  Kerugian dari pendekatan ini adalah bahwa kode apa pun dapat membuat struktur, sehingga tidak ada satu tempat, seperti konstruktor, untuk mempertahankan invarian.  Dalam praktiknya, ini mudah diselesaikan dengan privasi: jika bidang struktur bersifat pribadi, maka struktur ini hanya dapat dibuat dalam modul yang sama.  Dalam <em>satu</em> modul, tidak sulit untuk mematuhi perjanjian "semua metode membuat struktur harus menggunakan metode baru".  Anda bahkan dapat membayangkan ekstensi bahasa yang memungkinkan Anda menandai beberapa fungsi dengan atribut # [constructor], sehingga sintaks literal struktur hanya tersedia dalam fungsi yang ditandai.  Tetapi, sekali lagi, mekanisme linguistik tambahan tampak berlebihan bagi saya: mengikuti konvensi <strong>lokal</strong> membutuhkan sedikit usaha. </p><br><blockquote>  Secara pribadi, saya percaya bahwa kompromi ini terlihat persis sama untuk pemrograman kontrak secara umum.  Kontrak seperti "bukan nol" atau "nilai positif" paling baik dikodekan dalam jenis.  Untuk invarian yang kompleks, cukup tulis assert! (Self.validate ()) di setiap metode tidak begitu sulit.  Di antara kedua pola ini ada sedikit ruang untuk kondisi # [pra] dan # [pos] diimplementasikan pada tingkat bahasa atau berdasarkan makro. </blockquote><br><h1 id="a-chto-naschet-swift">  Bagaimana dengan Swift? </h1><br><p>  Swift adalah bahasa lain yang menarik yang patut dilihat di mekanisme desain.  Seperti Kotlin, Swift adalah bahasa aman nol.  Tidak seperti Kotlin, pemeriksaan nol Swift lebih kuat, jadi bahasa tersebut menggunakan trik menarik untuk mengurangi kerusakan yang disebabkan oleh konstruktor. </p><br><p>  <em>Pertama</em> , Swift menggunakan argumen bernama, dan sedikit membantu dengan "semua konstruktor memiliki nama yang sama."  Secara khusus, dua konstruktor dengan jenis parameter yang sama tidak menjadi masalah: </p><br><pre> <code class="swift hljs"><span class="hljs-type"><span class="hljs-type">Celsius</span></span>(fromFahrenheit: <span class="hljs-number"><span class="hljs-number">212.0</span></span>) <span class="hljs-type"><span class="hljs-type">Celsius</span></span>(fromKelvin: <span class="hljs-number"><span class="hljs-number">273.15</span></span>)</code> </pre> <br><p>  <em>Kedua</em> , untuk menyelesaikan masalah "konstruktor memanggil metode virtual kelas objek yang belum sepenuhnya dibuat" Swift menggunakan protokol inisialisasi dua fase yang dipikirkan dengan matang.  Meskipun tidak ada sintaks khusus untuk daftar inisialisasi, kompiler secara statis memeriksa bahwa tubuh konstruktor memiliki bentuk yang benar dan aman.  Sebagai contoh, metode memanggil hanya mungkin setelah semua bidang kelas dan turunannya diinisialisasi. </p><br><p>  <em>Ketiga</em> , di tingkat bahasa, ada dukungan untuk konstruktor, yang panggilannya mungkin gagal.  Konstruktor dapat ditetapkan sebagai nullable, yang menjadikan hasil memanggil kelas opsi.  Konstruktor juga dapat memiliki pengubah lemparan, yang berfungsi lebih baik dengan semantik inisialisasi dua fase di Swift daripada dengan sintaksis daftar inisialisasi di C ++. </p><br><p>  Swift berhasil menutup semua lubang di konstruktor yang saya keluhkan.  Ini, bagaimanapun, datang pada harga: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">bab inisialisasi adalah</a> salah satu yang terbesar dalam buku Swift. </p><br><h1 id="kogda-konstruktory-deystvitelno-neobhodimy">  Ketika konstruktor benar-benar dibutuhkan </h1><br><p>  Melawan segala rintangan, saya dapat memunculkan setidaknya dua alasan mengapa konstruktor tidak dapat diganti dengan struktur literal, seperti di Rust. </p><br><p>  <em>Pertama</em> , pewarisan, sampai taraf tertentu, memaksa bahasa untuk memiliki konstruktor.  Anda dapat membayangkan ekstensi sintaksis struktur dengan dukungan untuk kelas dasar: </p><br><pre> <code class="rust hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Base</span></span></span></span> { ... } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Derived</span></span></span></span>: Base { foo: <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> Derived { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">new</span></span></span></span>() -&gt; Derived { Derived { Base::new().., foo: <span class="hljs-number"><span class="hljs-number">92</span></span>, } } }</code> </pre> <br><p>  Tapi ini tidak akan bekerja dalam tata letak objek khas bahasa OO dengan warisan sederhana!  Biasanya, objek dimulai dengan judul yang diikuti oleh bidang kelas, dari pangkalan ke yang paling diturunkan.  Dengan demikian, awalan objek dari kelas turunan adalah objek yang benar dari kelas dasar.  Namun, agar tata letak seperti itu berfungsi, perancang harus mengalokasikan memori untuk seluruh objek sekaligus.  Itu tidak bisa hanya mengalokasikan memori hanya untuk kelas dasar, dan kemudian melampirkan bidang yang diturunkan.  Tetapi alokasi memori seperti itu diperlukan jika kita ingin menggunakan sintaks untuk membuat struktur di mana kita bisa menentukan nilai untuk kelas dasar. </p><br><p>  <em>Kedua</em> , tidak seperti sintaks literal struktur, konstruktor memiliki ABI yang berfungsi dengan baik dengan menempatkan objek subobjek dalam memori (ABI yang ramah penempatan).  Konstruktor bekerja dengan pointer ke ini, yang menunjuk ke area memori yang harus ditempati objek baru.  Yang paling penting, sebuah konstruktor dapat dengan mudah meneruskan pointer ke sub-objek konstruktor, sehingga memungkinkan penciptaan pohon nilai kompleks "pada tempatnya".  Sebaliknya, di Rust, membangun struktur secara semantik mencakup beberapa salinan, dan di sini kami berharap untuk rahmat pengoptimal.  Bukan kebetulan bahwa Rust belum memiliki proposal kerja yang diterima mengenai penempatan sub-proyek dalam memori! </p><br><p>  Pembaruan 1: memperbaiki kesalahan ketik.  Mengganti "tulis literal" dengan "struktur literal". </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id460831/">https://habr.com/ru/post/id460831/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id460819/index.html">WorldSkills: Ulasan dari peserta Olympiad</a></li>
<li><a href="../id460821/index.html">Intisari materi menarik untuk pengembang seluler # 307 (15-21 Juli)</a></li>
<li><a href="../id460823/index.html">Acara digital di Moskow dari 22 Juli hingga 28 Juli</a></li>
<li><a href="../id460825/index.html">Pengantar Screen Capture API - Memindai kode QR di browser</a></li>
<li><a href="../id460827/index.html">Masalah PGP</a></li>
<li><a href="../id460833/index.html">Fisika dan Ekonomi. Perbedaan gnoseologis dan manifestasinya dalam IT</a></li>
<li><a href="../id460837/index.html">Buku Pegangan Podcast Pemula</a></li>
<li><a href="../id460839/index.html">Peluncuran Predator - Repositori Data Terkompilasi</a></li>
<li><a href="../id460841/index.html">Aplikasi Pembelajaran Bahasa TOP-23</a></li>
<li><a href="../id460843/index.html">Memperkenalkan 3CX Call Flow Designer Baru dan Generator Template 3CX CRM</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>