<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🎐 👨‍🎓 👩🏼‍🤝‍👨🏿 Implementierung des neuen NTCP2-Transportprotokolls des I2P-Netzwerks 💹 👩🏾‍🤝‍👨🏼 🤚🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="I2P-Transportprotokolle wurden vor fast 15 Jahren entwickelt, als die Hauptaufgabe darin bestand, den Inhalt des Verkehrs zu verbergen und nicht die T...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Implementierung des neuen NTCP2-Transportprotokolls des I2P-Netzwerks</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/416785/">  I2P-Transportprotokolle wurden vor fast 15 Jahren entwickelt, als die Hauptaufgabe darin bestand, den Inhalt des Verkehrs zu verbergen und nicht die Tatsache, dass das eine oder andere Protokoll verwendet wurde.  DPI (Deep Packets Inspection) und Traffic Blocking wurden zu diesem Zeitpunkt nicht berücksichtigt.  Die Zeiten ändern sich jedoch, und obwohl die vorhandenen I2P-Protokolle immer noch recht gut geschützt sind, besteht Bedarf an einem neuen Transportprotokoll, das auf bestehende und zukünftige Bedrohungen reagiert, und vor allem an DPI, das die Paketlängen analysiert.  Darüber hinaus nutzt das neue Protokoll die neuesten Fortschritte in der Kryptografie.  Eine vollständige Beschreibung des Protokolls finden Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> .  Die Basis ist <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Noise</a> , in dem SHA256 als Hash-Funktion verwendet wird, und x25519 als DH (in der Noise-Terminologie). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/-j/jq/nz/-jjqnzbisqknquq286xng2djgla.png" alt="Bild"></div><a name="habracut"></a><br><h2>  Neue Kryptographie </h2><br>  Für NTCP2 müssen zusätzlich zu den bereits in I2P vorhandenen die folgenden kryptografischen Algorithmen implementiert werden: <br><br><ul><li>  x25519 </li><li>  HMAC-SHA256 </li><li> Chacha20 </li><li>  Poly1305 </li><li>  Aead </li><li>  Siphash </li></ul><br>  Mit Ausnahme von Siphash sind alle in openssl 1.1.0 implementiert.  Siphash wird wiederum in openssl 1.1.1 erscheinen, das in Kürze veröffentlicht wird.  Aus Gründen der Kompatibilität mit openssl 1.0.2, das in den meisten derzeit verwendeten Betriebssystemen enthalten ist, hat i2pd eigene Implementierungen hinzugefügt, die von einem der i2pd-Entwickler <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Jeff Becker geschrieben wurden</a> , der in ps als I ps bekannt ist. <br><br>  Im Vergleich zu NTCP ersetzt x25519 DH, AEAD / Chaha20 / Poly1305 ersetzt AES-256-CBC / Adler32 und Siphash wird zum Verschlüsseln der Länge der übertragenen Nachrichten verwendet.  Das Verfahren zur Berechnung des gemeinsam genutzten Schlüssels ist komplexer geworden: Mit vielen Aufrufen des HMAC-SHA256. <br><br><h2>  Änderungen an RouterInfo </h2><br>  Um mit dem NTCP2-Protokoll arbeiten zu können, wird zusätzlich zu den beiden vorhandenen Schlüsseln (Verschlüsselung und Signatur) ein dritter Schlüssel x25519 eingeführt, der als statischer Schlüssel bezeichnet wird und in einigen RouterInfo-Adressen als "s" -Parameter für Clients und Server vorhanden sein muss.  Wenn mehr als eine Adresse NTCP2 unterstützt, z. B. ipv4 und ipv6, muss "s" überall gleich sein.  Für Clients enthält die Adresse möglicherweise nur "s" und nicht die Parameter "host" und "port".  Der erforderliche Parameter von NTCP2 ist auch "v", derzeit immer gleich "2". <br><br>  Die NTCP2-Adresse kann als Adresse vom Typ „NTCP“ mit zusätzlichen Parametern festgelegt werden. In diesem Fall kann die Verbindung sowohl über NTCP als auch über NTCP2 oder als Adresse vom Typ NTCP2 hergestellt werden, die nur NTCP2-Verbindungen unterstützt.  In Java I2P wird die erste Methode verwendet, in i2pd die zweite. <br><br>  Wenn der Host eingehende NTCP2-Verbindungen akzeptiert, muss er den Parameter "i" mit dem Wert IV veröffentlichen, um den öffentlichen Schlüssel beim Herstellen der Verbindung zu verschlüsseln. <br><br><h2>  Stellen Sie eine Verbindung her </h2><br>  Beim Herstellen der Verbindung generieren die Parteien Paare von temporären Schlüsseln x25519, und basierend auf diesen und statischen Schlüsseln werden Schlüsselsätze zum Übertragen von Daten berechnet.  Es gibt auch die Authentifizierung statischer Schlüssel und die Einhaltung des Inhalts von RouterInfo. <br><br>  Die Parteien tauschen drei Nachrichten aus: <br><br>  SessionRequest -------------------&gt; <br>  &lt;- SessionCreated <br>  SessionConfirmed -----------------&gt; <br><br>  Für jeden von ihnen wird ein gemeinsamer Schlüssel x25519 berechnet, der als "Eingabeschlüsselmaterial" bezeichnet wird, und dann wird ein Nachrichtenverschlüsselungsschlüssel unter Verwendung der MixKey-Operation generiert, während der Wert ck (Verkettungsschlüssel) zwischen Nachrichten gespeichert wird und das Ergebnis ist, auf dessen Grundlage die Schlüssel für die Datenübertragung berechnet werden .  Die MixKey-Implementierung sieht ungefähr so ​​aus: <br><br><div class="spoiler">  <b class="spoiler_title">MixKey-Code</b> <div class="spoiler_text"><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> NTCP2Establisher::MixKey (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> * inputKeyMaterial, <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> * derived) { <span class="hljs-comment"><span class="hljs-comment">// temp_key = HMAC-SHA256(ck, input_key_material) uint8_t tempKey[32]; unsigned int len; HMAC(EVP_sha256(), m_CK, 32, inputKeyMaterial, 32, tempKey, &amp;len); // ck = HMAC-SHA256(temp_key, byte(0x01)) static uint8_t one[1] = { 1 }; HMAC(EVP_sha256(), tempKey, 32, one, 1, m_CK, &amp;len); // derived = HMAC-SHA256(temp_key, ck || byte(0x02)) m_CK[32] = 2; HMAC(EVP_sha256(), tempKey, 32, m_CK, 33, derived, &amp;len); }</span></span></code> </pre> <br></div></div><br>  <b>SessionRequest</b> besteht aus einem 32-Byte-öffentlichen Schlüssel x25519 des Clients und einem verschlüsselten AEAD / Chacha20 / Poly1305-16-Byte-Datenblock + 16-Byte-Hash sowie einem zufälligen Datensatz (Auffüllen), dessen Länge im verschlüsselten Block übertragen wird.  Dort wird auch die Länge der zweiten Hälfte der SessionConfirmed-Nachricht übertragen.  Der Block wird verschlüsselt und mit einem Schlüssel signiert, der auf dem temporären Schlüssel des Clients und dem statischen Schlüssel des Servers basiert.  Das anfängliche ck für MixKey ist auf SHA256 gesetzt ("Noise_XKaesobfse + hs2 + hs3_25519_ChaChaPoly_SHA256"). <br><br>  Da 32 Bytes des öffentlichen Schlüssels x25519 von dpi erkannt werden können, werden sie mit AES-256-CBC verschlüsselt, wobei der Schlüssel der Hash der Serveradresse ist und IV aus dem Parameter "i" der Adresse in RouterInfo entnommen wird. <br><br>  <b>Die</b> Struktur von SessionCreated ähnelt der von SessionRequest, mit der Ausnahme, dass der Schlüssel auf der Grundlage temporärer Schlüssel beider Parteien berechnet wird und IV als IV für die Verschlüsselung / Entschlüsselung des öffentlichen Schlüssels nach der Entschlüsselung / Verschlüsselung des öffentlichen Schlüssels aus SessionRequest verwendet wird. <br><br>  <b>SessionConfirmed</b> besteht aus zwei Teilen: dem statischen öffentlichen Schlüssel des Clients und der RouterInfo des Clients.  Im Gegensatz zu früheren Nachrichten wird der öffentliche Schlüssel mit AEAD / Chaha20 / Poly1305 mit demselben Schlüssel wie SessionCreated verschlüsselt.  Daher beträgt die Länge des ersten Teils nicht 32, sondern 48 Bytes.  Der zweite Teil ist ebenfalls mit AEAD / Chaha20 / Poly1305 verschlüsselt, aber mit einem neuen Schlüssel berechnen wir ihn basierend auf dem temporären Schlüssel des Servers und dem statischen Schlüssel des Clients.  RouterInfo kann auch ein Block zufälliger Daten hinzugefügt werden. Dies ist jedoch in der Regel nicht erforderlich, da die Länge von RouterInfo unterschiedlich ist. <br><br><h2>  Schlüsselgenerierung für die Datenübertragung </h2><br>  Wenn alle Überprüfungen von Hashes und Schlüsseln während des Verbindungsaufbaus erfolgreich waren, sollte nach dem letzten MixKey auf beiden Seiten derselbe ck vorhanden sein, aus dem auf jeder Seite 2 Sätze von Dreifachschlüsseln &lt;k, sipk, sipiv&gt; generiert werden, wobei k der AEAD-Schlüssel ist / Chaha20 / Poly1305, sipk ist der Schlüssel für Siphash, sipiv ist der anfängliche IV-Wert für Siphash, der sich nach jeder Anwendung ändert. <br><br><div class="spoiler">  <b class="spoiler_title">Code zum Generieren von Schlüsseln</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> NTCP2Session::KeyDerivationFunctionDataPhase () { <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> tempKey[<span class="hljs-number"><span class="hljs-number">32</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> len; <span class="hljs-comment"><span class="hljs-comment">// temp_key = HMAC-SHA256(ck, zerolen) HMAC(EVP_sha256(), m_Establisher-&gt;GetCK (), 32, nullptr, 0, tempKey, &amp;len); static uint8_t one[1] = { 1 }; // k_ab = HMAC-SHA256(temp_key, byte(0x01)). HMAC(EVP_sha256(), tempKey, 32, one, 1, m_Kab, &amp;len); m_Kab[32] = 2; // k_ba = HMAC-SHA256(temp_key, k_ab || byte(0x02)) HMAC(EVP_sha256(), tempKey, 32, m_Kab, 33, m_Kba, &amp;len); static uint8_t ask[4] = { 'a', 's', 'k', 1 }, master[32]; // ask_master = HMAC-SHA256(temp_key, "ask" || byte(0x01)) HMAC(EVP_sha256(), tempKey, 32, ask, 4, master, &amp;len); uint8_t h[39]; memcpy (h, m_Establisher-&gt;GetH (), 32); memcpy (h + 32, "siphash", 7); // temp_key = HMAC-SHA256(ask_master, h || "siphash") HMAC(EVP_sha256(), master, 32, h, 39, tempKey, &amp;len); // sip_master = HMAC-SHA256(temp_key, byte(0x01)) HMAC(EVP_sha256(), tempKey, 32, one, 1, master, &amp;len); // temp_key = HMAC-SHA256(sip_master, zerolen) HMAC(EVP_sha256(), master, 32, nullptr, 0, tempKey, &amp;len); // sipkeys_ab = HMAC-SHA256(temp_key, byte(0x01)). HMAC(EVP_sha256(), tempKey, 32, one, 1, m_Sipkeysab, &amp;len); m_Sipkeysab[32] = 2; // sipkeys_ba = HMAC-SHA256(temp_key, sipkeys_ab || byte(0x02)) HMAC(EVP_sha256(), tempKey, 32, m_Sipkeysab, 33, m_Sipkeysba, &amp;len); }</span></span></code> </pre><br></div></div><br>  Die ersten 16 Bytes des Sipkeys-Arrays sind der Siphash-Schlüssel, die zweiten 8 Bytes sind IV. <br>  Tatsächlich benötigt Siphash zwei Schlüssel mit jeweils 8 Bytes, aber in i2pd werden sie als 1 Schlüssel mit einer Länge von 16 Bytes betrachtet. <br><br><h2>  Datenübertragung </h2><br>  Daten werden in Frames übertragen, jeder Frame besteht aus 3 Teilen: <br><br><ol><li>  2 Bytes Frame-Länge, verschlüsselt von Siphash </li><li>  Daten von Chacha20 verschlüsselt </li><li>  16 Bytes Poly1305-Hash </li></ol><br>  Die maximale Länge der übertragenen Daten in einem Frame beträgt 65519 Bytes. <br><br>  Die Nachrichtenlänge wird mithilfe der XOR-Operation mit den ersten zwei Bytes des aktuellen IV-Siphash verschlüsselt. <br><br>  Daten bestehen aus Blöcken. Vor jedem Block befindet sich ein 3-Byte-Header mit Blocktyp und -länge.  Grundsätzlich werden I2NP-Blöcke übertragen, die I2NP-Nachrichten mit einem modifizierten Header enthalten.  In einem Frame können mehrere I2NP-Blöcke übertragen werden. <br><br>  Ein weiterer wichtiger Blocktyp ist ein zufälliger Datenblock, der jedem Frame hinzugefügt werden sollte.  Es kann nur einer und der letzte sein. <br><br>  Darüber hinaus gibt es in der aktuellen Implementierung von NTCP2 drei weitere Blocktypen: <br><br><ul><li>  RouterInfo - Enthält normalerweise den RouterInfo-Server unmittelbar nach dem Herstellen der Verbindung. RouterInfo eines beliebigen Knotens kann jedoch jederzeit übertragen werden, um die Arbeit von Floodfills zu beschleunigen, für die das Flag-Feld in der Nachricht angegeben ist. </li><li>  Beendigung - wird vom Knoten gesendet, wenn die Verbindung von sich aus unterbrochen wird, und gibt den Grund an. </li><li>  DateTime - aktuelle Uhrzeit in Sekunden. </li></ul><br>  Somit ermöglicht das neue Transportprotokoll nicht nur, DPI effektiv zu widerstehen, sondern reduziert auch die CPU-Last aufgrund einer moderneren und schnelleren Kryptografie erheblich, was besonders wichtig ist, wenn an schwachen Geräten wie Smartphones und Routern gearbeitet wird.  Derzeit ist die NTCP2-Unterstützung sowohl in offiziellem I2P als auch in i2pd vollständig implementiert und wird in den nächsten Versionen 0.9.36 bzw. 2.20 offiziell erscheinen.  Um ntcp2 in i2pd zu aktivieren, geben Sie den Konfigurationsparameter ntcp2.enabled = true und ntcp2.published = true und ntcp2.port = &lt;port&gt; für eingehende Verbindungen an. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de416785/">https://habr.com/ru/post/de416785/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de416767/index.html">Ein Deuce für Sie oder ein Audit mit Hacking</a></li>
<li><a href="../de416775/index.html">Noch ein Papercraft</a></li>
<li><a href="../de416777/index.html">Das Funktionsprinzip des Faltungsnetzwerks. Fast kompliziert</a></li>
<li><a href="../de416781/index.html">Wer wird die Relativitätstheorie retten?</a></li>
<li><a href="../de416783/index.html">Wie wird die Dezentralisierungsrevolution die Weltwirtschaft verändern?</a></li>
<li><a href="../de416787/index.html">Zabbix: Überwachung des Festplattenspeichers DELL MD36XX</a></li>
<li><a href="../de416791/index.html">Bericht des Club of Rome 2018, Kapitel 3.3: Blaue Wirtschaft</a></li>
<li><a href="../de416793/index.html">Bericht des Club of Rome 2018, Kapitel 3.12: „Reformen des Wirtschaftssystems“</a></li>
<li><a href="../de416795/index.html">Bericht des Club of Rome 2018, Kapitel 3.17: „Nationale Aktionen: China und Bhutan“</a></li>
<li><a href="../de416797/index.html">Bericht des Club of Rome 2018, Kapitel 3.1: „Regenerative Ökonomie“</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>