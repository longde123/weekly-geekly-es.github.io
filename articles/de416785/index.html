<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üéê üë®‚Äçüéì üë©üèº‚Äçü§ù‚Äçüë®üèø Implementierung des neuen NTCP2-Transportprotokolls des I2P-Netzwerks üíπ üë©üèæ‚Äçü§ù‚Äçüë®üèº ü§öüèª</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="I2P-Transportprotokolle wurden vor fast 15 Jahren entwickelt, als die Hauptaufgabe darin bestand, den Inhalt des Verkehrs zu verbergen und nicht die T...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Implementierung des neuen NTCP2-Transportprotokolls des I2P-Netzwerks</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/416785/">  I2P-Transportprotokolle wurden vor fast 15 Jahren entwickelt, als die Hauptaufgabe darin bestand, den Inhalt des Verkehrs zu verbergen und nicht die Tatsache, dass das eine oder andere Protokoll verwendet wurde.  DPI (Deep Packets Inspection) und Traffic Blocking wurden zu diesem Zeitpunkt nicht ber√ºcksichtigt.  Die Zeiten √§ndern sich jedoch, und obwohl die vorhandenen I2P-Protokolle immer noch recht gut gesch√ºtzt sind, besteht Bedarf an einem neuen Transportprotokoll, das auf bestehende und zuk√ºnftige Bedrohungen reagiert, und vor allem an DPI, das die Paketl√§ngen analysiert.  Dar√ºber hinaus nutzt das neue Protokoll die neuesten Fortschritte in der Kryptografie.  Eine vollst√§ndige Beschreibung des Protokolls finden Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> .  Die Basis ist <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Noise</a> , in dem SHA256 als Hash-Funktion verwendet wird, und x25519 als DH (in der Noise-Terminologie). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/-j/jq/nz/-jjqnzbisqknquq286xng2djgla.png" alt="Bild"></div><a name="habracut"></a><br><h2>  Neue Kryptographie </h2><br>  F√ºr NTCP2 m√ºssen zus√§tzlich zu den bereits in I2P vorhandenen die folgenden kryptografischen Algorithmen implementiert werden: <br><br><ul><li>  x25519 </li><li>  HMAC-SHA256 </li><li> Chacha20 </li><li>  Poly1305 </li><li>  Aead </li><li>  Siphash </li></ul><br>  Mit Ausnahme von Siphash sind alle in openssl 1.1.0 implementiert.  Siphash wird wiederum in openssl 1.1.1 erscheinen, das in K√ºrze ver√∂ffentlicht wird.  Aus Gr√ºnden der Kompatibilit√§t mit openssl 1.0.2, das in den meisten derzeit verwendeten Betriebssystemen enthalten ist, hat i2pd eigene Implementierungen hinzugef√ºgt, die von einem der i2pd-Entwickler <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Jeff Becker geschrieben wurden</a> , der in ps als I ps bekannt ist. <br><br>  Im Vergleich zu NTCP ersetzt x25519 DH, AEAD / Chaha20 / Poly1305 ersetzt AES-256-CBC / Adler32 und Siphash wird zum Verschl√ºsseln der L√§nge der √ºbertragenen Nachrichten verwendet.  Das Verfahren zur Berechnung des gemeinsam genutzten Schl√ºssels ist komplexer geworden: Mit vielen Aufrufen des HMAC-SHA256. <br><br><h2>  √Ñnderungen an RouterInfo </h2><br>  Um mit dem NTCP2-Protokoll arbeiten zu k√∂nnen, wird zus√§tzlich zu den beiden vorhandenen Schl√ºsseln (Verschl√ºsselung und Signatur) ein dritter Schl√ºssel x25519 eingef√ºhrt, der als statischer Schl√ºssel bezeichnet wird und in einigen RouterInfo-Adressen als "s" -Parameter f√ºr Clients und Server vorhanden sein muss.  Wenn mehr als eine Adresse NTCP2 unterst√ºtzt, z. B. ipv4 und ipv6, muss "s" √ºberall gleich sein.  F√ºr Clients enth√§lt die Adresse m√∂glicherweise nur "s" und nicht die Parameter "host" und "port".  Der erforderliche Parameter von NTCP2 ist auch "v", derzeit immer gleich "2". <br><br>  Die NTCP2-Adresse kann als Adresse vom Typ ‚ÄûNTCP‚Äú mit zus√§tzlichen Parametern festgelegt werden. In diesem Fall kann die Verbindung sowohl √ºber NTCP als auch √ºber NTCP2 oder als Adresse vom Typ NTCP2 hergestellt werden, die nur NTCP2-Verbindungen unterst√ºtzt.  In Java I2P wird die erste Methode verwendet, in i2pd die zweite. <br><br>  Wenn der Host eingehende NTCP2-Verbindungen akzeptiert, muss er den Parameter "i" mit dem Wert IV ver√∂ffentlichen, um den √∂ffentlichen Schl√ºssel beim Herstellen der Verbindung zu verschl√ºsseln. <br><br><h2>  Stellen Sie eine Verbindung her </h2><br>  Beim Herstellen der Verbindung generieren die Parteien Paare von tempor√§ren Schl√ºsseln x25519, und basierend auf diesen und statischen Schl√ºsseln werden Schl√ºssels√§tze zum √úbertragen von Daten berechnet.  Es gibt auch die Authentifizierung statischer Schl√ºssel und die Einhaltung des Inhalts von RouterInfo. <br><br>  Die Parteien tauschen drei Nachrichten aus: <br><br>  SessionRequest -------------------&gt; <br>  &lt;- SessionCreated <br>  SessionConfirmed -----------------&gt; <br><br>  F√ºr jeden von ihnen wird ein gemeinsamer Schl√ºssel x25519 berechnet, der als "Eingabeschl√ºsselmaterial" bezeichnet wird, und dann wird ein Nachrichtenverschl√ºsselungsschl√ºssel unter Verwendung der MixKey-Operation generiert, w√§hrend der Wert ck (Verkettungsschl√ºssel) zwischen Nachrichten gespeichert wird und das Ergebnis ist, auf dessen Grundlage die Schl√ºssel f√ºr die Daten√ºbertragung berechnet werden .  Die MixKey-Implementierung sieht ungef√§hr so ‚Äã‚Äãaus: <br><br><div class="spoiler">  <b class="spoiler_title">MixKey-Code</b> <div class="spoiler_text"><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> NTCP2Establisher::MixKey (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> * inputKeyMaterial, <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> * derived) { <span class="hljs-comment"><span class="hljs-comment">// temp_key = HMAC-SHA256(ck, input_key_material) uint8_t tempKey[32]; unsigned int len; HMAC(EVP_sha256(), m_CK, 32, inputKeyMaterial, 32, tempKey, &amp;len); // ck = HMAC-SHA256(temp_key, byte(0x01)) static uint8_t one[1] = { 1 }; HMAC(EVP_sha256(), tempKey, 32, one, 1, m_CK, &amp;len); // derived = HMAC-SHA256(temp_key, ck || byte(0x02)) m_CK[32] = 2; HMAC(EVP_sha256(), tempKey, 32, m_CK, 33, derived, &amp;len); }</span></span></code> </pre> <br></div></div><br>  <b>SessionRequest</b> besteht aus einem 32-Byte-√∂ffentlichen Schl√ºssel x25519 des Clients und einem verschl√ºsselten AEAD / Chacha20 / Poly1305-16-Byte-Datenblock + 16-Byte-Hash sowie einem zuf√§lligen Datensatz (Auff√ºllen), dessen L√§nge im verschl√ºsselten Block √ºbertragen wird.  Dort wird auch die L√§nge der zweiten H√§lfte der SessionConfirmed-Nachricht √ºbertragen.  Der Block wird verschl√ºsselt und mit einem Schl√ºssel signiert, der auf dem tempor√§ren Schl√ºssel des Clients und dem statischen Schl√ºssel des Servers basiert.  Das anf√§ngliche ck f√ºr MixKey ist auf SHA256 gesetzt ("Noise_XKaesobfse + hs2 + hs3_25519_ChaChaPoly_SHA256"). <br><br>  Da 32 Bytes des √∂ffentlichen Schl√ºssels x25519 von dpi erkannt werden k√∂nnen, werden sie mit AES-256-CBC verschl√ºsselt, wobei der Schl√ºssel der Hash der Serveradresse ist und IV aus dem Parameter "i" der Adresse in RouterInfo entnommen wird. <br><br>  <b>Die</b> Struktur von SessionCreated √§hnelt der von SessionRequest, mit der Ausnahme, dass der Schl√ºssel auf der Grundlage tempor√§rer Schl√ºssel beider Parteien berechnet wird und IV als IV f√ºr die Verschl√ºsselung / Entschl√ºsselung des √∂ffentlichen Schl√ºssels nach der Entschl√ºsselung / Verschl√ºsselung des √∂ffentlichen Schl√ºssels aus SessionRequest verwendet wird. <br><br>  <b>SessionConfirmed</b> besteht aus zwei Teilen: dem statischen √∂ffentlichen Schl√ºssel des Clients und der RouterInfo des Clients.  Im Gegensatz zu fr√ºheren Nachrichten wird der √∂ffentliche Schl√ºssel mit AEAD / Chaha20 / Poly1305 mit demselben Schl√ºssel wie SessionCreated verschl√ºsselt.  Daher betr√§gt die L√§nge des ersten Teils nicht 32, sondern 48 Bytes.  Der zweite Teil ist ebenfalls mit AEAD / Chaha20 / Poly1305 verschl√ºsselt, aber mit einem neuen Schl√ºssel berechnen wir ihn basierend auf dem tempor√§ren Schl√ºssel des Servers und dem statischen Schl√ºssel des Clients.  RouterInfo kann auch ein Block zuf√§lliger Daten hinzugef√ºgt werden. Dies ist jedoch in der Regel nicht erforderlich, da die L√§nge von RouterInfo unterschiedlich ist. <br><br><h2>  Schl√ºsselgenerierung f√ºr die Daten√ºbertragung </h2><br>  Wenn alle √úberpr√ºfungen von Hashes und Schl√ºsseln w√§hrend des Verbindungsaufbaus erfolgreich waren, sollte nach dem letzten MixKey auf beiden Seiten derselbe ck vorhanden sein, aus dem auf jeder Seite 2 S√§tze von Dreifachschl√ºsseln &lt;k, sipk, sipiv&gt; generiert werden, wobei k der AEAD-Schl√ºssel ist / Chaha20 / Poly1305, sipk ist der Schl√ºssel f√ºr Siphash, sipiv ist der anf√§ngliche IV-Wert f√ºr Siphash, der sich nach jeder Anwendung √§ndert. <br><br><div class="spoiler">  <b class="spoiler_title">Code zum Generieren von Schl√ºsseln</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> NTCP2Session::KeyDerivationFunctionDataPhase () { <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> tempKey[<span class="hljs-number"><span class="hljs-number">32</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> len; <span class="hljs-comment"><span class="hljs-comment">// temp_key = HMAC-SHA256(ck, zerolen) HMAC(EVP_sha256(), m_Establisher-&gt;GetCK (), 32, nullptr, 0, tempKey, &amp;len); static uint8_t one[1] = { 1 }; // k_ab = HMAC-SHA256(temp_key, byte(0x01)). HMAC(EVP_sha256(), tempKey, 32, one, 1, m_Kab, &amp;len); m_Kab[32] = 2; // k_ba = HMAC-SHA256(temp_key, k_ab || byte(0x02)) HMAC(EVP_sha256(), tempKey, 32, m_Kab, 33, m_Kba, &amp;len); static uint8_t ask[4] = { 'a', 's', 'k', 1 }, master[32]; // ask_master = HMAC-SHA256(temp_key, "ask" || byte(0x01)) HMAC(EVP_sha256(), tempKey, 32, ask, 4, master, &amp;len); uint8_t h[39]; memcpy (h, m_Establisher-&gt;GetH (), 32); memcpy (h + 32, "siphash", 7); // temp_key = HMAC-SHA256(ask_master, h || "siphash") HMAC(EVP_sha256(), master, 32, h, 39, tempKey, &amp;len); // sip_master = HMAC-SHA256(temp_key, byte(0x01)) HMAC(EVP_sha256(), tempKey, 32, one, 1, master, &amp;len); // temp_key = HMAC-SHA256(sip_master, zerolen) HMAC(EVP_sha256(), master, 32, nullptr, 0, tempKey, &amp;len); // sipkeys_ab = HMAC-SHA256(temp_key, byte(0x01)). HMAC(EVP_sha256(), tempKey, 32, one, 1, m_Sipkeysab, &amp;len); m_Sipkeysab[32] = 2; // sipkeys_ba = HMAC-SHA256(temp_key, sipkeys_ab || byte(0x02)) HMAC(EVP_sha256(), tempKey, 32, m_Sipkeysab, 33, m_Sipkeysba, &amp;len); }</span></span></code> </pre><br></div></div><br>  Die ersten 16 Bytes des Sipkeys-Arrays sind der Siphash-Schl√ºssel, die zweiten 8 Bytes sind IV. <br>  Tats√§chlich ben√∂tigt Siphash zwei Schl√ºssel mit jeweils 8 Bytes, aber in i2pd werden sie als 1 Schl√ºssel mit einer L√§nge von 16 Bytes betrachtet. <br><br><h2>  Daten√ºbertragung </h2><br>  Daten werden in Frames √ºbertragen, jeder Frame besteht aus 3 Teilen: <br><br><ol><li>  2 Bytes Frame-L√§nge, verschl√ºsselt von Siphash </li><li>  Daten von Chacha20 verschl√ºsselt </li><li>  16 Bytes Poly1305-Hash </li></ol><br>  Die maximale L√§nge der √ºbertragenen Daten in einem Frame betr√§gt 65519 Bytes. <br><br>  Die Nachrichtenl√§nge wird mithilfe der XOR-Operation mit den ersten zwei Bytes des aktuellen IV-Siphash verschl√ºsselt. <br><br>  Daten bestehen aus Bl√∂cken. Vor jedem Block befindet sich ein 3-Byte-Header mit Blocktyp und -l√§nge.  Grunds√§tzlich werden I2NP-Bl√∂cke √ºbertragen, die I2NP-Nachrichten mit einem modifizierten Header enthalten.  In einem Frame k√∂nnen mehrere I2NP-Bl√∂cke √ºbertragen werden. <br><br>  Ein weiterer wichtiger Blocktyp ist ein zuf√§lliger Datenblock, der jedem Frame hinzugef√ºgt werden sollte.  Es kann nur einer und der letzte sein. <br><br>  Dar√ºber hinaus gibt es in der aktuellen Implementierung von NTCP2 drei weitere Blocktypen: <br><br><ul><li>  RouterInfo - Enth√§lt normalerweise den RouterInfo-Server unmittelbar nach dem Herstellen der Verbindung. RouterInfo eines beliebigen Knotens kann jedoch jederzeit √ºbertragen werden, um die Arbeit von Floodfills zu beschleunigen, f√ºr die das Flag-Feld in der Nachricht angegeben ist. </li><li>  Beendigung - wird vom Knoten gesendet, wenn die Verbindung von sich aus unterbrochen wird, und gibt den Grund an. </li><li>  DateTime - aktuelle Uhrzeit in Sekunden. </li></ul><br>  Somit erm√∂glicht das neue Transportprotokoll nicht nur, DPI effektiv zu widerstehen, sondern reduziert auch die CPU-Last aufgrund einer moderneren und schnelleren Kryptografie erheblich, was besonders wichtig ist, wenn an schwachen Ger√§ten wie Smartphones und Routern gearbeitet wird.  Derzeit ist die NTCP2-Unterst√ºtzung sowohl in offiziellem I2P als auch in i2pd vollst√§ndig implementiert und wird in den n√§chsten Versionen 0.9.36 bzw. 2.20 offiziell erscheinen.  Um ntcp2 in i2pd zu aktivieren, geben Sie den Konfigurationsparameter ntcp2.enabled = true und ntcp2.published = true und ntcp2.port = &lt;port&gt; f√ºr eingehende Verbindungen an. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de416785/">https://habr.com/ru/post/de416785/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de416767/index.html">Ein Deuce f√ºr Sie oder ein Audit mit Hacking</a></li>
<li><a href="../de416775/index.html">Noch ein Papercraft</a></li>
<li><a href="../de416777/index.html">Das Funktionsprinzip des Faltungsnetzwerks. Fast kompliziert</a></li>
<li><a href="../de416781/index.html">Wer wird die Relativit√§tstheorie retten?</a></li>
<li><a href="../de416783/index.html">Wie wird die Dezentralisierungsrevolution die Weltwirtschaft ver√§ndern?</a></li>
<li><a href="../de416787/index.html">Zabbix: √úberwachung des Festplattenspeichers DELL MD36XX</a></li>
<li><a href="../de416791/index.html">Bericht des Club of Rome 2018, Kapitel 3.3: Blaue Wirtschaft</a></li>
<li><a href="../de416793/index.html">Bericht des Club of Rome 2018, Kapitel 3.12: ‚ÄûReformen des Wirtschaftssystems‚Äú</a></li>
<li><a href="../de416795/index.html">Bericht des Club of Rome 2018, Kapitel 3.17: ‚ÄûNationale Aktionen: China und Bhutan‚Äú</a></li>
<li><a href="../de416797/index.html">Bericht des Club of Rome 2018, Kapitel 3.1: ‚ÄûRegenerative √ñkonomie‚Äú</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>