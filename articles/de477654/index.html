<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>📏 👨🏿‍✈️ 🈸 Probieren Sie den verbesserten instanceof-Operator in Java 14 aus 😄 👨🏾 ⛑️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Nicht weit entfernt ist die neue, 14. Version von Java, was bedeutet, dass es Zeit ist zu sehen, welche neuen Syntaxfunktionen diese Version von Java ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Probieren Sie den verbesserten instanceof-Operator in Java 14 aus</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/477654/"> Nicht weit entfernt ist die neue, <a href="http://openjdk.java.net/projects/jdk/14/">14. Version von</a> Java, was bedeutet, dass es Zeit ist zu sehen, welche neuen Syntaxfunktionen diese Version von Java enthalten wird.  Eine dieser syntaktischen Möglichkeiten ist der <a href="https://openjdk.java.net/jeps/305">Mustervergleich des Typs</a> , der unter Verwendung der verbesserten (erweiterten) <code>instanceof</code> Operators implementiert wird. <br><br>  Heute möchte ich mit diesem neuen Operator herumspielen und die Funktionen seiner Arbeit detaillierter betrachten.  Da die Mustererkennung nach Typ noch nicht im Haupt-JDK-Repository vorhanden ist, musste ich das Repository <a href="https://openjdk.java.net/projects/amber/">des Amber-Projekts</a> herunterladen, das neue Java-Syntaxkonstrukte entwickelt, und <a href="https://builds.shipilev.net/workspaces/">das JDK</a> aus diesem Repository <a href="https://builds.shipilev.net/workspaces/">kompilieren</a> . <br><a name="habracut"></a><br>  Als erstes überprüfen wir die Java-Version, um sicherzustellen, dass wir wirklich JDK 14 verwenden: <br><br><pre> <code class="bash hljs">&gt; java -version openjdk version <span class="hljs-string"><span class="hljs-string">"14-internal"</span></span> 2020-03-17 OpenJDK Runtime Environment (build 14-internal+0-adhoc.osboxes.amber-amber) OpenJDK 64-Bit Server VM (build 14-internal+0-adhoc.osboxes.amber-amber, mixed mode, sharing)</code> </pre> <br>  Alles ist richtig. <br><br>  Jetzt schreiben wir ein kleines Stück Code mit der "alten" <code>instanceof</code> Operators und führen es aus: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String[] args)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> A().f(<span class="hljs-string"><span class="hljs-string">"Hello, world!"</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Object obj)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (obj <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> String) { String str = (String) obj; System.out.println(str.toLowerCase()); } } }</code> </pre> <br><pre> <code class="bash hljs">&gt; java A.java hello, world!</code> </pre> <br>  Es funktioniert  Dies ist eine Standardtypprüfung, gefolgt von einer Besetzung.  Wir schreiben jeden Tag ähnliche Konstruktionen, egal welche Java-Version wir verwenden, mindestens 1.0, mindestens 13. <br>  Aber jetzt haben wir Java 14 in unseren Händen und schreiben den Code mit der verbesserten <code>instanceof</code> Operators neu (ich werde in Zukunft darauf verzichten, Codezeilen zu wiederholen): <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (obj <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> String str) { System.out.println(str.toLowerCase()); }</code> </pre> <br><pre> <code class="bash hljs">&gt; java --<span class="hljs-built_in"><span class="hljs-built_in">enable</span></span>-preview --<span class="hljs-built_in"><span class="hljs-built_in">source</span></span> 14 A.java hello, world!</code> </pre> <br>  Großartig.  Der Code ist sauberer, kürzer, sicherer und lesbarer.  Es gab drei Wiederholungen des Wortes String, eine wurde.  Beachten Sie, dass wir nicht vergessen haben, die Argumente <code>--enable-preview --source 14</code> , as anzugeben  Der neue Operator ist eine <a href="https://openjdk.java.net/jeps/12">Vorschaufunktion</a> .  Darüber hinaus hat ein aufmerksamer Leser wahrscheinlich bemerkt, dass wir die A.java-Quelldatei direkt ohne Kompilierung ausgeführt haben.  Diese Funktion <a href="https://openjdk.java.net/jeps/330">erschien</a> in Java 11. <br><br>  Versuchen wir, etwas komplexeres zu schreiben und fügen eine zweite Bedingung hinzu, die die gerade deklarierte Variable verwendet: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (obj <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> String str &amp;&amp; str.length() &gt; <span class="hljs-number"><span class="hljs-number">5</span></span>) { System.out.println(str.toLowerCase()); }</code> </pre> <br>  Es kompiliert und funktioniert.  Aber was ist, wenn Sie die Bedingungen tauschen? <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (str.length() &gt; <span class="hljs-number"><span class="hljs-number">5</span></span> &amp;&amp; obj <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> String str) { System.out.println(str.toLowerCase()); }</code> </pre> <br><pre> <code class="bash hljs">A.java:7: error: cannot find symbol <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (str.length() &gt; 5 &amp;&amp; obj instanceof String str) { ^</code> </pre> <br>  Kompilierungsfehler.  Was zu erwarten ist: Die Variable <code>str</code> wurde noch nicht deklariert, kann also nicht verwendet werden. <br><br>  Was ist übrigens mit der Veränderlichkeit?  Ist die Variable final oder nicht?  Wir versuchen: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (obj <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> String str) { str = <span class="hljs-string"><span class="hljs-string">"World, hello!"</span></span>; System.out.println(str.toLowerCase()); }</code> </pre> <br><pre> <code class="bash hljs">A.java:8: error: pattern binding str may not be assigned str = <span class="hljs-string"><span class="hljs-string">"World, hello!"</span></span>; ^</code> </pre> <br>  Ja, die letzte Variable.  Dies bedeutet, dass das Wort „Variable“ hier nicht ganz richtig ist.  Und der Compiler verwendet den Spezialbegriff "Musterbindung".  Daher schlage ich von nun an vor, nicht "variabel", sondern "Musterbindung" zu sagen (das Wort "Bindung" ist leider nicht sehr gut ins Russische übersetzt). <br><br>  Mit Veränderlichkeit und Terminologie aussortiert.  Lass uns weiter experimentieren.  Was ist, wenn es uns gelingt, den Compiler zu "brechen"? <br><br>  Was ist, wenn Sie eine Variable und ein Muster mit demselben Namen benennen? <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (obj <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> String obj) { System.out.println(obj.toLowerCase()); }</code> </pre> <br><pre> <code class="bash hljs">A.java:7: error: variable obj is already defined <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> method f(Object) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (obj instanceof String obj) { ^</code> </pre> <br>  Ist logisch.  Das Überlappen einer Variablen aus dem äußeren Bereich funktioniert nicht.  Dies ist äquivalent dazu, als ob wir die Variable <code>obj</code> zweites Mal im selben Bereich <code>obj</code> . <br><br>  Und wenn ja: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (obj <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> String str &amp;&amp; obj <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> String str) { System.out.println(str.toLowerCase()); }</code> </pre> <br><pre> <code class="bash hljs">A.java:7: error: illegal attempt to redefine an existing match binding <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (obj instanceof String str &amp;&amp; obj instanceof String str) { ^</code> </pre> <br>  Der Compiler ist solide wie Beton. <br><br>  Was können Sie noch versuchen?  Lassen Sie uns mit den Bereichen herumspielen.  Wenn Bindung in der <code>if</code> Verzweigung definiert ist, wird sie in der <code>else</code> Verzweigung definiert, wenn die Bedingung invertiert ist? <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!(obj <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> String str)) { System.out.println(<span class="hljs-string"><span class="hljs-string">"not a string"</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { System.out.println(str.toLowerCase()); }</code> </pre> <br>  Es hat funktioniert  Der Compiler ist nicht nur zuverlässig, sondern auch intelligent. <br><br>  Und wenn ja <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (obj <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> String str &amp;&amp; <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>) { System.out.println(str.toLowerCase()); }</code> </pre> <br>  Es hat wieder funktioniert.  Der Compiler versteht richtig, dass die Bedingung auf eine einfache <code>obj instanceof String str</code> . <br><br>  Ist es wirklich nicht möglich, den Compiler zu "brechen"? <br><br>  Möglicherweise so? <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (obj <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> String str || <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>) { System.out.println(str.toLowerCase()); }</code> </pre> <br><pre> <code class="bash hljs">A.java:8: error: cannot find symbol System.out.println(str.toLowerCase()); ^</code> </pre><br>  Ja!  Das sieht schon nach einem Bug aus.  Schließlich sind alle drei Bedingungen absolut gleichwertig: <br><br><ul><li> <code>obj instanceof String str</code> </li> <li> <code>obj instanceof String str &amp;&amp; true</code> </li> <li> <code>obj instanceof String str || false</code> </li> </ul><br>  Flow-Scoping-Regeln sind dagegen eher nicht <a href="http://cr.openjdk.java.net/~briangoetz/amber/pattern-semantics.html">trivial</a> , und vielleicht sollte ein solcher Fall wirklich nicht funktionieren.  Aber wenn Sie rein aus menschlicher Sicht schauen, dann denke ich, dass dies ein Fehler ist. <br><br>  Aber komm, lass uns etwas anderes versuchen.  Funktioniert das: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!(obj <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> String str)) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> RuntimeException(); } System.out.println(str.toLowerCase());</code> </pre> <br>  Kompiliert.  Das ist gut, da dieser Code dem Folgenden entspricht: <br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!(obj <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> String str)) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> RuntimeException(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { System.out.println(str.toLowerCase()); }</code> </pre> <br>  Und da beide Optionen gleichwertig sind, erwartet der Programmierer, dass sie auf die gleiche Weise funktionieren. <br><br>  Was ist mit überlappenden Feldern? <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> String str; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Object obj)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (obj <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> String str) { System.out.println(str.toLowerCase()); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { System.out.println(str.toLowerCase()); } } }</code> </pre> <br>  Der Compiler hat nicht geschworen.  Dies ist logisch, da lokale Variablen immer Felder überlappen können.  Anscheinend haben sie auch beschlossen, keine Ausnahmen für Musterbindungen zu machen.  Andererseits ist ein solcher Code ziemlich zerbrechlich.  Ein unvorsichtiger Schritt, und Sie werden möglicherweise nicht bemerken, wie Ihr <code>if</code> Zweig gebrochen ist: <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isOK</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Object obj)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (obj <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> String str || isOK()) { System.out.println(str.toLowerCase()); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { System.out.println(str.toLowerCase()); } }</code> </pre> <br>  Beide Zweige verwenden jetzt das Feld <code>str</code> , das ein unaufmerksamer Programmierer möglicherweise nicht erwartet.  Um solche Fehler so früh wie möglich zu erkennen, verwenden Sie die Überprüfungen in der IDE und unterschiedliche Syntaxhervorhebungen für Felder und Variablen.  Ich empfehle außerdem, dass Sie <code>this</code> Qualifikationsmerkmal immer für Felder verwenden.  Dies erhöht die Zuverlässigkeit. <br><br>  Was ist noch interessant?  Wie die "alte" <code>instanceof</code> , stimmt die neue nie mit <code>null</code> überein.  Dies bedeutet, dass Sie sich immer darauf verlassen können, dass Musterbinder niemals <code>null</code> : <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (obj <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> String str) { System.out.println(str.toLowerCase()); <span class="hljs-comment"><span class="hljs-comment">//    NullPointerException }</span></span></code> </pre> <br>  Übrigens können Sie mit dieser Eigenschaft solche Ketten verkürzen: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (a != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { B b = a.getB(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (b != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { C c = b.getC(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (c != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { System.out.println(c.getSize()); } } }</code> </pre> <br>  Wenn Sie <code>instanceof</code> , kann der obige Code folgendermaßen umgeschrieben werden: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (a != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> &amp;&amp; a.getB() <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> B b &amp;&amp; b.getC() <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> C c) { System.out.println(c.getSize()); }</code> </pre> <br>  Schreiben Sie in die Kommentare, was Sie über diesen Stil denken.  Würden Sie diese Redewendung verwenden? <br><br>  Was ist mit Generika? <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.util.List; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String[] args)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> A().f(List.of(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>)); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Object obj)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (obj <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> List&lt;Integer&gt; list) { System.out.println(list.size()); } } }</code> </pre> <br><pre> <code class="bash hljs">&gt; java --<span class="hljs-built_in"><span class="hljs-built_in">enable</span></span>-preview --<span class="hljs-built_in"><span class="hljs-built_in">source</span></span> 14 A.java Note: A.java uses unchecked or unsafe operations. Note: Recompile with -Xlint:unchecked <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> details. 3</code> </pre> <br>  Sehr interessant.  Wenn die "alte" <code>instanceof</code> nur " <code>instanceof List</code> oder " <code>instanceof List&lt;?&gt;</code> " Unterstützt, funktioniert die neue mit einem bestimmten Typ.  Wir warten darauf, dass die erste Person in eine solche Falle gerät: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (obj <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> List&lt;Integer&gt; list) { System.out.println(<span class="hljs-string"><span class="hljs-string">"Int list of size "</span></span> + list.size()); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (obj <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> List&lt;String&gt; list) { System.out.println(<span class="hljs-string"><span class="hljs-string">"String list of size "</span></span> + list.size()); }</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Warum funktioniert das nicht?</b> <div class="spoiler_text">  Antwort: Mangel an reifizierten Generika in Java. </div></div><br>  IMHO, das ist ein ziemlich ernstes Problem.  Andererseits weiß ich nicht, wie ich das beheben soll.  Es sieht so aus, als müssten Sie sich wieder auf Inspektionen in der IDE verlassen. <br><br><h2>  Schlussfolgerungen </h2><br>  Im Allgemeinen funktioniert der neue Pattern-Matching-Typ sehr gut.  Mit der verbesserten <code>instanceof</code> Operators können Sie nicht nur eine Typprüfung durchführen, sondern auch fertige Bindemittel dieses Typs deklarieren, sodass kein manuelles Gießen erforderlich ist.  Dies bedeutet, dass der Code weniger Rauschen enthält und der Leser nützliche Logik leichter erkennen kann.  Beispielsweise können die meisten <code>equals()</code> -Implementierungen in einer Zeile geschrieben werden: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Point</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x, y; … <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">hashCode</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Objects.hash(x, y); } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">equals</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Object obj)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> obj <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> Point p &amp;&amp; px == <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.x &amp;&amp; py == <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.y; } }</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Der obige Code kann noch kürzer geschrieben werden.</b>  <b class="spoiler_title">Wie?</b> <div class="spoiler_text">  Verwenden von <a href="https://openjdk.java.net/jeps/359">Einträgen</a> , die auch in Java 14 enthalten sein werden. Wir werden beim nächsten Mal darüber sprechen. </div></div><br>  Andererseits werfen einige kontroverse Punkte kleine Fragen auf: <br><br><ul><li>  Nicht vollständig transparente Bereichsregeln (Beispiel mit <code>instanceof || false</code> ). </li><li>  Überlappende Felder. </li><li>  <code>instanceof</code> und Generika. </li></ul><br>  Dies sind jedoch eher unbedeutende Anschuldigungen als ernsthafte Behauptungen.  Alles in allem sind die enormen Vorteile der neuen <code>instanceof</code> Operators definitiv eine zusätzliche Sprache wert.  Und wenn es immer noch den Vorschau-Status verlässt und zu einer stabilen Syntax wird, ist es eine gute Motivation, Java 8 endgültig der neuen Java-Version zu überlassen. <br><br>  PS Ich habe einen <a href="https://t.me/miniJUG">Kanal in Telegram,</a> in dem ich über Java-Nachrichten schreibe.  Ich fordere Sie auf, es zu abonnieren. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de477654/">https://habr.com/ru/post/de477654/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de477642/index.html">Machine (Radio) Vision sieht durch Wände</a></li>
<li><a href="../de477644/index.html">Wiederherstellen von UNIX v0 auf PDP-7: Backroom-Details</a></li>
<li><a href="../de477646/index.html">Mathematiker schneiden Formen auf der Suche nach Teilen von Gleichungen</a></li>
<li><a href="../de477648/index.html">MVCC in PostgreSQL-3. Zeilenversionen</a></li>
<li><a href="../de477650/index.html">Verschlüsselung des TLS-Verkehrs nach GOST-2012-Algorithmen mit Stunnel</a></li>
<li><a href="../de477656/index.html">Also trotzdem, warum brauchst du make?</a></li>
<li><a href="../de477658/index.html">Active Restore: Kann Disaster Recovery schneller sein? Viel schneller</a></li>
<li><a href="../de477662/index.html">Zugriff auf Redd Tyres auf FTDI-Brücken</a></li>
<li><a href="../de477668/index.html">29. November, 18 Uhr - devleads-mitap</a></li>
<li><a href="../de477670/index.html">Was gibt Testautomatisierung</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>