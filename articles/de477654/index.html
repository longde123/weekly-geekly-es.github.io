<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üìè üë®üèø‚Äç‚úàÔ∏è üà∏ Probieren Sie den verbesserten instanceof-Operator in Java 14 aus üòÑ üë®üèæ ‚õëÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Nicht weit entfernt ist die neue, 14. Version von Java, was bedeutet, dass es Zeit ist zu sehen, welche neuen Syntaxfunktionen diese Version von Java ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Probieren Sie den verbesserten instanceof-Operator in Java 14 aus</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/477654/"> Nicht weit entfernt ist die neue, <a href="http://openjdk.java.net/projects/jdk/14/">14. Version von</a> Java, was bedeutet, dass es Zeit ist zu sehen, welche neuen Syntaxfunktionen diese Version von Java enthalten wird.  Eine dieser syntaktischen M√∂glichkeiten ist der <a href="https://openjdk.java.net/jeps/305">Mustervergleich des Typs</a> , der unter Verwendung der verbesserten (erweiterten) <code>instanceof</code> Operators implementiert wird. <br><br>  Heute m√∂chte ich mit diesem neuen Operator herumspielen und die Funktionen seiner Arbeit detaillierter betrachten.  Da die Mustererkennung nach Typ noch nicht im Haupt-JDK-Repository vorhanden ist, musste ich das Repository <a href="https://openjdk.java.net/projects/amber/">des Amber-Projekts</a> herunterladen, das neue Java-Syntaxkonstrukte entwickelt, und <a href="https://builds.shipilev.net/workspaces/">das JDK</a> aus diesem Repository <a href="https://builds.shipilev.net/workspaces/">kompilieren</a> . <br><a name="habracut"></a><br>  Als erstes √ºberpr√ºfen wir die Java-Version, um sicherzustellen, dass wir wirklich JDK 14 verwenden: <br><br><pre> <code class="bash hljs">&gt; java -version openjdk version <span class="hljs-string"><span class="hljs-string">"14-internal"</span></span> 2020-03-17 OpenJDK Runtime Environment (build 14-internal+0-adhoc.osboxes.amber-amber) OpenJDK 64-Bit Server VM (build 14-internal+0-adhoc.osboxes.amber-amber, mixed mode, sharing)</code> </pre> <br>  Alles ist richtig. <br><br>  Jetzt schreiben wir ein kleines St√ºck Code mit der "alten" <code>instanceof</code> Operators und f√ºhren es aus: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String[] args)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> A().f(<span class="hljs-string"><span class="hljs-string">"Hello, world!"</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Object obj)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (obj <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> String) { String str = (String) obj; System.out.println(str.toLowerCase()); } } }</code> </pre> <br><pre> <code class="bash hljs">&gt; java A.java hello, world!</code> </pre> <br>  Es funktioniert  Dies ist eine Standardtyppr√ºfung, gefolgt von einer Besetzung.  Wir schreiben jeden Tag √§hnliche Konstruktionen, egal welche Java-Version wir verwenden, mindestens 1.0, mindestens 13. <br>  Aber jetzt haben wir Java 14 in unseren H√§nden und schreiben den Code mit der verbesserten <code>instanceof</code> Operators neu (ich werde in Zukunft darauf verzichten, Codezeilen zu wiederholen): <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (obj <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> String str) { System.out.println(str.toLowerCase()); }</code> </pre> <br><pre> <code class="bash hljs">&gt; java --<span class="hljs-built_in"><span class="hljs-built_in">enable</span></span>-preview --<span class="hljs-built_in"><span class="hljs-built_in">source</span></span> 14 A.java hello, world!</code> </pre> <br>  Gro√üartig.  Der Code ist sauberer, k√ºrzer, sicherer und lesbarer.  Es gab drei Wiederholungen des Wortes String, eine wurde.  Beachten Sie, dass wir nicht vergessen haben, die Argumente <code>--enable-preview --source 14</code> , as anzugeben  Der neue Operator ist eine <a href="https://openjdk.java.net/jeps/12">Vorschaufunktion</a> .  Dar√ºber hinaus hat ein aufmerksamer Leser wahrscheinlich bemerkt, dass wir die A.java-Quelldatei direkt ohne Kompilierung ausgef√ºhrt haben.  Diese Funktion <a href="https://openjdk.java.net/jeps/330">erschien</a> in Java 11. <br><br>  Versuchen wir, etwas komplexeres zu schreiben und f√ºgen eine zweite Bedingung hinzu, die die gerade deklarierte Variable verwendet: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (obj <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> String str &amp;&amp; str.length() &gt; <span class="hljs-number"><span class="hljs-number">5</span></span>) { System.out.println(str.toLowerCase()); }</code> </pre> <br>  Es kompiliert und funktioniert.  Aber was ist, wenn Sie die Bedingungen tauschen? <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (str.length() &gt; <span class="hljs-number"><span class="hljs-number">5</span></span> &amp;&amp; obj <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> String str) { System.out.println(str.toLowerCase()); }</code> </pre> <br><pre> <code class="bash hljs">A.java:7: error: cannot find symbol <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (str.length() &gt; 5 &amp;&amp; obj instanceof String str) { ^</code> </pre> <br>  Kompilierungsfehler.  Was zu erwarten ist: Die Variable <code>str</code> wurde noch nicht deklariert, kann also nicht verwendet werden. <br><br>  Was ist √ºbrigens mit der Ver√§nderlichkeit?  Ist die Variable final oder nicht?  Wir versuchen: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (obj <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> String str) { str = <span class="hljs-string"><span class="hljs-string">"World, hello!"</span></span>; System.out.println(str.toLowerCase()); }</code> </pre> <br><pre> <code class="bash hljs">A.java:8: error: pattern binding str may not be assigned str = <span class="hljs-string"><span class="hljs-string">"World, hello!"</span></span>; ^</code> </pre> <br>  Ja, die letzte Variable.  Dies bedeutet, dass das Wort ‚ÄûVariable‚Äú hier nicht ganz richtig ist.  Und der Compiler verwendet den Spezialbegriff "Musterbindung".  Daher schlage ich von nun an vor, nicht "variabel", sondern "Musterbindung" zu sagen (das Wort "Bindung" ist leider nicht sehr gut ins Russische √ºbersetzt). <br><br>  Mit Ver√§nderlichkeit und Terminologie aussortiert.  Lass uns weiter experimentieren.  Was ist, wenn es uns gelingt, den Compiler zu "brechen"? <br><br>  Was ist, wenn Sie eine Variable und ein Muster mit demselben Namen benennen? <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (obj <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> String obj) { System.out.println(obj.toLowerCase()); }</code> </pre> <br><pre> <code class="bash hljs">A.java:7: error: variable obj is already defined <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> method f(Object) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (obj instanceof String obj) { ^</code> </pre> <br>  Ist logisch.  Das √úberlappen einer Variablen aus dem √§u√üeren Bereich funktioniert nicht.  Dies ist √§quivalent dazu, als ob wir die Variable <code>obj</code> zweites Mal im selben Bereich <code>obj</code> . <br><br>  Und wenn ja: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (obj <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> String str &amp;&amp; obj <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> String str) { System.out.println(str.toLowerCase()); }</code> </pre> <br><pre> <code class="bash hljs">A.java:7: error: illegal attempt to redefine an existing match binding <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (obj instanceof String str &amp;&amp; obj instanceof String str) { ^</code> </pre> <br>  Der Compiler ist solide wie Beton. <br><br>  Was k√∂nnen Sie noch versuchen?  Lassen Sie uns mit den Bereichen herumspielen.  Wenn Bindung in der <code>if</code> Verzweigung definiert ist, wird sie in der <code>else</code> Verzweigung definiert, wenn die Bedingung invertiert ist? <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!(obj <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> String str)) { System.out.println(<span class="hljs-string"><span class="hljs-string">"not a string"</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { System.out.println(str.toLowerCase()); }</code> </pre> <br>  Es hat funktioniert  Der Compiler ist nicht nur zuverl√§ssig, sondern auch intelligent. <br><br>  Und wenn ja <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (obj <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> String str &amp;&amp; <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>) { System.out.println(str.toLowerCase()); }</code> </pre> <br>  Es hat wieder funktioniert.  Der Compiler versteht richtig, dass die Bedingung auf eine einfache <code>obj instanceof String str</code> . <br><br>  Ist es wirklich nicht m√∂glich, den Compiler zu "brechen"? <br><br>  M√∂glicherweise so? <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (obj <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> String str || <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>) { System.out.println(str.toLowerCase()); }</code> </pre> <br><pre> <code class="bash hljs">A.java:8: error: cannot find symbol System.out.println(str.toLowerCase()); ^</code> </pre><br>  Ja!  Das sieht schon nach einem Bug aus.  Schlie√ülich sind alle drei Bedingungen absolut gleichwertig: <br><br><ul><li> <code>obj instanceof String str</code> </li> <li> <code>obj instanceof String str &amp;&amp; true</code> </li> <li> <code>obj instanceof String str || false</code> </li> </ul><br>  Flow-Scoping-Regeln sind dagegen eher nicht <a href="http://cr.openjdk.java.net/~briangoetz/amber/pattern-semantics.html">trivial</a> , und vielleicht sollte ein solcher Fall wirklich nicht funktionieren.  Aber wenn Sie rein aus menschlicher Sicht schauen, dann denke ich, dass dies ein Fehler ist. <br><br>  Aber komm, lass uns etwas anderes versuchen.  Funktioniert das: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!(obj <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> String str)) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> RuntimeException(); } System.out.println(str.toLowerCase());</code> </pre> <br>  Kompiliert.  Das ist gut, da dieser Code dem Folgenden entspricht: <br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!(obj <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> String str)) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> RuntimeException(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { System.out.println(str.toLowerCase()); }</code> </pre> <br>  Und da beide Optionen gleichwertig sind, erwartet der Programmierer, dass sie auf die gleiche Weise funktionieren. <br><br>  Was ist mit √ºberlappenden Feldern? <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> String str; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Object obj)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (obj <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> String str) { System.out.println(str.toLowerCase()); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { System.out.println(str.toLowerCase()); } } }</code> </pre> <br>  Der Compiler hat nicht geschworen.  Dies ist logisch, da lokale Variablen immer Felder √ºberlappen k√∂nnen.  Anscheinend haben sie auch beschlossen, keine Ausnahmen f√ºr Musterbindungen zu machen.  Andererseits ist ein solcher Code ziemlich zerbrechlich.  Ein unvorsichtiger Schritt, und Sie werden m√∂glicherweise nicht bemerken, wie Ihr <code>if</code> Zweig gebrochen ist: <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isOK</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Object obj)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (obj <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> String str || isOK()) { System.out.println(str.toLowerCase()); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { System.out.println(str.toLowerCase()); } }</code> </pre> <br>  Beide Zweige verwenden jetzt das Feld <code>str</code> , das ein unaufmerksamer Programmierer m√∂glicherweise nicht erwartet.  Um solche Fehler so fr√ºh wie m√∂glich zu erkennen, verwenden Sie die √úberpr√ºfungen in der IDE und unterschiedliche Syntaxhervorhebungen f√ºr Felder und Variablen.  Ich empfehle au√üerdem, dass Sie <code>this</code> Qualifikationsmerkmal immer f√ºr Felder verwenden.  Dies erh√∂ht die Zuverl√§ssigkeit. <br><br>  Was ist noch interessant?  Wie die "alte" <code>instanceof</code> , stimmt die neue nie mit <code>null</code> √ºberein.  Dies bedeutet, dass Sie sich immer darauf verlassen k√∂nnen, dass Musterbinder niemals <code>null</code> : <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (obj <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> String str) { System.out.println(str.toLowerCase()); <span class="hljs-comment"><span class="hljs-comment">//    NullPointerException }</span></span></code> </pre> <br>  √úbrigens k√∂nnen Sie mit dieser Eigenschaft solche Ketten verk√ºrzen: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (a != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { B b = a.getB(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (b != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { C c = b.getC(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (c != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { System.out.println(c.getSize()); } } }</code> </pre> <br>  Wenn Sie <code>instanceof</code> , kann der obige Code folgenderma√üen umgeschrieben werden: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (a != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> &amp;&amp; a.getB() <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> B b &amp;&amp; b.getC() <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> C c) { System.out.println(c.getSize()); }</code> </pre> <br>  Schreiben Sie in die Kommentare, was Sie √ºber diesen Stil denken.  W√ºrden Sie diese Redewendung verwenden? <br><br>  Was ist mit Generika? <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.util.List; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String[] args)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> A().f(List.of(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>)); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Object obj)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (obj <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> List&lt;Integer&gt; list) { System.out.println(list.size()); } } }</code> </pre> <br><pre> <code class="bash hljs">&gt; java --<span class="hljs-built_in"><span class="hljs-built_in">enable</span></span>-preview --<span class="hljs-built_in"><span class="hljs-built_in">source</span></span> 14 A.java Note: A.java uses unchecked or unsafe operations. Note: Recompile with -Xlint:unchecked <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> details. 3</code> </pre> <br>  Sehr interessant.  Wenn die "alte" <code>instanceof</code> nur " <code>instanceof List</code> oder " <code>instanceof List&lt;?&gt;</code> " Unterst√ºtzt, funktioniert die neue mit einem bestimmten Typ.  Wir warten darauf, dass die erste Person in eine solche Falle ger√§t: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (obj <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> List&lt;Integer&gt; list) { System.out.println(<span class="hljs-string"><span class="hljs-string">"Int list of size "</span></span> + list.size()); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (obj <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> List&lt;String&gt; list) { System.out.println(<span class="hljs-string"><span class="hljs-string">"String list of size "</span></span> + list.size()); }</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Warum funktioniert das nicht?</b> <div class="spoiler_text">  Antwort: Mangel an reifizierten Generika in Java. </div></div><br>  IMHO, das ist ein ziemlich ernstes Problem.  Andererseits wei√ü ich nicht, wie ich das beheben soll.  Es sieht so aus, als m√ºssten Sie sich wieder auf Inspektionen in der IDE verlassen. <br><br><h2>  Schlussfolgerungen </h2><br>  Im Allgemeinen funktioniert der neue Pattern-Matching-Typ sehr gut.  Mit der verbesserten <code>instanceof</code> Operators k√∂nnen Sie nicht nur eine Typpr√ºfung durchf√ºhren, sondern auch fertige Bindemittel dieses Typs deklarieren, sodass kein manuelles Gie√üen erforderlich ist.  Dies bedeutet, dass der Code weniger Rauschen enth√§lt und der Leser n√ºtzliche Logik leichter erkennen kann.  Beispielsweise k√∂nnen die meisten <code>equals()</code> -Implementierungen in einer Zeile geschrieben werden: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Point</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x, y; ‚Ä¶ <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">hashCode</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Objects.hash(x, y); } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">equals</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Object obj)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> obj <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> Point p &amp;&amp; px == <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.x &amp;&amp; py == <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.y; } }</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Der obige Code kann noch k√ºrzer geschrieben werden.</b>  <b class="spoiler_title">Wie?</b> <div class="spoiler_text">  Verwenden von <a href="https://openjdk.java.net/jeps/359">Eintr√§gen</a> , die auch in Java 14 enthalten sein werden. Wir werden beim n√§chsten Mal dar√ºber sprechen. </div></div><br>  Andererseits werfen einige kontroverse Punkte kleine Fragen auf: <br><br><ul><li>  Nicht vollst√§ndig transparente Bereichsregeln (Beispiel mit <code>instanceof || false</code> ). </li><li>  √úberlappende Felder. </li><li>  <code>instanceof</code> und Generika. </li></ul><br>  Dies sind jedoch eher unbedeutende Anschuldigungen als ernsthafte Behauptungen.  Alles in allem sind die enormen Vorteile der neuen <code>instanceof</code> Operators definitiv eine zus√§tzliche Sprache wert.  Und wenn es immer noch den Vorschau-Status verl√§sst und zu einer stabilen Syntax wird, ist es eine gute Motivation, Java 8 endg√ºltig der neuen Java-Version zu √ºberlassen. <br><br>  PS Ich habe einen <a href="https://t.me/miniJUG">Kanal in Telegram,</a> in dem ich √ºber Java-Nachrichten schreibe.  Ich fordere Sie auf, es zu abonnieren. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de477654/">https://habr.com/ru/post/de477654/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de477642/index.html">Machine (Radio) Vision sieht durch W√§nde</a></li>
<li><a href="../de477644/index.html">Wiederherstellen von UNIX v0 auf PDP-7: Backroom-Details</a></li>
<li><a href="../de477646/index.html">Mathematiker schneiden Formen auf der Suche nach Teilen von Gleichungen</a></li>
<li><a href="../de477648/index.html">MVCC in PostgreSQL-3. Zeilenversionen</a></li>
<li><a href="../de477650/index.html">Verschl√ºsselung des TLS-Verkehrs nach GOST-2012-Algorithmen mit Stunnel</a></li>
<li><a href="../de477656/index.html">Also trotzdem, warum brauchst du make?</a></li>
<li><a href="../de477658/index.html">Active Restore: Kann Disaster Recovery schneller sein? Viel schneller</a></li>
<li><a href="../de477662/index.html">Zugriff auf Redd Tyres auf FTDI-Br√ºcken</a></li>
<li><a href="../de477668/index.html">29. November, 18 Uhr - devleads-mitap</a></li>
<li><a href="../de477670/index.html">Was gibt Testautomatisierung</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>