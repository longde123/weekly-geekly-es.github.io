<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👈🏻 🏍️ 🖕🏻 Algorithmes d'apprentissage automatique de test Blitz: alimentez votre ensemble de données vers la bibliothèque scikit-learn ♐️ 🍻 🧛🏽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Chaque jour, le Web mondial est rempli d'articles sur les algorithmes d'apprentissage automatique les plus populaires et les plus utilisés pour résoud...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Algorithmes d'apprentissage automatique de test Blitz: alimentez votre ensemble de données vers la bibliothèque scikit-learn</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/475552/"><img src="https://habrastorage.org/getpro/habr/post_images/7d1/0a1/6c9/7d10a16c9f50f8289a4b30eb53ffc661.jpg" alt="image"><br><br>  Chaque jour, le Web mondial est rempli d'articles sur les algorithmes d'apprentissage automatique les plus populaires et les plus utilisés pour résoudre divers problèmes.  De plus, la base de ces articles, légèrement modifiés de forme à un endroit ou à un autre, se déplace d'un chercheur de données à un autre.  De plus, tous ces travaux sont unis par un postulat généralement accepté et incontestable: l'application de l'un ou l'autre algorithme d'apprentissage automatique dépend de la taille et de la nature des données disponibles et de la tâche à accomplir. <br><br>  En plus de cela, en particulier les chercheurs de données insistés, partageant leur expérience, soulignent: <i>«Le choix d'une méthode d'évaluation devrait dépendre en partie de vos données et de ce qui, à votre avis, le modèle devrait être bon» («Data Science: informations privilégiées pour les débutants. Y compris le langage R, par Cathy O'Neill, Rachel Shutt)</i> . <br><a name="habracut"></a><br>  En d'autres termes, un statisticien / chercheur de données devrait avoir non seulement une expérience dans le domaine, mais également un large éventail de connaissances diverses: <i>«Un chercheur de données est celui qui possède des connaissances dans les domaines suivants: mathématiques, statistiques, génie informatique, apprentissage automatique, visualisation, moyens d'échanger des données ... »</i> (du même livre).  Seul un chargement approfondi des connaissances des domaines ci-dessus dans la tête permet d'approcher l'apprentissage automatique et de trouver des solutions aux problèmes indiqués. <br><br>  Pour moi, ce début convient tout à fait à un livre ordinaire d'un kilo et demi sur la science des données, ou à un article d'histoire d'horreur scientifique avec des formules, des symboles et des gribouillis à deux étages «sans valeur» qui ont un impact grave et déprimant sur les débutants dans le domaine de l'apprentissage automatique et juste par hasard intéressé par cette direction lecteurs inexpérimentés, pas accablés de "connaissances nécessaires".  De plus, le nombre rond 10 des mêmes articles sur les 10 algorithmes d'apprentissage automatique les plus populaires ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">par exemple</a> ) ne fait que renforcer l'effet imposé. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Chez habr, ils se sont également distingués</a> : <i>«La réponse à la question:« Quel type d'algorithme d'apprentissage automatique dois-je utiliser? »Cela ressemble toujours à ceci:« Selon les circonstances ».</i>  <i>Le choix de l'algorithme dépend du volume, de la qualité et de la nature des données.</i>  <i>Cela dépend de la façon dont vous gérez le résultat.</i>  <i>Cela dépend de la façon dont les instructions pour l'ordinateur qui le met en œuvre ont été créées à partir de l'algorithme, et également du temps dont vous disposez.</i>  <i>Même les analystes de données les plus expérimentés ne vous diront pas quel algorithme est le meilleur avant de l'essayer. »</i> <br><br>  Sans aucun doute, toutes ces connaissances, ainsi que la persévérance et l'intérêt sont nécessaires et utiles pour obtenir de bons résultats non seulement sur la voie de la compréhension de l'apprentissage automatique, mais aussi dans de nombreux autres domaines.  En outre, ils faciliteront la compréhension du fait que les algorithmes d'apprentissage automatique (ci-après dénommés algorithmes) sont loin d'être une douzaine;  mais ce n'est que plus tard, avec une étude indépendante. <br><br>  Mon objectif est de présenter au lecteur les algorithmes les plus utilisés d'un point de vue pratique et accessible.  (Le fait que je ne suis pas un programmeur et, en plus, pas un mathématicien (saint-saint-saint!) Devrait souligner l'intérêt pour le récit. La formation d'ingénieur plus l'expérience dans le «sujet grandissent» de 10 ans (juste une sorte de nombre magique ) - comme on dit, et toutes mes affaires, tous mes bagages avec lesquels je suis allé directement à l'apprentissage automatique. Grâce à mon expérience dans l'industrie pétrolière, des idées pour utiliser des réseaux de neurones artificiels et des algorithmes d'apprentissage automatique ont été trouvées tout de suite (lire - il fallait ensembles de données.) Il ne restait plus qu'à  Scarlet - apprendre à tordre-tordre les données afin de les soumettre correctement à l'entrée du "programme" et qui, en fait, l'algorithme à choisir. Et puis dans un cercle vicieux. Je constate que mon chemin était épineux et amusant - "des balles sifflaient au-dessus de ma tête" (de m / f "Les Aventures de Funtik"), - mais j'ai quand même réussi à prendre des notes, et si l'intérêt est indiqué, alors à l'avenir je publierai d'autres messages.) <br><br>  Donc, je propose l'approche de l '«usinage» d'autre part: pourquoi ne pas alimenter votre ensemble de données existant (dans les exemples, vous chargerez des ensembles de données qui peuvent être facilement formés) à beaucoup d'algorithmes à la fois, et en fonction des résultats, décidez de celui auquel vous devez prêter une attention particulière étude approfondie et sélection des paramètres optimaux qui améliorent le résultat.  De plus, la principale valeur de la méthode discutée ci-dessus est que ses résultats répondront à la question de la valeur de votre ensemble de données: <i>"commencez par résoudre le problème et assurez-vous que vous avez quelque chose à optimiser"</i> (également de certains puis les statistiques insistantes sont allées, "respect" pour lui, bon conseil!). <br><br>  Comment est-il fait? <br><br>  On sait que l'essentiel des problèmes résolus à l'aide d'algorithmes concerne les problèmes de classification (classification) et d'analyse de régression (analyse prédictive).  Par <i>classification,</i> on entend une différenciation constante des unités d'observation (instances) d'un ensemble de données vers une certaine catégorie (classe) en fonction des résultats de la formation.  <i>L'analyse de régression</i> est un ensemble de méthodes et de processus statistiques permettant d'évaluer la relation entre les variables [ <i>Statistics: Textbook / Ed.</i>  <i>prof.</i>  <i>M.R.</i>  <i>Efimova.</i>  <i>- M.: INFRA-M, 2002</i> ].  Le but de l'analyse de régression est d'évaluer la valeur d'une variable de sortie continue à partir des valeurs des variables d'entrée [ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">lien</a> ]. <br><br>  Nous laissons de côté le fait que l'analyse de régression dispose de deux méthodes différentes: la modélisation prédictive et la prévision.  Nous notons seulement que s'il existe une série temporelle (données de séries temporelles), alors en utilisant un modèle de régression basé sur une tendance explicite, soumise à la stationnarité (constance), la prévision peut être effectuée.  Si les conditions de formation des niveaux de la série temporelle changent, c'est-à-dire que le processus non stationnaire n'est pas observé, alors c'est à la modélisation prédictive.  Particulièrement destiné à la maîtrise totale du ML, je vous propose de lire cet article en anglais: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">lien</a> .  Si une discussion se lève à ce sujet, je serai heureux d'y participer. <br><br>  Étant donné que les séries chronologiques ne seront pas utilisées dans les exemples de cet article, le terme <i>prévision</i> fait référence à <i>l'analyse prédictive</i> . <br><br>  Pour résoudre les problèmes de classification et de prévision, toute une gamme d'algorithmes convient, dont certains seront examinés plus loin.  Pour plus de commodité, le texte suivant sera divisé en deux parties: dans la première, nous considérons les algorithmes de classification les plus courants, la seconde que nous consacrons aux algorithmes d'analyse de régression.  Pour chaque partie, un ensemble de données «jouet» chargé à partir de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">la bibliothèque scikit-learn</a> (v0.21.3): <i>ensemble de données à chiffres (classification)</i> et <i>ensemble de données sur les prix des maisons à boston (régression)</i> sera présenté, ainsi que des liens vers chaque algorithme de la bibliothèque scikit-learn pour auto-examen et, éventuellement, étude. <br><br>  Tous les exemples de code sont exécutés dans la console <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">IDE Spyder</a> 3.3.3 sur Python 3.7.3. <br><br><h3>  Problème de classification </h3><br>  Tout d'abord, nous importons les modules et fonctions nécessaires que nous utiliserons pour résoudre le problème de la classification des données: <br><br><pre><code class="python hljs"><span class="hljs-comment"><span class="hljs-comment">#      from sklearn.datasets import load_digits from sklearn.model_selection import train_test_split from sklearn.linear_model import LogisticRegression from sklearn.discriminant_analysis import LinearDiscriminantAnalysis from sklearn.neighbors import KNeighborsClassifier from sklearn.tree import DecisionTreeClassifier from sklearn.naive_bayes import GaussianNB from sklearn.svm import LinearSVC from sklearn.svm import SVC from sklearn.neural_network import MLPClassifier from sklearn.ensemble import BaggingClassifier from sklearn.ensemble import RandomForestClassifier from sklearn.ensemble import ExtraTreesClassifier from sklearn.ensemble import AdaBoostClassifier from sklearn.ensemble import GradientBoostingClassifier from sklearn.model_selection import KFold from sklearn.model_selection import cross_val_score from sklearn.pipeline import Pipeline from sklearn.preprocessing import StandardScaler from sklearn.preprocessing import MinMaxScaler from sklearn.preprocessing import Normalizer from matplotlib import pyplot</span></span></code> </pre> <br>  Téléchargez le jeu de données 'digits' directement depuis <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">le module 'sklearn.datasets'</a> : <br><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment">#    dataset = load_digits()</span></span></code> </pre> <br>  IDE Spyder fournit un outil pratique "Variable Manager", qui est utile à tout moment pour étudier l'apprentissage automatique (au moins pour moi), comme d' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">autres "trucs"</a> : <br><br>  Exécutez le code.  Dans la console "gestionnaire de variables", cliquez sur la variable d' <i>ensemble de données</i> .  Le dictionnaire suivant s'affiche: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f9f/362/64a/f9f36264a8a368644793b6f4ed7ad045.png" alt="image"><br><br>  La description de l'ensemble de données est la suivante: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/887/659/b2b/887659b2bc79bfd532c30d6ddee8aa5e.png" alt="image"><br><br>  Dans cet exemple, nous n'avons pas besoin de la clé «images», nous affectons donc la variable «data» à <i>X</i> , qui est un tableau NumPy multidimensionnel avec un ensemble d'attributs, 1797 lignes dans 64 colonnes et la variable <i>Y</i> à «cible», un tableau multidimensionnel NumPy avec un marqueur pour chaque chaîne. <br><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment">#    # dataset = load_digits() X = dataset.data Y = dataset.target</span></span></code> </pre> <br>  Ensuite, nous divisons l'ensemble de données en parties d'apprentissage et de test, configurons les paramètres pour évaluer les algorithmes (la validation croisée est utilisée [ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">un</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">deux</a> ]), définissant la métrique `` précision '' dans le paramètre `` scoring '' [ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">lien</a> ].  La précision est la proportion d'objets correctement classés par rapport au nombre total d'objets.  Plus le résultat est proche de 1, mieux c'est [ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">link</a> ].  De plus, dans l'un des livres, il a été constaté que les résultats de 0,95 (ou 95%) et plus sont considérés comme excellents. <br><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment">#         test_size = 0.2 seed = 7 X_train, X_test, Y_train, Y_test = train_test_split(X, Y, test_size=test_size, random_state=seed) #     num_folds = 10 n_estimators = 100 scoring = 'accuracy'</span></span></code> </pre> <br>  <i>Laissez les</i> variables <i>X_train</i> et <i>Y_train être utilisées</i> à des fins de formation, <i>X_test</i> et <i>Y_test</i> pour le développement des valeurs de prévision.  Dans ce cas, la variable <i>Y_test n'est</i> pas impliquée dans le calcul de la prévision: en utilisant la méthode du `` score '', qui est la même pour chacun des algorithmes présentés ci-dessous, nous calculerons les bonnes réponses en utilisant la métrique `` précision ''.  Cela nous permettra de juger comment l'algorithme fait face à la tâche.  Je ne dis pas, pour notre part, il est si humainement vil de ne pas inciter la voiture avec les bonnes réponses, mais comment vérifier ses performances autrement? <br><br>  Vous trouverez ci-dessous une liste d'algorithmes avec lesquels nous alimentons l'ensemble de données.  Sur la base des résultats des calculs, nous conclurons quel algorithme (lequel des algorithmes) montre la plus grande efficacité.  Cette méthode peut très bien être qualifiée de <b>«test blitz d'algorithmes d'apprentissage automatique»</b> (ci-après - test blitz). <br><br>  Pour plus de commodité, les informations seront abrégées à côté de chaque algorithme.  Il convient de noter que les paramètres de chaque algorithme sont acceptés par défaut (par défaut), à l'exception de certains points, afin de fournir des conditions égales. <br><br><h4>  Algorithmes linéaires: </h4><br>  - Régression logistique * / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Régression logistique</a> ('LR') <br>  <i>* Le mot «régression» peut prêter à confusion.</i>  <i>Mais n'oubliez pas que la «régression logistique» est un algorithme de classification</i> <br>  - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Analyse discriminante linéaire</a> («LDA») <br><br><h4>  Algorithmes non linéaires: </h4><br>  - Méthode des k voisins les plus proches (classification) / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">K-Neighbors Classifier</a> («KNN») <br>  - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Classificateur d'arbre de décision</a> («CART») <br>  - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Naive Bayes Classifier</a> («NB») <br>  - Méthode de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">classification des vecteurs de support linéaire</a> (Classification) / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Classification des vecteurs de support linéaire</a> («LSVC») <br>  - Méthode du <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">vecteur de support</a> (Classification) / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Classification du vecteur de support C</a> («SVC») <br><br><h4>  Algorithme de réseau de neurones artificiels: </h4><br>  - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Perceptron multicouches</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Perceptrons multicouches</a> («MLP») <br><br><h4>  Algorithmes d'ensemble: </h4><br>  - Bagging (classification) / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Bagging Classifier</a> ('BG') (Bagging = Bootstrap agrégation) <br>  - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Classification aléatoire des forêts</a> («RF») <br>  - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Classificateur d'arbres supplémentaires</a> («ET») <br>  - AdaBoost (classification) / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">AdaBoost Classifier</a> («AB») (AdaBoost = Adaptive Boosting) <br>  - Amplification de gradient (classification) / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Classificateur de renforcement de gradient</a> ('GB') <br><br>  Ainsi, la liste des «modèles» contient les modèles suivants: <br><br><pre> <code class="python hljs">models = [] models.append((<span class="hljs-string"><span class="hljs-string">'LR'</span></span>, LogisticRegression())) models.append((<span class="hljs-string"><span class="hljs-string">'LDA'</span></span>, LinearDiscriminantAnalysis())) models.append((<span class="hljs-string"><span class="hljs-string">'KNN'</span></span>, KNeighborsClassifier())) models.append((<span class="hljs-string"><span class="hljs-string">'CART'</span></span>, DecisionTreeClassifier())) models.append((<span class="hljs-string"><span class="hljs-string">'NB'</span></span>, GaussianNB())) models.append((<span class="hljs-string"><span class="hljs-string">'LSVC'</span></span>, LinearSVC())) models.append((<span class="hljs-string"><span class="hljs-string">'SVC'</span></span>, SVC())) models.append((<span class="hljs-string"><span class="hljs-string">'MLP'</span></span>, MLPClassifier())) models.append((<span class="hljs-string"><span class="hljs-string">'BG'</span></span>, BaggingClassifier(n_estimators=n_estimators))) models.append((<span class="hljs-string"><span class="hljs-string">'RF'</span></span>, RandomForestClassifier(n_estimators=n_estimators))) models.append((<span class="hljs-string"><span class="hljs-string">'ET'</span></span>, ExtraTreesClassifier(n_estimators=n_estimators))) models.append((<span class="hljs-string"><span class="hljs-string">'AB'</span></span>, AdaBoostClassifier(n_estimators=n_estimators, algorithm=<span class="hljs-string"><span class="hljs-string">'SAMME'</span></span>))) models.append((<span class="hljs-string"><span class="hljs-string">'GB'</span></span>, GradientBoostingClassifier(n_estimators=n_estimators)))</code> </pre> <br>  Comme déjà mentionné, l'efficacité de chaque algorithme est évaluée en utilisant la validation croisée.  En conséquence, un message s'affiche (msg - abréviation du message) contenant les informations suivantes: nom du modèle sous la forme d'une abréviation, score moyen de 10 fois la validation croisée des données d'entraînement (`` précision '' métrique), l'écart type est indiqué entre parenthèses , ainsi que la valeur de la métrique de «précision» sur les données de test. <br><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment">#      scores = [] names = [] results = [] predictions = [] msg_row = [] for name, model in models: kfold = KFold(n_splits=num_folds, random_state=seed) cv_results = cross_val_score(model, X_train, Y_train, cv=kfold, scoring=scoring) names.append(name) results.append(cv_results) m_fit = model.fit(X_train, Y_train) m_predict = model.predict(X_test) predictions.append(m_predict) m_score = model.score(X_test, Y_test) scores.append(m_score) msg = "%s: train = %.3f (%.3f) / test = %.3f" % (name, cv_results.mean(), cv_results.std(), m_score) msg_row.append(msg) print(msg)</span></span></code> </pre> <br>  Après avoir exécuté le code, nous obtenons les résultats suivants: <br><br><pre> <code class="python hljs">LR: train = <span class="hljs-number"><span class="hljs-number">0.957</span></span> (<span class="hljs-number"><span class="hljs-number">0.014</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.948</span></span> LDA: train = <span class="hljs-number"><span class="hljs-number">0.951</span></span> (<span class="hljs-number"><span class="hljs-number">0.014</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.946</span></span> KNN: train = <span class="hljs-number"><span class="hljs-number">0.985</span></span> (<span class="hljs-number"><span class="hljs-number">0.013</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.981</span></span> CART: train = <span class="hljs-number"><span class="hljs-number">0.843</span></span> (<span class="hljs-number"><span class="hljs-number">0.033</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.830</span></span> NB: train = <span class="hljs-number"><span class="hljs-number">0.819</span></span> (<span class="hljs-number"><span class="hljs-number">0.048</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.806</span></span> LSVC: train = <span class="hljs-number"><span class="hljs-number">0.942</span></span> (<span class="hljs-number"><span class="hljs-number">0.017</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.928</span></span> SVC: train = <span class="hljs-number"><span class="hljs-number">0.343</span></span> (<span class="hljs-number"><span class="hljs-number">0.079</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.342</span></span> MLP: train = <span class="hljs-number"><span class="hljs-number">0.972</span></span> (<span class="hljs-number"><span class="hljs-number">0.012</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.961</span></span> BG: train = <span class="hljs-number"><span class="hljs-number">0.952</span></span> (<span class="hljs-number"><span class="hljs-number">0.021</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.941</span></span> RF: train = <span class="hljs-number"><span class="hljs-number">0.968</span></span> (<span class="hljs-number"><span class="hljs-number">0.017</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.965</span></span> ET: train = <span class="hljs-number"><span class="hljs-number">0.980</span></span> (<span class="hljs-number"><span class="hljs-number">0.010</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.975</span></span> AB: train = <span class="hljs-number"><span class="hljs-number">0.827</span></span> (<span class="hljs-number"><span class="hljs-number">0.049</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.823</span></span> GB: train = <span class="hljs-number"><span class="hljs-number">0.964</span></span> (<span class="hljs-number"><span class="hljs-number">0.013</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.968</span></span></code> </pre> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Diagramme d'étendue</a> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">«boîte avec moustache»</a> ) (diagramme ou diagramme en boîte et moustaches, diagramme en boîte): <br><br><img src="https://habrastorage.org/getpro/habr/post_images/e3e/301/4c9/e3e3014c9931e3af6b7ea01eda90a0d0.png" alt="image"><br><br>  À la suite d'un test éclair sur des données brutes, on peut voir que les plus efficaces sur les données de test étaient les algorithmes «KNN» (k-voisins les plus proches), «ET» (extra-arbres), «GB» (gradient «boosting»), 'RF' (forêt aléatoire) et 'MLP' (perceptron multicouche): <br><br><pre> <code class="python hljs">KNN: train = <span class="hljs-number"><span class="hljs-number">0.985</span></span> (<span class="hljs-number"><span class="hljs-number">0.013</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.981</span></span> ET: train = <span class="hljs-number"><span class="hljs-number">0.980</span></span> (<span class="hljs-number"><span class="hljs-number">0.010</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.975</span></span> GB: train = <span class="hljs-number"><span class="hljs-number">0.964</span></span> (<span class="hljs-number"><span class="hljs-number">0.013</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.968</span></span> RF: train = <span class="hljs-number"><span class="hljs-number">0.968</span></span> (<span class="hljs-number"><span class="hljs-number">0.017</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.965</span></span> MLP: train = <span class="hljs-number"><span class="hljs-number">0.972</span></span> (<span class="hljs-number"><span class="hljs-number">0.012</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.961</span></span> LR: train = <span class="hljs-number"><span class="hljs-number">0.957</span></span> (<span class="hljs-number"><span class="hljs-number">0.014</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.948</span></span> LDA: train = <span class="hljs-number"><span class="hljs-number">0.951</span></span> (<span class="hljs-number"><span class="hljs-number">0.014</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.946</span></span> BG: train = <span class="hljs-number"><span class="hljs-number">0.952</span></span> (<span class="hljs-number"><span class="hljs-number">0.021</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.941</span></span> LSVC: train = <span class="hljs-number"><span class="hljs-number">0.942</span></span> (<span class="hljs-number"><span class="hljs-number">0.017</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.928</span></span> CART: train = <span class="hljs-number"><span class="hljs-number">0.843</span></span> (<span class="hljs-number"><span class="hljs-number">0.033</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.830</span></span> AB: train = <span class="hljs-number"><span class="hljs-number">0.827</span></span> (<span class="hljs-number"><span class="hljs-number">0.049</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.823</span></span> NB: train = <span class="hljs-number"><span class="hljs-number">0.819</span></span> (<span class="hljs-number"><span class="hljs-number">0.048</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.806</span></span> SVC: train = <span class="hljs-number"><span class="hljs-number">0.343</span></span> (<span class="hljs-number"><span class="hljs-number">0.079</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.342</span></span></code> </pre> <br>  Cependant, de nombreux algorithmes sont très pointilleux sur les données qui leur sont fournies.  Par conséquent, l'une des étapes nécessaires est la soi-disant préparation préliminaire des données (prétraitement des données [ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">lien</a> ]) <br><br>  Cependant, il arrive que l'algorithme montre les meilleurs résultats sans traitement préalable.  D'où la recommandation suivante: inclure dans le test Blitz plusieurs transformations de l'ensemble de données d'origine et, après avoir effectué les calculs, comparer les résultats afin de saisir l'essence du problème dans son ensemble. <br><br>  Les méthodes de préparation des données préliminaires les plus couramment utilisées sont les suivantes: <br><br>  - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">normalisation;</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><br></a> <br>  - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">mise à l'échelle</a> (la plage par défaut est [0, 1]); <br><br>  - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">normalisation</a> <br><br>  Ces opérations avec évaluation ultérieure peuvent être automatisées et placées sur le convoyeur à l'aide de l'outil <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Pipeline</a> . <br><br>  Un extrait de code avec normalisation des données source est le suivant: <br><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># -      #    ( StandardScaler) pipelines = [] pipelines.append(('SS_LR', Pipeline([('Scaler', StandardScaler()), ('LR', LogisticRegression())]))) pipelines.append(('SS_LDA', Pipeline([('Scaler', StandardScaler()), ('LDA', LinearDiscriminantAnalysis())]))) pipelines.append(('SS_KNN', Pipeline([('Scaler', StandardScaler()), ('KNN', KNeighborsClassifier())]))) pipelines.append(('SS_CART', Pipeline([('Scaler', StandardScaler()), ('CART', DecisionTreeClassifier())]))) pipelines.append(('SS_NB', Pipeline([('Scaler', StandardScaler()), ('NB', GaussianNB())]))) pipelines.append(('SS_LSVC', Pipeline([('Scaler', StandardScaler()), ('LSVC', LinearSVC())]))) pipelines.append(('SS_SVC', Pipeline([('Scaler', StandardScaler()), ('SVC', SVC())]))) pipelines.append(('SS_MLP', Pipeline([('Scaler', StandardScaler()), ('MLP', MLPClassifier())]))) pipelines.append(('SS_BG', Pipeline([('Scaler', StandardScaler()), ('BG', BaggingClassifier(n_estimators=n_estimators))]))) pipelines.append(('SS_RF', Pipeline([('Scaler', StandardScaler()), ('RF', RandomForestClassifier(n_estimators=n_estimators))]))) pipelines.append(('SS_ET', Pipeline([('Scaler', StandardScaler()), ('ET', ExtraTreesClassifier(n_estimators=n_estimators))]))) pipelines.append(('SS_AB', Pipeline([('Scaler', StandardScaler()), ('AB', AdaBoostClassifier(n_estimators=n_estimators, algorithm='SAMME'))]))) pipelines.append(('SS_GB', Pipeline([('Scaler', StandardScaler()), ('GB', GradientBoostingClassifier(n_estimators=n_estimators))]))) #      scores_SS = [] names_SS = [] results_SS = [] predictions_SS = [] msg_SS = [] for name, model in pipelines: kfold = KFold(n_splits=num_folds, random_state=seed) cv_results = cross_val_score(model, X_train, Y_train, cv=kfold) names_SS.append(name) results_SS.append(cv_results) m_fit = model.fit(X_train, Y_train) m_predict = model.predict(X_test) predictions_SS.append(m_predict) m_score = model.score(X_test, Y_test) scores_SS.append(m_score) msg = "%s: train = %.3f (%.3f) / test = %.3f" % (name, cv_results.mean(), cv_results.std(), m_score) msg_SS.append(msg) print(msg) #    (StandardScaler) fig = pyplot.figure() fig.suptitle('     . ') ax = fig.add_subplot(111) red_square = dict(markerfacecolor='r', marker='s') pyplot.boxplot(results_SS, flierprops=red_square) ax.set_xticklabels(names_SS, rotation=45) pyplot.show()</span></span></code> </pre> <br>  Notez l'ajout de «_SS» (abréviation de StandardScaler) pour répertorier les noms.  Ceci est fait afin de ne pas empiler les résultats, ainsi que de les visualiser commodément en utilisant le "gestionnaire de variables" après que les conversions soient effectuées. <br><br>  L'exécution d'un extrait de code produit les résultats suivants: <br><br><pre> <code class="python hljs">SS_LR: train = <span class="hljs-number"><span class="hljs-number">0.958</span></span> (<span class="hljs-number"><span class="hljs-number">0.015</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.949</span></span> SS_LDA: train = <span class="hljs-number"><span class="hljs-number">0.951</span></span> (<span class="hljs-number"><span class="hljs-number">0.014</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.946</span></span> SS_KNN: train = <span class="hljs-number"><span class="hljs-number">0.968</span></span> (<span class="hljs-number"><span class="hljs-number">0.023</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.970</span></span> SS_CART: train = <span class="hljs-number"><span class="hljs-number">0.853</span></span> (<span class="hljs-number"><span class="hljs-number">0.036</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.835</span></span> SS_NB: train = <span class="hljs-number"><span class="hljs-number">0.756</span></span> (<span class="hljs-number"><span class="hljs-number">0.046</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.751</span></span> SS_LSVC: train = <span class="hljs-number"><span class="hljs-number">0.945</span></span> (<span class="hljs-number"><span class="hljs-number">0.018</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.941</span></span> SS_SVC: train = <span class="hljs-number"><span class="hljs-number">0.976</span></span> (<span class="hljs-number"><span class="hljs-number">0.015</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.990</span></span> SS_MLP: train = <span class="hljs-number"><span class="hljs-number">0.976</span></span> (<span class="hljs-number"><span class="hljs-number">0.012</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.973</span></span> SS_BG: train = <span class="hljs-number"><span class="hljs-number">0.947</span></span> (<span class="hljs-number"><span class="hljs-number">0.018</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.948</span></span> SS_RF: train = <span class="hljs-number"><span class="hljs-number">0.973</span></span> (<span class="hljs-number"><span class="hljs-number">0.016</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.970</span></span> SS_ET: train = <span class="hljs-number"><span class="hljs-number">0.980</span></span> (<span class="hljs-number"><span class="hljs-number">0.012</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.975</span></span> SS_AB: train = <span class="hljs-number"><span class="hljs-number">0.827</span></span> (<span class="hljs-number"><span class="hljs-number">0.049</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.823</span></span> SS_GB: train = <span class="hljs-number"><span class="hljs-number">0.964</span></span> (<span class="hljs-number"><span class="hljs-number">0.013</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.968</span></span></code> </pre> <br>  Boîte à moustache (StandardScaler): <br><br><img src="https://habrastorage.org/getpro/habr/post_images/8f7/a0d/bf7/8f7a0dbf718cfdd7b061ffd43a7bed8e.png" alt="image"><br><br>  Selon les résultats du calcul sur des données standardisées, les algorithmes suivants sont devenus leaders: <br><br><pre> <code class="python hljs">SS_SVC: train = <span class="hljs-number"><span class="hljs-number">0.976</span></span> (<span class="hljs-number"><span class="hljs-number">0.015</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.990</span></span> SS_ET: train = <span class="hljs-number"><span class="hljs-number">0.980</span></span> (<span class="hljs-number"><span class="hljs-number">0.012</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.975</span></span> SS_MLP: train = <span class="hljs-number"><span class="hljs-number">0.976</span></span> (<span class="hljs-number"><span class="hljs-number">0.012</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.973</span></span> SS_KNN: train = <span class="hljs-number"><span class="hljs-number">0.968</span></span> (<span class="hljs-number"><span class="hljs-number">0.023</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.970</span></span> SS_RF: train = <span class="hljs-number"><span class="hljs-number">0.973</span></span> (<span class="hljs-number"><span class="hljs-number">0.016</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.970</span></span> SS_GB: train = <span class="hljs-number"><span class="hljs-number">0.964</span></span> (<span class="hljs-number"><span class="hljs-number">0.013</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.968</span></span> SS_LR: train = <span class="hljs-number"><span class="hljs-number">0.958</span></span> (<span class="hljs-number"><span class="hljs-number">0.015</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.949</span></span> SS_BG: train = <span class="hljs-number"><span class="hljs-number">0.947</span></span> (<span class="hljs-number"><span class="hljs-number">0.018</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.948</span></span> SS_LDA: train = <span class="hljs-number"><span class="hljs-number">0.951</span></span> (<span class="hljs-number"><span class="hljs-number">0.014</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.946</span></span> SS_LSVC: train = <span class="hljs-number"><span class="hljs-number">0.945</span></span> (<span class="hljs-number"><span class="hljs-number">0.018</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.941</span></span> SS_CART: train = <span class="hljs-number"><span class="hljs-number">0.853</span></span> (<span class="hljs-number"><span class="hljs-number">0.036</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.835</span></span> SS_AB: train = <span class="hljs-number"><span class="hljs-number">0.827</span></span> (<span class="hljs-number"><span class="hljs-number">0.049</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.823</span></span> SS_NB: train = <span class="hljs-number"><span class="hljs-number">0.756</span></span> (<span class="hljs-number"><span class="hljs-number">0.046</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.751</span></span></code> </pre> <br>  Comme on dit, des chiffons aux richesses: la méthode des vecteurs supports («SVC»), alimentée par des données standardisées, a fait le reste, montrant un excellent résultat.  Lors de la vérification «manuelle», en comparant les valeurs des variables <i>Y_test</i> et <i>predictions_SS [6]</i> , l'algorithme n'a pas mâché seulement quelques valeurs. <br><br>  Ensuite, le même code est exécuté pour les fonctions MinMaxScaler (mise à l'échelle) et Normalizer (normalisation).  Je ne donnerai pas le code complet dans l'article.  Vous pouvez le télécharger depuis mon référentiel sur GitHub: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">lien</a> . <br><br>  N'oubliez pas de vous arrêter un moment et de vous moquer de vous à des fins éducatives uniquement!  :) <br><br>  Par conséquent, après avoir parcouru tout le code, nous obtenons les résultats suivants: <br><br><pre> <code class="python hljs">LR: train = <span class="hljs-number"><span class="hljs-number">0.957</span></span> (<span class="hljs-number"><span class="hljs-number">0.014</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.948</span></span> LDA: train = <span class="hljs-number"><span class="hljs-number">0.951</span></span> (<span class="hljs-number"><span class="hljs-number">0.014</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.946</span></span> KNN: train = <span class="hljs-number"><span class="hljs-number">0.985</span></span> (<span class="hljs-number"><span class="hljs-number">0.013</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.981</span></span> CART: train = <span class="hljs-number"><span class="hljs-number">0.843</span></span> (<span class="hljs-number"><span class="hljs-number">0.033</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.830</span></span> NB: train = <span class="hljs-number"><span class="hljs-number">0.819</span></span> (<span class="hljs-number"><span class="hljs-number">0.048</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.806</span></span> LSVC: train = <span class="hljs-number"><span class="hljs-number">0.942</span></span> (<span class="hljs-number"><span class="hljs-number">0.017</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.928</span></span> SVC: train = <span class="hljs-number"><span class="hljs-number">0.343</span></span> (<span class="hljs-number"><span class="hljs-number">0.079</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.342</span></span> MLP: train = <span class="hljs-number"><span class="hljs-number">0.972</span></span> (<span class="hljs-number"><span class="hljs-number">0.012</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.961</span></span> BG: train = <span class="hljs-number"><span class="hljs-number">0.952</span></span> (<span class="hljs-number"><span class="hljs-number">0.021</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.941</span></span> RF: train = <span class="hljs-number"><span class="hljs-number">0.968</span></span> (<span class="hljs-number"><span class="hljs-number">0.017</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.965</span></span> ET: train = <span class="hljs-number"><span class="hljs-number">0.980</span></span> (<span class="hljs-number"><span class="hljs-number">0.010</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.975</span></span> AB: train = <span class="hljs-number"><span class="hljs-number">0.827</span></span> (<span class="hljs-number"><span class="hljs-number">0.049</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.823</span></span> GB: train = <span class="hljs-number"><span class="hljs-number">0.964</span></span> (<span class="hljs-number"><span class="hljs-number">0.013</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.968</span></span> SS_LR: train = <span class="hljs-number"><span class="hljs-number">0.958</span></span> (<span class="hljs-number"><span class="hljs-number">0.015</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.949</span></span> SS_LDA: train = <span class="hljs-number"><span class="hljs-number">0.951</span></span> (<span class="hljs-number"><span class="hljs-number">0.014</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.946</span></span> SS_KNN: train = <span class="hljs-number"><span class="hljs-number">0.968</span></span> (<span class="hljs-number"><span class="hljs-number">0.023</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.970</span></span> SS_CART: train = <span class="hljs-number"><span class="hljs-number">0.853</span></span> (<span class="hljs-number"><span class="hljs-number">0.036</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.835</span></span> SS_NB: train = <span class="hljs-number"><span class="hljs-number">0.756</span></span> (<span class="hljs-number"><span class="hljs-number">0.046</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.751</span></span> SS_LSVC: train = <span class="hljs-number"><span class="hljs-number">0.945</span></span> (<span class="hljs-number"><span class="hljs-number">0.018</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.941</span></span> SS_SVC: train = <span class="hljs-number"><span class="hljs-number">0.976</span></span> (<span class="hljs-number"><span class="hljs-number">0.015</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.990</span></span> SS_MLP: train = <span class="hljs-number"><span class="hljs-number">0.976</span></span> (<span class="hljs-number"><span class="hljs-number">0.012</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.973</span></span> SS_BG: train = <span class="hljs-number"><span class="hljs-number">0.947</span></span> (<span class="hljs-number"><span class="hljs-number">0.018</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.948</span></span> SS_RF: train = <span class="hljs-number"><span class="hljs-number">0.973</span></span> (<span class="hljs-number"><span class="hljs-number">0.016</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.970</span></span> SS_ET: train = <span class="hljs-number"><span class="hljs-number">0.980</span></span> (<span class="hljs-number"><span class="hljs-number">0.012</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.975</span></span> SS_AB: train = <span class="hljs-number"><span class="hljs-number">0.827</span></span> (<span class="hljs-number"><span class="hljs-number">0.049</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.823</span></span> SS_GB: train = <span class="hljs-number"><span class="hljs-number">0.964</span></span> (<span class="hljs-number"><span class="hljs-number">0.013</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.968</span></span> MMS_LR: train = <span class="hljs-number"><span class="hljs-number">0.961</span></span> (<span class="hljs-number"><span class="hljs-number">0.013</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.953</span></span> MMS_LDA: train = <span class="hljs-number"><span class="hljs-number">0.951</span></span> (<span class="hljs-number"><span class="hljs-number">0.014</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.946</span></span> MMS_KNN: train = <span class="hljs-number"><span class="hljs-number">0.985</span></span> (<span class="hljs-number"><span class="hljs-number">0.013</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.981</span></span> MMS_CART: train = <span class="hljs-number"><span class="hljs-number">0.850</span></span> (<span class="hljs-number"><span class="hljs-number">0.027</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.840</span></span> MMS_NB: train = <span class="hljs-number"><span class="hljs-number">0.796</span></span> (<span class="hljs-number"><span class="hljs-number">0.045</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.786</span></span> MMS_LSVC: train = <span class="hljs-number"><span class="hljs-number">0.964</span></span> (<span class="hljs-number"><span class="hljs-number">0.012</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.958</span></span> MMS_SVC: train = <span class="hljs-number"><span class="hljs-number">0.963</span></span> (<span class="hljs-number"><span class="hljs-number">0.016</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.956</span></span> MMS_MLP: train = <span class="hljs-number"><span class="hljs-number">0.972</span></span> (<span class="hljs-number"><span class="hljs-number">0.011</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.963</span></span> MMS_BG: train = <span class="hljs-number"><span class="hljs-number">0.948</span></span> (<span class="hljs-number"><span class="hljs-number">0.024</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.946</span></span> MMS_RF: train = <span class="hljs-number"><span class="hljs-number">0.973</span></span> (<span class="hljs-number"><span class="hljs-number">0.014</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.968</span></span> MMS_ET: train = <span class="hljs-number"><span class="hljs-number">0.983</span></span> (<span class="hljs-number"><span class="hljs-number">0.010</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.981</span></span> MMS_AB: train = <span class="hljs-number"><span class="hljs-number">0.827</span></span> (<span class="hljs-number"><span class="hljs-number">0.049</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.823</span></span> MMS_GB: train = <span class="hljs-number"><span class="hljs-number">0.963</span></span> (<span class="hljs-number"><span class="hljs-number">0.013</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.968</span></span> N_LR: train = <span class="hljs-number"><span class="hljs-number">0.938</span></span> (<span class="hljs-number"><span class="hljs-number">0.020</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.919</span></span> N_LDA: train = <span class="hljs-number"><span class="hljs-number">0.952</span></span> (<span class="hljs-number"><span class="hljs-number">0.013</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.949</span></span> N_KNN: train = <span class="hljs-number"><span class="hljs-number">0.981</span></span> (<span class="hljs-number"><span class="hljs-number">0.012</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.985</span></span> N_CART: train = <span class="hljs-number"><span class="hljs-number">0.834</span></span> (<span class="hljs-number"><span class="hljs-number">0.028</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.825</span></span> N_NB: train = <span class="hljs-number"><span class="hljs-number">0.825</span></span> (<span class="hljs-number"><span class="hljs-number">0.043</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.805</span></span> N_LSVC: train = <span class="hljs-number"><span class="hljs-number">0.960</span></span> (<span class="hljs-number"><span class="hljs-number">0.014</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.953</span></span> N_SVC: train = <span class="hljs-number"><span class="hljs-number">0.551</span></span> (<span class="hljs-number"><span class="hljs-number">0.053</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.586</span></span> N_MLP: train = <span class="hljs-number"><span class="hljs-number">0.963</span></span> (<span class="hljs-number"><span class="hljs-number">0.018</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.946</span></span> N_BG: train = <span class="hljs-number"><span class="hljs-number">0.949</span></span> (<span class="hljs-number"><span class="hljs-number">0.016</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.938</span></span> N_RF: train = <span class="hljs-number"><span class="hljs-number">0.973</span></span> (<span class="hljs-number"><span class="hljs-number">0.015</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.970</span></span> N_ET: train = <span class="hljs-number"><span class="hljs-number">0.982</span></span> (<span class="hljs-number"><span class="hljs-number">0.012</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.980</span></span> N_AB: train = <span class="hljs-number"><span class="hljs-number">0.825</span></span> (<span class="hljs-number"><span class="hljs-number">0.040</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.820</span></span> N_GB: train = <span class="hljs-number"><span class="hljs-number">0.953</span></span> (<span class="hljs-number"><span class="hljs-number">0.022</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.956</span></span></code> </pre> <br>  Résultats du «Top 5»: <br><br><pre> <code class="python hljs">SS_SVC: train = <span class="hljs-number"><span class="hljs-number">0.976</span></span> (<span class="hljs-number"><span class="hljs-number">0.015</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.990</span></span> N_KNN: train = <span class="hljs-number"><span class="hljs-number">0.981</span></span> (<span class="hljs-number"><span class="hljs-number">0.012</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.985</span></span> KNN: train = <span class="hljs-number"><span class="hljs-number">0.985</span></span> (<span class="hljs-number"><span class="hljs-number">0.013</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.981</span></span> MMS_KNN: train = <span class="hljs-number"><span class="hljs-number">0.985</span></span> (<span class="hljs-number"><span class="hljs-number">0.013</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.981</span></span> MMS_ET: train = <span class="hljs-number"><span class="hljs-number">0.983</span></span> (<span class="hljs-number"><span class="hljs-number">0.010</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.981</span></span></code> </pre> <br>  Ainsi, selon les résultats d'un test éclair d'algorithmes d'apprentissage automatique pour résoudre le problème de classification de l'ensemble de données `` chiffres '', les algorithmes d'apprentissage automatique les plus appropriés sont: la méthode k-voisins les plus proches ('KNN'), la méthode des vecteurs de support ('SVC') et les arbres supplémentaires («ET»).  Ces algorithmes devraient faire l'objet d'une plus grande attention au développement ultérieur des résultats visant à accroître l'efficacité des calculs.  Tout, comme on dit, est résoluble. <br><br>  Et sur cette note soulevée, passez en douceur à la 2ème partie. <br><br><h3>  Problème de prévision </h3><br>  On bouge sur le pouce: <br><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment">#      from sklearn.datasets import load_boston from sklearn.model_selection import train_test_split from sklearn.linear_model import LinearRegression from sklearn.linear_model import Ridge from sklearn.linear_model import Lasso from sklearn.linear_model import ElasticNet from sklearn.linear_model import LarsCV from sklearn.linear_model import BayesianRidge from sklearn.neighbors import KNeighborsRegressor from sklearn.tree import DecisionTreeRegressor from sklearn.svm import LinearSVR from sklearn.svm import SVR from sklearn.ensemble import AdaBoostRegressor from sklearn.ensemble import BaggingRegressor from sklearn.ensemble import ExtraTreesRegressor from sklearn.ensemble import GradientBoostingRegressor from sklearn.ensemble import RandomForestRegressor from sklearn.model_selection import KFold from sklearn.model_selection import cross_val_score from sklearn.pipeline import Pipeline from sklearn.preprocessing import StandardScaler from sklearn.preprocessing import Normalizer from matplotlib import pyplot #    dataset = load_boston()</span></span></code> </pre> <br>  Exécutez le code et traitez le dictionnaire.  La description et les clés sont les suivantes: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/1e2/80f/4e2/1e280f4e239b31bae42274ab21c42d29.png" alt="image"><br><br><img src="https://habrastorage.org/getpro/habr/post_images/24a/448/05a/24a44805af40951d544ef8cc6637c52a.png" alt="image"><br><br>  Nous attribuons la clé `` données '' à la variable <i>X</i> , qui est un tableau NumPy multidimensionnel avec un ensemble d'attributs, dimensionnez 506 lignes par 13 colonnes, et la variable <i>Y</i> - `` cible '', un tableau NumPy multidimensionnel avec un marqueur pour chaque ligne. <br><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment">#    #dataset = load_boston() X = dataset.data Y = dataset.target</span></span></code> </pre> <br>  Nous divisons l'ensemble de données en parties de formation et de test, configurons les paramètres d'évaluation des algorithmes.  Dans le paramètre «scoring», nous définissons l'une des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">métriques «r2»</a> traditionnelles pour l'analyse de régression: <br><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment">#    dataset = load_boston() X = dataset.data Y = dataset.target #         test_size = 0.2 seed = 7 X_train, X_test, Y_train, Y_test = train_test_split(X, Y, test_size=test_size, random_state=seed) #     num_folds = 10 n_iter = 1000 n_estimators = 100 scoring = 'r2'</span></span></code> </pre> <br>  R2 - coefficient de détermination - c'est la proportion de la variance de la variable dépendante, expliquée par le modèle en question ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">lien</a> ). <br><br>  <i>«Le coefficient de détermination pour un modèle avec une constante prend des valeurs de 0 à 1. Plus le coefficient est proche de 1, plus la dépendance est forte.</i>  <i>Lors de l'évaluation des modèles de régression, cela est interprété comme faisant correspondre le modèle aux données.</i>  <i>Pour les modèles acceptables, on suppose que le coefficient de détermination doit être d'au moins 50% (dans ce cas, le coefficient de corrélation multiple dépasse 70% modulo).</i>  <i>Les modèles avec un coefficient de détermination supérieur à 80% peuvent être considérés comme assez bons (le coefficient de corrélation dépasse 90%).</i>  <i>L'égalité du coefficient de détermination à l'unité signifie que la variable expliquée est exactement décrite par le modèle considéré »</i> (ibid.). <br><br>  Pour résoudre le problème de prévision, nous utilisons les algorithmes suivants: <br><br><h4>  Algorithmes linéaires: </h4><br>  - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Régression linéaire</a> («LR») <br>  - Régression de crête (régression de crête) / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Régression de crête</a> («R») <br>  - Régression Lasso (de l'anglais LASSO - Opérateur de retrait et de sélection le moins absolu) / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Régression Lasso</a> ('L') <br>  - Méthode de régression <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Elastic Net Regression</a> («ELN») <br>  - Méthode de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">régression du moindre angle</a> (LARS) («LARS») <br>  - Régression de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">la crête bayésienne</a> / régression de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">la crête bayésienne</a> («BR») <br><br><h4>  Algorithmes non linéaires: </h4><br>  - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Méthode du régresseur k-voisins les plus proches</a> («KNR») <br>  - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Régresseur d'arbre de décision</a> («DTR») <br>  - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Machine à vecteur de support linéaire</a> (régression) / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Machine à vecteur de support linéaire - Régression</a> / ('LSVR') <br>  - Méthode de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">vecteur de support</a> (régression) / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Régression de vecteur de support Epsilon</a> ('SVR') <br><br><h4>  Algorithmes d'ensemble: </h4><br>  - AdaBoost (régression) / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">AdaBoost Regressor</a> ('ABR') (AdaBoost = Adaptive Boosting) <br>  - Ensachage (régression) / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Régresseur d'ensachage</a> ('BR') (Ensachage = agrégation Bootstrap) <br>  - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Régresseur d'arbres supplémentaires</a> («ETR») <br>  - Augmentation du gradient (régression) / Régression de l'augmentation du <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">gradient</a> ('GBR') <br>  - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Classification aléatoire des forêts</a> (régression) / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Random Forest Classifier</a> («RFR») <br><br>  Ainsi, la liste des «modèles» contient les modèles suivants: <br><br><pre> <code class="python hljs">models = [] models.append((<span class="hljs-string"><span class="hljs-string">'LR'</span></span>, LinearRegression())) models.append((<span class="hljs-string"><span class="hljs-string">'R'</span></span>, Ridge())) models.append((<span class="hljs-string"><span class="hljs-string">'L'</span></span>, Lasso())) models.append((<span class="hljs-string"><span class="hljs-string">'ELN'</span></span>, ElasticNet())) models.append((<span class="hljs-string"><span class="hljs-string">'LARS'</span></span>, Lars())) models.append((<span class="hljs-string"><span class="hljs-string">'BR'</span></span>, BayesianRidge(n_iter=n_iter))) models.append((<span class="hljs-string"><span class="hljs-string">'KNR'</span></span>, KNeighborsRegressor())) models.append((<span class="hljs-string"><span class="hljs-string">'DTR'</span></span>, DecisionTreeRegressor())) models.append((<span class="hljs-string"><span class="hljs-string">'LSVR'</span></span>, LinearSVR())) models.append((<span class="hljs-string"><span class="hljs-string">'SVR'</span></span>, SVR())) models.append((<span class="hljs-string"><span class="hljs-string">'ABR'</span></span>, AdaBoostRegressor(n_estimators=n_estimators))) models.append((<span class="hljs-string"><span class="hljs-string">'BR'</span></span>, BaggingRegressor(n_estimators=n_estimators))) models.append((<span class="hljs-string"><span class="hljs-string">'ETR'</span></span>, ExtraTreesRegressor(n_estimators=n_estimators))) models.append((<span class="hljs-string"><span class="hljs-string">'GBR'</span></span>, GradientBoostingRegressor(n_estimators=n_estimators))) models.append((<span class="hljs-string"><span class="hljs-string">'RFR'</span></span>, RandomForestRegressor(n_estimators=n_estimators)))</code> </pre> <br>  Comme pour la classification, l'évaluation de l'efficacité de chaque algorithme se fait par validation croisée.  Le message affiché contient les informations suivantes: le nom du modèle sous la forme d'une abréviation, le score moyen d'une validation croisée 10 fois sur les données d'entraînement (métrique `` r2 ''), l'écart type et le coefficient de détermination r2 sur les données de test sont indiqués entre parenthèses. <br><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment">#      scores = [] names = [] results = [] predictions = [] msg_row = [] for name, model in models: kfold = KFold(n_splits=num_folds, random_state=seed) cv_results = cross_val_score(model, X_train, Y_train, cv=kfold, scoring=scoring) names.append(name) results.append(cv_results) m_fit = model.fit(X_train, Y_train) m_predict = model.predict(X_test) predictions.append(m_predict) m_score = model.score(X_test, Y_test) scores.append(m_score) msg = "%s: train = %.3f (%.3f) / test = %.3f" % (name, cv_results.mean(), cv_results.std(), m_score) msg_row.append(msg) print(msg) #   («  ») fig = pyplot.figure() fig.suptitle('   ') ax = fig.add_subplot(111) red_square = dict(markerfacecolor='r', marker='s') pyplot.boxplot(results, flierprops=red_square) ax.set_xticklabels(names, rotation=45) pyplot.show()</span></span></code> </pre> <br>  Après avoir exécuté le code, nous obtenons les résultats suivants: <br><br><pre> <code class="python hljs">LR: train = <span class="hljs-number"><span class="hljs-number">0.746</span></span> (<span class="hljs-number"><span class="hljs-number">0.068</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.579</span></span> R: train = <span class="hljs-number"><span class="hljs-number">0.744</span></span> (<span class="hljs-number"><span class="hljs-number">0.067</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.570</span></span> L: train = <span class="hljs-number"><span class="hljs-number">0.689</span></span> (<span class="hljs-number"><span class="hljs-number">0.070</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.641</span></span> ELN: train = <span class="hljs-number"><span class="hljs-number">0.677</span></span> (<span class="hljs-number"><span class="hljs-number">0.074</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.662</span></span> LARS: train = <span class="hljs-number"><span class="hljs-number">0.744</span></span> (<span class="hljs-number"><span class="hljs-number">0.069</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.579</span></span> BR: train = <span class="hljs-number"><span class="hljs-number">0.739</span></span> (<span class="hljs-number"><span class="hljs-number">0.069</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.571</span></span> KNR: train = <span class="hljs-number"><span class="hljs-number">0.434</span></span> (<span class="hljs-number"><span class="hljs-number">0.288</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.538</span></span> DTR: train = <span class="hljs-number"><span class="hljs-number">0.671</span></span> (<span class="hljs-number"><span class="hljs-number">0.145</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.637</span></span> LSVR: train = <span class="hljs-number"><span class="hljs-number">0.550</span></span> (<span class="hljs-number"><span class="hljs-number">0.144</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.459</span></span> SVR: train = <span class="hljs-number"><span class="hljs-number">-0.012</span></span> (<span class="hljs-number"><span class="hljs-number">0.048</span></span>) / test = <span class="hljs-number"><span class="hljs-number">-0.003</span></span> ABR: train = <span class="hljs-number"><span class="hljs-number">0.810</span></span> (<span class="hljs-number"><span class="hljs-number">0.078</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.763</span></span> BR: train = <span class="hljs-number"><span class="hljs-number">0.854</span></span> (<span class="hljs-number"><span class="hljs-number">0.064</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.805</span></span> ETR: train = <span class="hljs-number"><span class="hljs-number">0.889</span></span> (<span class="hljs-number"><span class="hljs-number">0.047</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.836</span></span> GBR: train = <span class="hljs-number"><span class="hljs-number">0.878</span></span> (<span class="hljs-number"><span class="hljs-number">0.042</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.863</span></span> RFR: train = <span class="hljs-number"><span class="hljs-number">0.852</span></span> (<span class="hljs-number"><span class="hljs-number">0.068</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.819</span></span></code> </pre> <br>  Tableau de portée: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/2a7/140/96c/2a714096c35498ccddc267298f502a6a.png" alt="image"><br><br>  Les leaders évidents sont les méthodes d'ensemble 'GBR' (gradient 'boosting'), 'ETR' (extra-trees), 'RFR' (random forest) et 'BR' ('bagging'): <br><br><pre> <code class="python hljs">GBR: train = <span class="hljs-number"><span class="hljs-number">0.878</span></span> (<span class="hljs-number"><span class="hljs-number">0.042</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.863</span></span> ETR: train = <span class="hljs-number"><span class="hljs-number">0.889</span></span> (<span class="hljs-number"><span class="hljs-number">0.047</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.836</span></span> RFR: train = <span class="hljs-number"><span class="hljs-number">0.852</span></span> (<span class="hljs-number"><span class="hljs-number">0.068</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.819</span></span> BR: train = <span class="hljs-number"><span class="hljs-number">0.854</span></span> (<span class="hljs-number"><span class="hljs-number">0.064</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.805</span></span> ABR: train = <span class="hljs-number"><span class="hljs-number">0.810</span></span> (<span class="hljs-number"><span class="hljs-number">0.078</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.763</span></span> ELN: train = <span class="hljs-number"><span class="hljs-number">0.677</span></span> (<span class="hljs-number"><span class="hljs-number">0.074</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.662</span></span> L: train = <span class="hljs-number"><span class="hljs-number">0.689</span></span> (<span class="hljs-number"><span class="hljs-number">0.070</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.641</span></span> DTR: train = <span class="hljs-number"><span class="hljs-number">0.671</span></span> (<span class="hljs-number"><span class="hljs-number">0.145</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.637</span></span> LR: train = <span class="hljs-number"><span class="hljs-number">0.746</span></span> (<span class="hljs-number"><span class="hljs-number">0.068</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.579</span></span> LARS: train = <span class="hljs-number"><span class="hljs-number">0.744</span></span> (<span class="hljs-number"><span class="hljs-number">0.069</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.579</span></span> BR: train = <span class="hljs-number"><span class="hljs-number">0.739</span></span> (<span class="hljs-number"><span class="hljs-number">0.069</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.571</span></span> R: train = <span class="hljs-number"><span class="hljs-number">0.744</span></span> (<span class="hljs-number"><span class="hljs-number">0.067</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.570</span></span> KNR: train = <span class="hljs-number"><span class="hljs-number">0.434</span></span> (<span class="hljs-number"><span class="hljs-number">0.288</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.538</span></span> LSVR: train = <span class="hljs-number"><span class="hljs-number">0.550</span></span> (<span class="hljs-number"><span class="hljs-number">0.144</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.459</span></span> SVR: train = <span class="hljs-number"><span class="hljs-number">-0.012</span></span> (<span class="hljs-number"><span class="hljs-number">0.048</span></span>) / test = <span class="hljs-number"><span class="hljs-number">-0.003</span></span></code> </pre> <br>  Un "adabust", une sorte de "loshara", est en retard. <br><br>  Peut-être que les trois dirigeants peignent la normalisation et la normalisation.  Découvrons-le en exécutant le reste du code. <br><br>  Les résultats sont les suivants: <br><br><pre> <code class="python hljs">SS_LR: train = <span class="hljs-number"><span class="hljs-number">0.746</span></span> (<span class="hljs-number"><span class="hljs-number">0.068</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.579</span></span> SS_R: train = <span class="hljs-number"><span class="hljs-number">0.746</span></span> (<span class="hljs-number"><span class="hljs-number">0.068</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.578</span></span> SS_L: train = <span class="hljs-number"><span class="hljs-number">0.678</span></span> (<span class="hljs-number"><span class="hljs-number">0.054</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.510</span></span> SS_ELN: train = <span class="hljs-number"><span class="hljs-number">0.665</span></span> (<span class="hljs-number"><span class="hljs-number">0.060</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.513</span></span> SS_LARS: train = <span class="hljs-number"><span class="hljs-number">0.744</span></span> (<span class="hljs-number"><span class="hljs-number">0.069</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.579</span></span> SS_BR: train = <span class="hljs-number"><span class="hljs-number">0.746</span></span> (<span class="hljs-number"><span class="hljs-number">0.066</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.576</span></span> SS_KNR: train = <span class="hljs-number"><span class="hljs-number">0.763</span></span> (<span class="hljs-number"><span class="hljs-number">0.098</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.739</span></span> SS_DTR: train = <span class="hljs-number"><span class="hljs-number">0.610</span></span> (<span class="hljs-number"><span class="hljs-number">0.242</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.629</span></span> SS_LSVR: train = <span class="hljs-number"><span class="hljs-number">0.727</span></span> (<span class="hljs-number"><span class="hljs-number">0.091</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.482</span></span> SS_SVR: train = <span class="hljs-number"><span class="hljs-number">0.653</span></span> (<span class="hljs-number"><span class="hljs-number">0.126</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.610</span></span> SS_ABR: train = <span class="hljs-number"><span class="hljs-number">0.811</span></span> (<span class="hljs-number"><span class="hljs-number">0.076</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.819</span></span> SS_BR: train = <span class="hljs-number"><span class="hljs-number">0.853</span></span> (<span class="hljs-number"><span class="hljs-number">0.074</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.813</span></span> SS_ETR: train = <span class="hljs-number"><span class="hljs-number">0.887</span></span> (<span class="hljs-number"><span class="hljs-number">0.048</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.846</span></span> SS_GBR: train = <span class="hljs-number"><span class="hljs-number">0.878</span></span> (<span class="hljs-number"><span class="hljs-number">0.038</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.860</span></span> SS_RFR: train = <span class="hljs-number"><span class="hljs-number">0.851</span></span> (<span class="hljs-number"><span class="hljs-number">0.071</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.818</span></span> N_LR: train = <span class="hljs-number"><span class="hljs-number">0.751</span></span> (<span class="hljs-number"><span class="hljs-number">0.099</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.576</span></span> N_R: train = <span class="hljs-number"><span class="hljs-number">0.287</span></span> (<span class="hljs-number"><span class="hljs-number">0.126</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.271</span></span> N_L: train = <span class="hljs-number"><span class="hljs-number">-0.030</span></span> (<span class="hljs-number"><span class="hljs-number">0.032</span></span>) / test = <span class="hljs-number"><span class="hljs-number">-0.000</span></span> N_ELN: train = <span class="hljs-number"><span class="hljs-number">-0.007</span></span> (<span class="hljs-number"><span class="hljs-number">0.030</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.023</span></span> N_LARS: train = <span class="hljs-number"><span class="hljs-number">0.751</span></span> (<span class="hljs-number"><span class="hljs-number">0.099</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.576</span></span> N_BR: train = <span class="hljs-number"><span class="hljs-number">0.744</span></span> (<span class="hljs-number"><span class="hljs-number">0.100</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.589</span></span> N_KNR: train = <span class="hljs-number"><span class="hljs-number">0.485</span></span> (<span class="hljs-number"><span class="hljs-number">0.192</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.504</span></span> N_DTR: train = <span class="hljs-number"><span class="hljs-number">0.729</span></span> (<span class="hljs-number"><span class="hljs-number">0.080</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.765</span></span> N_LSVR: train = <span class="hljs-number"><span class="hljs-number">0.182</span></span> (<span class="hljs-number"><span class="hljs-number">0.108</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.136</span></span> N_SVR: train = <span class="hljs-number"><span class="hljs-number">0.086</span></span> (<span class="hljs-number"><span class="hljs-number">0.076</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.084</span></span> N_ABR: train = <span class="hljs-number"><span class="hljs-number">0.795</span></span> (<span class="hljs-number"><span class="hljs-number">0.053</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.752</span></span> N_BR: train = <span class="hljs-number"><span class="hljs-number">0.854</span></span> (<span class="hljs-number"><span class="hljs-number">0.054</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.827</span></span> N_ETR: train = <span class="hljs-number"><span class="hljs-number">0.877</span></span> (<span class="hljs-number"><span class="hljs-number">0.048</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.850</span></span> N_GBR: train = <span class="hljs-number"><span class="hljs-number">0.852</span></span> (<span class="hljs-number"><span class="hljs-number">0.063</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.872</span></span> N_RFR: train = <span class="hljs-number"><span class="hljs-number">0.852</span></span> (<span class="hljs-number"><span class="hljs-number">0.051</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.801</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Comme vous pouvez le voir, les méthodes d'ensemble sont toujours en avance sur tout le monde. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">«Top 5» contient les résultats suivants:</font></font><br><br><pre> <code class="python hljs">N_GBR: train = <span class="hljs-number"><span class="hljs-number">0.852</span></span> (<span class="hljs-number"><span class="hljs-number">0.063</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.872</span></span> GBR: train = <span class="hljs-number"><span class="hljs-number">0.878</span></span> (<span class="hljs-number"><span class="hljs-number">0.042</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.863</span></span> SS_GBR: train = <span class="hljs-number"><span class="hljs-number">0.878</span></span> (<span class="hljs-number"><span class="hljs-number">0.038</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.860</span></span> N_ETR: train = <span class="hljs-number"><span class="hljs-number">0.877</span></span> (<span class="hljs-number"><span class="hljs-number">0.048</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.850</span></span> SS_ETR: train = <span class="hljs-number"><span class="hljs-number">0.887</span></span> (<span class="hljs-number"><span class="hljs-number">0.048</span></span>) / test = <span class="hljs-number"><span class="hljs-number">0.846</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous afficherons un tableau comparant les résultats: le </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/8b1/9a0/cc6/8b19a0cc6379c2337c9082eedd415585.jpg" alt="image"><br><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">test Y</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> est la norme. Les cinq résultats sélectionnés montrés dans le diagramme sont indiqués par une ligne pointillée. On peut voir que tous les pics ont été reproduits soit avec répétition exacte, soit à un degré ou à un autre. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bref extrait de comparaison manuelle des valeurs de référence et des valeurs prévisionnelles de l'algorithme inclus dans le Top 5: </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/711/0a7/2de/7110a72de1daa81209ecaee33542dfef.png" alt="image"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ainsi, selon les résultats d'un test de blitz d'algorithmes d'apprentissage automatique pour résoudre le problème de la prévision de l'ensemble de données «Boston House-Price», les algorithmes les plus appropriés sont le «boosting» de gradient («GBR ») et d'arbres supplémentaires (« ETR »). Ces algorithmes doivent faire l'objet d'une attention accrue afin de développer davantage les résultats et d'améliorer l'efficacité des prévisions.</font></font><br><br><h3>  Postface </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Une vérification rapide des algorithmes d'apprentissage automatique permet, en première approximation, d'identifier les algorithmes les plus efficaces pour résoudre les problèmes de classification et d'analyse de régression (prévision). Nous en avons été convaincus en traitant l'ensemble de données «digits», en triant brillamment les instances en 10 classes, ainsi que l'ensemble de données «boston house-price», en triant «étonnamment» la recherche de dépendances et en faisant une prévision «fluctuante» de la variable dépendante. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vous êtes invité à essayer cette méthode sur vos propres ensembles de données ou sur ceux que vous pouvez creuser dans différents référentiels, y compris GitHub. Par exemple: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">lien</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Obtenez un ensemble de données approprié pour la cible - et définissez un troupeau d'algorithmes dessus dans l'équipe du test de blitz. Et là, il devient clair dont la prise: un sur le terrain n'est pas un guerrier.</font></font> :) <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Et en conclusion. Je serai reconnaissant pour vos commentaires, questions et suggestions, car la base de cet article est l'information que je partage avec de nouveaux collègues sur chaque nouveau projet dans le domaine de l'apprentissage automatique. Chacun d'eux a sa propre spécialisation, à propos de l'apprentissage automatique et des réseaux de neurones artificiels, beaucoup d'entre eux ne sont «entendus que quelque part», il est donc important pour moi de parler de complexes, de multiples facettes et, enfin, imprenables (il s'agit de l'ANN et de l'apprentissage automatique en général) :), dans un langage simple et compréhensible; montrez que ce ne sont pas les dieux qui brûlent des pots; et que s'il y a un intérêt, alors plus d'une douzaine d'algorithmes peuvent être "exploités".</font></font> :) <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PS À la fin de l'article, j'ai déjà commencé à me prédire, donc aux questions à venir sur où j'ai obtenu la feuille de triche dans le premier chiffre que je donne: tout sur le même site scikit-learn.org ( </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">`` Choisir le bon estimateur ''</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ): </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">lien</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Et la personnification de l'intelligence artificielle sous la forme d'un Samodelkin rougi est ainsi des vagues de la mémoire de mon enfance heureuse.</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr475552/">https://habr.com/ru/post/fr475552/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr475542/index.html">L'évolution du marketing par e-mail depuis 2013: 4 tendances principales et statistiques actuelles</a></li>
<li><a href="../fr475544/index.html">Catalogues de produits, services et plus</a></li>
<li><a href="../fr475546/index.html">Syndromes addictifs IT</a></li>
<li><a href="../fr475548/index.html">Matchmaking ennuyeux sans déséquilibre et files d'attente: un guide pratique</a></li>
<li><a href="../fr475550/index.html">Systèmes acoustiques pour pièces ouvertes</a></li>
<li><a href="../fr475554/index.html">Techniques de conception d'interface utilisateur qui font gagner du temps</a></li>
<li><a href="../fr475556/index.html">Déménagement à Munich. Le chemin Scalors d'Amazon vers le travail de rêve d'Amazon</a></li>
<li><a href="../fr475558/index.html">Dictionnaire informatique ou quoi? O?? Où aller? Partie 1</a></li>
<li><a href="../fr475560/index.html">KotlinConf 2019 Live: Regardez en direct les 5 et 6 décembre</a></li>
<li><a href="../fr475562/index.html">MVC dans Unity avec des objets scriptables. Partie 1</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>