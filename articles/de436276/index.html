<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§¥ üë©üèø‚Äçü§ù‚Äçüë©üèº üîõ Dreidimensionale Visualisierung in Simulatoren von Fahrzeugen basierend auf der OpenSceneGraph-Engine üèÇ üíú üôåüèΩ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Vor etwas weniger als einem Jahr wurde eine Ver√∂ffentlichung ver√∂ffentlicht, in der wir √ºber den Trainings- und Laborkomplex (ULK) des von unserer Uni...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Dreidimensionale Visualisierung in Simulatoren von Fahrzeugen basierend auf der OpenSceneGraph-Engine</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/436276/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/bp/4h/_g/bp4h_g1ct8gq0ntec_7pe8pkan8.jpeg"></div><br><br>  Vor etwas weniger als einem Jahr wurde eine <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Ver√∂ffentlichung</a> ver√∂ffentlicht, in der wir √ºber den Trainings- und Laborkomplex (ULK) des von unserer Universit√§t entwickelten elektrischen Zuges ES1 Lastochka sprachen.  Dann versprach ich, dass dies nicht die letzte Ver√∂ffentlichung zu diesem Thema sein w√ºrde, insbesondere drohte ich, √ºber die Probleme bei der Erstellung einer dreidimensionalen Visualisierung f√ºr solche Simulatoren zu sprechen und die wichtigsten L√∂sungsans√§tze zu skizzieren. <br><br>  Letztes Jahr waren wir mit unserer n√§chsten Ver√∂ffentlichung zufrieden - dem ULK des elektrischen Hochgeschwindigkeitszuges EVS2 von Sapsan, der im August letzten Jahres stattfand.  Der Bildungs- und Laborkomplex dieses elektrischen Zuges selbst verdient eine eigene Geschichte, aber im Rahmen dieser Ver√∂ffentlichung werden wir √ºber die Wunde sprechen - das Problem der Schaffung eines ad√§quaten Subsystems der dreidimensionalen Visualisierung, das unser Team etwa zwei Jahre lang von zwei Seiten angesprochen hat.  Die Ver√∂ffentlichung des Sapsan-Simulators ist (unter anderem) von Bedeutung und hat den Entwicklungsvektor unserer Entwicklungen in diesem Bereich bestimmt. <br><a name="habracut"></a><br><h1>  1. Kurz √ºber ULK EVS2 ‚ÄûSapsan‚Äú </h1><br>  Ich m√∂chte noch einmal betonen (was ich mit beneidenswerter H√§ufigkeit mache), dass die an unserer Universit√§t entwickelten Bildungs- und Laborkomplexe von Schienenfahrzeugen nicht f√ºr die Vorbereitung von Lokomotivenbrigaden bestimmt sind.  Wie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">einer der Kommentatoren des</a> vorherigen Artikels zu Recht <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">feststellte</a> , handelt es sich bei unseren ULK nicht um Simulatoren, sondern um Simulatoren, bei denen der Schwerpunkt auf der kompetenten Umsetzung der Physik der Zugbewegung und der Simulation des Betriebs der Teilsysteme des rollenden Materials liegt, die dessen Bewegung und Stopp sicherstellen.  Der Sapsan-Simulator ist keine Ausnahme, bei der folgende Aufgaben gel√∂st werden: <br><br><ul><li>  Unter Ber√ºcksichtigung der L√§ngskr√§fte und des Gleisprofils wurde ein dynamisches Modell des mechanischen Teils des Zuges implementiert </li><li>  Es wurde ein detailliertes Computermodell f√ºr den Betrieb der wichtigsten Teilsysteme des elektrischen Zuges erstellt: Stromkreis, elektrischer Traktionsantrieb, pneumatische und elektropneumatische Bremsen </li><li>  Die grundlegenden Algorithmen f√ºr den Betrieb des elektrischen Zugsteuerungssystems auf verschiedenen Ebenen werden reproduziert. </li></ul><br>  Dar√ºber hinaus umfasst der Schulungs- und Laborkomplex ein Modell der Kabine des elektrischen Zuges in Originalgr√∂√üe mit den Hauptsteuerungen und Mitteln zur Anzeige von Informationen.  Im Gegensatz zum Swallows-Simulator wurde diese Kabine nicht von uns selbst hergestellt, sondern 2015 von einem B√ºro im Land gekauft, das Trainingssimulatoren herstellt.  Daher konzentrierte sich der Entwicklungsprozess des Simulators auf die Erstellung von Software. <br><br><div class="spoiler">  <b class="spoiler_title">Kabinenfoto</b> <div class="spoiler_text">  <i>Gesamtansicht des Kabineninneren</i> <br><img src="https://habrastorage.org/webt/ud/de/ic/uddeiczrsp23eszvl6tx6zwal7y.jpeg"><br><br>  <i>Blick durch die Windschutzscheibe</i> <br><img src="https://habrastorage.org/webt/r1/nz/kn/r1nzknpyastfa6b8iy6ghp2m4ic.jpeg"><br><br>  <i>Integrierte Sicherheitsvorrichtung f√ºr Lokomotiven (CLUB-U) anzeigen.</i>  <i>Das rote ‚Äû290‚Äú ist die aktuelle Geschwindigkeitsbegrenzung, die von der elektronischen CLUB-U-Karte erhalten wird.</i>  <i>Bisher zeigt sich hier das Tempolimit, das Sapsan mit der Oktoberbahn erreicht hat.</i>  <i>In Zukunft wird die elektronische Karte so implementiert, wie es im Leben geschieht.</i> <br><img src="https://habrastorage.org/webt/nt/on/-g/nton-ggphlulx1e0yxmznf_epnu.jpeg"><br><br>  <i>Hauptdisplay ‚ÄûMensch-Maschine-Schnittstelle‚Äú</i> <br><img src="https://habrastorage.org/webt/xk/kd/qk/xkkdqkxqznjjkl_vx-lfbdhys4w.jpeg"><br><br>  <i>Anzeige f√ºr den Status des Bremssystems des elektrischen Zuges</i> <br><img src="https://habrastorage.org/webt/ap/wl/qv/apwlqvuggyfjgwd_prliwn3hjck.jpeg"><br><br>  <i>Geschwindigkeitsregler und Traktionsregler</i> <br><img src="https://habrastorage.org/webt/u3/ok/nb/u3oknbv0nitjk-d7fcpqmywhxr4.jpeg"><br><br>  <i>Steuerung der elektrischen Zugbremssteuerung</i> <br><img src="https://habrastorage.org/webt/6k/mf/eg/6kmfegwxufy_317kqfvmp7n00k8.jpeg"><br><br>  <i>Kippschalter zur Steuerung von Stromabnehmern und Schutzeinrichtungen (BV / GV) - schwarze Kippschalter in der N√§he des Geschwindigkeitssetzers</i> <br><img src="https://habrastorage.org/webt/dn/gs/3p/dngs3pxzgoqcawtdewf84z8squc.jpeg"><br><br>  <i>Trainingsmanagement-Oberfl√§che - Routenauswahlbildschirm</i> <br><img src="https://habrastorage.org/webt/_n/sh/jp/_nshjpyo8nu8wbxalcfhtfowns0.jpeg"><br><br>  <i>Lautst√§rkeregelungsbildschirm f√ºr Audioeffekte</i> <br><img src="https://habrastorage.org/webt/ba/ll/p_/ballp_v52zh8rmq4iosfkicienw.jpeg"><br><br>  <i>Kilometerz√§hler.</i>  <i>Eine lustige Geschichte ist mit seinem Aussehen verbunden.</i>  <i>Als wir unseren ersten Simulator der Diesellokomotive 2TE116 √ºbergaben, scherzte der Kundenvertreter zu unserer Frage, wann der Fertigstellungsakt unterzeichnet wird: ‚ÄûNun, machen wir es wie im Leben - wenn eine neue Lokomotive in Betrieb genommen wird, muss sie eine Strecke von 5000 Kilometern zur√ºcklegen.</i>  <i>Das wird vergehen ... ".</i>  <i>Das Gesetz wurde nat√ºrlich viel fr√ºher unterzeichnet, aber um den Humor der Situation zu bewerten, haben wir bereits einen √§hnlichen Z√§hler auf dem Swallows-Simulator erstellt.</i>  <i>Der Z√§hler kann durch Eingabe des Servicekennworts auf "0" zur√ºckgesetzt werden.</i> <br><img src="https://habrastorage.org/webt/yo/hc/jq/yohcjqcfhoe8irnm6j3ynr9exby.jpeg"><br><br>  <i>Rechte Zubeh√∂rplatte mit Bremsdruckmessern und Notbremsventil.</i>  <i>Nicht alle in diesem Sapsan enthaltenen Elemente sind hier installiert - eine solche Fernbedienung wurde von uns vom Lieferanten erhalten</i> <br><img src="https://habrastorage.org/webt/fr/te/5l/frte5lrezbuss2ng2iesdqcl0p8.jpeg"><br><br>  <i>Daher wurden einige der f√ºr uns wichtigen Steuerelemente in Software implementiert, insbesondere das Bedienfeld der Bypass-Schalter, die √ºber den Touchscreen gesteuert werden</i> <br><img src="https://habrastorage.org/webt/he/c2/ga/hec2gahq08cziegrxl1qfkriqya.png"><br></div></div><br>  Die Entwicklung von Software f√ºr einen solchen Simulatorsimulator ist eine sehr weit gefasste Frage, und ich werde (nach besten Kr√§ften) versuchen, das Interesse der Leser an diesen Themen in Zukunft (falls vorhanden) zu befriedigen. Kehren wir jedoch zun√§chst zum Hauptthema des Artikels zur√ºck - der dreidimensionalen Visualisierung des Zugbewegungsprozesses. <br><br><h1>  2. Hintergrund und Technologie der Vergangenheit </h1><br>  In den Kommentaren zum letzten Artikel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">wurde eine Frage gestellt</a> , die mich ehrlich gesagt ziemlich am√ºsierte.  Ja, in der Tat wird dieser Ansatz in vielen heute noch verwendeten Simulatoren immer noch verwendet: Video wird auf einem realen Abschnitt der Eisenbahn aufgenommen und dann mit einer Geschwindigkeit, die proportional zur Bewegungsgeschwindigkeit ist, auf dem Simulator gescrollt.  Dies geschah nur, weil in jenen Tagen, als solche Simulatoren erstellt wurden, die Qualit√§t dreidimensionaler Grafiken zu w√ºnschen √ºbrig lie√ü, und dies galt auch f√ºr raue Grafikstationen auf kommerziellen Unixen, und es gab keine Frage eines PCs.  Daher z√∂gerten auch Hersteller von Computerspielen, beispielsweise <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">dieses</a> , nicht, diesen Ansatz zu verwenden. <br><br>  Das macht heute keinen Sinn, weil: <br><br><ol><li>  Die unzureichende Bildrate bei niedrigen Zuggeschwindigkeiten bietet nicht die gew√ºnschte Gl√§tte der Bildaktualisierung.  Wir werden die gesch√§tzten 25 fps nur bei der Geschwindigkeit haben, mit der das Video aus der Fahrerkabine aufgenommen wurde.  Und dieser fatale Fehler kann in keiner Weise behoben werden - weder durch Aufnahmen mit einer Hochgeschwindigkeitskamera (wie viel wiegt das mit 120 Bildern pro Sekunde aufgenommene Video? Das ist das gleiche ...) noch durch die programmierte Erzeugung von Zwischenbildern.  Letzteres wurde von uns mit OpenCV-Technologie durchgef√ºhrt, f√ºhrte jedoch nicht zu normalen Ergebnissen.  Diese Frage wurde wiederholt von allen Seiten untersucht, und als Ergebnis wurde der Schluss gezogen, dass die Kosten f√ºr Ressourcen zur Erstellung eines solchen Systems viel h√∂her sind als f√ºr die Entwicklung eines √§hnlichen Systems, jedoch basierend auf 3D-Grafiken </li><li>  Schwierigkeiten beim reibungslosen Zur√ºckbl√§ttern des Videos.  Und selbst wenn man bedenkt, dass sie √ºberwunden werden, wo werden dann die Hunde, die auf der Plattform laufen, rennen? Denken wir, wir sollten umgekehrt vorgehen? </li><li>  Das Fehlen aller "Interaktivit√§t".  Was tun mit einem Ampelwechsel, mit der Bewegung von Weichen, der Bewegung entgegenkommender und vorbeifahrender Z√ºge? </li></ol><br>  Daher werden alle modernen Simulatoren und Simulatoren mit interaktiven 3D-Grafiken erstellt, da es heute weder aus Software- noch aus Hardwaresicht Hindernisse gibt. <br><br>  Wenn aus Hardware-Sicht alles sehr klar ist - der anstelle der Windschutzscheibe installierte Monitor ist mit einer normalen Grafikkarte (nicht einmal der Top-End-Karte) an einen PC angeschlossen -, stellt sich aus Sicht der Software die Frage, welche Technologie f√ºr die Implementierung der Aufgabe ausgew√§hlt werden soll. <br><br><h1>  3. Die Grafik-Engine im Vergleich zur Game-Engine oder warum OpenSceneGraph ausgew√§hlt wurde </h1><br>  Ich kann mich irren, aber ich erwarte Kommentare im Voraus, die eine v√∂llig logische Frage stellen, warum unsere Wahl bei der Analyse bestehender Technologien nicht bei Mastodons wie Unity oder Unreal Engine 4 aufgeh√∂rt hat.  Ich werde diese Frage beantworten, au√üerdem werde ich meine Antwort rechtfertigen. <br><br>  Kurz gesagt - weder Unity noch Unreal Engine erf√ºllen die Anforderungen der zu l√∂senden Aufgabe.  Eine detailliertere Antwort enth√§lt zun√§chst eine Auflistung der betreffenden Anforderungen.  TK, zusammengestellt von uns auf dem Teilsystem der dreidimensionalen Visualisierung, enth√§lt (in absteigender Reihenfolge der Wichtigkeit) die folgenden Bestimmungen: <br><br><ol><li>  Unabh√§ngigkeit des Softwareentwicklungsprozesses des Visualisierungssubsystems und des Prozesses der Erstellung von Ressourcen daf√ºr.  Zu den Ressourcen geh√∂ren in diesem Fall dreidimensionale Modelle, Texturen sowie die sogenannten <i>Routen</i> .  Unter einer Route wird eine Kombination von Konfigurationsobjekten und Ressourcen verstanden, die es dem Videosubsystem erm√∂glichen, den gew√ºnschten Abschnitt der Eisenbahn anzuzeigen und die Bewegung des Zuges entlang dieser zu simulieren.  Dies beinhaltet auch die <i>M√∂glichkeit, die Route zu √§ndern, ohne den Softwareteil des Video-Subsystems neu zu erstellen</i> </li><li>  Erstellen Sie Routen mit unbegrenzter L√§nge.  Ich werde reservieren, dass eine unbegrenzte L√§nge aufgrund begrenzter Hardwareressourcen grunds√§tzlich nicht erreichbar ist.  Diese Anforderung sollte verstanden werden, dass die L√§nge der Route mindestens innerhalb einer ‚ÄûSchulter‚Äú liegen sollte, dh eines Stra√üenabschnitts zwischen den Wendepunkten, und dies ist in Abh√§ngigkeit von verschiedenen Faktoren eine ziemlich gro√üe Entfernung, die auf mehr als einhundert Kilometer gesch√§tzt wird.  Diese Anforderung erfordert ein dynamisches Laden / Entladen von Programmressourcen mit ausreichender Gl√§tte bei angemessenem Speicherverbrauch.  Und es ist w√ºnschenswert, dass die Engine solche Funktionen "out of the box" enth√§lt. </li><li>  Bequeme Integration in den verwendeten Technologie-Stack.  Aus objektiven Gr√ºnden verwendet unser Team traditionell die C ++ - Sprache mit Qt-Framework, QtCreator IDE und Git als Versionskontrollsystem f√ºr die Entwicklung von Software f√ºr ULK PS.  Als Systemplattform ULK PS wird ein auf dem Linux-Kernel basierendes Betriebssystem verwendet </li></ol><br>  Was ist los mit Unity und UE?  Was ist die Tatsache, dass andere Engines Ressourcen in v√∂llig anderen Formaten importieren k√∂nnen.  Beim Zusammenstellen des Projekts werden sie jedoch irreversibel in das interne Bin√§rformat konvertiert, wodurch das Hinzuf√ºgen und √Ñndern von Ressourcen ohne erneutes Zusammensetzen des Projekts unm√∂glich wird.  In Unity verf√ºgbare Technologien wie Fertigh√§user und Asset-Bundles l√∂sen das Problem nicht, da der Motoreneditor nicht der beste Ort ist, um Bahnstandorte zu erstellen. Dies erfordert die Erweiterung des Editors, was dazu f√ºhrt, dass ein ‚ÄûMotor im Motor‚Äú geschrieben werden muss.  Dar√ºber hinaus ist die Erstellung von Fertigh√§usern und Bundles ohne die Verwendung des Unity-Editors nicht m√∂glich, und dies ist, wie die Praxis gezeigt hat, insbesondere f√ºr reine Modellierer und Leveldesigner nicht sehr praktisch.  In Bezug auf die UE habe ich √ºber zwei Jahre hinweg viele Fragen zu dieser und anderen Ressourcen gestellt, wie der Prozess des Erstellens eines Projekts vom Prozess des Hinzuf√ºgens / √Ñnderns der verwendeten Ressourcen getrennt werden kann, und ich habe weder in der Dokumentation noch in ‚Äû eingefleischte "Spieleentwickler.  Ich w√ºrde mich sehr freuen (ohne Sarkasmus), wenn ich vern√ºnftigerweise auf etwas sto√üen w√ºrde, das ich verpasst habe. <br><br>  Was die zweite Anforderung betrifft, scheinen sowohl Unity als auch UE die M√∂glichkeit zu bieten, dynamisch geladene Speicherorte zu erstellen. Die Frage bleibt jedoch unbeantwortet, wie solche Speicherorte unabh√§ngig vom Editor und ohne Neuerstellung des Projekts erstellt werden k√∂nnen.  Es gibt nur einen Ausweg: Schreiben Sie eine ‚ÄûEngine in die Engine‚Äú, die die ‚ÄûRoh‚Äú -Geometrie und -Texturen (in einem der zuvor angegebenen Exportformate von 3D-Editoren) l√§dt, alle erforderlichen Effekte auf sie anwendet und sie basierend auf den von einem Drittanbieter beschriebenen Daten im Raum positioniert unabh√§ngig vom Motorformat, das noch entwickelt und gelehrt werden muss, um den Motor zu interpretieren. <br><br>  Im Zusammenhang mit dem oben Gesagten stellt sich die Frage: Wenn zur L√∂sung dieses Problems eine leistungsstarke Softwareschicht √ºber die Spiel-Engine geschrieben werden muss, deren Funktionalit√§t f√ºr das betreffende Problem gr√∂√ütenteils nicht ben√∂tigt wird, warum ben√∂tigen wir dann eine Spiel-Engine? <br><br>  Vielleicht reicht die Grafik-Engine?  Ich habe diese Frage dem vorherigen Team gestellt, das das zur Diskussion stehende Problem unter Berufung auf Unity angegangen ist (und nat√ºrlich etwas sp√§ter zusammengef√ºhrt hat).  Als Antwort erhielt er eine Gegenfrage: "Was schlagen Sie vor?", Auf die er antwortete, und im Geiste des obigen Textes erhielt er das sarkastische L√§cheln eines Gegners. <br><br>  Wenn Sie auf Sarkasmus verzichten, ist die vorgestellte Aufgabe eine typische Visualisierungsaufgabe - sie erfordert nur ein Framework f√ºr die Arbeit mit Grafiken, da sowohl die Physik als auch das auf Physik basierende Audio-Subsystem auf der Serverseite implementiert sind.  Mein Team und ich haben diese Tatsache verstanden, indem wir uns durch die Tr√§gheit fr√ºherer Entwickler zun√§chst in Richtung Unity durch UE bewegt und versucht haben, das Grafik-Subsystem von einem der offenen Eisenbahnsimulatoren (OpenBVE, das sich √ºbrigens herausstellte, aber es wurde zu einer vor√ºbergehenden Kr√ºcke) zu befestigen. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">OpenSceneGraph</a> ist mit Abstand die am weitesten entwickelte (offene und kostenlose) Grafik-Engine, die sich auf die C ++ - Entwicklung konzentriert.  Es wird im Ausland gerade zur technischen dreidimensionalen Visualisierung weit verbreitet.  Dieser Motor wurde von keinem Simulator verschont, von dem der bekannteste <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">FlightGear ist</a> .  Es gab einmal einen Eisenbahnsimulator, der auf diesem Motor basierte - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Indra</a> , der jedoch nur langweilige Screenshots des obigen Links hinterlie√ü und dessen weiteres Schicksal mir unbekannt ist. <br><br>  Im Rahmen der vorliegenden Aufgabe weist die OSG-Grafik-Engine die folgenden positiven Eigenschaften auf: <br><br><ul><li>  Plattform√ºbergreifend, wodurch es m√∂glich ist, es im GNU / Linux-√ñkosystem anzuwenden </li><li>  Die Entwicklungssprache ist C ++ / STL, was es erm√∂glicht, sie einfach und nat√ºrlich in den etablierten technologischen Entwicklungsprozess zu integrieren. </li><li>  Die gr√∂√üte Auswahl an Ressourcenformaten wird "out of the box" unterst√ºtzt - 3D-Geometrie und Texturen aufgrund des entwickelten Plug-In-Systems.  Eine einfache und intuitive Oberfl√§che zum Schreiben eigener Plug-Ins zum Einrichten des Ressourcenmanagers f√ºr nicht standardm√§√üige Formate, die wir verwendet haben (dar√ºber werde ich weiter unten schreiben). </li><li>  Ein Speicherverwaltungssystem, das auf einem propriet√§ren Modell von intelligenten Zeigern basiert (ein propriet√§res Format von intelligenten Zeigern wurde in der Vergangenheit verwendet, da es zu Beginn der Entwicklung keine intelligente Zeiger-Engine im C ++ - Standard gab). </li><li>  Flexible modulare Architektur; </li><li>  Der Szenenobjekt-Manager, der Objekte dynamisch l√§dt, erm√∂glicht das Laden und Rendern nur der Objekte, die in die Beschneidungspyramide fallen (aufgrund der Klasse osg :: PagedLOD). </li><li>  Integrationsf√§higkeit in das Qt-Framework.  Dank des praktischen Qs-Slots-Modells von Qt, das die C ++ - Entwicklung erheblich vereinfacht und beschleunigt, verwenden wir dieses Framework h√§ufig f√ºr die Entwicklung komplexer Schulungssoftware.  Dementsprechend haben wir eine signifikante Codebasis angesammelt, die in verschiedenen Projekten wiederverwendet wurde, insbesondere im Hinblick auf die Bibliothek der Interprozesskommunikation basierend auf TCP-Sockets.  Die Verwendung der Funktionen von Qt im Video-Subsystem-Projekt scheint eine logische Entscheidung zu sein. </li><li>  Ausreichende Bildqualit√§t f√ºr die zu l√∂sende Aufgabe. </li></ul><br>  Es dauerte ungef√§hr sechs Monate intensiver Untersuchung der OSG-F√§higkeiten, um den Boden gr√ºndlich zu "untersuchen" und Ans√§tze zur L√∂sung des Problems mit dieser Engine zu finden.  Was als Ergebnis geboren wurde, verdient eine gesonderte Diskussion. <br><br><h1>  4. Von der Architektur zum funktionierenden Prototyp </h1><br>  Das Video-Subsystem der Rollmaterial-Trainingssimulatoren (HTSC) ist eine Client-Anwendung, die routinem√§√üig als Video3d-Client bezeichnet wird und die folgenden Funktionen ausf√ºhrt: <br><br><ul><li>  Eine Anforderung zum Herstellen einer Verbindung zum Serverteil des Simulators, Autorisierung auf dem Server, gefolgt von einer regelm√§√üigen Anforderung nach der Kennung der geladenen Route und anschlie√üend zur aktuellen Position des Zuges.  Wenn die Verbindung von der Serverseite getrennt wird, wechselt das System zum erneuten Herstellen der Verbindung in den Standby-Modus. </li><li>  Herunterladen der ausgew√§hlten Route, Organisation der dynamischen Verwaltung des Inhalts der gerenderten Szene; </li><li>  Tats√§chliches Rendern der Szene in √úbereinstimmung mit der aktuellen Position des Zuges auf der Strecke </li></ul><br>  Nicht dass dieses Projekt Open Source war, aber den Code einer voll funktionsf√§higen Technologiedemo finden Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> .  Das Projekt besteht aus folgenden Modulen: <br><br><ul><li>  <i>Dateisystem</i> - Eine Bibliothek f√ºr die Arbeit mit dem Dateisystem bietet die Generierung von Pfaden zu Konfigurationsdateien und Anwendungsressourcen </li><li>  <i>Bibliothek</i> - eine plattform√ºbergreifende Implementierung des dynamischen Bibliotheksladers.  Im Allgemeinen war eine Kr√ºcke, die zu einer Zeit geschrieben wurde, als die M√∂glichkeiten der Integration mit Qt (wo ein QLibrary-Modul f√ºr den Kampf bereit ist) noch vage waren </li><li>  <i>osgdb_dmd</i> - ein Plugin zum Laden von Modellen eines Formats, das f√ºr die DGLEngine Engine Version 1.1 spezifisch ist.  F√ºr das, was es brauchte, werde ich etwas weiter unten erkl√§ren </li><li>  <i>route-loader</i> ist eine Bibliothek, die eine abstrakte Schnittstelle zum route loader bietet.  Es ist m√∂glich, Routen mit beliebigem Format zu laden </li><li>  TCP <i>-Verbindung</i> - Interprozess-Kommunikationsbibliothek √ºber TCP-Sockets </li><li>  <i>Viewer</i> - das ausf√ºhrbare Hauptmodul des Programms </li><li>  <i>zds-route-loader</i> - Plug-In zum Laden von Routen im ZDSimulator-Format </li></ul><br>  Bei der Gestaltung des VTPS stellte sich die Frage, ob ein eigenst√§ndiges Streckenformat entwickelt oder das vorhandene Streckenformat sowie vorgefertigte Strecken der Inlandsbahnen f√ºr den vorhandenen Eisenbahnsimulator verwendet werden sollen.  Gl√ºcklicherweise stellte sich heraus, dass es sich bei der L√∂sung um das geschlossene propriet√§re Produkt <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ZDSimulator handelt</a> , das die Besonderheit aufweist, dass es auf inl√§ndische Fahrzeuge und die Besonderheiten des Eisenbahnnetzes zugeschnitten ist.  Trotz des Lobes der Autoren des Projekts weist es viele erhebliche Nachteile auf, hat aber gleichzeitig ein einfaches und klares Format √∂ffentlich zug√§nglicher Routen.  In der ersten Phase war es eine S√ºnde, die Gelegenheit nicht zu nutzen, obwohl der grafische Teil des Simulators auf der offenen DGLEngine-Engine basiert.  Das Problem ist, dass diese Engine zwar entwickelt wird (der aktuelle Status des Projekts <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ist hier zu sehen</a> ), die aktuelle zweite Version jedoch nicht mit der Version 1.1 kompatibel ist, auf der ZDSimulator basiert.   1.1 ,      . <br><br>         ,  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">DGLEngine v1.1</a>  Gtihub.    ,   3D-.          OSG. <br><br>             OSG.       ,              ,      . <br><br>         <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/59/2l/sx/592lsx2l9c4ktp7q9j__9mqu3ic.png"></div><br>       <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/dl/yw/lb/dlywlbrbkjuzxgl_3whfakiv11q.png"></div><br>          ,  ,    RouteLoader.          ,        ,     . <br><br>       OSG  Qt.      <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">osgQt</a> .          : <br><br><ol><li>      ,  Qt. OSG        GUI     GUI   GUI,   osgQt       OSG  GUI   Qt </li><li> osgQt   ‚Äî     OpenGL,          OSG  QGLWidget, -     ,     Qt.      ,         . </li></ol><br>   ,    Qt      ¬´-¬ª,       tcp-connection,  Qt    -   .     OSG    TCP- (   )   .   ,   ,    ,     ,           : <br><br><ol><li>  Erben Sie interagierende Klassen von QObject </li><li>  Organisieren Sie eine Signalverarbeitungsschleife </li><li>  Erstellen Sie eine Instanz der Klasse QApplication (oder QCoreApplication), die w√§hrend des Anwendungsvorgangs im Speicher vorhanden ist </li></ol><br>            QApplication::exec(),     ,          QApplication::processEvents().  OSG    ( ,    )      ,     osgGA::GUIEventAdapter::FRAME,      .        <br><br>  <b>qt-events.h</b> <br><br><pre><code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> QT_EVENTS_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> QT_EVENTS_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;osgGA/GUIEventHandler&gt; #include &lt;QtCore/QtCore&gt; class QtEventsHandler : public osgGA::GUIEventHandler { public: QtEventsHandler(){} virtual bool handle(const osgGA::GUIEventAdapter &amp;ea, osgGA::GUIActionAdapter &amp;aa); protected: }; #endif // QT_EVENTS_H</span></span></span></span></code> </pre> <br><br>  <b>qt-events.cpp</b> <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"qt-events.h"</span></span></span><span class="hljs-meta"> bool QtEventsHandler::handle(const osgGA::GUIEventAdapter &amp;ea, osgGA::GUIActionAdapter &amp;aa) { switch (ea.getEventType()) { case osgGA::GUIEventAdapter::FRAME: { QCoreApplication::processEvents(QEventLoop::AllEvents, 100); break; } default: break; } return false; }</span></span></code> </pre><br>  <b>main.cpp</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"main.h"</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/*! * \fn * \brief Entry point */</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//------------------------------------------------------------------------------ // //------------------------------------------------------------------------------ int main(int argc, char *argv[]) { QCoreApplication app(argc, argv); RouteViewer viewer(argc, argv); if (viewer.isReady()) return viewer.run(); return 0; }</span></span></span></span></code> </pre><br>  Danach k√∂nnen von QObject und seinen Ableitungen geerbte Klassen Signale austauschen, bis der Impuls verloren geht. <br><br>  All dies erlaubte zwei Monate, um den ersten funktionierenden Prototyp von HTPS zu erstellen.  Um zu demonstrieren, was am Ende passiert ist, schlage ich den folgenden Abschnitt von experimentellen Reisen auf realen Routen vor.  Ich entschuldige mich im Voraus f√ºr die Qualit√§t der Aufnahmen - sie haben keine intelligente Technologie erhalten <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/CENZVOC2ZxE" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><h1>  Schlussfolgerung und Schlussfolgerungen </h1><br>  Die wichtigste Schlussfolgerung, zumindest f√ºr unser Team, war, dass die Wahl der Technologie f√ºr die Umsetzung des Projekts keine "graue Kugel" enthielt.  Aggressiv vermarktete Game-Engines eignen sich nicht immer zur L√∂sung bestimmter Aufgaben, einschlie√ülich der Visualisierung der Ergebnisse der Modellierung technischer Systeme.  Und wenn sie geeignet sind, sind sie hinsichtlich des Aufwands f√ºr die Entwicklung und Wartung des Projekts nicht optimal. <br><br>  Es ist eine Schande, dass eine sehr gute und vor allem kostenlose OSG-Grafik-Engine in unserem Land keine Community hat.  Um dieses Problem zu beheben, schreibe ich hier eine <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Reihe von Artikeln √ºber die Ressource</a> (dort habe ich alle Links zu mehr oder weniger angemessenen Informationsquellen gesammelt, auch in russischer Sprache).  Dar√ºber hinaus kann ich als Dokumentation, die die Grundprinzipien von OSG beschreibt, auch <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">diesen Blog</a> anbieten.  Ich hoffe, dass jemand diese Informationen n√ºtzlich findet. <br><br>  In Bezug auf HTSC wird die Arbeit in dieser Richtung fortgesetzt.  Es gibt noch viele wichtige Aufgaben, die in naher Zukunft gel√∂st werden m√ºssen. <br><br>  Danke f√ºr die Aufmerksamkeit! <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">(c) Zentrum f√ºr die Entwicklung von Innovationskompetenzen</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de436276/">https://habr.com/ru/post/de436276/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de436266/index.html">Extreme Skalierung in Alibaba JDK</a></li>
<li><a href="../de436268/index.html">Wir sammeln ein komplettes Deck</a></li>
<li><a href="../de436270/index.html">35% der Runet-Zuschauer verwenden √ºberhaupt keinen Computer f√ºr das Internet</a></li>
<li><a href="../de436272/index.html">Visuelle Programmierung f√ºr Sonoff Basic</a></li>
<li><a href="../de436274/index.html">In Russland wird eine mobile Anwendung zur Unfallregistrierung erstellt</a></li>
<li><a href="../de436280/index.html">Implementieren Sie Honeypot auf Cisco-Routern</a></li>
<li><a href="../de436282/index.html">Herausforderung von einer ausl√§ndischen Firma oder wie ich ein Interview nicht bestanden habe</a></li>
<li><a href="../de436284/index.html">Hacken von Amazon Echo und Google Home zum Schutz der Privatsph√§re</a></li>
<li><a href="../de436288/index.html">Wie begann das Monopol oder ein wenig Aufhebens um den IBM PC 5150?</a></li>
<li><a href="../de436292/index.html">Kontrollieren, √§ndern, l√∂schen: Top 10 Berichte von DotNext 2018 Moskau</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>