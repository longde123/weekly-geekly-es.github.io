<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤴 👩🏿‍🤝‍👩🏼 🔛 Dreidimensionale Visualisierung in Simulatoren von Fahrzeugen basierend auf der OpenSceneGraph-Engine 🏂 💜 🙌🏽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Vor etwas weniger als einem Jahr wurde eine Veröffentlichung veröffentlicht, in der wir über den Trainings- und Laborkomplex (ULK) des von unserer Uni...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Dreidimensionale Visualisierung in Simulatoren von Fahrzeugen basierend auf der OpenSceneGraph-Engine</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/436276/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/bp/4h/_g/bp4h_g1ct8gq0ntec_7pe8pkan8.jpeg"></div><br><br>  Vor etwas weniger als einem Jahr wurde eine <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Veröffentlichung</a> veröffentlicht, in der wir über den Trainings- und Laborkomplex (ULK) des von unserer Universität entwickelten elektrischen Zuges ES1 Lastochka sprachen.  Dann versprach ich, dass dies nicht die letzte Veröffentlichung zu diesem Thema sein würde, insbesondere drohte ich, über die Probleme bei der Erstellung einer dreidimensionalen Visualisierung für solche Simulatoren zu sprechen und die wichtigsten Lösungsansätze zu skizzieren. <br><br>  Letztes Jahr waren wir mit unserer nächsten Veröffentlichung zufrieden - dem ULK des elektrischen Hochgeschwindigkeitszuges EVS2 von Sapsan, der im August letzten Jahres stattfand.  Der Bildungs- und Laborkomplex dieses elektrischen Zuges selbst verdient eine eigene Geschichte, aber im Rahmen dieser Veröffentlichung werden wir über die Wunde sprechen - das Problem der Schaffung eines adäquaten Subsystems der dreidimensionalen Visualisierung, das unser Team etwa zwei Jahre lang von zwei Seiten angesprochen hat.  Die Veröffentlichung des Sapsan-Simulators ist (unter anderem) von Bedeutung und hat den Entwicklungsvektor unserer Entwicklungen in diesem Bereich bestimmt. <br><a name="habracut"></a><br><h1>  1. Kurz über ULK EVS2 „Sapsan“ </h1><br>  Ich möchte noch einmal betonen (was ich mit beneidenswerter Häufigkeit mache), dass die an unserer Universität entwickelten Bildungs- und Laborkomplexe von Schienenfahrzeugen nicht für die Vorbereitung von Lokomotivenbrigaden bestimmt sind.  Wie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">einer der Kommentatoren des</a> vorherigen Artikels zu Recht <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">feststellte</a> , handelt es sich bei unseren ULK nicht um Simulatoren, sondern um Simulatoren, bei denen der Schwerpunkt auf der kompetenten Umsetzung der Physik der Zugbewegung und der Simulation des Betriebs der Teilsysteme des rollenden Materials liegt, die dessen Bewegung und Stopp sicherstellen.  Der Sapsan-Simulator ist keine Ausnahme, bei der folgende Aufgaben gelöst werden: <br><br><ul><li>  Unter Berücksichtigung der Längskräfte und des Gleisprofils wurde ein dynamisches Modell des mechanischen Teils des Zuges implementiert </li><li>  Es wurde ein detailliertes Computermodell für den Betrieb der wichtigsten Teilsysteme des elektrischen Zuges erstellt: Stromkreis, elektrischer Traktionsantrieb, pneumatische und elektropneumatische Bremsen </li><li>  Die grundlegenden Algorithmen für den Betrieb des elektrischen Zugsteuerungssystems auf verschiedenen Ebenen werden reproduziert. </li></ul><br>  Darüber hinaus umfasst der Schulungs- und Laborkomplex ein Modell der Kabine des elektrischen Zuges in Originalgröße mit den Hauptsteuerungen und Mitteln zur Anzeige von Informationen.  Im Gegensatz zum Swallows-Simulator wurde diese Kabine nicht von uns selbst hergestellt, sondern 2015 von einem Büro im Land gekauft, das Trainingssimulatoren herstellt.  Daher konzentrierte sich der Entwicklungsprozess des Simulators auf die Erstellung von Software. <br><br><div class="spoiler">  <b class="spoiler_title">Kabinenfoto</b> <div class="spoiler_text">  <i>Gesamtansicht des Kabineninneren</i> <br><img src="https://habrastorage.org/webt/ud/de/ic/uddeiczrsp23eszvl6tx6zwal7y.jpeg"><br><br>  <i>Blick durch die Windschutzscheibe</i> <br><img src="https://habrastorage.org/webt/r1/nz/kn/r1nzknpyastfa6b8iy6ghp2m4ic.jpeg"><br><br>  <i>Integrierte Sicherheitsvorrichtung für Lokomotiven (CLUB-U) anzeigen.</i>  <i>Das rote „290“ ist die aktuelle Geschwindigkeitsbegrenzung, die von der elektronischen CLUB-U-Karte erhalten wird.</i>  <i>Bisher zeigt sich hier das Tempolimit, das Sapsan mit der Oktoberbahn erreicht hat.</i>  <i>In Zukunft wird die elektronische Karte so implementiert, wie es im Leben geschieht.</i> <br><img src="https://habrastorage.org/webt/nt/on/-g/nton-ggphlulx1e0yxmznf_epnu.jpeg"><br><br>  <i>Hauptdisplay „Mensch-Maschine-Schnittstelle“</i> <br><img src="https://habrastorage.org/webt/xk/kd/qk/xkkdqkxqznjjkl_vx-lfbdhys4w.jpeg"><br><br>  <i>Anzeige für den Status des Bremssystems des elektrischen Zuges</i> <br><img src="https://habrastorage.org/webt/ap/wl/qv/apwlqvuggyfjgwd_prliwn3hjck.jpeg"><br><br>  <i>Geschwindigkeitsregler und Traktionsregler</i> <br><img src="https://habrastorage.org/webt/u3/ok/nb/u3oknbv0nitjk-d7fcpqmywhxr4.jpeg"><br><br>  <i>Steuerung der elektrischen Zugbremssteuerung</i> <br><img src="https://habrastorage.org/webt/6k/mf/eg/6kmfegwxufy_317kqfvmp7n00k8.jpeg"><br><br>  <i>Kippschalter zur Steuerung von Stromabnehmern und Schutzeinrichtungen (BV / GV) - schwarze Kippschalter in der Nähe des Geschwindigkeitssetzers</i> <br><img src="https://habrastorage.org/webt/dn/gs/3p/dngs3pxzgoqcawtdewf84z8squc.jpeg"><br><br>  <i>Trainingsmanagement-Oberfläche - Routenauswahlbildschirm</i> <br><img src="https://habrastorage.org/webt/_n/sh/jp/_nshjpyo8nu8wbxalcfhtfowns0.jpeg"><br><br>  <i>Lautstärkeregelungsbildschirm für Audioeffekte</i> <br><img src="https://habrastorage.org/webt/ba/ll/p_/ballp_v52zh8rmq4iosfkicienw.jpeg"><br><br>  <i>Kilometerzähler.</i>  <i>Eine lustige Geschichte ist mit seinem Aussehen verbunden.</i>  <i>Als wir unseren ersten Simulator der Diesellokomotive 2TE116 übergaben, scherzte der Kundenvertreter zu unserer Frage, wann der Fertigstellungsakt unterzeichnet wird: „Nun, machen wir es wie im Leben - wenn eine neue Lokomotive in Betrieb genommen wird, muss sie eine Strecke von 5000 Kilometern zurücklegen.</i>  <i>Das wird vergehen ... ".</i>  <i>Das Gesetz wurde natürlich viel früher unterzeichnet, aber um den Humor der Situation zu bewerten, haben wir bereits einen ähnlichen Zähler auf dem Swallows-Simulator erstellt.</i>  <i>Der Zähler kann durch Eingabe des Servicekennworts auf "0" zurückgesetzt werden.</i> <br><img src="https://habrastorage.org/webt/yo/hc/jq/yohcjqcfhoe8irnm6j3ynr9exby.jpeg"><br><br>  <i>Rechte Zubehörplatte mit Bremsdruckmessern und Notbremsventil.</i>  <i>Nicht alle in diesem Sapsan enthaltenen Elemente sind hier installiert - eine solche Fernbedienung wurde von uns vom Lieferanten erhalten</i> <br><img src="https://habrastorage.org/webt/fr/te/5l/frte5lrezbuss2ng2iesdqcl0p8.jpeg"><br><br>  <i>Daher wurden einige der für uns wichtigen Steuerelemente in Software implementiert, insbesondere das Bedienfeld der Bypass-Schalter, die über den Touchscreen gesteuert werden</i> <br><img src="https://habrastorage.org/webt/he/c2/ga/hec2gahq08cziegrxl1qfkriqya.png"><br></div></div><br>  Die Entwicklung von Software für einen solchen Simulatorsimulator ist eine sehr weit gefasste Frage, und ich werde (nach besten Kräften) versuchen, das Interesse der Leser an diesen Themen in Zukunft (falls vorhanden) zu befriedigen. Kehren wir jedoch zunächst zum Hauptthema des Artikels zurück - der dreidimensionalen Visualisierung des Zugbewegungsprozesses. <br><br><h1>  2. Hintergrund und Technologie der Vergangenheit </h1><br>  In den Kommentaren zum letzten Artikel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">wurde eine Frage gestellt</a> , die mich ehrlich gesagt ziemlich amüsierte.  Ja, in der Tat wird dieser Ansatz in vielen heute noch verwendeten Simulatoren immer noch verwendet: Video wird auf einem realen Abschnitt der Eisenbahn aufgenommen und dann mit einer Geschwindigkeit, die proportional zur Bewegungsgeschwindigkeit ist, auf dem Simulator gescrollt.  Dies geschah nur, weil in jenen Tagen, als solche Simulatoren erstellt wurden, die Qualität dreidimensionaler Grafiken zu wünschen übrig ließ, und dies galt auch für raue Grafikstationen auf kommerziellen Unixen, und es gab keine Frage eines PCs.  Daher zögerten auch Hersteller von Computerspielen, beispielsweise <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">dieses</a> , nicht, diesen Ansatz zu verwenden. <br><br>  Das macht heute keinen Sinn, weil: <br><br><ol><li>  Die unzureichende Bildrate bei niedrigen Zuggeschwindigkeiten bietet nicht die gewünschte Glätte der Bildaktualisierung.  Wir werden die geschätzten 25 fps nur bei der Geschwindigkeit haben, mit der das Video aus der Fahrerkabine aufgenommen wurde.  Und dieser fatale Fehler kann in keiner Weise behoben werden - weder durch Aufnahmen mit einer Hochgeschwindigkeitskamera (wie viel wiegt das mit 120 Bildern pro Sekunde aufgenommene Video? Das ist das gleiche ...) noch durch die programmierte Erzeugung von Zwischenbildern.  Letzteres wurde von uns mit OpenCV-Technologie durchgeführt, führte jedoch nicht zu normalen Ergebnissen.  Diese Frage wurde wiederholt von allen Seiten untersucht, und als Ergebnis wurde der Schluss gezogen, dass die Kosten für Ressourcen zur Erstellung eines solchen Systems viel höher sind als für die Entwicklung eines ähnlichen Systems, jedoch basierend auf 3D-Grafiken </li><li>  Schwierigkeiten beim reibungslosen Zurückblättern des Videos.  Und selbst wenn man bedenkt, dass sie überwunden werden, wo werden dann die Hunde, die auf der Plattform laufen, rennen? Denken wir, wir sollten umgekehrt vorgehen? </li><li>  Das Fehlen aller "Interaktivität".  Was tun mit einem Ampelwechsel, mit der Bewegung von Weichen, der Bewegung entgegenkommender und vorbeifahrender Züge? </li></ol><br>  Daher werden alle modernen Simulatoren und Simulatoren mit interaktiven 3D-Grafiken erstellt, da es heute weder aus Software- noch aus Hardwaresicht Hindernisse gibt. <br><br>  Wenn aus Hardware-Sicht alles sehr klar ist - der anstelle der Windschutzscheibe installierte Monitor ist mit einer normalen Grafikkarte (nicht einmal der Top-End-Karte) an einen PC angeschlossen -, stellt sich aus Sicht der Software die Frage, welche Technologie für die Implementierung der Aufgabe ausgewählt werden soll. <br><br><h1>  3. Die Grafik-Engine im Vergleich zur Game-Engine oder warum OpenSceneGraph ausgewählt wurde </h1><br>  Ich kann mich irren, aber ich erwarte Kommentare im Voraus, die eine völlig logische Frage stellen, warum unsere Wahl bei der Analyse bestehender Technologien nicht bei Mastodons wie Unity oder Unreal Engine 4 aufgehört hat.  Ich werde diese Frage beantworten, außerdem werde ich meine Antwort rechtfertigen. <br><br>  Kurz gesagt - weder Unity noch Unreal Engine erfüllen die Anforderungen der zu lösenden Aufgabe.  Eine detailliertere Antwort enthält zunächst eine Auflistung der betreffenden Anforderungen.  TK, zusammengestellt von uns auf dem Teilsystem der dreidimensionalen Visualisierung, enthält (in absteigender Reihenfolge der Wichtigkeit) die folgenden Bestimmungen: <br><br><ol><li>  Unabhängigkeit des Softwareentwicklungsprozesses des Visualisierungssubsystems und des Prozesses der Erstellung von Ressourcen dafür.  Zu den Ressourcen gehören in diesem Fall dreidimensionale Modelle, Texturen sowie die sogenannten <i>Routen</i> .  Unter einer Route wird eine Kombination von Konfigurationsobjekten und Ressourcen verstanden, die es dem Videosubsystem ermöglichen, den gewünschten Abschnitt der Eisenbahn anzuzeigen und die Bewegung des Zuges entlang dieser zu simulieren.  Dies beinhaltet auch die <i>Möglichkeit, die Route zu ändern, ohne den Softwareteil des Video-Subsystems neu zu erstellen</i> </li><li>  Erstellen Sie Routen mit unbegrenzter Länge.  Ich werde reservieren, dass eine unbegrenzte Länge aufgrund begrenzter Hardwareressourcen grundsätzlich nicht erreichbar ist.  Diese Anforderung sollte verstanden werden, dass die Länge der Route mindestens innerhalb einer „Schulter“ liegen sollte, dh eines Straßenabschnitts zwischen den Wendepunkten, und dies ist in Abhängigkeit von verschiedenen Faktoren eine ziemlich große Entfernung, die auf mehr als einhundert Kilometer geschätzt wird.  Diese Anforderung erfordert ein dynamisches Laden / Entladen von Programmressourcen mit ausreichender Glätte bei angemessenem Speicherverbrauch.  Und es ist wünschenswert, dass die Engine solche Funktionen "out of the box" enthält. </li><li>  Bequeme Integration in den verwendeten Technologie-Stack.  Aus objektiven Gründen verwendet unser Team traditionell die C ++ - Sprache mit Qt-Framework, QtCreator IDE und Git als Versionskontrollsystem für die Entwicklung von Software für ULK PS.  Als Systemplattform ULK PS wird ein auf dem Linux-Kernel basierendes Betriebssystem verwendet </li></ol><br>  Was ist los mit Unity und UE?  Was ist die Tatsache, dass andere Engines Ressourcen in völlig anderen Formaten importieren können.  Beim Zusammenstellen des Projekts werden sie jedoch irreversibel in das interne Binärformat konvertiert, wodurch das Hinzufügen und Ändern von Ressourcen ohne erneutes Zusammensetzen des Projekts unmöglich wird.  In Unity verfügbare Technologien wie Fertighäuser und Asset-Bundles lösen das Problem nicht, da der Motoreneditor nicht der beste Ort ist, um Bahnstandorte zu erstellen. Dies erfordert die Erweiterung des Editors, was dazu führt, dass ein „Motor im Motor“ geschrieben werden muss.  Darüber hinaus ist die Erstellung von Fertighäusern und Bundles ohne die Verwendung des Unity-Editors nicht möglich, und dies ist, wie die Praxis gezeigt hat, insbesondere für reine Modellierer und Leveldesigner nicht sehr praktisch.  In Bezug auf die UE habe ich über zwei Jahre hinweg viele Fragen zu dieser und anderen Ressourcen gestellt, wie der Prozess des Erstellens eines Projekts vom Prozess des Hinzufügens / Änderns der verwendeten Ressourcen getrennt werden kann, und ich habe weder in der Dokumentation noch in „ eingefleischte "Spieleentwickler.  Ich würde mich sehr freuen (ohne Sarkasmus), wenn ich vernünftigerweise auf etwas stoßen würde, das ich verpasst habe. <br><br>  Was die zweite Anforderung betrifft, scheinen sowohl Unity als auch UE die Möglichkeit zu bieten, dynamisch geladene Speicherorte zu erstellen. Die Frage bleibt jedoch unbeantwortet, wie solche Speicherorte unabhängig vom Editor und ohne Neuerstellung des Projekts erstellt werden können.  Es gibt nur einen Ausweg: Schreiben Sie eine „Engine in die Engine“, die die „Roh“ -Geometrie und -Texturen (in einem der zuvor angegebenen Exportformate von 3D-Editoren) lädt, alle erforderlichen Effekte auf sie anwendet und sie basierend auf den von einem Drittanbieter beschriebenen Daten im Raum positioniert unabhängig vom Motorformat, das noch entwickelt und gelehrt werden muss, um den Motor zu interpretieren. <br><br>  Im Zusammenhang mit dem oben Gesagten stellt sich die Frage: Wenn zur Lösung dieses Problems eine leistungsstarke Softwareschicht über die Spiel-Engine geschrieben werden muss, deren Funktionalität für das betreffende Problem größtenteils nicht benötigt wird, warum benötigen wir dann eine Spiel-Engine? <br><br>  Vielleicht reicht die Grafik-Engine?  Ich habe diese Frage dem vorherigen Team gestellt, das das zur Diskussion stehende Problem unter Berufung auf Unity angegangen ist (und natürlich etwas später zusammengeführt hat).  Als Antwort erhielt er eine Gegenfrage: "Was schlagen Sie vor?", Auf die er antwortete, und im Geiste des obigen Textes erhielt er das sarkastische Lächeln eines Gegners. <br><br>  Wenn Sie auf Sarkasmus verzichten, ist die vorgestellte Aufgabe eine typische Visualisierungsaufgabe - sie erfordert nur ein Framework für die Arbeit mit Grafiken, da sowohl die Physik als auch das auf Physik basierende Audio-Subsystem auf der Serverseite implementiert sind.  Mein Team und ich haben diese Tatsache verstanden, indem wir uns durch die Trägheit früherer Entwickler zunächst in Richtung Unity durch UE bewegt und versucht haben, das Grafik-Subsystem von einem der offenen Eisenbahnsimulatoren (OpenBVE, das sich übrigens herausstellte, aber es wurde zu einer vorübergehenden Krücke) zu befestigen. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">OpenSceneGraph</a> ist mit Abstand die am weitesten entwickelte (offene und kostenlose) Grafik-Engine, die sich auf die C ++ - Entwicklung konzentriert.  Es wird im Ausland gerade zur technischen dreidimensionalen Visualisierung weit verbreitet.  Dieser Motor wurde von keinem Simulator verschont, von dem der bekannteste <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">FlightGear ist</a> .  Es gab einmal einen Eisenbahnsimulator, der auf diesem Motor basierte - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Indra</a> , der jedoch nur langweilige Screenshots des obigen Links hinterließ und dessen weiteres Schicksal mir unbekannt ist. <br><br>  Im Rahmen der vorliegenden Aufgabe weist die OSG-Grafik-Engine die folgenden positiven Eigenschaften auf: <br><br><ul><li>  Plattformübergreifend, wodurch es möglich ist, es im GNU / Linux-Ökosystem anzuwenden </li><li>  Die Entwicklungssprache ist C ++ / STL, was es ermöglicht, sie einfach und natürlich in den etablierten technologischen Entwicklungsprozess zu integrieren. </li><li>  Die größte Auswahl an Ressourcenformaten wird "out of the box" unterstützt - 3D-Geometrie und Texturen aufgrund des entwickelten Plug-In-Systems.  Eine einfache und intuitive Oberfläche zum Schreiben eigener Plug-Ins zum Einrichten des Ressourcenmanagers für nicht standardmäßige Formate, die wir verwendet haben (darüber werde ich weiter unten schreiben). </li><li>  Ein Speicherverwaltungssystem, das auf einem proprietären Modell von intelligenten Zeigern basiert (ein proprietäres Format von intelligenten Zeigern wurde in der Vergangenheit verwendet, da es zu Beginn der Entwicklung keine intelligente Zeiger-Engine im C ++ - Standard gab). </li><li>  Flexible modulare Architektur; </li><li>  Der Szenenobjekt-Manager, der Objekte dynamisch lädt, ermöglicht das Laden und Rendern nur der Objekte, die in die Beschneidungspyramide fallen (aufgrund der Klasse osg :: PagedLOD). </li><li>  Integrationsfähigkeit in das Qt-Framework.  Dank des praktischen Qs-Slots-Modells von Qt, das die C ++ - Entwicklung erheblich vereinfacht und beschleunigt, verwenden wir dieses Framework häufig für die Entwicklung komplexer Schulungssoftware.  Dementsprechend haben wir eine signifikante Codebasis angesammelt, die in verschiedenen Projekten wiederverwendet wurde, insbesondere im Hinblick auf die Bibliothek der Interprozesskommunikation basierend auf TCP-Sockets.  Die Verwendung der Funktionen von Qt im Video-Subsystem-Projekt scheint eine logische Entscheidung zu sein. </li><li>  Ausreichende Bildqualität für die zu lösende Aufgabe. </li></ul><br>  Es dauerte ungefähr sechs Monate intensiver Untersuchung der OSG-Fähigkeiten, um den Boden gründlich zu "untersuchen" und Ansätze zur Lösung des Problems mit dieser Engine zu finden.  Was als Ergebnis geboren wurde, verdient eine gesonderte Diskussion. <br><br><h1>  4. Von der Architektur zum funktionierenden Prototyp </h1><br>  Das Video-Subsystem der Rollmaterial-Trainingssimulatoren (HTSC) ist eine Client-Anwendung, die routinemäßig als Video3d-Client bezeichnet wird und die folgenden Funktionen ausführt: <br><br><ul><li>  Eine Anforderung zum Herstellen einer Verbindung zum Serverteil des Simulators, Autorisierung auf dem Server, gefolgt von einer regelmäßigen Anforderung nach der Kennung der geladenen Route und anschließend zur aktuellen Position des Zuges.  Wenn die Verbindung von der Serverseite getrennt wird, wechselt das System zum erneuten Herstellen der Verbindung in den Standby-Modus. </li><li>  Herunterladen der ausgewählten Route, Organisation der dynamischen Verwaltung des Inhalts der gerenderten Szene; </li><li>  Tatsächliches Rendern der Szene in Übereinstimmung mit der aktuellen Position des Zuges auf der Strecke </li></ul><br>  Nicht dass dieses Projekt Open Source war, aber den Code einer voll funktionsfähigen Technologiedemo finden Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> .  Das Projekt besteht aus folgenden Modulen: <br><br><ul><li>  <i>Dateisystem</i> - Eine Bibliothek für die Arbeit mit dem Dateisystem bietet die Generierung von Pfaden zu Konfigurationsdateien und Anwendungsressourcen </li><li>  <i>Bibliothek</i> - eine plattformübergreifende Implementierung des dynamischen Bibliotheksladers.  Im Allgemeinen war eine Krücke, die zu einer Zeit geschrieben wurde, als die Möglichkeiten der Integration mit Qt (wo ein QLibrary-Modul für den Kampf bereit ist) noch vage waren </li><li>  <i>osgdb_dmd</i> - ein Plugin zum Laden von Modellen eines Formats, das für die DGLEngine Engine Version 1.1 spezifisch ist.  Für das, was es brauchte, werde ich etwas weiter unten erklären </li><li>  <i>route-loader</i> ist eine Bibliothek, die eine abstrakte Schnittstelle zum route loader bietet.  Es ist möglich, Routen mit beliebigem Format zu laden </li><li>  TCP <i>-Verbindung</i> - Interprozess-Kommunikationsbibliothek über TCP-Sockets </li><li>  <i>Viewer</i> - das ausführbare Hauptmodul des Programms </li><li>  <i>zds-route-loader</i> - Plug-In zum Laden von Routen im ZDSimulator-Format </li></ul><br>  Bei der Gestaltung des VTPS stellte sich die Frage, ob ein eigenständiges Streckenformat entwickelt oder das vorhandene Streckenformat sowie vorgefertigte Strecken der Inlandsbahnen für den vorhandenen Eisenbahnsimulator verwendet werden sollen.  Glücklicherweise stellte sich heraus, dass es sich bei der Lösung um das geschlossene proprietäre Produkt <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ZDSimulator handelt</a> , das die Besonderheit aufweist, dass es auf inländische Fahrzeuge und die Besonderheiten des Eisenbahnnetzes zugeschnitten ist.  Trotz des Lobes der Autoren des Projekts weist es viele erhebliche Nachteile auf, hat aber gleichzeitig ein einfaches und klares Format öffentlich zugänglicher Routen.  In der ersten Phase war es eine Sünde, die Gelegenheit nicht zu nutzen, obwohl der grafische Teil des Simulators auf der offenen DGLEngine-Engine basiert.  Das Problem ist, dass diese Engine zwar entwickelt wird (der aktuelle Status des Projekts <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ist hier zu sehen</a> ), die aktuelle zweite Version jedoch nicht mit der Version 1.1 kompatibel ist, auf der ZDSimulator basiert.   1.1 ,      . <br><br>         ,  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">DGLEngine v1.1</a>  Gtihub.    ,   3D-.          OSG. <br><br>             OSG.       ,              ,      . <br><br>         <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/59/2l/sx/592lsx2l9c4ktp7q9j__9mqu3ic.png"></div><br>       <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/dl/yw/lb/dlywlbrbkjuzxgl_3whfakiv11q.png"></div><br>          ,  ,    RouteLoader.          ,        ,     . <br><br>       OSG  Qt.      <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">osgQt</a> .          : <br><br><ol><li>      ,  Qt. OSG        GUI     GUI   GUI,   osgQt       OSG  GUI   Qt </li><li> osgQt   —     OpenGL,          OSG  QGLWidget, -     ,     Qt.      ,         . </li></ol><br>   ,    Qt      «-»,       tcp-connection,  Qt    -   .     OSG    TCP- (   )   .   ,   ,    ,     ,           : <br><br><ol><li>  Erben Sie interagierende Klassen von QObject </li><li>  Organisieren Sie eine Signalverarbeitungsschleife </li><li>  Erstellen Sie eine Instanz der Klasse QApplication (oder QCoreApplication), die während des Anwendungsvorgangs im Speicher vorhanden ist </li></ol><br>            QApplication::exec(),     ,          QApplication::processEvents().  OSG    ( ,    )      ,     osgGA::GUIEventAdapter::FRAME,      .        <br><br>  <b>qt-events.h</b> <br><br><pre><code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> QT_EVENTS_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> QT_EVENTS_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;osgGA/GUIEventHandler&gt; #include &lt;QtCore/QtCore&gt; class QtEventsHandler : public osgGA::GUIEventHandler { public: QtEventsHandler(){} virtual bool handle(const osgGA::GUIEventAdapter &amp;ea, osgGA::GUIActionAdapter &amp;aa); protected: }; #endif // QT_EVENTS_H</span></span></span></span></code> </pre> <br><br>  <b>qt-events.cpp</b> <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"qt-events.h"</span></span></span><span class="hljs-meta"> bool QtEventsHandler::handle(const osgGA::GUIEventAdapter &amp;ea, osgGA::GUIActionAdapter &amp;aa) { switch (ea.getEventType()) { case osgGA::GUIEventAdapter::FRAME: { QCoreApplication::processEvents(QEventLoop::AllEvents, 100); break; } default: break; } return false; }</span></span></code> </pre><br>  <b>main.cpp</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"main.h"</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/*! * \fn * \brief Entry point */</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//------------------------------------------------------------------------------ // //------------------------------------------------------------------------------ int main(int argc, char *argv[]) { QCoreApplication app(argc, argv); RouteViewer viewer(argc, argv); if (viewer.isReady()) return viewer.run(); return 0; }</span></span></span></span></code> </pre><br>  Danach können von QObject und seinen Ableitungen geerbte Klassen Signale austauschen, bis der Impuls verloren geht. <br><br>  All dies erlaubte zwei Monate, um den ersten funktionierenden Prototyp von HTPS zu erstellen.  Um zu demonstrieren, was am Ende passiert ist, schlage ich den folgenden Abschnitt von experimentellen Reisen auf realen Routen vor.  Ich entschuldige mich im Voraus für die Qualität der Aufnahmen - sie haben keine intelligente Technologie erhalten <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/CENZVOC2ZxE" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><h1>  Schlussfolgerung und Schlussfolgerungen </h1><br>  Die wichtigste Schlussfolgerung, zumindest für unser Team, war, dass die Wahl der Technologie für die Umsetzung des Projekts keine "graue Kugel" enthielt.  Aggressiv vermarktete Game-Engines eignen sich nicht immer zur Lösung bestimmter Aufgaben, einschließlich der Visualisierung der Ergebnisse der Modellierung technischer Systeme.  Und wenn sie geeignet sind, sind sie hinsichtlich des Aufwands für die Entwicklung und Wartung des Projekts nicht optimal. <br><br>  Es ist eine Schande, dass eine sehr gute und vor allem kostenlose OSG-Grafik-Engine in unserem Land keine Community hat.  Um dieses Problem zu beheben, schreibe ich hier eine <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Reihe von Artikeln über die Ressource</a> (dort habe ich alle Links zu mehr oder weniger angemessenen Informationsquellen gesammelt, auch in russischer Sprache).  Darüber hinaus kann ich als Dokumentation, die die Grundprinzipien von OSG beschreibt, auch <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">diesen Blog</a> anbieten.  Ich hoffe, dass jemand diese Informationen nützlich findet. <br><br>  In Bezug auf HTSC wird die Arbeit in dieser Richtung fortgesetzt.  Es gibt noch viele wichtige Aufgaben, die in naher Zukunft gelöst werden müssen. <br><br>  Danke für die Aufmerksamkeit! <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">(c) Zentrum für die Entwicklung von Innovationskompetenzen</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de436276/">https://habr.com/ru/post/de436276/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de436266/index.html">Extreme Skalierung in Alibaba JDK</a></li>
<li><a href="../de436268/index.html">Wir sammeln ein komplettes Deck</a></li>
<li><a href="../de436270/index.html">35% der Runet-Zuschauer verwenden überhaupt keinen Computer für das Internet</a></li>
<li><a href="../de436272/index.html">Visuelle Programmierung für Sonoff Basic</a></li>
<li><a href="../de436274/index.html">In Russland wird eine mobile Anwendung zur Unfallregistrierung erstellt</a></li>
<li><a href="../de436280/index.html">Implementieren Sie Honeypot auf Cisco-Routern</a></li>
<li><a href="../de436282/index.html">Herausforderung von einer ausländischen Firma oder wie ich ein Interview nicht bestanden habe</a></li>
<li><a href="../de436284/index.html">Hacken von Amazon Echo und Google Home zum Schutz der Privatsphäre</a></li>
<li><a href="../de436288/index.html">Wie begann das Monopol oder ein wenig Aufhebens um den IBM PC 5150?</a></li>
<li><a href="../de436292/index.html">Kontrollieren, ändern, löschen: Top 10 Berichte von DotNext 2018 Moskau</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>