<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🧑🏿‍🤝‍🧑🏼 🏂🏻 👉🏻 Kurz über Redux-Saga-Kanäle 💅🏻 💹 👩🏼‍🤝‍👩🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Guten Tag, liebe Freunde. 


 In diesem Artikel möchte ich den Mechanismus der Redux-Saga-Kanäle so einfach und präzise wie möglich beschreiben. Ich h...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Kurz über Redux-Saga-Kanäle</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/432070/"><p>  Guten Tag, liebe Freunde. </p><br><p>  In diesem Artikel möchte ich den Mechanismus der Redux-Saga-Kanäle so einfach und präzise wie möglich beschreiben. Ich hoffe, dass dies für mich funktioniert hat. </p><br><p>  Also fangen wir an. </p><a name="habracut"></a><br><h3 id="problema-modeli-watch-and-fork">  Problem mit dem Watch-and-Fork-Modell </h3><br><p>  Angenommen, wir haben ein reguläres Uhrenmodell in der folgenden Form: </p><br><pre><code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { take, fork } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'redux-saga/effects'</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">watchRequest</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-literal"><span class="hljs-literal">true</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> {payload} = <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> take(<span class="hljs-string"><span class="hljs-string">'INIT_REQUEST'</span></span>); <span class="hljs-comment"><span class="hljs-comment">// ,     yield fork(makeRequest, payload); } } function* makeRequest(payload) { //   }</span></span></code> </pre> <br><p>  Dieser Ansatz ist schlecht, da beim Abfangen mehrerer <code>INIT_REQUEST</code> Ereignisse, die nacheinander folgen, jeweils mehrere <code>makeRequest</code> Ausführungen <code>makeRequest</code> werden.  Was wiederum dazu führen kann, dass sie „rennen“. </p><br><p>  Und hier hilft uns der Kanalmechanismus. </p><br><p>  Kanäle haben Puffer, wodurch eingehende Ereignisse (z. B. <code>INIT_REQUEST</code> ) ausgerichtet und ihre sequentielle Ausführung organisiert werden können (z. B. wird <code>makeRequest</code> mehrmals nacheinander ausgeführt). </p><br><p>  Grob gesagt bilden Kanäle eine FIFO-Warteschlange für die sequentielle Ausführung. </p><br><p>  Nach Ereignisquelle klassifizieren: </p><br><ul><li>  Kanalereignisse werden manuell mit <code>put</code> die Warteschlange <code>put</code> . </li><li>  <code>actionChannel</code> - Ereignisse werden in der Nähe des Redux-Speichers abgefangen. </li><li>  <code>eventChannel</code> - eine externe Ereignisquelle, meistens ein Web-Socket; </li></ul><br><p>  Wir werden also jeweils kurz analysieren. </p><br><h3 id="podrobnee-o-channel">  Mehr zum Kanal </h3><br><p>  Solche Kanäle lösen normalerweise das Problem der Kommunikation zwischen Sagen.  Sehr selten verwendet.  Zum Beispiel, wenn Sie mehrere Anforderungen gleichzeitig koordinieren müssen. </p><br><pre> <code class="javascript hljs">channel([buffer])</code> </pre> <br><p>  Es hat ein einzelnes <code>buffer</code> - den akkumulierenden Puffer (wir werden die Puffer unten genauer untersuchen). </p><br><h3 id="podrobnee-ob-actionchannel">  Mehr zu actionChannel </h3><br><p>  Es wird am häufigsten verwendet, wenn auf Ereignisse aus dem Redux-Speicher reagiert werden muss. </p><br><pre> <code class="javascript hljs">actionChannel(pattern, [buffer])</code> </pre> <br><p>  Es braucht zwei Argumente: </p><br><ul><li>  <code>pattern</code> - das Muster der gewünschten Ereignisse sowie <code>take</code> ; </li><li>  <code>buffer</code> - Akkumulationspuffer; </li></ul><br><p>  Ein kurzes Anwendungsbeispiel: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { take, actionChannel, call } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'redux-saga/effects'</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">watchRequest</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> requestChannel = <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> actionChannel(<span class="hljs-string"><span class="hljs-string">'INIT_REQUEST'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-literal"><span class="hljs-literal">true</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> {payload} = <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> take(requestChannel); <span class="hljs-comment"><span class="hljs-comment">//      yield call(makeRequest, payload); } } function* makeRequest(payload) { //   }</span></span></code> </pre> <br><h3 id="podrobnee-ob-eventchannel">  Mehr zu eventChannel </h3><br><p>  Normalerweise löst es das Problem der Kommunikation über einen Web-Socket. </p><br><pre> <code class="javascript hljs">eventChannel(subscribe, [buffer], [matcher])</code> </pre> <br><p>  Es braucht drei Argumente: </p><br><ul><li>  <code>subscribe</code> ist eine Funktion, die eine externe Ereignisquelle initialisiert (im folgenden Beispiel setTimeout).  In den Argumenten wird ein Rückruf als Emitter bezeichnet, der aufgerufen wird, wenn Daten von der Quelle an den Kanal gesendet werden müssen.  Return sollte die Funktion abbestellen; </li><li>  <code>buffer</code> - Akkumulationspuffer; </li><li>  <code>matcher</code> - Funktion zum Filtern eingehender Nachrichten. </li></ul><br><p>  Ein kurzes Anwendungsbeispiel: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { eventChannel, END } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'redux-saga'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { take, put, call } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'redux-saga/effects'</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">initSocketChannel</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">query</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> eventChannel(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">emitter</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-comment"><span class="hljs-comment">//     web socket const handshakeTimeoutId = setTimeout(() =&gt; { emitter('handshake - ok'); }, 100); const messageTimeoutId = setTimeout(() =&gt; { emitter('message'); }, 500); const endTimeoutId = setTimeout(() =&gt; { emitter(END); }, 1000); //     return () =&gt; { clearTimeout(handshakeTimeoutId); clearTimeout(messageTimeoutId); clearTimeout(endTimeoutId); } } ) } export function* saga() { const chan = yield call(initSocketChannel, query) try { while (true) { const message = yield take(chan); //    END   brake console.log(`socket : ${message}`) } } finally { console.log('socket terminated') } }</span></span></code> </pre> <br><p>  Sicherlich haben Sie das Vorhandensein der <code>END</code> Konstante bemerkt - dies ist eine Aktion, die das Ende der Kommunikation mit dem Kanal bedeutet. </p><br><p>  Im Quellcode wird die Redux-Saga wie folgt dargestellt: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> CHANNEL_END_TYPE = <span class="hljs-string"><span class="hljs-string">'@@redux-saga/CHANNEL_END'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> END = { <span class="hljs-attr"><span class="hljs-attr">type</span></span>: CHANNEL_END_TYPE }; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> isEnd = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isEnd</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">a</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a &amp;&amp; a.type === CHANNEL_END_TYPE; };</code> </pre> <br><p>  und im <code>eventChannel</code> Quellcode sehen <code>eventChannel</code> das folgende Skript </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">eventChannel</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">subscribe</span></span></span><span class="hljs-function">) </span></span>{ … <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (isEnd(input)) { close(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } ... }</code> </pre> <br><h3 id="chto-zhe-takoe-buffer">  Was ist Puffer? </h3><br><p>  Es ist bemerkenswert, da jeder Kanal einen Basispuffer hat und damit eine Warteschlange für die Verarbeitung gebildet wird. </p><br><p>  Beispiel zum Erstellen eines Puffers: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { buffers } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'redux-saga'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> buffer = buffers.sliding(<span class="hljs-number"><span class="hljs-number">5</span></span>);</code> </pre> <br><p>  <code>buffers</code> sind eine Instanz einer Fabrik zum Erstellen von Puffern mit unterschiedlichen Strategien. </p><br><p>  Nur 5 Strategien, Methoden entsprechen ihnen: </p><br><ul><li>  <code>buffers.none()</code> - keine Pufferung, neue Nachrichten gehen verloren, wenn keine Teilnehmer anstehen; </li><li>  <code>buffers.fixed(limit)</code> - Neue Nachrichten werden bis zum Limit gepuffert.  Ein Überlauffehler führt zu einer Ausnahme.  Das Standardlimit ist 10; </li><li>  <code>buffers.expanding(initialSize)</code> - wie fest, aber ein Überlauf führt dazu, dass der Puffer dynamisch erweitert wird. </li><li>  <code>buffers.dropping(limit)</code> ist dasselbe wie fest, aber der Überlauf verwirft Nachrichten stillschweigend. </li><li>  <code>buffers.sliding(limit)</code> ist dasselbe wie fixed, aber ein Überlauf fügt am Ende eine neue Nachricht hinzu und löscht die älteste Nachricht im Puffer. </li></ul><br><h3 id="vmesto-zklyucheniya">  Anstatt herunterzufahren </h3><br><p>  Wir haben also untersucht, warum der Kanalmechanismus erfunden wurde und welche praktischen Aufgaben verwendet werden. </p><br><p>  Ich hoffe nach dem Lesen der allgemeinen Idee und die Welt ist ein wenig einfacher geworden. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de432070/">https://habr.com/ru/post/de432070/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de432058/index.html">Was ist neu in AppCode 2018.3?</a></li>
<li><a href="../de432060/index.html">Die besten Möglichkeiten, sich englische Wörter zu merken</a></li>
<li><a href="../de432062/index.html">KI-Entwicklung am Beispiel des Dicey Dungeons-Spiels</a></li>
<li><a href="../de432064/index.html">Wie man den "Hasen" entkommt. UV-Anweisung</a></li>
<li><a href="../de432068/index.html">So erleichtern Sie das Englischlernen: 5 nützliche Dienste</a></li>
<li><a href="../de432072/index.html">Drei Arten von Speicherlecks</a></li>
<li><a href="../de432074/index.html">Wie Spieler Spelunky Reality-Stoff mit Schrotflinten zerreißen</a></li>
<li><a href="../de432076/index.html">Eine nicht erkannte Funktion verlangsamt das Programm fünfmal</a></li>
<li><a href="../de432078/index.html">Verkehr am Ende des Tunnels oder DNS im Pentest</a></li>
<li><a href="../de432080/index.html">Missverständnisse der Spieler bei der Bewertung von Risiken. Steuerung des Zufallszahlengenerators in Entwicklung</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>