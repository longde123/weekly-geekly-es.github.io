<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë®üèº‚Äçüéì ‚õ∏Ô∏è üö¶ Comment faire clignoter 4 LED sur CortexM en utilisant C ++ 17, tuple et un peu de fantaisie ‚öúÔ∏è üë®üèΩ‚Äçüè´ üêù</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Bonne sant√© √† tous! 

 Lorsque j'enseigne aux √©tudiants comment d√©velopper des logiciels embarqu√©s pour les microcontr√¥leurs √† l'universit√©, j'utilise...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Comment faire clignoter 4 LED sur CortexM en utilisant C ++ 17, tuple et un peu de fantaisie</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/457246/"> Bonne sant√© √† tous! <br><br>  Lorsque j'enseigne aux √©tudiants comment d√©velopper des logiciels embarqu√©s pour les microcontr√¥leurs √† l'universit√©, j'utilise le C ++ et parfois je donne aux √©tudiants qui sont particuli√®rement int√©ress√©s par toutes sortes de t√¢ches d'identifier les √©tudiants dou√©s qui sont particuli√®rement <s>malades</s> . <br><br>  Une fois de plus, ces √©tudiants ont eu la t√¢che de faire clignoter 4 LED en utilisant le langage C ++ 17 et la biblioth√®que C ++ standard, sans connecter de biblioth√®ques suppl√©mentaires, telles que CMSIS et leurs fichiers d'en-t√™te avec une description des structures de registre, et ainsi de suite ... Celui avec le code gagne en ROM sera la plus petite taille et la RAM la moins utilis√©e.  L'optimisation du compilateur ne doit pas √™tre sup√©rieure √† Medium.  Compilateur IAR 8.40.1. <br>  Le gagnant se <s>rend aux Canaries et</s> obtient 5 pour l'examen. <br><br>  Moi non plus, je n‚Äôai pas r√©solu ce probl√®me auparavant. Je vais donc vous dire comment les √©l√®ves l‚Äôont r√©solu et ce qui m‚Äôest arriv√©.  Je vous pr√©viens tout de suite qu'il est peu probable qu'un tel code puisse √™tre utilis√© dans de vraies applications, c'est pourquoi j'ai post√© la publication dans la section "Programmation anormale", mais qui sait. <br><a name="habracut"></a><br><h3>  Conditions de t√¢che </h3><br>  Il y a 4 LED sur les ports GPIOA.5, GPIOC.5, GPIOC.8, GPIOC.9.  Ils ont besoin de cligner des yeux.  Pour avoir quelque chose √† comparer, nous avons pris le code √©crit en C: <br><br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">delay</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">1000000</span></span>; ++i){ } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(;;) { GPIOA-&gt;ODR ^= (<span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; <span class="hljs-number"><span class="hljs-number">5</span></span>); GPIOC-&gt;ODR ^= (<span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; <span class="hljs-number"><span class="hljs-number">5</span></span>); GPIOC-&gt;ODR ^= (<span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; <span class="hljs-number"><span class="hljs-number">8</span></span>); GPIOC-&gt;ODR ^= (<span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; <span class="hljs-number"><span class="hljs-number">9</span></span>); delay(); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> ; }</code> </pre> <br>  La fonction <code>delay()</code> est ici purement formelle, un cycle r√©gulier, elle ne peut pas √™tre optimis√©e. <br>  Il est suppos√© que les ports sont d√©j√† configur√©s pour la sortie et que l'horloge leur est appliqu√©e. <br>  Je dirai √©galement tout de suite que le bitbanging n'a pas √©t√© utilis√© pour rendre le code portable. <br><br>  Ce code prend 8 octets sur la pile et 256 octets en ROM sur l'optimisation moyenne <br><blockquote>  255 octets de m√©moire de code en lecture seule <br>  1 octet de m√©moire de donn√©es en lecture seule <br>  8 octets de m√©moire de donn√©es en lecture-√©criture </blockquote><br>  255 octets du fait qu'une partie de la m√©moire est pass√©e sous la table des vecteurs d'interruption, des appels aux fonctions IAR pour initialiser un bloc √† virgule flottante, toutes sortes de fonctions de d√©bogage et la fonction __low_level_init, o√π les ports eux-m√™mes ont √©t√© configur√©s. <br><br>  Ainsi, les exigences compl√®tes sont: <br><br><ul><li>  La fonction main () doit contenir le moins de code possible </li><li>  Vous ne pouvez pas utiliser de macros </li><li>  Compilateur IAR 8.40.1 prenant en charge C ++ 17 </li><li>  Les fichiers d'en-t√™te CMSIS tels que "#include" stm32f411xe.h "ne peuvent pas √™tre utilis√©s </li><li>  Vous pouvez utiliser la directive __forceinline pour les fonctions en ligne </li><li>  Optimisation du compilateur moyen </li></ul><br><h3>  D√©cision des √©tudiants </h3><br>  En g√©n√©ral, il y avait plusieurs solutions, je n'en montrerai qu'une ... ce n'est pas optimal, mais j'ai bien aim√©. <br><br>  Comme les en-t√™tes ne peuvent pas √™tre utilis√©s, la premi√®re chose que les √©tudiants ont faite est la classe <code>Gpio</code> , qui devrait stocker un lien vers les registres de port √† leurs adresses.  Pour ce faire, ils utilisent une superposition de structure, tr√®s probablement ils ont pris l'id√©e d'ici: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Superposition de structure</a> : <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Gpio</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: __<span class="hljs-function"><span class="hljs-function">forceinline </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Toggle</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint8_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> bitNum)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">volatile</span></span></span><span class="hljs-function"> </span></span>{ Odr ^= bitNum ; } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">volatile</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> Moder; <span class="hljs-keyword"><span class="hljs-keyword">volatile</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> Otyper; <span class="hljs-keyword"><span class="hljs-keyword">volatile</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> Ospeedr; <span class="hljs-keyword"><span class="hljs-keyword">volatile</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> Pupdr; <span class="hljs-keyword"><span class="hljs-keyword">volatile</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> Idr; <span class="hljs-keyword"><span class="hljs-keyword">volatile</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> Odr; <span class="hljs-comment"><span class="hljs-comment">//    static_assert(sizeof(Gpio) == sizeof(std::uint32_t) * 6); } ;</span></span></code> </pre> <br>  Comme vous pouvez le voir, ils ont imm√©diatement identifi√© la classe <code>Gpio</code> avec des attributs qui devraient √™tre situ√©s aux adresses des registres correspondants et une m√©thode pour changer d'√©tat par le nombre de branches: <br>  Ensuite, nous avons d√©termin√© la structure de <code>GpioPin</code> contenant le pointeur vers <code>Gpio</code> et le num√©ro de la jambe: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">GpioPin</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">volatile</span></span> Gpio* port ; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> pinNum ; } ;</code> </pre> <br>  Ensuite, ils ont cr√©√© un tableau de LED qui reposent sur les jambes sp√©cifiques du port et l'ont parcouru en appelant la m√©thode <code>Toggle()</code> de chaque LED: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> GpioPin leds[] = {{<span class="hljs-keyword"><span class="hljs-keyword">reinterpret_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">volatile</span></span> Gpio*&gt;(GpioaBaseAddr), <span class="hljs-number"><span class="hljs-number">5</span></span>}, {<span class="hljs-keyword"><span class="hljs-keyword">reinterpret_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">volatile</span></span> Gpio*&gt;(GpiocBaseAddr), <span class="hljs-number"><span class="hljs-number">5</span></span>}, {<span class="hljs-keyword"><span class="hljs-keyword">reinterpret_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">volatile</span></span> Gpio*&gt;(GpiocBaseAddr), <span class="hljs-number"><span class="hljs-number">9</span></span>}, {<span class="hljs-keyword"><span class="hljs-keyword">reinterpret_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">volatile</span></span> Gpio*&gt;(GpiocBaseAddr), <span class="hljs-number"><span class="hljs-number">9</span></span>} } ; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">LedsDriver</span></span></span><span class="hljs-class"> {</span></span> __<span class="hljs-function"><span class="hljs-function">forceinline </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ToggelAll</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span>&amp; it: leds) { it.port-&gt;Toggle(it.pinNum); } } } ;</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Eh bien, en fait, tout le code:</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> GpioaBaseAddr = <span class="hljs-number"><span class="hljs-number">0x4002'0000</span></span> ; <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> GpiocBaseAddr = <span class="hljs-number"><span class="hljs-number">0x4002'0800</span></span> ; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Gpio</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: __<span class="hljs-function"><span class="hljs-function">forceinline </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Toggle</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint8_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> bitNum)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">volatile</span></span></span><span class="hljs-function"> </span></span>{ Odr ^= bitNum ; } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">volatile</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> Moder; <span class="hljs-keyword"><span class="hljs-keyword">volatile</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> Otyper; <span class="hljs-keyword"><span class="hljs-keyword">volatile</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> Ospeedr; <span class="hljs-keyword"><span class="hljs-keyword">volatile</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> Pupdr; <span class="hljs-keyword"><span class="hljs-keyword">volatile</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> Idr; <span class="hljs-keyword"><span class="hljs-keyword">volatile</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> Odr; } ; <span class="hljs-comment"><span class="hljs-comment">//    static_assert(sizeof(Gpio) == sizeof(std::uint32_t) * 6); struct GpioPin { volatile Gpio* port ; std::uint32_t pinNum ; } ; const GpioPin leds[] = {{reinterpret_cast&lt;volatile Gpio*&gt;(GpioaBaseAddr), 5}, {reinterpret_cast&lt;volatile Gpio*&gt;(GpiocBaseAddr), 5}, {reinterpret_cast&lt;volatile Gpio*&gt;(GpiocBaseAddr), 9}, {reinterpret_cast&lt;volatile Gpio*&gt;(GpiocBaseAddr), 9} } ; struct LedsDriver { __forceinline static inline void ToggelAll() { for (auto&amp; it: leds) { it.port-&gt;Toggle(it.pinNum); } } } ; int main() { for(;;) { LedsContainer::ToggleAll() ; delay(); } return 0 ; }</span></span></code> </pre> <br></div></div><br>  Statistiques de leur code sur l'optimisation Medium: <br><blockquote>  275 octets de m√©moire de code en lecture seule <br>  1 octet de m√©moire de donn√©es en lecture seule <br>  8 octets de m√©moire de donn√©es en lecture-√©criture </blockquote><br>  Une bonne solution, mais elle prend beaucoup de m√©moire :) <br><br><h3>  Ma d√©cision </h3><br>  Bien s√ªr, j'ai d√©cid√© de ne pas chercher de moyens simples et j'ai d√©cid√© d'agir s√©rieusement :). <br>  Les LED sont sur diff√©rents ports et diff√©rents pieds.  La premi√®re chose dont vous avez besoin est de cr√©er la classe <code>Port</code> , mais pour vous d√©barrasser des pointeurs et des variables qui prennent de la RAM, vous devez utiliser des m√©thodes statiques.  La classe de port pourrait ressembler √† ceci: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> addr&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Port</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-comment"><span class="hljs-comment">//  -  };</span></span></code> </pre> <br>  En tant que param√®tre de mod√®le, il aura une adresse de port.  Dans l'en- <code>"#include "stm32f411xe.h"</code> , par exemple, pour le port A, il est d√©fini comme GPIOA_BASE. Mais nous ne sommes pas autoris√©s √† utiliser les en-t√™tes, il nous suffit donc de cr√©er notre propre constante. Par cons√©quent, la classe peut √™tre utilis√©e comme suit: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> GpioaBaseAddr = <span class="hljs-number"><span class="hljs-number">0x4002'0000</span></span> ; <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> GpiocBaseAddr = <span class="hljs-number"><span class="hljs-number">0x4002'0800</span></span> ; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> PortA = Port&lt;GpioaBaseAddr&gt; ; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> PortC = Port&lt;GpiocBaseAddr&gt; ;</code> </pre><br>  Pour clignoter, vous avez besoin de la m√©thode Toggle (const std :: uint8_t bit), qui commutera le bit requis √† l'aide d'une op√©ration OU exclusive.  La m√©thode doit √™tre statique, ajoutez-la √† la classe: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> addr&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Port</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-comment"><span class="hljs-comment">//   __forceinline,        __forceinline inline static void Toggle(const std::uint8_t bitNum) { *reinterpret_cast&lt;std::uint32_t*&gt;(addr+20) ^= (1 &lt;&lt; bitNum) ; //addr + 20  ODR  } };</span></span></code> </pre> <br>  Excellent <code>Port&lt;&gt;</code> est, il peut changer l'√©tat des jambes.  La LED se trouve sur une jambe sp√©cifique, il est donc logique de cr√©er une <code>Pin</code> classe, qui aura le <code>Port&lt;&gt;</code> et le num√©ro de jambe comme param√®tres de mod√®le.  √âtant donn√© que le type <code>Port&lt;&gt;</code> est un mod√®le, c'est-√†-dire  diff√©rent pour diff√©rents ports, nous ne pouvons transmettre que le type universel T. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> pinNum&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Pin</span></span></span><span class="hljs-class"> {</span></span> __<span class="hljs-function"><span class="hljs-function">forceinline </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Toggle</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ T::Toggle(pinNum) ; } } ;</code> </pre> <br>  Il est mauvais que nous puissions passer n'importe quel non-sens de type <code>T</code> qui a une m√©thode <code>Toggle()</code> et cela fonctionnera, bien qu'il soit suppos√© que nous ne devrions transmettre que le type <code>Port&lt;&gt;</code> .  Pour <code>PortBase</code> prot√©ger de cela, nous allons faire en sorte que <code>Port&lt;&gt;</code> h√©rite de la classe de base <code>PortBase</code> , et dans le mod√®le, nous v√©rifierons que notre type pass√© est bien bas√© sur <code>PortBase</code> .  Nous obtenons ce qui suit: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> OdrAddrShift = <span class="hljs-number"><span class="hljs-number">20U</span></span>; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PortBase</span></span></span><span class="hljs-class"> {</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> addr&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Port</span></span></span><span class="hljs-class">:</span></span> PortBase { __<span class="hljs-function"><span class="hljs-function">forceinline </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Toggle</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint8_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> bit)</span></span></span><span class="hljs-function"> </span></span>{ *<span class="hljs-keyword"><span class="hljs-keyword">reinterpret_cast</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span>*&gt;(addr ) ^= (<span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; bit) ; } }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> pinNum, <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">typename</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">std</span></span></span><span class="hljs-class">:</span></span>:<span class="hljs-keyword"><span class="hljs-keyword">enable_if_t</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::is_base_of&lt;PortBase, T&gt;::value&gt;&gt; <span class="hljs-comment"><span class="hljs-comment">//   struct Pin { __forceinline inline static void Toggle() { T::Toggle(pinNum) ; } } ;</span></span></code> </pre> <br>  Maintenant, le mod√®le n'est instanci√© que si notre classe a la classe de base <code>PortBase</code> . <br>  En th√©orie, vous pouvez d√©j√† utiliser ces classes, voyons ce qui se passe sans optimisation: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> PortA = Port&lt;GpioaBaseAddr&gt; ; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> PortC = Port&lt;GpiocBaseAddr&gt; ; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Led1 = Pin&lt;PortA, <span class="hljs-number"><span class="hljs-number">5</span></span>&gt; ; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Led2 = Pin&lt;PortC, <span class="hljs-number"><span class="hljs-number">5</span></span>&gt; ; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Led3 = Pin&lt;PortC, <span class="hljs-number"><span class="hljs-number">8</span></span>&gt; ; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Led4 = Pin&lt;PortC, <span class="hljs-number"><span class="hljs-number">9</span></span>&gt; ; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(;;) { Led1::Toggle(); Led2::Toggle(); Led3::Toggle(); Led4::Toggle(); delay(); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> ; }</code> </pre> <br><blockquote>  271 octets de m√©moire de code en lecture seule <br>  1 octet de m√©moire de donn√©es en lecture seule <br>  24 octets de m√©moire de donn√©es en lecture-√©criture </blockquote><br>  D'o√π venaient ces 16 octets suppl√©mentaires en RAM et 16 octets en ROM.  Ils proviennent du fait que nous passons le param√®tre bit √† la fonction Toggle (const std :: uint8_t bit) de la classe Port, et le compilateur, lors de l'entr√©e dans la fonction principale, enregistre 4 registres suppl√©mentaires sur la pile √† travers laquelle ce param√®tre passe, puis les utilise registres dans lesquels les valeurs du num√©ro de jambe pour chaque broche sont stock√©es et lorsque vous quittez principal restaure ces registres √† partir de la pile.  Et bien qu'il s'agisse essentiellement d'une sorte de travail compl√®tement inutile, car les fonctions sont int√©gr√©es, mais le compilateur agit en totale conformit√© avec la norme. <br>  Vous pouvez vous en d√©barrasser en supprimant la classe de port en g√©n√©ral, en passant l'adresse de port en tant que param√®tre de mod√®le pour la classe <code>Pin</code> , et √† l'int√©rieur de la m√©thode <code>Toggle()</code> , calculez l'adresse du registre ODR: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> OdrAddrShift = <span class="hljs-number"><span class="hljs-number">20U</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> addr, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> pinNum, <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Pin</span></span></span><span class="hljs-class"> {</span></span> __<span class="hljs-function"><span class="hljs-function">forceinline </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Toggle</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ *<span class="hljs-keyword"><span class="hljs-keyword">reinterpret_cast</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span>*&gt;(addr + OdrAddrShift ) ^= (<span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; bit) ; } } ; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Led1 = Pin&lt;GpioaBaseAddr, <span class="hljs-number"><span class="hljs-number">5</span></span>&gt; ;</code> </pre> <br>  Mais cela ne semble pas tr√®s bon et convivial.  Par cons√©quent, nous esp√©rons que le compilateur supprime cette conservation de registre inutile avec un peu d'optimisation. <br><br>  Nous mettons l'optimisation sur Medium et voyons le r√©sultat: <br><blockquote>  251 octets de m√©moire de code en lecture seule <br>  1 octet de m√©moire de donn√©es en lecture seule <br>  8 octets de m√©moire de donn√©es en lecture-√©criture </blockquote><br>  Wow wow wow ... nous avons 4 octets de moins <div class="spoiler">  <b class="spoiler_title">code</b> <div class="spoiler_text"><blockquote>  255 octets de m√©moire de code en lecture seule <br>  1 octet de m√©moire de donn√©es en lecture seule <br>  8 octets de m√©moire de donn√©es en lecture-√©criture </blockquote><br></div></div><br>  Comment est-ce possible?  Jetons un coup d'≈ìil √† l'assembleur dans le d√©bogueur pour le code C ++ (√† gauche) et le code C (√† droite): <br><br><img src="https://habrastorage.org/webt/vh/ym/d9/vhymd9hbcko9luonsasg-xz7w7e.png" alt="image"><br><br>  On peut voir que, d'une part, le compilateur a int√©gr√© toutes les fonctions, maintenant il n'y a plus d'appels du tout, et d'autre part, il a optimis√© l'utilisation des registres.  On peut voir que dans le cas du code C, le compilateur utilise le registre R1 ou R2 pour stocker les adresses de port et effectue des op√©rations suppl√©mentaires chaque fois que le bit est commut√© (enregistrez l'adresse dans le registre soit dans R1 soit dans R2).  Dans le second cas, il utilise uniquement le registre R1, et comme les 3 derniers appels de commutation sont toujours depuis le port C, il n'est plus n√©cessaire de sauvegarder la m√™me adresse de port C dans le registre.  En cons√©quence, 2 √©quipes et 4 octets sont enregistr√©s. <br><br>  Ici, c'est un miracle des compilateurs modernes :) Eh bien, d'accord.  En principe, on pourrait s'arr√™ter l√†, mais passons √† autre chose.  Je ne pense pas qu'il sera possible d'optimiser quoi que ce soit d'autre, bien que ce ne soit probablement pas correct, si vous avez des id√©es, √©crivez dans les commentaires.  Mais avec la quantit√© de code dans main (), vous pouvez travailler. <br><br>  Maintenant, je veux que toutes les LED soient quelque part dans le conteneur, et vous pouvez appeler la m√©thode, tout changer ... Quelque chose comme √ßa: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(;;) { LedsContainer::ToggleAll() ; delay(); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> ; }</code> </pre> <br>  On n'ins√©rera pas b√™tement la commutation de 4 LEDs dans la fonction LedsContainer :: ToggleAll, car ce n'est pas int√©ressant :).  Nous voulons mettre les LED dans un conteneur, puis les parcourir et appeler la m√©thode Toggle () sur chacune. <br><br>  <i>Les √©l√®ves ont utilis√© un tableau pour stocker des pointeurs sur des LED.</i>  Mais j'ai diff√©rents types, par exemple: <code>Pin&lt;PortA, 5&gt;</code> , <code>Pin&lt;PortC, 5&gt;</code> , et je ne peux pas stocker de pointeurs vers diff√©rents types dans un tableau.  Vous pouvez cr√©er une classe de base virtuelle pour tous les codes PIN, mais un tableau de fonctions virtuelles appara√Ætra et je ne r√©ussirai pas √† gagner des √©tudiants. <br><br>  Par cons√©quent, nous utiliserons le tuple.  Il vous permet de stocker des objets de diff√©rents types.  Ce cas ressemblera √† ceci: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">LedsContainer</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> records = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::make_tuple ( Pin&lt;PortA, <span class="hljs-number"><span class="hljs-number">5</span></span>&gt;{}, Pin&lt;PortC, <span class="hljs-number"><span class="hljs-number">5</span></span>&gt;{}, Pin&lt;PortC, <span class="hljs-number"><span class="hljs-number">8</span></span>&gt;{}, Pin&lt;PortC, <span class="hljs-number"><span class="hljs-number">9</span></span>&gt;{} ) ; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> tRecordsTuple = <span class="hljs-keyword"><span class="hljs-keyword">decltype</span></span>(records) ; }</code> </pre> <br>  Il y a un grand conteneur, il stocke toutes les LED.  Maintenant, ajoutez-y la m√©thode <code>ToggleAll()</code> : <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">LedsContainer</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: __<span class="hljs-function"><span class="hljs-function">forceinline </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ToggleAll</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//        } private: constexpr static auto records = std::make_tuple ( Pin&lt;PortA, 5&gt;{}, Pin&lt;PortC, 5&gt;{}, Pin&lt;PortC, 8&gt;{}, Pin&lt;PortC, 9&gt;{} ) ; using tRecordsTuple = decltype(records) ; }</span></span></code> </pre> <br>  Vous ne pouvez pas simplement parcourir les √©l√©ments d'un tuple, car l'√©l√©ment tuple ne doit √™tre re√ßu qu'au stade de la compilation.  Pour acc√©der aux √©l√©ments du tuple, il existe une m√©thode d'obtention de mod√®le.  Eh bien, c'est-√†-dire  si nous √©crivons <code>std::get&lt;0&gt;(records).Toggle()</code> , alors la m√©thode <code>Toggle()</code> est appel√©e pour l'objet de la classe <code>Pin&lt;PortA, 5&gt;</code> , si <code>std::get&lt;1&gt;(records).Toggle()</code> , alors la m√©thode <code>Toggle()</code> est appel√©e pour l'objet de la classe <code>Pin&lt;Port, 5&gt;</code> et ainsi de suite ... <br><br>  Vous pouvez <s>essuyer le nez de vos √©l√®ves</s> et √©crire simplement: <br><br><pre> <code class="cpp hljs"> __<span class="hljs-function"><span class="hljs-function">forceinline </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ToggleAll</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::get&lt;<span class="hljs-number"><span class="hljs-number">0</span></span>&gt;(records).Toggle(); <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::get&lt;<span class="hljs-number"><span class="hljs-number">1</span></span>&gt;(records).Toggle(); <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::get&lt;<span class="hljs-number"><span class="hljs-number">2</span></span>&gt;(records).Toggle(); <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::get&lt;<span class="hljs-number"><span class="hljs-number">3</span></span>&gt;(records).Toggle(); }</code> </pre> <br>  Mais nous ne voulons pas forcer le programmeur qui prendra en charge ce code et lui permettra de faire un travail suppl√©mentaire, en d√©pensant les ressources de son entreprise, par exemple, au cas o√π une autre LED appara√Ætrait.  Vous devrez ajouter le code √† deux endroits, dans le tuple et dans cette m√©thode - et ce n'est pas bon et le propri√©taire de l'entreprise ne sera pas tr√®s content.  Par cons√©quent, nous contournons le tuple √† l'aide de m√©thodes d'assistance: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">LedsContainer</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">friend</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: __<span class="hljs-function"><span class="hljs-function">forceinline </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ToggleAll</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//    3,2,1,0    ,     visit(std::make_index_sequence&lt;std::tuple_size&lt;tRecordsTuple&gt;::value&gt;()); } private: __forceinline template&lt;std::size_t... index&gt; static inline void visit(std::index_sequence&lt;index...&gt;) { Pass((std::get&lt;index&gt;(records).Toggle(), true)...); //    get&lt;3&gt;(records).Toggle(), get&lt;2&gt;(records).Toggle(), get&lt;1&gt;(records).Toggle(), get&lt;0&gt;(records).Toggle() } __forceinline template&lt;typename... Args&gt; static void inline Pass(Args... ) {//      } constexpr static auto records = std::make_tuple ( Pin&lt;PortA, 5&gt;{}, Pin&lt;PortC, 5&gt;{}, Pin&lt;PortC, 8&gt;{}, Pin&lt;PortC, 9&gt;{} ) ; using tRecordsTuple = decltype(records) ; }</span></span></code> </pre> <br>  Cela semble effrayant, mais j'ai averti au d√©but de l'article que la m√©thode <s>shizany n'est</s> pas tr√®s ordinaire ... <br><br>  Toute cette magie d'en haut au stade de la compilation fait litt√©ralement ce qui suit: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//  LedsContainer::ToggleAll() ; //   4 : Pin&lt;Port, 9&gt;().Toggle() ; Pin&lt;Port, 8&gt;().Toggle() ; Pin&lt;PortC, 5&gt;().Toggle() ; Pin&lt;PortA, 5&gt;().Toggle() ; //     Toggle() inline,   : *reinterpret_cast&lt;std::uint32_t*&gt;(0x40020814 ) ^= (1 &lt;&lt; 9) ; *reinterpret_cast&lt;std::uint32_t*&gt;(0x40020814 ) ^= (1 &lt;&lt; 8) ; *reinterpret_cast&lt;std::uint32_t*&gt;(0x40020814 ) ^= (1 &lt;&lt; 5) ; *reinterpret_cast&lt;std::uint32_t*&gt;(0x40020014 ) ^= (1 &lt;&lt; 5) ;</span></span></code> </pre> <br>  Allez-y, compilez et v√©rifiez la taille du code sans optimisation: <br><br><div class="spoiler">  <b class="spoiler_title">Le code qui compile</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;cstddef&gt; #include &lt;tuple&gt; #include &lt;utility&gt; #include &lt;cstdint&gt; #include &lt;type_traits&gt; //#include "stm32f411xe.h" #define __forceinline _Pragma("inline=forced") constexpr std::uint32_t GpioaBaseAddr = 0x4002'0000 ; constexpr std::uint32_t GpiocBaseAddr = 0x4002'0800 ; constexpr std::uint32_t OdrAddrShift = 20U; struct PortBase { }; template &lt;std::uint32_t addr&gt; struct Port: PortBase { __forceinline inline static void Toggle(const std::uint8_t bit) { *reinterpret_cast&lt;std::uint32_t*&gt;(addr + OdrAddrShift) ^= (1 &lt;&lt; bit) ; } }; template &lt;typename T, std::uint8_t pinNum, class = typename std::enable_if_t&lt;std::is_base_of&lt;PortBase, T&gt;::value&gt;&gt; struct Pin { __forceinline inline static void Toggle() { T::Toggle(pinNum) ; } } ; using PortA = Port&lt;GpioaBaseAddr&gt; ; using PortC = Port&lt;GpiocBaseAddr&gt; ; //using Led1 = Pin&lt;PortA, 5&gt; ; //using Led2 = Pin&lt;PortC, 5&gt; ; //using Led3 = Pin&lt;PortC, 8&gt; ; //using Led4 = Pin&lt;PortC, 9&gt; ; class LedsContainer { friend int main() ; public: __forceinline static inline void ToggleAll() { //    3,2,1,0    ,     visit(std::make_index_sequence&lt;std::tuple_size&lt;tRecordsTuple&gt;::value&gt;()); } private: __forceinline template&lt;std::size_t... index&gt; static inline void visit(std::index_sequence&lt;index...&gt;) { Pass((std::get&lt;index&gt;(records).Toggle(), true)...); } __forceinline template&lt;typename... Args&gt; static void inline Pass(Args... ) { } constexpr static auto records = std::make_tuple ( Pin&lt;PortA, 5&gt;{}, Pin&lt;PortC, 5&gt;{}, Pin&lt;PortC, 8&gt;{}, Pin&lt;PortC, 9&gt;{} ) ; using tRecordsTuple = decltype(records) ; } ; void delay() { for (int i = 0; i &lt; 1000000; ++i){ } } int main() { for(;;) { LedsContainer::ToggleAll() ; //GPIOA-&gt;ODR ^= 1 &lt;&lt; 5; //GPIOC-&gt;ODR ^= 1 &lt;&lt; 5; //GPIOC-&gt;ODR ^= 1 &lt;&lt; 8; //GPIOC-&gt;ODR ^= 1 &lt;&lt; 9; delay(); } return 0 ; }</span></span></span></span></code> </pre> <br></div></div><br><div class="spoiler">  <b class="spoiler_title">Epreuve de montage, d√©ball√©e comme pr√©vu:</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/0e/aa/un/0eaaunh1qwmg73s1p-3ev4zcpws.png" alt="image"><br></div></div><br>  Nous voyons que la m√©moire est exag√©r√©e, 18 octets de plus.  Les probl√®mes sont les m√™mes, plus 12 autres octets.  Je ne comprenais pas d'o√π ils venaient ... peut-√™tre que quelqu'un va expliquer. <br><blockquote>  283 octets de m√©moire de code en lecture seule <br>  1 octet de m√©moire de donn√©es en lecture seule <br>  24 octets de m√©moire de donn√©es en lecture-√©criture </blockquote><br>  Maintenant, la m√™me chose sur l'optimisation moyenne et lo and behold ... nous avons obtenu un code identique aux impl√©mentations C ++ dans le front et de mani√®re plus optimale le code C. <br><blockquote>  251 octets de m√©moire de code en lecture seule <br>  1 octet de m√©moire de donn√©es en lecture seule <br>  8 octets de m√©moire de donn√©es en lecture-√©criture </blockquote><br><div class="spoiler">  <b class="spoiler_title">Assembleur</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/y4/7w/l9/y47wl95frzmeyb2brdekbnvqvr8.png" alt="image"><br></div></div><br>  Comme vous pouvez le voir, j'ai gagn√© et je suis <s>all√© aux √Æles Canaries</s> et je suis heureux de me reposer √† Tcheliabinsk :), mais les √©tudiants √©taient √©galement super, ils ont r√©ussi l'examen! <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Peu importe, le code est ici</a> <br><br>  O√π puis-je utiliser cela, eh bien, j'ai trouv√©, par exemple, tel, nous avons des param√®tres dans la m√©moire EEPROM et une classe d√©crivant ces param√®tres (lecture, √©criture, initialisation √† la valeur initiale).  La classe est un mod√®le, comme <code>Param&lt;float&lt;&gt;&gt;</code> , <code>Param&lt;int&lt;&gt;&gt;</code> et vous devez, par exemple, r√©initialiser tous les param√®tres aux valeurs par d√©faut.  C'est l√† que vous pouvez les mettre tous dans un tuple, car le type est diff√©rent et appeler la m√©thode <code>SetToDefault()</code> sur chaque param√®tre.  Certes, s'il existe 100 de ces param√®tres, la ROM mangera beaucoup, mais la RAM n'en souffrira pas. <br><br>  PS Je dois admettre qu'√† l'optimisation maximale ce code a la m√™me taille qu'en C et dans ma solution.  Et tous les efforts du programmeur pour am√©liorer le code se r√©sument au m√™me code assembleur. <br><br>  P.S1 Merci <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" class="user_link">0xd34df00d</a> pour les <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" class="user_link">bons</a> conseils.  Vous pouvez simplifier le d√©compactage d'un tuple avec <code>std::apply()</code> .  Le code de la fonction <code>ToggleAll()</code> se simplifie alors comme <code>ToggleAll()</code> : <br><br><pre> <code class="cpp hljs"> __<span class="hljs-function"><span class="hljs-function">forceinline </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ToggleAll</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::apply([](<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span>... args) { (args.Toggle(), ...); }, records); }</code> </pre> <br>  Malheureusement, dans l'IAR, std :: apply n'est pas encore impl√©ment√© dans la version actuelle, mais cela fonctionnera √©galement, voir l' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">impl√©mentation avec std :: apply</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr457246/">https://habr.com/ru/post/fr457246/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr457224/index.html">Une approche moderne de la concurrence dans Android: Corotins chez Kotlin</a></li>
<li><a href="../fr457232/index.html">Abeille robot "Bumble" - le premier vol d'essai √† l'int√©rieur de l'ISS</a></li>
<li><a href="../fr457234/index.html">Biais cognitif du produit</a></li>
<li><a href="../fr457236/index.html">Comment une entreprise informatique a eu du mal √† vendre de la musique</a></li>
<li><a href="../fr457240/index.html">Nouvelles de la semaine: r√©seau neuronal et images photographi√©es, croissance des actions Yandex, Huawei a besoin d'un milliard de dollars pour les brevets</a></li>
<li><a href="../fr457248/index.html">Programmation JavaScript pour un tour</a></li>
<li><a href="../fr457250/index.html">Jour sombre pour Vue.js</a></li>
<li><a href="../fr457254/index.html">Le condens√© de mat√©riaux int√©ressants pour le d√©veloppeur mobile # 303 (17 - 23 juin)</a></li>
<li><a href="../fr457256/index.html">Historique Internet: ARPANET - package</a></li>
<li><a href="../fr457258/index.html">The Pirate Bay depuis 15 ans et n'a pas pu tuer</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>