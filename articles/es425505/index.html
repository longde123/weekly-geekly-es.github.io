<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🧘🏻 🔏 🤦 Análisis del proceso de arranque del kernel de Linux 🔔 🤳🏾 📆</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hola a todos! 

 Mientras Leonid se está preparando para su primera lección abierta en nuestro curso de Administrador de Linux , seguimos hablando de ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Análisis del proceso de arranque del kernel de Linux</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/otus/blog/425505/">  Hola a todos! <br><br>  Mientras <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Leonid se</a> está preparando para su primera <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">lección abierta</a> en nuestro curso de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Administrador de Linux</a> , seguimos hablando de cargar el kernel de Linux. <br><br>  Vamos! <br><br>  Comprender cómo funciona un sistema sin fallas: preparación para solucionar las averías inevitables <br><br>  La broma más antigua en el campo de código abierto es la declaración de que "el código se documenta a sí mismo".  La experiencia ha demostrado que leer el código fuente es como escuchar las previsiones meteorológicas: las personas inteligentes aún saldrán a mirar el cielo.  A continuación se presentan sugerencias para verificar y examinar el arranque del sistema Linux utilizando herramientas de depuración familiares.  Un análisis del proceso de arranque de un sistema que funciona bien prepara a los usuarios y desarrolladores para resolver fallas inevitables. <br><br>  Por un lado, el proceso de descarga es sorprendentemente simple.  El núcleo del sistema operativo (kernel) se ejecuta con un solo subproceso y sincrónicamente en un núcleo (núcleo), lo que puede parecer comprensible incluso para una mente humana patética.  Pero, ¿cómo comienza el núcleo del sistema operativo?  ¿Qué funciones hacen initrd ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">un disco RAM para la inicialización inicial</a> ) y los cargadores de arranque?  Y espera, ¿por qué el LED en el puerto Ethernet siempre está encendido? <br><br><img src="https://habrastorage.org/webt/dl/v5/cc/dlv5cchbiput5mmnbjyzz1nloho.png"><a name="habracut"></a><br><br>  Siga leyendo para obtener respuestas a estas y algunas otras preguntas;  El código para las demostraciones y ejercicios descritos también está disponible en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">GitHub</a> . <br><br>  <b>Inicio del arranque: estado desactivado</b> <br><br>  <i><b>Wake-on-LAN</b></i> <br><br>  Un estado de APAGADO significa que el sistema no tiene energía, ¿verdad?  La aparente simplicidad es engañosa.  Por ejemplo, el LED de Ethernet está encendido incluso en este estado, porque la activación en LAN (WOL, activación en [señal desde] red local) está activada en su sistema.  Asegúrate escribiendo: <br><br><pre><code class="bash hljs"><span class="hljs-variable"><span class="hljs-variable">$#</span></span> sudo ethtool &lt;interface name&gt;</code> </pre> <br>  Donde, en cambio, puede ser, por ejemplo, eth0 (ethtool está en paquetes Linux con el mismo nombre).  Si el "Wake-on" en la salida muestra g, los hosts remotos pueden iniciar el sistema enviando <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">MagicPacket</a> .  Si no desea encender su sistema de forma remota y dar esta oportunidad a otros, desactive WOL en el menú del BIOS del sistema o use: <br><br><pre> <code class="bash hljs"><span class="hljs-variable"><span class="hljs-variable">$#</span></span> sudo ethtool -s &lt;interface name&gt; wol d</code> </pre> <br>  Un procesador que responde a MagicPacket puede ser un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">controlador de administración de placa base</a> (BMC) o parte de una interfaz de red. <br><br>  <i><b>Intel Management Engine, Platform Controller Hub y Minix</b></i> <br><br>  BMC no es el único microcontrolador (MCU) que puede "escuchar" un sistema apagado nominalmente.  Los sistemas X86_64 tienen el paquete de software Intel Management Engine (IME) para la administración remota de sistemas.  Una amplia gama de dispositivos, desde servidores hasta computadoras portátiles, tienen tecnología que <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">tiene características</a> como KVM Remote Control o Intel Capability Licensing Service.  Según la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">herramienta de Inte</a> l, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">IME tiene vulnerabilidades sin parches.</a>  La mala noticia es que deshabilitar IME es difícil.  Trammell Hudson creó <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">el proyecto me_cleaner, que borra</a> algunos de los componentes IME más atroces, como el servidor web incorporado, pero al mismo tiempo existe la posibilidad de que el uso del proyecto convierta el sistema en el que se está ejecutando. <br><br>  El firmware IME y el programa de Modo de administración del sistema (SMM) que lo sigue en el arranque se basan en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">el sistema operativo Minix</a> y se ejecutan en un procesador Hub de controlador de plataforma separado, no en la CPU principal del sistema.  Luego, SMM lanza el programa Universal Extensible Firmware Interface (UEFI) en el procesador principal, que se ha <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">escrito más de una vez</a> .  El grupo Coreboot lanzó un proyecto <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">de firmware reducido no extensible (NERF)</a> espectacularmente ambicioso en Google, que tiene como objetivo reemplazar no solo UEFI, sino también los primeros componentes del espacio de usuario de Linux, como systemd.  Mientras tanto, estamos esperando los resultados, los usuarios de Linux pueden comprar computadoras portátiles de Purism, System76 o Dell, en las que <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">IME está desactivado</a> , además, podemos esperar computadoras portátiles con un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">procesador ARM de 64 bits</a> . <br><br>  <i><b>Cargadores</b></i> <i><b><br></b></i> <br>  ¿Qué hace el firmware de arranque además de lanzar el presunto spyware?  La tarea del gestor de arranque es proporcionar al procesador que se acaba de encender con los recursos necesarios para ejecutar un sistema operativo de propósito general como Linux.  Durante el encendido, no solo hay memoria virtual, sino también DRAM hasta el momento de elevar su controlador.  Luego, el cargador de arranque enciende las fuentes de alimentación y escanea los buses e interfaces para encontrar la imagen del núcleo y el sistema de archivos raíz.  Los cargadores de arranque populares, como U-Boot y GRUB, admiten interfaces comunes como USB, PCI y NFS, así como otros dispositivos integrados más especializados, como NOR y NAND-flash.  Los cargadores también interactúan con dispositivos de hardware de seguridad, como <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Trusted Platform Module (TPM)</a> , para establecer una cadena de confianza desde el inicio de la descarga. <br><br><img src="https://habrastorage.org/webt/ur/fy/-n/urfy-neq9uuqezexjmitgdyg4aa.png"><br>  <i>Ejecutando el cargador U-boot en el sandbox en el servidor de compilación.</i> <br><br>  El popular <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">cargador de</a> arranque <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">U-Boot de</a> código abierto es compatible con sistemas desde Raspberry Pi hasta dispositivos Nintendo, tableros de automóviles y Chromebooks.  No hay registro del sistema, y ​​si algo sale mal, puede que ni siquiera haya salida de consola.  Para facilitar la depuración, el equipo de U-Boot proporciona un entorno limitado para probar parches en el host de compilación o incluso en el sistema de integración continua.  En un sistema con herramientas de desarrollo comunes como Git y GNU Compiler Collection (GCC) instaladas, comprender el entorno limitado de U-Boot es fácil. <br><br><pre> <code class="bash hljs"><span class="hljs-variable"><span class="hljs-variable">$#</span></span> git <span class="hljs-built_in"><span class="hljs-built_in">clone</span></span> git://git.denx.de/u-boot; <span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> u-boot <span class="hljs-variable"><span class="hljs-variable">$#</span></span> make ARCH=sandbox defconfig <span class="hljs-variable"><span class="hljs-variable">$#</span></span> make; ./u-boot =&gt; printenv =&gt; <span class="hljs-built_in"><span class="hljs-built_in">help</span></span></code> </pre><br>  Eso es todo: lanzó U-Boot en x86_64 y puede probar características complicadas, por ejemplo, repartición de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">dispositivos de almacenamiento ficticios</a> , manipulación de claves secretas basadas en TPM y conexión en caliente de dispositivos USB.  El entorno limitado U-Boot puede ser de una etapa dentro del depurador GDB.  El desarrollo utilizando el sandbox es 10 veces más rápido que las pruebas sobrescribiendo el gestor de arranque en el tablero, además, el sandbox "ladrillo" se puede restaurar presionando Ctrl + C. <br><br>  <b>Lanzamiento de Kernel</b> <br><br>  <i><b>Suministro de kernel de arranque</b></i> <br><br>  Una vez completadas sus tareas, el gestor de arranque cambiará al código del núcleo que cargó en la memoria principal y comenzará a ejecutarlo, pasando todos los parámetros de línea de comando que especificó el usuario.  ¿Qué programa es el kernel?  file / boot / vmlinuz muestra que esto es bzImage.  El árbol fuente de Linux tiene <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">una herramienta extract-vmlinux</a> que puede usar para extraer el archivo: <br><br><pre> <code class="bash hljs"><span class="hljs-variable"><span class="hljs-variable">$#</span></span> scripts/extract-vmlinux /boot/vmlinuz-$(uname -r) &gt; vmlinux <span class="hljs-variable"><span class="hljs-variable">$#</span></span> file vmlinux vmlinux: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), statically linked, stripped</code> </pre><br>  El kernel es un archivo binario de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">formato ejecutable y de enlace (ELF)</a> , como los programas de espacio de usuario de Linux.  Esto significa que podemos usar comandos binutils como readelf para aprenderlo.  Compare, por ejemplo, las siguientes conclusiones: <br><br><pre> <code class="bash hljs"><span class="hljs-variable"><span class="hljs-variable">$#</span></span> readelf -S /bin/date <span class="hljs-variable"><span class="hljs-variable">$#</span></span> readelf -S vmlinux</code> </pre><br>  La lista de particiones en archivos binarios es en su mayor parte similar. <br><br>  Entonces, el kernel debería lanzar otros binarios ELF de Linux ... ¿Pero cómo se ejecutan los programas de espacio de usuario?  En la función <code>main()</code> , ¿verdad?  En realidad no <br><br>  Antes de ejecutar la función <code>main()</code> , los programas necesitan un contexto de ejecución, que incluye memoria heap- (heap) y stack- (stack), además de descriptores de archivo para <code>stdio</code> , <code>stdout</code> y <code>stderr</code> .  Los programas de espacio de usuario obtienen estos recursos de la biblioteca estándar ( <code>glibc</code> para la mayoría de los sistemas Linux).  Considere lo siguiente: <br><br><pre> <code class="bash hljs"><span class="hljs-variable"><span class="hljs-variable">$#</span></span> file /bin/date /bin/date: ELF 64-bit LSB shared object, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> GNU/Linux 2.6.32, BuildID[sha1]=14e8563676febeb06d701dbee35d225c5a8e565a, stripped</code> </pre> <br>  Los archivos binarios ELF tienen un intérprete, al igual que los scripts de Bash y Python.  ¡Pero no necesita especificarse a través de <code>#!</code>  como en los scripts, porque ELF es un formato nativo de Linux.  El intérprete ELF proporciona al archivo binario todos los recursos necesarios llamando a <code>_start()</code> , una función disponible en el <code>glibc</code> fuente <code>glibc</code> , que se puede aprender a través de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">GDB</a> .  El núcleo, obviamente, no tiene un intérprete, y debería suministrarse de forma independiente, pero ¿cómo? <br><br>  Un estudio sobre cómo iniciar un núcleo con GDB proporciona una respuesta a esta pregunta.  Para comenzar, instale el paquete de depuración del núcleo, que contiene la versión sin cortar de <code>vmlinux</code> , por ejemplo, <code>apt-get install linux-image-amd64-dbg</code> .  O compile e instale su propio núcleo desde alguna fuente, por ejemplo, siguiendo las instrucciones del excelente <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Manual del núcleo de Debian</a> .  <code>gdb vmlinux</code> seguido de <code>info files</code> muestra la sección ELF <code>init.text</code> .  Indique el inicio de la ejecución del programa en <code>init.text</code> con <code>l *(address)</code> , donde dirección es el inicio hexadecimal de <code>init.text</code> .  GDB indicará que el núcleo x86_64 se inicia en el <code><a href="">arch/x86/kernel/head_64.S</a></code> , donde encontramos la función de compilación <code>start_cpu0()</code> y el código que crea explícitamente la pila y descomprime zImage antes de llamar a <code>x86_64 start_kernel()</code> .  Los núcleos ARM de 32 bits tienen un <code><a href="">arch/arm/kernel/head.S. start_kernel()</a></code>  <code><a href="">arch/arm/kernel/head.S. start_kernel()</a></code> es independiente de la arquitectura, por lo que la función se encuentra en el núcleo <code>init/main.c</code>  Podemos decir que <code>start_kernel()</code> es una función real <code>main()</code> Linux. <br><br>  <b>De start_kernel () a PID 1</b> <br>  <i><b>Manifiesto del hardware del núcleo: tablas ACPI y árboles de dispositivos</b></i> <br><br>  Al arrancar, el kernel necesita información sobre el hardware además del tipo de procesador para el que fue compilado.  Las instrucciones en el código se complementan con datos de configuración, que se almacenan por separado.  Hay dos métodos principales para almacenar datos: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">árboles de</a> dispositivos y <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">tablas ACPI</a> .  A partir de estos archivos, el kernel descubre qué equipo debe ejecutarse en cada arranque. <br><br>  Para dispositivos integrados, el árbol de dispositivos (DU) es un manifiesto del equipo instalado.  DU es un archivo que se compila al mismo tiempo que la fuente del núcleo y generalmente se encuentra en / boot junto con <code>vmlinux</code> .  Para ver qué hay en el árbol de dispositivos binarios en el dispositivo ARM, simplemente use el comando de <code>strings</code> del paquete binutils en el archivo cuyo nombre corresponde a <code>/boot/*.dtb</code> , ya que <code>dtb</code> significa el archivo binario del árbol de dispositivos (Device-Tree Binary).  Puede cambiar el control remoto editando los archivos similares a JSON en los que se compone y reiniciando el compilador dtc especial provisto con la fuente del núcleo.  DU es un archivo estático cuya ruta generalmente se pasa al núcleo por los gestores de arranque en la línea de comando, pero en los últimos años se ha agregado una <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">superposición de árbol de dispositivos</a> donde el núcleo puede cargar dinámicamente fragmentos adicionales en respuesta a eventos de conexión en caliente después de la carga. <br><br>  La familia x86 y muchos dispositivos de nivel empresarial ARM64 utilizan el mecanismo alternativo de Interfaz avanzada de configuración y energía ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">ACPI)</a> .  A diferencia del control remoto, la información ACPI se almacena en el sistema de archivos virtual <code>/sys/firmware/acpi/tables</code> , que es creado por el núcleo al inicio al acceder a la ROM interna.  Para leer las tablas ACPI, use el comando <code>acpica-tools</code> paquete <code>acpica-tools</code> .  Aquí hay un ejemplo: <br><br><img src="https://habrastorage.org/webt/gq/gw/mj/gqgwmjbpkadcvz6fbzyp7uc8gvg.png"><br>  <i>Las tablas ACPI en las computadoras portátiles Lenovo están listas para Windows 2001.</i> <br><br>  Sí, su sistema Linux está listo para Windows 2001 si desea instalarlo.  ACPI tiene métodos y datos, en contraste con el control remoto, que es más como un lenguaje de descripción de hardware.  Los métodos ACPI continúan activos después del arranque.  Por ejemplo, si ejecuta el comando acpi_listen (desde el paquete apcid) y luego cierra y abre la tapa de la computadora portátil, verá que la funcionalidad ACPI continuó funcionando todo este tiempo.  La <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">reescritura</a> temporal y dinámica <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">de las tablas ACPI</a> es posible, pero el cambio permanente requerirá la interacción con el menú del BIOS al arrancar o flashear la ROM.  En lugar de tales complejidades, quizás debería simplemente <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">instalar coreboot</a> , un reemplazo para el firmware de código abierto. <br><br>  De start_kernel () al espacio de usuario <br><br>  El código en <code><a href="">init/main.c</a></code> es sorprendentemente fácil de leer y, curiosamente, todavía usa los derechos de autor originales de Linus Torvalds de 1991-1992.  Líneas encontradas en <code>dmesg | head</code>  <code>dmesg | head</code> sistema en ejecución se origina básicamente en este archivo fuente.  El sistema registra la primera CPU, las estructuras de datos globales se inicializan, una tras otra, se activan el planificador, los controladores de interrupciones (IRQ), los temporizadores y la consola.  Todas las marcas de tiempo antes de ejecutar <code>timekeeping_init()</code> son cero.  Esta parte de la inicialización del núcleo es síncrona, es decir, la ejecución se produce en un solo subproceso.  Las funciones no se ejecutan hasta que se completa y se devuelve la última.  Como resultado, la salida de <code>dmesg</code> será totalmente reproducible incluso entre los dos sistemas, siempre que tengan el mismo control remoto o tablas ACPI.  Linux también se comporta como un sistema operativo en tiempo real (RTOS) que se ejecuta en una MCU, como QNX o VxWorks.  Esta situación se almacena en la función <code>rest_init()</code> , que es llamada por <code>start_kernel()</code> en el momento de su finalización. <br><br><img src="https://habrastorage.org/webt/dt/ge/49/dtge49gofpzdjlzk__surv1x9-o.png"><br>  <i>Una breve descripción del proceso inicial de arranque del kernel</i> <i><br></i> <br>  El modesto nombre <code>rest_init()</code> crea un nuevo hilo que ejecuta <code>kernel_init()</code> , que a su vez llama a <code>do_initcalls()</code> .  Los usuarios pueden monitorear la operación de <code>initcalls</code> agregando <code>initcalls_debug</code> a la línea de comando del kernel.  Como resultado, obtendrá la entidad <code>dmesg</code> cada vez que ejecute la función <code>initcall</code> .  <code>initcalls</code> pasa por siete niveles consecutivos: temprano, núcleo, postcore, arch, subsys, fs, dispositivo y tarde.  La parte más notable de <code>initcalls</code> para los usuarios es la identificación e instalación de dispositivos periféricos del procesador: buses, red, almacenamiento, pantallas, etc., acompañados de la carga de sus módulos de kernel.  <code>rest_init()</code> también crea un segundo subproceso en el procesador de arranque, que comienza ejecutando <code>cpu_idle()</code> mientras el programador distribuye su trabajo. <br><br>  <code>kernel_init()</code> también configura el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">multiprocesamiento simétrico</a> (SMP).  En los núcleos modernos, puede encontrar este momento en la salida de dmesg con la línea "Activando CPU secundarias ...".  SMP luego realiza la conexión en caliente de la CPU, lo que significa que gestiona su ciclo de vida utilizando una máquina de estado condicionalmente similar a la utilizada en dispositivos como memorias USB con detección automática.  El sistema de administración de energía del núcleo a menudo apaga los núcleos individuales (núcleos) y los activa según sea necesario para que el mismo código de CPU de conexión en caliente se llame repetidamente en una máquina desocupada.  Eche un vistazo a cómo un sistema de administración de energía <code>offcputime.py</code> CPU utilizando <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">una herramienta BCC</a> llamada <code>offcputime.py</code> . <br><br>  Tenga en cuenta que el código en <code>init/main.c</code> casi terminó de ejecutarse cuando se <code>smp_init()</code> .  El procesador de arranque completó la mayor parte de la inicialización única, que otros núcleos no necesitan repetir.  Sin embargo, se deben crear subprocesos para cada núcleo para controlar las interrupciones (IRQ), la cola de trabajo, los temporizadores y los eventos de potencia en cada uno.  Por ejemplo, observe los hilos del procesador que sirven softirqs y colas de trabajo con el comando <code>ps -o psr.</code> psr <code>ps -o psr.</code> <br><br><pre> <code class="bash hljs">$\<span class="hljs-comment"><span class="hljs-comment"># ps -o pid,psr,comm $(pgrep ksoftirqd) PID PSR COMMAND 7 0 ksoftirqd/0 16 1 ksoftirqd/1 22 2 ksoftirqd/2 28 3 ksoftirqd/3 $\# ps -o pid,psr,comm $(pgrep kworker) PID PSR COMMAND 4 0 kworker/0:0H 18 1 kworker/1:0H 24 2 kworker/2:0H 30 3 kworker/3:0H [ . . . ]</span></span></code> </pre> <br>  donde el campo PSR significa "procesador".  Cada núcleo debe tener sus propios temporizadores y controladores de conexión en caliente cpuhp. <br><br>  Y finalmente, ¿cómo se lanza el espacio de usuario?  Hacia el final, <code>kernel_init()</code> buscando un <code>initrd</code> que pueda iniciar el proceso <code>init</code> en su nombre.  Si no, el núcleo ejecuta <code>init</code> sí solo.  ¿Por qué entonces se puede necesitar <code>initrd</code> ? <br><br>  <i><b>Espacio de usuario temprano: ¿quién ordenó initrd?</b></i> <br><br>  Además del árbol de dispositivos, otra ruta de inicio al archivo, opcionalmente proporcionada por el núcleo en el arranque, pertenece a <code>initrd</code> .  <code>initrd</code> menudo se encuentra en / boot junto con el archivo bzImage vmlinuz en x86, o con un árbol similar de imágenes y dispositivos para ARM.  Se puede ver una lista de contenidos <code>intrd</code> usando la herramienta <code>lsinitramfs</code> , que es parte del paquete <code>initramfs-tools-core</code> .  La imagen de distribución initrd contiene los directorios mínimos <code>/bin</code> , <code>/sbin</code> y <code>/etc</code> , así como los módulos del núcleo y los archivos en <code>/scripts</code> .  Todo debería parecer más o menos familiar, ya que <code>initrd</code> en su mayor parte similar al sistema simplificado de archivos raíz de Linux.  Esta similitud es un poco engañosa, ya que casi todos los ejecutables en <code>/bin</code> y <code>/sbin</code> dentro de ramdisk son enlaces simbólicos al <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">binario BusyBox</a> , lo que hace que los directorios / bin y / sbin sean 10 veces más pequeños que en <code>glibc</code> . <br><br>  ¿Por qué intentar crear un <code>initrd</code> si lo único que hace es cargar algunos módulos y ejecutar <code>init</code> en un sistema de archivos raíz normal?  Considere un sistema de archivos raíz encriptado.  El descifrado puede depender de cargar el módulo del núcleo almacenado en <code>/lib/modules</code> sistema de archivos raíz ... y, como se esperaba, en <code>initrd</code> .  El módulo criptográfico puede compilarse estáticamente en el kernel y no cargarse desde un archivo, pero hay varias razones para rechazar esto.  Por ejemplo, la compilación estática de un núcleo con módulos puede hacer que sea demasiado grande para caber en el almacenamiento disponible, o la compilación estática puede violar los términos de la licencia de software.  Como era de esperar, los controladores de almacenamiento, las redes y los HID (dispositivos de entrada humanos) también se pueden representar en <code>initrd</code> , esencialmente cualquier código que no sea una parte necesaria del núcleo necesario para montar el sistema de archivos raíz.  También en initrd, los usuarios pueden almacenar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">su propio código ACPI para tablas</a> . <br><br><img src="https://habrastorage.org/webt/gx/nj/lj/gxnjljvh-gs47qpacftktsubl2e.png"><br>  <i>Diversión con shell de rescate e initrd personalizado.</i> <br><br>  <code>initrd</code> también <code>initrd</code> ideal para probar sistemas de archivos y dispositivos de almacenamiento.  Coloque las herramientas de prueba en <code>initrd</code> y ejecute las pruebas desde la memoria, no desde el objeto de prueba. <br><br>  Finalmente, cuando <code>init</code> ejecutando, ¡el sistema se está ejecutando!  Dado que los procesadores secundarios ya están en funcionamiento, la máquina se ha convertido en una criatura asíncrona, paginada, impredecible y de alto rendimiento que todos conocemos y amamos.  De hecho, <code>ps -o pid,psr,comm -p</code> indica que el proceso de <code>init</code> espacio de usuario ya no se ejecuta en el procesador de arranque. <br><br>  <b>Resumen</b> <br><br>  El proceso de arranque de Linux parece prohibido, dada la cantidad de software afectado, incluso en un dispositivo integrado simple.  Por otro lado, el proceso de arranque es bastante simple, ya que no hay una complejidad excesiva causada por el desplazamiento de multitarea, RCU y condiciones de carrera.  Prestando atención solo al kernel y al PID 1, se puede pasar por alto el gran trabajo realizado por los cargadores de arranque y los procesadores auxiliares para preparar la plataforma para el lanzamiento del kernel.  El kernel es ciertamente diferente de otros programas de Linux, pero el uso de herramientas para trabajar con otros binarios ELF ayudará a comprender mejor su estructura.  Estudiar un proceso de arranque viable preparará para futuros bloqueos. <br><br>  El fin <br><br>  Estamos esperando sus comentarios y preguntas, como de costumbre, ya sea aquí o en nuestra <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">lección abierta</a> donde Leonid quedará impresionado. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es425505/">https://habr.com/ru/post/es425505/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es425493/index.html">Configuración de MikroTik hAP mini para IPTV Beeline</a></li>
<li><a href="../es425497/index.html">Tutu PHP Meetup # 2: transmisión de eventos en vivo</a></li>
<li><a href="../es425499/index.html">HyperX Impact DDR4: ¡SO-DIMM que podría! ¿O por qué en una computadora portátil 64 GB de memoria con una frecuencia de 3200 MHz?</a></li>
<li><a href="../es425501/index.html">Pruebas A / B en Android de la A a la Z</a></li>
<li><a href="../es425503/index.html">Cassandra Sink para Spark Structured Streaming</a></li>
<li><a href="../es425507/index.html">Parsim Wikipedia para tareas de PNL en 4 equipos</a></li>
<li><a href="../es425511/index.html">Características no obvias de la aplicación Rotativa para generar PDF en la aplicación ASP.NET MVC</a></li>
<li><a href="../es425515/index.html">Apple bloquea la reparación independiente de los nuevos modelos de MacBook</a></li>
<li><a href="../es425517/index.html">Cómo Yandex creó un pronóstico de precipitación global utilizando radares y satélites</a></li>
<li><a href="../es425521/index.html">Métodos protegidos en JavaScript ES5</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>