<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üßòüèª üîè ü§¶ An√°lisis del proceso de arranque del kernel de Linux üîî ü§≥üèæ üìÜ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hola a todos! 

 Mientras Leonid se est√° preparando para su primera lecci√≥n abierta en nuestro curso de Administrador de Linux , seguimos hablando de ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>An√°lisis del proceso de arranque del kernel de Linux</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/otus/blog/425505/">  Hola a todos! <br><br>  Mientras <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Leonid se</a> est√° preparando para su primera <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">lecci√≥n abierta</a> en nuestro curso de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Administrador de Linux</a> , seguimos hablando de cargar el kernel de Linux. <br><br>  Vamos! <br><br>  Comprender c√≥mo funciona un sistema sin fallas: preparaci√≥n para solucionar las aver√≠as inevitables <br><br>  La broma m√°s antigua en el campo de c√≥digo abierto es la declaraci√≥n de que "el c√≥digo se documenta a s√≠ mismo".  La experiencia ha demostrado que leer el c√≥digo fuente es como escuchar las previsiones meteorol√≥gicas: las personas inteligentes a√∫n saldr√°n a mirar el cielo.  A continuaci√≥n se presentan sugerencias para verificar y examinar el arranque del sistema Linux utilizando herramientas de depuraci√≥n familiares.  Un an√°lisis del proceso de arranque de un sistema que funciona bien prepara a los usuarios y desarrolladores para resolver fallas inevitables. <br><br>  Por un lado, el proceso de descarga es sorprendentemente simple.  El n√∫cleo del sistema operativo (kernel) se ejecuta con un solo subproceso y sincr√≥nicamente en un n√∫cleo (n√∫cleo), lo que puede parecer comprensible incluso para una mente humana pat√©tica.  Pero, ¬øc√≥mo comienza el n√∫cleo del sistema operativo?  ¬øQu√© funciones hacen initrd ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">un disco RAM para la inicializaci√≥n inicial</a> ) y los cargadores de arranque?  Y espera, ¬øpor qu√© el LED en el puerto Ethernet siempre est√° encendido? <br><br><img src="https://habrastorage.org/webt/dl/v5/cc/dlv5cchbiput5mmnbjyzz1nloho.png"><a name="habracut"></a><br><br>  Siga leyendo para obtener respuestas a estas y algunas otras preguntas;  El c√≥digo para las demostraciones y ejercicios descritos tambi√©n est√° disponible en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">GitHub</a> . <br><br>  <b>Inicio del arranque: estado desactivado</b> <br><br>  <i><b>Wake-on-LAN</b></i> <br><br>  Un estado de APAGADO significa que el sistema no tiene energ√≠a, ¬øverdad?  La aparente simplicidad es enga√±osa.  Por ejemplo, el LED de Ethernet est√° encendido incluso en este estado, porque la activaci√≥n en LAN (WOL, activaci√≥n en [se√±al desde] red local) est√° activada en su sistema.  Aseg√∫rate escribiendo: <br><br><pre><code class="bash hljs"><span class="hljs-variable"><span class="hljs-variable">$#</span></span> sudo ethtool &lt;interface name&gt;</code> </pre> <br>  Donde, en cambio, puede ser, por ejemplo, eth0 (ethtool est√° en paquetes Linux con el mismo nombre).  Si el "Wake-on" en la salida muestra g, los hosts remotos pueden iniciar el sistema enviando <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">MagicPacket</a> .  Si no desea encender su sistema de forma remota y dar esta oportunidad a otros, desactive WOL en el men√∫ del BIOS del sistema o use: <br><br><pre> <code class="bash hljs"><span class="hljs-variable"><span class="hljs-variable">$#</span></span> sudo ethtool -s &lt;interface name&gt; wol d</code> </pre> <br>  Un procesador que responde a MagicPacket puede ser un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">controlador de administraci√≥n de placa base</a> (BMC) o parte de una interfaz de red. <br><br>  <i><b>Intel Management Engine, Platform Controller Hub y Minix</b></i> <br><br>  BMC no es el √∫nico microcontrolador (MCU) que puede "escuchar" un sistema apagado nominalmente.  Los sistemas X86_64 tienen el paquete de software Intel Management Engine (IME) para la administraci√≥n remota de sistemas.  Una amplia gama de dispositivos, desde servidores hasta computadoras port√°tiles, tienen tecnolog√≠a que <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">tiene caracter√≠sticas</a> como KVM Remote Control o Intel Capability Licensing Service.  Seg√∫n la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">herramienta de Inte</a> l, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">IME tiene vulnerabilidades sin parches.</a>  La mala noticia es que deshabilitar IME es dif√≠cil.  Trammell Hudson cre√≥ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">el proyecto me_cleaner, que borra</a> algunos de los componentes IME m√°s atroces, como el servidor web incorporado, pero al mismo tiempo existe la posibilidad de que el uso del proyecto convierta el sistema en el que se est√° ejecutando. <br><br>  El firmware IME y el programa de Modo de administraci√≥n del sistema (SMM) que lo sigue en el arranque se basan en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">el sistema operativo Minix</a> y se ejecutan en un procesador Hub de controlador de plataforma separado, no en la CPU principal del sistema.  Luego, SMM lanza el programa Universal Extensible Firmware Interface (UEFI) en el procesador principal, que se ha <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">escrito m√°s de una vez</a> .  El grupo Coreboot lanz√≥ un proyecto <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">de firmware reducido no extensible (NERF)</a> espectacularmente ambicioso en Google, que tiene como objetivo reemplazar no solo UEFI, sino tambi√©n los primeros componentes del espacio de usuario de Linux, como systemd.  Mientras tanto, estamos esperando los resultados, los usuarios de Linux pueden comprar computadoras port√°tiles de Purism, System76 o Dell, en las que <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">IME est√° desactivado</a> , adem√°s, podemos esperar computadoras port√°tiles con un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">procesador ARM de 64 bits</a> . <br><br>  <i><b>Cargadores</b></i> <i><b><br></b></i> <br>  ¬øQu√© hace el firmware de arranque adem√°s de lanzar el presunto spyware?  La tarea del gestor de arranque es proporcionar al procesador que se acaba de encender con los recursos necesarios para ejecutar un sistema operativo de prop√≥sito general como Linux.  Durante el encendido, no solo hay memoria virtual, sino tambi√©n DRAM hasta el momento de elevar su controlador.  Luego, el cargador de arranque enciende las fuentes de alimentaci√≥n y escanea los buses e interfaces para encontrar la imagen del n√∫cleo y el sistema de archivos ra√≠z.  Los cargadores de arranque populares, como U-Boot y GRUB, admiten interfaces comunes como USB, PCI y NFS, as√≠ como otros dispositivos integrados m√°s especializados, como NOR y NAND-flash.  Los cargadores tambi√©n interact√∫an con dispositivos de hardware de seguridad, como <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Trusted Platform Module (TPM)</a> , para establecer una cadena de confianza desde el inicio de la descarga. <br><br><img src="https://habrastorage.org/webt/ur/fy/-n/urfy-neq9uuqezexjmitgdyg4aa.png"><br>  <i>Ejecutando el cargador U-boot en el sandbox en el servidor de compilaci√≥n.</i> <br><br>  El popular <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">cargador de</a> arranque <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">U-Boot de</a> c√≥digo abierto es compatible con sistemas desde Raspberry Pi hasta dispositivos Nintendo, tableros de autom√≥viles y Chromebooks.  No hay registro del sistema, y ‚Äã‚Äãsi algo sale mal, puede que ni siquiera haya salida de consola.  Para facilitar la depuraci√≥n, el equipo de U-Boot proporciona un entorno limitado para probar parches en el host de compilaci√≥n o incluso en el sistema de integraci√≥n continua.  En un sistema con herramientas de desarrollo comunes como Git y GNU Compiler Collection (GCC) instaladas, comprender el entorno limitado de U-Boot es f√°cil. <br><br><pre> <code class="bash hljs"><span class="hljs-variable"><span class="hljs-variable">$#</span></span> git <span class="hljs-built_in"><span class="hljs-built_in">clone</span></span> git://git.denx.de/u-boot; <span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> u-boot <span class="hljs-variable"><span class="hljs-variable">$#</span></span> make ARCH=sandbox defconfig <span class="hljs-variable"><span class="hljs-variable">$#</span></span> make; ./u-boot =&gt; printenv =&gt; <span class="hljs-built_in"><span class="hljs-built_in">help</span></span></code> </pre><br>  Eso es todo: lanz√≥ U-Boot en x86_64 y puede probar caracter√≠sticas complicadas, por ejemplo, repartici√≥n de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">dispositivos de almacenamiento ficticios</a> , manipulaci√≥n de claves secretas basadas en TPM y conexi√≥n en caliente de dispositivos USB.  El entorno limitado U-Boot puede ser de una etapa dentro del depurador GDB.  El desarrollo utilizando el sandbox es 10 veces m√°s r√°pido que las pruebas sobrescribiendo el gestor de arranque en el tablero, adem√°s, el sandbox "ladrillo" se puede restaurar presionando Ctrl + C. <br><br>  <b>Lanzamiento de Kernel</b> <br><br>  <i><b>Suministro de kernel de arranque</b></i> <br><br>  Una vez completadas sus tareas, el gestor de arranque cambiar√° al c√≥digo del n√∫cleo que carg√≥ en la memoria principal y comenzar√° a ejecutarlo, pasando todos los par√°metros de l√≠nea de comando que especific√≥ el usuario.  ¬øQu√© programa es el kernel?  file / boot / vmlinuz muestra que esto es bzImage.  El √°rbol fuente de Linux tiene <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">una herramienta extract-vmlinux</a> que puede usar para extraer el archivo: <br><br><pre> <code class="bash hljs"><span class="hljs-variable"><span class="hljs-variable">$#</span></span> scripts/extract-vmlinux /boot/vmlinuz-$(uname -r) &gt; vmlinux <span class="hljs-variable"><span class="hljs-variable">$#</span></span> file vmlinux vmlinux: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), statically linked, stripped</code> </pre><br>  El kernel es un archivo binario de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">formato ejecutable y de enlace (ELF)</a> , como los programas de espacio de usuario de Linux.  Esto significa que podemos usar comandos binutils como readelf para aprenderlo.  Compare, por ejemplo, las siguientes conclusiones: <br><br><pre> <code class="bash hljs"><span class="hljs-variable"><span class="hljs-variable">$#</span></span> readelf -S /bin/date <span class="hljs-variable"><span class="hljs-variable">$#</span></span> readelf -S vmlinux</code> </pre><br>  La lista de particiones en archivos binarios es en su mayor parte similar. <br><br>  Entonces, el kernel deber√≠a lanzar otros binarios ELF de Linux ... ¬øPero c√≥mo se ejecutan los programas de espacio de usuario?  En la funci√≥n <code>main()</code> , ¬øverdad?  En realidad no <br><br>  Antes de ejecutar la funci√≥n <code>main()</code> , los programas necesitan un contexto de ejecuci√≥n, que incluye memoria heap- (heap) y stack- (stack), adem√°s de descriptores de archivo para <code>stdio</code> , <code>stdout</code> y <code>stderr</code> .  Los programas de espacio de usuario obtienen estos recursos de la biblioteca est√°ndar ( <code>glibc</code> para la mayor√≠a de los sistemas Linux).  Considere lo siguiente: <br><br><pre> <code class="bash hljs"><span class="hljs-variable"><span class="hljs-variable">$#</span></span> file /bin/date /bin/date: ELF 64-bit LSB shared object, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> GNU/Linux 2.6.32, BuildID[sha1]=14e8563676febeb06d701dbee35d225c5a8e565a, stripped</code> </pre> <br>  Los archivos binarios ELF tienen un int√©rprete, al igual que los scripts de Bash y Python.  ¬°Pero no necesita especificarse a trav√©s de <code>#!</code>  como en los scripts, porque ELF es un formato nativo de Linux.  El int√©rprete ELF proporciona al archivo binario todos los recursos necesarios llamando a <code>_start()</code> , una funci√≥n disponible en el <code>glibc</code> fuente <code>glibc</code> , que se puede aprender a trav√©s de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">GDB</a> .  El n√∫cleo, obviamente, no tiene un int√©rprete, y deber√≠a suministrarse de forma independiente, pero ¬øc√≥mo? <br><br>  Un estudio sobre c√≥mo iniciar un n√∫cleo con GDB proporciona una respuesta a esta pregunta.  Para comenzar, instale el paquete de depuraci√≥n del n√∫cleo, que contiene la versi√≥n sin cortar de <code>vmlinux</code> , por ejemplo, <code>apt-get install linux-image-amd64-dbg</code> .  O compile e instale su propio n√∫cleo desde alguna fuente, por ejemplo, siguiendo las instrucciones del excelente <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Manual del n√∫cleo de Debian</a> .  <code>gdb vmlinux</code> seguido de <code>info files</code> muestra la secci√≥n ELF <code>init.text</code> .  Indique el inicio de la ejecuci√≥n del programa en <code>init.text</code> con <code>l *(address)</code> , donde direcci√≥n es el inicio hexadecimal de <code>init.text</code> .  GDB indicar√° que el n√∫cleo x86_64 se inicia en el <code><a href="">arch/x86/kernel/head_64.S</a></code> , donde encontramos la funci√≥n de compilaci√≥n <code>start_cpu0()</code> y el c√≥digo que crea expl√≠citamente la pila y descomprime zImage antes de llamar a <code>x86_64 start_kernel()</code> .  Los n√∫cleos ARM de 32 bits tienen un <code><a href="">arch/arm/kernel/head.S. start_kernel()</a></code>  <code><a href="">arch/arm/kernel/head.S. start_kernel()</a></code> es independiente de la arquitectura, por lo que la funci√≥n se encuentra en el n√∫cleo <code>init/main.c</code>  Podemos decir que <code>start_kernel()</code> es una funci√≥n real <code>main()</code> Linux. <br><br>  <b>De start_kernel () a PID 1</b> <br>  <i><b>Manifiesto del hardware del n√∫cleo: tablas ACPI y √°rboles de dispositivos</b></i> <br><br>  Al arrancar, el kernel necesita informaci√≥n sobre el hardware adem√°s del tipo de procesador para el que fue compilado.  Las instrucciones en el c√≥digo se complementan con datos de configuraci√≥n, que se almacenan por separado.  Hay dos m√©todos principales para almacenar datos: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">√°rboles de</a> dispositivos y <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">tablas ACPI</a> .  A partir de estos archivos, el kernel descubre qu√© equipo debe ejecutarse en cada arranque. <br><br>  Para dispositivos integrados, el √°rbol de dispositivos (DU) es un manifiesto del equipo instalado.  DU es un archivo que se compila al mismo tiempo que la fuente del n√∫cleo y generalmente se encuentra en / boot junto con <code>vmlinux</code> .  Para ver qu√© hay en el √°rbol de dispositivos binarios en el dispositivo ARM, simplemente use el comando de <code>strings</code> del paquete binutils en el archivo cuyo nombre corresponde a <code>/boot/*.dtb</code> , ya que <code>dtb</code> significa el archivo binario del √°rbol de dispositivos (Device-Tree Binary).  Puede cambiar el control remoto editando los archivos similares a JSON en los que se compone y reiniciando el compilador dtc especial provisto con la fuente del n√∫cleo.  DU es un archivo est√°tico cuya ruta generalmente se pasa al n√∫cleo por los gestores de arranque en la l√≠nea de comando, pero en los √∫ltimos a√±os se ha agregado una <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">superposici√≥n de √°rbol de dispositivos</a> donde el n√∫cleo puede cargar din√°micamente fragmentos adicionales en respuesta a eventos de conexi√≥n en caliente despu√©s de la carga. <br><br>  La familia x86 y muchos dispositivos de nivel empresarial ARM64 utilizan el mecanismo alternativo de Interfaz avanzada de configuraci√≥n y energ√≠a ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">ACPI)</a> .  A diferencia del control remoto, la informaci√≥n ACPI se almacena en el sistema de archivos virtual <code>/sys/firmware/acpi/tables</code> , que es creado por el n√∫cleo al inicio al acceder a la ROM interna.  Para leer las tablas ACPI, use el comando <code>acpica-tools</code> paquete <code>acpica-tools</code> .  Aqu√≠ hay un ejemplo: <br><br><img src="https://habrastorage.org/webt/gq/gw/mj/gqgwmjbpkadcvz6fbzyp7uc8gvg.png"><br>  <i>Las tablas ACPI en las computadoras port√°tiles Lenovo est√°n listas para Windows 2001.</i> <br><br>  S√≠, su sistema Linux est√° listo para Windows 2001 si desea instalarlo.  ACPI tiene m√©todos y datos, en contraste con el control remoto, que es m√°s como un lenguaje de descripci√≥n de hardware.  Los m√©todos ACPI contin√∫an activos despu√©s del arranque.  Por ejemplo, si ejecuta el comando acpi_listen (desde el paquete apcid) y luego cierra y abre la tapa de la computadora port√°til, ver√° que la funcionalidad ACPI continu√≥ funcionando todo este tiempo.  La <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">reescritura</a> temporal y din√°mica <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">de las tablas ACPI</a> es posible, pero el cambio permanente requerir√° la interacci√≥n con el men√∫ del BIOS al arrancar o flashear la ROM.  En lugar de tales complejidades, quiz√°s deber√≠a simplemente <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">instalar coreboot</a> , un reemplazo para el firmware de c√≥digo abierto. <br><br>  De start_kernel () al espacio de usuario <br><br>  El c√≥digo en <code><a href="">init/main.c</a></code> es sorprendentemente f√°cil de leer y, curiosamente, todav√≠a usa los derechos de autor originales de Linus Torvalds de 1991-1992.  L√≠neas encontradas en <code>dmesg | head</code>  <code>dmesg | head</code> sistema en ejecuci√≥n se origina b√°sicamente en este archivo fuente.  El sistema registra la primera CPU, las estructuras de datos globales se inicializan, una tras otra, se activan el planificador, los controladores de interrupciones (IRQ), los temporizadores y la consola.  Todas las marcas de tiempo antes de ejecutar <code>timekeeping_init()</code> son cero.  Esta parte de la inicializaci√≥n del n√∫cleo es s√≠ncrona, es decir, la ejecuci√≥n se produce en un solo subproceso.  Las funciones no se ejecutan hasta que se completa y se devuelve la √∫ltima.  Como resultado, la salida de <code>dmesg</code> ser√° totalmente reproducible incluso entre los dos sistemas, siempre que tengan el mismo control remoto o tablas ACPI.  Linux tambi√©n se comporta como un sistema operativo en tiempo real (RTOS) que se ejecuta en una MCU, como QNX o VxWorks.  Esta situaci√≥n se almacena en la funci√≥n <code>rest_init()</code> , que es llamada por <code>start_kernel()</code> en el momento de su finalizaci√≥n. <br><br><img src="https://habrastorage.org/webt/dt/ge/49/dtge49gofpzdjlzk__surv1x9-o.png"><br>  <i>Una breve descripci√≥n del proceso inicial de arranque del kernel</i> <i><br></i> <br>  El modesto nombre <code>rest_init()</code> crea un nuevo hilo que ejecuta <code>kernel_init()</code> , que a su vez llama a <code>do_initcalls()</code> .  Los usuarios pueden monitorear la operaci√≥n de <code>initcalls</code> agregando <code>initcalls_debug</code> a la l√≠nea de comando del kernel.  Como resultado, obtendr√° la entidad <code>dmesg</code> cada vez que ejecute la funci√≥n <code>initcall</code> .  <code>initcalls</code> pasa por siete niveles consecutivos: temprano, n√∫cleo, postcore, arch, subsys, fs, dispositivo y tarde.  La parte m√°s notable de <code>initcalls</code> para los usuarios es la identificaci√≥n e instalaci√≥n de dispositivos perif√©ricos del procesador: buses, red, almacenamiento, pantallas, etc., acompa√±ados de la carga de sus m√≥dulos de kernel.  <code>rest_init()</code> tambi√©n crea un segundo subproceso en el procesador de arranque, que comienza ejecutando <code>cpu_idle()</code> mientras el programador distribuye su trabajo. <br><br>  <code>kernel_init()</code> tambi√©n configura el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">multiprocesamiento sim√©trico</a> (SMP).  En los n√∫cleos modernos, puede encontrar este momento en la salida de dmesg con la l√≠nea "Activando CPU secundarias ...".  SMP luego realiza la conexi√≥n en caliente de la CPU, lo que significa que gestiona su ciclo de vida utilizando una m√°quina de estado condicionalmente similar a la utilizada en dispositivos como memorias USB con detecci√≥n autom√°tica.  El sistema de administraci√≥n de energ√≠a del n√∫cleo a menudo apaga los n√∫cleos individuales (n√∫cleos) y los activa seg√∫n sea necesario para que el mismo c√≥digo de CPU de conexi√≥n en caliente se llame repetidamente en una m√°quina desocupada.  Eche un vistazo a c√≥mo un sistema de administraci√≥n de energ√≠a <code>offcputime.py</code> CPU utilizando <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">una herramienta BCC</a> llamada <code>offcputime.py</code> . <br><br>  Tenga en cuenta que el c√≥digo en <code>init/main.c</code> casi termin√≥ de ejecutarse cuando se <code>smp_init()</code> .  El procesador de arranque complet√≥ la mayor parte de la inicializaci√≥n √∫nica, que otros n√∫cleos no necesitan repetir.  Sin embargo, se deben crear subprocesos para cada n√∫cleo para controlar las interrupciones (IRQ), la cola de trabajo, los temporizadores y los eventos de potencia en cada uno.  Por ejemplo, observe los hilos del procesador que sirven softirqs y colas de trabajo con el comando <code>ps -o psr.</code> psr <code>ps -o psr.</code> <br><br><pre> <code class="bash hljs">$\<span class="hljs-comment"><span class="hljs-comment"># ps -o pid,psr,comm $(pgrep ksoftirqd) PID PSR COMMAND 7 0 ksoftirqd/0 16 1 ksoftirqd/1 22 2 ksoftirqd/2 28 3 ksoftirqd/3 $\# ps -o pid,psr,comm $(pgrep kworker) PID PSR COMMAND 4 0 kworker/0:0H 18 1 kworker/1:0H 24 2 kworker/2:0H 30 3 kworker/3:0H [ . . . ]</span></span></code> </pre> <br>  donde el campo PSR significa "procesador".  Cada n√∫cleo debe tener sus propios temporizadores y controladores de conexi√≥n en caliente cpuhp. <br><br>  Y finalmente, ¬øc√≥mo se lanza el espacio de usuario?  Hacia el final, <code>kernel_init()</code> buscando un <code>initrd</code> que pueda iniciar el proceso <code>init</code> en su nombre.  Si no, el n√∫cleo ejecuta <code>init</code> s√≠ solo.  ¬øPor qu√© entonces se puede necesitar <code>initrd</code> ? <br><br>  <i><b>Espacio de usuario temprano: ¬øqui√©n orden√≥ initrd?</b></i> <br><br>  Adem√°s del √°rbol de dispositivos, otra ruta de inicio al archivo, opcionalmente proporcionada por el n√∫cleo en el arranque, pertenece a <code>initrd</code> .  <code>initrd</code> menudo se encuentra en / boot junto con el archivo bzImage vmlinuz en x86, o con un √°rbol similar de im√°genes y dispositivos para ARM.  Se puede ver una lista de contenidos <code>intrd</code> usando la herramienta <code>lsinitramfs</code> , que es parte del paquete <code>initramfs-tools-core</code> .  La imagen de distribuci√≥n initrd contiene los directorios m√≠nimos <code>/bin</code> , <code>/sbin</code> y <code>/etc</code> , as√≠ como los m√≥dulos del n√∫cleo y los archivos en <code>/scripts</code> .  Todo deber√≠a parecer m√°s o menos familiar, ya que <code>initrd</code> en su mayor parte similar al sistema simplificado de archivos ra√≠z de Linux.  Esta similitud es un poco enga√±osa, ya que casi todos los ejecutables en <code>/bin</code> y <code>/sbin</code> dentro de ramdisk son enlaces simb√≥licos al <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">binario BusyBox</a> , lo que hace que los directorios / bin y / sbin sean 10 veces m√°s peque√±os que en <code>glibc</code> . <br><br>  ¬øPor qu√© intentar crear un <code>initrd</code> si lo √∫nico que hace es cargar algunos m√≥dulos y ejecutar <code>init</code> en un sistema de archivos ra√≠z normal?  Considere un sistema de archivos ra√≠z encriptado.  El descifrado puede depender de cargar el m√≥dulo del n√∫cleo almacenado en <code>/lib/modules</code> sistema de archivos ra√≠z ... y, como se esperaba, en <code>initrd</code> .  El m√≥dulo criptogr√°fico puede compilarse est√°ticamente en el kernel y no cargarse desde un archivo, pero hay varias razones para rechazar esto.  Por ejemplo, la compilaci√≥n est√°tica de un n√∫cleo con m√≥dulos puede hacer que sea demasiado grande para caber en el almacenamiento disponible, o la compilaci√≥n est√°tica puede violar los t√©rminos de la licencia de software.  Como era de esperar, los controladores de almacenamiento, las redes y los HID (dispositivos de entrada humanos) tambi√©n se pueden representar en <code>initrd</code> , esencialmente cualquier c√≥digo que no sea una parte necesaria del n√∫cleo necesario para montar el sistema de archivos ra√≠z.  Tambi√©n en initrd, los usuarios pueden almacenar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">su propio c√≥digo ACPI para tablas</a> . <br><br><img src="https://habrastorage.org/webt/gx/nj/lj/gxnjljvh-gs47qpacftktsubl2e.png"><br>  <i>Diversi√≥n con shell de rescate e initrd personalizado.</i> <br><br>  <code>initrd</code> tambi√©n <code>initrd</code> ideal para probar sistemas de archivos y dispositivos de almacenamiento.  Coloque las herramientas de prueba en <code>initrd</code> y ejecute las pruebas desde la memoria, no desde el objeto de prueba. <br><br>  Finalmente, cuando <code>init</code> ejecutando, ¬°el sistema se est√° ejecutando!  Dado que los procesadores secundarios ya est√°n en funcionamiento, la m√°quina se ha convertido en una criatura as√≠ncrona, paginada, impredecible y de alto rendimiento que todos conocemos y amamos.  De hecho, <code>ps -o pid,psr,comm -p</code> indica que el proceso de <code>init</code> espacio de usuario ya no se ejecuta en el procesador de arranque. <br><br>  <b>Resumen</b> <br><br>  El proceso de arranque de Linux parece prohibido, dada la cantidad de software afectado, incluso en un dispositivo integrado simple.  Por otro lado, el proceso de arranque es bastante simple, ya que no hay una complejidad excesiva causada por el desplazamiento de multitarea, RCU y condiciones de carrera.  Prestando atenci√≥n solo al kernel y al PID 1, se puede pasar por alto el gran trabajo realizado por los cargadores de arranque y los procesadores auxiliares para preparar la plataforma para el lanzamiento del kernel.  El kernel es ciertamente diferente de otros programas de Linux, pero el uso de herramientas para trabajar con otros binarios ELF ayudar√° a comprender mejor su estructura.  Estudiar un proceso de arranque viable preparar√° para futuros bloqueos. <br><br>  El fin <br><br>  Estamos esperando sus comentarios y preguntas, como de costumbre, ya sea aqu√≠ o en nuestra <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">lecci√≥n abierta</a> donde Leonid quedar√° impresionado. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es425505/">https://habr.com/ru/post/es425505/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es425493/index.html">Configuraci√≥n de MikroTik hAP mini para IPTV Beeline</a></li>
<li><a href="../es425497/index.html">Tutu PHP Meetup # 2: transmisi√≥n de eventos en vivo</a></li>
<li><a href="../es425499/index.html">HyperX Impact DDR4: ¬°SO-DIMM que podr√≠a! ¬øO por qu√© en una computadora port√°til 64 GB de memoria con una frecuencia de 3200 MHz?</a></li>
<li><a href="../es425501/index.html">Pruebas A / B en Android de la A a la Z</a></li>
<li><a href="../es425503/index.html">Cassandra Sink para Spark Structured Streaming</a></li>
<li><a href="../es425507/index.html">Parsim Wikipedia para tareas de PNL en 4 equipos</a></li>
<li><a href="../es425511/index.html">Caracter√≠sticas no obvias de la aplicaci√≥n Rotativa para generar PDF en la aplicaci√≥n ASP.NET MVC</a></li>
<li><a href="../es425515/index.html">Apple bloquea la reparaci√≥n independiente de los nuevos modelos de MacBook</a></li>
<li><a href="../es425517/index.html">C√≥mo Yandex cre√≥ un pron√≥stico de precipitaci√≥n global utilizando radares y sat√©lites</a></li>
<li><a href="../es425521/index.html">M√©todos protegidos en JavaScript ES5</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>