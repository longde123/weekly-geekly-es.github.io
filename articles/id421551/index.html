<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🍄 👩🏿‍🎨 👞 Menguasai Vuex - Dari Nol ke Pahlawan 🖨️ 🕊️ 🌱</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Halo, Habr! Saya mempersembahkan untuk Anda terjemahan dari artikel “Mastering Vuex - Zero to Hero” oleh Sanath Kumar. 


 Dokumentasi resmi Vuex mend...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Menguasai Vuex - Dari Nol ke Pahlawan</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/421551/"><p>  Halo, Habr!  Saya mempersembahkan untuk Anda terjemahan dari artikel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">“Mastering Vuex - Zero to Hero”</a> oleh Sanath Kumar. </p><br><p>  Dokumentasi resmi Vuex mendefinisikannya sebagai <b>pola</b> + perpustakaan <b>manajemen negara</b> untuk aplikasi Vue.js.  <i>Tapi apa artinya itu?</i>  <i>Apa itu pola manajemen negara?</i> </p><br><p>  Bayangkan Anda sedang mengerjakan aplikasi web besar dengan ratusan rute dan komponen.  Bukankah lebih mudah jika kita bisa menyimpan semua data yang kita perlukan dalam aplikasi dalam satu penyimpanan terpusat? </p><br><img src="https://habrastorage.org/webt/dm/rc/t5/dmrct5ro7paby7tugthhzagynxw.jpeg"><a name="habracut"></a><br><p> Setiap komponen atau rute dalam aplikasi kita akan meminta data dari negara Vuex dan mentransfer data yang diubah kembali ke keadaan. </p><br><p>  Intinya, keadaan Vuex dapat dilihat sebagai satu-satunya sumber kebenaran untuk seluruh aplikasi. </p><br><p>  Data disimpan di dalam negara sebagai objek JSON.  Sebagai contoh: </p><br><pre><code class="plaintext hljs">state: { name: "John Doe", age: "28" }</code> </pre> <br><p>  Tetapi bagaimana komponen dan rute kita dapat mengakses data yang disimpan di negara kita?  Untuk melakukan ini, kita perlu mendefinisikan <b>getter</b> di dalam repositori Vuex kita yang akan mengembalikan data dari repositori ke komponen kita.  Mari kita lihat seperti apa seorang <b>pengambil</b> sederhana, yang mendapatkan nama dari repositori kami: </p><br><pre> <code class="plaintext hljs">getters: { NAME: state =&gt; { return state.name; }, }</code> </pre> <br><p>  Perhatikan bahwa nama pengambil dalam huruf kapital.  Ini hanya rekomendasi gaya kode.  Tidak perlu mengikutinya jika Anda tidak menyukainya. </p><br><p>  Sekarang kita telah menetapkan pengambil untuk nama, sangat mudah untuk mendapatkan nilai nama di dalam komponen kita.  Kode di bawah ini memungkinkan Anda untuk melakukan ini. </p><br><pre> <code class="plaintext hljs">let name = this.$store.getters.NAME;</code> </pre> <br><p>  Kami menemukan cara <b>untuk mendapatkan</b> data dari penyimpanan.  Sekarang mari kita lihat bagaimana kita dapat <b>mengatur</b> data di repositori.  Kami akan menentukan setter, kan?  Selain itu, setter Vuex dinamai sedikit berbeda.  Kami mendefinisikan <b>Mutasi</b> untuk mengatur data ke status Vuex kami. </p><br><pre> <code class="plaintext hljs">mutations: { SET_NAME: (state, payload) =&gt; { state.name = payload; }, }</code> </pre> <br><p>  Apa lagi payload?  <b>Payload</b> adalah data yang dikirim ke mutasi kami dari komponen yang membuat mutasi.  Bagaimana kita bisa melakukan ini?  Sangat sederhana: </p><br><pre> <code class="plaintext hljs">this.$store.commit('SET_NAME', your_name);</code> </pre> <br><p>  Sepotong kode ini akan mengubah status aplikasi dan menetapkan nilai apa pun yang ditetapkan pada <i>namaAnda</i> untuk properti nama di dalam repositori kami. </p><br><p>  MUTASI SINKRON </p><br><p>  Bayangkan kita memiliki daftar nama yang disimpan dalam database di server jauh.  Server memberi kami titik akhir yang mengembalikan array nama yang dapat digunakan di Vue.js.  Tentu saja, kita dapat menggunakan <b>Axios</b> untuk menanyakan titik akhir dan mendapatkan data. </p><br><pre> <code class="plaintext hljs">let {data} = await Axios.get('https://myapiendpoint.com/api/names');</code> </pre> <br><p>  Setelah itu, kita bisa meneruskan array yang dikembalikan ke keadaan Vuex store kita menggunakan mutasi.  Mudah kan?  Tapi tidak juga.  Mutasi bersifat sinkron, dan kami tidak dapat menjalankan operasi asinkron, seperti panggilan API, di dalam mutasi. </p><br><p>  Apa yang harus kita lakukan?  Buat <b>Tindakan</b> . </p><br><p>  Tindakan itu seperti mutasi, tetapi alih-alih mengubah keadaan secara langsung, mereka membuat mutasi.  Kedengarannya membingungkan?  Mari kita lihat pengumuman aksi. </p><br><pre> <code class="plaintext hljs">actions: { SET_NAME: (context, payload) { context.commit('SET_NAME', payload); }, }</code> </pre> <br><p>  Kami mendefinisikan tindakan yang disebut SET_NAME yang menggunakan konteks dan <i>muatan</i> sebagai parameter.  Tindakan ini melakukan mutasi SET_NAME, yang dibuat sebelumnya, dengan data diteruskan ke sana, yaitu <b>namaAnda</b> . </p><br><p>  Sekarang, alih-alih meminta mutasi secara langsung, komponen kami memicu tindakan SET_NAME dengan nama baru sebagai data sebagai berikut: </p><br><pre> <code class="plaintext hljs">this.$store.dispatch('SET_NAME', your_name);</code> </pre> <br><p>  Kemudian tindakan memulai mutasi dengan data yang diteruskan ke sana, yaitu <i>nama_Anda</i> . </p><br><br><h2>  Tapi mengapa? </h2><br><p>  Anda mungkin bertanya-tanya mengapa deklarasi tindakan diperlukan jika kita dapat memulai mutasi dengan nilai baru langsung dari komponen kami.  Seperti disebutkan di atas, mutasi bersifat sinkron, tetapi tidak ada tindakan. </p><br><p>  Dalam contoh di atas, kasus dipertimbangkan ketika Anda perlu memperbarui nilai nama, tetapi tidak hanya dalam keadaannya, tetapi juga dalam database yang berjalan di server jauh.  Saya yakin ini adalah bagaimana Anda berniat untuk menggunakan Vuex dalam proyek nyata dalam 99% kasus.  Lihatlah potongan kode berikut: </p><br><pre> <code class="plaintext hljs">mutations: { SET_NAME: (state, name) =&gt; { state.name = name; }, }, actions: { SET_NAME: async (context, name) =&gt; { let {data} = await Axios.post('http://myapiendpoint.com/api/name', {name: name}); if (data.status == 200) { context.commit('SET_NAME', name); } }, }</code> </pre> <br><p>  Kode itu sendiri sudah jelas.  Kami menggunakan Axios untuk mengirim nama ke titik akhir.  Jika permintaan POST berhasil, dan nilai nama bidang berhasil diubah di server, kami memulai mutasi SET_ NAME untuk memperbarui nilai nama di dalam negara bagian kami. </p><br><p>  MENGAMBIL PRAKTEK TIDAK PERNAH MEMULAI MUTASI LANGSUNG.  UNTUK INI SELALU MENGGUNAKAN TINDAKAN. </p><br><br><h2>  Mengkonfigurasi Penyimpanan Vuex di Vue.JS </h2><br><p>  Mari selami lebih dalam dan temukan bagaimana kita bisa mengimplementasikan Vuex dalam aplikasi nyata. </p><br><h3>  Langkah 1. Instal Vuex </h3><br><pre> <code class="plaintext hljs">npm install --save vuex</code> </pre> <br><h3>  Langkah 2. Membuat repositori Vuex </h3><br><ol><li>  Buat direktori <b>toko</b> di root aplikasi kita. </li><li>  Buat file <b>index.js</b> di direktori ini dan gunakan kode di bawah ini untuk membuat repositori baru. </li></ol><br><pre> <code class="plaintext hljs">import Vue from 'vue'; import Vuex from 'vuex'; Vue.use(Vuex); export const store = new Vuex.Store({ state: {}, getters: {}, mutations: {}, actions: {}, });</code> </pre> <br><h3>  Langkah 3. Menambahkan Penyimpanan Vuex ke Aplikasi Vue.JS </h3><br><p>  1. Impor <b>repositori</b> ke file main.js: </p><br><pre> <code class="plaintext hljs">import {store} from './store';</code> </pre> <br><p>  2. Tambahkan <b>penyimpanan</b> ke instance Vue, seperti yang ditunjukkan di bawah ini: </p><br><pre> <code class="plaintext hljs">new Vue({ el: '#app', store, router, render: h =&gt; h(App), });</code> </pre> <br><p>  Sekarang kita dapat menambahkan variabel status, getter, mutasi, dan tindakan ke repositori Vuex kami. </p><br><br><h2>  Contoh </h2><br><p>  Lihatlah repositori Vuex dari aplikasi daftar tugas yang sederhana.  “Bukan hanya daftar pekerjaan yang harus dilakukan !!!”.  Hah?  Jangan khawatir.  Di akhir artikel ini, Anda akan belajar cara menggunakan kekuatan penuh dan kekuatan Vuex. </p><br><pre> <code class="plaintext hljs">import Vue from 'vue'; import Vuex from 'vuex'; import Axios from 'axios'; Vue.use(Vuex); export const store = new Vuex.Store({ state: { todos: null, }, getters: { TODOS: state =&gt; { return state.todos; }, }, mutations: { SET_TODO: (state, payload) =&gt; { state.todos = payload; }, ADD_TODO: (state, payload) =&gt; { state.todos.push(payload); }, }, actions: { GET_TODO: async (context, payload) =&gt; { let {data} = await Axios.get('http://yourwebsite.com/api/todo'); context.commit('SET_TODO', data); }, SAVE_TODO: async (context, payload) =&gt; { let {data} = await Axios.post('http://yourwebsite.com/api/todo'); context.commit('ADD_TODO', payload); }, }, });</code> </pre> <br><br><h2>  Tambahkan item baru ke daftar agenda </h2><br><p>  Di dalam komponen Anda, mulailah tindakan SAVE_TODO dengan mengirimkan item tugas yang harus dilakukan kepadanya, seperti yang ditunjukkan dalam cuplikan kode di bawah ini. </p><br><pre> <code class="plaintext hljs">let item = 'Get groceries'; this.$store.dispatch('SAVE_TODO', item);</code> </pre> <br><p>  Tindakan <b>SAVE_TODO</b> membuat permintaan POST ke titik akhir, dan kemudian memulai <b>mutasi ADD_TODO</b> , yang menambahkan item agenda ke variabel status <b>todos</b> . </p><br><br><h2>  Aktivitas yang harus dilakukan </h2><br><p>  Di dalam blok <b>mount ()</b> komponen Anda, <b>awali</b> aksi <b>GET_TODO</b> kedua, yang menerima semua item yang harus dilakukan dari titik akhir dan menyimpannya dalam variabel status <i>todos</i> , memulai mutasi SET_TODO: </p><br><pre> <code class="plaintext hljs">mounted() { this.$store.dispatch('GET_TODO'); }</code> </pre> <br><br><h2>  Akses item yang harus dilakukan di dalam suatu komponen </h2><br><p>  Untuk mengakses elemen <i>todos</i> di dalam komponen, buat properti yang dihitung: </p><br><pre> <code class="plaintext hljs">computed: { todoList() { return this.$store.getters.TODOS; }, }</code> </pre> <br><p>  Di dalam komponen, Anda dapat mengakses properti yang dihitung: </p><br><pre> <code class="plaintext hljs">&lt;div class="todo-item" v-for="item in todoList"&gt;&lt;/div&gt;</code> </pre> <br><br><h2>  Menggunakan Metode mapGetters </h2><br><p>  Bahkan ada cara yang lebih mudah untuk mengakses item-item yang harus dilakukan dalam suatu komponen menggunakan metode <b>mapGetters</b> yang disediakan oleh Vuex. </p><br><pre> <code class="plaintext hljs">import {mapGetters} from 'vuex'; computed : { ...mapGetters(['TODOS']), //    }</code> </pre> <br><p>  Anda mungkin sudah menebak bahwa kode di dalam template harus diubah, seperti yang ditunjukkan pada snippet di bawah ini. </p><br><pre> <code class="plaintext hljs">&lt;div class="todo-item" v-for="item in TODOS"&gt;&lt;/div&gt;</code> </pre> <br><p>  Perhatikan bagaimana kami menggunakan operator distribusi ES6 [...] di dalam properti yang dihitung. </p><br><p>  PENYIMPANAN VUEX BUKAN HANYA SUMBER NEGARA SAAT INI DARI APLIKASI ANDA.  ITU JUGA TITIK HANYA YANG HARUS MENGUBAH NEGARA INI. </p><br><p>  Ini membutuhkan sedikit penjelasan.  Kami telah belajar cara membuat tindakan untuk <b>menerima</b> dan <b>menginstal</b> item yang <b>harus dilakukan</b> di repositori kami.  Bagaimana jika kita perlu memperbarui elemen dan menandainya?  Di mana kita menjalankan kode untuk ini? </p><br><p>  Di Internet Anda dapat menemukan berbagai pendapat tentang masalah ini.  Dokumentasi juga tidak memiliki panduan yang jelas mengenai hal ini. </p><br><p>  Saya akan merekomendasikan menyimpan semua panggilan API di dalam tindakan di repositori Vuex Anda.  Dengan demikian, setiap perubahan status hanya terjadi di dalam repositori, sehingga memfasilitasi debugging dan menyederhanakan pemahaman kode, dan juga membuat pengeditan kode lebih mudah. </p><br><br><h2>  Organisasi Kode </h2><br><p>  Menyimpan semua variabel keadaan, getter, tindakan, dan mutasi dalam satu file akan dengan cepat membuatnya menjadi rumit segera setelah Anda mulai bekerja dengan aplikasi besar.  Mari kita lihat bagaimana Anda dapat mengatur penyimpanan dalam beberapa file sebagai modul. </p><br><p>  Buat direktori baru di dalam repositori Anda dan beri nama <i>modul</i> .  Tambahkan file <i>todos.js</i> ke direktori yang dibuat yang berisi kode berikut: </p><br><pre> <code class="plaintext hljs">const state = {}; const getters = {}; const mutations = {}; const actions = {}; export default { state, getters, mutations, actions, };</code> </pre> <br><p>  Sekarang kita dapat memindahkan variabel keadaan, getter, mutasi dan tindakan dari file <b>index.js</b> ke file <b>todos.js</b> .  Ingatlah untuk mengimpor <b>Axios</b> .  Yang perlu kita lakukan adalah memberi tahu Vuex bahwa kita telah menciptakan modul penyimpanan dan di mana menemukannya.  File <i>index.js yang</i> diperbarui akan terlihat seperti ini: </p><br><pre> <code class="plaintext hljs">import Vue from 'vue'; import Vuex from 'vuex'; import Axios from 'axios'; import todos from './modules/todos'; Vue.use(Vuex); export const store = new Vuex.Store({ state: {}, getters: {}, mutations: {}, actions: {}, modules: { todos, }, });</code> </pre> <br><p>  File <b>todos.js</b> akan terlihat seperti ini: </p><br><pre> <code class="plaintext hljs">import Axios from 'axios'; state = { todos: null, }; getters = { TODOS: state =&gt; { return state.todos; }, }; mutations = { SET_TODO: (state, payload) =&gt; { state.todos = payload; }, ADD_TODO: (state, payload) =&gt; { state.todos.push(payload); }, }; actions = { GET_TODO: async (context, payload) =&gt; { let {data} = await Axios.get('http://yourwebsite.com/api/todo'); context.commit('SET_TODO', data); }, SAVE_TODO: async (context, payload) =&gt; { let {data} = await Axios.post('http://yourwebsite.com/api/todo'); context.commit('ADD_TODO', payload); }, }; export default { state, getters, mutations, actions, };</code> </pre> <br><br><h2>  Ringkasan </h2><br><ol><li>  Status aplikasi disimpan sebagai satu objek JSON besar. </li><li>  <b>Getters</b> digunakan untuk mengakses nilai yang disimpan di toko. </li><li>  <b>Mutasi</b> memperbarui kondisi Anda.  Harus diingat bahwa mutasi itu sinkron. </li><li>  Semua operasi asinkron harus dilakukan dalam <b>tindakan</b> .  Tindakan mengubah status, memulai mutasi. </li><li>  Buat aturan untuk memulai <b>mutasi</b> secara eksklusif melalui <b>tindakan</b> . </li><li>  <b>Modul</b> dapat digunakan untuk mengatur penyimpanan Anda dalam beberapa file kecil. </li></ol><br><p>  Vuex membuat bekerja dengan Vue lebih mudah dan lebih menyenangkan.  Jika Anda seorang pemula, mungkin ada situasi di mana sulit bagi Anda untuk memutuskan apakah akan menggunakan Vuex di area tertentu dari aplikasi Anda.  Ikuti insting Anda.  Anda akan mencapai kecepatan tinggi dengan cukup cepat. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id421551/">https://habr.com/ru/post/id421551/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id421537/index.html">Fungsi Tingkat Tinggi di JS: Kursus Petarung Muda</a></li>
<li><a href="../id421543/index.html">Kloning kartu tanpa kontak menggunakan aplikasi seluler</a></li>
<li><a href="../id421545/index.html">Ulasan PocketBook 616 - dompet 2018 paling hemat dengan fungsi backlight</a></li>
<li><a href="../id421547/index.html">Penerimaan Pusat Data Independen</a></li>
<li><a href="../id421549/index.html">Kami sedang menulis dokumentasi teknis: panduan untuk orang awam</a></li>
<li><a href="../id421553/index.html">Kami berbagi konten teknologi: kami telah mengumpulkan semua materi kami di satu situs</a></li>
<li><a href="../id421555/index.html">Proyek WideNES - melampaui batas layar NES</a></li>
<li><a href="../id421557/index.html">Buka pelajaran "Pemrograman Asinkron di Jawa"</a></li>
<li><a href="../id421559/index.html">Arsitektur komponen UI dalam aplikasi iOS</a></li>
<li><a href="../id421561/index.html">12 pertanyaan tentang skuter yang tidak malu bertanya</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>