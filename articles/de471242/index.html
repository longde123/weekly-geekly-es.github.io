<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩‍❤️‍💋‍👨 ⛹🏽 😵 Einführung in Bash Shell ⛵️ 👨🏻‍🍳 👩🏿‍💼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hallo an alle. Dies ist eine Übersetzung aus dem RedHat RHCE Exam Preparation Book. Meiner Meinung nach ist es sehr zugänglich über die Bash-Grundlage...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Einführung in Bash Shell</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/471242/">  Hallo an alle.  Dies ist eine Übersetzung aus dem RedHat RHCE Exam Preparation Book.  Meiner Meinung nach ist es sehr zugänglich über die Bash-Grundlagen. <br><br>  Shell-Skripte sind eine Wissenschaft für sich.  Ohne auf Details von allem einzugehen, was „unter der Haube“ passiert, lernen Sie, wie Sie die Grundelemente zum Schreiben Ihrer eigenen Skripte verwenden und analysieren, was in Shell-Skripten von Drittanbietern passiert. <br><br><img src="https://habrastorage.org/webt/8w/vx/z3/8wvxz3nzeh5uaiubay0ezgvrbwm.jpeg"><br><a name="habracut"></a><br><h2>  Grundlegendes zu Shell-Skripten </h2><br>  Tatsächlich ist ein Shell-Skript eine Liste von Befehlen, die nacheinander ausgeführt werden, sowie eine Logik, mit der Code nur unter bestimmten Bedingungen ausgeführt werden kann. <br><br>  Um komplexe Shell-Skripte zu verstehen, wird empfohlen, mit grundlegenden Skripten zu beginnen. <br><br>  Das Folgende ist ein sehr einfaches Skript: <br><br><pre><code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#!/bin/bash # # #This is a script that greets the world # Usage: ./hello clear echo hello world exit 0</span></span></code> </pre> <br>  Es enthält mehrere Elemente, die in allen Skripten verwendet werden sollten.  Für den Anfang gibt es Shebang - dies ist die Zeile #! / Bin / Bash.  Wenn das Skript über die übergeordnete Shell gestartet wird, wird eine Subshell geöffnet, in der die im Skript angegebenen Befehle ausgeführt werden. <br><br>  Diese Befehle können auf verschiedene Arten interpretiert werden.  Um genau zu verstehen, wie sie interpretiert werden sollen, wird Shebang verwendet.  Im obigen Beispiel macht shebang deutlich, dass das Skript von der Bash-Shell ausgeführt werden muss. <br><br>  Andere Schalen können ebenfalls angezeigt sein.  Wenn Ihr Skript beispielsweise Perl-Code enthält, sollte shebang #! / Usr / bin / perl sein.  Das Starten eines Skripts mit shebang ist eine gute Praxis.  Wenn nicht angegeben, wird der Skriptcode von derselben Shell ausgeführt, die zum Ausführen des Skripts verwendet wird. <br><br>  Unmittelbar nach dem Schebang gibt es einen Teil, in dem erklärt wird, worum es im Drehbuch geht.  Ein paar Kommentarzeilen am Anfang jedes Szenarios sind eine gute Idee.  In einem kurzen Skript ist oft klar, was es tut, aber je länger das Skript wird und je mehr Leute es schreiben und unterstützen, desto weniger wird klar, was die Autoren vorhaben. <br><br>  Um diese Situation zu vermeiden, müssen Sie Kommentarzeilen hinzufügen, die mit jedem # -Zeichen beginnen.  Kommentare können nicht nur in den ersten Zeilen, sondern auch am Anfang jedes Unterabschnitts des Skripts stehen.  Dies wird sicherlich helfen, wenn Sie Ihr Skript in ein paar Monaten lesen! <br><br>  Sie können auch nicht nur Unterabschnitte, sondern auch einzelne Zeilen kommentieren. <br><br>  Egal in welcher Position es verwendet wird, alles vom # -Zeichen bis zum Ende der Zeile ist ein Kommentar. <br><br>  Nach dem Kommentarblock befindet sich der Skriptkörper.  Im obigen Beispiel sind dies mehrere Befehle, die nacheinander ausgeführt werden.  Der Hauptteil des Shell-Skripts kann sich während der Entwicklung vergrößern. <br><br>  Am Ende des Skripts habe ich die Anweisung <b>exit 0</b> eingefügt.  Die exit-Anweisung teilt der übergeordneten Shell mit, ob das Skript erfolgreich war.  Der Exit-Status des letzten Befehls im Skript ist der Exit-Status des Skripts selbst, es sei denn, <b>Exit 0</b> wird am Ende des Skripts verwendet. <br><br>  Es ist nützlich zu wissen, dass Sie mit <b>exit arbeiten können</b> , um der übergeordneten Shell mitzuteilen, wie die Dinge gelaufen sind. <br><blockquote>  In der übergeordneten Shell wird das Echo $?  Mit dieser Option können Sie den Exit-Status des zuletzt ausgeführten Skripts abfragen. <br></blockquote>  Stellen Sie nach dem Erstellen des Skripts sicher, dass es ausgeführt werden kann.  Der häufigste Weg, dies zu tun, besteht darin, ein Run-Bit darauf anzuwenden.  Wenn der Name der Skriptdatei Hallo lautet, verwenden Sie den <b>Befehl chmod + x ./hello</b> , um sie ausführbar zu machen. <br><br>  Das Skript kann auch als Argument für den Befehl bash ausgeführt werden.  <b>Geben Sie</b> in diesem Fall <b>bash ./hello ein</b> , um das Hallo-Skript auszuführen.  Wenn das Skript als Argument für den Befehl bash ausgeführt wird, muss die Skriptdatei nicht ausführbar sein. <br><br>  Sie können das Skript zwar überall speichern, aber wenn Sie es in einem Verzeichnis speichern möchten, das nicht in der Variablen $ PATH enthalten ist, müssen Sie es mit ./ vor dem Skriptnamen ausführen. <br><br>  <b>Geben Sie ./hello ein</b> , um das Skript auszuführen, oder legen Sie es in dem Standardverzeichnis ab, das in der Variablen $ PATH enthalten ist, z. B. / usr / local / bin. <br><br>  Sie können das Skript auch im Verzeichnis / bin ablegen. Geben Sie anschließend einfach den Dateinamen an einer beliebigen Stelle im Dateisystem ein, und das Skript wird ausgeführt. <br><br>  <b>Beispiel</b> <br><br>  Erstellen Sie mit <b>vi / bin / datetime</b> eine Datei mit dem Namen datetime im Verzeichnis / bin.  Fügen Sie diesen Inhalt in die erstellte Datei ein: <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#!/bin/bash #    .     ,      date who</span></span></code> </pre><br>  <b>Geben Sie</b> nach dem Speichern der Datei <b>chmod + x / bin / datetime ein</b> , um der Datei die Berechtigung zur Ausführung zu erteilen.  Wechseln Sie beispielsweise mit dem <b>Befehl cd ~</b> in <b>Ihr Ausgangsverzeichnis</b> und geben Sie einfach <b>datetime ein</b> . <br><br>  Gehen Sie zum Beispiel in das Verzeichnis cd ~ home und geben Sie einfach datetime ein. <br><br><pre> <code class="bash hljs">[root@localhost ~]<span class="hljs-comment"><span class="hljs-comment"># datetime Sat Sep 28 00:33:41 EDT 2019 root tty1 2019-09-25 20:28 root pts/0 2019-09-27 20:07 (comp.corp.domain.ru)</span></span></code> </pre><br><h2>  Verwenden von Variablen und Eingaben </h2><br>  Bash-Skripte sind viel mehr als nur eine Liste von Befehlen, die nacheinander ausgeführt werden.  Eines der schönen Dinge an Skripten ist, dass sie mit Variablen und Eingaben arbeiten können, um das Skript flexibel zu machen.  In diesem Abschnitt erfahren Sie, wie Sie mit ihnen arbeiten. <br><br><h3>  Positionsparameter verwenden </h3><br>  Beim Ausführen des Skripts können Sie die Argumente verwenden.  Ein Argument ist alles, was Sie hinter einen Skriptbefehl setzen.  Argumente können verwendet werden, um das Skript flexibler zu gestalten.  Nehmen Sie den Befehl <b>useradd lisa</b> .  In diesem Beispiel lautet der Befehl <b>useradd</b> , und sein Argument <b>lisa</b> gibt an, was zu tun ist. <br><br>  Als Ergebnis eines solchen Befehls sollte ein Benutzer namens lisa erstellt werden. <br><br>  Im Skript ist das erste Argument <b>$ 1</b> , das zweite Argument <b>$ 2</b> usw. Listing 1 zeigt, wie die Argumente verwendet werden können.  Versuchen Sie, diesen Code auszuführen, indem Sie Benutzernamen als Parameter angeben. <br><br>  <b>Listing 1</b> <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#!/bin/bash # run this script with a few arguments echo The first argument is $1 echo The second argument is $2 echo The third argument is $3</span></span></code> </pre><br>  Parameter bedeuten Dateneingabe vor dem Ausführen des Skripts.  In diesem Fall habe ich <b>lisa</b> , <b>lori</b> und <b>bob</b> als Parameter nach dem Argument Skriptname angegeben: <br><br><pre> <code class="bash hljs">[root@server1 ~]<span class="hljs-comment"><span class="hljs-comment"># ./argument lisa lori bob The first argument is lisa The second argument is lori The third argument is bob [root@server1 ~]#</span></span></code> </pre><br>  Wenn Sie versucht haben, den Beispielcode auszuführen, stellen Sie möglicherweise fest, dass sein Inhalt nicht perfekt ist.  Wenn Sie beim Ausführen des Skripts aus Listing 1 drei Argumente verwenden, funktioniert dies einwandfrei.  Wenn Sie nur zwei Argumente verwenden, wird das dritte ohne den Wert $ 3 ausgegeben. <br><br>  Wenn Sie vier Argumente verwenden, wird der vierte Wert (der in $ 4 gespeichert wird) niemals angezeigt.  Wenn Sie also Argumente verwenden möchten, sollten Sie einen flexibleren Ansatz verwenden. <br><br>  <b>Listing 2:</b> <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#!/bin/bash # run this script with a few arguments echo you have entered $# arguments for i in $@ do echo $i done exit 0</span></span></code> </pre><br>  <b>Listing 2 zeigt zwei neue Elemente, die sich auf Argumente beziehen:</b> <br><br><ul><li>  $ # Ist ein Zähler, der angibt, wie viele Argumente beim Ausführen des Skripts verwendet wurden. </li><li>  $ @ Ist eine Liste aller Argumente, die beim Ausführen des Skripts verwendet wurden. </li></ul><br>  Um die Argumente aufzulisten, die beim Ausführen dieses Skripts verwendet wurden, wird die <b>for-</b> Schleife verwendet.  In <b>for-</b> Schleifen werden Anweisungen ausgeführt, solange die Bedingung erfüllt ist.  In diesem Szenario bedeutet die Bedingung <b>für i in $ @</b> "für jedes Argument".  Jedes Mal, wenn das Skript die Schleife durchläuft, <b>wird</b> der Variable <b>$ i</b> der Wert aus der Variablen <b>$ @</b> zugewiesen. <br><br>  Solange also Argumente vorhanden sind, wird der Hauptteil des Skripts ausgeführt. <br><br>  Der Hauptteil der for-Schleife beginnt immer mit <b>do</b> und schließt <b>done</b> , und die auszuführenden Befehle werden zwischen diesen beiden Schlüsselwörtern aufgelistet.  Daher verwendet das Beispielskript <b>echo</b> , um den Wert jedes Arguments anzuzeigen, und stoppt, wenn keine weiteren Argumente verfügbar sind. <br><br>  <b>Versuchen wir das Skript in Listing 2 in diesem Beispiel:</b> <br><br><ol><li>  <b>Geben Sie das Argument vi ein</b> , um die Argumentdatei zu erstellen und den Inhalt aus dem Skript in Listing 2 in diese Datei zu kopieren. </li><li>  Speichern Sie die Datei und machen Sie sie ausführbar. </li><li>  Führen Sie den Befehl <b>./argument abc aus</b> .  Sie werden sehen, dass drei Zeilen angezeigt werden. </li><li>  Führen Sie den Befehl <b>./argument abcdef aus</b> .  Sie werden sehen, dass neben abc auch de f angezeigt wird. </li></ol><br><h2>  Variablen </h2><br>  Eine Variable ist eine Bezeichnung, die verwendet wird, um eine bestimmte Stelle im Speicher anzugeben, die einen bestimmten Wert enthält.  Variablen können statisch mit NAME = value oder dynamisch definiert werden.  Es gibt zwei Lösungen zum dynamischen Definieren einer Variablen: <br><br><ul><li>  Verwenden Sie das Schlüsselwort <b>read</b> in einem Skript, um Daten vom Benutzer anzufordern, der das Skript ausführt. </li><li>  Verwenden Sie die Befehlssubstitution, um das Ergebnis des Befehls zu verwenden und es einer Variablen zuzuweisen.  Das Befehlsdatum <b>+% d-% m-% y</b> zeigt beispielsweise das aktuelle Datum im Format Tag-Monat-Jahr an.  Um dies in einem Skript zu tun, können Sie <b>HEUTE = $ (Datum +% d-% m-% y) verwenden</b> .  Um Befehle zu ersetzen, müssen Sie nur den Befehl, dessen Ergebnis Sie verwenden möchten, in die Klammern setzen. </li></ul><br>  Im vorherigen Abschnitt zu Positionsparametern haben Sie gelernt, wie Sie Variablen beim Ausführen eines Skripts Argumente zuweisen.  In einigen Fällen kann es effizienter sein, Informationen anzufordern, wenn Sie feststellen, dass etwas Wesentliches fehlt.  Das folgende Skript zeigt, wie das geht. <br><br>  <b>Listing 3.</b> Beispielskript mit dem Befehl <b>read</b> <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#!/bin/bash if [ -z $1 ]; then echo enter a text read TEXT else TEXT=$1 fi echo you have entered the text $TEXT exit 0</span></span></code> </pre><br>  Im Skript in Listing 3 wird der Operator <b>if ... then ... else ... fi</b> verwendet, um die Existenz des Arguments <b>$ 1</b> zu testen.  Dies erfolgt mit <b>test</b> (test ist ein separater Befehl).  Der Testbefehl kann auf zwei Arten * geschrieben werden: <b>test</b> oder <b>[...]</b> .  Im Beispiel wird die Zeile <b>if [-z $ 1] ...</b> ausgeführt, um den Test (check) <b>-z $ 1 anzuzeigen</b> . <br><br>  * <i>- eigentlich drei <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Quellen</a> (ca. Übersetzer)</i> <br><br>  <b>-z Test</b> prüft, ob <b>$ 1</b> existiert oder nicht.  Mit anderen Worten, die Zeile <b>if [-z $ 1]</b> prüft, ob <b>$ 1</b> leer ist. Dies bedeutet, dass beim Ausführen dieses Skripts keine Argumente angegeben wurden.  In diesem Fall werden die Befehle nach der <b>then-</b> Anweisung ausgeführt. <br><br>  Bitte beachten Sie, dass es beim Schreiben des <b>Testbefehls</b> in eckigen Klammern wichtig ist, Leerzeichen nach der öffnenden Klammer und vor der schließenden Klammer zu verwenden. Ohne Leerzeichen funktioniert der Befehl nicht. <br><br>  Beachten Sie, dass die <b>then-</b> Anweisung unmittelbar auf den <b>Test</b> folgt.  Dies ist möglich, weil ein Semikolon (;) verwendet wird.  Das Semikolon ist ein Befehlstrennzeichen und kann eine neue Zeile in einem Skript ersetzen. <br><br>  Die <b>then-</b> Anweisung führt zwei Befehle aus: den <b>Echo-</b> Befehl, der die Nachricht auf dem Bildschirm anzeigt, und den <b>Lesebefehl</b> . <br><br>  Der Befehl <b>read</b> stoppt das Skript, damit Benutzereingaben verarbeitet und in der Variablen TEXT gespeichert werden können.  Beim <b>Lesen von TEXT</b> werden daher alle Benutzereingaben in die TEXT-Variable eingefügt, die später im Skript verwendet wird. <br><br>  Der nächste Teil wird durch die <b>else-Anweisung dargestellt</b> .  Befehle nach der <b>else-Anweisung</b> werden in allen anderen Fällen ausgeführt, was in diesem Fall "andernfalls, wenn das Argument angegeben wurde" bedeutet.  Wenn ja, wird die TEXT-Variable bestimmt und der aktuelle Wert von <b>$ 1</b> zugewiesen. <br><br>  Beachten Sie, wie die Variable definiert ist: Unmittelbar nach dem Namen der Variablen steht ein = -Zeichen gefolgt von $ 1.  Beachten Sie, dass Sie beim Definieren von Variablen niemals Leerzeichen verwenden sollten. <br><br>  Dann werden die if-Bedingungen mit dem <b>fi-</b> Operator geschlossen.  Nachdem die if-Bedingung erfüllt ist, wissen Sie sicher, dass die TEXT-Variable definiert ist und einen Wert hat.  Die vorletzte Zeile des Skripts liest den Wert der TEXT-Variablen und ordnet diesen Wert mit dem Befehl <b>echo</b> STDOUT zu.  Beachten Sie, dass sich das Anfordern des aktuellen Werts einer Variablen auf den Namen der Variablen bezieht, beginnend mit dem $ -Zeichen davor. <br><br>  <b>Sie können dieses Beispiel üben, wenn Sie mit Eingaben arbeiten.</b> <br><br><ol><li>  Öffnen Sie den Editor und erstellen Sie eine Datei mit dem Namen Text.  Geben Sie den Inhalt des Codes in Listing 3 in diese Datei ein. </li><li>  Schreiben Sie die Datei auf die Festplatte und führen Sie <b>chmod + x-Text aus</b> , um sie ausführbar zu machen. </li><li>  Führen Sie das Skript aus, indem Sie <b>./text</b> und ohne zusätzliche Argumente <b>ausführen</b> .  Sie werden sehen, dass Sie zur Eingabe aufgefordert werden. </li><li>  Führen Sie das Skript mit " <b>Hallo</b> " als Argument aus (./text Hallo).  Das Ergebnis zeigt in STDOUT "Sie haben den Text Hallo eingegeben" an. </li></ol><br><h2>  Bedingungen und Schleifen verwenden </h2><br>  Wie Sie bereits gesehen haben, können bedingte Anweisungen in einem Skript verwendet werden.  Diese bedingten Anweisungen werden nur ausgeführt, wenn eine bestimmte Bedingung erfüllt ist. <br><br>  Es gibt mehrere bedingte Anweisungen und Schleifen in bash, die häufig verwendet werden. <br><br><ul><li>  <b>if ... then ... else</b> - wird verwendet, um Code auszuführen, wenn eine bestimmte Bedingung erfüllt ist </li><li>  <b>for</b> - wird verwendet, um Befehle für einen Wertebereich auszuführen </li><li>  <b>while</b> - wird verwendet, um Code auszuführen, wenn eine bestimmte Bedingung erfüllt ist </li><li>  <b>before</b> - wird verwendet, um Code auszuführen, bis eine bestimmte Bedingung erfüllt ist </li><li>  <b>case</b> - wird verwendet, um eine begrenzte Anzahl spezifischer Werte auszuwerten </li></ul><br><h3>  wenn dann sonst </h3><br>  Das <b>if then else-Konstrukt</b> ist für die Bewertung bestimmter Bedingungen üblich.  Sie haben bereits ein Beispiel mit ihm gesehen.  Diese bedingte Anweisung wird häufig mit dem <b>Testbefehl verwendet</b> .  Mit diesem Befehl können Sie viele Dinge überprüfen: Zum Beispiel nicht nur, ob eine Datei vorhanden ist, sondern auch Dateien vergleichen, Ganzzahlen vergleichen und vieles mehr. <br><blockquote>  Weitere Informationen zum Test finden Sie in der Referenz mit dem Befehl man test. </blockquote><br>  Das grundlegende <b>if-</b> Konstrukt ist <b>if ... then ... fi</b> . <br><br>  Es vergleicht eine Bedingung, wie im folgenden Beispiel gezeigt: <br><br><pre> <code class="bash hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> [ -z <span class="hljs-variable"><span class="hljs-variable">$1</span></span> ] <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> no value provided <span class="hljs-keyword"><span class="hljs-keyword">fi</span></span></code> </pre><br>  In Listing 3 haben Sie gesehen, wie Sie zwei Bedingungen bewerten können, einschließlich <b>else</b> in einem Ausdruck.  Listing 4 zeigt, wie mehrere Bedingungen von <b>if</b> bis <b>else</b> bewertet werden.  Dies ist nützlich, wenn Sie viele verschiedene Werte überprüfen müssen. <br><br>  Beachten Sie, dass in diesem Beispiel auch mehrere <b>Testbefehle verwendet</b> werden. <br><br>  <b>Listing 4</b> :  Beispiel mit <b>wenn dann sonst</b> <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#!/bin/bash # run this script with one argument # the goal is to find out if the argument is a file or a directory if [ -f $1 ] then echo "$1 is a file" elif [ -d $1 ] then echo "$1 is a directory" else echo "I do not know what \$1 is" fi exit 0</span></span></code> </pre> <br><h3>  ||  und &amp;&amp; </h3><br>  Anstatt vollständige <b>if ... -Anweisungen zu</b> schreiben <b>,</b> können Sie die logischen Operatoren <b>|| verwenden</b>  sowie <b>&amp;&amp;</b> .  <b>||</b>  ist ein logisches "ODER" und führt den zweiten Teil der Anweisung nur aus, wenn der erste Teil nicht wahr ist;  <b>&amp;&amp;</b> ist ein logisches "UND" und führt den zweiten Teil der Anweisung nur aus, wenn der erste Teil wahr ist. <br><br>  <b>Betrachten Sie diese beiden Zeilen:</b> <br><br><pre> <code class="bash hljs">[ -z <span class="hljs-variable"><span class="hljs-variable">$1</span></span> ] &amp;&amp; <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> no argument provided</code> </pre> <br><pre> <code class="bash hljs">ping -c 1 8.8.8.8 2&gt;/dev/null || <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> node is not available</code> </pre><br>  Im ersten Beispiel wird überprüft, ob <b>$ 1</b> leer ist.  Wenn diese Prüfung korrekt ist (was im Grunde bedeutet, dass der Befehl mit dem Exit-Code 0 endet), wird der zweite Befehl ausgeführt. <br><br>  Im zweiten Beispiel wird der Befehl <b>ping</b> verwendet, um die Verfügbarkeit des Hosts zu überprüfen. <br>  In diesem Beispiel wird ein logisches "ODER" verwendet, um den Text "Knoten ist nicht verfügbar" anzuzeigen, falls ein <b>Ping-</b> Befehl fehlschlägt. <br><br>  Sie werden das häufig anstelle der bedingten <b>if-Anweisung</b> <b>&amp;&amp;</b> und <b>|| finden</b>  .  In der folgenden Übung können Sie die Verwendung von bedingten Anweisungen üben, indem Sie entweder <b>if ... then ... else</b> oder <b>&amp;&amp;</b> und <b>|| verwenden</b>  . <br><br>  <b>Übung</b> .  Verwenden Sie <b>if ... then ... else</b> <br><br>  In dieser Übung arbeiten Sie an einem Skript, das überprüft, was eine Datei und was ein Verzeichnis ist. <br><br><ol><li>  Starten Sie den Editor und erstellen Sie ein Skript namens filechk. </li><li>  Kopieren Sie den Inhalt von Listing 4 in dieses Skript. </li><li>  Führen Sie damit einige Tests durch, z. B. <b>./filechk / etc / hosts</b> , <b>./filechck / usr</b> , <b>./filechk nicht vorhandene Datei</b> . </li></ol><br><h2>  Für Schleife </h2><br>  Die <b>for-</b> Schleife ist eine großartige Lösung für die Verarbeitung von Datenbereichen.  In Listing 5 sehen Sie das erste Beispiel mit <b>for</b> , in dem der Bereich bestimmt und verarbeitet wird, während sich Rohwerte in diesem Bereich befinden. <br><br>  <b>Listing 5:</b> <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#!/bin/bash # for (( COUNTER=100; COUNTER&gt;1; COUNTER-- )); do echo $COUNTER done exit 0</span></span></code> </pre> <br>  Eine <b>for-</b> Schleife beginnt immer mit dem Schlüsselwort for, gefolgt von einer Bedingung, die überprüft werden muss.  Darauf folgt das Schlüsselwort <b>do</b> , gefolgt von Befehlen, die ausgeführt werden müssen. Wenn die Bedingung erfüllt ist, wird die Schleife mit dem Schlüsselwort <b>done</b> beendet. <br><br>  Im Beispiel in Listing 5 sehen Sie, dass die Bedingung ein Zahlenbereich in Klammern ist, der der Variablen COUNTER zugewiesen ist. <br><br>  <b>Eine kleine Erklärung</b> <br><br>  Innerhalb <b>((...)) werden</b> arithmetische Ausdrücke berechnet und ihr Ergebnis zurückgegeben.  Im einfachsten Fall weist die Konstruktion a = $ ((5 + 3)) der Variablen "a" den Wert des Ausdrucks "5 + 3" oder 8 zu. Außerdem ermöglichen doppelte Klammern das Arbeiten mit Variablen im Stil der C-Sprache. <br><br>  Zuerst wird die Variable auf 100 initialisiert, und solange der Wert größer als 1 ist, wird sie bei jeder Iteration von 1 subtrahiert. Solange die Bedingung erfüllt ist, wird der Wert der Variablen $ COUNTER mit dem Befehl <b>echo</b> angezeigt. <br><br>  In Listing 6 sehen Sie einen meiner Lieblings-Einzeiler mit <b>für</b> .  Der Bereich wird diesmal als eine Folge von Zahlen definiert, die von 100 bis 104 reichen. <br><br>  <b>Listing 6:</b> <br><br><pre> <code class="bash hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> {100..104}; <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> ping –c 1 192.168.4.<span class="hljs-variable"><span class="hljs-variable">$i</span></span> &gt;/dev/null &amp;&amp; <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> 192.168.4.<span class="hljs-variable"><span class="hljs-variable">$i</span></span> is up; <span class="hljs-keyword"><span class="hljs-keyword">done</span></span></code> </pre><br>  Beachten Sie, wie der Bereich bestimmt wird: Zuerst geben Sie die erste Zahl an, dann zwei Punkte und geben die letzte Zahl im Bereich an.  Darüber hinaus wird mit <b>für i in</b> für jede dieser Zahlen die Variable <b>i</b> zugewiesen.  Jede dieser Nummern wird der Variablen <b>i</b> zugewiesen, und dann wird der <b>Ping-</b> Befehl ausgeführt, wobei die Option <b>-c 1</b> sicherstellt, dass nur eine Anforderung gesendet wird. <br><br>  Das Ergebnis des <b>Ping-</b> Befehls <b>wird</b> nicht berücksichtigt, daher wird seine Ausgabe nach / dev / null umgeleitet.  Basierend auf dem Ausgabestatus des <b>Ping-</b> Befehls wird ein Teil des Ausdrucks <b>&amp;&amp;</b> ausgeführt.  Wenn der Host verfügbar ist, wird eine Zeile angezeigt, die angibt, dass er ausgeführt wird. <br><br><h2>  Verstehen während und bis </h2><br>  Wenn die for-Anweisung, über die Sie gerade gelesen haben, für die Arbeit mit Elementbereichen nützlich ist, ist die while-Anweisung hilfreich, wenn Sie beispielsweise die Prozesszugänglichkeit verfolgen möchten.  Es gibt auch eine <b>till-</b> Anweisung, die ausgeführt wird, solange die zu prüfende Bedingung falsch ist.  In Listing 7 können Sie lesen, wie <b>while</b> zur Überwachung der Prozessaktivität verwendet wird. <br><blockquote>  Hinweis  Ich habe nicht verstanden, was dieses Skript macht.  In meinem Fall wird CentOS 7 verwendet und standardmäßig gibt es keinen Monitor, obwohl das Skript ausdrücklich sagt: <pre>  Verwendung: Monitor &lt;Prozessname&gt; </pre>  Irgendwo für eine halbe Stunde habe ich das Monitorprogramm für CetOS gegoogelt, es aber nicht gefunden.  Und im Allgemeinen ist nicht klar, welcher Seitenmonitor hier ist, wenn ps aux verwendet wird.  Auf jeden Fall habe ich nicht verstanden, was dieses Skript macht.  Eine große Anfrage zur Behebung dieses Problems besteht darin, den Text und / oder das Skript anzupassen. </blockquote>  <b>Listing 7:</b> <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#!/bin/bash # # usage: monitor &lt;processname&gt; while ps aux | grep $1 | grep -v grep &gt; /dev/tty11 do sleep 5 done clear echo your process has stopped logger $1 is no longer present mail -s "process $1 has stopped" root &lt; .</span></span></code> </pre> <br>  Das Skript in Listing 7 besteht aus zwei Teilen.  Erstens gibt es eine <b>while-Schleife</b> .  Zweitens muss alles getan werden, wenn die <b>while-Schleife</b> nicht mehr als wahr ausgewertet wird. <br><br>  Der Kern der <b>while-Schleife</b> ist der Befehl <b>ps</b> mit dem Wert <b>$ 1</b> . <br><br>  Beachten Sie die Verwendung von <b>grep -v grep</b> , wodurch Zeilen, die den <b>Befehl grep enthalten,</b> vom Ergebnis ausgeschlossen werden.  Denken Sie daran, dass der Befehl <b>ps</b> alle laufenden Prozesse enthält, einschließlich des <b>Befehls grep</b> , an den die Ausgabe des <b>Befehls</b> <b>ps</b> übergeben wird.  Dies kann zu einer falsch positiven Übereinstimmung führen. <br><br>  Die Ausgabe des Befehls <b>ps aux</b> wird nach / dev / tty11 umgeleitet.  Auf diese Weise können Sie die Ergebnisse von tty11 bei Bedarf später lesen, sie werden jedoch standardmäßig nicht angezeigt. <br><br>   <b>while</b>  ,   ,    .      <b>sleep 5</b> ,      5 . <br><br>    <b>while</b> ,   .     (    ,     ),       ,   . <br><br>       ,  .   <b>mail -s “process $1 has stopped” root &lt; .</b>    root     ,      Linux*.  <b>mail</b>       ,     <b>-s</b> . <br><br> <i>* —     CentOS   . (. )</i> <br><br>    <b>&lt; .</b>   . <br><br>     <b>mail</b>     ,      .   ,  ,    .        STDIN.      -     . <br><br>  <b>while</b> —    <b>until</b> ,      8. <b>until</b>  ,     ,     . <br><br>   8        <b>users</b>   <b>$1</b> ,    .     ,  .       ,  ,    <b>until</b>   . <br><br> <b> 8</b> <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#!/bin/bash # until users | grep $1 &gt; /dev/null do echo $1 is not logged in yet sleep 5 done echo $1 has just logged in mail -s "$1 has just logged in" root &lt; .</span></span></code> </pre> <br><h2>  case </h2><br>      —  <b>case</b> *.  <b>case</b>      .  ,  <b>case</b>     Linux,        . <br><br> <i>* —  ?</i> <br><br>   <b>case</b>       ,    ,   ,    . <br><br>   9      <b>case</b> ,          . <br><br> <b> 9</b> <br><br><pre> <code class="bash hljs"><span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$1</span></span></span><span class="hljs-string">"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> start) start;; stop) rm -f <span class="hljs-variable"><span class="hljs-variable">$lockfile</span></span> stop;; restart) restart;; reload) reload;; status) status ;; *) <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">"Usage: </span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$0</span></span></span><span class="hljs-string"> (start|stop|restart|reload|status)"</span></span> ;; <span class="hljs-keyword"><span class="hljs-keyword">esac</span></span></code> </pre> <br> <b>case</b>   .    — <i>case  in</i> .      ,   .     <b>)</b> . <br><br>    ,   ,    .        ;;            . <br><br>   ,  <b>*)</b>     ,   .  «» . <br><br>   <b>case</b>   <b>esac</b> . <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Beachten Sie, dass die Sequenzen für den </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fall</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> der Reihe nach </font><font style="vertical-align: inherit;">ausgeführt werden. </font><font style="vertical-align: inherit;">Wenn die erste Übereinstimmung hergestellt </font><font style="vertical-align: inherit;">wird, bewertet </font><font style="vertical-align: inherit;">die </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">case-Anweisung</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> nichts. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Im Rahmen der Bewertung können Vorlagen verwendet werden, die der Vorlage ähnlich sind. </font><font style="vertical-align: inherit;">Dies wird in </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">*) einer</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Sequenz gezeigt, die zu allem passt. </font><font style="vertical-align: inherit;">Sie können aber auch Sequenzen wie start | Start | START verwenden, um mit einem anderen </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fall übereinzustimmen</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Debuggen von Skripten in Bash </font></font></h2><br>     ,   ,    .  ,       <b>bash -x</b> .    ,    ,    ,      . <br><br>   10    <b>bash -x</b> ,    ,   <b>grep</b>  ,    ,       . <br><br><pre> <code class="bash hljs">[root@server1 ~]<span class="hljs-comment"><span class="hljs-comment"># bash -x 319.sh + grep Usage: grep [OPTION]... PATTERN [FILE]... Try 'grep --help' for more information. + users + echo is not logged in yet is not logged in yet + sleep 5</span></span></code> </pre> <br><h2>   </h2><br>     ,    .           ,     . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de471242/">https://habr.com/ru/post/de471242/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de471226/index.html">Linux hat viele Gesichter: wie man an jeder Distribution arbeitet</a></li>
<li><a href="../de471228/index.html">Grokay PyTorch</a></li>
<li><a href="../de471232/index.html">Meine Erfahrung mit der Verbindung von LPS331AP mit Omega Onion2</a></li>
<li><a href="../de471236/index.html">Dosimeter für Seryozha. Teil III. Nationales Radiometer</a></li>
<li><a href="../de471240/index.html">"Bitchy Betty" und moderne Audio-Interfaces: Warum sprechen sie mit weiblicher Stimme?</a></li>
<li><a href="../de471244/index.html">Rosetta-Code: Messen Sie die Länge des Codes in einer Vielzahl von Programmiersprachen und untersuchen Sie die Nähe der Sprachen zueinander</a></li>
<li><a href="../de471248/index.html">Die US-Aufsichtsbehörden verbieten die Verteilung des Telegram Open Network-Tokens</a></li>
<li><a href="../de471254/index.html">ITMO University Accelerator Startups - Beginn von Bildverarbeitungsprojekten</a></li>
<li><a href="../de471256/index.html">Vue.js ist gut, aber ist es besser als eckig oder reagiert es?</a></li>
<li><a href="../de471258/index.html">Datenspeicher- / Ladesystem</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>