<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë©‚Äç‚ù§Ô∏è‚Äçüíã‚Äçüë® ‚õπüèΩ üòµ Einf√ºhrung in Bash Shell ‚õµÔ∏è üë®üèª‚Äçüç≥ üë©üèø‚Äçüíº</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hallo an alle. Dies ist eine √úbersetzung aus dem RedHat RHCE Exam Preparation Book. Meiner Meinung nach ist es sehr zug√§nglich √ºber die Bash-Grundlage...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Einf√ºhrung in Bash Shell</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/471242/">  Hallo an alle.  Dies ist eine √úbersetzung aus dem RedHat RHCE Exam Preparation Book.  Meiner Meinung nach ist es sehr zug√§nglich √ºber die Bash-Grundlagen. <br><br>  Shell-Skripte sind eine Wissenschaft f√ºr sich.  Ohne auf Details von allem einzugehen, was ‚Äûunter der Haube‚Äú passiert, lernen Sie, wie Sie die Grundelemente zum Schreiben Ihrer eigenen Skripte verwenden und analysieren, was in Shell-Skripten von Drittanbietern passiert. <br><br><img src="https://habrastorage.org/webt/8w/vx/z3/8wvxz3nzeh5uaiubay0ezgvrbwm.jpeg"><br><a name="habracut"></a><br><h2>  Grundlegendes zu Shell-Skripten </h2><br>  Tats√§chlich ist ein Shell-Skript eine Liste von Befehlen, die nacheinander ausgef√ºhrt werden, sowie eine Logik, mit der Code nur unter bestimmten Bedingungen ausgef√ºhrt werden kann. <br><br>  Um komplexe Shell-Skripte zu verstehen, wird empfohlen, mit grundlegenden Skripten zu beginnen. <br><br>  Das Folgende ist ein sehr einfaches Skript: <br><br><pre><code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#!/bin/bash # # #This is a script that greets the world # Usage: ./hello clear echo hello world exit 0</span></span></code> </pre> <br>  Es enth√§lt mehrere Elemente, die in allen Skripten verwendet werden sollten.  F√ºr den Anfang gibt es Shebang - dies ist die Zeile #! / Bin / Bash.  Wenn das Skript √ºber die √ºbergeordnete Shell gestartet wird, wird eine Subshell ge√∂ffnet, in der die im Skript angegebenen Befehle ausgef√ºhrt werden. <br><br>  Diese Befehle k√∂nnen auf verschiedene Arten interpretiert werden.  Um genau zu verstehen, wie sie interpretiert werden sollen, wird Shebang verwendet.  Im obigen Beispiel macht shebang deutlich, dass das Skript von der Bash-Shell ausgef√ºhrt werden muss. <br><br>  Andere Schalen k√∂nnen ebenfalls angezeigt sein.  Wenn Ihr Skript beispielsweise Perl-Code enth√§lt, sollte shebang #! / Usr / bin / perl sein.  Das Starten eines Skripts mit shebang ist eine gute Praxis.  Wenn nicht angegeben, wird der Skriptcode von derselben Shell ausgef√ºhrt, die zum Ausf√ºhren des Skripts verwendet wird. <br><br>  Unmittelbar nach dem Schebang gibt es einen Teil, in dem erkl√§rt wird, worum es im Drehbuch geht.  Ein paar Kommentarzeilen am Anfang jedes Szenarios sind eine gute Idee.  In einem kurzen Skript ist oft klar, was es tut, aber je l√§nger das Skript wird und je mehr Leute es schreiben und unterst√ºtzen, desto weniger wird klar, was die Autoren vorhaben. <br><br>  Um diese Situation zu vermeiden, m√ºssen Sie Kommentarzeilen hinzuf√ºgen, die mit jedem # -Zeichen beginnen.  Kommentare k√∂nnen nicht nur in den ersten Zeilen, sondern auch am Anfang jedes Unterabschnitts des Skripts stehen.  Dies wird sicherlich helfen, wenn Sie Ihr Skript in ein paar Monaten lesen! <br><br>  Sie k√∂nnen auch nicht nur Unterabschnitte, sondern auch einzelne Zeilen kommentieren. <br><br>  Egal in welcher Position es verwendet wird, alles vom # -Zeichen bis zum Ende der Zeile ist ein Kommentar. <br><br>  Nach dem Kommentarblock befindet sich der Skriptk√∂rper.  Im obigen Beispiel sind dies mehrere Befehle, die nacheinander ausgef√ºhrt werden.  Der Hauptteil des Shell-Skripts kann sich w√§hrend der Entwicklung vergr√∂√üern. <br><br>  Am Ende des Skripts habe ich die Anweisung <b>exit 0</b> eingef√ºgt.  Die exit-Anweisung teilt der √ºbergeordneten Shell mit, ob das Skript erfolgreich war.  Der Exit-Status des letzten Befehls im Skript ist der Exit-Status des Skripts selbst, es sei denn, <b>Exit 0</b> wird am Ende des Skripts verwendet. <br><br>  Es ist n√ºtzlich zu wissen, dass Sie mit <b>exit arbeiten k√∂nnen</b> , um der √ºbergeordneten Shell mitzuteilen, wie die Dinge gelaufen sind. <br><blockquote>  In der √ºbergeordneten Shell wird das Echo $?  Mit dieser Option k√∂nnen Sie den Exit-Status des zuletzt ausgef√ºhrten Skripts abfragen. <br></blockquote>  Stellen Sie nach dem Erstellen des Skripts sicher, dass es ausgef√ºhrt werden kann.  Der h√§ufigste Weg, dies zu tun, besteht darin, ein Run-Bit darauf anzuwenden.  Wenn der Name der Skriptdatei Hallo lautet, verwenden Sie den <b>Befehl chmod + x ./hello</b> , um sie ausf√ºhrbar zu machen. <br><br>  Das Skript kann auch als Argument f√ºr den Befehl bash ausgef√ºhrt werden.  <b>Geben Sie</b> in diesem Fall <b>bash ./hello ein</b> , um das Hallo-Skript auszuf√ºhren.  Wenn das Skript als Argument f√ºr den Befehl bash ausgef√ºhrt wird, muss die Skriptdatei nicht ausf√ºhrbar sein. <br><br>  Sie k√∂nnen das Skript zwar √ºberall speichern, aber wenn Sie es in einem Verzeichnis speichern m√∂chten, das nicht in der Variablen $ PATH enthalten ist, m√ºssen Sie es mit ./ vor dem Skriptnamen ausf√ºhren. <br><br>  <b>Geben Sie ./hello ein</b> , um das Skript auszuf√ºhren, oder legen Sie es in dem Standardverzeichnis ab, das in der Variablen $ PATH enthalten ist, z. B. / usr / local / bin. <br><br>  Sie k√∂nnen das Skript auch im Verzeichnis / bin ablegen. Geben Sie anschlie√üend einfach den Dateinamen an einer beliebigen Stelle im Dateisystem ein, und das Skript wird ausgef√ºhrt. <br><br>  <b>Beispiel</b> <br><br>  Erstellen Sie mit <b>vi / bin / datetime</b> eine Datei mit dem Namen datetime im Verzeichnis / bin.  F√ºgen Sie diesen Inhalt in die erstellte Datei ein: <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#!/bin/bash #    .     ,      date who</span></span></code> </pre><br>  <b>Geben Sie</b> nach dem Speichern der Datei <b>chmod + x / bin / datetime ein</b> , um der Datei die Berechtigung zur Ausf√ºhrung zu erteilen.  Wechseln Sie beispielsweise mit dem <b>Befehl cd ~</b> in <b>Ihr Ausgangsverzeichnis</b> und geben Sie einfach <b>datetime ein</b> . <br><br>  Gehen Sie zum Beispiel in das Verzeichnis cd ~ home und geben Sie einfach datetime ein. <br><br><pre> <code class="bash hljs">[root@localhost ~]<span class="hljs-comment"><span class="hljs-comment"># datetime Sat Sep 28 00:33:41 EDT 2019 root tty1 2019-09-25 20:28 root pts/0 2019-09-27 20:07 (comp.corp.domain.ru)</span></span></code> </pre><br><h2>  Verwenden von Variablen und Eingaben </h2><br>  Bash-Skripte sind viel mehr als nur eine Liste von Befehlen, die nacheinander ausgef√ºhrt werden.  Eines der sch√∂nen Dinge an Skripten ist, dass sie mit Variablen und Eingaben arbeiten k√∂nnen, um das Skript flexibel zu machen.  In diesem Abschnitt erfahren Sie, wie Sie mit ihnen arbeiten. <br><br><h3>  Positionsparameter verwenden </h3><br>  Beim Ausf√ºhren des Skripts k√∂nnen Sie die Argumente verwenden.  Ein Argument ist alles, was Sie hinter einen Skriptbefehl setzen.  Argumente k√∂nnen verwendet werden, um das Skript flexibler zu gestalten.  Nehmen Sie den Befehl <b>useradd lisa</b> .  In diesem Beispiel lautet der Befehl <b>useradd</b> , und sein Argument <b>lisa</b> gibt an, was zu tun ist. <br><br>  Als Ergebnis eines solchen Befehls sollte ein Benutzer namens lisa erstellt werden. <br><br>  Im Skript ist das erste Argument <b>$ 1</b> , das zweite Argument <b>$ 2</b> usw. Listing 1 zeigt, wie die Argumente verwendet werden k√∂nnen.  Versuchen Sie, diesen Code auszuf√ºhren, indem Sie Benutzernamen als Parameter angeben. <br><br>  <b>Listing 1</b> <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#!/bin/bash # run this script with a few arguments echo The first argument is $1 echo The second argument is $2 echo The third argument is $3</span></span></code> </pre><br>  Parameter bedeuten Dateneingabe vor dem Ausf√ºhren des Skripts.  In diesem Fall habe ich <b>lisa</b> , <b>lori</b> und <b>bob</b> als Parameter nach dem Argument Skriptname angegeben: <br><br><pre> <code class="bash hljs">[root@server1 ~]<span class="hljs-comment"><span class="hljs-comment"># ./argument lisa lori bob The first argument is lisa The second argument is lori The third argument is bob [root@server1 ~]#</span></span></code> </pre><br>  Wenn Sie versucht haben, den Beispielcode auszuf√ºhren, stellen Sie m√∂glicherweise fest, dass sein Inhalt nicht perfekt ist.  Wenn Sie beim Ausf√ºhren des Skripts aus Listing 1 drei Argumente verwenden, funktioniert dies einwandfrei.  Wenn Sie nur zwei Argumente verwenden, wird das dritte ohne den Wert $ 3 ausgegeben. <br><br>  Wenn Sie vier Argumente verwenden, wird der vierte Wert (der in $ 4 gespeichert wird) niemals angezeigt.  Wenn Sie also Argumente verwenden m√∂chten, sollten Sie einen flexibleren Ansatz verwenden. <br><br>  <b>Listing 2:</b> <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#!/bin/bash # run this script with a few arguments echo you have entered $# arguments for i in $@ do echo $i done exit 0</span></span></code> </pre><br>  <b>Listing 2 zeigt zwei neue Elemente, die sich auf Argumente beziehen:</b> <br><br><ul><li>  $ # Ist ein Z√§hler, der angibt, wie viele Argumente beim Ausf√ºhren des Skripts verwendet wurden. </li><li>  $ @ Ist eine Liste aller Argumente, die beim Ausf√ºhren des Skripts verwendet wurden. </li></ul><br>  Um die Argumente aufzulisten, die beim Ausf√ºhren dieses Skripts verwendet wurden, wird die <b>for-</b> Schleife verwendet.  In <b>for-</b> Schleifen werden Anweisungen ausgef√ºhrt, solange die Bedingung erf√ºllt ist.  In diesem Szenario bedeutet die Bedingung <b>f√ºr i in $ @</b> "f√ºr jedes Argument".  Jedes Mal, wenn das Skript die Schleife durchl√§uft, <b>wird</b> der Variable <b>$ i</b> der Wert aus der Variablen <b>$ @</b> zugewiesen. <br><br>  Solange also Argumente vorhanden sind, wird der Hauptteil des Skripts ausgef√ºhrt. <br><br>  Der Hauptteil der for-Schleife beginnt immer mit <b>do</b> und schlie√üt <b>done</b> , und die auszuf√ºhrenden Befehle werden zwischen diesen beiden Schl√ºsselw√∂rtern aufgelistet.  Daher verwendet das Beispielskript <b>echo</b> , um den Wert jedes Arguments anzuzeigen, und stoppt, wenn keine weiteren Argumente verf√ºgbar sind. <br><br>  <b>Versuchen wir das Skript in Listing 2 in diesem Beispiel:</b> <br><br><ol><li>  <b>Geben Sie das Argument vi ein</b> , um die Argumentdatei zu erstellen und den Inhalt aus dem Skript in Listing 2 in diese Datei zu kopieren. </li><li>  Speichern Sie die Datei und machen Sie sie ausf√ºhrbar. </li><li>  F√ºhren Sie den Befehl <b>./argument abc aus</b> .  Sie werden sehen, dass drei Zeilen angezeigt werden. </li><li>  F√ºhren Sie den Befehl <b>./argument abcdef aus</b> .  Sie werden sehen, dass neben abc auch de f angezeigt wird. </li></ol><br><h2>  Variablen </h2><br>  Eine Variable ist eine Bezeichnung, die verwendet wird, um eine bestimmte Stelle im Speicher anzugeben, die einen bestimmten Wert enth√§lt.  Variablen k√∂nnen statisch mit NAME = value oder dynamisch definiert werden.  Es gibt zwei L√∂sungen zum dynamischen Definieren einer Variablen: <br><br><ul><li>  Verwenden Sie das Schl√ºsselwort <b>read</b> in einem Skript, um Daten vom Benutzer anzufordern, der das Skript ausf√ºhrt. </li><li>  Verwenden Sie die Befehlssubstitution, um das Ergebnis des Befehls zu verwenden und es einer Variablen zuzuweisen.  Das Befehlsdatum <b>+% d-% m-% y</b> zeigt beispielsweise das aktuelle Datum im Format Tag-Monat-Jahr an.  Um dies in einem Skript zu tun, k√∂nnen Sie <b>HEUTE = $ (Datum +% d-% m-% y) verwenden</b> .  Um Befehle zu ersetzen, m√ºssen Sie nur den Befehl, dessen Ergebnis Sie verwenden m√∂chten, in die Klammern setzen. </li></ul><br>  Im vorherigen Abschnitt zu Positionsparametern haben Sie gelernt, wie Sie Variablen beim Ausf√ºhren eines Skripts Argumente zuweisen.  In einigen F√§llen kann es effizienter sein, Informationen anzufordern, wenn Sie feststellen, dass etwas Wesentliches fehlt.  Das folgende Skript zeigt, wie das geht. <br><br>  <b>Listing 3.</b> Beispielskript mit dem Befehl <b>read</b> <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#!/bin/bash if [ -z $1 ]; then echo enter a text read TEXT else TEXT=$1 fi echo you have entered the text $TEXT exit 0</span></span></code> </pre><br>  Im Skript in Listing 3 wird der Operator <b>if ... then ... else ... fi</b> verwendet, um die Existenz des Arguments <b>$ 1</b> zu testen.  Dies erfolgt mit <b>test</b> (test ist ein separater Befehl).  Der Testbefehl kann auf zwei Arten * geschrieben werden: <b>test</b> oder <b>[...]</b> .  Im Beispiel wird die Zeile <b>if [-z $ 1] ...</b> ausgef√ºhrt, um den Test (check) <b>-z $ 1 anzuzeigen</b> . <br><br>  * <i>- eigentlich drei <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Quellen</a> (ca. √úbersetzer)</i> <br><br>  <b>-z Test</b> pr√ºft, ob <b>$ 1</b> existiert oder nicht.  Mit anderen Worten, die Zeile <b>if [-z $ 1]</b> pr√ºft, ob <b>$ 1</b> leer ist. Dies bedeutet, dass beim Ausf√ºhren dieses Skripts keine Argumente angegeben wurden.  In diesem Fall werden die Befehle nach der <b>then-</b> Anweisung ausgef√ºhrt. <br><br>  Bitte beachten Sie, dass es beim Schreiben des <b>Testbefehls</b> in eckigen Klammern wichtig ist, Leerzeichen nach der √∂ffnenden Klammer und vor der schlie√üenden Klammer zu verwenden. Ohne Leerzeichen funktioniert der Befehl nicht. <br><br>  Beachten Sie, dass die <b>then-</b> Anweisung unmittelbar auf den <b>Test</b> folgt.  Dies ist m√∂glich, weil ein Semikolon (;) verwendet wird.  Das Semikolon ist ein Befehlstrennzeichen und kann eine neue Zeile in einem Skript ersetzen. <br><br>  Die <b>then-</b> Anweisung f√ºhrt zwei Befehle aus: den <b>Echo-</b> Befehl, der die Nachricht auf dem Bildschirm anzeigt, und den <b>Lesebefehl</b> . <br><br>  Der Befehl <b>read</b> stoppt das Skript, damit Benutzereingaben verarbeitet und in der Variablen TEXT gespeichert werden k√∂nnen.  Beim <b>Lesen von TEXT</b> werden daher alle Benutzereingaben in die TEXT-Variable eingef√ºgt, die sp√§ter im Skript verwendet wird. <br><br>  Der n√§chste Teil wird durch die <b>else-Anweisung dargestellt</b> .  Befehle nach der <b>else-Anweisung</b> werden in allen anderen F√§llen ausgef√ºhrt, was in diesem Fall "andernfalls, wenn das Argument angegeben wurde" bedeutet.  Wenn ja, wird die TEXT-Variable bestimmt und der aktuelle Wert von <b>$ 1</b> zugewiesen. <br><br>  Beachten Sie, wie die Variable definiert ist: Unmittelbar nach dem Namen der Variablen steht ein = -Zeichen gefolgt von $ 1.  Beachten Sie, dass Sie beim Definieren von Variablen niemals Leerzeichen verwenden sollten. <br><br>  Dann werden die if-Bedingungen mit dem <b>fi-</b> Operator geschlossen.  Nachdem die if-Bedingung erf√ºllt ist, wissen Sie sicher, dass die TEXT-Variable definiert ist und einen Wert hat.  Die vorletzte Zeile des Skripts liest den Wert der TEXT-Variablen und ordnet diesen Wert mit dem Befehl <b>echo</b> STDOUT zu.  Beachten Sie, dass sich das Anfordern des aktuellen Werts einer Variablen auf den Namen der Variablen bezieht, beginnend mit dem $ -Zeichen davor. <br><br>  <b>Sie k√∂nnen dieses Beispiel √ºben, wenn Sie mit Eingaben arbeiten.</b> <br><br><ol><li>  √ñffnen Sie den Editor und erstellen Sie eine Datei mit dem Namen Text.  Geben Sie den Inhalt des Codes in Listing 3 in diese Datei ein. </li><li>  Schreiben Sie die Datei auf die Festplatte und f√ºhren Sie <b>chmod + x-Text aus</b> , um sie ausf√ºhrbar zu machen. </li><li>  F√ºhren Sie das Skript aus, indem Sie <b>./text</b> und ohne zus√§tzliche Argumente <b>ausf√ºhren</b> .  Sie werden sehen, dass Sie zur Eingabe aufgefordert werden. </li><li>  F√ºhren Sie das Skript mit " <b>Hallo</b> " als Argument aus (./text Hallo).  Das Ergebnis zeigt in STDOUT "Sie haben den Text Hallo eingegeben" an. </li></ol><br><h2>  Bedingungen und Schleifen verwenden </h2><br>  Wie Sie bereits gesehen haben, k√∂nnen bedingte Anweisungen in einem Skript verwendet werden.  Diese bedingten Anweisungen werden nur ausgef√ºhrt, wenn eine bestimmte Bedingung erf√ºllt ist. <br><br>  Es gibt mehrere bedingte Anweisungen und Schleifen in bash, die h√§ufig verwendet werden. <br><br><ul><li>  <b>if ... then ... else</b> - wird verwendet, um Code auszuf√ºhren, wenn eine bestimmte Bedingung erf√ºllt ist </li><li>  <b>for</b> - wird verwendet, um Befehle f√ºr einen Wertebereich auszuf√ºhren </li><li>  <b>while</b> - wird verwendet, um Code auszuf√ºhren, wenn eine bestimmte Bedingung erf√ºllt ist </li><li>  <b>before</b> - wird verwendet, um Code auszuf√ºhren, bis eine bestimmte Bedingung erf√ºllt ist </li><li>  <b>case</b> - wird verwendet, um eine begrenzte Anzahl spezifischer Werte auszuwerten </li></ul><br><h3>  wenn dann sonst </h3><br>  Das <b>if then else-Konstrukt</b> ist f√ºr die Bewertung bestimmter Bedingungen √ºblich.  Sie haben bereits ein Beispiel mit ihm gesehen.  Diese bedingte Anweisung wird h√§ufig mit dem <b>Testbefehl verwendet</b> .  Mit diesem Befehl k√∂nnen Sie viele Dinge √ºberpr√ºfen: Zum Beispiel nicht nur, ob eine Datei vorhanden ist, sondern auch Dateien vergleichen, Ganzzahlen vergleichen und vieles mehr. <br><blockquote>  Weitere Informationen zum Test finden Sie in der Referenz mit dem Befehl man test. </blockquote><br>  Das grundlegende <b>if-</b> Konstrukt ist <b>if ... then ... fi</b> . <br><br>  Es vergleicht eine Bedingung, wie im folgenden Beispiel gezeigt: <br><br><pre> <code class="bash hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> [ -z <span class="hljs-variable"><span class="hljs-variable">$1</span></span> ] <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> no value provided <span class="hljs-keyword"><span class="hljs-keyword">fi</span></span></code> </pre><br>  In Listing 3 haben Sie gesehen, wie Sie zwei Bedingungen bewerten k√∂nnen, einschlie√ülich <b>else</b> in einem Ausdruck.  Listing 4 zeigt, wie mehrere Bedingungen von <b>if</b> bis <b>else</b> bewertet werden.  Dies ist n√ºtzlich, wenn Sie viele verschiedene Werte √ºberpr√ºfen m√ºssen. <br><br>  Beachten Sie, dass in diesem Beispiel auch mehrere <b>Testbefehle verwendet</b> werden. <br><br>  <b>Listing 4</b> :  Beispiel mit <b>wenn dann sonst</b> <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#!/bin/bash # run this script with one argument # the goal is to find out if the argument is a file or a directory if [ -f $1 ] then echo "$1 is a file" elif [ -d $1 ] then echo "$1 is a directory" else echo "I do not know what \$1 is" fi exit 0</span></span></code> </pre> <br><h3>  ||  und &amp;&amp; </h3><br>  Anstatt vollst√§ndige <b>if ... -Anweisungen zu</b> schreiben <b>,</b> k√∂nnen Sie die logischen Operatoren <b>|| verwenden</b>  sowie <b>&amp;&amp;</b> .  <b>||</b>  ist ein logisches "ODER" und f√ºhrt den zweiten Teil der Anweisung nur aus, wenn der erste Teil nicht wahr ist;  <b>&amp;&amp;</b> ist ein logisches "UND" und f√ºhrt den zweiten Teil der Anweisung nur aus, wenn der erste Teil wahr ist. <br><br>  <b>Betrachten Sie diese beiden Zeilen:</b> <br><br><pre> <code class="bash hljs">[ -z <span class="hljs-variable"><span class="hljs-variable">$1</span></span> ] &amp;&amp; <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> no argument provided</code> </pre> <br><pre> <code class="bash hljs">ping -c 1 8.8.8.8 2&gt;/dev/null || <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> node is not available</code> </pre><br>  Im ersten Beispiel wird √ºberpr√ºft, ob <b>$ 1</b> leer ist.  Wenn diese Pr√ºfung korrekt ist (was im Grunde bedeutet, dass der Befehl mit dem Exit-Code 0 endet), wird der zweite Befehl ausgef√ºhrt. <br><br>  Im zweiten Beispiel wird der Befehl <b>ping</b> verwendet, um die Verf√ºgbarkeit des Hosts zu √ºberpr√ºfen. <br>  In diesem Beispiel wird ein logisches "ODER" verwendet, um den Text "Knoten ist nicht verf√ºgbar" anzuzeigen, falls ein <b>Ping-</b> Befehl fehlschl√§gt. <br><br>  Sie werden das h√§ufig anstelle der bedingten <b>if-Anweisung</b> <b>&amp;&amp;</b> und <b>|| finden</b>  .  In der folgenden √úbung k√∂nnen Sie die Verwendung von bedingten Anweisungen √ºben, indem Sie entweder <b>if ... then ... else</b> oder <b>&amp;&amp;</b> und <b>|| verwenden</b>  . <br><br>  <b>√úbung</b> .  Verwenden Sie <b>if ... then ... else</b> <br><br>  In dieser √úbung arbeiten Sie an einem Skript, das √ºberpr√ºft, was eine Datei und was ein Verzeichnis ist. <br><br><ol><li>  Starten Sie den Editor und erstellen Sie ein Skript namens filechk. </li><li>  Kopieren Sie den Inhalt von Listing 4 in dieses Skript. </li><li>  F√ºhren Sie damit einige Tests durch, z. B. <b>./filechk / etc / hosts</b> , <b>./filechck / usr</b> , <b>./filechk nicht vorhandene Datei</b> . </li></ol><br><h2>  F√ºr Schleife </h2><br>  Die <b>for-</b> Schleife ist eine gro√üartige L√∂sung f√ºr die Verarbeitung von Datenbereichen.  In Listing 5 sehen Sie das erste Beispiel mit <b>for</b> , in dem der Bereich bestimmt und verarbeitet wird, w√§hrend sich Rohwerte in diesem Bereich befinden. <br><br>  <b>Listing 5:</b> <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#!/bin/bash # for (( COUNTER=100; COUNTER&gt;1; COUNTER-- )); do echo $COUNTER done exit 0</span></span></code> </pre> <br>  Eine <b>for-</b> Schleife beginnt immer mit dem Schl√ºsselwort for, gefolgt von einer Bedingung, die √ºberpr√ºft werden muss.  Darauf folgt das Schl√ºsselwort <b>do</b> , gefolgt von Befehlen, die ausgef√ºhrt werden m√ºssen. Wenn die Bedingung erf√ºllt ist, wird die Schleife mit dem Schl√ºsselwort <b>done</b> beendet. <br><br>  Im Beispiel in Listing 5 sehen Sie, dass die Bedingung ein Zahlenbereich in Klammern ist, der der Variablen COUNTER zugewiesen ist. <br><br>  <b>Eine kleine Erkl√§rung</b> <br><br>  Innerhalb <b>((...)) werden</b> arithmetische Ausdr√ºcke berechnet und ihr Ergebnis zur√ºckgegeben.  Im einfachsten Fall weist die Konstruktion a = $ ((5 + 3)) der Variablen "a" den Wert des Ausdrucks "5 + 3" oder 8 zu. Au√üerdem erm√∂glichen doppelte Klammern das Arbeiten mit Variablen im Stil der C-Sprache. <br><br>  Zuerst wird die Variable auf 100 initialisiert, und solange der Wert gr√∂√üer als 1 ist, wird sie bei jeder Iteration von 1 subtrahiert. Solange die Bedingung erf√ºllt ist, wird der Wert der Variablen $ COUNTER mit dem Befehl <b>echo</b> angezeigt. <br><br>  In Listing 6 sehen Sie einen meiner Lieblings-Einzeiler mit <b>f√ºr</b> .  Der Bereich wird diesmal als eine Folge von Zahlen definiert, die von 100 bis 104 reichen. <br><br>  <b>Listing 6:</b> <br><br><pre> <code class="bash hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> {100..104}; <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> ping ‚Äìc 1 192.168.4.<span class="hljs-variable"><span class="hljs-variable">$i</span></span> &gt;/dev/null &amp;&amp; <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> 192.168.4.<span class="hljs-variable"><span class="hljs-variable">$i</span></span> is up; <span class="hljs-keyword"><span class="hljs-keyword">done</span></span></code> </pre><br>  Beachten Sie, wie der Bereich bestimmt wird: Zuerst geben Sie die erste Zahl an, dann zwei Punkte und geben die letzte Zahl im Bereich an.  Dar√ºber hinaus wird mit <b>f√ºr i in</b> f√ºr jede dieser Zahlen die Variable <b>i</b> zugewiesen.  Jede dieser Nummern wird der Variablen <b>i</b> zugewiesen, und dann wird der <b>Ping-</b> Befehl ausgef√ºhrt, wobei die Option <b>-c 1</b> sicherstellt, dass nur eine Anforderung gesendet wird. <br><br>  Das Ergebnis des <b>Ping-</b> Befehls <b>wird</b> nicht ber√ºcksichtigt, daher wird seine Ausgabe nach / dev / null umgeleitet.  Basierend auf dem Ausgabestatus des <b>Ping-</b> Befehls wird ein Teil des Ausdrucks <b>&amp;&amp;</b> ausgef√ºhrt.  Wenn der Host verf√ºgbar ist, wird eine Zeile angezeigt, die angibt, dass er ausgef√ºhrt wird. <br><br><h2>  Verstehen w√§hrend und bis </h2><br>  Wenn die for-Anweisung, √ºber die Sie gerade gelesen haben, f√ºr die Arbeit mit Elementbereichen n√ºtzlich ist, ist die while-Anweisung hilfreich, wenn Sie beispielsweise die Prozesszug√§nglichkeit verfolgen m√∂chten.  Es gibt auch eine <b>till-</b> Anweisung, die ausgef√ºhrt wird, solange die zu pr√ºfende Bedingung falsch ist.  In Listing 7 k√∂nnen Sie lesen, wie <b>while</b> zur √úberwachung der Prozessaktivit√§t verwendet wird. <br><blockquote>  Hinweis  Ich habe nicht verstanden, was dieses Skript macht.  In meinem Fall wird CentOS 7 verwendet und standardm√§√üig gibt es keinen Monitor, obwohl das Skript ausdr√ºcklich sagt: <pre>  Verwendung: Monitor &lt;Prozessname&gt; </pre>  Irgendwo f√ºr eine halbe Stunde habe ich das Monitorprogramm f√ºr CetOS gegoogelt, es aber nicht gefunden.  Und im Allgemeinen ist nicht klar, welcher Seitenmonitor hier ist, wenn ps aux verwendet wird.  Auf jeden Fall habe ich nicht verstanden, was dieses Skript macht.  Eine gro√üe Anfrage zur Behebung dieses Problems besteht darin, den Text und / oder das Skript anzupassen. </blockquote>  <b>Listing 7:</b> <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#!/bin/bash # # usage: monitor &lt;processname&gt; while ps aux | grep $1 | grep -v grep &gt; /dev/tty11 do sleep 5 done clear echo your process has stopped logger $1 is no longer present mail -s "process $1 has stopped" root &lt; .</span></span></code> </pre> <br>  Das Skript in Listing 7 besteht aus zwei Teilen.  Erstens gibt es eine <b>while-Schleife</b> .  Zweitens muss alles getan werden, wenn die <b>while-Schleife</b> nicht mehr als wahr ausgewertet wird. <br><br>  Der Kern der <b>while-Schleife</b> ist der Befehl <b>ps</b> mit dem Wert <b>$ 1</b> . <br><br>  Beachten Sie die Verwendung von <b>grep -v grep</b> , wodurch Zeilen, die den <b>Befehl grep enthalten,</b> vom Ergebnis ausgeschlossen werden.  Denken Sie daran, dass der Befehl <b>ps</b> alle laufenden Prozesse enth√§lt, einschlie√ülich des <b>Befehls grep</b> , an den die Ausgabe des <b>Befehls</b> <b>ps</b> √ºbergeben wird.  Dies kann zu einer falsch positiven √úbereinstimmung f√ºhren. <br><br>  Die Ausgabe des Befehls <b>ps aux</b> wird nach / dev / tty11 umgeleitet.  Auf diese Weise k√∂nnen Sie die Ergebnisse von tty11 bei Bedarf sp√§ter lesen, sie werden jedoch standardm√§√üig nicht angezeigt. <br><br>   <b>while</b>  ,   ,    .      <b>sleep 5</b> ,      5 . <br><br>    <b>while</b> ,   .     (    ,     ),       ,   . <br><br>       ,  .   <b>mail -s ‚Äúprocess $1 has stopped‚Äù root &lt; .</b>    root     ,      Linux*.  <b>mail</b>       ,     <b>-s</b> . <br><br> <i>* ‚Äî     CentOS   . (. )</i> <br><br>    <b>&lt; .</b>   . <br><br>     <b>mail</b>     ,      .   ,  ,    .        STDIN.      -     . <br><br>  <b>while</b> ‚Äî    <b>until</b> ,      8. <b>until</b>  ,     ,     . <br><br>   8        <b>users</b>   <b>$1</b> ,    .     ,  .       ,  ,    <b>until</b>   . <br><br> <b> 8</b> <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#!/bin/bash # until users | grep $1 &gt; /dev/null do echo $1 is not logged in yet sleep 5 done echo $1 has just logged in mail -s "$1 has just logged in" root &lt; .</span></span></code> </pre> <br><h2>  case </h2><br>      ‚Äî  <b>case</b> *.  <b>case</b>      .  ,  <b>case</b>     Linux,        . <br><br> <i>* ‚Äî  ?</i> <br><br>   <b>case</b>       ,    ,   ,    . <br><br>   9      <b>case</b> ,          . <br><br> <b> 9</b> <br><br><pre> <code class="bash hljs"><span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$1</span></span></span><span class="hljs-string">"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> start) start;; stop) rm -f <span class="hljs-variable"><span class="hljs-variable">$lockfile</span></span> stop;; restart) restart;; reload) reload;; status) status ;; *) <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">"Usage: </span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$0</span></span></span><span class="hljs-string"> (start|stop|restart|reload|status)"</span></span> ;; <span class="hljs-keyword"><span class="hljs-keyword">esac</span></span></code> </pre> <br> <b>case</b>   .    ‚Äî <i>case  in</i> .      ,   .     <b>)</b> . <br><br>    ,   ,    .        ;;            . <br><br>   ,  <b>*)</b>     ,   .  ¬´¬ª . <br><br>   <b>case</b>   <b>esac</b> . <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Beachten Sie, dass die Sequenzen f√ºr den </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fall</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> der Reihe nach </font><font style="vertical-align: inherit;">ausgef√ºhrt werden. </font><font style="vertical-align: inherit;">Wenn die erste √úbereinstimmung hergestellt </font><font style="vertical-align: inherit;">wird, bewertet </font><font style="vertical-align: inherit;">die </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">case-Anweisung</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> nichts. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Im Rahmen der Bewertung k√∂nnen Vorlagen verwendet werden, die der Vorlage √§hnlich sind. </font><font style="vertical-align: inherit;">Dies wird in </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">*) einer</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Sequenz gezeigt, die zu allem passt. </font><font style="vertical-align: inherit;">Sie k√∂nnen aber auch Sequenzen wie start | Start | START verwenden, um mit einem anderen </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fall √ºbereinzustimmen</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Debuggen von Skripten in Bash </font></font></h2><br>     ,   ,    .  ,       <b>bash -x</b> .    ,    ,    ,      . <br><br>   10    <b>bash -x</b> ,    ,   <b>grep</b>  ,    ,       . <br><br><pre> <code class="bash hljs">[root@server1 ~]<span class="hljs-comment"><span class="hljs-comment"># bash -x 319.sh + grep Usage: grep [OPTION]... PATTERN [FILE]... Try 'grep --help' for more information. + users + echo is not logged in yet is not logged in yet + sleep 5</span></span></code> </pre> <br><h2>   </h2><br>     ,    .           ,     . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de471242/">https://habr.com/ru/post/de471242/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de471226/index.html">Linux hat viele Gesichter: wie man an jeder Distribution arbeitet</a></li>
<li><a href="../de471228/index.html">Grokay PyTorch</a></li>
<li><a href="../de471232/index.html">Meine Erfahrung mit der Verbindung von LPS331AP mit Omega Onion2</a></li>
<li><a href="../de471236/index.html">Dosimeter f√ºr Seryozha. Teil III. Nationales Radiometer</a></li>
<li><a href="../de471240/index.html">"Bitchy Betty" und moderne Audio-Interfaces: Warum sprechen sie mit weiblicher Stimme?</a></li>
<li><a href="../de471244/index.html">Rosetta-Code: Messen Sie die L√§nge des Codes in einer Vielzahl von Programmiersprachen und untersuchen Sie die N√§he der Sprachen zueinander</a></li>
<li><a href="../de471248/index.html">Die US-Aufsichtsbeh√∂rden verbieten die Verteilung des Telegram Open Network-Tokens</a></li>
<li><a href="../de471254/index.html">ITMO University Accelerator Startups - Beginn von Bildverarbeitungsprojekten</a></li>
<li><a href="../de471256/index.html">Vue.js ist gut, aber ist es besser als eckig oder reagiert es?</a></li>
<li><a href="../de471258/index.html">Datenspeicher- / Ladesystem</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>