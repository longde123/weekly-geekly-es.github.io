<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>â­ï¸ ğŸ›€ğŸ¾ ğŸ˜˜ Menghapus data dari database shardable ğŸ‘¨â€ğŸš€ ğŸ”ª â—¼ï¸</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Artikel tentang cara mengatasi masalah mengoptimalkan proses menghapus file dari sistem yang terbengkalai. Ini tentang proyek untuk berbagi dan bekerj...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Menghapus data dari database shardable</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/427895/"> Artikel tentang cara mengatasi masalah mengoptimalkan proses menghapus file dari sistem yang terbengkalai.  Ini tentang proyek untuk berbagi dan bekerja dengan file.  Sistem itu startup sekitar 8 tahun yang lalu, kemudian berhasil menembak dan dijual beberapa kali.  Proyek ini memiliki 4 pengembang yang bersama dengan proyek dari awal, yang sangat berharga.  Dokumentasi, secara tradisional, tidak punya waktu untuk menulis, atau tidak terlalu relevan. <br><br>  Mengapa Anda membaca ini dan mengapa saya menulis semua ini?  Saya ingin berbicara tentang garu yang dengan hati-hati terletak di dalam sistem dan memukul sehingga bintang-bintang keluar dari mata. <br><br>  Saya ingin mengucapkan terima kasih banyak kepada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" class="user_link">Hanna_Hlushakova</a> untuk bekerja bersama, membawa proyek sampai akhir dan membantu dalam mempersiapkan artikel.  Pada dasarnya, Anda akan menemukan deskripsi masalah dan algoritma untuk menyelesaikannya, yang kami gunakan, tidak ada contoh kode, struktur data, atau hal-hal lain yang diperlukan.  Saya tidak tahu apakah pengalaman saya akan membantu Anda menghindari menyapu di rumah, tetapi saya harap Anda mendapatkan sesuatu yang bermanfaat.  Mungkin artikel ini akan benar-benar kehilangan waktu berharga yang tidak dapat dibatalkan. <br><br><img src="https://habrastorage.org/webt/lb/p2/s5/lbp2s5dnlsusssfxqfd3zf9aoyk.png"><br><a name="habracut"></a><br><h3>  Tentang proyek </h3><br>  Proyek ini adalah salah satu pemimpin di lapangan Gartner, memiliki perusahaan klien dengan lebih dari 300 ribu karyawan di AS dan Eropa, dan beberapa miliar file untuk pemeliharaan. <br><br>  Teknologi berikut digunakan dalam proyek: Microsoft, C # .net server, database MS SQL, 14 server aktif + 14 dalam mode mirroring data. <br><br>  Volume database hingga 4 Tb, beban konstan dalam jam kerja adalah sekitar 400 ribu permintaan per menit. <br><br>  Ada banyak logika bisnis dalam database: <br>  450 meja <br>  1000 prosedur tersimpan <br>  80.000 baris kode SQL <br>  Secara tradisional, mereka tidak punya waktu untuk menulis dokumentasi, atau tidak relevan. <br><br><h3>  Tentang tugas </h3><br>  Tugasnya adalah untuk menghapus penghapusan file dari penyimpanan yang sudah dihapus oleh klien, dan periode penyimpanan file yang dihapus telah kedaluwarsa, jika mereka ingin dikembalikan.  Dalam versi saat ini, menurut perhitungan perusahaan itu sendiri, file yang dihapus 1 tahun yang lalu disimpan di server, meskipun menurut ketentuan bisnis mereka seharusnya disimpan hanya 1 bulan.  Karena beberapa file disimpan pada S3, perusahaan membayar untuk data tambahan, dan pelanggan yang menggunakan penyimpanan On-Premises bertanya-tanya mengapa file mengambil lebih banyak ruang daripada yang seharusnya. <br><br>  Database shardovany untuk klien perusahaan. <br><br><h3>  Bagaimana cara kerja penghapusan sebelumnya? </h3><br><br><img src="https://habrastorage.org/webt/wy/zx/dq/wyzxdqqakclb2u1kjmtbzl3v39y.png"><br><br>  Pada server global dengan informasi tentang semua file dalam sistem, rentang 15 ribu pengidentifikasi file terbentuk. <br><br>  Kemudian, sesuai dengan jadwal, survei server diluncurkan untuk berbagai pengidentifikasi file. <br>  Batas-batas rentang ditransmisikan ke setiap beling. <br><br>  Shard sebagai respons mengirim file yang ditemukan dari jangkauan. <br><br>  Server utama menambahkan file yang hilang ke tabel antrian untuk dihapus dalam database-nya. <br>  Kemudian, dari tabel antrian, layanan penghapusan file fisik dari penyimpanan menerima banyak pengidentifikasi untuk dihapus, setelah itu mengirim konfirmasi bahwa itu akan menghapus file dan cek dimulai untuk semua pecahan apakah file-file ini digunakan di sana. <br>  Dengan peningkatan jumlah file, pendekatan ini mulai bekerja sangat lambat, karena ada beberapa miliar file, dan jumlah rentang meningkat secara signifikan.  File yang dihapus masih kurang dari 5% dibandingkan dengan jumlah total, masing-masing, sangat tidak efisien untuk menyortir miliaran file untuk menemukan beberapa juta file yang dihapus. <br><br>  Misalnya, biasanya setelah pengguna menghapus file, itu harus disimpan selama 1 bulan, jika perlu dipulihkan.  Setelah periode ini, file harus dihapus oleh program dari repositori.  Dengan jumlah file saat ini, jumlah rentang dan kecepatan bypass rentang, akan membutuhkan waktu 1 tahun bagi server untuk sepenuhnya memotong semua rentang. <br>  Jelas bahwa tempat itu tidak dibebaskan, dan ini menyebabkan ketidakpuasan pengguna, karena server mereka menyimpan file berkali-kali lebih banyak daripada yang seharusnya dilaporkan.  Perusahaan jasa itu sendiri membayar tempat tambahan pada S3, yang merupakan kerugian langsung untuk itu. <br><br>  Hanya pada S3 saat pekerjaan dimulai, 2 Petabyte file yang dihapus disimpan, dan ini hanya di cloud.  Selain itu, ada klien yang file-nya disimpan di server khusus mereka, yang memiliki masalah yang sama: ruang server ditempati oleh file yang dihapus oleh pengguna tetapi tidak dihapus dari server. <br><br><h3>  Apa yang Anda putuskan untuk lakukan? </h3><br>  Kami memutuskan untuk melacak peristiwa penghapusan: <br><br><ul><li>  klien menghapus file dan kemudian kedaluwarsa. </li><li>  pengguna langsung menghapus file tanpa kemungkinan pemulihan. </li></ul><br>  Saat menghapus file dari database yang terbengkalai, kami memutuskan untuk menggunakan pendekatan optimis dan menghapus salah satu pemeriksaan untuk digunakan.  Kami tahu bahwa 99% file hanya digunakan dalam satu shard.  Kami memutuskan untuk segera menambahkan file ke antrean penghapusan, dan jangan memeriksa sisa pecahan untuk penggunaan file ini, karena pemeriksaan akan dilakukan lagi ketika penghapusan dari toko mengkonfirmasi layanan. <br><br>  Selain itu, mereka meninggalkan PEKERJAAN saat ini yang memeriksa file yang dihapus oleh rentang untuk menambahkan file yang dihapus sebelum rilis versi baru. <br><br>  Segala sesuatu yang dihapus pada beling dikumpulkan dalam sebuah tabel dan kemudian ditransfer ke server tunggal, dengan informasi tentang semua file. <br><br>  Di server ini, ia dikirim ke tabel antrian hapus. <br><br>  Dalam tabel untuk dihapus sebelum dihapus, diperiksa bahwa file tersebut tidak digunakan pada semua pecahan.  Bagian cek ini ada di sini sebelum kode diubah, dan mereka memutuskan untuk tidak menyentuhnya. <br><br><h4>  Apa yang perlu Anda ubah dalam kode? </h4><br>  Pada masing-masing pecahan, sebuah tabel ditambahkan ke mana pengidentifikasi file yang dihapus harus ditulis. <br><br>  Kami menemukan semua prosedur untuk menghapus file dari database, hanya ada 2. Setelah pengguna menghapus file, file tersebut masih berada di database untuk beberapa waktu. <br><br>  Dalam prosedur untuk menghapus file dari database, kami menambahkan entri ke tabel lokal ini dengan file yang dihapus. <br><br>  Di server global dengan file, mereka membuat PEKERJAAN yang mengunduh daftar file dari database shard.  Hanya dengan memanggil prosedur dari basis data shardable, itu membuat DELETE di dalam dan menampilkan daftar file dalam OUTPUT.  Dalam MS SQL Server tarik - tarik dari server jauh lebih cepat daripada memasukkan ke server jauh.  Semua ini dilakukan dalam blok. <br>  File-file ini kemudian ditambahkan ke tabel antrian hapus di server global. <br>  Tabel dengan pengidentifikasi shard ditambahkan ke tabel antrian untuk mengetahui dari mana datangnya acara hapus. <br><br><h3>  Bagaimana semua orang mengujinya? </h3><br>  Ada 3 lingkungan: <br><br>  Dev adalah lingkungan pengembangan.  Kode diambil dari cabang pengembangan gith.  Dimungkinkan untuk menggunakan versi kode yang berbeda pada IIS dan membuat beberapa versi orkestrasi.  Ini akan terhubung ke lingkungan dev dari klien di dalam vpn.  Sampai saat ini, ketidaknyamanan itu hanya dengan database, karena semua perubahan pada database dapat merusak pekerjaan bagian lain dari sistem.  Kemudian basis dibuat lokal.  Kode yang sudah berjalan dapat dituangkan ke server dev dengan basis data agar tidak merusak pekerjaan semua orang.  Pada lingkungan dev, ada 3 pecahan, bukannya 12, yang ada di prod, tetapi ini biasanya cukup untuk menguji interaksi. <br><br>  Pementasan - lingkungannya sama dengan prod menurut versi kode (hampir sama, karena jarang, tetapi ada perubahan langsung pada prod oleh administrator).  Salinan kode dari cabang master.  Terkadang beberapa perbedaan dengan kode pada prod tertangkap dalam database, tetapi secara umum keduanya identik.  Ada juga 3 pecahan pada Pementasan serta pada gadis.  Tidak ada beban pada pementasan maupun pada dev.  Di sini Anda dapat menjalankan tes integrasi sepenuhnya, karena kode cocok dengan prod.  Semua tes harus lulus, ini adalah prasyarat sebelum pergi ke penempatan. <br><br>  Perf lab, tempat pengujian dilakukan di bawah beban.  Beban dibuat menggunakan jmeter, 10 kali lebih sedikit dari pada prod, dan hanya ada satu beling, yang terkadang menciptakan ketidaknyamanan.  Data penjualan diambil, kemudian dianonimkan dan digunakan di laboratorium perf.  Semua server dengan konfigurasi yang sama seperti pada prod. <br><br>  Bebannya 10 kali lebih sedikit, karena diasumsikan bahwa ini adalah perkiraan beban yang datang ke prod untuk 1 shard.  Kelemahannya adalah bahwa basis global sangat kurang dimanfaatkan, tidak seperti penjualan.  Dan, jika perubahan terutama menyangkut basis data global dengan file, maka Anda dapat mengandalkan hanya pada hasil tes - pada prod ini mungkin tidak berfungsi seperti itu.  Meskipun perf lab tidak sesuai dengan beban dengan prod, kemampuan untuk menguji di bawah beban sudah membantu untuk menangkap banyak kesalahan sebelum disebarkan ke prod. <br><br>  Ada juga server cadangan di mana Anda dapat melihat data dari penjualan untuk menangkap beberapa kasus.  Secara umum, perusahaan beroperasi di bawah lisensi yang melarang pengembang memberikan akses ke data penjualan, dan akses administrasi dan tim dukungan (Operasi), sehingga Anda perlu meminta bantuan administrator database.  Data penjualan membuat pengujian sangat mudah, karena beberapa kasus hanya muncul pada data prod dan sangat berguna untuk mempelajari data dalam sistem nyata untuk memahami cara kerja sistem bagi pengguna. <br><br>  Selama tes di laboratorium perf, ternyata beban menghapus file dari penyimpanan tidak disadari dari kata sama sekali.  Saat menerapkan pengujian beban, kami memilih permintaan yang lebih populer dari perangkat lunak klien, beberapa di antaranya tidak dimasukkan dalam pembersihan penyimpanan.  Karena ini adalah basis data, ternyata melakukan pengujian yang disederhanakan untuk semua objek yang diubah dengan panggilan prosedur yang diubah pada data yang berbeda secara manual.  (pada opsi yang saya tahu). <br>  Selain itu, dalam tes integrasi dan perf, penekanan utama ditempatkan pada jenis penyimpanan file yang paling populer. <br><br>  Fitur tambahan dari lab perf, yang tidak segera ditemukan, adalah ketidakcocokan jumlah data dalam beberapa tabel pada prod dan perf.  Dalam arti bahwa semua PEKERJAAN penjualan bekerja pada perf, yang menghasilkan data, tetapi tidak selalu ada sesuatu yang memproses data yang dihasilkan dalam tabel.  Dan, misalnya, tabel-antrian untuk penghapusan pada perf jauh lebih besar daripada pada prod - 20 juta rekaman pada perf dan 200 ribu rekaman pada pro <br><br><h4>  Proses penyebaran </h4><br>  Proses penyebaran cukup standar.  Tidak ada perubahan dalam kode aplikasi untuk tugas ini, semua perubahan hanya ada di database.  DBA selalu dimasukkan ke dalam basis data, proses ini tidak otomatis.  2 versi skrip disiapkan - untuk menerapkan perubahan dan untuk mengembalikan perubahan, dan instruksi untuk DBA ditulis.  2 versi skrip selalu dibuat, dan mereka harus diuji untuk rollback dan rollback perubahan.  Dan skrip yang sama ini digunakan untuk menerapkan perubahan pada laboratorium pementasan dan kinerja sebelum meluncurkan pengujian integrasi dan pemuatan. <br><br><h3>  Apa yang terjadi setelah penempatan? </h3><br>  Dalam 5 jam pertama setelah penyebaran, 1 juta peristiwa datang bahwa perangkat lunak klien menerima kesalahan saat mencoba mengunduh file.  Acara "file rusak".  Ini berarti bahwa klien sedang mencoba mengunduh file, tetapi file itu tidak ditemukan di repositori.  Biasanya peristiwa ini tidak sama sekali, atau mereka diukur dengan 1 - 2 ribu per hari. <br><br>  Saya harus mengatakan segera bahwa diperlukan setidaknya 1 minggu untuk menemukan penyebab kegagalan pada tim yang terdiri dari 3 orang dan kadang-kadang 5 orang (termasuk saya). <br><br>  Kami mengumpulkan seluruh daftar file tempat acara "File Corrupted" datang. <br><br>  Terlepas dari kenyataan bahwa ada lebih dari 1 juta peristiwa dan semuanya berasal dari pengguna yang berbeda, perusahaan yang berbeda, hanya ada 250 file unik dalam daftar ini. <br><br>  DBA pada server cadangan dinaikkan untuk menyelidiki cadangan database pada saat kejadian tiba.  Ada beberapa tabel di pangkalan proyek dengan semua jenis log yang membantu dalam analisis.  Bahkan ketika menghapus informasi dari database, log ditambahkan ke apa yang telah dihapus dan oleh peristiwa apa.  Pada prod, catatan tersebut disimpan selama 1 minggu, kemudian digabungkan ke server arsip. <br><br>  Demikian juga tabel dengan log yang banyak membantu dalam menganalisis apa yang terjadi: <br>  Log lengkap dengan acara klien disimpan di setiap beling <br><br>  Di server global: <br><br><ul><li>  Log permintaan untuk mengunduh semua file oleh pengguna </li><li>  Log mengunggah file ke sistem dari pengguna </li><li>  Log peristiwa FileCorrupt </li><li>  Log file untuk membatalkan penghapusan dari penyimpanan </li><li>  Log file yang dihapus dari database </li></ul><br>  Selain itu, ELK dengan log aplikasi juga tersedia. <br><br>  Kami berhasil mengulangi kesalahan pada lingkungan dev, yang mengkonfirmasi kebenaran asumsi tersebut.  Pada awalnya, tidak ada yang menganggap hipotesis ini serius, karena sangat sulit untuk percaya bahwa begitu banyak faktor bertepatan pada waktu yang sama dan begitu banyak pengguna yang datang pada waktu khusus ini. <br><br><h3>  Apa yang salah? </h3><br>  Ternyata sistem tersebut memiliki sekitar 250 (untuk perbandingan, miliaran file dalam sistem) file super mega duper super.  250 ya! <br><br>  File-file ini masih sangat tua.  Pada saat file-file ini diunggah ke sistem, sistem lain untuk menghasilkan kunci file ke penyimpanan digunakan. <br><br>  Ternyata untuk jenis kunci ini, metode penghapusan fisik dari penyimpanan fisik berperilaku berbeda dari file lain. <br><br>  Di kelas dengan penghapusan, ada blok kode dengan kondisi khusus untuk file dengan kunci lama.  Sistem, pada saat penghapusan, sebelum diperiksa bahwa file tidak ada di pecahan, memindahkan file lama ini ke lokasi lain.  Yah, itu tidak berhasil. <br><br>  Dan ternyata pada saat file dipindahkan (dan saya akan mengingatkannya sangat populer), jika salah satu pengguna mencoba memberinya hak pengguna baru, perangkat lunak klien pergi ke penyimpanan untuk file ini, tetapi file tersebut tidak berada di tempat yang tepat.  Sejak dipindahkan, jadi tidak berhasil.  Dan perangkat lunak klien mengirim pesan bahwa file tersebut rusak.  Dalam database, itu ditandai sebagai rusak.  Dan semua informasi dihapus dari database (well, hampir semua). <br><br>  Sementara itu, rutin pemeriksaan beling kami menemukan bahwa file tersebut sedang digunakan.  Dan mengirimkan respons yang Anda perlukan untuk mengembalikannya.  Tetapi semua info sudah dihapus dari database, dan tidak mungkin mengembalikannya. <br><br>  Lucu ya <br><br>  Yaitu, ketika file dihapus, pengguna berada dalam periode waktu ketika file dipindahkan, pecahan diperiksa, dan pada saat itulah pengguna mengirim permintaan untuk mengunduh. <br><br>  Ini dia - mainkan dalam aksi, saat pertandingan paling luar biasa yang cocok dengan Anda. <br><br><img src="https://habrastorage.org/webt/_y/m6/me/_ym6meu2s43ds32d1ngjzspn67k.png"><br><br>  Setelah pulih dari keterkejutan dan mengembalikan semuanya, kami memastikan bahwa file dari pengguna masih hidup, karena dipulihkan dari disk klien lain. <br><br>  Secara alami, semuanya baik-baik saja dalam pengujian, karena selama pengujian file yang lebih baru dihapus dengan tipe kunci baru yang digunakan dalam 5 tahun terakhir. File tersebut tidak ditransfer ke lokasi penyimpanan lain untuk waktu penghapusan. <br><br>  Optimisme kami berkurang, dan kami memutuskan untuk tidak mengambil jalan yang paling optimis. <br><br><h3>  Retrospektif </h3><br>  Kami memutuskan bahwa kami perlu menambahkan tes untuk berbagai jenis penyimpanan <br>  Tambahkan beban ke laboratorium perf yang menggunakan panggilan saat dihapus dari penyimpanan <br>  Tutup kondisi lomba yang terkenal <br>  Tambahkan pemantauan (meskipun akan ada dalam rencana, tetapi tidak sesuai dengan ruang lingkup asli) <br><br><h3>  Tentang pemantauan </h3><br>  Mereka memutuskan untuk melakukan pemantauan segera, tetapi kemudian dia menghilang ke latar belakang, karena itu perlu untuk digunakan lebih cepat. <br><br>  Untuk pemantauan, proyek menggunakan Zabbix, ELK, Grafana, NewRelic, SQL Sentry dan versi uji AppDynamics. <br><br>  Dari jumlah ini, pada laboratorium pef adalah NewRelic dan SQL Sentry. <br><br>  Kami sudah mengukur semua metrik sistem dan karenanya, kami ingin mengukur metrik bisnis.  Saya memiliki pengalaman mengatur pemantauan melalui Zabbix - kami memutuskan untuk melakukan hal yang sama. <br><br>  Skema ini sangat sederhana dalam database untuk membuat tabel untuk mengumpulkan metrik yang diperlukan oleh JOB dan prosedur yang akan mengunggah metrik yang dikumpulkan ke Zabbix. <br><br>  Metrik: <br><br><ul><li>  Jumlah file dalam antrian untuk dihapus secara global </li><li>  Jumlah file yang antri oleh server </li><li>  Jumlah file yang dikirim ke program uninstall dari repositori </li><li>  Jumlah file yang dihapus </li><li>  Jumlah Acara FileCorrupt </li><li>  Jumlah file yang akan dihapus pada setiap pecahan </li></ul><br>  Pemantauan dilaksanakan dan disebarkan ke prod secara terpisah, sebelum mereka mulai menerapkan implementasi penghapusan baru. <br><br><h3>  Solusi baru </h3><br>  Secara umum, kami memutuskan bahwa makan lebih baik daripada tidak tidur, dan membuat rencana baru. <br><br><ol><li>  periksa beling yang sama yang tidak ada lagi yang menggunakan file itu, dan hanya transfer file yang tidak digunakan ke server; </li><li>  ketika mentransfer ke server, kumpulkan semua file dalam tabel dan verifikasi bahwa file tidak digunakan pada pecahan sebelum ditempatkan di tabel antrian dequeue; </li><li>  saat menggunakan file dan mencarinya di sistem, tandai antrian dequeue di tabel sebagai file yang membutuhkan verifikasi; </li><li>  kembalikan hanya file yang tidak ada pencarian; </li><li>  file yang dicari, periksa kembali pecahan; </li><li>  secara umum, hapus centang pada prosedur yang menghapus file, karena harus bekerja dengan cepat - dan file yang digunakan seharusnya tidak mencapainya secara prinsip; </li><li>  memperhitungkan dalam prosedur bahwa semuanya terhapus oleh file yang dipukul itu dalam proses penghapusan, dan tidak menghapus informasi tentang itu. </li></ol><br>  Poin 6 selama penyebaran termasuk penghapusan cek dalam beberapa tahap.  Pertama, mereka meninggalkan cek, lalu seminggu kemudian cek pada file karyawan perusahaan dimatikan, setelah 2 minggu, cek dimatikan sepenuhnya. <br><br><h3>  Apa yang perlu Anda ubah dalam kode? </h3><br>  Sekali lagi, semua perubahan hanya berlaku untuk database. <br><br>  Skala perubahan adalah yang terbesar di server global: <br>  Tambahkan tabel perantara untuk menambahkan semua file yang diunduh dari pecahan. <br>  Buat PEKERJAAN yang memeriksa file pada tabel perantara yang tidak digunakan pada pecahan. <br><br>  Dalam antrian file yang dihapus, tambahkan bidang dengan tanggal file terakhir diakses dan tambahkan indeks. <br><br>  Temukan semua prosedur dengan akses ke file - ternyata 5 prosedur.  Tambahkan ke mereka satu blok mengubah tanggal penggunaan terakhir dalam tabel antrian.  Tanggal berubah setiap saat, terlepas dari apakah itu diisi atau tidak. <br><br>  Tambahkan program penghapusan ke prosedur penerbitan file sehingga hanya menampilkan file dengan tanggal penggunaan kosong. <br><br>  JOB,          (  10 ,  ,        ,    2 ,   )     .      ,    ,       .       ,      ,          ,            . <br><br>  : <br><br>  ,              ,    .         â€”  DELETE  output   NOT EXISTS. <br><br>  JOB,          . <br><br><h4>  Tes </h4><br>          . <br>    ,       . <br><br>  Perf Lab     .         . <br><br><h4>  </h4><br>          . DBA    ,           -   .     ,     . <br><br> -    JOB           ,  ,         . <br><br><h3>  </h3><br>              . <br> ,     ,          . <br><br>      S3   2   .         ,     ,          . <br><br>    -      ,      ,    -   . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id427895/">https://habr.com/ru/post/id427895/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id427879/index.html">Bagaimana saya beralih dari Python ke Julia (dan mengapa)</a></li>
<li><a href="../id427883/index.html">Memperkenalkan Virtualisasi, Kontainer, dan Kubernet: 18 Sumber Daya Cloud</a></li>
<li><a href="../id427889/index.html">Salah, salah, salah! metode mitigasi DDoS</a></li>
<li><a href="../id427891/index.html">Jutaan Orang Dapat Diserang Melalui Kerentanan dalam Platform Konferensi Cisco WebEx</a></li>
<li><a href="../id427893/index.html">Berdarah Lola di Omega 2 atau tersedak Python di Halloween</a></li>
<li><a href="../id427897/index.html">Parsing a Magnetic Resonance Imager II: Metamaterials dalam MRI</a></li>
<li><a href="../id427899/index.html">JsonWriterSax - perpustakaan untuk membuat JSON</a></li>
<li><a href="../id427901/index.html">Bagaimana tidak menggunakan Node.js Stream API</a></li>
<li><a href="../id427905/index.html">Penambangan makanan atau persimpangan jalan melalui mata seorang hacker</a></li>
<li><a href="../id427907/index.html">Drone shooting, rake, life hacks, pengembangan diri dan karier seorang fotografer / videografer: podcast GLPH baru</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>