<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üéª ‚è≠Ô∏è üìõ MVCC-2. Calques, fichiers, pages üë©üèø ü¶ñ ü•¶</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="La derni√®re fois, nous avons parl√© de la coh√©rence des donn√©es, examin√© la diff√©rence entre les diff√©rents niveaux d'isolement des transactions aux ye...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>MVCC-2. Calques, fichiers, pages</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/postgrespro/blog/444536/">  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">La derni√®re fois,</a> nous avons parl√© de la coh√©rence des donn√©es, examin√© la diff√©rence entre les diff√©rents niveaux d'isolement des transactions aux yeux de l'utilisateur et compris pourquoi il √©tait important de le savoir.  Nous commen√ßons maintenant √† apprendre comment PostgreSQL impl√©mente l'isolement bas√© sur les instantan√©s et le multi-versionnement. <br><br>  Dans cet article, nous verrons comment les donn√©es sont physiquement situ√©es dans des fichiers et des pages.  Cela nous √©loigne du sujet de l'isolement, mais une telle digression est n√©cessaire pour comprendre d'autres √©l√©ments.  Nous devons comprendre le fonctionnement du stockage de donn√©es de bas niveau. <br><br><h1>  Les relations </h1><br>  Si vous regardez √† l'int√©rieur des tables et des index, il s'av√®re qu'ils sont dispos√©s de mani√®re similaire.  √Ä la fois cela et un autre - objets de base qui contiennent des donn√©es constitu√©es de lignes. <br><br>  Le fait que le tableau se compose de lignes ne fait aucun doute;  pour l'indice, c'est moins √©vident.  Cependant, imaginez un arbre B: il se compose de n≈ìuds qui contiennent des valeurs index√©es et des liens vers d'autres n≈ìuds ou vers des lignes de table.  Ces n≈ìuds peuvent √™tre consid√©r√©s comme des lignes d'index - en fait, tels quels. <br><br>  En fait, il existe encore un certain nombre d'objets dispos√©s de mani√®re similaire: s√©quences (essentiellement des tables √† une seule ligne), vues mat√©rialis√©es (essentiellement des tables qui se souviennent de la requ√™te).  Et puis il y a les vues habituelles, qui en elles-m√™mes ne stockent pas de donn√©es, mais dans tous les autres sens sont similaires aux tableaux. <br><br>  Tous ces objets dans PostgreSQL sont appel√©s la <em>relation de</em> mots communs.  Le mot est extr√™mement malheureux car c'est un terme de la th√©orie relationnelle.  Vous pouvez faire un parall√®le entre la relation et la table (vue), mais certainement pas entre la relation et l'index.  Mais il en est ainsi: les racines acad√©miques de PostgreSQL se font sentir.  Je pense qu'au d√©but, cela s'appelait des tables et des vues, et le reste a augment√© avec le temps. <br><a name="habracut"></a><br>  De plus, pour plus de simplicit√©, nous ne parlerons que des tables et des index, mais le reste des <em>relations</em> sont structur√©es exactement de la m√™me mani√®re. <br><br><h1>  Calques (fourches) et fichiers </h1><br>  Habituellement, chaque relation a plusieurs <em>couches</em> (fourches).  Les couches sont de plusieurs types et chacune contient un certain type de donn√©es. <br><br>  S'il y a une couche, elle est d'abord repr√©sent√©e par un seul <em>fichier</em> .  Le nom du fichier est constitu√© d'un identifiant num√©rique auquel la fin correspondant au nom de la couche peut √™tre ajout√©e. <br><br>  Le fichier augmente progressivement et lorsque sa taille atteint 1 Go, le fichier suivant de la m√™me couche est cr√©√© (ces fichiers sont parfois appel√©s <em>segments</em> ).  Le num√©ro de segment est ajout√© √† la fin du nom de fichier. <br><br>  La limite de taille de fichier de 1 Go est apparue historiquement pour prendre en charge divers syst√®mes de fichiers, dont certains ne peuvent pas fonctionner avec des fichiers volumineux.  La restriction peut √™tre modifi√©e lors de la construction de PostgreSQL ( <code>./configure --with-segsize</code> ). <br><br>  Ainsi, plusieurs fichiers peuvent correspondre √† une relation sur un disque.  Par exemple, pour une petite table, il y en aura 3. <br><br>  Tous les fichiers d'objets appartenant √† un espace table et √† une base de donn√©es seront plac√©s dans un r√©pertoire.  Ceci doit √™tre pris en compte car les syst√®mes de fichiers ne fonctionnent g√©n√©ralement pas tr√®s bien avec un grand nombre de fichiers dans un r√©pertoire. <br><br>  Notez simplement que les fichiers, √† leur tour, sont divis√©s en <em>pages</em> (ou <em>blocs</em> ), g√©n√©ralement 8 Ko.  Nous allons parler de la structure interne des pages ci-dessous. <br><br><img src="https://habrastorage.org/webt/oz/ur/4z/ozur4zenihys-v-7wl5rnxyi8em.png"><br><br>  Voyons maintenant les types de calques. <br><br>  <strong>La couche principale</strong> est constitu√©e des donn√©es elles-m√™mes: la m√™me table ou les m√™mes lignes d'index.  La couche principale existe pour toute relation (sauf pour les repr√©sentations qui ne contiennent pas de donn√©es). <br><br>  Les noms des fichiers de la couche principale ne sont constitu√©s que d'un identifiant num√©rique.  Voici un exemple de chemin d'acc√®s au fichier de table que nous avons cr√©√© la derni√®re fois: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_relation_filepath(<span class="hljs-string"><span class="hljs-string">'accounts'</span></span>);</code> </pre><pre> <code class="plaintext hljs"> pg_relation_filepath ---------------------- base/41493/41496 (1 row)</code> </pre><br>  D'o√π viennent ces identifiants?  Le r√©pertoire de base correspond au tablespace pg_default, le sous-r√©pertoire suivant correspond √† la base de donn√©es, et le fichier qui nous int√©resse s'y trouve d√©j√†: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-type"><span class="hljs-type">oid</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_database <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> datname = <span class="hljs-string"><span class="hljs-string">'test'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> oid ------- 41493 (1 row)</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> relfilenode <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_class <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> relname = <span class="hljs-string"><span class="hljs-string">'accounts'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> relfilenode ------------- 41496 (1 row)</code> </pre><br>  Le chemin est relatif, il est compt√© √† partir du r√©pertoire de donn√©es (PGDATA).  De plus, presque tous les chemins dans PostgreSQL sont compt√©s √† partir de PGDATA.  Gr√¢ce √† cela, vous pouvez transf√©rer PGDATA en toute s√©curit√© vers un autre endroit - il ne contient rien (sauf si vous devrez peut-√™tre configurer le chemin d'acc√®s aux biblioth√®ques dans LD_LIBRARY_PATH). <br><br>  Nous regardons plus loin dans le syst√®me de fichiers: <br><br><pre> <code class="plaintext hljs">postgres$ ls -l --time-style=+ /var/lib/postgresql/11/main/base/41493/41496</code> </pre><pre> <code class="plaintext hljs">-rw------- 1 postgres postgres 8192 /var/lib/postgresql/11/main/base/41493/41496</code> </pre><br>  <strong>Une couche d'initialisation</strong> existe uniquement pour les tables non journalis√©es (cr√©√©es avec UNLOGGED) et leurs index.  Ces objets ne sont pas diff√©rents des objets ordinaires, sauf que les actions avec eux ne sont pas enregistr√©es dans le journal de pr√©-enregistrement.  Pour cette raison, le travail avec eux est plus rapide, mais en cas de panne, il est impossible de restaurer les donn√©es dans un √©tat coh√©rent.  Par cons√©quent, lors de la r√©cup√©ration, PostgreSQL supprime simplement toutes les couches de ces objets et √©crit la couche d'initialisation √† la place de la couche principale.  Le r√©sultat est un "mannequin".  Nous parlerons de la journalisation en d√©tail, mais dans un cycle diff√©rent. <br><br>  La table des comptes est journalis√©e, il n'y a donc pas de couche d'initialisation pour elle.  Mais pour l'exp√©rience, vous pouvez d√©sactiver la journalisation: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">ALTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> <span class="hljs-keyword"><span class="hljs-keyword">UNLOGGED</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_relation_filepath(<span class="hljs-string"><span class="hljs-string">'accounts'</span></span>);</code> </pre><pre> <code class="plaintext hljs"> pg_relation_filepath ---------------------- base/41493/41507 (1 row)</code> </pre><br>  La possibilit√© d'activer et de d√©sactiver la journalisation √† la vol√©e, comme le montre l'exemple, implique le remplacement des donn√©es dans des fichiers avec des noms diff√©rents. <br><br>  La couche d'initialisation porte le m√™me nom que la couche principale, mais avec le suffixe "_init": <br><br><pre> <code class="plaintext hljs">postgres$ ls -l --time-style=+ /var/lib/postgresql/11/main/base/41493/41507_init</code> </pre><pre> <code class="plaintext hljs">-rw------- 1 postgres postgres 0 /var/lib/postgresql/11/main/base/41493/41507_init</code> </pre><br>  <strong>Carte de l'espace libre</strong> ( <strong>carte de l'espace</strong> libre) - une couche dans laquelle il y a un espace vide √† l'int√©rieur des pages.  Cet endroit est en constante √©volution: lorsque de nouvelles versions de cha√Ænes sont ajout√©es, elles diminuent, tout en nettoyant - elles augmentent.  La carte d'espace libre est utilis√©e lors de l'insertion de nouvelles versions de lignes pour trouver rapidement une page appropri√©e sur laquelle les donn√©es √† ajouter tiendront. <br><br>  La carte d'espace libre a le suffixe "_fsm".  Mais le fichier n'appara√Æt pas imm√©diatement, mais seulement si n√©cessaire.  La fa√ßon la plus simple d'y parvenir est de nettoyer la table (pourquoi - parlons en temps voulu): <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">VACUUM</span></span> accounts;</code> </pre><br><pre> <code class="plaintext hljs">postgres$ ls -l --time-style=+ /var/lib/postgresql/11/main/base/41493/41507_fsm</code> </pre><pre> <code class="plaintext hljs">-rw------- 1 postgres postgres 24576 /var/lib/postgresql/11/main/base/41493/41507_fsm</code> </pre><br>  <strong>Une</strong> carte de visibilit√© est une couche dans laquelle les pages qui contiennent uniquement les versions actuelles des cha√Ænes sont marqu√©es d'un bit.  En gros, cela signifie que lorsqu'une transaction essaie de lire une ligne √† partir d'une telle page, la ligne peut √™tre affich√©e sans v√©rifier sa visibilit√©.  Nous examinerons en d√©tail comment cela se produit dans les articles suivants. <br><br><pre> <code class="plaintext hljs">postgres$ ls -l --time-style=+ /var/lib/postgresql/11/main/base/41493/41507_vm</code> </pre><pre> <code class="plaintext hljs">-rw------- 1 postgres postgres 8192 /var/lib/postgresql/11/main/base/41493/41507_vm</code> </pre><br><h1>  Pages </h1><br>  Comme nous l'avons d√©j√† dit, les fichiers sont logiquement divis√©s en pages. <br><br>  En r√®gle g√©n√©rale, une page fait 8 Ko.  Vous pouvez modifier la taille dans certaines limites (16 Ko ou 32 Ko), mais uniquement pendant l'assemblage ( <code>./configure --with-blocksize</code> ).  L'instance assembl√©e et en cours d'ex√©cution peut fonctionner avec des pages d'une seule taille. <br><br>  Quelle que soit la couche √† laquelle appartiennent les fichiers, ils sont utilis√©s par le serveur de la m√™me mani√®re.  Les pages sont d'abord lues dans le cache tampon, o√π les processus peuvent les lire et les modifier;  puis, si n√©cessaire, les pages sont repouss√©es sur le disque. <br><br>  Chaque page a un balisage interne et contient g√©n√©ralement les sections suivantes: <br><br><pre>        0 + ----------------------------------- +
           |  titre |
       24 + ----------------------------------- +
           |  tableau de pointeurs vers les cha√Ænes de version |
    inf√©rieur + ----------------------------------- +
           |  espace libre |
    sup√©rieur + ----------------------------------- +
           |  versions de ligne |
  sp√©cial + ----------------------------------- +
           |  zone sp√©ciale |
 taille de page + ----------------------------------- +
</pre><br>  La taille de ces sections est facile √† d√©couvrir avec l'extension "research" pageinspect: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">EXTENSION</span></span> pageinspect; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> lower, upper, special, pagesize <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> page_header(get_raw_page(<span class="hljs-string"><span class="hljs-string">'accounts'</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>));</code> </pre><pre> <code class="plaintext hljs"> lower | upper | special | pagesize -------+-------+---------+---------- 40 | 8016 | 8192 | 8192 (1 row)</code> </pre><br>  Nous regardons ici le <strong>titre de la</strong> toute premi√®re page (z√©ro) du tableau.  En plus de la taille des zones restantes, l'en-t√™te contient d'autres informations sur la page, mais cela ne nous int√©resse pas encore. <br><br>  Au bas de la page se trouve une <strong>zone sp√©ciale</strong> , dans notre cas, vide.  Il n'est utilis√© que pour les index, puis pas pour tout le monde.  Le ¬´bas¬ª correspond ici √† l'image;  il serait peut-√™tre plus juste de dire ¬´√† des adresses √©lev√©es¬ª. <br><br>  Apr√®s la zone sp√©ciale se trouvent <strong>les versions de ligne</strong> - les donn√©es m√™mes que nous stockons dans le tableau, ainsi que certaines informations de surcharge. <br><br>  En haut de la page, imm√©diatement apr√®s l'en-t√™te, se trouve la table des mati√®res: un <strong>tableau de pointeurs</strong> vers la version des lignes disponibles dans la page. <br><br>  Entre les versions de lignes et de pointeurs, il peut y avoir de <strong>l'espace libre</strong> (qui est marqu√© sur la carte de l'espace libre).  Notez qu'il n'y a pas de fragmentation √† l'int√©rieur de la page, tout l'espace libre est toujours repr√©sent√© par un fragment. <br><br><h2>  Pointeurs </h2><br>  Pourquoi des pointeurs vers des versions de cha√Ænes sont-ils n√©cessaires?  Le fait est que les lignes d'index doivent en quelque sorte faire r√©f√©rence √† la version des lignes de la table.  Il est clair que le lien doit contenir le num√©ro de fichier, le num√©ro de page dans le fichier et une indication de la version de la ligne.  Un d√©calage par rapport au d√©but de la page pourrait √™tre utilis√© comme une telle indication, mais cela n'est pas pratique.  Nous ne pourrions pas d√©placer la version de la ligne √† l'int√©rieur de la page car cela casserait les liens existants.  Et cela entra√Ænerait une fragmentation de l'espace √† l'int√©rieur des pages et d'autres cons√©quences d√©sagr√©ables.  Par cons√©quent, l'index fait r√©f√©rence au num√©ro d'index et le pointeur fait r√©f√©rence √† la position actuelle de la version de ligne dans la page.  Il s'av√®re que l'adressage indirect. <br><br>  Chaque pointeur occupe exactement 4 octets et contient: <br><br><ul><li>  lien vers la version de la cha√Æne; </li><li>  la longueur de cette version de la cha√Æne; </li><li>  plusieurs bits qui d√©terminent l'√©tat de version d'une cha√Æne. </li></ul><br><h2>  Format des donn√©es </h2><br>  Le format des donn√©es sur le disque co√Øncide compl√®tement avec la repr√©sentation des donn√©es en RAM.  La page est lue dans le cache tampon "en l'√©tat", sans aucune transformation.  Par cons√©quent, les fichiers de donn√©es d'une plate-forme sont incompatibles avec d'autres plates-formes. <br><br>  Par exemple, dans l'architecture x86, l'ordre des octets est adopt√© du moins significatif au plus √©lev√© (little-endian), z / Architecture utilise l'ordre inverse (big-endian), et dans ARM l'ordre de commutation. <br><br>  De nombreuses architectures assurent l'alignement des donn√©es au-del√† des limites des mots machine.  Par exemple, sur un syst√®me x86 32 bits, les entiers (type entier, occupent 4 octets) seront align√©s sur la bordure des mots de 4 octets, ainsi que les nombres √† virgule flottante double pr√©cision (type double pr√©cision, 8 octets).  Et sur un syst√®me 64 bits, les valeurs doubles seront align√©es sur la bordure des mots de 8 octets.  C'est une autre raison de l'incompatibilit√©. <br><br>  En raison de l'alignement, la taille de la ligne du tableau d√©pend de l'ordre des champs.  Habituellement, cet effet n'est pas tr√®s visible, mais dans certains cas, il peut entra√Æner une augmentation significative de la taille.  Par exemple, si vous placez les champs char (1) et entier m√©lang√©s, 3 octets seront g√©n√©ralement gaspill√©s entre eux.  Vous pouvez en savoir plus √† ce sujet dans la pr√©sentation de Nikolai Shaplov ¬´ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">What's Inside It</a> ¬ª. <br><br><h1>  Versions String et TOAST </h1><br>  √Ä propos de la fa√ßon dont les versions des cha√Ænes sont organis√©es de l'int√©rieur, nous parlerons en d√©tail la prochaine fois.  Jusqu'√† pr√©sent, la seule chose importante pour nous est que chaque version doit tenir enti√®rement sur une seule page: PostgreSQL ne fournit pas un moyen de "continuer" la ligne sur la page suivante.  Au lieu de cela, une technologie appel√©e TOAST (The Oversized Attributes Storage Technique) est utilis√©e.  Le nom lui-m√™me sugg√®re que la cha√Æne peut √™tre coup√©e en toasts. <br><br>  Plus s√©rieusement, TOAST implique plusieurs strat√©gies.  Les valeurs d'attribut ¬´longues¬ª peuvent √™tre envoy√©es √† une table de service distincte, pr√©alablement coup√©es en petits morceaux de pain grill√©.  Une autre option consiste √† compresser la valeur afin que la version de la ligne tienne toujours sur une page de table normale.  Et il est possible √† la fois cela et un autre: d'abord compresser, puis seulement couper et envoyer. <br><br>  Pour chaque table principale, si n√©cessaire, une table distincte, mais une pour tous les attributs, la table TOAST (et un index sp√©cial pour celle-ci) est cr√©√©e.  La n√©cessit√© est d√©termin√©e par la pr√©sence d'attributs potentiellement longs dans la table.  Par exemple, si une table a une colonne de type num√©rique ou texte, une table TOAST sera cr√©√©e imm√©diatement, m√™me si les valeurs longues ne sont pas utilis√©es. <br><br>  √âtant donn√© que la table TOAST est essentiellement une table r√©guli√®re, elle a toujours le m√™me ensemble de couches.  Et cela double le nombre de fichiers qui ¬´servent¬ª la table. <br><br>  Initialement, les strat√©gies sont d√©termin√©es par les types de donn√©es de colonne.  Vous pouvez les visualiser avec la commande <code>\d+</code> en psql, mais comme elle affiche √©galement de nombreuses autres informations, nous utiliserons la requ√™te dans le r√©pertoire syst√®me: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> attname, atttypid::<span class="hljs-type"><span class="hljs-type">regtype</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">CASE</span></span> attstorage <span class="hljs-keyword"><span class="hljs-keyword">WHEN</span></span> <span class="hljs-string"><span class="hljs-string">'p'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">THEN</span></span> <span class="hljs-string"><span class="hljs-string">'plain'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHEN</span></span> <span class="hljs-string"><span class="hljs-string">'e'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">THEN</span></span> <span class="hljs-string"><span class="hljs-string">'external'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHEN</span></span> <span class="hljs-string"><span class="hljs-string">'m'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">THEN</span></span> <span class="hljs-string"><span class="hljs-string">'main'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHEN</span></span> <span class="hljs-string"><span class="hljs-string">'x'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">THEN</span></span> <span class="hljs-string"><span class="hljs-string">'extended'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">END</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">storage</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_attribute <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> attrelid = <span class="hljs-string"><span class="hljs-string">'accounts'</span></span>::<span class="hljs-type"><span class="hljs-type">regclass</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> attnum &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>;</code> </pre><pre> <code class="plaintext hljs"> attname | atttypid | storage ---------+----------+---------- id | integer | plain number | text | extended client | text | extended amount | numeric | main (4 rows)</code> </pre><br>  Les noms des strat√©gies ont les significations suivantes: <br><br><ul><li>  plain - TOAST n'est pas utilis√© (utilis√© pour les types de donn√©es manifestement ¬´courts¬ª, comme l'entier); </li><li>  √©tendu - la compression et le stockage dans une table TOAST distincte sont autoris√©s; </li><li>  externe - les valeurs longues sont stock√©es dans la table TOAST non compress√©es; </li><li>  main - les valeurs longues sont compress√©es en premier et uniquement dans la table TOAST si la compression n'a pas aid√©. </li></ul><br>  En termes g√©n√©raux, l'algorithme est le suivant.  PostgreSQL veut qu'au moins 4 lignes tiennent sur une page.  Par cons√©quent, si la taille de la ligne d√©passe la quatri√®me partie de la page, en tenant compte de l'en-t√™te (avec une page normale de 8 Ko, c'est 2040 octets), TOAST doit √™tre appliqu√© √† une partie des valeurs.  Nous agissons dans l'ordre d√©crit ci-dessous et nous nous arr√™tons d√®s que la ligne cesse de d√©passer le seuil: <br><br><ol><li>  Tout d'abord, nous trions les attributs avec des strat√©gies externes et √©tendues, en passant du plus long au plus court.  Les attributs √©tendus sont compress√©s (si cela a un effet) et, si la valeur elle-m√™me d√©passe un quart de la page, elle est imm√©diatement envoy√©e √† la table TOAST.  Les attributs externes sont g√©r√©s de la m√™me mani√®re, mais ne sont pas compress√©s. </li><li>  Si apr√®s la premi√®re passe, la version de la ligne ne correspond toujours pas, nous envoyons les attributs restants avec les strat√©gies externes et √©tendues √† la table TOAST. </li><li>  Si cela ne vous aide pas non plus, essayez de compresser les attributs avec la strat√©gie principale, tout en les laissant dans la page du tableau. </li><li>  Et seulement si apr√®s cela la ligne n'est toujours pas assez courte, les principaux attributs sont envoy√©s √† la table TOAST. </li></ol><br>  Parfois, il peut √™tre utile de modifier la strat√©gie de certaines colonnes.  Par exemple, s'il est connu √† l'avance que les donn√©es de la colonne ne sont pas compress√©es, vous pouvez d√©finir une strat√©gie externe pour cela - cela vous √©vitera des tentatives de compression inutiles.  Cela se fait comme suit: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">ALTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">ALTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">COLUMN</span></span> number <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> <span class="hljs-keyword"><span class="hljs-keyword">STORAGE external</span></span>;</code> </pre><br>  En r√©p√©tant la demande, nous obtenons: <br><br><pre> <code class="plaintext hljs"> attname | atttypid | storage ---------+----------+---------- id | integer | plain number | text | external client | text | extended amount | numeric | main</code> </pre><br>  Les tables et index TOAST sont situ√©s dans un sch√©ma pg_toast distinct et ne sont donc g√©n√©ralement pas visibles.  Pour les tables temporaires, le sch√©ma pg_toast_temp_ <em>N</em> est utilis√©, similaire au pg_temp_ <em>N.</em> habituel <em>.</em> <br><br>  Bien s√ªr, si vous le souhaitez, personne ne prend la peine de jeter un ≈ìil √† la m√©canique interne du processus.  Supposons qu'il y ait trois attributs potentiellement longs dans la table des comptes, donc une table TOAST doit l'√™tre.  Le voici: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> relnamespace::<span class="hljs-type"><span class="hljs-type">regnamespace</span></span>, relname <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_class <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> <span class="hljs-type"><span class="hljs-type">oid</span></span> = ( <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> reltoastrelid <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_class <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> relname = <span class="hljs-string"><span class="hljs-string">'accounts'</span></span> );</code> </pre><pre> <code class="plaintext hljs"> relnamespace | relname --------------+---------------- pg_toast | pg_toast_33953 (1 row)</code> </pre><br><pre> <code class="pgsql hljs">=&gt; \d+ pg_toast.pg_toast_33953</code> </pre><pre> <code class="plaintext hljs">TOAST table "pg_toast.pg_toast_33953" Column | Type | Storage ------------+---------+--------- chunk_id | oid | plain chunk_seq | integer | plain chunk_data | bytea | plain</code> </pre><br>  Il est logique que pour les "toasts" dans lesquels la ligne est tranch√©e, la strat√©gie simple soit appliqu√©e: TOAST du deuxi√®me niveau n'existe pas. <br><br>  L'index PostgreSQL se cache plus soigneusement, mais il est √©galement facile √† trouver: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> indexrelid::<span class="hljs-type"><span class="hljs-type">regclass</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_index <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> indrelid = ( <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-type"><span class="hljs-type">oid</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_class <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> relname = <span class="hljs-string"><span class="hljs-string">'pg_toast_33953'</span></span> );</code> </pre><pre> <code class="plaintext hljs"> indexrelid ------------------------------- pg_toast.pg_toast_33953_index (1 row)</code> </pre><br><pre> <code class="pgsql hljs">=&gt; \d pg_toast.pg_toast_33953_index</code> </pre><pre> <code class="plaintext hljs">Unlogged index "pg_toast.pg_toast_33953_index" Column | Type | Key? | Definition -----------+---------+------+------------ chunk_id | oid | yes | chunk_id chunk_seq | integer | yes | chunk_seq primary key, btree, for table "pg_toast.pg_toast_33953"</code> </pre><br>  La colonne client utilise la strat√©gie √©tendue: les valeurs qu'elle contient seront compress√©es.  V√©rifier: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> client = repeat(<span class="hljs-string"><span class="hljs-string">'A'</span></span>,<span class="hljs-number"><span class="hljs-number">3000</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">1</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_toast.pg_toast_33953;</code> </pre><pre> <code class="plaintext hljs"> chunk_id | chunk_seq | chunk_data ----------+-----------+------------ (0 rows)</code> </pre><br>  Il n'y a rien dans la table TOAST: les caract√®res r√©p√©titifs sont parfaitement compress√©s et apr√®s cela la valeur tient dans une page de table normale. <br><br>  Maintenant, laissez le nom du client compos√© de caract√®res al√©atoires: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> client = ( <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> string_agg( chr(trunc(<span class="hljs-number"><span class="hljs-number">65</span></span>+random()*<span class="hljs-number"><span class="hljs-number">26</span></span>)::<span class="hljs-type"><span class="hljs-type">integer</span></span>), <span class="hljs-string"><span class="hljs-string">''</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> generate_series(<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">3000</span></span>) ) <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">RETURNING</span></span> left(client,<span class="hljs-number"><span class="hljs-number">10</span></span>) || <span class="hljs-string"><span class="hljs-string">'...'</span></span> || right(client,<span class="hljs-number"><span class="hljs-number">10</span></span>);</code> </pre><pre> <code class="plaintext hljs"> ?column? ------------------------- TCKGKZZSLI...RHQIOLWRRX (1 row)</code> </pre><br>  Cette s√©quence ne peut pas √™tre compress√©e et tombe dans la table TOAST: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> chunk_id, chunk_seq, length(chunk_data), left(encode(chunk_data,<span class="hljs-string"><span class="hljs-string">'escape'</span></span>)::<span class="hljs-type"><span class="hljs-type">text</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>) || <span class="hljs-string"><span class="hljs-string">'...'</span></span> || right(encode(chunk_data,<span class="hljs-string"><span class="hljs-string">'escape'</span></span>)::<span class="hljs-type"><span class="hljs-type">text</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_toast.pg_toast_33953;</code> </pre><pre> <code class="plaintext hljs"> chunk_id | chunk_seq | length | ?column? ----------+-----------+--------+------------------------- 34000 | 0 | 2000 | TCKGKZZSLI...ZIPFLOXDIW 34000 | 1 | 1000 | DDXNNBQQYH...RHQIOLWRRX (2 rows)</code> </pre><br>  Comme vous pouvez le voir, les donn√©es sont d√©coup√©es en fragments de 2000 octets. <br><br>  Lors de l'acc√®s √† une valeur "longue", PostgreSQL automatiquement, transparent pour l'application, restaure la valeur d'origine et la renvoie au client. <br><br>  Bien s√ªr, beaucoup de ressources sont consacr√©es √† la compression en tranches et √† la r√©cup√©ration ult√©rieure.  Par cons√©quent, le stockage de donn√©es volumineuses dans PostgreSQL n'est pas une bonne id√©e, surtout si elles sont activement utilis√©es et qu'aucune logique transactionnelle n'est requise pour elles (par exemple: les originaux scann√©s de documents comptables).  Une alternative plus rentable pourrait √™tre de stocker ces donn√©es sur le syst√®me de fichiers et, dans le SGBD, les noms des fichiers correspondants. <br><br>  Une table TOAST n'est utilis√©e que lorsqu'elle se r√©f√®re √† une valeur ¬´longue¬ª.  De plus, la table toast a son propre versioning: si la mise √† jour des donn√©es n'affecte pas la valeur "longue", la nouvelle version de la ligne se r√©f√©rera √† la m√™me valeur dans la table TOAST - cela √©conomise de l'espace. <br><br>  Notez que TOAST ne fonctionne que pour les tables, mais pas pour les index.  Cela impose une limite sur la taille des cl√©s index√©es. <br><blockquote>  Vous pouvez en savoir plus sur l'organisation des donn√©es internes <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">dans la documentation</a> . <br></blockquote>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">√Ä suivre</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr444536/">https://habr.com/ru/post/fr444536/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr444524/index.html">Lambdas: de C ++ 11 √† C ++ 20. Partie 1</a></li>
<li><a href="../fr444526/index.html">Pile DOTS: C ++ & C #</a></li>
<li><a href="../fr444528/index.html">Situation: le Japon peut limiter le t√©l√©chargement de contenu √† partir du r√©seau - nous comprenons et discutons</a></li>
<li><a href="../fr444530/index.html">L'avenir de l'injection de d√©pendance dans Android</a></li>
<li><a href="../fr444534/index.html">Analyse des vuln√©rabilit√©s et d√©veloppement s√©curis√©. Partie 1</a></li>
<li><a href="../fr444540/index.html">Intel est pr√™t √† commencer la production de m√©moire MRAM</a></li>
<li><a href="../fr444542/index.html">Diffusion en direct et calendrier des conf√©rences pour SmartMail Conf: Machine Learning</a></li>
<li><a href="../fr444544/index.html">Quelque chose au sujet des centres de donn√©es distribu√©s pour les entreprises</a></li>
<li><a href="../fr444546/index.html">Comment et pourquoi travailler plus lentement? La m√©thode de Sergey Korolev</a></li>
<li><a href="../fr444548/index.html">Exp√©rience personnelle: comment nous nous sommes engag√©s dans la promotion de startups hispaniques en Am√©rique latine</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>