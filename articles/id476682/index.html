<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë±üèø üë©üèæ ü§≥üèª Cara menulis pencari ranjau di Phaser dan menjalankan tugas pengujian pengembang HTML5 üèÅ üéüÔ∏è üôå</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Selamat siang, kawan-kawan tercinta! 

 Nama saya Alexander, saya adalah pengembang game HTML5. 

 Di salah satu perusahaan tempat saya mengirimkan re...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Cara menulis pencari ranjau di Phaser dan menjalankan tugas pengujian pengembang HTML5</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/476682/"> Selamat siang, kawan-kawan tercinta! <br><br>  Nama saya Alexander, saya adalah pengembang game HTML5. <br><br>  Di salah satu perusahaan tempat saya mengirimkan resume saya, saya diminta menyelesaikan tugas tes.  Saya setuju dan, setelah 1 hari, dikirim sebagai hasilnya game dikembangkan sesuai dengan TOR HTML5. <br><br><img src="https://habrastorage.org/webt/4t/ng/dn/4tngdnvlxq3izqrpk2nykww2dvs.png"><br><br>  Karena saya berlatih pemrograman game, dan juga untuk penggunaan kode saya yang lebih efisien, saya memutuskan bahwa akan bermanfaat untuk menulis artikel pelatihan tentang proyek yang sudah selesai.  Dan karena tes yang selesai menerima penilaian positif dan mengarah ke undangan untuk wawancara, mungkin keputusan saya memiliki hak untuk eksis dan, mungkin, akan membantu seseorang di masa depan. <br><br>  Artikel ini akan memberikan gambaran tentang jumlah pekerjaan yang cukup untuk berhasil menyelesaikan tugas tes rata-rata untuk posisi HTML5 pengembang.  Materi tersebut mungkin juga menarik bagi siapa saja yang ingin berkenalan dengan kerangka Phaser.  Dan jika Anda sudah bekerja dengan Phaser dan menulis dalam JS - lihat bagaimana mengembangkan proyek di TypeScript. <br><br>  Jadi, di bawah cat ada banyak kode TypeScript! <br><a name="habracut"></a><br><h2>  Pendahuluan </h2><br>  Kami memberikan pernyataan singkat tentang masalahnya. <br><br><ol><li>  Kami akan mengembangkan game HTML5 sederhana - pencari ranjau klasik. </li><li>  Sebagai alat utama kita akan menggunakan phaser 3, naskah dan webpack. </li><li>  Game ini akan dirancang untuk desktop dan dijalankan di browser. </li></ol><br>  Kami menyediakan tautan ke proyek akhir. <br><br><div class="spoiler">  <b class="spoiler_title">Tautan ke demo dan sumber</b> <div class="spoiler_text">  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Demo yang dapat dimainkan</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Kode sumber GitHub</a> <br></div></div><br>  Dan ingat kembali mekanisme mesin pencari ranjau, jika tiba-tiba seseorang lupa aturan mainnya.  Tetapi karena ini adalah kasus yang tidak mungkin, aturan ditempatkan di bawah spoiler :) <br><br><div class="spoiler">  <b class="spoiler_title">Aturan pencari kerja</b> <div class="spoiler_text">  Lapangan bermain terdiri dari sel-sel yang diatur dalam sebuah tabel.  Secara default, saat permainan dimulai, semua sel ditutup.  Bom ditempatkan di beberapa sel. <br><br>  Ketika mengklik kiri pada sel yang tertutup, itu terbuka.  Jika ada bom di sel terbuka, maka pertandingan berakhir dengan kekalahan. <br><br>  Jika tidak ada bom di dalam sel, maka angka ditampilkan di dalamnya, menunjukkan jumlah bom yang berada di sel tetangga relatif terhadap pembukaan saat ini.  Jika tidak ada bom di dekatnya, maka sel itu terlihat kosong. <br><br>  Mengklik kanan pada sel yang tertutup menetapkan bendera di atasnya.  Tugas pemain adalah mengatur semua bendera yang tersedia untuknya sehingga mereka menandai semua sel yang ditambang.  Setelah meletakkan semua bendera, pemain menekan tombol kiri mouse pada salah satu sel yang terbuka untuk memeriksa apakah dia menang. <br></div></div><br>  Selanjutnya, kita langsung menuju manual itu sendiri.  Semua materi dibagi menjadi langkah-langkah kecil, yang masing-masing menggambarkan implementasi tugas tertentu dalam waktu singkat.  Jadi, melakukan gol kecil selangkah demi selangkah, pada akhirnya kami akan membuat game lengkap.  Gunakan daftar isi jika Anda memutuskan untuk dengan cepat pergi ke langkah tertentu. <br><br><div class="spoiler">  <b class="spoiler_title">Daftar isi</b> <div class="spoiler_text">  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">1. Persiapan</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">1.1 Template Proyek</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">1.2 Membangun Konfigurasi</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">1.3 Memasang Modul</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">1.4 Persiapan aset</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">2. Membuat adegan</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">2.1 Titik Masuk</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">2.2 Adegan Mulai</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">2.3 Teks-teks adegan awal</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">2.4 Transisi ke tingkat permainan</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Adegan 2,5 tingkat</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">2.6 Mengatur adegan pada titik masuk</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">3. Objek permainan</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">3.1 Papan permainan</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">3.2 Model Sel</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">3.3 Tampilan Sel</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">3.4 Membuat sprite di kelas tampilan</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">3.5 Posisi Sprite</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">3.6 Membuat instance dari FieldView</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">3.7 bidang papan display.</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">3.8 Membuat bom</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">3.9 Mengatur nilai</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">4. Menangani input event</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">4.1 Pelacakan peristiwa klik mouse</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">4.2.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Pemrosesan klik kiri</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">4.4 Pemrosesan klik kanan</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">4.5 Objek GameSceneView</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">5. Animasi</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">5.1 Animasi isi papan</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">5.2 Animasi Flip Cell</a> <br></div></div><br><a name="section-1"></a><h2>  <font color="#008080">1. Persiapan</font> </h2><br><a name="section-1-1"></a><h3>  <font color="#008080">1.1 Template Proyek</font> </h3><br>  Unduh <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">templat proyek phaser default</a> .  Ini adalah template yang direkomendasikan dari pembuat framework dan ia menawarkan kepada kita struktur direktori berikut: <br><div class="scrollable-table"><table><tbody><tr><td>  index.html </td><td colspan="2">  Halaman HTML meluncurkan game </td></tr><tr><td rowspan="2">  webpack / </td><td>  base.js </td><td>  membangun konfigurasi untuk lingkungan pengujian </td></tr><tr><td>  prod.js </td><td>  membangun konfigurasi untuk produksi </td></tr><tr><td rowspan="2">  src / </td><td>  aset / </td><td>  aset game (sprite, suara, font) </td></tr><tr><td>  index.js </td><td>  titik masuk </td></tr></tbody></table></div> Untuk proyek kami, kami tidak memerlukan file <code>index.js</code> saat ini, jadi hapus saja.  Kemudian buat direktori <code>/src/scripts/</code> dan tempatkan file <code>index.ts</code> kosong di dalamnya.  Kami akan menambahkan semua skrip kami ke folder ini. <br>  Perlu juga diingat bahwa ketika membangun proyek untuk produksi, direktori <code>dist</code> akan dibuat di root, di mana rilis rilis akan ditempatkan. <br><br><a name="section-1-2"></a><h3>  <font color="#008080">1.2 Membangun Konfigurasi</font> </h3><br>  Kami akan menggunakan webpack untuk perakitan.  Karena template kami awalnya disiapkan untuk bekerja dengan JavaScript, dan kami menulis dalam TypeScript, kami perlu membuat perubahan kecil pada konfigurasi kolektor. <br><br>  Dalam file <code>webpack/base.js</code> tambahkan kunci <code>entry</code> yang menunjukkan titik masuk ketika membangun proyek kami, serta konfigurasi <code>ts-loader</code> yang menjelaskan aturan untuk membangun skrip TS: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// webpack/base.js //... module.exports = { entry: './src/scripts/index.ts', // ... resolve: { extensions: [ '.ts', '.tsx', '.js' ] }, module: { rules: [{ test: /\.tsx?$/, use: 'ts-loader', exclude: /node_modules/ }, //...</span></span></code> </pre><br>  Kita juga perlu membuat file tsconfig.json di root proyek.  Bagi saya itu memiliki konten berikut: <br><br><pre> <code class="javascript hljs">{ <span class="hljs-string"><span class="hljs-string">"compilerOptions"</span></span>: { <span class="hljs-string"><span class="hljs-string">"module"</span></span>: <span class="hljs-string"><span class="hljs-string">"commonjs"</span></span>, <span class="hljs-string"><span class="hljs-string">"lib"</span></span>: [ <span class="hljs-string"><span class="hljs-string">"dom"</span></span>, <span class="hljs-string"><span class="hljs-string">"es5"</span></span>, <span class="hljs-string"><span class="hljs-string">"es6"</span></span>, <span class="hljs-string"><span class="hljs-string">"es2015"</span></span>, <span class="hljs-string"><span class="hljs-string">"es2017"</span></span>, <span class="hljs-string"><span class="hljs-string">"es2015.promise"</span></span> ], <span class="hljs-string"><span class="hljs-string">"target"</span></span>: <span class="hljs-string"><span class="hljs-string">"es5"</span></span>, <span class="hljs-string"><span class="hljs-string">"skipLibCheck"</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span> }, <span class="hljs-string"><span class="hljs-string">"exclude"</span></span>: [<span class="hljs-string"><span class="hljs-string">"node_modules"</span></span>, <span class="hljs-string"><span class="hljs-string">"dist"</span></span>] }</code> </pre> <br><a name="section-1-3"></a><h3>  <font color="#008080">1.3 Memasang Modul</font> </h3><br>  Instal semua dependensi dari package.json dan tambahkan modul skrip dan ts-loader ke dalamnya: <br><br><pre> <code class="plaintext hljs">npm i npm i typescript --save-dev npm i ts-loader --save-dev</code> </pre><br>  Sekarang proyek siap untuk memulai pengembangan.  Kami memiliki 2 perintah yang kami miliki yang sudah ditentukan dalam properti <code>scripts</code> di file <code>package.json</code> . <br><br><ol><li>  Bangun proyek untuk debugging dan buka di browser melalui server lokal <br><br><pre> <code class="plaintext hljs">npm start</code> </pre> </li><li>  Jalankan build untuk dijual dan letakkan build rilis di dist / folder <br><br><pre> <code class="plaintext hljs">npm run build</code> </pre> </li></ol><br><a name="section-1-4"></a><h3>  <font color="#008080">1.4 Persiapan aset</font> </h3><br>  Semua aset untuk game ini diunduh dengan jujur ‚Äã‚Äãdari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">OpenGameArt</a> (versi 61x61) dan memiliki lisensi yang ramah yang disebut <i>Jangan ragu untuk digunakan</i> , yang diceritakan oleh laman dengan paket tersebut dengan cermat).  Omong-omong, kode yang disajikan dalam artikel memiliki lisensi yang sama!  ;) <br><br>  Saya menghapus gambar jam dari set yang diunduh, dan mengganti nama sisa file sehingga mendapatkan nama bingkai yang mudah digunakan.  Daftar nama dan file yang sesuai ditampilkan pada layar di bawah ini. <br><br>  Dari sprite yang dihasilkan, kita akan membuat atlas format <code>Phaser JSONArray</code> dalam program <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">TexturePacker</a> (ada lebih dari cukup versi gratis, saya belum mendapatkan pekerjaan) dan meletakkan file <code>spritesheet.json</code> dan <code>spritesheet.json</code> di direktori <code>src/assets/</code> project. <br><br><img src="https://habrastorage.org/webt/ms/ki/z9/mskiz9zmuidbxk8hhcbksfmny4k.png"><br><br><a name="section-2"></a><h2>  <font color="#008080">2. Membuat adegan</font> </h2><br><a name="section-2-1"></a><h3>  <font color="#008080">2.1 Titik Masuk</font> </h3><br>  Kami memulai pengembangan dengan membuat titik masuk yang dijelaskan dalam konfigurasi webpack. <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// src/scripts/index.ts import * as Phaser from "phaser"; new Phaser.Game({ type: Phaser.AUTO, parent: "minesweeper", width: window.innerWidth, height: window.innerHeight, backgroundColor: "#F0FFFF", scene: [] });</span></span></code> </pre><br>  Karena permainan yang kami miliki dirancang untuk desktop dan akan memenuhi seluruh layar, kami dengan berani menggunakan seluruh lebar dan tinggi browser untuk bidang <code>width</code> dan <code>height</code> . <br>  Bidang <code>scene</code> saat ini adalah array kosong dan kami akan memperbaikinya! <br><br><a name="section-2-2"></a><h3>  <font color="#008080">2.2 Adegan Mulai</font> </h3><br>  Buat kelas adegan pertama dalam file <code>src/scripts/scenes/StartScene.ts</code> : <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">StartScene</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Phaser</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Scene</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>(<span class="hljs-string"><span class="hljs-string">'Start'</span></span>); } public preload(): <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> { } public create(): <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> { } }</code> </pre><br>  Untuk warisan <code>Phaser.Scene</code> valid <code>Phaser.Scene</code> kami meneruskan nama adegan sebagai parameter ke konstruktor dari kelas induk. <br><br>  Adegan ini akan menggabungkan fungsionalitas preloading sumber daya dan layar mulai, mengundang pengguna ke permainan. <br><br>  Biasanya dalam proyek saya seorang pemain melewati dua adegan sebelum ia sampai ke yang mulai, dalam urutan ini: <br><br><pre> <code class="plaintext hljs">Boot =&gt; Preload =&gt; Start</code> </pre><br>  Tetapi dalam kasus ini, gim ini sangat sederhana, dan ada sangat sedikit aset sehingga tidak ada alasan untuk memasukkan preload ke adegan terpisah dan terlebih lagi untuk melakukan <code>Boot</code> loader terpisah awal. <br><br>  Kami akan memuat semua aset dalam metode <code>preload</code> .  Agar dapat bekerja dengan atlas yang dibuat di masa mendatang, kita perlu melakukan 2 langkah: <br><br><ol><li>  mendapatkan kedua file <code>png</code> dan <code>json</code> atlas menggunakan <code>require</code> : <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// StartScene.ts const spritesheetPng = require("./../../assets/spritesheet.png"); const spritesheetJson = require("./../../assets/spritesheet.json"); // ...</span></span></code> </pre><br></li><li>  memuatnya dalam metode <code>preload</code> adegan awal: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// StartScene.ts // ... public preload(): void { this.load.atlas("spritesheet", spritesheetPng, spritesheetJson); } // ...</span></span></code> </pre><br></li></ol><br><a name="section-2-3"></a><h3>  <font color="#008080">2.3 Teks-teks adegan awal</font> </h3><br>  Ada 2 hal yang harus dilakukan di adegan awal: <br><br><ol><li>  beri tahu pemain cara memulai permainan </li><li>  memulai permainan atas inisiatif pemain </li></ol><br>  Untuk memenuhi poin pertama, pertama-tama kita membuat dua enumerasi di awal file adegan untuk menjelaskan teks dan gaya mereka: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// StartScene.js enum Texts { Title = 'Minesweeper HTML5', Message = 'Click anywhere to start' } enum Styles { Color = '#008080', Font = 'Arial' } //...</span></span></code> </pre><br>  Dan kemudian buat kedua teks sebagai objek dalam metode <code>create</code> .  Biarkan saya mengingatkan Anda bahwa metode <code>create</code> adegan di <code>Phaser</code> akan dipanggil hanya setelah memuat semua sumber daya dalam metode <code>preload</code> dan ini sangat cocok untuk kami. <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// StartScene.js //... public create(): void { this.add.text( this.cameras.main.centerX, this.cameras.main.centerY - 100, Texts.Title, {font: `52px ${Styles.Font}`, fill: Styles.Color}) .setOrigin(0.5); this.add.text( this.cameras.main.centerX, this.cameras.main.centerY + 100, Texts.Message, {font: `28px ${Styles.Font}`, fill: Styles.Color}) .setOrigin(0.5); } //...</span></span></code> </pre><br>  Dalam proyek lain yang lebih besar, kita dapat mengambil teks dan gaya ke dalam file lokal json atau ke konfigurasi terpisah, tetapi mengingat bahwa kita sekarang hanya memiliki 2 baris, saya menganggap langkah ini berlebihan dan dalam hal ini saya sarankan tidak menyulitkan hidup kita, membatasi diri pada daftar di awal file adegan. <br><br><a name="section-2-4"></a><h3>  <font color="#008080">2.4 Transisi ke tingkat permainan</font> </h3><br>  Hal terakhir yang akan kita lakukan dalam adegan ini sebelum melanjutkan adalah melacak acara klik mouse untuk meluncurkan pemain ke dalam permainan: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// StartScene.js //... public create(): void { //... this.input.once('pointerdown', () =&gt; { this.scene.start('Game'); }); } //...</span></span></code> </pre> <br><a name="section-2-5"></a><h3>  <font color="#008080">Adegan 2,5 tingkat</font> </h3><br>  Menilai oleh parameter <code>"Game"</code> diteruskan ke metode <code>this.scene.start</code> Anda sudah menduga bahwa sudah waktunya untuk membuat adegan kedua, yang akan memproses logika permainan utama.  Buat file <code>src/scripts/scenes/GameScene.ts</code> : <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">GameScene</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Phaser</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Scene</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>(<span class="hljs-string"><span class="hljs-string">'Game'</span></span>); } public create(): <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> { } }</code> </pre><br>  Dalam adegan ini, kita tidak perlu metode <code>preload</code> , karena  kami telah memuat semua sumber daya yang diperlukan dalam adegan sebelumnya. <br><br><a name="section-2-6"></a><h3>  <font color="#008080">2.6 Mengatur adegan pada titik masuk</font> </h3><br>  Sekarang setelah kedua adegan dibuat, tambahkan mereka ke titik masuk kami <br>  <code>src/scripts/index.ts</code> : <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//... import { StartScene } from "./scenes/StartScene"; import { GameScene } from "./scenes/GameScene"; //... new Phaser.Game({ // ... scene: [StartScene, GameScene] });</span></span></code> </pre><br><a name="section-3"></a><h2>  <font color="#008080">3. Objek permainan</font> </h2><br>  Jadi, kelas <code>GameScene</code> akan mengimplementasikan logika tingkat permainan.  Dan apa yang kita harapkan dari level game pencari ranjau?  Secara visual, kami berharap melihat lapangan bermain dengan sel tertutup.  Kita tahu bahwa lapangan adalah sebuah tabel, yang berarti memiliki sejumlah baris dan kolom tertentu, di mana beberapa bom ditempatkan dengan nyaman.  Dengan demikian, kami memiliki informasi yang cukup untuk membuat entitas terpisah yang menjelaskan bidang permainan. <br><br><a name="section-3-1"></a><h3>  <font color="#008080">3.1 Papan permainan</font> </h3><br>  Buat file <code>src/scripts/models/Board.ts</code> mana kita menempatkan kelas <code>Board</code> : <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { Field } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"./Field"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Board</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Phaser</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Events</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">EventEmitter</span></span></span><span class="hljs-class"> </span></span>{ private _scene: Phaser.Scene = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; private _rows: number = <span class="hljs-number"><span class="hljs-number">0</span></span>; private _cols: number = <span class="hljs-number"><span class="hljs-number">0</span></span>; private _bombs: number = <span class="hljs-number"><span class="hljs-number">0</span></span>; private _fields: Field[] = []; <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(scene: Phaser.Scene, rows: number, cols: number, bombs: number) { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>(); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._scene = scene; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._rows = rows; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._cols = cols; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._bombs = bombs; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._fields = []; } public get cols(): number { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._cols; } public get rows(): number { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._rows; } }</code> </pre> <br>  Mari kita buat kelas sebagai penerus Phaser.Events.EventEmitter untuk mengakses antarmuka untuk mendaftarkan dan memanggil acara, yang akan kita butuhkan di masa depan. <br><br>  Array objek dari kelas <code>Field</code> akan disimpan di properti pribadi <code>_fields</code> .  Kami akan mengimplementasikan model ini nanti. <br><br>  Kami menyiapkan properti numerik pribadi <code>_rows</code> dan <code>_cols</code> untuk menunjukkan jumlah baris dan kolom bidang bermain.  Buat getter publik untuk membaca <code>_rows</code> dan <code>_cols</code> . <br><br>  Bidang <code>_bombs</code> memberi tahu kita jumlah bom yang perlu dihasilkan untuk level tersebut.  Dan dalam parameter <code>_scene</code> kami meneruskan referensi ke objek adegan game <code>GameScene</code> , di mana kami akan membuat turunan dari kelas <code>Board</code> . <br><br>  Perlu dicatat bahwa kami mentransfer objek adegan ke model hanya untuk transmisi lebih lanjut ke tampilan, di mana kami akan menggunakannya hanya untuk menampilkan tampilan.  Faktanya adalah phaser secara langsung menggunakan objek adegan untuk membuat sprite dan karenanya mengharuskan kita untuk memberikan tautan ke adegan saat ini ketika membuat prefab sprite, yang akan kita kembangkan di masa depan.  Dan bagi kami sendiri, kami akan menerima perjanjian bahwa kami mentransfer tautan ke tempat kejadian hanya untuk penggunaan lebih lanjut sebagai mesin pajangan dan setuju bahwa kami tidak akan secara langsung memanggil metode khusus tempat kejadian dalam model dan tampilan. <br><br>  Setelah kami memutuskan antarmuka pembuatan papan, saya mengusulkan untuk menginisialisasi di adegan level, menyelesaikan kelas <code>GameScene</code> : <br><br><pre> <code class="javascript hljs"> <span class="hljs-comment"><span class="hljs-comment">// GameScene.ts import { Board } from "../models/Board"; const Rows = 8; const Cols = 8; const Bombs = 8; export class GameScene extends Phaser.Scene { private _board: Board = null; //... public create(): void { this._board = new Board(this, Rows, Cols, Bombs); } }</span></span></code> </pre> <br>  Kami mengambil parameter papan ke konstanta di awal file adegan dan meneruskannya ke konstruktor papan saat membuat turunan dari kelas ini. <br><br><a name="section-3-2"></a><h3>  <font color="#008080">3.2 Model Sel</font> </h3><br>  Papan terdiri dari sel, yang ingin Anda tampilkan di layar.  Setiap sel harus ditempatkan di posisi yang sesuai, ditentukan oleh baris dan kolom. <br><br>  Sel juga dipilih sebagai entitas terpisah.  Buat file <code>src/scripts/models/Field.ts</code> di mana kita akan menempatkan kelas yang menjelaskan sel: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { Board } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"./Board"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Field</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Phaser</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Events</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">EventEmitter</span></span></span><span class="hljs-class"> </span></span>{ private _scene: Phaser.Scene = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; private _board: Board = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; private _row: number = <span class="hljs-number"><span class="hljs-number">0</span></span>; private _col: number = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(scene: Phaser.Scene, board: Board, row: number, col: number) { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>(); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._init(scene, board, row, col); } public get col(): number { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._col; } public get row(): number { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._row; } public get board(): Board { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._board; } private _init(scene: Phaser.Scene, <span class="hljs-attr"><span class="hljs-attr">board</span></span>: Board, <span class="hljs-attr"><span class="hljs-attr">row</span></span>: number, <span class="hljs-attr"><span class="hljs-attr">col</span></span>: number): <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._scene = scene; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._board = board; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._row = row; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._col = col; } }</code> </pre><br>  Setiap sel harus memiliki metrik baris dan kolom di mana ia berada.  Kami mengatur parameter <code>_board</code> dan <code>_scene</code> untuk mengatur tautan ke objek papan dan tempat kejadian.  Kami menerapkan getter untuk membaca bidang <code>_row</code> , <code>_col</code> dan <code>_board</code> . <br><br><a name="section-3-3"></a><h3>  <font color="#008080">3.3 Tampilan Sel</font> </h3><br>  Sel abstrak dibuat dan sekarang kami ingin memvisualisasikannya.  Untuk menampilkan sel di layar, Anda harus membuat tampilan.  Buat file <code>src/scripts/views/FieldView.ts</code> dan letakkan kelas view di dalamnya: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { Field } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"../models/Field"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FieldView</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Phaser</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">GameObjects</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Sprite</span></span></span><span class="hljs-class"> </span></span>{ private _model: Field = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(scene: Phaser.Scene, model: Field) { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>(scene, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-string"><span class="hljs-string">'spritesheet'</span></span>, <span class="hljs-string"><span class="hljs-string">'closed'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._model = model; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._init(); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._create(); } private _init(): <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> { } private _create(): <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> { } }</code> </pre><br>  Harap dicatat bahwa kami menjadikan kelas ini keturunan <code>Phaser.GameObjects.Sprite</code> .  Dalam istilah phaser, kelas ini telah menjadi prefab sprite.  Artinya, saya mendapatkan fungsionalitas objek game dari sprite, yang akan kami kembangkan lebih lanjut dengan metode kami sendiri. <br><br>  Mari kita lihat konstruktor dari kelas ini.  Di sini, pertama-tama, kita harus memanggil konstruktor dari kelas induk dengan set parameter berikut: <br><br><ul><li>  tautan ke objek adegan (seperti yang saya peringatkan pada bagian 3.1: phaser mengharuskan kita untuk menautkan ke adegan saat ini untuk membuat sprite) </li><li>  koordinat <code>x</code> dan <code>y</code> atas kanvas </li><li>  kunci string yang tersedia untuk atlas, yang kami muat dalam metode <code>preload</code> dari adegan awal </li><li>  kunci bingkai kunci di atlas ini yang ingin Anda pilih untuk menampilkan sprite </li></ul><br>  Tetapkan referensi ke model (yaitu, instance dari kelas <code>Field</code> ) di properti <code>_model</code> pribadi. <br><br>  Kami juga dengan bijaksana memulai 2 <code>_create</code> dan <code>_init</code> kosong saat ini, yang akan kami implementasikan nanti. <br><br><a name="section-3-4"></a><h3>  <font color="#008080">3.4 Membuat sprite di kelas tampilan</font> </h3><br>  Jadi, pemandangan telah dibuat, tetapi dia masih tidak tahu cara menggambar sprite.  Untuk menempatkan sprite dengan bingkai yang kita butuhkan di kanvas, Anda perlu memodifikasi metode <code>_create</code> pribadi kita sendiri: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// FieldView.js //... private _create(): void { this.scene.add.existing(this); //      this.setOrigin(0.5); //  pivot point    } //...</span></span></code> </pre><br><a name="section-3-5"></a><h3>  <font color="#008080">3.5 Posisi Sprite</font> </h3><br>  Saat ini, semua sprite yang dibuat akan ditempatkan di koordinat (0, 0) kanvas.  Kita juga perlu menempatkan setiap sel di posisi yang sesuai di papan tulis.  Yaitu, ke tempat yang sesuai dengan baris dan kolom sel ini.  Untuk melakukan ini, kita perlu menulis kode untuk menghitung koordinat setiap instance dari kelas <code>FieldView</code> . <br><br>  Tambahkan properti <code>_position</code> ke kelas, yang bertanggung jawab untuk koordinat akhir sel di lapangan bermain: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// FieldView.ts //... interface Vec2 {x: number, y: number}; export class FieldView extends Phaser.GameObjects.Sprite { private _position: Vec2 = {x: 0, y: 0}; //...</span></span></code> </pre><br>  Karena kami ingin menyelaraskan papan, dan sesuai dengan sel di dalamnya, relatif terhadap bagian tengah layar, kami juga memerlukan properti <code>_offset</code> , yang menunjukkan offset sel khusus ini relatif ke tepi kiri dan atas layar.  Tambahkan dengan pengambil pribadi: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// FieldView.ts //... private get _offset(): Vec2 { return { x: (this.scene.cameras.main.width - this._model.board.cols * this.width) / 2, y: (this.scene.cameras.main.height - this._model.board.rows * this.height) / 2 }; } //...</span></span></code> </pre><br>  Jadi, kami: <br><br><ol><li>  Dapatkan total lebar layar di <code>this._scene.cameras.main.width</code> . </li><li>  Kami mendapatkan total lebar papan dengan mengalikan jumlah sel dengan lebar satu sel: <code>this._board.cols * this.width</code> . </li><li>  Mengambil lebar papan dari lebar layar, kami mendapat tempat di layar, tidak ditempati oleh papan. </li><li>  Membagi angka yang dihasilkan dengan 2, kami mendapat nilai indentasi di kiri dan kanan papan. </li><li>  Dengan menggeser setiap sel dengan nilai indentasi ini, kami menjamin keselarasan seluruh papan sepanjang sumbu <code>x</code> . </li></ol><br>  Kami melakukan tindakan yang sangat mirip untuk mendapatkan perpindahan vertikal. <br><br>  Tetap menambahkan kode yang diperlukan dalam metode <code>_init</code> : <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// FieldView.ts // ... private _init(): void { const offset = this._offset; this.x = this._position.x = offset.x + this.width * this._model.col + this.width / 2; this.y = this._position.y = offset.y + this.height * this._model.row + this.height / 2; } // ...</span></span></code> </pre><br>  Properti <code>this.x</code> , <code>this.y</code> , <code>this.width</code> dan <code>this.height</code> sini adalah properti yang diwarisi dari kelas induk <code>Phaser.GameObjects.Sprite</code> .  Mengubah properti <code>this.x</code> dan <code>this.y</code> mengarah ke posisi sprite yang benar pada kanvas. <br><br><a name="section-3-6"></a><h3>  <font color="#008080">3.6 Membuat instance dari FieldView</font> </h3><br>  Buat tampilan di kelas <code>Field</code> : <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// Field.ts // ... private _view: FieldView = null; public get view(): FieldView { return this._view; } private _init(scene: Phaser.Scene, board: Board, row: number, col: number): void { //... this._view = new FieldView(this._scene, this); } // ...</span></span></code> </pre><br><a name="section-3-7"></a><h3>  <font color="#008080">3.7 bidang papan display.</font> </h3><br>  Mari kita kembali ke kelas <code>Board</code> , yang pada dasarnya adalah kumpulan objek <code>Field</code> dan akan membuat sel. <br><br>  Kami akan mengeluarkan kode pembuatan papan ke metode <code>_create</code> terpisah dan memanggil metode ini dari konstruktor.  Mengetahui bahwa dalam metode <code>_create</code> kita tidak hanya akan membuat sel, kita akan mengeluarkan kode untuk membuat sel dalam metode <code>_createFields</code> terpisah. <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// Board.ts constructor(scene: Phaser.Scene, rows: number, cols: number, bombs: number) { // ... this._create(); } private _create(): void { this._createFields(); } private _createFields(): void { }</span></span></code> </pre><br>  Dalam metode ini kita akan membuat jumlah sel yang diinginkan dalam loop bersarang: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// Board.ts // ... private _createFields(): void { for (let row = 0; row &lt; this._rows; row++) { for (let col = 0; col &lt; this._cols; col++) { this._fields.push(new Field(this._scene, this, row, col)); } } } //...</span></span></code> </pre><br>  Sudah waktunya untuk pertama kalinya menjalankan perakitan untuk debugging dengan perintah <br><br><pre> <code class="plaintext hljs">npm start</code> </pre> <br>  Pastikan bahwa di tengah layar kita diharapkan melihat 64 sel dalam 8 baris. <br><br><a name="section-3-8"></a><h3>  <font color="#008080">3.8 Membuat bom</font> </h3><br>  Sebelumnya, saya melaporkan bahwa dalam metode <code>_create</code> dari kelas <code>Board</code> , kami tidak hanya akan membuat bidang.  Apa lagi  Juga akan ada pembuatan bom, dan pengaturan sel yang dibuat dengan jumlah bom tetangga.  Mari kita mulai dengan bomnya sendiri. <br><br>  Kita perlu menempatkan bom N di papan dalam sel acak.  Kami menjelaskan proses pembuatan bom dengan algoritma perkiraan: <br><br><pre> <code class="plaintext hljs">                        </code> </pre><br>  Pada setiap iterasi dari loop, kita akan mendapatkan sel acak dari properti <code>this._fields</code> hingga kita membuat bom sebanyak yang ditunjukkan dalam bidang <code>this._bombs</code> ,.  Jika sel yang diterima kosong, maka kami akan memasang bom di dalamnya dan memperbarui penghitung bom yang diperlukan untuk pembangkitan. <br><br>  Untuk menghasilkan angka acak, kami menggunakan metode statis <code>Phaser.Math.Between</code> . <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// Board.ts //... private _createBombs(): void { let count = this._bombs; //      while (count &gt; 0) { //       let field = this._fields[Phaser.Math.Between(0, this._fields.length - 1)]; //    if (field.empty) { //     field.setBomb(); //     --count; //    } } }</span></span></code> </pre><br>  Jangan lupa untuk menulis panggilan ke <code>this._createBombs();</code> di file <code>Board.ts</code> <code>this._createBombs();</code>  di akhir metode <code>_create</code> <br><br>  Seperti yang sudah Anda perhatikan, agar kode ini berfungsi dengan benar, Anda perlu memperbaiki kelas <code>Field</code> dengan menambahkan pengambil <code>empty</code> dan metode <code>setBomb</code> ke <code>setBomb</code> . <br><br>  Tambahkan bidang <code>_value</code> pribadi ke <code>_value</code> bidang, yang akan mengatur konten sel.  Kami menerima perjanjian berikut. <br><div class="scrollable-table"><table><tbody><tr><td>  <code>_value</code> === 0 </td><td>  sel kosong dan tidak ada tambang atau nilai di dalamnya </td></tr><tr><td>  <code>_value</code> === -1 </td><td>  ada tambang di sel </td></tr><tr><td>  <code>_value</code> &gt; 0 </td><td>  dalam sel adalah jumlah tambang yang terletak di sebelah sel saat ini </td></tr></tbody></table></div><br>  Mengikuti aturan-aturan ini, kami akan mengembangkan metode di kelas <code>Field</code> yang bekerja dengan properti <code>_value</code> : <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// Field.ts // ... private _value: number = 0; // ... public get value(): number { return this._value; } public set value(value) { this._value = value; } public get empty(): boolean { return this._value === 0; } public get mined(): boolean { return this._value === -1; } public get filled(): boolean { return this._value &gt; 0; } public setBomb(): void { this._value = -1; } // ...</span></span></code> </pre><br><a name="section-3-9"></a><h3>  <font color="#008080">3.9 Mengatur nilai</font> </h3><br>  Bom diatur dan sekarang kami memiliki semua data untuk mengatur nilai numerik di semua sel yang membutuhkannya. <br><br>  Biarkan saya mengingatkan Anda bahwa menurut aturan pencari ranjau, sel harus memiliki nomor yang sesuai dengan jumlah bom yang terletak di sebelah sel ini.  Berdasarkan aturan ini, kami menulis pseudocode yang sesuai. <br><br><pre> <code class="plaintext hljs">                  </code> </pre><br>  Di kelas <code>Board</code> , buat metode baru dan terjemahkan pseudocode yang ditentukan ke dalam kode nyata: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// Board.ts //... private _createValues() { //      this._fields.forEach(field =&gt; { //      if (field.mined) { //     field.getClosestFields().forEach(item =&gt; { //      if (item.value &gt;= 0) { ++item.value; } }); } }); } //...</span></span></code> </pre><br>  Mari kita lihat antarmuka mana yang kita gunakan yang tidak diimplementasikan.  Anda perlu menambahkan metode <code>getClosestFields</code> untuk mendapatkan sel tetangga. <br><br>  Bagaimana cara mengidentifikasi sel tetangga? <br><br>  Sebagai contoh, perhatikan setiap sel papan yang tidak ada di tepi, yaitu, tidak di baris yang ekstrim dan tidak di kolom yang ekstrim.  Sel-sel tersebut memiliki jumlah tetangga maksimum: 1 di atas, 1 di bawah, 3 di sebelah kiri dan 3 di sebelah kanan (termasuk sel di diagonal). <br><br>  Dengan demikian, dalam setiap sel tetangga, indikator <code>_row</code> dan <code>_col</code> tidak berbeda lebih dari 1. Ini berarti bahwa kita dapat menentukan terlebih dahulu perbedaan antara parameter <code>_row</code> dan <code>_col</code> dengan bidang saat ini.  Tambahkan konstanta di awal file ke deskripsi kelas: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// Field.ts const Positions = [ {row : 0, col : 1}, //  {row : 0, col : -1}, //  {row : 1, col : 0}, //  {row : 1, col : 1}, //   {row : 1, col : -1}, //   {row : -1, col : 0}, //  {row : -1, col : 1}, //   {row : -1, col : -1} //   ]; //...</span></span></code> </pre><br>  Dan sekarang kita bisa menambahkan metode yang hilang, di mana kita akan mengulang melalui array ini: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// Field.ts //... public getClosestFields(): Field[] { let results = []; //      Positions.forEach(position =&gt; { //      let field = this._board.getField(this._row + position.row, this._col + position.col); //       if (field) { //     results.push(field); } }); return results; }; //...</span></span></code> </pre><br>  Jangan lupa untuk memeriksa variabel <code>field</code> pada setiap iterasi, karena tidak semua sel di papan memiliki 8 tetangga.  Misalnya, sel kiri atas tidak akan memiliki tetangga di sebelah kirinya, dan seterusnya. <br><br>  Tetap menerapkan metode <code>getField</code> dan menambahkan semua panggilan yang diperlukan ke metode <code>_create</code> di kelas <code>Board</code> <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// Board.ts //... public getField(row: number, col: number): Field { return this._fields.find(field =&gt; field.row === row &amp;&amp; field.col === col); } //... private _create(): void { this._createFields(); this._createBombs(); this._createValues(); } //...</span></span></code> </pre><br><a name="section-4"></a><h2> <font color="#008080"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4. Menangani input event</font></font></font> </h2><br><a name="section-4-1"></a><h3> <font color="#008080"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4.1 Pelacakan peristiwa klik mouse</font></font></font> </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Saat ini, papan benar-benar diinisialisasi, memiliki bom dan ada sel dengan angka, tetapi semuanya saat ini ditutup dan tidak ada cara untuk membukanya. </font><font style="vertical-align: inherit;">Kami akan memperbaiki ini dan menerapkan pembukaan sel dengan mengklik tombol kiri mouse. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pertama, kita perlu melacak klik ini. </font><font style="vertical-align: inherit;">Di kelas, </font></font><code>FieldView</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tambahkan </font></font><code>_create</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">kode berikut </font><font style="vertical-align: inherit;">ke bagian paling akhir metode </font><font style="vertical-align: inherit;">:</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// FielView.ts //... private _create(): void { // ... this.setInteractive(); } //...</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Di phaser, Anda dapat berlangganan objek dari namespace untuk berbagai aktivitas </font></font><code>Phaser.GameObjects</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Secara khusus, kami akan berlangganan acara klik ( </font></font><code>pointerdown</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) cetakan dari sprite itu sendiri, yaitu objek dari kelas yang </font></font><code>FieldView</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">diwarisi </font></font><code>Phaser.GameObjects.Sprite</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tetapi sebelum kita melakukan ini, kita harus secara eksplisit menunjukkan bahwa sprite berpotensi interaktif, yaitu, Anda umumnya perlu mendengarkan input pengguna di dalamnya. Anda perlu melakukan ini dengan memanggil metode </font></font><code>setInteractive</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tanpa parameter pada sprite itu sendiri, yang kami lakukan pada contoh di atas. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sekarang sprite telah menjadi interaktif, kita akan kembali ke kelas </font></font><code>Board</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">di tempat objek model baru dibuat </font></font><code>Field</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, yaitu metode </font></font><code>_createFields</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dan mendaftarkan panggilan balik untuk peristiwa input untuk tampilan:</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// Board.ts //... private _createFields(): void { for (let row = 0; row &lt; this._rows; row++) { for (let col = 0; col &lt; this._cols; col++) { const field = new Field(this._scene, this, row, col) field.view.on('pointerdown', this._onFieldClick.bind(this, field)); this._fields.push(field); } } } //...</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Setelah kami menetapkan bahwa dengan mengklik sprite kami ingin menjalankan metode </font></font><code>_onFieldClick</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, kami perlu mengimplementasikannya. Tetapi kami akan menghapus logika pemrosesan klik dari kelas </font></font><code>Board</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Ada pendapat bahwa lebih baik memproses model tergantung pada input dan karenanya mengubah datanya dalam pengontrol terpisah, kesamaan yang kami miliki adalah kelas adegan permainan </font></font><code>GameScene</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Jadi, kita perlu meneruskan acara klik lebih lanjut, dari kelas </font></font><code>Board</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ke adegan itu sendiri. Jadi kita akan melakukan:</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// Board.ts //... private _onFieldClick(field: Field, pointer: Phaser.Input.Pointer): void { if (pointer.leftButtonDown()) { this.emit(`left-click`, field); } else if (pointer.rightButtonDown()) { this.emit(`right-click`, field); } } //...</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Di sini kita tidak hanya melempar acara klik seperti sebelumnya, tetapi juga menentukan klik mana yang sebenarnya. </font><font style="vertical-align: inherit;">Ini akan berguna di masa depan, ketika di kelas adegan kami akan memproses setiap opsi secara berbeda. </font><font style="vertical-align: inherit;">Tentu saja, akan mungkin untuk mengirim acara klik sebagaimana adanya, tetapi kami akan menyederhanakan kode adegan, meninggalkan beberapa logika mengenai acara itu sendiri di kelas </font></font><code>Field</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nah, sekarang mari kita kembali ke kelas adegan permainan </font></font><code>GameScene</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dan menambahkan </font></font><code>_create</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">kode </font><font style="vertical-align: inherit;">di akhir metode </font><font style="vertical-align: inherit;">yang melacak peristiwa klik pada sel:</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// Board.ts //... import { Field } from "../models/Field"; //... public create(): void { this._board = new Board(this, Rows, Cols, Bombs); this._board.on('left-click', this._onFieldClickLeft, this); this._board.on('right-click', this._onFieldClickRight, this); } private _onFieldClickLeft(field: Field): void { } private _onFieldClickRight(field: Field): void { } //...</span></span></code> </pre><br><a name="section-4-2"></a><h3> <font color="#008080"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4.2. </font><font style="vertical-align: inherit;">Pemrosesan klik kiri</font></font></font> </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kami terus menerapkan pemrosesan peristiwa klik mouse. </font><font style="vertical-align: inherit;">Dan mulailah dengan membuka sel. </font><font style="vertical-align: inherit;">Sel harus dibuka dengan menekan tombol kiri. </font><font style="vertical-align: inherit;">Dan sebelum kita memulai pemrograman, mari kita menyuarakan kondisi yang harus dipenuhi:</font></font><br><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ketika mengklik sel yang tertutup, itu harus dibuka </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> jika ada tambang di sel terbuka - permainan hilang </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> jika tidak ada ranjau atau nilai di sel terbuka, maka min tidak di sel tetangga, dalam hal ini Anda perlu membuka semua sel tetangga dan terus melakukannya sampai nilai muncul di sel terbuka </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ketika Anda mengklik pada sel terbuka, Anda harus memeriksa apakah semua bendera diatur dengan benar dan jika demikian, maka akhiri permainan dengan kemenangan </font></font></li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Dan sekarang, untuk menyederhanakan pemahaman fungsionalitas yang diperlukan, kami menerjemahkan logika di atas ke dalam pseudo-code: </font></font><br><br><pre> <code class="plaintext hljs">                         </code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sekarang kami memiliki pemahaman tentang apa yang perlu diprogram. </font><font style="vertical-align: inherit;">Kami menerapkan metode ini </font></font><code>_onFieldClickLeft</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// GameScene.ts //... private _onFieldClickLeft(field: Field): void { if (field.closed) { //    field.open(); //   if (field.mined) { //    field.exploded = true; this._onGameOver(false); //   } else if (field.empty) { //    this._board.openClosestFields(field); //   } } else if (field.opened) { //    if (this._board.completed) { //       this._onGameOver(true); //   } } } //...</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dan kemudian, seperti biasa, kita akan menyelesaikan kelas-kelas </font></font><code>Field</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dan </font></font><code>Board</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mengimplementasikan metode-metode di dalamnya yang kita panggil di handler. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kami menunjukkan 3 kemungkinan status sel dalam enumerasi </font></font><code>States</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, menambahkan bidang, </font></font><code>_state</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dan menerapkan pengambil untuk setiap kemungkinan kondisi:</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// Field.ts enum States { Closed = 'closed', Opened = 'opened', Marked = 'flag' }; export class Field extends Phaser.Events.EventEmitter { private _state: string = States.Closed; //... public get marked(): boolean { return this._state === States.Marked; } public get closed(): boolean { return this._state === States.Closed; } public get opened(): boolean { return this._state === States.Opened; } //...</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sekarang kita memiliki status yang menunjukkan apakah sel ditutup atau tidak, kita dapat menambahkan metode </font></font><code>open</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">yang akan mengubah status:</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// Field.ts //... public open(): void { this._setState(States.Opened); } private _setState(state: string): void { if (this._state !== state) { this._state = state; this.emit('change'); } } //...</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Setiap perubahan dalam keadaan model harus memicu peristiwa yang melaporkan hal ini. </font><font style="vertical-align: inherit;">Oleh karena itu, kami memperkenalkan metode pribadi tambahan </font></font><code>_setState</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">di mana seluruh logika perubahan negara akan diimplementasikan. </font><font style="vertical-align: inherit;">Metode ini akan dipanggil dalam semua metode publik model, yang harus mengubah kondisinya. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tambahkan bendera Boolean </font></font><code>_exploded</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">untuk secara eksplisit menunjukkan objek bidang yang diledakkan:</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// Field.ts private _exploded: boolean = false; //... public set exploded(exploded: boolean) { this._exploded = exploded; this.emit('change'); } public get exploded(): boolean { return this._exploded; } //...</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sekarang buka kelas </font></font><code>Board</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dan terapkan metode di dalamnya </font></font><code>openClosestFields</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Metode ini bersifat rekursif dan tugasnya adalah untuk membuka semua bidang tetangga yang kosong relatif terhadap sel yang diterima dalam parameter. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Algoritma akan menjadi sebagai berikut:</font></font><br><br><pre> <code class="plaintext hljs"> :                </code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Dan kali ini kita sudah memiliki semua antarmuka yang diperlukan untuk implementasi penuh dari metode ini: </font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// Board.ts //... public openClosestFields(field: Field): void { field.getClosestFields().forEach(item =&gt; {//     if (item.closed) {//    item.open();//   if (item.empty) {//    this.openClosestFields(item);//     } } }); } //...</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tambahkan rajin </font></font><code>completed</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ke kelas </font></font><code>Board</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">untuk menunjukkan penempatan bendera yang benar di papan tulis. </font><font style="vertical-align: inherit;">Bagaimana kita dapat menentukan apakah suatu papan telah berhasil dibersihkan? </font><font style="vertical-align: inherit;">Jumlah bidang yang ditandai dengan benar harus sama dengan jumlah total bom di papan.</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// Board.ts //... public get completed(): boolean { return this._fields.filter(field =&gt; field.completed).length === this._bombs; } //...</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Metode ini memfilter array </font></font><code>_fields</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dengan pengambil </font></font><code>completed</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, yang harus menunjukkan validitas tanda bidang. </font><font style="vertical-align: inherit;">Jika panjang array yang difilter (di mana hanya bidang yang ditandai dengan benar jatuh, yang pengambil </font></font><code>completed</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sudah </font><font style="vertical-align: inherit;">bertanggung jawab </font><font style="vertical-align: inherit;">untuk kelas </font></font><code>Field</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) sama dengan nilai bidang </font></font><code>_bombs</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(yaitu, jumlah bom di papan), maka kami kembali </font></font><code>true</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, dengan kata lain, kami menganggap permainan dimenangkan. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kami juga tidak keberatan dengan kesempatan untuk membuka seluruh papan dengan satu panggilan, apa yang harus kami lakukan di akhir level. </font><font style="vertical-align: inherit;">Kami juga akan menambahkan fitur ini ke kelas </font></font><code>Board</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// Board.ts //... public open(): void { this._fields.forEach(field =&gt; field.open()); } //...</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Masih menambahkan getter </font></font><code>completed</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ke kelas itu sendiri </font></font><code>Field</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Dalam kasus apa bidang akan dianggap berhasil dibersihkan? </font><font style="vertical-align: inherit;">Jika ditambang dan ditandai. </font><font style="vertical-align: inherit;">Kedua getter yang diperlukan sudah ada di sana dan kita dapat menambahkan metode ini:</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// Field.ts //... public get completed(): boolean { return this.marked &amp;&amp; this.mined; } //...</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Untuk menyelesaikan pemrosesan klik kiri mouse, kami akan membuat metode </font></font><code>_onGameOver</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">di mana kami menonaktifkan pelacakan peristiwa papan dan menunjukkan kepada pemain seluruh papan. </font><font style="vertical-align: inherit;">Nanti kita juga akan menambahkan kode rendering laporan penyelesaian status berdasarkan parameter </font></font><code>status</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// GameScene.ts //... private _onGameOver(status: boolean) { this._board.off('left-click', this._onFieldClickLeft, this); this._board.off('right-click', this._onFieldClickRight, this); this._board.open(); } //...</span></span></code> </pre><br><a name="section-4-3"></a><h3> <font color="#008080"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4.3 Tampilan Bidang</font></font></font> </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sebelum Anda mulai memproses klik kanan, kami akan belajar cara menggambar ulang sel yang baru dibuka. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sebelumnya di kelas, </font></font><code>Field</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">kami mengembangkan sebuah metode </font></font><code>_setState</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">yang menembakkan suatu peristiwa </font></font><code>change</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ketika keadaan model berubah. Kami akan menggunakan ini dan di kelas kami akan </font></font><code>FieldView</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">melacak acara ini:</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// FieldView.ts //... private _init(): void { //... this._model.on('change', this._onStateChange, this); } private _onStateChange(): void { this._render(); } private _render(): void { this.setFrame(this._frameName); } //...</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kami secara khusus membuat metode perantara sebagai </font></font><code>_onStateChange</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">panggilan balik acara perubahan model. </font><font style="vertical-align: inherit;">Di masa depan, kita perlu memeriksa bagaimana model itu diubah untuk memahami apakah itu perlu dilakukan </font></font><code>_render</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Untuk menunjukkan sprite sel saat ini dalam keadaan baru, Anda perlu mengubah bingkainya. </font><font style="vertical-align: inherit;">Karena kami memuat atlas sebagai aset, kami dapat memanggil metode </font></font><code>setFrame</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">untuk mengubah kerangka saat ini ke yang baru. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Untuk mendapatkan frame dalam satu baris, kami dengan cerdik menggunakan pengambil </font></font><code>_frameName</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, yang sekarang perlu diimplementasikan. </font><font style="vertical-align: inherit;">Pertama, kami menjelaskan semua nilai yang mungkin diambil oleh bingkai sel.</font></font><br><div class="scrollable-table"><table><tbody><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Bingkai </font></font></td><td>  Ketentuan </td></tr><tr><td> <code>closed</code> </td> <td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Bidang ditutup </font></font><br></td></tr><tr><td> <code>flag</code> </td> <td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Bidang yang ditandai </font></font><br></td></tr><tr><td> <code>empty</code> </td> <td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Bidang terbuka, tidak ditambang atau diisi dengan nilai </font></font><br></td></tr><tr><td> <code>exploded</code> <br> </td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> lapangan terbuka, ditambang dan diledakkan </font></font><br></td></tr><tr><td> <code>mined</code> <br> </td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> lapangan terbuka, ditambang, tetapi tidak meledak </font></font><br></td></tr><tr><td> <code>1...9</code> <br> </td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> lapangan terbuka dan menampilkan nilai dari 1 hingga 9, yang menunjukkan jumlah bom di sebelah bidang ini </font></font><br></td></tr></tbody></table></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kami mendapat deskripsi semua negara bagian dan sudah memiliki semua metode model ini, terima kasih yang dapat diperoleh negara bagian ini. </font><font style="vertical-align: inherit;">Mari kita dapatkan konfigurasi kecil di awal file:</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// FieldView.ts const States = { 'closed': field =&gt; field.closed, 'flag': field =&gt; field.marked, 'empty': field =&gt; field.opened &amp;&amp; !field.mined &amp;&amp; !field.filled, 'exploded': field =&gt; field.opened &amp;&amp; field.mined &amp;&amp; field.exploded, 'mined': field =&gt; field.opened &amp;&amp; field.mined &amp;&amp; !field.exploded } //...</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kunci dalam objek ini akan menjadi nilai-nilai frame, dan nilai-nilai kunci ini adalah panggilan balik yang mengembalikan hasil Boolean. </font><font style="vertical-align: inherit;">Berdasarkan konfigurasi ini, kita dapat mengembangkan metode untuk mendapatkan bingkai yang diinginkan (yaitu, kunci dari konfigurasi):</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// FieldView.ts //... private get _frameName(): string { for (let key in States) { if (States[key](this._model)) { return key; } } return this._model.value.toString(); }</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dengan demikian, dengan penghitungan sederhana dalam satu lingkaran, kita pergi melalui semua kunci dari objek konfigurasi dan memanggil setiap panggilan balik secara bergantian. </font><font style="vertical-align: inherit;">Fungsi yang mengembalikan kita terlebih dahulu akan </font></font><code>true</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">menunjukkan bahwa kunci </font></font><code>key</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pada iterasi saat ini adalah bingkai yang benar untuk keadaan model saat ini. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jika tidak ada kunci yang cocok, maka untuk keadaan default kami akan mempertimbangkan bidang terbuka dengan nilai </font></font><code>_value</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, karena </font></font><code>States</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">kami tidak menetapkan </font><font style="vertical-align: inherit;">negara ini di konfigurasi </font><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sekarang kita dapat sepenuhnya menguji klik kiri pada bidang papan dan memeriksa bagaimana sel-sel terbuka dan apa yang ditampilkan setelah membukanya.</font></font><br><br><a name="section-4-4"></a><h3> <font color="#008080"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4.4 Pemrosesan klik kanan</font></font></font> </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Seperti dalam kasus membuat penangan klik kiri, pertama-tama kita mendefinisikan dengan jelas fungsionalitas yang diharapkan. </font><font style="vertical-align: inherit;">Dengan mengklik kanan, kita harus menandai sel yang dipilih dengan bendera. </font><font style="vertical-align: inherit;">Tetapi ada beberapa kondisi tertentu.</font></font><br><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Hanya bidang tertutup yang saat ini tidak ditandai yang dapat ditandai </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Jika bidang dicentang, maka klik kanan lagi harus menghapus bendera dari bidang </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Saat mengatur / menghapus bendera, perlu memperbarui jumlah bendera yang tersedia di tingkat dan menampilkan teks dengan nomor saat ini </font></font></li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Menerjemahkan kondisi ini ke dalam pseudo-code, kami mendapatkan baris komentar berikut: </font></font><br><br><pre> <code class="plaintext hljs">                              </code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Sekarang kita dapat menerjemahkan algoritme ini menjadi panggilan ke metode yang kita butuhkan, bahkan jika belum dikembangkan: </font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// GameScene.ts private _flags: number = 0; //... private _onFieldClickRight(field: Field): void { if (field.closed &amp;&amp; this._flags &gt; 0) { //        field.addFlag(); //     } else if (field.marked) { //     field.removeFlag(); //   } this._flags = Bombs - this._board.countMarked; } //... public create(): void { this._flags = Bombs; //... } //...</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Di sini kami juga memulai bidang baru </font></font><code>_flags</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, yang pada awal tingkat permainan sama dengan jumlah bom di papan, karena di awal permainan tidak ada satu bendera pun yang telah ditetapkan. </font><font style="vertical-align: inherit;">Bidang ini dipaksa untuk diperbarui dengan setiap klik kanan, karena dalam kasus ini bendera ditambahkan atau dihapus dari papan. </font><font style="vertical-align: inherit;">Tambahkan </font></font><code>Board</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">getter </font><font style="vertical-align: inherit;">ke kelas </font></font><code>countMarked</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// Board.ts //... public get countMarked(): number { return this._fields.filter(field =&gt; field.marked).length; } //...</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mengatur dan menghapus bendera adalah perubahan dalam keadaan model </font></font><code>Field</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, jadi kami menerapkan metode ini di kelas yang sesuai dengan metode yang sama </font></font><code>open</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// Field.ts //... public addFlag(): void { this._setState(States.Marked); } public removeFlag(): void { this._setState(States.Closed); } //...</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Biarkan saya mengingatkan Anda bahwa itu </font></font><code>_setState</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">akan memicu peristiwa </font></font><code>change</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">yang dilacak dalam tampilan dan, dengan demikian, sprite akan digambar ulang secara otomatis saat ini ketika model berubah. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Saat menguji fungsionalitas yang dikembangkan, Anda pasti akan menemukan bahwa setiap kali Anda mengklik tombol mouse kanan, menu konteks terbuka. </font><font style="vertical-align: inherit;">Tambahkan kode yang menonaktifkan perilaku ini ke konstruktor adegan permainan:</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// GameScene.ts //... constructor() { super('Game'); //        document.querySelector("canvas").oncontextmenu = e =&gt; e.preventDefault(); } //...</span></span></code> </pre><br><a name="section-4-5"></a><h3> <font color="#008080"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4.5 Objek GameSceneView</font></font></font> </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Untuk menampilkan UI pada adegan game, kami akan membuat kelas </font></font><code>GameSceneView</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dan menempatkannya di </font></font><code>src/scripts/views/GameSceneView.ts</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dalam hal ini, kami akan bertindak dengan cara yang berbeda dari penciptaan </font></font><code>FieldView</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dan tidak akan membuat kelas ini sebagai cetakan dan pewaris </font></font><code>GameObjects</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dalam hal ini, kita perlu menampilkan elemen-elemen berikut dari tampilan adegan:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> teks dalam jumlah bendera </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> tombol keluar </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Pesan status penyelesaian permainan (menang / kalah) </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mari kita buat setiap elemen UI bidang terpisah di kelas </font></font><code>GameSceneView</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kami akan menyiapkan rintisan.</font></font><br><br><pre> <code class="javascript hljs">enum Styles { Color = <span class="hljs-string"><span class="hljs-string">'#008080'</span></span>, Font = <span class="hljs-string"><span class="hljs-string">'Arial'</span></span> } enum Texts { Flags = <span class="hljs-string"><span class="hljs-string">'FLAGS: '</span></span>, Exit = <span class="hljs-string"><span class="hljs-string">'EXIT'</span></span>, Success = <span class="hljs-string"><span class="hljs-string">'YOU WIN!'</span></span>, Failure = <span class="hljs-string"><span class="hljs-string">'YOU LOOSE'</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">GameSceneView</span></span></span><span class="hljs-class"> </span></span>{ private _scene: Phaser.Scene = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; private _style: {<span class="hljs-attr"><span class="hljs-attr">font</span></span>: string, <span class="hljs-attr"><span class="hljs-attr">fill</span></span>: string}; <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(scene: Phaser.Scene) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._scene = scene; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._style = {<span class="hljs-attr"><span class="hljs-attr">font</span></span>: <span class="hljs-string"><span class="hljs-string">`28px </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${Styles.Font}</span></span></span><span class="hljs-string">`</span></span>, <span class="hljs-attr"><span class="hljs-attr">fill</span></span>: Styles.Color}; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._create(); } private _create(): <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> { } public render() { } }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Tambahkan teks dengan jumlah bendera. </font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// GameSceneView.ts //... private _txtFlags: Phaser.GameObjects.Text = null; //... private _createTxtFlags(): void { this._txtFlags = this._scene.add.text( 50, 50, Texts.Flags, this._style ).setOrigin(0, 1); } //...</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kode ini akan menempatkan teks yang kita butuhkan dalam posisi menjorok 50px dari sisi atas dan kiri dan mengaturnya ke gaya yang ditentukan. </font><font style="vertical-align: inherit;">Selain itu, metode ini </font></font><code>setOrigin</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mengatur titik pivot teks ke koordinat (0, 1). </font><font style="vertical-align: inherit;">Ini berarti bahwa teks akan sejajar dengan batas kirinya. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tambahkan pesan status.</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// GameSceneView.ts //... private _txtStatus: Phaser.GameObjects.Text = null; //... private _createTxtStatus(): void { this._txtStatus = this._scene.add.text( this._scene.cameras.main.centerX, 50, Texts.Success, this._style ).setOrigin(0.5, 1); this._txtStatus.visible = false; } //...</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kami menempatkan teks status di tengah layar dan menyelaraskannya dengan tengah garis dengan memanggil </font></font><code>setOrigin</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dengan parameter 0,5 untuk koordinat x. </font><font style="vertical-align: inherit;">Selain itu, secara default, teks ini perlu disembunyikan, karena kami hanya akan menampilkannya setelah permainan selesai. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Buat tombol keluar, yang intinya juga merupakan objek teks.</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// GameSceneView.ts //... private _btnExit: Phaser.GameObjects.Text = null; //... private _createBtnExit(): void { this._btnExit = this._scene.add.text( this._scene.cameras.main.width - 50, 50, Texts.Exit, this._style ).setOrigin(1); this._btnExit.setInteractive(); this._btnExit.once('pointerdown', () =&gt; { this._scene.scene.start('Start'); }); } //...</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kami menempatkan tombol di sudut kanan atas layar dan menggunakannya lagi </font></font><code>setOrigin</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">untuk menyelaraskan teks kali ini dengan tepi kanannya. </font><font style="vertical-align: inherit;">Kami membuat tombol interaktif dan menambahkan panggilan balik ke acara klik, yang mengirim pemain ke adegan awal. </font><font style="vertical-align: inherit;">Dengan demikian, kami memberikan pemain kesempatan untuk keluar dari level kapan saja. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tetap mengembangkan metode </font></font><code>render</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">untuk memperbarui semua elemen UI dengan benar dan menambahkan panggilan ke semua metode yang dibuat di </font></font><code>_create</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// GameSceneView.ts //... private _create(): void { this._createTxtFlags(); this._createTxtStatus(); this._createBtnExit(); } public render(data: {flags?: number, status?: boolean}) { if (typeof data.flags !== 'undefined') { this._txtFlags.text = Texts.Flags + data.flags.toString(); } if (typeof data.status !== 'undefined') { this._txtStatus.text = data.status ? Texts.Success : Texts.Failure; this._txtStatus.visible = true; } } //...</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bergantung pada properti yang diteruskan dalam parameter, kami memperbarui UI, menampilkan perubahan yang diperlukan. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Buat representasi dalam adegan permainan di kelas GameScene dan tulis panggilan ke metode _render di mana pun dibutuhkan dengan makna:</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// GameScene.ts //... import { GameSceneView } from "../views/GameSceneView"; //... export class GameScene extends Phaser.Scene { private _view: GameSceneView = null; //... private _onGameOver(status: boolean) { //... this._view.render({status}); } //... private _onFieldClickRight(field: Field): void { //... this._flags = Bombs - this._board.countMarked; this._view.render({flags: this._flags}); } //... public create(): void { //... this._view = new GameSceneView(this); this._view.render({flags: this._flags}); } //... }</span></span></code> </pre><br><a name="section-5"></a><h2> <font color="#008080"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5. Animasi</font></font></font> </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Penggemar macam apa yang menciptakan game, bahkan sesederhana milik kita, jika tidak ada animasi di dalamnya ?! </font><font style="vertical-align: inherit;">Selain itu, sejak kami mulai mempelajari phaser, mari berkenalan dengan fitur paling dasar dari animasi dan pertimbangkan fungsi si kembar. </font><font style="vertical-align: inherit;">Kembar diimplementasikan dalam kerangka itu sendiri dan tidak ada perpustakaan pihak ketiga yang diperlukan. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tambahkan 2 animasi ke permainan: mengisi papan dengan sel di awal dan membalik sel di pembukaan. </font><font style="vertical-align: inherit;">Mari kita mulai dengan yang pertama.</font></font><br><br><a name="section-5-1"></a><h3> <font color="#008080"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5.1 Animasi isi papan</font></font></font> </h3><br><img src="https://habrastorage.org/webt/7r/uu/1v/7ruu1vtppaw26sp-fapxbahgm9q.gif"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kami memastikan bahwa semua sel papan terbang ke tempatnya dari tepi kiri atas layar. </font><font style="vertical-align: inherit;">Saat memulai level permainan, kita perlu menggeser semua sel ke sudut kiri atas layar dan untuk setiap sel untuk memulai animasi gerakan ke koordinat yang sesuai. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Di kelas, </font></font><code>FiledView</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tambahkan </font></font><code>_create</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">panggilan </font><font style="vertical-align: inherit;">ke akhir metode </font></font><code>_animateShow</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// FieldView.ts //... private _create(): void { //... this._animateShow(); } //...</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">B kita menerapkan metode baru yang kita butuhkan. </font><font style="vertical-align: inherit;">Di dalamnya, seperti yang kami sepakati di atas, perlu melakukan 2 hal:</font></font><br><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> gerakkan sel di belakang sudut kiri atas sehingga tidak terlihat di layar </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> mulai gerakan kembar ke koordinat yang diinginkan dengan penundaan yang benar </font></font></li></ol><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// FieldView.ts //... private _animateShow(): Promise&lt;void&gt; { this.x = -this.width; this.y = -this.height; const delay = this._model.row * 50 + this._model.col * 10; return this._moveTo(this._position, delay); } //...</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Karena sudut kiri atas kanvas memiliki koordinat (0, 0), maka jika kita mengatur sel ke koordinat sama dengan nilai negatifnya lebar dan tinggi, ini akan menempatkan sel di belakang sudut kiri atas dan bersembunyi dari layar. </font><font style="vertical-align: inherit;">Jadi, kami menyelesaikan tugas pertama kami. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Anda akan mencapai tujuan kedua dengan memanggil metode </font></font><code>_moveTo</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// FieldView.ts //... private _moveTo(position: Vec2, delay: number): Promise&lt;void&gt; { return new Promise(resolve =&gt; { this.scene.tweens.add({ targets: this, x: position.x, y: position.y, duration: 600, ease: 'Elastic', easeParams: [1, 1], delay, onComplete: () =&gt; { resolve(); } }); }); } //...</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Untuk membuat animasi, kami menggunakan properti scene </font></font><code>tweens</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Dalam metodenya, </font></font><code>add</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">kami melewatkan objek konfigurasi dengan pengaturan:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Properti di </font></font><code>targets</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sini harus berisi sebagai nilai objek-objek game yang ingin Anda terapkan efek animasi. </font><font style="vertical-align: inherit;">Dalam kasus kami, ini adalah tautan </font></font><code>this</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ke objek saat ini, karena ini adalah cetakan dari sprite.</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Parameter kedua dan ketiga kami melewati koordinat tujuan. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Properti </font></font><code>duration</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ini bertanggung jawab atas durasi animasi, dalam kasus kami - 600ms.</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Parameter </font></font><code>ease</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dan </font></font><code>easeParams</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">atur fungsi pelonggaran.</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Di bidang penundaan, kami mengganti nilai dari argumen kedua, yang dihasilkan untuk setiap sel individu, dengan mempertimbangkan posisinya di papan tulis. </font><font style="vertical-align: inherit;">Ini dilakukan agar sel-sel tidak terbang bersamaan. </font><font style="vertical-align: inherit;">Sebaliknya, setiap sel akan muncul dengan sedikit penundaan relatif terhadap yang sebelumnya.</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Akhirnya, </font></font><code>onComplete</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">kami melakukan panggilan balik </font><font style="vertical-align: inherit;">di properti </font><font style="vertical-align: inherit;">, yang akan dipanggil pada akhir tindakan tween.</font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Adalah masuk akal untuk membungkus kembaran itu dalam sebuah janji sehingga di masa depan itu akan dapat dengan indah mem-dock animasi yang berbeda, jadi kami akan menempatkan pemanggilan fungsi dalam panggilan balik yang </font></font><code>resolve</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">menunjukkan keberhasilan pelaksanaan animasi.</font></font><br><br><a name="section-5-2"></a><h3> <font color="#008080"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5.2 Animasi Flip Cell</font></font></font> </h3><br><img src="https://habrastorage.org/webt/uc/d-/yw/ucd-yw-nq6a4veixb-npp0mdyqy.gif"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Akan lebih bagus jika, ketika sel dibuka, efek pembalikannya direproduksi. Bagaimana kita bisa mencapai ini? </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Membuka sel saat ini dilakukan dengan mengubah bingkai ketika metode dipanggil </font></font><code>_render</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dalam tampilan. Jika kita memeriksa keadaan model dalam metode ini, kita akan melihat apakah sel itu terbuka. Jika sel terbuka, mulai animasi bukannya langsung menampilkan bingkai pembalikan baru.</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// FieldView.ts //... private _onStateChange(): void { if (this._model.opened) { this._animateFlip(); } else { this._render(); } } //...</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Untuk mendapatkan efek yang diinginkan, kami akan menggunakan transformasi sprite melalui properti </font></font><code>scale</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Jika kita skala sprite sepanjang sumbu </font></font><code>x</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ke nol </font><font style="vertical-align: inherit;">dari waktu ke waktu </font><font style="vertical-align: inherit;">, itu akhirnya akan menyusut, menghubungkan sisi kiri dan kanan. </font><font style="vertical-align: inherit;">Dan sebaliknya, jika Anda menskalakan sprite sepanjang sumbu </font></font><code>x</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dari nol hingga lebar penuh, kami merentangkannya ke ukuran penuhnya. </font><font style="vertical-align: inherit;">Kami menerapkan logika ini dalam metode ini </font></font><code>_animateFlip</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// FieldView.ts //... private _animateFlip(): void { this._scaleXTo(0).then(() =&gt; { this._render(); this._scaleXTo(1); }) } //...</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dengan analogi dengan metode ini, kami </font></font><code>_moveTo</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">menerapkan </font></font><code>_scaleTo</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// FieldView.ts //... private _scaleXTo(scaleX: number): Promise&lt;void&gt; { return new Promise(resolve =&gt; { this.scene.tweens.add({ targets: this, scaleX, ease: 'Elastic.easeInOut', easeParams: [1, 1], duration: 150, onComplete: () =&gt; { resolve() } }); }); } //...</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dalam metode ini, sebagai parameter, kita mengambil nilai skala, yang akan kita gunakan untuk mengubah ukuran sprite di kedua arah dan meneruskannya sebagai parameter kedua ke objek konfigurasi animasi. </font><font style="vertical-align: inherit;">Semua parameter konfigurasi lain sudah akrab bagi kita dari animasi sebelumnya. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sekarang kita akan memulai proyek untuk pengujian dan setelah debugging kita akan mempertimbangkan permainan kita selesai, dan tugas pengujian selesai!</font></font> :) <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Saya dengan tulus berterima kasih kepada semua orang karena telah mencapai momen ini dengan saya! </font></font><br><br><h2>  Kesimpulan </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kolega, saya akan sangat senang jika materi yang disajikan dalam artikel ini bermanfaat bagi Anda dan Anda dapat menggunakan pendekatan ini atau yang dijelaskan dalam proyek Anda sendiri. Anda selalu dapat menoleh kepada saya dengan pertanyaan, baik pada artikel ini, dan pada pemrograman phaser atau bekerja di gamedev secara umum. Saya menyambut komunikasi dan akan senang untuk berkenalan dan bertukar pengalaman baru! </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dan saya punya pertanyaan untuk Anda sekarang. Karena saya membuat video tutorial tentang pengembangan game, saya secara alami mengumpulkan selusin game kecil ini. Setiap game membuka framework dengan caranya sendiri. Misalnya, dalam game ini kami menyentuh topik tentang si kembar, tetapi ada banyak fitur lain, seperti fisika, tilemap, tulang belakang, dll.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dalam hal ini, pertanyaannya adalah, apakah Anda menyukai artikel ini dan, jika demikian, apakah Anda tertarik untuk terus membaca artikel seperti ini, tetapi tentang game klasik kecil lainnya? </font><font style="vertical-align: inherit;">Jika jawabannya ya, saya dengan senang hati akan menerjemahkan materi tutorial video saya ke dalam format teks dan terus menerbitkan manual baru dari waktu ke waktu, tetapi untuk game lain. </font><font style="vertical-align: inherit;">Saya membawa survei yang sesuai. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Terima kasih atas perhatian Anda! </font><font style="vertical-align: inherit;">Saya akan dengan senang hati memberikan tanggapan dan melihat Anda segera!</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id476682/">https://habr.com/ru/post/id476682/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id476670/index.html">Gambaran umum CAD pada inti geometri C3D - 2</a></li>
<li><a href="../id476674/index.html">ReportPortal penyebaran cepat untuk pengenalan</a></li>
<li><a href="../id476676/index.html">48 sumber daya open source untuk JavaScript (2019)</a></li>
<li><a href="../id476678/index.html">API untuk pengambilan asinkron jarak jauh menggunakan Apple Combine</a></li>
<li><a href="../id476680/index.html">Sistem perencanaan produksi berkelanjutan Rodov adalah Lean / MRP Soviet 1961. Lepas landas, matahari terbenam, dan kelahiran baru</a></li>
<li><a href="../id476686/index.html">Pengembangan gateway IoT berdasarkan Raspberry CM3 +</a></li>
<li><a href="../id476688/index.html">Kursus baru dari OTUS. ‚ÄúPengembang iOS. Kursus Lanjutan V 2.0 ¬ª</a></li>
<li><a href="../id476692/index.html">Prinsip Pemasaran Konten</a></li>
<li><a href="../id476694/index.html">Tentang robotika bisnis dengan Farida Roslovets dan direktur electroNeek perusahaan RPA</a></li>
<li><a href="../id476696/index.html">Cara membuat dan menyebarkan Full-Stack Bereaksi-aplikasi</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>