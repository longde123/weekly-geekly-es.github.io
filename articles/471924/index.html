<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤾🏿 🌐 🤸🏾 Presentación de los módulos Sass 👎🏾 🚍 🧛🏾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hola Habr! Les presento la traducción del artículo "Introducing Sass Modules" de Miriam Suzanne. 

 Recientemente, apareció una característica en Sass...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Presentación de los módulos Sass</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/471924/"> Hola Habr!  Les presento la traducción del artículo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">"Introducing Sass Modules"</a> de Miriam Suzanne. <br><br>  Recientemente, apareció una característica en Sass que le resulta familiar en otros idiomas: un <b>sistema modular</b> .  Este es un gran paso adelante para <code>@import</code> , una de las funciones más utilizadas en Sass.  A pesar de que la directiva <code>@import</code> existente le permite conectar paquetes de terceros y separar sus estilos en elementos compatibles, todavía tiene varias limitaciones <a name="habracut"></a>  : <br><br><ul><li>  <code>@import</code> también existe en CSS, y cualquier diferencia en su comportamiento puede ser confusa. </li><li>  Si importa <code>@import</code> varias veces para un archivo, esto puede ralentizar la compilación, provocar conflictos de redefinición y obtener código duplicado en la salida. </li><li>  Todo está en el ámbito global, incluidos los paquetes de terceros: así es como mi función de <code>color</code> puede anular su función de <code>color</code> existente o viceversa. </li><li>  Cuando utiliza una función como el <code>color</code> , es imposible saber exactamente dónde se define.  ¿Qué <code>@import</code> conectó? </li></ul><br>  Los autores de los paquetes Sass (como yo) intentaron solucionar los problemas de espacio de nombres estableciendo manualmente prefijos para variables y funciones, pero los módulos Sass son una solución mucho más poderosa.  En resumen, <code>@import</code> se <code>@import</code> reemplazando por <code>@forward</code> más explícitas <code>@use</code> y <code>@forward</code> .  En los próximos años, <code>@import</code> en Sass quedará en desuso y luego se eliminará.  Aún puede usar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><code>CSS Import</code> 's</a> , pero Sass no los compilará.  Pero no se preocupe, hay <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">una herramienta de migración</a> que lo ayudará a actualizar. <br><br><h2>  Importar archivos usando <code>@use</code> </h2><br><pre> <code class="css hljs">@<span class="hljs-keyword"><span class="hljs-keyword">use</span></span> <span class="hljs-string"><span class="hljs-string">'buttons'</span></span>;</code> </pre><br>  El nuevo <code>@use</code> es similar a <code>@import</code> , pero tiene algunas diferencias notables: <br><br><ul><li>  El archivo se importa una vez, sin importar cuántas veces use <code>@use</code> en el proyecto. </li><li>  Las variables, mixins y funciones (que se llaman "miembros" en Sass) que comienzan con un guión bajo ( <code>_</code> ) o guión ( <code>-</code> ) se consideran privadas y no se importan. </li><li>  Los miembros del archivo conectado a través de <code>@use</code> (en nuestro caso <code>buttons.scss</code> ) son accesibles solo localmente y no se transfieren a la importación posterior. </li><li>  Del mismo modo, <code>@extends</code> solo se aplicará en sentido ascendente;  es decir, la extensión se aplica solo a los estilos que se importan, y no a los estilos que se importan. </li><li>  Todos los miembros importados tienen su propio <i>espacio</i> de <i>nombres</i> de forma predeterminada. </li></ul><br>  Cuando adjuntamos el archivo a través de <code>@use</code> , Sass genera automáticamente un espacio de nombres basado en el nombre del archivo. <br><br><pre> <code class="css hljs">@<span class="hljs-keyword"><span class="hljs-keyword">use</span></span> <span class="hljs-string"><span class="hljs-string">'buttons'</span></span>; <span class="hljs-comment"><span class="hljs-comment">/*    `buttons`*/</span></span> @<span class="hljs-keyword"><span class="hljs-keyword">use</span></span> <span class="hljs-string"><span class="hljs-string">'forms'</span></span>; <span class="hljs-comment"><span class="hljs-comment">/*    `forms`*/</span></span></code> </pre><br>  Ahora tenemos acceso a los miembros tanto del archivo <code>forms.scss</code> archivo <code>forms.scss</code> , pero este acceso no se transfiere entre las importaciones: <code>forms.scss</code> todavía no tiene acceso a las variables definidas en <code>buttons.scss</code> .  Dado que las entidades importadas tienen un espacio de nombres, debemos usar la nueva sintaxis delimitada por puntos para acceder a ellas: <br><br><pre> <code class="css hljs"><span class="hljs-comment"><span class="hljs-comment">/* : &lt;namespace&gt;.$variable */</span></span> $<span class="hljs-selector-tag"><span class="hljs-selector-tag">btn-color</span></span>: <span class="hljs-selector-tag"><span class="hljs-selector-tag">buttons</span></span>.$<span class="hljs-selector-tag"><span class="hljs-selector-tag">color</span></span>; $<span class="hljs-selector-tag"><span class="hljs-selector-tag">form-border</span></span>: <span class="hljs-selector-tag"><span class="hljs-selector-tag">forms</span></span>.$<span class="hljs-selector-tag"><span class="hljs-selector-tag">input-border</span></span>; <span class="hljs-comment"><span class="hljs-comment">/* : &lt;namespace&gt;.function() */</span></span> $<span class="hljs-selector-tag"><span class="hljs-selector-tag">btn-background</span></span>: <span class="hljs-selector-tag"><span class="hljs-selector-tag">buttons</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.background</span></span>(); $<span class="hljs-selector-tag"><span class="hljs-selector-tag">form-border</span></span>: <span class="hljs-selector-tag"><span class="hljs-selector-tag">forms</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.border</span></span>(); <span class="hljs-comment"><span class="hljs-comment">/* : @include &lt;namespace&gt;.mixin() */</span></span> @<span class="hljs-keyword"><span class="hljs-keyword">include</span></span> buttons.submit(); @<span class="hljs-keyword"><span class="hljs-keyword">include</span></span> forms.input();</code> </pre><br>  Podemos cambiar o eliminar el espacio de nombres predeterminado agregando <code>as &lt;name&gt;</code> a la importación. <br><br><pre> <code class="css hljs">@<span class="hljs-keyword"><span class="hljs-keyword">use</span></span> <span class="hljs-string"><span class="hljs-string">'buttons'</span></span> as *; <span class="hljs-comment"><span class="hljs-comment">/*      */</span></span> @<span class="hljs-keyword"><span class="hljs-keyword">use</span></span> <span class="hljs-string"><span class="hljs-string">'forms'</span></span> as <span class="hljs-string"><span class="hljs-string">'f'</span></span>; $<span class="hljs-selector-tag"><span class="hljs-selector-tag">btn-color</span></span>: $<span class="hljs-selector-tag"><span class="hljs-selector-tag">color</span></span>; <span class="hljs-comment"><span class="hljs-comment">/* buttons.$color    */</span></span> $<span class="hljs-selector-tag"><span class="hljs-selector-tag">form-border</span></span>: <span class="hljs-selector-tag"><span class="hljs-selector-tag">f</span></span>.$<span class="hljs-selector-tag"><span class="hljs-selector-tag">input-border</span></span>; <span class="hljs-comment"><span class="hljs-comment">/* forms.$input-border    */</span></span></code> </pre><br>  El uso de <code>as *</code> agrega el módulo al espacio de nombres raíz, por lo que el prefijo no es necesario, pero sus miembros aún están limitados localmente por el documento actual. <br><br><h2>  Importar módulos integrados Sass </h2><br>  Las capacidades internas de Sass también se han trasladado a un sistema modular, por lo que tenemos control total sobre el espacio de nombres global.  Hay varios módulos integrados ( <code>math</code> , <code>color</code> , <code>string</code> , <code>list</code> , <code>map</code> , <code>selector</code> y <code>meta</code> ) que deben importarse explícitamente al archivo antes de su uso. <br><br><pre> <code class="css hljs">@<span class="hljs-keyword"><span class="hljs-keyword">use</span></span> <span class="hljs-string"><span class="hljs-string">'sass:math'</span></span>; $<span class="hljs-selector-tag"><span class="hljs-selector-tag">half</span></span>: <span class="hljs-selector-tag"><span class="hljs-selector-tag">math</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.percentage</span></span>(1/2);</code> </pre><br>  Los módulos integrados también se pueden importar al espacio global: <br><br><pre> <code class="css hljs">@<span class="hljs-keyword"><span class="hljs-keyword">use</span></span> <span class="hljs-string"><span class="hljs-string">'sass:math'</span></span> as *; $<span class="hljs-selector-tag"><span class="hljs-selector-tag">half</span></span>: <span class="hljs-selector-tag"><span class="hljs-selector-tag">percentage</span></span>(1/2);</code> </pre><br>  Las funciones integradas que ya tienen nombres de prefijo, como <code>map-get</code> o <code>str-index</code> , se pueden usar sin duplicar este prefijo: <br><br><pre> <code class="css hljs">@<span class="hljs-keyword"><span class="hljs-keyword">use</span></span> <span class="hljs-string"><span class="hljs-string">'sass:map'</span></span>; @<span class="hljs-keyword"><span class="hljs-keyword">use</span></span> <span class="hljs-string"><span class="hljs-string">'sass:string'</span></span>; $<span class="hljs-selector-tag"><span class="hljs-selector-tag">map-get</span></span>: <span class="hljs-selector-tag"><span class="hljs-selector-tag">map</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.get</span></span>(('<span class="hljs-selector-tag"><span class="hljs-selector-tag">key</span></span>': '<span class="hljs-selector-tag"><span class="hljs-selector-tag">value</span></span>'), '<span class="hljs-selector-tag"><span class="hljs-selector-tag">key</span></span>'); $<span class="hljs-selector-tag"><span class="hljs-selector-tag">str-index</span></span>: <span class="hljs-selector-tag"><span class="hljs-selector-tag">string</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.index</span></span>('<span class="hljs-selector-tag"><span class="hljs-selector-tag">string</span></span>', '<span class="hljs-selector-tag"><span class="hljs-selector-tag">i</span></span>');</code> </pre><br>  Puede encontrar una lista completa de módulos integrados, funciones y cambios de nombre en <a href="">la especificación del módulo Sass</a> . <br><br><h2>  Características principales nuevas y modificadas </h2><br>  Como beneficio adicional, esto significa que Sass puede agregar de manera segura nuevas combinaciones y funciones internas sin causar conflictos de nombres.  El ejemplo más sorprendente es el <code>sass:meta</code> de <code>load-css</code> del módulo <code>sass:meta</code> .  Funciona de manera similar a <code>@use</code> , pero solo devuelve el CSS generado y funciona dinámicamente en cualquier parte de su código: <br><br><pre> <code class="css hljs">@<span class="hljs-keyword"><span class="hljs-keyword">use</span></span> <span class="hljs-string"><span class="hljs-string">'sass:meta'</span></span>; $<span class="hljs-selector-tag"><span class="hljs-selector-tag">theme-name</span></span>: '<span class="hljs-selector-tag"><span class="hljs-selector-tag">dark</span></span>'; <span class="hljs-selector-attr"><span class="hljs-selector-attr">[data-theme='#{$theme-name}']</span></span> { @include meta.load-css($theme-name); }</code> </pre><br>  El primer argumento es la URL del módulo (como en <code>@use</code> ), pero se puede cambiar dinámicamente usando una variable, incluso usando interpolación, por ejemplo, el <code>theme-#{$name}</code> .  El segundo argumento (opcional) toma una estructura de <code>map</code> con la configuración: <br><br><pre> <code class="css hljs"><span class="hljs-comment"><span class="hljs-comment">/*   $base-color  'theme/dark'   */</span></span> @<span class="hljs-keyword"><span class="hljs-keyword">include</span></span> meta.load-css( <span class="hljs-string"><span class="hljs-string">'theme/dark'</span></span>, $with: (<span class="hljs-string"><span class="hljs-string">'base-color'</span></span>: rebeccapurple) );</code> </pre><br>  El argumento <code>$with</code> permite configurar cualquier variable en el módulo cargado utilizando la estructura del <code>map</code> , y esta variable debe cumplir las condiciones: <br><br><ul><li>  No es una variable privada que comienza con <code>_</code> o <code>-</code> </li><li>  Marcado con la directiva <code>!default</code> Default </li></ul><br><pre> <code class="css hljs"><span class="hljs-comment"><span class="hljs-comment">/* theme/_dark.scss */</span></span> $<span class="hljs-selector-tag"><span class="hljs-selector-tag">base-color</span></span>: <span class="hljs-selector-tag"><span class="hljs-selector-tag">black</span></span> !<span class="hljs-selector-tag"><span class="hljs-selector-tag">default</span></span>; <span class="hljs-comment"><span class="hljs-comment">/*    */</span></span> $_<span class="hljs-selector-tag"><span class="hljs-selector-tag">private</span></span>: <span class="hljs-selector-tag"><span class="hljs-selector-tag">true</span></span> !<span class="hljs-selector-tag"><span class="hljs-selector-tag">default</span></span>; <span class="hljs-comment"><span class="hljs-comment">/*        */</span></span> $<span class="hljs-selector-tag"><span class="hljs-selector-tag">config</span></span>: <span class="hljs-selector-tag"><span class="hljs-selector-tag">false</span></span>; <span class="hljs-comment"><span class="hljs-comment">/*    ,      !default */</span></span></code> </pre><br>  Tenga en cuenta que la clave <code>'base-color'</code> establece la variable <code>$base-color</code> . <br><br>  Hay un par de nuevas funciones más del módulo <code>sass:meta</code> : <code>module-variables()</code> y <code>module-functions()</code> .  Cada uno de ellos devuelve una estructura de <code>map</code> partir de nombres y valores de un módulo ya importado.  Toman un argumento correspondiente al espacio de nombres del módulo: <br><br><pre> <code class="css hljs">@<span class="hljs-keyword"><span class="hljs-keyword">use</span></span> <span class="hljs-string"><span class="hljs-string">'forms'</span></span>; $<span class="hljs-selector-tag"><span class="hljs-selector-tag">form-vars</span></span>: <span class="hljs-selector-tag"><span class="hljs-selector-tag">module-variables</span></span>('<span class="hljs-selector-tag"><span class="hljs-selector-tag">forms</span></span>'); <span class="hljs-comment"><span class="hljs-comment">/* ( button-color: blue, input-border: thin, ) */</span></span> $<span class="hljs-selector-tag"><span class="hljs-selector-tag">form-functions</span></span>: <span class="hljs-selector-tag"><span class="hljs-selector-tag">module-functions</span></span>('<span class="hljs-selector-tag"><span class="hljs-selector-tag">forms</span></span>'); <span class="hljs-comment"><span class="hljs-comment">/* ( background: get-function('background'), border: get-function('border'), ) */</span></span></code> </pre><br>  Varias otras funciones de <code>sass:meta</code> - <code>global-variable-exists()</code> , <code>function-exists()</code> , <code>mixin-exists()</code> y <code>get-function()</code> - recibirán argumentos adicionales de <code>$module</code> que nos permitirán verificar explícitamente cada espacio de nombres. <br><br><h3>  Ajustar y escalar colores </h3><br>  El módulo <code>sass:color</code> también tiene algunas reservas interesantes sobre la resolución de algunos de nuestros viejos problemas.  Muchas de las funciones heredadas como <code>lighten()</code> o <code>adjust-hue()</code> ya no se recomiendan para utilizar las funciones explícitas <code>color.adjust()</code> y <code>color.scale()</code> : <br><br><pre> <code class="css hljs"><span class="hljs-comment"><span class="hljs-comment">/*  lighten(red, 20%) */</span></span> $<span class="hljs-selector-tag"><span class="hljs-selector-tag">light-red</span></span>: <span class="hljs-selector-tag"><span class="hljs-selector-tag">color</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.adjust</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">red</span></span>, $<span class="hljs-selector-tag"><span class="hljs-selector-tag">lightness</span></span>: 20%); <span class="hljs-comment"><span class="hljs-comment">/*  adjust-hue(red, 180deg) */</span></span> $<span class="hljs-selector-tag"><span class="hljs-selector-tag">complement</span></span>: <span class="hljs-selector-tag"><span class="hljs-selector-tag">color</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.adjust</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">red</span></span>, $<span class="hljs-selector-tag"><span class="hljs-selector-tag">hue</span></span>: 180<span class="hljs-selector-tag"><span class="hljs-selector-tag">deg</span></span>);</code> </pre><br><br>  Algunas de estas funciones obsoletas (por ejemplo, <code>adjust-hue</code> ) son redundantes e innecesarias.  Otros, como <code>lighten</code> , <code>darken</code> , <code>saturate</code> , etc.  - Necesita una nueva implementación para mejorar la lógica interna.  Las funciones originales se basaron en <code>adjust()</code> , que utiliza matemática lineal: agregar un <code>20%</code> a la luminosidad actual del <code>red</code> en nuestro ejemplo anterior.  En la mayoría de los casos, queremos cambiar ( <code>scale()</code> ) el color en un cierto porcentaje en relación con el valor actual: <br><br><pre> <code class="css hljs"><span class="hljs-comment"><span class="hljs-comment">/*        20,   0.2,     */</span></span> $<span class="hljs-selector-tag"><span class="hljs-selector-tag">light-red</span></span>: <span class="hljs-selector-tag"><span class="hljs-selector-tag">color</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.scale</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">red</span></span>, $<span class="hljs-selector-tag"><span class="hljs-selector-tag">lightness</span></span>: 20%);</code> </pre><br>  Después de ser completamente desaprobado y eliminado, estas funciones eventualmente reaparecerán en <code>sass:color</code> con un nuevo comportamiento basado en <code>color.scale()</code> , no <code>color.adjust()</code> .  Esto sucederá gradualmente para evitar problemas repentinos de compatibilidad con versiones anteriores.  Mientras tanto, recomiendo verificar manualmente su código para ver dónde <code>color.scale()</code> podría ser más útil. <br><br><h2>  Configurar bibliotecas importadas </h2><br>  Las bibliotecas de terceros o reutilizables a menudo vienen con variables con algunos valores predeterminados que puede anular.  Hicimos esto con variables antes de importar: <br><br><pre> <code class="css hljs"><span class="hljs-comment"><span class="hljs-comment">/* _buttons.scss */</span></span> $<span class="hljs-selector-tag"><span class="hljs-selector-tag">color</span></span>: <span class="hljs-selector-tag"><span class="hljs-selector-tag">blue</span></span> !<span class="hljs-selector-tag"><span class="hljs-selector-tag">default</span></span>; <span class="hljs-comment"><span class="hljs-comment">/* old.scss */</span></span> $<span class="hljs-selector-tag"><span class="hljs-selector-tag">color</span></span>: <span class="hljs-selector-tag"><span class="hljs-selector-tag">red</span></span>; @<span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-string"><span class="hljs-string">'buttons'</span></span>;</code> </pre><br>  Dado que cuando se usan módulos ya no hay acceso a variables locales, necesitamos una nueva forma de establecer valores.  Podemos hacer esto pasando la configuración a través del <code>map</code> a <code>@use</code> : <br><br><pre> <code class="css hljs">@<span class="hljs-keyword"><span class="hljs-keyword">use</span></span> <span class="hljs-string"><span class="hljs-string">'buttons'</span></span> with ( $color: red, $style: <span class="hljs-string"><span class="hljs-string">'flat'</span></span>, );</code> </pre><br>  Esto es similar al argumento <code>$with</code> en <code>load-css()</code> , pero en lugar de usar nombres de variables como claves, usamos las variables mismas con el símbolo <code>$</code> . <br><br>  Me gusta cuán explícito se ha vuelto el ajuste, pero hay una regla que me ha desconcertado varias veces: un <b>módulo solo se puede configurar una vez al primer uso</b> .  El orden de conexión siempre ha sido importante para Sass, incluso con <code>@import</code> , pero estos problemas pasaron desapercibidos.  Ahora tenemos un error claro, y esto es bueno y un poco inesperado.  Asegúrese de conectar las bibliotecas a través de <code>@use</code> y configurarlas en el punto de entrada de archivos (el documento central que importa todos los demás archivos) para que estas configuraciones se <code>@use</code> antes de otras conexiones de biblioteca a través de <code>@use</code> . <br><br>  No es posible (por el momento) "enlazar" las configuraciones juntas, manteniéndolas editables, pero puede ajustar el módulo configurado y transferirlo como un nuevo módulo. <br><br><h2>  Transferencia de archivos con <code>@forward</code> </h2><br>  No siempre necesitamos usar el archivo y referirnos a sus miembros.  A veces solo queremos pasarlo a importaciones posteriores.  Supongamos que tenemos varios archivos asociados con formularios y queremos conectarlos todos juntos como un espacio de nombres.  Podemos hacer esto con <code>@forward</code> : <br><br><pre> <code class="css hljs"><span class="hljs-comment"><span class="hljs-comment">/* forms/_index.scss */</span></span> @<span class="hljs-keyword"><span class="hljs-keyword">forward</span></span> <span class="hljs-string"><span class="hljs-string">'input'</span></span>; @<span class="hljs-keyword"><span class="hljs-keyword">forward</span></span> <span class="hljs-string"><span class="hljs-string">'textarea'</span></span>; @<span class="hljs-keyword"><span class="hljs-keyword">forward</span></span> <span class="hljs-string"><span class="hljs-string">'select'</span></span>; @<span class="hljs-keyword"><span class="hljs-keyword">forward</span></span> <span class="hljs-string"><span class="hljs-string">'buttons'</span></span>;</code> </pre><br>  Los miembros de dichos archivos reenviados no están disponibles en el documento actual y no se crea ningún espacio de nombres, pero estas variables, funciones y mixins estarán disponibles cuando otro archivo los conecte a través de <code>@use</code> o <code>@use</code> toda la colección a través de <code>@forward</code> .  Si los archivos individuales enviados contienen CSS real, también se transmitirán sin generarlos directamente hasta que se use el paquete.  En esta etapa, todo esto se considerará como un módulo con un espacio de nombres: <br><br><pre> <code class="css hljs"><span class="hljs-comment"><span class="hljs-comment">/* styles.scss */</span></span> @<span class="hljs-keyword"><span class="hljs-keyword">use</span></span> <span class="hljs-string"><span class="hljs-string">'forms'</span></span>; <span class="hljs-comment"><span class="hljs-comment">/*        `forms` */</span></span></code> </pre><br>  <b>Nota</b> : Si le pide a Sass que adjunte una carpeta, buscará el <code>index</code> o el archivo <code>_index</code> en ella. <br><br>  Por defecto, todos los miembros públicos serán reenviados junto con el módulo.  Pero podemos ser más selectivos utilizando las condiciones de <code>show</code> y <code>hide</code> y especificando miembros específicos que queremos agregar o excluir. <br><br><pre> <code class="css hljs"><span class="hljs-comment"><span class="hljs-comment">/*    `border()`   `$border-color`   `input` */</span></span> @<span class="hljs-keyword"><span class="hljs-keyword">forward</span></span> <span class="hljs-string"><span class="hljs-string">'input'</span></span> show border, $border-color; <span class="hljs-comment"><span class="hljs-comment">/*     `buttons`    `gradient()` */</span></span> @<span class="hljs-keyword"><span class="hljs-keyword">forward</span></span> <span class="hljs-string"><span class="hljs-string">'buttons'</span></span> hide gradient;</code> </pre><br>  <b>Nota</b> : cuando las funciones y los mixins tienen un nombre común, se agregan y se ocultan también juntos. <br><br>  Para aclarar las fuentes o evitar conflictos de nombres de módulos reenviados, podemos agregar prefijos a los miembros del archivo conectado usando <code>as</code> : <br><br><pre> <code class="css hljs"><span class="hljs-comment"><span class="hljs-comment">/* forms/_index.scss */</span></span> <span class="hljs-comment"><span class="hljs-comment">/* @forward "&lt;url&gt;" as &lt;prefix&gt;-*; */</span></span> <span class="hljs-comment"><span class="hljs-comment">/* ,      `background()` */</span></span> @<span class="hljs-keyword"><span class="hljs-keyword">forward</span></span> <span class="hljs-string"><span class="hljs-string">'input'</span></span> as input-*; @<span class="hljs-keyword"><span class="hljs-keyword">forward</span></span> <span class="hljs-string"><span class="hljs-string">'buttons'</span></span> as btn-*; <span class="hljs-comment"><span class="hljs-comment">/* style.scss */</span></span> @<span class="hljs-keyword"><span class="hljs-keyword">use</span></span> <span class="hljs-string"><span class="hljs-string">'forms'</span></span>; @<span class="hljs-keyword"><span class="hljs-keyword">include</span></span> forms.input-background(); @<span class="hljs-keyword"><span class="hljs-keyword">include</span></span> forms.btn-background();</code> </pre><br>  Y, si es necesario, siempre podemos usar a través de <code>@use</code> y <code>@forward</code> el mismo módulo a través de <code>@forward</code> , agregando ambas reglas: <br><br><pre> <code class="css hljs">@<span class="hljs-keyword"><span class="hljs-keyword">forward</span></span> <span class="hljs-string"><span class="hljs-string">'forms'</span></span>; @<span class="hljs-keyword"><span class="hljs-keyword">use</span></span> <span class="hljs-string"><span class="hljs-string">'forms'</span></span>;</code> </pre><br>  Esto es especialmente útil si desea preconfigurar la biblioteca o agregar herramientas adicionales antes de transferirla a otros archivos.  Esto puede ayudar a simplificar las rutas de conexión: <br><br><pre> <code class="css hljs"><span class="hljs-comment"><span class="hljs-comment">/* _tools.scss */</span></span> <span class="hljs-comment"><span class="hljs-comment">/*        */</span></span> @<span class="hljs-keyword"><span class="hljs-keyword">use</span></span> <span class="hljs-string"><span class="hljs-string">'accoutrement/sass/tools'</span></span> with ( $font-path: <span class="hljs-string"><span class="hljs-string">'../fonts/'</span></span>, ); <span class="hljs-comment"><span class="hljs-comment">/*    */</span></span> @<span class="hljs-keyword"><span class="hljs-keyword">forward</span></span> <span class="hljs-string"><span class="hljs-string">'accoutrement/sass/tools'</span></span>; <span class="hljs-comment"><span class="hljs-comment">/* -  ... */</span></span> <span class="hljs-comment"><span class="hljs-comment">/* _anywhere-else.scss */</span></span> <span class="hljs-comment"><span class="hljs-comment">/*      */</span></span> @<span class="hljs-keyword"><span class="hljs-keyword">use</span></span> <span class="hljs-string"><span class="hljs-string">'tools'</span></span>;</code> </pre><br>  Tanto <code>@use</code> como <code>@forward</code> deben declararse en la raíz del documento (no anidado) y al comienzo del archivo.  Solo pueden aparecer <code>@charset</code> y definiciones de variables simples antes de las directivas de importación. <br><br><h2>  Transición a un sistema modular. </h2><br>  Para probar la nueva sintaxis, creé una nueva biblioteca Sass de código abierto ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Cascading Color Systems</a> ) y un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">nuevo sitio para mi grupo</a> , ambos todavía en desarrollo.  Necesitaba comprender los módulos desde el punto de vista del autor de la biblioteca y desde el punto de vista del desarrollador del sitio.  Comencemos con la experiencia del "usuario final" al escribir estilos de sitio utilizando la sintaxis del módulo ... <br><br><h3>  Soporte y estilos de escritura </h3><br>  Usar los módulos en el sitio fue divertido.  La nueva sintaxis admite la arquitectura de código que ya uso.  Todas mis importaciones de configuraciones y herramientas globales están en el mismo directorio (lo llamo <code>config</code> ) con un archivo de índice que transfiere todo lo que necesito: <br><br><pre> <code class="css hljs"><span class="hljs-comment"><span class="hljs-comment">/* config/_index.scss */</span></span> @<span class="hljs-keyword"><span class="hljs-keyword">forward</span></span> <span class="hljs-string"><span class="hljs-string">'tools'</span></span>; @<span class="hljs-keyword"><span class="hljs-keyword">forward</span></span> <span class="hljs-string"><span class="hljs-string">'fonts'</span></span>; @<span class="hljs-keyword"><span class="hljs-keyword">forward</span></span> <span class="hljs-string"><span class="hljs-string">'scale'</span></span>; @<span class="hljs-keyword"><span class="hljs-keyword">forward</span></span> <span class="hljs-string"><span class="hljs-string">'colors'</span></span>;</code> </pre><br>  Al desarrollar otras partes del sitio, puedo importar estas herramientas y configuraciones donde las necesite: <br><br><pre> <code class="css hljs"><span class="hljs-comment"><span class="hljs-comment">/* layout/_banner.scss */</span></span> @<span class="hljs-keyword"><span class="hljs-keyword">use</span></span> <span class="hljs-string"><span class="hljs-string">'../config'</span></span>; <span class="hljs-selector-class"><span class="hljs-selector-class">.page-title</span></span> { @include config.font-family('header'); }</code> </pre><br>  Incluso funciona junto con mis bibliotecas existentes, como <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Accoutrement</a> y <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Herman</a> , que todavía usan la antigua sintaxis <code>@import</code> .  Dado que la regla <code>@import</code> no se reemplazará en todas partes a la vez, los desarrolladores de Sass han dado algo de tiempo para la transición.  Los módulos están disponibles ahora, pero <code>@import</code> no <code>@import</code> o dos años más y se eliminarán del idioma solo un año después.  Al mismo tiempo, los dos sistemas funcionarán juntos de cualquier manera: <br><br><ul><li>  Si ejecutamos <code>@import</code> para un archivo que contiene la nueva sintaxis <code>@use/@forward</code> , solo se importarán los miembros públicos sin un espacio de nombres. </li><li>  Si ejecutamos <code>@use</code> o <code>@forward</code> para un archivo que contiene la antigua sintaxis <code>@import</code> , obtendremos acceso a todas las importaciones anidadas como un solo espacio de nombres. </li></ul><br>  Esto significa que puede comenzar a usar de inmediato la nueva sintaxis del módulo, sin esperar el lanzamiento de una nueva versión de sus bibliotecas favoritas: ¡y puedo pasar un tiempo actualizando todas mis bibliotecas! <br><br><h3>  Herramienta de migración </h3><br>  La actualización no tardará mucho si utilizamos la herramienta de migración creada por Jennifer Thakar.  Se puede instalar usando NPM, Chocolatey o Homebrew: <br><br><pre> <code class="bash hljs">npm install -g sass-migrator choco install sass-migrator brew install sass/sass/migrator</code> </pre><br>  Esta no es una herramienta única para migrar a módulos.  Ahora que Sass ha vuelto al desarrollo activo (ver más abajo), la herramienta de migración también recibirá actualizaciones periódicas para ayudar a portar cada nueva característica.  Es una buena idea instalar esta herramienta a nivel mundial y guardarla para su uso futuro. <br><br>  El migrador se puede iniciar desde la línea de comandos y, con suerte, se agregará a aplicaciones de terceros como CodeKit y Scout.  Apunte a un único archivo Sass, por ejemplo <code>style.scss</code> y dígale qué migraciones aplicar.  Por el momento, solo hay una migración llamada <code>module</code> : <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># sass-migrator &lt;migration&gt; &lt;entrypoint.scss...&gt; sass-migrator module style.scss</span></span></code> </pre><br>  De manera predeterminada, el migrador solo actualiza un archivo, pero en la mayoría de los casos queremos actualizar el archivo principal y todas sus dependencias: cualquier elemento conectado a través de <code>@import</code> , <code>@forward</code> o <code>@use</code> .  Podemos hacer esto especificando cada archivo individualmente o simplemente agregando la bandera <code>--migrate-deps</code> . <br><br><pre> <code class="bash hljs">sass-migrator --migrate-deps module style.scss</code> </pre><br>  Para una ejecución de prueba, podemos agregar <code>--dry-run --verbose</code> (o en forma abreviada <code>-nv</code> ) y ver los resultados sin cambiar los archivos de origen.  Hay una serie de otras opciones que podemos usar para configurar la migración, incluso hay una diseñada específicamente para ayudar a los autores de bibliotecas a eliminar espacios de nombres antiguos creados manualmente, pero no los describiré aquí.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">La herramienta de migración está completamente documentada</a> en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">el sitio web de Sass</a> . <br><br><h3>  Actualización de bibliotecas publicadas </h3><br>  Encontré varios problemas en el lado de la biblioteca, en particular, cuando intenté hacer que las configuraciones de usuario estuvieran disponibles para varios archivos y encontrar una solución para las configuraciones de "cadena" que faltan.  Los errores relacionados con los pedidos pueden ser difíciles de depurar, pero los resultados merecen la pena y creo que pronto veremos algunas soluciones adicionales.  Todavía necesito experimentar con la herramienta de migración en paquetes complejos, y tal vez escribir un artículo adicional para autores de bibliotecas. <br><br>  Lo importante que debe saber en este momento es que Sass nos proporcionó protección durante la transición.  Las antiguas importaciones y los módulos no solo pueden funcionar juntos, sino que también podemos crear archivos " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">solo de importación</a> " para proporcionar un trabajo más conveniente a los usuarios que aún conectan nuestras bibliotecas a través de <code>@import</code> .  En la mayoría de los casos, esta será una versión alternativa del archivo del paquete principal, y desea que estén cerca de: <code>&lt;name&gt;.scss</code> para usuarios del módulo y <code>&lt;name&gt;.import.scss</code> para usuarios antiguos.  Cada vez que el usuario llama a <code>@import &lt;name&gt;</code> , carga la <code>.import</code> archivo: <br><br><pre> <code class="css hljs"><span class="hljs-comment"><span class="hljs-comment">/*  `_forms.scss` */</span></span> @<span class="hljs-keyword"><span class="hljs-keyword">use</span></span> <span class="hljs-string"><span class="hljs-string">'forms'</span></span>; <span class="hljs-comment"><span class="hljs-comment">/*  `_forms.import.scss` */</span></span> @<span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-string"><span class="hljs-string">'forms'</span></span>;</code> </pre><br><br>  Esto es especialmente útil para agregar prefijos para desarrolladores que no usan módulos: <br><br><pre> <code class="css hljs"><span class="hljs-comment"><span class="hljs-comment">/* _forms.import.scss */</span></span> <span class="hljs-comment"><span class="hljs-comment">/*       */</span></span> @<span class="hljs-keyword"><span class="hljs-keyword">forward</span></span> <span class="hljs-string"><span class="hljs-string">'forms'</span></span> as forms-*;</code> </pre><br><br><h2>  Sass Update </h2><br>  Puede recordar que Sass congeló la incorporación de nuevas funciones hace varios años, por lo que sus diversas implementaciones (LibSass, Node Sass, Dart Sass) se ponen al día con la implementación original de Ruby, de modo que al final se <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">abandona por completo</a> .  La congelación terminó el año pasado con varias características nuevas y <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">debates activos y desarrollo</a> en GitHub, pero no tan solemnemente.  Si se perdió estos lanzamientos, puede leer el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">blog de Sass</a> : <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Importaciones CSS y compatibilidad CSS</a> (Dart Sass v1.11) </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Parámetros de directivas de contenido y funciones de color (Dart Sass v1.15)</a> </li></ul><br>  Actualmente, Dart Sass es una implementación canónica y generalmente es la primera en introducir nuevas características.  Recomiendo cambiar a él si desea recibir lo último.  Puede <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">instalar Dart Sass</a> usando NPM, Chocolatey o Homebrew.  También funciona muy bien con <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">gulp-sass</a> . <br><br>  Al igual que CSS (comenzando con CSS3), ya no hay un solo número de versión para las nuevas versiones.  Todas las implementaciones de Sass funcionan con la misma especificación, pero cada una de ellas tiene un cronograma de lanzamiento y numeración únicos, que se refleja en la información de soporte en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">una hermosa y nueva documentación</a> diseñada por <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Jina</a> . <br><br><img src="https://res.cloudinary.com/css-tricks/image/upload/c_scale,w_1400,f_auto,q_auto/v1570122240/sass-modules-01_gapdpb.png" alt="imagen"><br><br>  Los módulos Sass están disponibles a partir <b>del 1 de octubre de 2019</b> en <b>Dart Sass 1.23.0</b> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/471924/">https://habr.com/ru/post/471924/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../471906/index.html">Los peligros de optimizaciones incorrectas</a></li>
<li><a href="../471908/index.html">La belleza inesperada de los números primos</a></li>
<li><a href="../471912/index.html">Aprender inglés: 7 formas prácticas de ampliar tu vocabulario</a></li>
<li><a href="../471914/index.html">Cómo funcionaba el sistema de gráficos Sega Mega Drive: procesador de visualización de video</a></li>
<li><a href="../471918/index.html">SwiftUI: Conocido</a></li>
<li><a href="../471928/index.html">Restaura automáticamente la última configuración guardada en los enrutadores Mikrotik</a></li>
<li><a href="../471930/index.html">Diseño atómico mitap: letras, colores, uniformes, equipo y dinero</a></li>
<li><a href="../471938/index.html">Notas de diseño: Extensiones útiles de Google Chrome en 2019</a></li>
<li><a href="../471940/index.html">Cómo reducir el riesgo de impagos en los asentamientos diferidos: factoring para empresas</a></li>
<li><a href="../471942/index.html">Según sus requisitos: prueba profesional de los SSD DC500R y DC500M de Kingston</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>