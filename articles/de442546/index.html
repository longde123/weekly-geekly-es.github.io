<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🈁 🔍 🙆🏿 Indizes in PostgreSQL - 2 😊 👰🏻 🍭</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Schnittstelle 
 Im ersten Artikel haben wir erwähnt, dass eine Zugriffsmethode Informationen über sich selbst bereitstellen muss. Schauen wir uns die ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Indizes in PostgreSQL - 2</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/postgrespro/blog/442546/"><h1>  Schnittstelle </h1><br>  Im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ersten Artikel</a> haben wir erwähnt, dass eine Zugriffsmethode Informationen über sich selbst bereitstellen muss.  Schauen wir uns die Struktur der Schnittstelle für Zugriffsmethoden an. <br><br><h2>  Eigenschaften </h2><br>  Alle Eigenschaften von Zugriffsmethoden werden in der Tabelle "pg_am" gespeichert ("am" steht für Zugriffsmethode).  Aus derselben Tabelle können wir auch eine Liste der verfügbaren Methoden abrufen: <br><br><pre><code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> amname <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pg_am;</code> </pre> <pre> <code class="plaintext hljs"> amname -------- btree hash gist gin spgist brin (6 rows)</code> </pre><br>  Obwohl der sequentielle Scan zu Recht auf Zugriffsmethoden bezogen werden kann, ist er aus historischen Gründen nicht in dieser Liste enthalten. <br><br>  In PostgreSQL-Versionen 9.5 und niedriger wurde jede Eigenschaft mit einem separaten Feld in der Tabelle "pg_am" dargestellt.  Ab Version 9.6 werden Eigenschaften mit speziellen Funktionen abgefragt und in mehrere Ebenen unterteilt: <br><br><ul><li>  Eigenschaften der Zugriffsmethode - "pg_indexam_has_property" </li><li>  Eigenschaften eines bestimmten Index - "pg_index_has_property" </li><li>  Eigenschaften einzelner Spalten des Index - "pg_index_column_has_property" </li></ul><br>  Die Zugriffsmethodenschicht und die Indexschicht sind mit Blick auf die Zukunft getrennt: Ab sofort haben alle Indizes, die auf einer Zugriffsmethode basieren, immer dieselben Eigenschaften. <br><a name="habracut"></a><br>  <strong>Die folgenden vier Eigenschaften entsprechen denen der Zugriffsmethode</strong> (anhand eines Beispiels für "btree"): <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> a.amname, p.name, pg_indexam_has_property(a.oid,p.name) <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pg_am a, unnest(<span class="hljs-keyword"><span class="hljs-keyword">array</span></span>[<span class="hljs-string"><span class="hljs-string">'can_order'</span></span>,<span class="hljs-string"><span class="hljs-string">'can_unique'</span></span>,<span class="hljs-string"><span class="hljs-string">'can_multi_col'</span></span>,<span class="hljs-string"><span class="hljs-string">'can_exclude'</span></span>]) p(<span class="hljs-type"><span class="hljs-type">name</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> a.amname = <span class="hljs-string"><span class="hljs-string">'btree'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">order</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> a.amname;</code> </pre><pre> <code class="plaintext hljs"> amname | name | pg_indexam_has_property --------+---------------+------------------------- btree | can_order | t btree | can_unique | t btree | can_multi_col | t btree | can_exclude | t (4 rows)</code> </pre><br><ul><li>  can_order. <br>  Mit der Zugriffsmethode können wir die Sortierreihenfolge für Werte angeben, wenn ein Index erstellt wird (gilt bisher nur für "btree"). </li><li>  can_unique <br>  Unterstützung der eindeutigen Einschränkung und des Primärschlüssels (gilt nur für "btree"). </li><li>  can_multi_col. <br>  Ein Index kann aus mehreren Spalten bestehen. </li><li>  can_exclude <br>  Unterstützung der Ausschlussbeschränkung EXCLUDE. </li></ul><br>  <strong>Die folgenden Eigenschaften beziehen sich auf einen Index</strong> (betrachten wir beispielsweise einen vorhandenen): <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> p.name, pg_index_has_property(<span class="hljs-string"><span class="hljs-string">'t_a_idx'</span></span>::<span class="hljs-type"><span class="hljs-type">regclass</span></span>,p.name) <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> unnest(<span class="hljs-keyword"><span class="hljs-keyword">array</span></span>[ <span class="hljs-string"><span class="hljs-string">'clusterable'</span></span>,<span class="hljs-string"><span class="hljs-string">'index_scan'</span></span>,<span class="hljs-string"><span class="hljs-string">'bitmap_scan'</span></span>,<span class="hljs-string"><span class="hljs-string">'backward_scan'</span></span> ]) p(<span class="hljs-type"><span class="hljs-type">name</span></span>);</code> </pre><pre> <code class="plaintext hljs"> name | pg_index_has_property ---------------+----------------------- clusterable | t index_scan | t bitmap_scan | t backward_scan | t (4 rows)</code> </pre><br><ul><li>  clusterfähig. <br>  Eine Möglichkeit, Zeilen entsprechend dem Index neu anzuordnen (Clustering mit dem gleichnamigen Befehl CLUSTER). </li><li>  index_scan. <br>  Unterstützung des Index-Scans.  Obwohl diese Eigenschaft seltsam erscheint, können nicht alle Indizes TIDs einzeln zurückgeben - einige geben Ergebnisse auf einmal zurück und unterstützen nur den Bitmap-Scan. </li><li>  bitmap_scan. <br>  Unterstützung des Bitmap-Scans. </li><li>  backward_scan. <br>  Das Ergebnis kann in umgekehrter Reihenfolge wie beim Erstellen des Index angegeben zurückgegeben werden. </li></ul><br>  <strong>Schließlich sind die folgenden Spalteneigenschaften:</strong> <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> p.name, pg_index_column_has_property(<span class="hljs-string"><span class="hljs-string">'t_a_idx'</span></span>::<span class="hljs-type"><span class="hljs-type">regclass</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,p.name) <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> unnest(<span class="hljs-keyword"><span class="hljs-keyword">array</span></span>[ <span class="hljs-string"><span class="hljs-string">'asc'</span></span>,<span class="hljs-string"><span class="hljs-string">'desc'</span></span>,<span class="hljs-string"><span class="hljs-string">'nulls_first'</span></span>,<span class="hljs-string"><span class="hljs-string">'nulls_last'</span></span>,<span class="hljs-string"><span class="hljs-string">'orderable'</span></span>,<span class="hljs-string"><span class="hljs-string">'distance_orderable'</span></span>, <span class="hljs-string"><span class="hljs-string">'returnable'</span></span>,<span class="hljs-string"><span class="hljs-string">'search_array'</span></span>,<span class="hljs-string"><span class="hljs-string">'search_nulls'</span></span> ]) p(<span class="hljs-type"><span class="hljs-type">name</span></span>);</code> </pre><pre> <code class="plaintext hljs"> name | pg_index_column_has_property --------------------+------------------------------ asc | t desc | f nulls_first | f nulls_last | t orderable | t distance_orderable | f returnable | t search_array | t search_nulls | t (9 rows)</code> </pre><br><ul><li>  asc, desc, nulls_first, nulls_last, orderable. <br>  Diese Eigenschaften beziehen sich auf die Reihenfolge der Werte (wir werden sie diskutieren, wenn wir eine Beschreibung der "btree" -Indizes erhalten). </li><li>  distance_orderable. <br>  Das Ergebnis kann in der durch die Operation festgelegten Sortierreihenfolge zurückgegeben werden (gilt bisher nur für GiST- und RUM-Indizes). </li><li>  Mehrweg <br>  Eine Möglichkeit, den Index ohne Zugriff auf die Tabelle zu verwenden, dh Unterstützung von Nur-Index-Scans. </li><li>  search_array. <br>  Unterstützung der Suche nach mehreren Werten mit dem Ausdruck " <em>indexed-field</em> IN ( <em>list_of_constants</em> )", der mit " <em>indexed-field</em> = ANY ( <em>array_of_constants</em> )" <em>identisch ist</em> . </li><li>  search_nulls. <br>  Eine Möglichkeit zur Suche nach IS NULL- und IS NOT NULL-Bedingungen. </li></ul><br>  Wir haben bereits einige der Eigenschaften im Detail besprochen.  Einige Eigenschaften sind für bestimmte Zugriffsmethoden spezifisch.  Wir werden solche Eigenschaften diskutieren, wenn wir diese spezifischen Methoden betrachten. <br><br><h2>  Betreiberklassen und Familien </h2><br>  Zusätzlich zu den Eigenschaften einer Zugriffsmethode, die von der beschriebenen Schnittstelle bereitgestellt wird, werden Informationen benötigt, um zu wissen, welche Datentypen und welche Operatoren die Zugriffsmethode akzeptiert.  Zu diesem Zweck führt PostgreSQL Konzepte für <em>Operatorklassen</em> und <em>Operatorfamilien ein</em> . <br><br>  Eine Operatorklasse enthält eine minimale Anzahl von Operatoren (und möglicherweise Hilfsfunktionen) für einen Index, um einen bestimmten Datentyp zu bearbeiten. <br><br>  Eine Operatorklasse ist in einigen Operatorfamilien enthalten.  Darüber hinaus kann eine gemeinsame Operatorfamilie mehrere Operatorklassen enthalten, wenn sie dieselbe Semantik haben.  Beispielsweise umfasst die Familie "integer_ops" die Klassen "int8_ops", "int4_ops" und "int2_ops" für die Typen "bigint", "integer" und "smallint" mit unterschiedlichen Größen, aber derselben Bedeutung: <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> opfname, opcname, opcintype::<span class="hljs-type"><span class="hljs-type">regtype</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pg_opclass opc, pg_opfamily opf <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> opf.opfname = <span class="hljs-string"><span class="hljs-string">'integer_ops'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> opc.opcfamily = opf.oid <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> opf.opfmethod = ( <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-type"><span class="hljs-type">oid</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pg_am <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> amname = <span class="hljs-string"><span class="hljs-string">'btree'</span></span> );</code> </pre><pre> <code class="plaintext hljs"> opfname | opcname | opcintype -------------+----------+----------- integer_ops | int2_ops | smallint integer_ops | int4_ops | integer integer_ops | int8_ops | bigint (3 rows)</code> </pre><br>  Ein weiteres Beispiel: Die Familie "datetime_ops" enthält Operatorklassen zum Bearbeiten von Datumsangaben (sowohl mit als auch ohne Zeit): <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> opfname, opcname, opcintype::<span class="hljs-type"><span class="hljs-type">regtype</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pg_opclass opc, pg_opfamily opf <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> opf.opfname = <span class="hljs-string"><span class="hljs-string">'datetime_ops'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> opc.opcfamily = opf.oid <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> opf.opfmethod = ( <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-type"><span class="hljs-type">oid</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pg_am <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> amname = <span class="hljs-string"><span class="hljs-string">'btree'</span></span> );</code> </pre><pre> <code class="plaintext hljs"> opfname | opcname | opcintype --------------+-----------------+----------------------------- datetime_ops | date_ops | date datetime_ops | timestamptz_ops | timestamp with time zone datetime_ops | timestamp_ops | timestamp without time zone (3 rows)</code> </pre><br>  Eine Operatorfamilie kann auch zusätzliche Operatoren enthalten, um Werte verschiedener Typen zu vergleichen.  Durch die Gruppierung in Familien kann der Planer einen Index für Prädikate mit Werten unterschiedlichen Typs verwenden.  Eine Familie kann auch andere Hilfsfunktionen enthalten. <br><br>  In den meisten Fällen müssen wir nichts über Operatorfamilien und -klassen wissen.  Normalerweise erstellen wir nur einen Index, wobei standardmäßig eine bestimmte Operatorklasse verwendet wird. <br><br>  Wir können jedoch die Operatorklasse explizit angeben.  Dies ist ein einfaches Beispiel dafür, wann die explizite Angabe erforderlich ist: In einer Datenbank mit einer anderen Sortierung als C unterstützt ein regulärer Index die LIKE-Operation nicht: <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">show</span></span> lc_collate;</code> </pre><pre> <code class="plaintext hljs"> lc_collate ------------- en_US.UTF-8 (1 row)</code> </pre><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">explain</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">costs</span></span> <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> t <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> b <span class="hljs-keyword"><span class="hljs-keyword">like</span></span> <span class="hljs-string"><span class="hljs-string">'A%'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> QUERY PLAN ----------------------------- Seq Scan on t Filter: (b ~~ 'A%'::text) (2 rows)</code> </pre><br>  Wir können diese Einschränkung überwinden, indem wir einen Index mit der Operatorklasse "text_pattern_ops" erstellen (beachten Sie, wie sich die Bedingung im Plan geändert hat): <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> t(b text_pattern_ops); postgres=# <span class="hljs-keyword"><span class="hljs-keyword">explain</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">costs</span></span> <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> t <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> b <span class="hljs-keyword"><span class="hljs-keyword">like</span></span> <span class="hljs-string"><span class="hljs-string">'A%'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> QUERY PLAN ---------------------------------------------------------------- Bitmap Heap Scan on t Filter: (b ~~ 'A%'::text) -&gt; Bitmap Index Scan on t_b_idx1 Index Cond: ((b ~&gt;=~ 'A'::text) AND (b ~&lt;~ 'B'::text)) (4 rows)</code> </pre><br><h2>  Systemkatalog </h2><br>  Zum Abschluss dieses Artikels stellen wir ein vereinfachtes Diagramm von Tabellen im Systemkatalog bereit, die in direktem Zusammenhang mit Operatorklassen und -familien stehen. <br><br><img src="https://habrastorage.org/webt/dq/pc/03/dqpc03qeinqqjzshzj9zsrcsecw.png"><br><br>  Es versteht sich von selbst, dass alle diese Tabellen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ausführlich beschrieben werden</a> . <br><br>  Der Systemkatalog ermöglicht es uns, Antworten auf eine Reihe von Fragen zu finden, ohne in die Dokumentation zu schauen.  Welche Datentypen kann beispielsweise eine bestimmte Zugriffsmethode bearbeiten? <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> opcname, opcintype::<span class="hljs-type"><span class="hljs-type">regtype</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pg_opclass <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> opcmethod = (<span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-type"><span class="hljs-type">oid</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pg_am <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> amname = <span class="hljs-string"><span class="hljs-string">'btree'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">order</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> opcintype::<span class="hljs-type"><span class="hljs-type">regtype</span></span>::<span class="hljs-type"><span class="hljs-type">text</span></span>;</code> </pre><pre> <code class="plaintext hljs"> opcname | opcintype ---------------------+----------------------------- abstime_ops | abstime array_ops | anyarray enum_ops | anyenum ...</code> </pre><br>  Welche Operatoren enthält eine Operatorklasse (und daher kann der Indexzugriff für eine Bedingung verwendet werden, die einen solchen Operator enthält)? <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> amop.amopopr::<span class="hljs-type"><span class="hljs-type">regoperator</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pg_opclass opc, pg_opfamily opf, pg_am am, pg_amop amop <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> opc.opcname = <span class="hljs-string"><span class="hljs-string">'array_ops'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> opf.oid = opc.opcfamily <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> am.oid = opf.opfmethod <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> amop.amopfamily = opc.opcfamily <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> am.amname = <span class="hljs-string"><span class="hljs-string">'btree'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> amop.amoplefttype = opc.opcintype;</code> </pre><pre> <code class="plaintext hljs"> amopopr ----------------------- &lt;(anyarray,anyarray) &lt;=(anyarray,anyarray) =(anyarray,anyarray) &gt;=(anyarray,anyarray) &gt;(anyarray,anyarray) (5 rows)</code> </pre><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Lesen Sie weiter</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de442546/">https://habr.com/ru/post/de442546/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de442530/index.html">Wireshark 3.0.0: Überprüfung von Innovationen</a></li>
<li><a href="../de442532/index.html">Videorecorder für die Videoüberwachung - kostenlos</a></li>
<li><a href="../de442534/index.html">Sprint Review: Scheiße bis großartig</a></li>
<li><a href="../de442536/index.html">Anschließen externer Postfächer an Zimbra</a></li>
<li><a href="../de442542/index.html">SmartMail Conf: Erste Mail.ru Mail-Konferenz zum maschinellen Lernen</a></li>
<li><a href="../de442548/index.html">Ameisenhügel oder Festung? Ich baue ein Haus zum Preis einer Wohnung. 4 Teil. Komfort oder Bedarf an Geräten zu Hause?</a></li>
<li><a href="../de442554/index.html">Was ist striktes Aliasing und warum sollten wir uns darum kümmern? Teil 1</a></li>
<li><a href="../de442556/index.html">Eine andere Geschichte des Fernen</a></li>
<li><a href="../de442558/index.html">„Wenn ein Produkt nicht benötigt wird, egal wie Sie es verpacken, macht es keinen Sinn“: Wie Technologieunternehmen an Schnittstellen arbeiten</a></li>
<li><a href="../de442560/index.html">Mash: Multithreading, Coroutinen, Async & Wait</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>