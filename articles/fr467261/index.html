<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ¤šğŸ¼ ğŸ¤œğŸ¿ ğŸ‘Œ Filetage correct dans Qt âš¡ï¸ ğŸ‘ ğŸŠ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Qt est un framework extrÃªmement puissant et pratique pour C ++. Mais cette commoditÃ© a un inconvÃ©nient: beaucoup de choses dans Qt se produisent cachÃ©...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Filetage correct dans Qt</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/467261/">  Qt est un framework extrÃªmement puissant et pratique pour C ++.  Mais cette commoditÃ© a un inconvÃ©nient: beaucoup de choses dans Qt se produisent cachÃ©es Ã  l'utilisateur.  Dans la plupart des cas, la fonctionnalitÃ© correspondante de Qt fonctionne Â«par magieÂ» et apprend Ã  l'utilisateur Ã  simplement prendre cette magie pour acquise.  Cependant, lorsque la magie se brise nÃ©anmoins, il est extrÃªmement difficile de reconnaÃ®tre et de rÃ©soudre un problÃ¨me qui apparaÃ®t soudainement Ã  un niveau apparemment plat. <br><br>  Cet article est une tentative de systÃ©matiser comment Qt "sous le capot" implÃ©mente le travail avec les flux et sur un certain nombre de piÃ¨ges non Ã©vidents associÃ©s aux limites de ce modÃ¨le. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Les bases</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">AffinitÃ© des threads, initialisation et leurs limites</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Fil principal, QCoreApplication et GUI</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Fil de rendu</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Conclusion</a> <br><br><a name="habracut"></a><a name="part1"></a><h3>  Les bases </h3><br>  CommenÃ§ons par les bases.  Dans Qt, tous les objets capables de gÃ©rer des signaux et des emplacements sont des descendants de la classe QObject.  De par leur conception, ces objets ne sont pas copiables et reprÃ©sentent logiquement certaines entitÃ©s individuelles qui Â«parlentÂ» entre elles - rÃ©agissent Ã  certains Ã©vÃ©nements et peuvent elles-mÃªmes gÃ©nÃ©rer des Ã©vÃ©nements.  En d'autres termes, QObject dans Qt implÃ©mente le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">modÃ¨le Actors</a> .  S'il est correctement implÃ©mentÃ©, tout programme Qt n'est rien de plus qu'un rÃ©seau de QObjects interagissant les uns avec les autres dans lequel toute la logique du programme Â«vitÂ». <br><br>  En plus d'un ensemble de QObjects, un programme Qt peut inclure des objets de donnÃ©es.  Ces objets ne peuvent pas gÃ©nÃ©rer et recevoir de signaux, mais peuvent Ãªtre copiÃ©s.  Par exemple, vous pouvez comparer QStringList et QStringListModel entre eux.  L'un d'eux est QObject et n'est pas copiable, mais peut interagir directement avec les objets d'interface utilisateur, l'autre est un conteneur de donnÃ©es copiable normal.  Ã€ leur tour, les objets contenant des donnÃ©es sont divisÃ©s en Â«mÃ©ta-types QtÂ» et tous les autres.  Par exemple, QStringList est un type mÃ©ta Qt, mais std :: list &lt;std :: string&gt; (sans gestes supplÃ©mentaires) ne l'est pas.  Le premier peut Ãªtre utilisÃ© dans n'importe quel contexte Qt-shnom (transmis via des signaux, se trouvant dans QVariant, etc.), mais nÃ©cessite une procÃ©dure d'enregistrement spÃ©ciale et la classe doit avoir un destructeur public, un constructeur de copie et un constructeur par dÃ©faut.  Les seconds sont des types C ++ arbitraires. <br><br><a name="part2"></a><h3>  Passez en toute transparence aux threads rÃ©els </h3><br>  Nous avons donc des Â«donnÃ©esÂ» conditionnelles et il existe un Â«codeÂ» conditionnel qui fonctionne avec elles.  Mais qui exÃ©cutera rÃ©ellement ce code?  Dans le modÃ¨le Qt, la rÃ©ponse Ã  cette question est explicitement dÃ©finie: chaque QObject est strictement attachÃ© Ã  un thread QThread qui, en fait, est engagÃ© dans la maintenance des emplacements et d'autres Ã©vÃ©nements de cet objet.  Un thread peut servir plusieurs QObjects Ã  la fois, ou pas du tout, mais QObject a toujours un thread parent et il en est toujours exactement un.  En fait, nous pouvons supposer que chaque QThread "possÃ¨de" un ensemble de QObject.  Dans la terminologie Qt, cela s'appelle l'affinitÃ© de thread.  Essayons de visualiser pour plus de clartÃ©: <br><br><img src="https://habrastorage.org/webt/zs/py/t2/zspyt2yti1t8-mr6k708rer0rao.png"><br><br>  Ã€ l'intÃ©rieur de chaque QThread se trouve une file d'attente de messages adressÃ©s aux objets que ce QThread Â«possÃ¨deÂ».  Le modÃ¨le Qt suppose que si nous voulons qu'un QObject entreprenne une action, alors nous Â«enverronsÂ» un message QEvent Ã  ce QObject: <br><br><pre><code class="cpp hljs">QCoreApplication::postEvent(QObject *receiver, QEvent *event, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> priority);</code> </pre> <br>  Dans cet appel thread-safe, Qt trouve le QThread auquel appartient l'objet rÃ©cepteur, Ã©crit le QEvent dans la file d'attente de messages de ce thread et rÃ©veille ce thread si nÃ©cessaire.  Il est prÃ©vu que le code exÃ©cutÃ© dans ce QThread Ã  un moment donnÃ© lira le message de la file d'attente et effectuera l'action correspondante.  Pour que cela se produise vraiment, le code de QThread doit entrer dans la boucle d'Ã©vÃ©nement QEventLoop, crÃ©ant l'objet appropriÃ© et l'appelant soit la mÃ©thode exec () soit la mÃ©thode processEvents ().  La premiÃ¨re option entre dans une boucle de traitement de message sans fin (avant que QEventLoop ne reÃ§oive l'Ã©vÃ©nement quit ()), la seconde se limite au traitement des messages qui se sont accumulÃ©s auparavant dans la file d'attente. <br><br><img src="https://habrastorage.org/webt/8x/ia/6o/8xia6o7i8wf0q5hoxkvzdjsl9xq.png"><br><br>  Il est facile de voir que les Ã©vÃ©nements de tous les objets appartenant Ã  un mÃªme thread sont traitÃ©s sÃ©quentiellement.  Si le traitement d'un Ã©vÃ©nement par un thread prend beaucoup de temps, tous les autres objets seront Â«gelÃ©sÂ» - leurs Ã©vÃ©nements s'accumuleront dans la file d'attente du flux, mais ne seront pas traitÃ©s.  Pour Ã©viter que cela ne se produise, Qt offre la possibilitÃ© d'un multitÃ¢che coopÃ©ratif - les gestionnaires d'Ã©vÃ©nements n'importe oÃ¹ peuvent Â«interrompre temporairementÂ» en crÃ©ant un nouveau QEventLoop et en lui passant le contrÃ´le.  Ã‰tant donnÃ© que le gestionnaire d'Ã©vÃ©nements a Ã©galement Ã©tÃ© prÃ©cÃ©demment appelÃ© Ã  partir de QEventLoop dans le flux, avec cette approche, une chaÃ®ne de boucles d'Ã©vÃ©nements Â«imbriquÃ©esÂ» les unes dans les autres est formÃ©e. <br><br><div class="spoiler">  <b class="spoiler_title">Quelques mots sur Event Dispatcher</b> <div class="spoiler_text">  Ã€ strictement parler, QEventLoop n'est rien de plus qu'un wrapper convivial sur une primitive dÃ©pendante du systÃ¨me de niveau infÃ©rieur appelÃ©e Event Dispatcher et implÃ©mente l'interface QAbstractEventDispatcher.  C'est lui qui effectue la collecte et le traitement rÃ©els des Ã©vÃ©nements.  Un thread ne peut avoir qu'un seul QAbstractEventDispatcher et il n'est installÃ© qu'une seule fois.  Entre autres choses, Ã  partir de Qt5, cela vous permet de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">remplacer</a> facilement <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">le rÃ©partiteur par un plus appropriÃ©</a> si nÃ©cessaire en ajoutant seulement 1 ligne Ã  l'initialisation du flux et sans toucher les endroits potentiellement nombreux oÃ¹ QEventLoop est utilisÃ©. </div></div><br>  Que comprend le concept d 'Â«Ã©vÃ©nementÂ» traitÃ© dans un tel cycle?  Bien connu de tous les employÃ©s de Qt, Â«signauxÂ» n'est qu'un exemple particulier, QEvent :: MetaCall.  Un tel QEvent stocke un pointeur sur les informations nÃ©cessaires pour identifier la fonction (slot) Ã  appeler et ses arguments.  Cependant, en plus des signaux dans Qt, il existe environ une centaine (!) D'autres Ã©vÃ©nements, dont une douzaine sont rÃ©servÃ©s aux Ã©vÃ©nements spÃ©ciaux Qt (ChildAdded, DeferredDelete, ParentChange) et le reste correspond Ã  divers messages du systÃ¨me d'exploitation. <br><br><div class="spoiler">  <b class="spoiler_title">Pourquoi y en a-t-il tant et pourquoi il Ã©tait impossible de se passer de signaux?</b> <div class="spoiler_text">  Le lecteur peut se demander: pourquoi y a-t-il tant d'Ã©vÃ©nements et pourquoi il Ã©tait impossible de s'en sortir avec un seul mÃ©canisme de signal pratique et universel?  Le fait est que diffÃ©rents signaux peuvent Ãªtre traitÃ©s trÃ¨s diffÃ©remment.  Par exemple, certains des signaux sont compressibles - si la file d'attente a dÃ©jÃ  un message brut de ce type (par exemple QEvent :: Paint), les messages suivants le modifient simplement.  D'autres signaux peuvent Ãªtre filtrÃ©s.  La prÃ©sence d'un petit nombre de QEvents standard et facilement identifiables simplifie considÃ©rablement le traitement correspondant.  De plus, le traitement QEvent dÃ» Ã  un dispositif sensiblement plus simple est gÃ©nÃ©ralement effectuÃ© un peu plus rapidement que le traitement d'un signal similaire. </div></div><br>  L'un des piÃ¨ges non Ã©vidents ici est que dans Qt, un flux, de maniÃ¨re gÃ©nÃ©rale, peut mÃªme ne pas avoir de Dispatcher, et donc pas un seul EventLoop.  Les objets appartenant Ã  ce flux ne rÃ©pondront pas aux Ã©vÃ©nements qui leur seront envoyÃ©s.  Puisque QThread :: run () appelle par dÃ©faut QThread :: exec () Ã  l'intÃ©rieur duquel le EventLoop standard vient d'Ãªtre implÃ©mentÃ©, ceux qui essaient souvent de dÃ©terminer leur propre version de run () hÃ©ritÃ©e de QThread sont souvent confrontÃ©s Ã  ce problÃ¨me.  Un cas d'utilisation similaire pour QThread est en principe tout Ã  fait valide et est mÃªme recommandÃ© dans la documentation, mais il va Ã  l'encontre de l'idÃ©e gÃ©nÃ©rale d'organiser le code dans Qt dÃ©crite ci-dessus et ne fonctionne souvent pas comme les utilisateurs <i>s'y attendent</i> .  Une erreur typique dans ce cas est une tentative d'arrÃªter un tel QThread personnalisÃ© en appelant QThread :: exit () ou quit ().  Ces deux fonctions envoient un message Ã  QEventLoop, mais s'il n'y a tout simplement pas de QEventLoop dans le flux, il n'y a naturellement personne pour les traiter.  En consÃ©quence, les utilisateurs inexpÃ©rimentÃ©s essayant de "rÃ©parer une classe cassÃ©e" commencent Ã  essayer d'utiliser un terminaison QThread :: "fonctionnel", ce qui est absolument impossible.  Gardez Ã  l'esprit - si vous redÃ©finissez run () et n'utilisez pas la boucle d'Ã©vÃ©nement standard, vous devrez fournir un mÃ©canisme pour quitter le flux vous-mÃªme - par exemple, en utilisant pour cela la fonction QThread :: requestInterruption () spÃ©cialement ajoutÃ©e.  Il est plus correct, cependant, de ne pas hÃ©riter de QThread si vous n'implÃ©mentez pas vraiment un nouveau type spÃ©cial de threads et d'utiliser le QtConcurrent spÃ©cialement crÃ©Ã© pour de tels scripts, ou de placer la logique dans un objet de travail spÃ©cial hÃ©ritÃ© de QObject, de placer ce dernier dans QThread standard et de gÃ©rer Travailleur utilisant des signaux. <br><br><a name="part3"></a><h3>  AffinitÃ© des threads, initialisation et leurs limites </h3><br>  Ainsi, comme nous l'avons dÃ©jÃ  compris, chaque objet dans Qt "appartient" Ã  un flux.  En mÃªme temps, une question logique se pose: Ã  laquelle, en fait, exactement?  Les conventions suivantes sont acceptÃ©es dans Qt: <br><br>  <b>1. Tous les Â«enfantsÂ» de tout Â«parentÂ» vivent toujours dans le mÃªme flux que le parent</b> <br><br>  C'est peut-Ãªtre la limitation la plus puissante du modÃ¨le de flux Qt, et les tentatives de le casser donnent souvent des rÃ©sultats trÃ¨s Ã©tranges pour l'utilisateur.  Par exemple, une tentative de crÃ©ation de setParent sur un objet vivant dans un autre thread dans Qt Ã©choue simplement en silence (un avertissement est Ã©crit sur la console).  Apparemment, ce compromis a Ã©tÃ© atteint en raison du fait que la suppression sans fil des Â«enfantsÂ» dans le cas de la mort d'un parent vivant dans un autre fil est trÃ¨s non triviale et sujette Ã  des bugs difficiles Ã  attraper.  Si vous souhaitez implÃ©menter une hiÃ©rarchie d'objets en interaction vivant dans diffÃ©rents flux, vous devrez organiser la suppression vous-mÃªme. <br><br>  <b>2. Un objet dont le parent n'est pas spÃ©cifiÃ© lors de la crÃ©ation vit dans le flux qui l'a crÃ©Ã©</b> <br><br>  Tout ici en mÃªme temps et simplement et en mÃªme temps n'est pas toujours Ã©vident.  Par exemple, en vertu de cette rÃ¨gle, QThread (en tant qu'objet) vit dans un thread diffÃ©rent du thread qu'il contrÃ´le lui-mÃªme (et en vertu de la rÃ¨gle 1, il ne peut possÃ©der aucun des objets crÃ©Ã©s dans ce thread).  Ou, si vous redÃ©finissez QThread :: run et crÃ©ez des descendants QObject Ã  l'intÃ©rieur, sans prendre de mesures spÃ©ciales (comme expliquÃ© dans le chapitre prÃ©cÃ©dent), les objets crÃ©Ã©s ne rÃ©pondront pas aux signaux. <br><br>  L'affinitÃ© de thread peut Ãªtre modifiÃ©e si nÃ©cessaire en appelant QObject :: moveToThread.  En vertu de la rÃ¨gle 1, seuls les Â«parentsÂ» de niveau supÃ©rieur (pour lesquels le parent == null) peuvent Ãªtre dÃ©placÃ©s, une tentative de dÃ©placer n'importe quel Â«enfantÂ» sera silencieusement ignorÃ©e.  Lorsque le Â«parentÂ» de niveau supÃ©rieur se dÃ©place, tous ses Â«enfantsÂ» se dÃ©placent Ã©galement vers un nouveau flux.  Curieusement, l'appel Ã  moveToThread (nullptr) est Ã©galement lÃ©gal et est un moyen de crÃ©er un objet avec une affinitÃ© de thread Â«nullÂ»;  ces objets ne peuvent recevoir aucun message. <br><br>  Vous pouvez obtenir le thread d'exÃ©cution "actuel" via un appel Ã  la fonction QThread :: currentThread (), le thread auquel l'objet est associÃ© - via un appel Ã  QObject :: thread () <br><br><div class="spoiler">  <b class="spoiler_title">Une question intÃ©ressante sur l'attention</b> <div class="spoiler_text">  A noter que la mise en Å“uvre de la fonctionnelle de propriÃ©tÃ© des objets et de stockage des QEvents qui leur sont adressÃ©s, Ã©videmment, nÃ©cessite le flux pour stocker quelque part les donnÃ©es correspondantes.  Dans le cas de Qt, la classe de base QThread est gÃ©nÃ©ralement impliquÃ©e dans l'extraction et la gestion de ces donnÃ©es.  Mais que se passe-t-il si vous crÃ©ez un QObject dans un thread std :: ou appelez la fonction QThread :: currentThread () Ã  partir de ce thread?  Il s'avÃ¨re que dans ce cas, Qt implicitement Â«en arriÃ¨re-planÂ» crÃ©era un objet wrapper spÃ©cial non propriÃ©taire QAdoptedThread.  Dans le mÃªme temps, il incombe Ã  l'utilisateur de s'assurer indÃ©pendamment que tous les objets d'un tel flux sont supprimÃ©s avant que le flux qui les a gÃ©nÃ©rÃ©s ne soit arrÃªtÃ©. <br></div></div><br><a name="part4"></a><h3>  Fil principal, QCoreApplication et GUI </h3><br>  Parmi tous les threads, Qt distinguera certainement un Â«thread principalÂ», qui dans le cas des applications d'interface utilisateur devient Ã©galement un thread d'interface graphique.  Dans ce thread rÃ©side l'objet QApplication (QCoreApplication / QGuiApplication) qui sert la boucle d'Ã©vÃ©nement principale orientÃ©e pour fonctionner avec les messages du systÃ¨me d'exploitation.  En vertu de la rÃ¨gle n Â° 2 de la section prÃ©cÃ©dente, dans la pratique, le thread "principal" sera celui qui a rÃ©ellement crÃ©Ã© l'objet QApplication, et comme dans de nombreux systÃ¨mes d'exploitation le "thread principal" a une signification particuliÃ¨re, la documentation recommande fortement de crÃ©er QApplication avec le tout premier objet dans son ensemble. Programmez Qt et faites-le immÃ©diatement aprÃ¨s le dÃ©marrage de l'application (== Ã  l'intÃ©rieur du premier thread du processus).  Pour obtenir un pointeur sur le thread principal de l'application, respectivement, vous pouvez utiliser une construction de la forme QCoreApplication :: instance () -&gt; thread ().  Cependant, purement techniquement, QApplication <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">peut Ã©galement Ãªtre suspendu sur un flux non principal ()</a> , par exemple, si l'interface Qt est crÃ©Ã©e dans une sorte de plug-in et dans de nombreux cas, cela fonctionnera correctement. <br><br>  En raison de la rÃ¨gle Â«les objets crÃ©Ã©s hÃ©ritent du thread actuelÂ», vous pouvez toujours travailler calmement sans dÃ©passer les limites d'un thread.  Tous les objets crÃ©Ã©s iront automatiquement au thread Â«principalÂ» pour l'entretien, oÃ¹ il y aura toujours une boucle d'Ã©vÃ©nement et (en raison de l'absence d'autres threads) il n'y aura jamais de problÃ¨mes de synchronisation.  MÃªme si vous travaillez avec un systÃ¨me plus complexe qui nÃ©cessite le multithreading, la plupart des objets tomberont trÃ¨s probablement dans le flux principal, Ã  l'exception de quelques-uns qui seront explicitement placÃ©s ailleurs.  C'est peut-Ãªtre prÃ©cisÃ©ment cette circonstance qui donne naissance Ã  l'apparente Â«magieÂ» dans laquelle les objets semblent fonctionner indÃ©pendamment sans aucun effort (car le multitÃ¢che coopÃ©ratif est mis en Å“uvre dans le flux) et en mÃªme temps ne nÃ©cessitent pas de synchronisation, de blocage ou similaires (parce que tout se passe dans un seul thread ) <br><br>  Outre le fait que le thread Â«principalÂ» est le Â«premierÂ» et contient la boucle de traitement d'Ã©vÃ©nement QCoreApplication principale, une autre caractÃ©ristique de limitation de Qt est que tous les objets liÃ©s Ã  l'interface graphique doivent Â«vivreÂ» dans ce thread.  Ceci est en partie une consÃ©quence de Legacy: du fait que dans un certain nombre de systÃ¨mes d'exploitation, toutes les opÃ©rations avec l'interface graphique ne peuvent se produire que dans le thread principal, Qt subdivise tous les objets en Â«widgetsÂ» et Â«non-widgetsÂ».  Un objet de type widget ne peut vivre que dans le thread principal, une tentative de "l'emporter" sur un tel objet dans n'importe quel autre s'embrasera automatiquement.  En vertu de cela, il existe mÃªme une mÃ©thode spÃ©ciale QObject :: isWidgetType () qui reflÃ¨te des diffÃ©rences internes assez profondes dans la mÃ©canique de travail avec de tels objets.  Mais il est intÃ©ressant de noter que dans le tout nouveau QtQuick, oÃ¹ ils ont essayÃ© de s'Ã©loigner de la bÃ©quille avec isWidgetType, le mÃªme problÃ¨me est restÃ© <br><br>  Quelle est la question?  Dans Qt5, les objets QML ne sont plus des widgets et peuvent Ãªtre rendus dans un thread sÃ©parÃ©.  Mais cela a conduit Ã  un autre problÃ¨me - des difficultÃ©s de synchronisation.  Le rendu des objets d'interface utilisateur est une Â«lectureÂ» de leur Ã©tat et doit Ãªtre cohÃ©rent: si nous essayons de changer l'Ã©tat d'un objet en mÃªme temps que son rendu, le rÃ©sultat de la Â«raceÂ» qui en rÃ©sulte peut ne pas nous plaire.  De plus, OpenGL autour duquel le "nouveau" graphique Qt est construit est extrÃªmement "affÃ»tÃ©" au fait que la formation des commandes de dessin est effectuÃ©e par un thread travaillant avec un Ã©tat global - le "contexte graphique" qui ne peut changer que comme une sÃ©rie d'opÃ©rations sÃ©quentielles.  Nous ne pouvons tout simplement pas dessiner simultanÃ©ment deux objets graphiques diffÃ©rents sur l'Ã©cran - ils seront toujours dessinÃ©s sÃ©quentiellement l'un aprÃ¨s l'autre.  En consÃ©quence, nous revenons Ã  la mÃªme solution - le rendu de l'interface utilisateur est affectÃ© Ã  un thread.  Un lecteur attentif, cependant, remarquera que ce thread ne doit pas Ãªtre le thread principal - et dans Qt5, le framework essaiera vraiment d'utiliser un thread de rendu sÃ©parÃ© pour cela. <br><br><a name="part5"></a><h3>  Fil de rendu </h3><br>  Dans le cadre du nouveau modÃ¨le Qt5, tout le rendu des objets a lieu dans un thread spÃ©cialement allouÃ© pour cela, le thread de rendu.  Dans le mÃªme temps, pour que cela ait du sens et ne se limite pas Ã  passer simplement d'un flux "principal" Ã  un autre, les objets sont implicitement divisÃ©s en un "front-end" que le programmeur voit et gÃ©nÃ©ralement un "back-end" cachÃ© de lui qui effectue rÃ©ellement le rendu rÃ©el.  Le back end vit dans le thread de rendu, tandis que le front end, thÃ©oriquement, peut vivre dans n'importe quel autre thread.  Il est supposÃ© que le frontal exÃ©cute le travail utile (le cas Ã©chÃ©ant) sous la forme d'un traitement d'Ã©vÃ©nements, tandis que la fonction principale n'est limitÃ©e que par le rendu.  En thÃ©orie, il s'avÃ¨re gagnant-gagnant: le dos Â«interrogeÂ» pÃ©riodiquement l'Ã©tat actuel des objets et les dessine sur l'Ã©cran, alors qu'il ne peut pas Ãªtre Â«stoppÃ©Â» par le fait que certains des objets Â«rÃ©flÃ©chissaientÂ» trop lors du traitement de l'Ã©vÃ©nement en raison du fait que cela un traitement lent se produit dans un autre thread.  Ã€ son tour, le flux de l'objet n'a pas besoin d'attendre les Â«rÃ©ponsesÂ» du pilote graphique confirmant la fin du rendu, et diffÃ©rents objets peuvent fonctionner dans diffÃ©rents flux. <br><br>  Mais comme je l'ai dÃ©jÃ  mentionnÃ© dans le chapitre prÃ©cÃ©dent, puisque nous avons un flux qui crÃ©e des donnÃ©es (un front) et un flux qui les lit (au dos), nous devons en quelque sorte les synchroniser.  Cette synchronisation dans Qt se fait par des verrous.  Le flux oÃ¹ vit le front est temporairement suspendu, suivi d'un appel de fonction spÃ©ciale (QQuickItem :: updatePaintNode (), QQuickFramebufferObject :: Renderer :: synchronize ()) dont la seule tÃ¢che est de copier l'objet pertinent pour visualiser l'Ã©tat d'avant en arriÃ¨re ".  Dans ce cas, l'appel d'une telle fonction se produit <i>Ã  l'intÃ©rieur du thread de rendu</i> , mais du fait que le thread oÃ¹ se trouve l'objet Ã  ce moment est arrÃªtÃ©, l'utilisateur peut librement travailler avec les donnÃ©es de l'objet comme si cela s'Ã©tait passÃ© Â«comme d'habitudeÂ», Ã  l'intÃ©rieur du flux auquel appartient l'objet. <br><br>  Tout va bien, tout va bien?  Malheureusement, non, et des moments assez Ã©vidents commencent ici.  Si nous prenons un verrou individuellement pour chaque objet, ce sera plutÃ´t lent car le thread de rendu sera obligÃ© d'attendre que ces objets finissent de traiter leurs Ã©vÃ©nements.  Le flux de Â«blocageÂ» oÃ¹ se trouve l'objet est Â«blocageÂ» et rendu.  De plus, une Â«dÃ©synchronisationÂ» deviendra possible lorsque, lorsque deux objets sont modifiÃ©s simultanÃ©ment, l'un sera dessinÃ© dans le cadre N et l'autre sera dessinÃ© uniquement dans le cadre N + 1.  Il serait prÃ©fÃ©rable de ne prendre le verrou qu'une seule fois et pour tous les objets Ã  la fois et uniquement lorsque nous sommes sÃ»rs que ce verrouillage rÃ©ussira. <br><br>  Qu'est-ce qui a Ã©tÃ© implÃ©mentÃ© pour rÃ©soudre ce problÃ¨me dans Qt?  PremiÃ¨rement, il a Ã©tÃ© dÃ©cidÃ© que tous les objets "graphiques" d'une fenÃªtre vivraient dans un mÃªme flux.  Ainsi, pour dessiner une fenÃªtre et verrouiller tous les objets qu'elle contient, il suffit d'arrÃªter ce flux seul.  DeuxiÃ¨mement, le thread avec des objets d'interface utilisateur initie le verrou pour la mise Ã  jour du back-end, envoyant un message au thread de rendu sur la nÃ©cessitÃ© de se synchroniser et de s'arrÃªter (QSGThreadedRenderLoop :: polishAndSync si quelqu'un est intÃ©ressÃ©).  Cela garantit que le thread de rendu n'attendra jamais un flux frontal.  S'il se "bloque" soudainement, le thread de rendu continuera simplement Ã  dessiner "l'ancien" Ã©tat des objets sans recevoir de messages sur la nÃ©cessitÃ© de mettre Ã  jour.  Cela donne vraiment lieu Ã  des bugs assez amusants de la forme Â«si pour une raison quelconque le rendu ne peut pas dessiner la fenÃªtre immÃ©diatement, le thread principal se figeÂ», mais en gÃ©nÃ©ral c'est un compromis raisonnable.  Ã€ partir de QtQuick 2.0, un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">certain nombre d'objets "animÃ©s"</a> peuvent mÃªme Ãªtre "remplis" dans le fil de rendu afin que l'animation puisse Ã©galement continuer Ã  fonctionner si le fil principal est "pensÃ©". <br><br><img src="https://habrastorage.org/getpro/habr/post_images/bc0/250/3da/bc02503da9d76ff4b66ae038ce3cf81f.png"><br><br>  Cependant, la consÃ©quence pratique de cette solution est que tous les objets d'interface utilisateur doivent de toute faÃ§on vivre dans le mÃªme thread.  Dans le cas d'anciens widgets, dans le thread "principal", dans le cas de nouveaux objets Qt Quick, dans le thread d'objet QQuickWindow qui les possÃ¨de.  La derniÃ¨re rÃ¨gle est assez Ã©lÃ©gamment battue - pour dessiner un QQuickItem, il doit faire de setParent le QQuickWindow correspondant qui, comme dÃ©jÃ  discutÃ©, garantit que l'objet se dÃ©place vers le flux correspondant ou que l'appel setParent Ã©choue. <br><br>  Et maintenant, hÃ©las, une mouche dans la pommade: bien que diffÃ©rents QQuickWindow puissent thÃ©oriquement vivre dans diffÃ©rents flux, cela nÃ©cessite en pratique l'envoi prÃ©cis de messages du systÃ¨me d'exploitation Ã  eux et dans Qt aujourd'hui, il n'est pas implÃ©mentÃ©.  Dans Qt 5.13, par exemple, QCoreApplication essaie de communiquer avec QQuickWindow via sendEvent en exigeant que le rÃ©cepteur et la partie Ã©mettrice soient dans le mÃªme thread (au lieu de postEvent qui permet aux threads d'Ãªtre diffÃ©rents).  Par consÃ©quent, dans la pratique, QQuickWindow ne fonctionne correctement que dans un thread GUI et, par consÃ©quent, tous les objets QtQuick vivent au mÃªme endroit.  Par consÃ©quent, malgrÃ© la prÃ©sence du thread de rendu, presque tous les objets liÃ©s Ã  l'interface graphique disponibles pour l'utilisateur vivent toujours dans le mÃªme thread GUI.  Peut-Ãªtre que cela va changer dans Qt 6. <br><br>  En plus de ce qui prÃ©cÃ¨de, il convient Ã©galement de se rappeler que, puisque Qt fonctionne sur de nombreuses plates-formes diffÃ©rentes (y compris celles qui ne prennent pas en charge le multithreading), le cadre fournit un nombre dÃ©cent de solutions de secours et, dans certains cas, la fonctionnalitÃ© du fil de rendu est en fait exÃ©cutÃ©e par le mÃªme fil gui .  Dans ce cas, l'interface utilisateur entiÃ¨re, y compris le rendu, vit dans un seul thread et le problÃ¨me de synchronisation disparaÃ®t automatiquement.  La situation est similaire avec l'ancienne interface utilisateur basÃ©e sur un widget de style Qt4.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Si vous le souhaitez, vous pouvez faire fonctionner Qt dans ce mode "monothread" en dÃ©finissant la variable d'environnement QSG_RENDER_LOOP sur l'option appropriÃ©e. </font></font><br><br><a name="part6"></a><h3>  Conclusion </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Qt est un framework Ã©norme et complexe, et travailler avec des threads reflÃ¨te une partie de cette complexitÃ©. </font><font style="vertical-align: inherit;">Mais il a Ã©tÃ© conÃ§u trÃ¨s soigneusement, logiquement et avec compÃ©tence, donc lorsque vous comprenez plusieurs idÃ©es clÃ©s avec des flux dans Qt, il est assez simple de travailler sans erreurs. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Permettez-moi de vous rappeler Ã  nouveau les points principaux;</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Chaque objet possÃ¨de un thread qui le possÃ¨de, exÃ©cutant des gestionnaires de tous les Ã©vÃ©nements se produisant avec l'objet, y compris le traitement des signaux en file d'attente </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Si le thread "propriÃ©taire" de l'objet n'exÃ©cute pas Qt Event Loop, alors les objets lui appartenant ne recevront aucun message et le thread lui-mÃªme ne rÃ©pondra pas aux tentatives de lui dire exit () </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Les parents et les descendants vivent toujours dans le mÃªme flux. </font><font style="vertical-align: inherit;">Seul le parent de niveau supÃ©rieur peut Ãªtre transfÃ©rÃ© d'un flux Ã  l'autre. </font><font style="vertical-align: inherit;">La violation de cette rÃ¨gle peut entraÃ®ner l'Ã©chec silencieux de l'opÃ©ration setParent ou moveToThread</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Un objet dont le parent n'est pas spÃ©cifiÃ© devient la propriÃ©tÃ© du thread que cet objet a crÃ©Ã©. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Tous les objets GUI Ã  l'exception du back-end de rendu doivent vivre dans le flux GUI </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Le thread GUI est celui dans lequel l'objet QApplication a Ã©tÃ© crÃ©Ã© </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> J'espÃ¨re que cela vous aidera Ã  utiliser Qt plus efficacement et Ã  ne pas faire d'erreurs associÃ©es Ã  son modÃ¨le multi-thread. </font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr467261/">https://habr.com/ru/post/fr467261/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr467251/index.html">Otages COBOL et Math. partie 1</a></li>
<li><a href="../fr467253/index.html">Otages COBOL et Math. 2e partie</a></li>
<li><a href="../fr467255/index.html">Trois erreurs de sÃ©curitÃ© courantes que chaque dÃ©veloppeur React devrait connaÃ®tre</a></li>
<li><a href="../fr467257/index.html">Ne stockez pas tous vos Å“ufs dans le mÃªme panier Ã  la fois</a></li>
<li><a href="../fr467259/index.html">DPI (inspection SSL) contredit le sens de la cryptographie, mais les entreprises la mettent en Å“uvre</a></li>
<li><a href="../fr467263/index.html">Nous gagnons sur l'Ã©nergie solaire ou un revenu passif Ã  25% par an, une expÃ©rience pratique. 2e partie</a></li>
<li><a href="../fr467269/index.html">ModÃ¨les en sÃ©curitÃ© de l'information</a></li>
<li><a href="../fr467271/index.html">Programmeur de vocations, chimiste de profession</a></li>
<li><a href="../fr467275/index.html">Au jour du programmeur. Programmeur en 2019</a></li>
<li><a href="../fr467277/index.html">pg_stat_statements + pg_stat_activity + loq_query = pg_ash?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>