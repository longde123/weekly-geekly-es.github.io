<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üßôüèº üë©üèø‚Äçü§ù‚Äçüë©üèº üé´ Pig Flight u optimizaci√≥n de int√©rpretes de bytecode üìô üìã üè¥‚Äç‚ò†Ô∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content=""No importa cu√°nto lo intentes, no puedes hacer un caballo de carreras con un cerdo. Sin embargo, puedes hacer un cerdo m√°s r√°pido" (comentario en el ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Pig Flight u optimizaci√≥n de int√©rpretes de bytecode</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/badoo/blog/428878/"><p><img src="https://habrastorage.org/webt/bg/lp/cz/bglpczwnjg-u0usatiwfxggd-zi.jpeg"></p><br><blockquote>  "No importa cu√°nto lo intentes, no puedes hacer un caballo de carreras con un cerdo. Sin embargo, puedes hacer un cerdo m√°s r√°pido" (comentario en el c√≥digo fuente de Emax) </blockquote><p>  Todos saben que los cerdos no vuelan.  Igualmente popular es la opini√≥n de que los int√©rpretes de bytecode como t√©cnica para ejecutar lenguajes de alto nivel no pueden acelerarse sin el uso de una compilaci√≥n din√°mica que consume mucho tiempo. </p><br><p>  En la segunda parte de una serie de art√≠culos sobre int√©rpretes de c√≥digo de bytes, intentar√© mostrar con el ejemplo de una peque√±a m√°quina virtual apilada de la FDA (M√°quina virtual de cerdo) que no todo se pierde para los lechones trabajadores con ambiciones y que es muy posible acelerar dentro del marco del est√°ndar (en su mayor√≠a) C El trabajo de tales int√©rpretes es al menos una vez y media. </p><a name="habracut"></a><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Primera parte, introductoria</a> <br>  Segunda parte, optimizaci√≥n (actual) <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Tercera parte, aplicada</a> </p><br><h1 id="porosenokvm">  Cochinillo </h1><br><p>  Vamos a conocernos. </p><br><p>  <a href="">Piglet</a> VM es una m√°quina apilada ordinaria basada en un <a href="">ejemplo</a> de la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">primera parte de una</a> serie de art√≠culos.  Nuestro cerdo solo conoce un tipo de datos: una palabra de m√°quina de 64 bits, y todos los c√°lculos (enteros) se realizan en la pila con una profundidad m√°xima de 256 palabras de m√°quina.  Adem√°s de la pila, este lech√≥n tiene una memoria de trabajo de 65.536 palabras de m√°quina.  El resultado de la ejecuci√≥n del programa, una palabra de m√°quina, puede colocarse en el registro de resultados o simplemente enviarse a la salida est√°ndar (stdout). </p><br><p>  Todo el estado en la m√°quina Piglet VM se almacena en una sola estructura: </p><br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-comment"><span class="hljs-comment">/* Current instruction pointer */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> *ip; <span class="hljs-comment"><span class="hljs-comment">/* Fixed-size stack */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span> <span class="hljs-built_in"><span class="hljs-built_in">stack</span></span>[STACK_MAX]; <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span> *stack_top; <span class="hljs-comment"><span class="hljs-comment">/* Operational memory */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span> memory[MEMORY_SIZE]; <span class="hljs-comment"><span class="hljs-comment">/* A single register containing the result */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span> result; } vm;</code> </pre> <br><p>  Lo anterior nos permite atribuir esta m√°quina a m√°quinas virtuales de bajo nivel, casi toda la sobrecarga en la que recae el mantenimiento del ciclo principal del programa: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">interpret_result </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">vm_interpret</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint8_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *bytecode)</span></span></span><span class="hljs-function"> </span></span>{ vm_reset(bytecode); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (;;) { <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> instruction = NEXT_OP(); <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (instruction) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> OP_PUSHI: { <span class="hljs-comment"><span class="hljs-comment">/* get the argument, push it onto stack */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> arg = NEXT_ARG(); PUSH(arg); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> OP_ADD: { <span class="hljs-comment"><span class="hljs-comment">/* Pop 2 values, add 'em, push the result back to the stack */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span> arg_right = POP(); *TOS_PTR() += arg_right; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } <span class="hljs-comment"><span class="hljs-comment">/* * ... * Lots of other instruction handlers here * ... */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> OP_DONE: { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> SUCCESS; } <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ERROR_UNKNOWN_OPCODE; } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ERROR_END_OF_STREAM; }</code> </pre> <br><p>  El c√≥digo muestra que para cada c√≥digo de operaci√≥n, el piggy debe: </p><br><ol><li>  Recupere el c√≥digo de operaci√≥n del flujo de instrucciones. </li><li>  Aseg√∫rese de que el c√≥digo de operaci√≥n est√© en el rango v√°lido de valores de c√≥digo de operaci√≥n (esta l√≥gica es agregada por el compilador de C al generar el c√≥digo del interruptor). </li><li>  Ir a las instrucciones del cuerpo. </li><li>  Extraiga argumentos de instrucciones de la pila o decodifique un argumento de instrucciones ubicado directamente en el c√≥digo de bytes. </li><li>  Realizar una operaci√≥n </li><li>  Si hay un resultado del c√°lculo, col√≥quelo en la pila. </li><li>  Mueva el puntero de la instrucci√≥n actual a la siguiente. </li></ol><br><p>  La carga √∫til aqu√≠ solo se encuentra en el quinto p√°rrafo, el resto est√° sobrecargado: decodificando o recuperando instrucciones de la pila (cl√°usula 4), verificando el valor del c√≥digo de operaci√≥n (cl√°usula 2), volviendo repetidamente al comienzo del bucle principal y al siguiente salto condicional dif√≠cilmente predicho (cl√°usula 3). </p><br><p>  En resumen, el cerdo ha superado claramente el √≠ndice de masa corporal recomendado, y si queremos ponerlo en forma, tendremos que lidiar con todos estos excesos. </p><br><h1 id="svinskiy-yazyk-assemblera-i-resheto-eratosfena">  Lenguaje ensamblador de cerdos y tamiz de Erat√≥stenes </h1><br><p>  Primero, decidamos las reglas del juego. </p><br><p>  Escribir programas para una m√°quina virtual directamente en C es una mala idea, pero crear un lenguaje de programaci√≥n es mucho tiempo, por lo que decidimos limitarnos a un lenguaje ensamblador guarro. </p><br><p>  Un programa que calcula la suma de n√∫meros del 1 al 65,536 en este ensamblador se parece a esto: </p><br><pre> <code class="plaintext hljs"># sum numbers from 1 to 65535 # init the current sum and the index PUSHI 1 PUSHI 1 # stack s=1, i=1 STOREI 0 # stack: s=1 # routine: increment the counter, add it to the current sum incrementandadd: # check if index is too big LOADI 0 # stack: s, i ADDI 1 # stack: s, i+1 DUP # stack: s, i+1, i+1 GREATER_OR_EQUALI 65535 # stack: s, i+1, 1 or 0 JUMP_IF_TRUE done # stack: s, i+1 DUP # stack: s, i+1, i+1 STOREI 0 # stack: s, i+1 ADD # stack: s+i+1 JUMP incrementandadd done: DISCARD PRINT DONE</code> </pre> <br><p>  No Python, por supuesto, pero hay todo lo que necesitas para la felicidad del cerdo: comentarios, etiquetas, saltos condicionales e incondicionales, mnemot√©cnicos para obtener instrucciones y la capacidad de especificar argumentos directos a las instrucciones. </p><br><p>  Completo con la m√°quina "Piglet VM" hay ensamblador y desensamblador, que son valientes en esp√≠ritu y tienen mucho tiempo libre, los lectores pueden probar de forma independiente en la batalla. </p><br><p>  Los n√∫meros se suman muy r√°pidamente, as√≠ que para probar el rendimiento escrib√≠ otro programa: una implementaci√≥n ingenua del <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">tamiz de Erat√≥stenes</a> . </p><br><p>  De hecho, el lech√≥n se ejecuta bastante r√°pido de todos modos (sus instrucciones son similares a las de la m√°quina), por lo tanto, para obtener resultados claros, har√© cada medici√≥n durante cien inicios del programa. </p><br><p>  La primera versi√≥n de nuestro cerdo no optimizado funciona as√≠: </p><br><pre> <code class="plaintext hljs">&gt; ./pigletvm runtimes test/sieve-unoptimized.bin 100 &gt; /dev/null PROFILE: switch code finished took 545ms</code> </pre> <br><p>  ¬°Medio segundo!  La comparaci√≥n es ciertamente deshonesta, pero el mismo algoritmo de Python hace que cien ejecuciones sean un poco m√°s lentas: </p><br><pre> <code class="plaintext hljs">&gt; python test/sieve.py &gt; /dev/null 4.66692185402</code> </pre> <br><p>  4.5 segundos, o nueve veces m√°s lento.  Debemos rendir homenaje al lech√≥n: ¬°tiene la habilidad!  Bueno, ahora veamos si nuestro cerdo puede inflar la prensa. <br><img src="https://habrastorage.org/webt/ce/eq/ni/ceeqnik6-41cuvd3rwvkkuquoes.jpeg"></p><br><h1 id="uprazhnenie-pervoe-staticheskie-superinstrukcii">  Ejercicio uno: superinstrucciones est√°ticas </h1><br><p>  La primera regla del c√≥digo r√°pido es no hacer demasiado trabajo.  La segunda regla del c√≥digo r√°pido es nunca hacer demasiado trabajo.  Entonces, ¬øqu√© tipo de trabajo adicional hace Piglet VM? </p><br><p>  Observaci√≥n uno: el perfil de nuestro programa muestra que hay secuencias de instrucciones que son m√°s comunes que otras.  No atormentaremos mucho a nuestro cerdo y nos limitaremos a solo un par de instrucciones: </p><br><ol><li>  LOADI 0, ADD: coloque en la pila un n√∫mero de la memoria en la direcci√≥n 0 y agr√©guelo al n√∫mero en la parte superior de la pila. </li><li>  PUSHI 65536, GREATER_OR_EQUAL: coloque un n√∫mero en la pila y comp√°relo con el n√∫mero que estaba anteriormente en la parte superior de la pila, colocando el resultado de la comparaci√≥n (0 o 1) nuevamente en la pila. </li><li>  PUSHI 1, ADD: coloque un n√∫mero en la pila, agr√©guelo al n√∫mero que estaba anteriormente en la parte superior de la pila y coloque el resultado de la suma nuevamente en la pila. </li></ol><br><p>  Hay un poco m√°s de 20 instrucciones en la m√°quina Piglet VM, y se utiliza un byte completo para la codificaci√≥n: 256 valores.  Introducir nuevas instrucciones no es un problema.  Lo que haremos: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (;;) { <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> instruction = NEXT_OP(); <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (instruction) { <span class="hljs-comment"><span class="hljs-comment">/* * Other instructions here * */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> OP_LOADADDI: { <span class="hljs-comment"><span class="hljs-comment">/* get immediate argument as an memory address , add it to value from the address to the top * of the stack */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> addr = NEXT_ARG(); <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span> val = vm.memory[addr]; *TOS_PTR() += val; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> OP_GREATER_OR_EQUALI:{ <span class="hljs-comment"><span class="hljs-comment">/* get the immediate argument, compare it with the value from the address to the top of the stack */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span> arg_right = NEXT_ARG(); *TOS_PTR() = PEEK() &gt;= arg_right; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> OP_ADDI: { <span class="hljs-comment"><span class="hljs-comment">/* Add immediate value to the top of the stack */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> arg_right = NEXT_ARG(); *TOS_PTR() += arg_right; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } <span class="hljs-comment"><span class="hljs-comment">/* * Other instructions here * */</span></span> }</code> </pre><br><p>  Nada complicado  Veamos que sali√≥ de eso: </p><br><pre> <code class="plaintext hljs">&gt; ./pigletvm runtimes test/sieve.bin 100 &gt; /dev/null PROFILE: switch code finished took 410ms</code> </pre> <br><p>  Wow!  ¬°El c√≥digo es solo para tres nuevas instrucciones, y ganamos cien milisegundos! </p><br><p>  La ganancia aqu√≠ se logra debido al hecho de que nuestro piggy no realiza movimientos innecesarios al ejecutar tales instrucciones: el hilo de ejecuci√≥n no cae en el bucle principal, no se decodifica nada, y los argumentos de las instrucciones no vuelven a pasar por la pila. </p><br><p>  Esto se denomina superinstrucciones est√°ticas, ya que el programador de m√°quina virtual define las instrucciones adicionales de forma est√°tica en la etapa de desarrollo.  Esta es una t√©cnica simple y efectiva que todas las m√°quinas virtuales de lenguajes de programaci√≥n usan de una forma u otra. </p><br><p>  El principal problema con las superinstrucciones est√°ticas es que sin un programa espec√≠fico es imposible determinar qu√© instrucciones se deben combinar.  Los diferentes programas utilizan diferentes secuencias de instrucciones, y puede encontrar estas secuencias solo en la etapa de lanzamiento de un c√≥digo espec√≠fico. </p><br><p>  El siguiente paso podr√≠a ser la compilaci√≥n din√°mica de superinstrucciones en el contexto de un programa en particular, es decir, superinstrucciones din√°micas (en los a√±os 90 y principios de 2000, esta t√©cnica desempe√±√≥ el papel de una compilaci√≥n JIT primitiva). </p><br><p>  Es imposible crear instrucciones sobre la marcha en el marco de la C ordinaria, y nuestro lech√≥n con toda raz√≥n no lo considera una competencia honesta.  Afortunadamente, tengo un par de mejores ejercicios para √©l. </p><br><h1 id="uprazhnenie-vtoroe-proverka-intervala-znacheniy-opkodov">  Ejercicio dos: verificar el rango de valores del c√≥digo de operaci√≥n </h1><br><p>  Siguiendo nuestras reglas de c√≥digo r√°pido, una vez m√°s nos hacemos la eterna pregunta: ¬øqu√© no puedes hacer? </p><br><p>  Cuando nos familiarizamos con el dispositivo de la m√°quina Piglet VM, enumer√© todas las acciones que realiza la m√°quina virtual para cada c√≥digo de operaci√≥n.  Y el punto 2 (comprobar el valor del c√≥digo de operaci√≥n para que se ajuste al rango v√°lido de valores de cambio) es el m√°s sospechoso. </p><br><p>  Echemos un vistazo a c√≥mo GCC compila la construcci√≥n del interruptor: </p><br><ol><li>  Se construye una tabla de transici√≥n, es decir, una tabla que muestra el valor del c√≥digo de operaci√≥n en la direcci√≥n del c√≥digo que ejecuta el cuerpo de la instrucci√≥n. </li><li>  Se inserta un c√≥digo que verifica si el c√≥digo de operaci√≥n recibido se encuentra dentro del rango de todos los valores de cambio posibles y lo env√≠a a la etiqueta predeterminada si no hay un controlador para el c√≥digo de operaci√≥n. </li><li>  Se inserta el c√≥digo que va al controlador. </li></ol><br><p>  Pero, ¬øpor qu√© verificar el intervalo de valores para cada instrucci√≥n?  Creemos que el c√≥digo de operaci√≥n es correcto - terminando la ejecuci√≥n por la instrucci√≥n OP_DONE, o incorrecto - yendo m√°s all√° del c√≥digo de bytes.  La cola de la secuencia de c√≥digos de operaci√≥n est√° marcada con cero, y cero es el c√≥digo de operaci√≥n de la instrucci√≥n OP_ABORT, que completa la ejecuci√≥n del c√≥digo de bytes con un error. </p><br><p>  ¬°Resulta que esta verificaci√≥n no es necesaria en absoluto!  Y el lech√≥n deber√≠a poder transmitir esta idea al compilador.  Intentemos arreglar un poco el interruptor principal: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> instruction = NEXT_OP(); <span class="hljs-comment"><span class="hljs-comment">/* Let the compiler know that opcodes are always between 0 and 31 */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (instruction &amp; <span class="hljs-number"><span class="hljs-number">0x1f</span></span>) { <span class="hljs-comment"><span class="hljs-comment">/* All the instructions here */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">26</span></span> ... <span class="hljs-number"><span class="hljs-number">0x1f</span></span>: { <span class="hljs-comment"><span class="hljs-comment">/*Handle the remaining 5 non-existing opcodes*/</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ERROR_UNKNOWN_OPCODE; } }</code> </pre> <br><p>  Sabiendo que solo tenemos 26 instrucciones, imponemos una m√°scara de bits (el valor octal 0x1f es un 0b11111 binario que cubre el rango de valores de 0 a 31) en el c√≥digo de operaci√≥n y agregamos controladores a valores no utilizados en el rango de 26 a 31. </p><br><p>  Las instrucciones de bit son algunas de las m√°s baratas en la arquitectura x86, y ciertamente son m√°s baratas que las ramas condicionales problem√°ticas como la que usa la comprobaci√≥n de intervalos.  Te√≥ricamente, deber√≠amos ganar varios ciclos en cada instrucci√≥n ejecutable si el compilador comprende nuestra sugerencia. </p><br><p>  Por cierto, la forma de especificar el rango de valores en caso de que no sea C est√°ndar, sino una extensi√≥n GCC.  Pero para nuestro prop√≥sito, este c√≥digo es adecuado, especialmente porque no es dif√≠cil rehacerlo en varios controladores para cada uno de los valores innecesarios. </p><br><p>  Intentamos: </p><br><pre> <code class="plaintext hljs">&gt; ./pigletvm runtimes test/sieve.bin 100 &gt; /dev/null PROFILE: switch code finished took 437ms PROFILE: switch code (no range check) finished took 383ms</code> </pre> <br><p>  ¬°Otros 50 milisegundos!  Piglet, ¬°es como si te hubieras escuchado en tus hombros! .. </p><br><h1 id="uprazhnenie-trete-trassy">  Ejercicio tres: senderos </h1><br><p>  ¬øQu√© otros ejercicios pueden ayudar a nuestro lech√≥n?  El mayor ahorro de tiempo que obtuvimos gracias a las s√∫per instrucciones.  Y reducen el n√∫mero de salidas al ciclo principal y le permiten deshacerse de los costos generales correspondientes. </p><br><p>  El interruptor central es el principal problema para cualquier procesador con una ejecuci√≥n extraordinaria de instrucciones.  Los predictores de ramificaci√≥n modernos han aprendido a predecir incluso transiciones indirectas tan complejas, pero los puntos de ramificaci√≥n "borrosos" a lo largo del c√≥digo pueden ayudar al procesador a cambiar r√°pidamente de una instrucci√≥n a otra. </p><br><p>  Otro problema es la lectura byte por byte de c√≥digos de operaci√≥n y argumentos directos de bytecode.  Las m√°quinas f√≠sicas funcionan con una palabra de m√°quina de 64 bits y realmente no les gusta cuando el c√≥digo funciona con valores m√°s bajos. </p><br><p>  Los compiladores a menudo operan con <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">bloques b√°sicos</a> , es decir, secuencias de instrucciones sin ramas y etiquetas dentro.  El bloque base comienza desde el comienzo del programa o desde la etiqueta, y termina con el final del programa, la ramificaci√≥n condicional o un salto directo a la etiqueta que inicia el siguiente bloque base. </p><br><p>  Trabajar con unidades base tiene muchas ventajas, pero nuestro cerdo est√° interesado en su caracter√≠stica clave: las instrucciones dentro de la unidad base se ejecutan secuencialmente.  Ser√≠a genial aislar de alguna manera estos bloques base y seguir las instrucciones en ellos sin perder tiempo entrando en el bucle principal. </p><br><p>  En nuestro caso, incluso puede extender la definici√≥n de la unidad base a la pista.  La pista en t√©rminos de la m√°quina Piglet VM incluir√° todos los bloques base conectados secuencialmente (es decir, utilizando saltos incondicionales). </p><br><p>  Adem√°s de la ejecuci√≥n secuencial de instrucciones, ser√≠a bueno decodificar los argumentos directos de las instrucciones de antemano. </p><br><p>  Todo suena bastante aterrador y se asemeja a una compilaci√≥n din√°mica, que decidimos no usar.  El cerdo incluso dud√≥ un poco de su fuerza, pero en la pr√°ctica no result√≥ tan malo. </p><br><p>  Primero pensemos en c√≥mo puedes imaginar la instrucci√≥n incluida en la pista: </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">scode</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span> arg; trace_op_handler *handler; };</code> </pre> <br><p>  Aqu√≠ arg es el argumento predescodificado de la instrucci√≥n, y handler es un puntero a una funci√≥n que ejecuta la l√≥gica de la instrucci√≥n. </p><br><p>  Ahora la vista de cada rastro se ve as√≠: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> scode trace[MAX_TRACE_LEN];</code> </pre> <br><p>  Es decir, una traza es una secuencia de c√≥digos s de longitud limitada.  El cach√© de seguimiento en s√≠ dentro de la m√°quina virtual se ve as√≠: </p><br><pre> <code class="cpp hljs">trace trace_cache[MAX_CODE_LEN];</code> </pre> <br><p>  Esto es solo un conjunto de trazas con una longitud que no excede la longitud posible del c√≥digo de bytes.  La soluci√≥n es perezosa, para ahorrar memoria tiene sentido usar una tabla hash. </p><br><p>  Al comienzo del int√©rprete, el primer controlador de cada rastreo se compilar√°: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> trace_i = <span class="hljs-number"><span class="hljs-number">0</span></span>; trace_i &lt; MAX_CODE_LEN; trace_i++ ) vm_trace.trace_cache[trace_i][<span class="hljs-number"><span class="hljs-number">0</span></span>].handler = trace_compile_handler;</code> </pre> <br><p>  El bucle principal de int√©rprete ahora se ve as√≠: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(vm_trace.is_running) { scode *code = &amp;vm_trace.trace_cache[vm_trace.pc][<span class="hljs-number"><span class="hljs-number">0</span></span>]; code-&gt;handler(code); }</code> </pre> <br><p>  Un compilador de rastreo es un poco m√°s complicado, y adem√°s de construir un rastreo a partir de la instrucci√≥n actual, hace lo siguiente: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">trace_compile_handler</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(scode *trace_head)</span></span></span><span class="hljs-function"> </span></span>{ scode *trace_tail = trace_head; <span class="hljs-comment"><span class="hljs-comment">/* * Trace building here */</span></span> <span class="hljs-comment"><span class="hljs-comment">/* now, run the chain that has a trace_compile_handler replaced with proper instruction handler * function pointer */</span></span> trace_head-&gt;handler(trace_head); }</code> </pre><br><p>  Instructor de instrucciones normales: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">op_add_handler</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(scode *code)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span> arg_right = POP(); *TOS_PTR() += arg_right; <span class="hljs-comment"><span class="hljs-comment">/* * Call the next trace handler * */</span></span> <span class="hljs-comment"><span class="hljs-comment">/* scodes are located in an array so we can use pointer arithmetic to get the next handler */</span></span> code++; code-&gt;handler(code); }</code> </pre> <br><p>  Un controlador que no realiza ninguna llamada en la cola de la funci√≥n termina cada rastreo: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">op_done_handler</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(scode *code)</span></span></span><span class="hljs-function"> </span></span>{ (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>) code; vm_trace.is_running = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; vm_trace.error = SUCCESS; }</code> </pre> <br><p>  Todo esto, por supuesto, es m√°s complicado que agregar superinstrucciones, pero veamos si nos dio algo: </p><br><pre> <code class="plaintext hljs">&gt; ./pigletvm runtimes test/sieve.bin 100 &gt; /dev/null PROFILE: switch code finished took 427ms PROFILE: switch code (no range check) finished took 395ms PROFILE: trace code finished took 367ms</code> </pre> <br><p>  ¬°Hurra, otros 30 milisegundos! </p><br><p>  ¬øC√≥mo es eso?  En lugar de simplemente navegar por las etiquetas, hacemos cadenas de llamadas de controladores de instrucciones, dedicamos tiempo a las llamadas y a pasar argumentos, pero nuestro cerdito sigue corriendo por los senderos m√°s r√°pido que un simple interruptor con sus etiquetas. </p><br><p>  Esta ganancia en el rendimiento de la pista se logra debido a tres factores: </p><br><ol><li>  Predecir ramas dispersas en diferentes lugares del c√≥digo es f√°cil. </li><li>  Los argumentos de los controladores siempre se codifican previamente en una palabra de m√°quina completa, y esto se hace solo una vez, durante la compilaci√≥n de la traza. </li><li>  El compilador convierte las cadenas de funciones en una sola llamada a la primera funci√≥n del controlador, lo cual es posible debido a la optimizaci√≥n de la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">llamada de cola</a> . </li></ol><br><p>  Antes de resumir los resultados de nuestro entrenamiento, el lech√≥n y yo decidimos probar otra t√©cnica antigua para interpretar programas: el c√≥digo cosido. </p><br><h1 id="uprazhnenie-chetvertoe-shityy-kod">  Ejercicio cuatro: c√≥digo "cosido" </h1><br><p>  Cualquier cerdo interesado en la historia de los int√©rpretes escuch√≥ un c√≥digo roscado.  Hay muchas opciones para esta t√©cnica, pero todas se reducen a, en lugar de seguir una matriz de c√≥digos de operaci√≥n, siguiendo una matriz de, por ejemplo, punteros a funciones o etiquetas, sigui√©ndolas directamente sin un c√≥digo de operaci√≥n intermedio. </p><br><p>  Llamar a funciones es un negocio costoso y sin sentido en estos d√≠as;  la mayor√≠a de las otras versiones de c√≥digo cosido no se pueden realizar dentro del marco del est√°ndar C. Incluso la t√©cnica, que se discutir√° a continuaci√≥n, utiliza los extensos, pero no est√°ndar, punteros en C para las etiquetas. </p><br><p>  En la versi√≥n del c√≥digo cosido (c√≥digo enroscado de token en ingl√©s) que eleg√≠ para lograr nuestros objetivos de cerdo, guardamos el c√≥digo de bytes, pero antes de comenzar la interpretaci√≥n, creamos una tabla que muestra los c√≥digos de operaci√≥n de las instrucciones en la direcci√≥n de las etiquetas del manejador de instrucciones: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> *labels[] = { [OP_PUSHI] = &amp;&amp;op_pushi, [OP_LOADI] = &amp;&amp;op_loadi, [OP_LOADADDI] = &amp;&amp;op_loadaddi, [OP_STORE] = &amp;&amp;op_store, [OP_STOREI] = &amp;&amp;op_storei, [OP_LOAD] = &amp;&amp;op_load, [OP_DUP] = &amp;&amp;op_dup, [OP_DISCARD] = &amp;&amp;op_discard, [OP_ADD] = &amp;&amp;op_add, [OP_ADDI] = &amp;&amp;op_addi, [OP_SUB] = &amp;&amp;op_sub, [OP_DIV] = &amp;&amp;op_div, [OP_MUL] = &amp;&amp;op_mul, [OP_JUMP] = &amp;&amp;op_jump, [OP_JUMP_IF_TRUE] = &amp;&amp;op_jump_if_true, [OP_JUMP_IF_FALSE] = &amp;&amp;op_jump_if_false, [OP_EQUAL] = &amp;&amp;op_equal, [OP_LESS] = &amp;&amp;op_less, [OP_LESS_OR_EQUAL] = &amp;&amp;op_less_or_equal, [OP_GREATER] = &amp;&amp;op_greater, [OP_GREATER_OR_EQUAL] = &amp;&amp;op_greater_or_equal, [OP_GREATER_OR_EQUALI] = &amp;&amp;op_greater_or_equali, [OP_POP_RES] = &amp;&amp;op_pop_res, [OP_DONE] = &amp;&amp;op_done, [OP_PRINT] = &amp;&amp;op_print, [OP_ABORT] = &amp;&amp;op_abort, };</code> </pre> <br><p>  Preste atenci√≥n a los s√≠mbolos &amp;&amp;: estos son punteros a las etiquetas con los cuerpos de las instrucciones, la extensi√≥n m√°s no est√°ndar de GCC. </p><br><p>  Para comenzar a ejecutar el c√≥digo, simplemente haga clic en el puntero correspondiente al primer c√≥digo de operaci√≥n del programa: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">goto</span></span> *labels[NEXT_OP()];</code> </pre> <br><p>  No hay ciclo aqu√≠ y no lo habr√°, cada una de las instrucciones en s√≠ da un salto al siguiente controlador: </p><br><pre> <code class="cpp hljs">op_pushi: { <span class="hljs-comment"><span class="hljs-comment">/* get the argument, push it onto stack */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> arg = NEXT_ARG(); PUSH(arg); <span class="hljs-comment"><span class="hljs-comment">/* jump to the next instruction*/</span></span> <span class="hljs-keyword"><span class="hljs-keyword">goto</span></span> *labels[NEXT_OP()]; }</code> </pre> <br><p>  La ausencia de un interruptor "extiende" puntos de ramificaci√≥n a lo largo de los cuerpos de instrucciones, lo que en teor√≠a deber√≠a ayudar al predictor de ramificaciones en caso de ejecuci√≥n extraordinaria de instrucciones.  Es como si construy√©ramos el conmutador directamente en las instrucciones y formamos manualmente una tabla de transici√≥n. </p><br><p>  Esa es toda la t√©cnica.  Le gustaba el lech√≥n por su simplicidad.  Veamos qu√© pasa en la pr√°ctica: </p><br><pre> <code class="plaintext hljs">&gt; ./pigletvm runtimes test/sieve.bin 100 &gt; /dev/null PROFILE: switch code finished took 443ms PROFILE: switch code (no range check) finished took 389ms PROFILE: threaded code finished took 477ms PROFILE: trace code finished took 364ms</code> </pre> <br><p>  ¬°Uy!  ¬°Esta es la m√°s lenta de todas nuestras t√©cnicas!  Que paso  Ejecutemos las mismas pruebas, desactivando todas las optimizaciones de GCC: </p><br><pre> <code class="plaintext hljs">&gt; ./pigletvm runtimes test/sieve.bin 100 &gt; /dev/null PROFILE: switch code finished took 969ms PROFILE: switch code (no range check) finished took 940ms PROFILE: threaded code finished took 824ms PROFILE: trace code finished took 1169ms</code> </pre> <br><p>  Aqu√≠, el c√≥digo cosido funciona mejor. </p><br><p>  Tres factores juegan un papel aqu√≠: </p><br><ol><li>  El compilador de optimizaci√≥n mismo crear√° una tabla de conversi√≥n no peor que nuestra placa de etiquetas manual. </li><li>  Los compiladores modernos eliminan notablemente las llamadas a funciones adicionales. </li><li>  Comenzando alrededor de la generaci√≥n Haswell de procesadores Intel, los predictores de ramificaci√≥n han aprendido a predecir con precisi√≥n las transiciones a trav√©s de un √∫nico punto de ramificaci√≥n. </li></ol><br><p>  Seg√∫n la memoria anterior, esta t√©cnica todav√≠a se usa en el c√≥digo de, por ejemplo, el int√©rprete de Python VM, pero, francamente, en estos d√≠as ya es arca√≠smo. </p><br><p>  Perm√≠tanos resumir y evaluar finalmente los √©xitos logrados por nuestro cerdo. </p><br><h1 id="razbor-porosyachih-poletov">  Debriefing </h1><br><p><img src="https://habrastorage.org/webt/co/vy/6k/covy6k28ts8__ozuzuswtqpcora.jpeg"><br>  No estoy seguro de c√≥mo se puede llamar un vuelo, pero seamos sinceros, nuestro cerdito ha recorrido un largo camino desde 550 milisegundos durante cien carreras en el "tamiz" hasta los 370 milisegundos finales.  Utilizamos diferentes t√©cnicas: superinstrucciones, eliminaci√≥n de intervalos de comprobaci√≥n de valores, mec√°nica complicada de trazas y, finalmente, incluso c√≥digo cosido.  Al mismo tiempo, nosotros, en general, actuamos dentro del marco de las cosas implementadas en todos los compiladores populares de C. La aceleraci√≥n en un factor de 1.5, como me parece, es un buen resultado, y el lech√≥n merece una porci√≥n adicional de salvado en el comedero. </p><br><p>  Una de las condiciones impl√≠citas que establecemos para nosotros con el pig es preservar la arquitectura de la pila de la m√°quina Piglet VM.  La transici√≥n a la arquitectura de registro, como regla, reduce el n√∫mero de instrucciones necesarias para la l√≥gica de los programas y, en consecuencia, puede ayudar a eliminar las salidas innecesarias al administrador de instrucciones.  Creo que otro 10-20% del tiempo en esto podr√≠a cortarse. </p><br><p>  Nuestra condici√≥n principal, la falta de compilaci√≥n din√°mica, tampoco es una ley de la naturaleza.  Bombear a un cerdo con esteroides en forma de una compilaci√≥n JIT es muy f√°cil en estos d√≠as: en bibliotecas como <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">GNU Lightning</a> o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">LibJIT,</a> todo el trabajo sucio ya se ha hecho.  Pero el tiempo de desarrollo y la cantidad total de c√≥digo, incluso utilizando bibliotecas, est√°n creciendo enormemente. </p><br><p>  Hay, por supuesto, otros trucos a los que nuestro cerdito no ha llegado al casco.    ,     ‚Äî       - ‚Äî    - .         ,       . </p><br><p> <strong>PS</strong>    ,  ,   ,   ,   ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">https://www.instagram.com/vovazomb/</a> ),   . </p><br><p> <strong>PPS</strong>       ,     .  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" class="user_link">true-grue</a> -           ‚Äî <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">PigletC</a> .     ! </p><br><p> <strong>PPPS</strong>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" class="user_link">iliazeus</a>    :      .            ;             .      <a href=""></a> . </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es428878/">https://habr.com/ru/post/es428878/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es428866/index.html">7 principios de dise√±o, actitud hacia las tendencias de dise√±o, cartera de dise√±adores UX, ...</a></li>
<li><a href="../es428868/index.html">JAR de lanzamiento m√∫ltiple: ¬ømalo o bueno?</a></li>
<li><a href="../es428870/index.html">Mrr: FRP total para reaccionar</a></li>
<li><a href="../es428872/index.html">La historia de un ojo y 20 operaciones (no se puede leer) o quer√≠a ser piloto, pero no se le permiti√≥ volar al cielo</a></li>
<li><a href="../es428876/index.html">No hay vuelta atr√°s: la experiencia personal del probador</a></li>
<li><a href="../es428880/index.html">Nuevos m√©todos de autenticaci√≥n: ¬øuna amenaza para la privacidad?</a></li>
<li><a href="../es428882/index.html">Mobile Yandex. Blitz: analizamos tareas</a></li>
<li><a href="../es428888/index.html">qml: poder y simplicidad</a></li>
<li><a href="../es428890/index.html">Toda la verdad sobre RTOS. Art√≠culo # 18. Grupos de banderas de eventos: servicios auxiliares y estructuras de datos</a></li>
<li><a href="../es428892/index.html">C√≥mo crear un juego AI: una gu√≠a para principiantes</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>