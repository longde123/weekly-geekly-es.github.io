<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë∏üèæ üë©üèæ‚Äçüç≥ üë∏üèº Programaci√≥n din√°mica o dividir y conquistar üßïüèº ‚è±Ô∏è üÜí</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Este art√≠culo analiza las similitudes y diferencias entre los dos enfoques para resolver problemas algor√≠tmicos: programaci√≥n din√°mica (programaci√≥n d...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Programaci√≥n din√°mica o dividir y conquistar</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/423939/"> Este art√≠culo analiza las similitudes y diferencias entre los dos enfoques para resolver problemas algor√≠tmicos: <b>programaci√≥n</b> din√°mica (programaci√≥n din√°mica) y el principio de <b>"divide y vencer√°s"</b> (divide y vencer√°s).  Compararemos utilizando dos algoritmos como ejemplo: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">b√∫squeda binaria</a> (c√≥mo encontrar r√°pidamente un n√∫mero en una matriz ordenada) y <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">distancia de Levenshtein</a> (c√≥mo convertir una fila a otra con un n√∫mero m√≠nimo de operaciones). <br><br>  <i>Quiero se√±alar de inmediato que esta comparaci√≥n y explicaci√≥n no pretende ser extremadamente correcta.</i>  <i>Y tal vez incluso algunos profesores universitarios quisieran expulsarme :) Este art√≠culo es solo mi intento personal de resolver las cosas y comprender qu√© es la programaci√≥n din√°mica y c√≥mo est√° involucrado el principio de "divide y vencer√°s".</i> <br><br>  Entonces, comencemos ... <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ca2/863/582/ca28635824478a8aa8e81bd43c78338e.png" alt="imagen"><br><a name="habracut"></a><br><h3>  El problema </h3><br>  Cuando <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">comenc√© a estudiar algoritmos,</a> fue dif√≠cil <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">para</a> m√≠ entender la idea b√°sica de la programaci√≥n din√°mica (en adelante <b>DP</b> , de Dynamic Programming) y c√≥mo difiere del enfoque de "divide y vencer√°s" (m√°s <b>DC</b> , de divide y vencer√°s).  Cuando se trata de comparar estos dos paradigmas, generalmente <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">muchos usan con √©xito la funci√≥n de Fibonacci</a> para ilustrar.  Y esta es una gran ilustraci√≥n.  Pero me parece que cuando usamos <b>la misma</b> tarea para ilustrar DP y DC, perdemos un detalle importante que puede ayudarnos a detectar la diferencia entre los dos enfoques m√°s r√°pido.  Y este detalle es que estas dos t√©cnicas se manifiestan mejor para resolver <b>diferentes</b> tipos de problemas. <br><br>  Todav√≠a estoy en el proceso de aprender DP y DC y no puedo decir que entend√≠ completamente estos conceptos.  Pero todav√≠a espero que este art√≠culo arroje luz adicional y ayude a dar el siguiente paso en el estudio de enfoques tan importantes como la programaci√≥n din√°mica y la divisi√≥n y conquista. <br><br><h3>  Similitudes entre DP y DC </h3><br>  Por la forma en que veo estos dos conceptos ahora, puedo concluir que <b>DP es una versi√≥n extendida de DC</b> . <br><br>  No los considerar√≠a algo completamente diferente.  Debido a que estos dos conceptos <b>dividen recursivamente un problema en dos o m√°s subproblemas del mismo tipo</b> hasta que estos subproblemas sean lo suficientemente f√°ciles de resolver directamente.  Adem√°s, todas las soluciones al subproblema se combinan para dar una respuesta al problema original original. <br><br>  Entonces, ¬øpor qu√© entonces todav√≠a tenemos dos enfoques diferentes (DP y DC) y por qu√© llam√© a la programaci√≥n din√°mica una extensi√≥n?  Esto se debe a que la programaci√≥n din√°mica se puede aplicar a tareas que tienen ciertas <b>caracter√≠sticas y limitaciones</b> .  Y solo en este caso DP expande DC mediante dos t√©cnicas: <b>memorizaci√≥n</b> y <b>tabulaci√≥n</b> . <br><br>  Vamos a profundizar un poco m√°s en los detalles ... <br><br><h3>  Limitaciones y caracter√≠sticas necesarias para la programaci√≥n din√°mica. </h3><br>  Como acabamos de descubrir, hay dos caracter√≠sticas clave que debe tener una tarea / problema para que podamos tratar de resolverlo utilizando la programaci√≥n din√°mica: <br><br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Subestructura √≥ptima</a> : deber√≠a ser posible componer una soluci√≥n √≥ptima a un problema desde una soluci√≥n √≥ptima a sus subtareas. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Subproblemas de intersecci√≥n</a> : el problema debe desglosarse en subproblemas, que a su vez se reutilizan repetidamente.  En otras palabras, un enfoque recursivo para resolver el problema implicar√≠a una soluci√≥n m√∫ltiple ( <b>no una</b> sola) para el mismo subproblema, en lugar de producir subproblemas nuevos y √∫nicos en cada ciclo recursivo. </li></ol><br>  Tan pronto como podamos encontrar estas dos caracter√≠sticas en el problema que estamos considerando, podemos decir que se puede resolver mediante programaci√≥n din√°mica. <br><br><h3>  Programaci√≥n din√°mica como una extensi√≥n del principio de "divide y vencer√°s" </h3><br>  DP extiende DC con la ayuda de dos t√©cnicas ( <b>memorizaci√≥n</b> y <b>tabulaci√≥n</b> ), cuyo prop√≥sito es guardar soluciones a subproblemas para su futura reutilizaci√≥n.  Por lo tanto, las soluciones se almacenan en cach√© por subproblema, lo que conduce a una mejora significativa en el rendimiento del algoritmo.  Por ejemplo, la complejidad temporal de una implementaci√≥n recursiva ‚Äúingenua‚Äù de la funci√≥n Fibonacci es <code>O(2 <sup>n</sup> )</code> .  Al mismo tiempo, una soluci√≥n basada en programaci√≥n din√°mica se ejecuta en solo <code>(n)</code> . <br><br>  <b>La memorizaci√≥n (llenar el cach√© de arriba a abajo)</b> es una t√©cnica de almacenamiento en cach√© que utiliza soluciones reci√©n calculadas para subtareas.  La funci√≥n de Fibonacci que usa la t√©cnica de memorizaci√≥n se ver√≠a as√≠: <br><br><pre> <code class="javascript hljs">memFib(n) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (mem[n] is <span class="hljs-literal"><span class="hljs-literal">undefined</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (n &lt; <span class="hljs-number"><span class="hljs-number">2</span></span>) result = n <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> result = memFib(n<span class="hljs-number"><span class="hljs-number">-2</span></span>) + memFib(n<span class="hljs-number"><span class="hljs-number">-1</span></span>) mem[n] = result <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> mem[n] }</code> </pre> <br>  <b>La tabulaci√≥n (llenar el cach√© de abajo hacia arriba)</b> es una t√©cnica similar, pero que se centra principalmente en llenar el cach√© y no en encontrar una soluci√≥n al subproblema.  El c√°lculo de los valores que deben almacenarse en cach√© es m√°s f√°cil en este caso para realizarse de forma iterativa, en lugar de recurrente.  La funci√≥n de Fibonacci que usa la t√©cnica de tabulaci√≥n se ver√≠a as√≠: <br><br><pre> <code class="javascript hljs">tabFib(n) { mem[<span class="hljs-number"><span class="hljs-number">0</span></span>] = <span class="hljs-number"><span class="hljs-number">0</span></span> mem[<span class="hljs-number"><span class="hljs-number">1</span></span>] = <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i = <span class="hljs-number"><span class="hljs-number">2.</span></span>..n mem[i] = mem[i<span class="hljs-number"><span class="hljs-number">-2</span></span>] + mem[i<span class="hljs-number"><span class="hljs-number">-1</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> mem[n] }</code> </pre><br>  Puede leer m√°s sobre la comparaci√≥n de la memorizaci√≥n y la tabulaci√≥n <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aqu√≠</a> . <br><br>  La idea principal que debe captarse en estos ejemplos es que, dado que nuestros problemas de DC tienen subproblemas superpuestos, podemos usar el almacenamiento en cach√© de soluciones a subproblemas utilizando una de dos t√©cnicas de almacenamiento en cach√©: memorizaci√≥n y tabulaci√≥n. <br><br><h3>  Entonces, ¬øcu√°l es la diferencia entre DP y DC al final </h3><br>  Aprendimos sobre las limitaciones y requisitos previos para usar la programaci√≥n din√°mica, as√≠ como las t√©cnicas de almacenamiento en cach√© utilizadas en el enfoque DP.  Tratemos de resumir y representar los pensamientos anteriores en la siguiente ilustraci√≥n: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/8f1/8e4/8a1/8f18e48a15bcdbe1e3541540c8a76274.png" alt="imagen"><br><br>  Intentemos resolver un par de problemas utilizando DP y DC para demostrar ambos enfoques en acci√≥n. <br><br><h3>  Divide y vencer√°s Ejemplo: B√∫squeda binaria </h3><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">El</a> algoritmo de b√∫squeda <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">binaria</a> es un algoritmo de b√∫squeda que encuentra la posici√≥n del elemento solicitado en una matriz ordenada.  En la b√∫squeda binaria, comparamos el valor de la variable con el valor del elemento en el medio de la matriz.  Si no son iguales, entonces la mitad de la matriz en la que el elemento deseado no puede excluirse de una b√∫squeda adicional.  La b√∫squeda contin√∫a en esa mitad de la matriz, en la que se puede ubicar la variable deseada hasta que se encuentre.  Si la siguiente mitad de la matriz no contiene elementos, la b√∫squeda se considera completa y concluimos que la matriz no contiene el valor deseado. <br><br>  <b>Ejemplo</b> <br><br>  La siguiente ilustraci√≥n es un ejemplo de una b√∫squeda binaria para el n√∫mero 4 en una matriz. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/a3f/845/628/a3f8456289058a7401640fdf368e7c44.png" alt="imagen"><br><br>  Representemos la misma l√≥gica de b√∫squeda, pero en forma de un "√°rbol de decisi√≥n". <br><br><img src="https://habrastorage.org/getpro/habr/post_images/a9f/79d/904/a9f79d904494ff947b2d730de4e9fbba.png" alt="imagen"><br><br>  Puede ver en este diagrama un principio claro de "divide y vencer√°s", utilizado para resolver este problema.  Dividimos iterativamente nuestra matriz original en submatrices e intentamos encontrar el elemento que estamos buscando en ellas. <br><br>  ¬øPodemos resolver este problema usando programaci√≥n din√°mica?  <b>No</b>  Por la raz√≥n de que esta tarea <b>no contiene subproblemas de intersecci√≥n</b> .  Cada vez que dividimos una matriz en partes, ambas partes son completamente independientes y no se superponen.  Y de acuerdo con los supuestos y las limitaciones de la programaci√≥n din√°mica que discutimos anteriormente, los subproblemas deben superponerse de alguna manera, <b>deben ser repetitivos</b> . <br><br>  Por lo general, cada vez que un √°rbol de decisi√≥n se ve exactamente como un <b>√°rbol</b> (y <b>no como un gr√°fico</b> ), lo m√°s probable es que no haya subproblemas superpuestos, <br><br>  <b>Implementaci√≥n de algoritmo</b> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Aqu√≠</a> puede encontrar el c√≥digo fuente completo del algoritmo de b√∫squeda binaria con pruebas y explicaciones. <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">binarySearch</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">sortedArray, seekElement</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> startIndex = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> endIndex = sortedArray.length - <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (startIndex &lt;= endIndex) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> middleIndex = startIndex + <span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.floor((endIndex - startIndex) / <span class="hljs-number"><span class="hljs-number">2</span></span>); <span class="hljs-comment"><span class="hljs-comment">// If we've found the element just return its position. if (sortedArray[middleIndex] === seekElement)) { return middleIndex; } // Decide which half to choose: left or right one. if (sortedArray[middleIndex] &lt; seekElement)) { // Go to the right half of the array. startIndex = middleIndex + 1; } else { // Go to the left half of the array. endIndex = middleIndex - 1; } } return -1; }</span></span></code> </pre><br><h3>  Ejemplo de programaci√≥n din√°mica: distancia de edici√≥n </h3><br>  Por lo general, cuando se trata de explicar la programaci√≥n din√°mica, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">la funci√≥n de Fibonacci se</a> usa como ejemplo.  Pero en nuestro caso, tomemos un ejemplo un poco m√°s complejo.  Cuantos m√°s ejemplos, m√°s f√°cil es entender el concepto. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">La distancia de edici√≥n</a> (o la distancia de Levenshtein) entre dos l√≠neas es el n√∫mero m√≠nimo de operaciones para insertar un car√°cter, eliminar un car√°cter y reemplazar un car√°cter con otro, necesario para convertir una l√≠nea en otra. <br><br>  <b>Ejemplo</b> <br><br>  Por ejemplo, la distancia de edici√≥n entre las palabras "gatito" y "sentado" es 3, porque necesita realizar tres operaciones de edici√≥n (dos reemplazos y una inserci√≥n) para convertir una l√≠nea en otra.  Y es imposible encontrar una opci√≥n de conversi√≥n m√°s r√°pida con menos operaciones: <br><br><ol><li>  gatito ‚Üí sitten (reemplazando "k" con "s") </li><li>  sitten ‚Üí sittin (reemplazando "e" con "i") </li><li>  sittin ‚Üí sentado (inserte "g" completamente). </li></ol><br>  <b>Aplicaci√≥n de algoritmo</b> <br><br>  El algoritmo tiene una amplia gama de aplicaciones, por ejemplo, para correcci√≥n ortogr√°fica, sistemas de correcci√≥n de reconocimiento √≥ptico, b√∫squeda de cadenas inexacta, etc. <br><br>  <b>Definici√≥n matem√°tica de un problema.</b> <br><br>  Matem√°ticamente, la distancia de Levenstein entre dos l√≠neas <code>a, b</code> (con longitudes | a | y <code>|b|</code> respectivamente) est√° determinada por la funci√≥n de <code>function lev(|a|, |b|)</code> , donde: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/2f4/242/84e/2f424284e297eab78f308d35eb27ed94.png" alt="imagen"><br><br>  Tenga en cuenta que la primera l√≠nea en la funci√≥n <code>min</code> corresponde a la operaci√≥n de <b>eliminaci√≥n</b> , la segunda l√≠nea corresponde a la operaci√≥n de <b>inserci√≥n</b> y la tercera l√≠nea corresponde a la operaci√≥n de <b>reemplazo</b> (en caso de que las letras no sean iguales). <br><br>  <b>Explicaci√≥n</b> <br><br>  Tratemos de descubrir qu√© nos dice esta f√≥rmula.  Tome un ejemplo simple de encontrar la distancia m√≠nima de edici√≥n entre las l√≠neas <b>ME</b> y <b>MY</b> .  Intuitivamente, ya sabe que la distancia m√≠nima de edici√≥n es una ( <b>1</b> ) operaci√≥n de reemplazo (reemplace "E" con "Y").  Pero formalicemos nuestra soluci√≥n y convi√©rtala en una forma algor√≠tmica, para poder resolver versiones m√°s complejas de este problema, como transformar la palabra <b>s√°bado</b> en <b>domingo</b> . <br><br>  Para aplicar la f√≥rmula a la transformaci√≥n ME ‚Üí MY, primero debemos encontrar la distancia m√≠nima de edici√≥n entre ME ‚Üí M, M ‚Üí MY y M ‚Üí M.  A continuaci√≥n, debemos elegir el m√≠nimo de tres distancias y agregarle una operaci√≥n (+1) de la transformaci√≥n E ‚Üí Y. <br><br>  Entonces, ya podemos ver la naturaleza recursiva de esta soluci√≥n: la distancia de edici√≥n m√≠nima ME ‚Üí MY se calcula en funci√≥n de las tres transformaciones posibles anteriores.  Por lo tanto, ya podemos decir que este es un algoritmo de divide y vencer√°s. <br><br>  Para explicar m√°s el algoritmo, pongamos nuestras dos filas en una matriz: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/b3d/71e/646/b3d71e646f887852ecf0a579ff8c5957.png" alt="imagen"><br><br>  <b>La celda (0,1)</b> contiene el n√∫mero rojo 1. Esto significa que debemos realizar 1 operaci√≥n para convertir M en una cadena vac√≠a: eliminar M. Por lo tanto, hemos marcado este n√∫mero en rojo. <br><br>  <b>La celda (0,2)</b> contiene un n√∫mero rojo 2. Esto significa que necesitamos realizar 2 operaciones para transformar la cadena ME en una cadena vac√≠a: eliminar E, eliminar M. <br><br>  <b>La celda (1,0)</b> contiene un n√∫mero verde 1. Esto significa que necesitamos 1 operaci√≥n para transformar una cadena vac√≠a en M - pegar M. Marcamos la operaci√≥n de inserci√≥n en verde. <br><br>  <b>La celda (2,0)</b> contiene un n√∫mero verde 2. Esto significa que necesitamos realizar 2 operaciones para convertir una cadena vac√≠a en una cadena MY - inserte Y, inserte M. <br><br>  <b>La celda (1,1)</b> contiene el n√∫mero 0. Esto significa que no necesitamos realizar ninguna operaci√≥n para convertir la cadena M a M. <br><br>  <b>La celda (1,2)</b> contiene el n√∫mero rojo 1. Esto significa que debemos realizar 1 operaci√≥n para transformar la cadena ME en M - eliminar E. <br><br>  Y as√≠ sucesivamente ... <br><br>  No parece dif√≠cil para matrices peque√±as, como la nuestra (solo 3x3).  Pero, ¬øc√≥mo podemos calcular los valores de todas las celdas para matrices grandes (por ejemplo, para una matriz de 9x7 en la transformaci√≥n s√°bado ‚Üí domingo)? <br><br>  La buena noticia es que, de acuerdo con la f√≥rmula, todo lo que necesitamos para calcular el valor de cualquier celda con coordenadas <code>(i,j)</code> son solo los valores de 3 celdas vecinas <code>(i-1,j)</code> , <code>(i-1,j-1)</code> y <code>(i,j-1)</code> .  Todo lo que tenemos que hacer es encontrar el valor m√≠nimo de tres celdas vecinas y agregar una (+1) a este valor si tenemos letras diferentes en la i-√©sima fila y la j-√©sima columna. <br><br>  De nuevo, puede ver claramente la naturaleza recursiva de esta tarea. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/c96/541/c96/c96541c96d184b5f7dee8b1465e5963e.png" alt="imagen"><br><br>  Tambi√©n vimos que est√°bamos lidiando con una tarea de dividir y conquistar.  Pero, ¬øpodemos aplicar programaci√≥n din√°mica para resolver este problema?  ¬øEsta tarea satisface las condiciones de " <b>problemas de intersecci√≥n</b> " y " <b>subestructuras √≥ptimas</b> " mencionadas anteriormente?  <b>Si</b>  Construyamos un √°rbol de decisi√≥n. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/cfa/d3d/aac/cfad3daaccada3e2bbfb66c85f93a9ef.png" alt="imagen"><br><br>  Primero, puede notar que nuestro √°rbol de decisi√≥n se parece m√°s a un <b>gr√°fico de decisi√≥n</b> <b>que a</b> un <b>√°rbol</b> .  Tambi√©n puede observar <b>varias subtareas superpuestas</b> .  Tambi√©n se ve que es imposible reducir el n√∫mero de operaciones y hacerlo m√°s peque√±o que el n√∫mero de operaciones de esas tres celdas vecinas (subproblemas). <br><br>  Tambi√©n puede observar que el valor en cada celda se calcula en funci√≥n de los valores anteriores.  Por lo tanto, en este caso, se utiliza la t√©cnica de <b>tabulaci√≥n</b> (llenando el cach√© en la direcci√≥n ascendente).  Ver√° esto en el ejemplo de c√≥digo a continuaci√≥n. <br><br>  Aplicando todos estos principios, podemos resolver problemas m√°s complejos, por ejemplo, la tarea de transformaci√≥n S√°bado ‚Üí Domingo: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ae9/c60/843/ae9c6084303f344ab2d54fbeaeb7f9d3.png" alt="imagen"><br><br>  <b>Ejemplo de c√≥digo</b> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Aqu√≠</a> puede encontrar una soluci√≥n completa para encontrar la distancia m√≠nima de edici√≥n con pruebas y explicaciones: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">levenshteinDistance</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">a, b</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> distanceMatrix = <span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>(b.length + <span class="hljs-number"><span class="hljs-number">1</span></span>) .fill(<span class="hljs-literal"><span class="hljs-literal">null</span></span>) .map( <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>(a.length + <span class="hljs-number"><span class="hljs-number">1</span></span>).fill(<span class="hljs-literal"><span class="hljs-literal">null</span></span>) ); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt;= a.length; i += <span class="hljs-number"><span class="hljs-number">1</span></span>) { distanceMatrix[<span class="hljs-number"><span class="hljs-number">0</span></span>][i] = i; } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> j = <span class="hljs-number"><span class="hljs-number">0</span></span>; j &lt;= b.length; j += <span class="hljs-number"><span class="hljs-number">1</span></span>) { distanceMatrix[j][<span class="hljs-number"><span class="hljs-number">0</span></span>] = j; } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> j = <span class="hljs-number"><span class="hljs-number">1</span></span>; j &lt;= b.length; j += <span class="hljs-number"><span class="hljs-number">1</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> i = <span class="hljs-number"><span class="hljs-number">1</span></span>; i &lt;= a.length; i += <span class="hljs-number"><span class="hljs-number">1</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> indicator = a[i - <span class="hljs-number"><span class="hljs-number">1</span></span>] === b[j - <span class="hljs-number"><span class="hljs-number">1</span></span>] ? <span class="hljs-number"><span class="hljs-number">0</span></span> : <span class="hljs-number"><span class="hljs-number">1</span></span>; distanceMatrix[j][i] = <span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.min( distanceMatrix[j][i - <span class="hljs-number"><span class="hljs-number">1</span></span>] + <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-comment"><span class="hljs-comment">// deletion distanceMatrix[j - 1][i] + 1, // insertion distanceMatrix[j - 1][i - 1] + indicator, // substitution ); } } return distanceMatrix[b.length][a.length]; }</span></span></code> </pre><br><h3>  Conclusiones </h3><br>  En este art√≠culo, comparamos dos enfoques algor√≠tmicos ("programaci√≥n din√°mica" y "divide y vencer√°s") para resolver problemas.  Descubrimos que la programaci√≥n din√°mica utiliza el principio de "divide y vencer√°s" y puede aplicarse para resolver problemas si el problema contiene subproblemas de intersecci√≥n y la subestructura √≥ptima (como es el caso con la distancia de Levenshtein).  La programaci√≥n din√°mica utiliza adem√°s t√©cnicas de memorizaci√≥n y tabulaci√≥n para preservar las resoluciones secundarias para su posterior reutilizaci√≥n. <br><br>  Espero que este art√≠culo aclare en lugar de complicar la situaci√≥n para aquellos de ustedes que han tratado de lidiar con conceptos tan importantes como la programaci√≥n din√°mica y "divide y vencer√°s" :) <br><br>  Puede encontrar m√°s ejemplos algor√≠tmicos utilizando programaci√≥n din√°mica, con pruebas y explicaciones en el repositorio de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">algoritmos de JavaScript y estructuras de datos</a> . <br><br>  Codificaci√≥n exitosa! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es423939/">https://habr.com/ru/post/es423939/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es423927/index.html">10 motores de b√∫squeda prometedores para mejorar el SEO</a></li>
<li><a href="../es423931/index.html">¬øC√≥mo omitir la autenticaci√≥n por SMS cuando se conecta a redes Wi-Fi p√∫blicas?</a></li>
<li><a href="../es423933/index.html">Microsoft Office Security: objetos incrustados</a></li>
<li><a href="../es423935/index.html">Embox responde a preguntas populares del festival TechTrain IT</a></li>
<li><a href="../es423937/index.html">Escalada de privilegios de Windows</a></li>
<li><a href="../es423941/index.html">Informes de iOS mitap Redmadrobot</a></li>
<li><a href="../es423943/index.html">Optimizaci√≥n de precios minoristas fuera de l√≠nea</a></li>
<li><a href="../es423945/index.html">La Corte Suprema especific√≥ el procedimiento para considerar casos con repost y likes</a></li>
<li><a href="../es423947/index.html">Nuestros datos personales no le cuestan nada</a></li>
<li><a href="../es423949/index.html">Un universo consistente con nuestras creencias actuales puede no ser posible.</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>