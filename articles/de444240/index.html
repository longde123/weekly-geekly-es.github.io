<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🐪 🏞️ 🎐 Spring Data JPA: Dateien bringen 👩🏽‍🤝‍👩🏻 📫 📕</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Grüße, dies ist der zweite Beitrag über Spring Data JPA. Der erste Teil war ausschließlich Unterwasserrechen sowie Tipps von erfahrenen gewidmet. In d...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Spring Data JPA: Dateien bringen</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/444240/"><p> Grüße, dies ist der zweite Beitrag über Spring Data JPA.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Der erste Teil</a> war ausschließlich Unterwasserrechen sowie Tipps von erfahrenen gewidmet.  In diesem Teil werden wir darüber sprechen, wie Sie das Framework an Ihre Bedürfnisse anpassen können.  Alle beschriebenen Beispiele finden Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> . </p><a name="habracut"></a><br><h4 id="grafy">  Zählt </h4><br><p>  Beginnen wir vielleicht mit einer einfachen und gleichzeitig gemeinsamen Aufgabe: Beim Laden einer Entität muss ihre „Tochter“ selektiv heruntergeladen werden.  Betrachten Sie ein einfaches Beispiel: </p><br><pre><code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Entity</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Child</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Id</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Long id; <span class="hljs-meta"><span class="hljs-meta">@JoinColumn</span></span>(name = <span class="hljs-string"><span class="hljs-string">"parent_id"</span></span>) <span class="hljs-meta"><span class="hljs-meta">@ManyToOne</span></span>(fetch = FetchType.LAZY, cascade = CascadeType.ALL) <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Parent parent; } <span class="hljs-meta"><span class="hljs-meta">@Entity</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Parent</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Id</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Long id; }</code> </pre> <br><p>  Die untergeordnete Entität in unserem Beispiel ist faul: Wir möchten beim Empfang von untergeordneten Elementen keine unnötigen Daten laden (und eine andere Tabelle in der SQL-Abfrage verknüpfen).  In einigen Fällen wissen wir in unserer Bewerbung jedoch mit Sicherheit, dass wir sowohl das Kind als auch seine Eltern brauchen werden.  Wenn Sie die Entität faul lassen, erhalten wir 2 separate Anfragen.  Wenn Sie durch Entfernen von <code>FetchType.LAZY</code> schnelles Laden <code>FetchType.LAZY</code> , werden beide Entitäten immer bei der ersten Anforderung geladen (und wir möchten dies nicht). </p><br><p>  JPQL bietet eine sofort einsatzbereite Lösung - dies ist das Schlüsselwort <code>fetch</code> : </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ChildRepository</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">JpaRepository</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Child</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Long</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Query</span></span>(<span class="hljs-string"><span class="hljs-string">"select c from Child c join fetch c.parent where c.id = :id"</span></span>) <span class="hljs-function"><span class="hljs-function">Child </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">findByIdFetchParent</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@Param(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"id"</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> Long id)</span></span>; }</code> </pre> <br><p>  Diese Anfrage ist einfach und klar, hat aber Nachteile: </p><br><ul><li>  Wir haben die Logik von <code>JpaRepository::findById</code> tatsächlich dupliziert, indem wir explizites Laden hinzugefügt haben </li><li>  Jede mit <code>@Query</code> beschriebene <code>@Query</code> beim Start der Anwendung überprüft. <code>@Query</code> müssen die Abfrage analysiert, Argumente usw. überprüft werden (siehe <a href="">org.springframework.data.jpa.repository.query.SimpleJpaQuery :: validateQuery</a> ).  All dies ist Arbeit, die Zeit und Gedächtnis braucht. </li><li>  Die Verwendung eines solchen Ansatzes in einem großen Projekt mit Dutzenden von Repositories und verschlungenen Entitäten (manchmal mit einem Dutzend "Töchtern") wird zu einer kombinatorischen Explosion führen. </li></ul><br><p>  Zählungen helfen uns: </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Entity</span></span> <span class="hljs-meta"><span class="hljs-meta">@NamedEntityGraphs</span></span>(value = { <span class="hljs-meta"><span class="hljs-meta">@NamedEntityGraph</span></span>( name = Child.PARENT, attributeNodes = <span class="hljs-meta"><span class="hljs-meta">@NamedAttributeNode</span></span>(<span class="hljs-string"><span class="hljs-string">"parent"</span></span>) ) }) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Child</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> String PARENT = <span class="hljs-string"><span class="hljs-string">"Child[parent]"</span></span>; <span class="hljs-meta"><span class="hljs-meta">@Id</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Long id; <span class="hljs-meta"><span class="hljs-meta">@JoinColumn</span></span>(name = <span class="hljs-string"><span class="hljs-string">"parent_id"</span></span>) <span class="hljs-meta"><span class="hljs-meta">@ManyToOne</span></span>(fetch = FetchType.LAZY, cascade = CascadeType.ALL) <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Parent parent; }</code> </pre> <br><p>  Das Diagramm selbst ist leicht zu beschreiben, Schwierigkeiten beginnen bei der Verwendung.  Spring Data JPA auf seiner Seite schlägt vor, dies folgendermaßen zu tun (wie in unserem Fall): </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">GroupRepository</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">JpaRepository</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">GroupInfo</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">String</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@EntityGraph</span></span>(value = Child.PARENT) <span class="hljs-meta"><span class="hljs-meta">@Query</span></span>(<span class="hljs-string"><span class="hljs-string">"select c from Child c where c.id = :id"</span></span>) <span class="hljs-function"><span class="hljs-function">Child </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">findByIdFetchParent</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@Param(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"id"</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> Long id)</span></span>; }</code> </pre> <br><p>  Hier sehen wir alle die gleichen Probleme (außer dass die schriftliche Anfrage etwas einfacher geworden ist).  Sie können sie mit Hilfe der Feinabstimmung auf einen Schlag beenden.  Erstellen Sie Ihre eigene Schnittstelle, über die wir anstelle des <code>JpaRepository</code> Repositorys <code>JpaRepository</code> : </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@NoRepositoryBean</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BaseJpaRepository</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ID</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Serializable</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">JpaRepository</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ID</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-function"><span class="hljs-function">T </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">findById</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ID id, String graphName)</span></span></span></span>; }</code> </pre> <br><p>  Jetzt Implementierung: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BaseJpaRepositoryImpl</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ID</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Serializable</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SimpleJpaRepository</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ID</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BaseJpaRepository</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ID</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> JpaEntityInformation&lt;T, ?&gt; entityInfo; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> EntityManager entityManager; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BaseJpaRepositoryImpl</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(JpaEntityInformation&lt;T, ?&gt; ei, EntityManager em)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>(ei, em); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.entityInfo = ei; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.entityManager = em; } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> T </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">findById</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ID id, String graphName)</span></span></span><span class="hljs-function"> </span></span>{ Assert.notNull(id, <span class="hljs-string"><span class="hljs-string">"The given id must not be null!"</span></span>); <span class="hljs-comment"><span class="hljs-comment">//  EntityGraph&lt;?&gt; graph = entityManager.getEntityGraph(graphName); Map&lt;String, Object&gt; hints = singletonMap(QueryHints.HINT_LOADGRAPH, graph); return entityManager.find(getDomainClass(), id, hints); }</span></span></code> </pre> <br><p>  <code>BaseJpaRepositoryImpl</code> Spring nun, <code>BaseJpaRepositoryImpl</code> als Grundlage für alle Repositorys unserer Anwendung zu verwenden: </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@EnableJpaRepositories</span></span>(repositoryBaseClass = BaseJpaRepositoryImpl.class) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AppConfig</span></span></span><span class="hljs-class"> </span></span>{ }</code> </pre> <br><p>  Jetzt ist unsere Methode in allen Repositorys verfügbar, die von unserem <code>BaseJpaRepository</code> geerbt <code>BaseJpaRepository</code> . </p><br><p>  Dieser Ansatz hat einen Nachteil, der ein sehr fettes Schwein setzen kann. </p><br><div class="spoiler">  <b class="spoiler_title">Versuche selbst zu denken</b> <div class="spoiler_text"><p>  Das Problem ist, dass der Ruhezustand (zumindest zum Zeitpunkt des Schreibens) nicht mit den Namen der Diagramme und den Diagrammen selbst übereinstimmt.  Aus diesem Grund kann es zu einem Laufzeitfehler kommen, wenn wir so etwas ausführen </p><br><pre> <code class="java hljs">Optional&lt;MyEntity&gt; entity = repository.findById(id, NON_EXISTING_GRAPH);</code> </pre> </div></div><br><p>  Sie können den Zustand der Lösung mithilfe des Tests überprüfen: </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Sql</span></span>(<span class="hljs-string"><span class="hljs-string">"/ChildRepositoryGraphTest.sql"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ChildRepositoryGraphTest</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TestBase</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Long childId = <span class="hljs-number"><span class="hljs-number">1L</span></span>; <span class="hljs-meta"><span class="hljs-meta">@Test</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">testGraph_expectFieldInitialized</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ Child child1 = childRepository.findOne(childId, Child.PARENT); <span class="hljs-keyword"><span class="hljs-keyword">boolean</span></span> initialized = Hibernate.isInitialized(child1.getParent()); assertTrue(initialized); } <span class="hljs-meta"><span class="hljs-meta">@Test</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">testGraph_expectFieldNotInitialized</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ Child child1 = childRepository .findById(childId) .orElseThrow(NullPointerException::<span class="hljs-keyword"><span class="hljs-keyword">new</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">boolean</span></span> initialized = Hibernate.isInitialized(child1.getParent()); assertFalse(initialized); } }</code> </pre> <br><h4 id="kogda-derevya-byli-bolshimi">  Als die Bäume groß waren </h4><br><p>  Und wir waren klein und unerfahren, wir mussten oft diesen Code sehen: </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> List&lt;DailyRecord&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">findBetweenDates</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Date from, Date to)</span></span></span><span class="hljs-function"> </span></span>{ StringBuilder query = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StringBuilder(<span class="hljs-string"><span class="hljs-string">"from Record "</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (from != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { query.append(<span class="hljs-string"><span class="hljs-string">" where date &gt;="</span></span>).append(format(from)).append(<span class="hljs-string"><span class="hljs-string">" "</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (to != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (from == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { query.append(<span class="hljs-string"><span class="hljs-string">" where date &lt;= "</span></span> + format(to) + <span class="hljs-string"><span class="hljs-string">" "</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { query.append(<span class="hljs-string"><span class="hljs-string">" and date &lt;= "</span></span> + format(to) + <span class="hljs-string"><span class="hljs-string">" "</span></span>); } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> em.createQuery(query.toString(), DailyRecord.class).getResultList(); }</code> </pre> <br><p>  Dieser Code sammelt die Anfrage Stück für Stück.  Die Nachteile dieses Ansatzes liegen auf der Hand: </p><br><ul><li>  du musst viel mit deinen Händen machen </li><li>  Wo manuelle Arbeit ist, gibt es Fehler </li><li>  Keine Syntaxhervorhebung (Tippfehler werden zur Laufzeit angezeigt) </li><li>  Es ist sehr schwierig, den Code zu erweitern und zu pflegen </li></ul><br><p>  Wenig später erschien die Kriterien-API, mit der wir den obigen Code ein wenig komprimieren konnten: </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> List&lt;DailyRecord&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">findBetweenDates</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Date from, Date to)</span></span></span><span class="hljs-function"> </span></span>{ Criteria criteria = em .unwrap(Session.class) .createCriteria(DailyRecord.class); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (from != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { criteria.add(Expression.ge(<span class="hljs-string"><span class="hljs-string">"date"</span></span>, from)); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (to != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { criteria.add(Expression.le(<span class="hljs-string"><span class="hljs-string">"date"</span></span>, to)); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> criteria.list(); }</code> </pre> <br><p>  Die Verwendung von Kriterien hat mehrere Vorteile: </p><br><ul><li>  die Möglichkeit, ein Metamodell anstelle von "verdrahteten" Werten wie "Datum" zu verwenden </li><li>  Einige Fehler beim Erstellen der Anforderung stellen sich als Kompilierungsfehler heraus, d. h. sie werden bereits beim Schreiben erkannt </li><li>  Der Code ist kürzer und verständlicher als beim blöden Einfügen von Strings </li></ul><br><p>  Es gibt auch Nachteile: </p><br><ul><li>  Der Code ist kompliziert genug, um zu verstehen </li><li>  Um zu lernen, wie man solche Abfragen schreibt, müssen Sie Ihre Hand füllen (ich erinnere mich an den wildesten Schmerz, als ich mich zum ersten Mal mit der Fehlerkorrektur in solchen Abfragen befassen musste, die manchmal aus 100-150 Zeilen bestehen, mit Verzweigung usw.) </li><li>  Eine komplexe Abfrage ist ziemlich umständlich (50 Zeilen sind weit vom Limit entfernt). </li></ul><br><p>  Ich möchte es einfach und mit Vergnügen entwickeln, daher mag ich diese beiden Methoden nicht. </p><br><p>  Wenden wir uns der bereits von uns untersuchten Entität zu: </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Entity</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Child</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Id</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Long id; <span class="hljs-meta"><span class="hljs-meta">@JoinColumn</span></span>(name = <span class="hljs-string"><span class="hljs-string">"parent_id"</span></span>) <span class="hljs-meta"><span class="hljs-meta">@ManyToOne</span></span>(fetch = FetchType.LAZY, cascade = CascadeType.ALL) <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Parent parent; <span class="hljs-comment"><span class="hljs-comment">//... @OneToMany(mappedBy = "owner", cascade = CascadeType.ALL) @LazyCollection(value = LazyCollectionOption.EXTRA) private List&lt;Toy&gt; toys = new ArrayList&lt;&gt;(); }</span></span></code> </pre> <br><p>  Ich möchte in der Lage sein, eine Entität in verschiedenen Modi (und deren Kombinationen) zu laden: </p><br><ul><li>  Eltern laden (oder nicht) </li><li>  Spielzeug laden (oder nicht) </li><li>  Kinder nach Alter sortieren </li></ul><br><p>  Wenn Sie dieses Problem direkt lösen, d. H. Indem Sie viele Abfragen schreiben, die dem ausgewählten Lademodus entsprechen, führt dies sehr schnell zu einer kombinatorischen Explosion: </p><br><pre> <code class="java hljs"> <span class="hljs-meta"><span class="hljs-meta">@Query</span></span>(<span class="hljs-string"><span class="hljs-string">"select c from Child c join fetch c.parent order by c.age"</span></span>) <span class="hljs-function"><span class="hljs-function">List&lt;Child&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">findWithParentOrderByAge</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-meta"><span class="hljs-meta">@Query</span></span>(<span class="hljs-string"><span class="hljs-string">"select c from Child c join fetch c.toys order by c.age"</span></span>) <span class="hljs-function"><span class="hljs-function">List&lt;Child&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">findWithToysOrderByAge</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-meta"><span class="hljs-meta">@Query</span></span>(<span class="hljs-string"><span class="hljs-string">"select c from Child c join fetch c.parent join fetch c.toys"</span></span>) <span class="hljs-function"><span class="hljs-function">List&lt;Child&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">findWithParentAndToys</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-comment"><span class="hljs-comment">//...</span></span></code> </pre> <br><p>  Es gibt eine einfache und elegante Möglichkeit, dieses Problem zu lösen: eine Kombination aus SQL / HQL- und Template-Engines.  "Freemarker" wurde für meine Projekte verwendet, obwohl andere Lösungen verwendet werden können ("Timlif", "Mustash" usw.). </p><br><p>  Beginnen wir mit dem Erstellen.  Zunächst müssen wir die Abfrage in einer Datei beschreiben, die die Erweiterung <code>*.hql.ftl</code> oder <code>*.sql.ftl</code> (wenn "reines" SQL verwendet wird): </p><br><pre> <code class="sql hljs"><span class="hljs-comment"><span class="hljs-comment">#* @vtlvariable name="fetchParent" type="java.lang.Boolean" *# #* @vtlvariable name="fetchToys" type="java.lang.Boolean" *# #* @vtlvariable name="orderByAge" type="java.lang.Boolean" *# select child from Child child #if($fetchParent) left join fetch child.parent #end #if($fetchToys) left join fetch child.toys #end #if($orderByAge) order by child.age #end</span></span></code> </pre> <br><p>  Jetzt brauchen Sie einen Handler: </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Component</span></span> <span class="hljs-meta"><span class="hljs-meta">@RequiredArgsConstructor</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TemplateParser</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Configuration configuration; <span class="hljs-meta"><span class="hljs-meta">@SneakyThrows</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">prepareQuery</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String templateName, Map&lt;String, Object&gt; params)</span></span></span></span>{ Template template = configuration.getTemplate(templateName); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> FreeMarkerTemplateUtils.processTemplateIntoString(template, params); } }</code> </pre> <br><p>  Nichts kompliziertes.  Zum Repository gelangen.  Offensichtlich <code>JpaRepository</code> die Schnittstelle, die <code>JpaRepository</code> erbt, nicht zu uns.  Stattdessen nutzen wir die Gelegenheit, um eigene Repositorys zu erstellen: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ChildRepositoryCustom</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-function">List&lt;Child&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">findAll</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">boolean</span></span></span></span><span class="hljs-function"><span class="hljs-params"> fetchParent, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">boolean</span></span></span></span><span class="hljs-function"><span class="hljs-params"> fetchToys, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">boolean</span></span></span></span><span class="hljs-function"><span class="hljs-params"> order)</span></span></span></span>; } <span class="hljs-meta"><span class="hljs-meta">@RequiredArgsConstructor</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ChildRepositoryImpl</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BaseDao</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ChildRepositoryCustom</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> TemplateParser templateParser; <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> List&lt;Child&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">findAll</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">boolean</span></span></span></span><span class="hljs-function"><span class="hljs-params"> fetchParent, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">boolean</span></span></span></span><span class="hljs-function"><span class="hljs-params"> fetchToys, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">boolean</span></span></span></span><span class="hljs-function"><span class="hljs-params"> order)</span></span></span><span class="hljs-function"> </span></span>{ Map&lt;String, Object&gt; params = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HashMap&lt;&gt;(); params.put(<span class="hljs-string"><span class="hljs-string">"fetchParent"</span></span>, fetchParent); params.put(<span class="hljs-string"><span class="hljs-string">"fetchToys"</span></span>, fetchToys); params.put(<span class="hljs-string"><span class="hljs-string">"orderByAge"</span></span>, orderByAge); String query = templateParser.prepareQuery(BASE_CHILD_TEMPLATE.name, params); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> em.createQuery(query, Child.class).getResultList(); } <span class="hljs-meta"><span class="hljs-meta">@RequiredArgsConstructor</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> RepositoryTemplates { BASE_CHILD_TEMPLATE(<span class="hljs-string"><span class="hljs-string">"BaseChildTemplate.hql.ftl"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> String name; } }</code> </pre> <br><p>  Um die <code>findUsingTemplate</code> Methode über <code>findUsingTemplate</code> zugänglich zu <code>ChildRepository</code> Sie <code>ChildRepository</code> tun: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ChildRepository</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BaseJpaRepository</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Child</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Long</span></span></span><span class="hljs-class">&gt;, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ChildRepositoryCustom</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//... }</span></span></code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Ein wichtiges Merkmal, das mit dem Namen verbunden ist</b> <div class="spoiler_text"><p>  Spring bindet unsere Klasse und Schnittstellen nur mit dem richtigen Namen zusammen: </p><br><ul><li>  Childrepository </li><li>  ChildRepository <strong>Custom</strong> </li><li>  ChildRepository <strong>Impl</strong> </li></ul><br><p>  Denken Sie daran, da im Falle eines Namensfehlers eine unverständliche Ausnahme ausgelöst wird, anhand derer die Fehlerursache nicht zu verstehen ist. </p></div></div><br><p>  Mit diesem Ansatz können Sie jetzt komplexere Probleme lösen.  Angenommen, wir müssen eine Auswahl basierend auf vom Benutzer ausgewählten Merkmalen treffen.  Mit anderen Worten, wenn der Benutzer die Daten "von" und "bis" nicht angegeben hat, erfolgt keine Zeitfilterung.  Wenn nur das Datum "von" oder nur das Datum "bis" angegeben wird, erfolgt die Filterung in eine Richtung.  Wenn beide Daten angegeben sind, fallen nur Datensätze zwischen den angegebenen Daten in die Auswahl: </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Getter</span></span> <span class="hljs-meta"><span class="hljs-meta">@RequiredArgsConstructor</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">RequestDto</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> LocalDate from; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> LocalDate to; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">hasDateFrom</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> from != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">hasDateTo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> to != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; } } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> List&lt;Child&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">findAll</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ChildRequest request)</span></span></span><span class="hljs-function"> </span></span>{ Map&lt;String, Object&gt; params = singletonMap(<span class="hljs-string"><span class="hljs-string">"request"</span></span>, request); String query = templateParser.prepareQuery(TEMPLATE.name, params); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> em.createQuery(query, Child.class).getResultList(); }</code> </pre> <br><p>  Nun die Vorlage: </p><br><pre> <code class="sql hljs">&lt;<span class="hljs-comment"><span class="hljs-comment">#-- @ftlvariable name="request" type="...RequestDto" --&gt; select child from Child child &lt;#if request.hasDateFrom() &amp;&amp; request.hasDateTo()&gt; where child.birthDate &gt;= :dateFrom and child.birthDate &lt;= :dateTo &lt;#elseif request.hasDateFrom()&gt; where child.birthDate &gt;= :dateFrom &lt;#elseif request.hasDateTo()&gt; where child.birthDate &lt;= :dateTo &lt;/#if&gt;</span></span></code> </pre> <br><h4 id="orakl-i-nvl">  Oracle und nvl </h4><br><p>  Betrachten Sie die Essenz: </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Entity</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DailyRecord</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Id</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Long id; <span class="hljs-meta"><span class="hljs-meta">@Column</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> String currency; <span class="hljs-meta"><span class="hljs-meta">@Column</span></span>(name = <span class="hljs-string"><span class="hljs-string">"record_rate"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> BigDecimal rate; <span class="hljs-meta"><span class="hljs-meta">@Column</span></span>(name = <span class="hljs-string"><span class="hljs-string">"fixed_rate"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> BigDecimal fxRate; <span class="hljs-meta"><span class="hljs-meta">@Setter</span></span>(value = AccessLevel.PRIVATE) <span class="hljs-meta"><span class="hljs-meta">@Formula</span></span>(<span class="hljs-string"><span class="hljs-string">"select avg(r.record_rate) from daily_record r where r.currency = currency"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> BigDecimal avgRate; }</code> </pre> <br><p>  Diese Entität wird in der Abfrage verwendet (DBMS, wie wir uns erinnern, haben wir Oracle): </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Query</span></span>(<span class="hljs-string"><span class="hljs-string">"select nvl(record.fxRate, record.avgRate) "</span></span> + <span class="hljs-string"><span class="hljs-string">" from DailyRecord record "</span></span> + <span class="hljs-string"><span class="hljs-string">"where record.currency = :currency"</span></span>) <span class="hljs-function"><span class="hljs-function">BigDecimal </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">findRateByCurrency</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@Param(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"currency"</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> String currency)</span></span>;</code> </pre> <br><p>  Dies ist eine funktionierende, gültige Anfrage.  Es gibt jedoch ein kleines Problem, auf das SQL-Experten wahrscheinlich hinweisen werden.  Tatsache ist, dass <code>nvl</code> in Oracle nicht faul ist.  Mit anderen Worten, wenn wir die <code>findRateByCurrency</code> Methode <code>findRateByCurrency</code> , wird das <code>findRateByCurrency</code> </p><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">select</span></span> nvl( dr.fixed_rate, <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-keyword"><span class="hljs-keyword">avg</span></span>(r.record_rate) <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> daily_record r <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> r.currency = dr.currency ) <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> daily_record dr <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> dr.currency = ?</code> </pre> <br><p>  Selbst wenn der Wert <code>dr.fixed_rate</code> vorhanden ist, berechnet das DBMS den Wert, der vom zweiten Ausdruck in <code>nvl</code> , in unserem Fall </p><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-keyword"><span class="hljs-keyword">avg</span></span>(r.record_rate) <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> daily_record r <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> r.currency = dr.currency)</code> </pre> <br><p>  Der Leser weiß wahrscheinlich bereits, wie er dem unnötigen Gewicht der Anfrage ausweichen kann: Dies ist natürlich das <code>coalesce</code> Schlüsselwort, das im Vergleich zu <code>nvl</code> seiner Faulheit und der Fähigkeit, mehr als zwei Ausdrücke zu akzeptieren, günstig ist.  Korrigieren wir unsere Anfrage: </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Query</span></span>(<span class="hljs-string"><span class="hljs-string">"select coalesce(record.fxRate, record.avgRate) "</span></span> + <span class="hljs-string"><span class="hljs-string">" from DailyRecord record "</span></span> + <span class="hljs-string"><span class="hljs-string">"where record.currency = :currency"</span></span>) <span class="hljs-function"><span class="hljs-function">BigDecimal </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">findRateByCurrency</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@Param(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"currency"</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> String currency)</span></span>;</code> </pre> <br><p>  Und dann, wie sie sagen, plötzlich: </p><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">select</span></span> nvl(dr.fixed_rate, <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-keyword"><span class="hljs-keyword">avg</span></span>(r.record_rate) <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> daily_record r <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> r.currency = dr.currency) <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> daily_record dr <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> dr.currency = ?</code> </pre> <br><p>  Die Anfrage blieb gleich.  Das liegt daran, dass der Orakel-Dialekt aus der Box die <code>nvl</code> in eine <code>nvl</code> Kette <code>nvl</code> . </p><br><div class="spoiler">  <b class="spoiler_title">Bemerkung</b> <div class="spoiler_text"><p>  Wenn Sie dieses Verhalten reproduzieren möchten, löschen Sie die zweite Zeile im Konstruktor der <a href="">CustomOracleDialect-</a> Klasse und führen Sie den <code>DailyRecordRepositoryTest::findRateByCurrency</code> </p></div></div><br><p>  Um dem auszuweichen, müssen Sie Ihren eigenen Dialekt erstellen und in der Anwendung verwenden: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CustomOracleDialect</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Oracle12cDialect</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CustomOracleDialect</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>(); registerFunction(<span class="hljs-string"><span class="hljs-string">"coalesce"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StandardSQLFunction(<span class="hljs-string"><span class="hljs-string">"coalesce"</span></span>)); } }</code> </pre> <br><p>  Ja, das ist so einfach.  Jetzt binden wir den erstellten Dialekt an die Anwendung: </p><br><pre> <code class="plaintext hljs">spring: jpa: database-platform: com.luxoft.logeek.config.CustomOracleDialect</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Ein anderer (veralteter) Weg:</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">spring: jpa: properties: hibernate.dialect: com.luxoft.logeek.config.CustomOracleDialect</code> </pre> </div></div><br><p>  Die wiederholte Ausführung der Anfrage ergibt den begehrten Koalesk: </p><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-keyword"><span class="hljs-keyword">coalesce</span></span>(dr.fixed_rate, <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-keyword"><span class="hljs-keyword">avg</span></span>(r.record_rate) <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> daily_record r <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> r.currency = dr.currency) <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> daily_record dr <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> dr.currency = ?</code> </pre> <br><h4 id="orakl-i-postranichnye-zaprosy">  Oracle- und Seitenanforderungen </h4><br><p>  Im Allgemeinen bietet die Vervollständigung eines Dialekts umfangreiche Möglichkeiten zur Manipulation von Abfragen.  Bei der Entwicklung einer Anwendung und eines Webface tritt häufig die Aufgabe des seitenweisen Hochladens von Daten auf.  Mit anderen Worten, wir haben mehrere hunderttausend Datensätze in der Datenbank, die jedoch in Paketen mit 10/50/100 Datensätzen pro Seite angezeigt werden.  Das sofort einsatzbereite Frühlingsdatum bietet dem Entwickler ähnliche Funktionen: </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Query</span></span>(<span class="hljs-string"><span class="hljs-string">"select new com.luxoft.logeek.data.BriefChildData("</span></span> + <span class="hljs-string"><span class="hljs-string">"c.id, "</span></span> + <span class="hljs-string"><span class="hljs-string">"c.age "</span></span> + <span class="hljs-string"><span class="hljs-string">") from Child c "</span></span> + <span class="hljs-string"><span class="hljs-string">" join c.parent p "</span></span> + <span class="hljs-string"><span class="hljs-string">"where p.name = ''"</span></span>) <span class="hljs-function"><span class="hljs-function">Page&lt;BriefChildData&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">browse</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Pageable pageable)</span></span></span></span>;</code> </pre> <br><p>  Dieser Ansatz hat einen erheblichen Nachteil, nämlich die Ausführung von zwei Abfragen, von denen die erste die Daten abruft und die zweite ihre Gesamtzahl in der Datenbank bestimmt (dies ist erforderlich, um die Gesamtdatenmenge im <code>Page</code> Objekt anzuzeigen).  In unserem Fall gibt ein Aufruf dieser Methode die folgenden Anforderungen (Protokollierung mit p6spy): </p><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> c.id, c.age <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-keyword"><span class="hljs-keyword">child</span></span> c <span class="hljs-keyword"><span class="hljs-keyword">inner</span></span> <span class="hljs-keyword"><span class="hljs-keyword">join</span></span> <span class="hljs-keyword"><span class="hljs-keyword">parent</span></span> p <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> c.parent_id = p.id <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> p.name = <span class="hljs-string"><span class="hljs-string">''</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> <span class="hljs-keyword"><span class="hljs-keyword">rownum</span></span> &lt;= <span class="hljs-number"><span class="hljs-number">3</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-keyword"><span class="hljs-keyword">count</span></span>(c.id) <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-keyword"><span class="hljs-keyword">child</span></span> c <span class="hljs-keyword"><span class="hljs-keyword">inner</span></span> <span class="hljs-keyword"><span class="hljs-keyword">join</span></span> <span class="hljs-keyword"><span class="hljs-keyword">parent</span></span> p <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> c.parent_id = p.id <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> p.name = <span class="hljs-string"><span class="hljs-string">''</span></span></code> </pre> <br><p>  Wenn die Abfrage sehr umfangreich ist (viele Tabellen werden durch eine nicht indizierbare Spalte, nur viele Verknüpfungen, eine schwierige Auswahlbedingung usw. verbunden), kann dies zu einem Problem werden.  Aber da wir Oracle haben, können Sie mit der Rownum-Pseudospalte mit einer Anfrage auskommen. </p><br><p>  Dazu müssen wir unseren Dialekt beenden und die Funktion beschreiben, mit der alle Datensätze gezählt werden: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CustomOracleDialect</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Oracle12cDialect</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CustomOracleDialect</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>(); registerFunction(<span class="hljs-string"><span class="hljs-string">"coalesce"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StandardSQLFunction(<span class="hljs-string"><span class="hljs-string">"coalesce"</span></span>)); registerFunction(<span class="hljs-string"><span class="hljs-string">"total_count"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> TotalCountFunc()); } } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TotalCountFunc</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SQLFunction</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">hasArguments</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">hasParenthesesIfNoArguments</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Type </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getReturnType</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Type type, Mapping mapping)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> StandardBasicTypes.LONG; } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">render</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Type type, List arguments, SessionFactoryImplementor factory)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (arguments.size() != <span class="hljs-number"><span class="hljs-number">1</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> IllegalArgumentException(<span class="hljs-string"><span class="hljs-string">"Only 1 argument acceptable"</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">" count("</span></span> + arguments.get(<span class="hljs-number"><span class="hljs-number">0</span></span>) + <span class="hljs-string"><span class="hljs-string">") over () "</span></span>; } }</code> </pre> <br><p>  Schreiben Sie nun eine neue Abfrage (in der <code>ChildRepositoryImpl</code> Klasse): </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Page&lt;BriefChildData&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">browseWithTotalCount</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Pageable pageable)</span></span></span><span class="hljs-function"> </span></span>{ String query = <span class="hljs-string"><span class="hljs-string">"select "</span></span> + <span class="hljs-string"><span class="hljs-string">" c.id as id,"</span></span> + <span class="hljs-string"><span class="hljs-string">" c.age as age, "</span></span> + <span class="hljs-string"><span class="hljs-string">" total_count(c.id) as totalCount"</span></span> + <span class="hljs-string"><span class="hljs-string">" from Child c "</span></span> + <span class="hljs-string"><span class="hljs-string">"join c.parent p "</span></span> + <span class="hljs-string"><span class="hljs-string">"where p.name = ''"</span></span>; List&lt;BriefChildData&gt; list = em.unwrap(Session.class) .createQuery(query) .setFirstResult((<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>) pageable.getOffset()) .setMaxResults(pageable.getPageSize()) .setResultTransformer(Transformers.aliasToBean(BriefChildData.class)) .getResultList(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (list.isEmpty()) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> PageImpl(Collections.emptyList()); } <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> totalCount = list.get(<span class="hljs-number"><span class="hljs-number">0</span></span>).getTotalCount(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> PageImpl&lt;&gt;(list, pageable, totalCount); }</code> </pre> <br><p>  Beim Aufrufen dieses Codes wird eine Anforderung ausgeführt </p><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">select</span></span> c.id, c.age, <span class="hljs-keyword"><span class="hljs-keyword">count</span></span>(c.id) <span class="hljs-keyword"><span class="hljs-keyword">over</span></span> () <span class="hljs-comment"><span class="hljs-comment">-- &lt;----- from child c inner join parent p on c.parent_id = p.id where p.name = '') where rownum &lt;= 3</span></span></code> </pre> <br><p>  Mit dem Ausdruck <code>count(c.id) over ()</code> Sie die Gesamtdatenmenge <code>count(c.id) over ()</code> und von der Datenklasse <code>PageImpl</code> um sie an den <code>PageImpl</code> Konstruktor zu übergeben.  Es gibt eine Möglichkeit, dies eleganter zu gestalten, ohne der Datenklasse ein weiteres Feld hinzuzufügen. Betrachten Sie es als Hausaufgabe :) Sie können die Lösung mit dem <a href="">ProjectionVsDataTest-</a> Test testen. </p><br><h4 id="podvodnye-kamni-kastomizacii">  Fallstricke der Anpassung </h4><br><p>  Wir haben ein cooles Projekt mit Oracle und Spring Date.  Unsere Aufgabe ist es, die Leistung eines solchen Codes zu verbessern: </p><br><pre> <code class="java hljs">List&lt;Long&gt; ids = getIds(); ids.stream() .map(repository::findById) .filter(Optional::isPresent) .map(Optional::get) .forEach(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>::sendToSchool);</code> </pre> <br><p>  Der Nachteil liegt an der Oberfläche: Die Anzahl der Datenbankabfragen entspricht der Anzahl der eindeutigen Schlüssel.  Es gibt eine bekannte Methode, um diese Schwierigkeit zu überwinden: </p><br><pre> <code class="java hljs">List&lt;Long&gt; ids = getIds(); repository .findAllById(ids) .forEach(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>::sendToSchool);</code> </pre> <br><p>  Der Vorteil der Mehrfachabtastung liegt auf der Hand: Wenn wir früher viele ähnliche Abfragen des Formulars hatten </p><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">select</span></span> p.* <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> Pupil p <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> p.id = <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> p.* <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> Pupil p <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> p.id = <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> p.* <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> Pupil p <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> p.id = <span class="hljs-number"><span class="hljs-number">3</span></span></code> </pre> <br><p>  dann sind sie jetzt zu einem zusammengebrochen </p><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">select</span></span> p.* <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> Pupil p <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> p.id <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> (<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, ... )</code> </pre> <br><p>  Es scheint einfacher zu sein und wurde gut.  Das Projekt wächst, entwickelt sich, die Daten vervielfachen sich und sobald das Unvermeidliche eintritt: </p><br><div class="spoiler">  <b class="spoiler_title">Aki donnert am klaren Himmel</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">ERROR - ORA-01795: maximum number of expressions in a list is 1000</code> </pre> </div></div><br><p>  Wir müssen wieder nach einem Ausweg suchen (nicht zur alten Version zurückkehren).  Da Oracle nicht zulässt, dass er mehr als 1000 Schlüssel füttert, können Sie den gesamten Datensatz in gleiche Anteile von nicht mehr als 1000 aufteilen und mehrere Abfragen ausführen: </p><br><pre> <code class="java hljs">List&lt;List&lt;Long&gt;&gt; idChunks = cgccLists.partition(ids, <span class="hljs-number"><span class="hljs-number">1000</span></span>); <span class="hljs-comment"><span class="hljs-comment">//* idChunks.forEach(idChunk -&gt; repository.findAllById(idChunk).forEach(this::sendToSchool) ); //* cgccLists = com.google.common.collect.Lists</span></span></code> </pre> <br><p>  Diese Methode funktioniert, riecht aber leicht (oder?): Wenn Sie an anderen Stellen auf solche Schwierigkeiten stoßen, müssen Sie denselben Garten umzäunen.  Versuchen wir, das Problem eleganter zu lösen, indem <code>BaseJpaRepositoryImpl</code> .  Der einfachste Weg, dies zu tun, besteht darin, die obige Logik nach innen zu übertragen und sie vor dem Benutzer zu verbergen: </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> List&lt;T&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">findAllById</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Iterable&lt;ID&gt; ids)</span></span></span><span class="hljs-function"> </span></span>{ Assert.notNull(ids, <span class="hljs-string"><span class="hljs-string">"The given Iterable of Id's must not be null!"</span></span>); Set&lt;ID&gt; idsCopy = Sets.newHashSet(ids); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (idsCopy.size() &lt;= OracleConstants.MAX_IN_COUNT) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.findAllById(ids); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> findAll(idsCopy); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> List&lt;T&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">findAll</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Collection&lt;ID&gt; ids)</span></span></span><span class="hljs-function"> </span></span>{ List&lt;List&lt;ID&gt;&gt; idChunks = Lists.partition(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList&lt;&gt;(ids), <span class="hljs-number"><span class="hljs-number">1000</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> idChunks .stream() .map(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>::findAllById) .flatMap(List::stream) .collect(Collectors.toList()); }</code> </pre> <br><p>  Es wurde besser: Erstens haben wir den <code>BaseJpaRepository</code> von den Infrastrukturebenen entfernt und zweitens haben wir den Umfang unserer Lösung auf alle Projekt-Repositorys erweitert, die <code>BaseJpaRepository</code> .  Es gibt auch Nachteile.  Die Hauptanforderung besteht aus mehreren Anforderungen anstelle einer und auch (ergibt sich aus der Hauptanforderung) aus der Notwendigkeit, die Schlüssel zu filtern. <code>idChunks</code> kann derselbe Schlüssel in verschiedenen <code>idChunks</code> .  Dies bedeutet wiederum, dass dieselbe Entität zweimal in die Liste aufgenommen und dementsprechend zweimal verarbeitet wird.  Wir brauchen das nicht, deshalb hier eine andere, komplexere Lösung: </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> List&lt;T&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">findAllById</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Iterable&lt;ID&gt; ids)</span></span></span><span class="hljs-function"> </span></span>{ Assert.notNull(ids, <span class="hljs-string"><span class="hljs-string">"The given Iterable of Id's must not be null!"</span></span>); ArrayList&lt;ID&gt; idsCopy = Lists.newArrayList(ids); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (idsCopy.size() &lt;= OracleConstants.MAX_IN_COUNT) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.findAllById(ids); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> findAll(idsCopy); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> List&lt;T&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">findAll</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ArrayList&lt;ID&gt; ids)</span></span></span><span class="hljs-function"> </span></span>{ CriteriaBuilder cb = entityManager.getCriteriaBuilder(); CriteriaQuery&lt;T&gt; query = cb.createQuery(getDomainClass()); Root&lt;T&gt; from = query.from(getDomainClass()); Predicate predicate = toPredicate(cb, ids, from); query = query.select(from).where(predicate); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> entityManager.createQuery(query).getResultList(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> Predicate </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">toPredicate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(CriteriaBuilder cb, ArrayList&lt;ID&gt; ids, Root&lt;T&gt; root)</span></span></span><span class="hljs-function"> </span></span>{ List&lt;List&lt;ID&gt;&gt; chunks = Lists.partition(ids, OracleConstants.MAX_IN_COUNT); SingularAttribute&lt;? <span class="hljs-keyword"><span class="hljs-keyword">super</span></span> T, ?&gt; id = entityInfo.getIdAttribute(); Predicate[] predicates = chunks.stream() .map(chunk -&gt; root.get(id).in(chunk)) .toArray(Predicate[]::<span class="hljs-keyword"><span class="hljs-keyword">new</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> cb.or(predicates); }</code> </pre> <br><p>  Es verwendet die Kriterien-API, mit der eine letzte Abfrage des Formulars erstellt werden kann </p><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">select</span></span> p.* <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> Pupil p <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> p.id <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> (<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, ... , <span class="hljs-number"><span class="hljs-number">1000</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> p.id <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> (<span class="hljs-number"><span class="hljs-number">1001</span></span>, ... , <span class="hljs-number"><span class="hljs-number">2000</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> p.id <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> (<span class="hljs-number"><span class="hljs-number">2001</span></span>, ... , <span class="hljs-number"><span class="hljs-number">3000</span></span>)</code> </pre> <br><p>  Es gibt eine Subtilität: Eine ähnliche Anforderung kann aufgrund der umständlichen Bedingungen länger als gewöhnlich ausgeführt werden, so dass die erste Methode (manchmal) vorzuziehen ist. </p><br><p>  Das ist alles, ich hoffe, die Beispiele waren nützlich für Sie und nützlich für die tägliche Entwicklung.  Kommentare und Ergänzungen sind willkommen. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de444240/">https://habr.com/ru/post/de444240/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de444226/index.html">@ Pythonetc Compilation Februar 2019</a></li>
<li><a href="../de444228/index.html">Tipps und Tricks von meinem Telegramm-Kanal @pythonetc, Februar 2019</a></li>
<li><a href="../de444230/index.html">Staatliches Internet: China Remote VPN Story</a></li>
<li><a href="../de444234/index.html">DeepMind und Google: Der Kampf um die Kontrolle über starke KI</a></li>
<li><a href="../de444238/index.html">Verweigern Sie mit einem Klick, oder wie ein Designer einen Traumjob bekommt</a></li>
<li><a href="../de444242/index.html">Überprüfen von FreeRDP mit dem PVS-Studio-Analysegerät</a></li>
<li><a href="../de444244/index.html">Bewegung durch Raum und Zeit</a></li>
<li><a href="../de444246/index.html">Überprüfen von FreeRDP mit PVS-Studio</a></li>
<li><a href="../de444248/index.html">Kopfloses Testen in einem Browser. Vorteile und Nachteile</a></li>
<li><a href="../de444250/index.html">Sind die Leute nicht bereit für Bitcoin oder Bitcoin für die Massenadoption?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>