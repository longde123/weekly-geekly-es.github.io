<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🌓 🏗️ 👩‍🚒 Arbeiten mit Daten beim Erstellen einer API auf Basis von GraphQL 🌇 🚶🏼 💪🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Präambel 


 Dieser Artikel richtet sich zunächst an Leser, die bereits mit GraphQL vertraut sind und mehr über die Feinheiten und Nuancen der Arbeit ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Arbeiten mit Daten beim Erstellen einer API auf Basis von GraphQL</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/427399/"><h3 id="preambula">  Präambel </h3><br><p>  Dieser Artikel richtet sich zunächst an Leser, die bereits mit GraphQL vertraut sind und mehr über die Feinheiten und Nuancen der Arbeit mit GraphQL erfahren.  Trotzdem hoffe ich, dass es für Anfänger nützlich sein wird. </p><br><p>  GraphQL ist ein großartiges Werkzeug.  Ich denke, viele Menschen kennen und verstehen die Vorteile bereits.  Beim Erstellen Ihrer GraphQL-basierten APIs sind jedoch einige Nuancen zu beachten. </p><br><p>  Mit GraphQL können Sie beispielsweise zum Verbraucher (Benutzer oder Programm) zurückkehren und nur die Daten anfordern, an denen dieser Verbraucher interessiert ist.  Beim Erstellen eines Servers kann es jedoch leicht zu Fehlern kommen, was dazu führt, dass die Daten innerhalb des Servers (der unter anderem verteilt werden kann) in vollständigen "Bundles" ausgeführt werden.  Dies ist in erster Linie auf die Tatsache zurückzuführen, dass GraphQL selbst keine praktischen Tools zum Parsen einer eingehenden Abfrage bietet und die darin verlegten Schnittstellen nicht gut dokumentiert sind. </p><a name="habracut"></a><br><h3 id="istochnik-problemy">  Problemquelle </h3><br><p>  Schauen wir uns ein typisches Beispiel für eine nicht optimale Implementierung an (öffnen Sie das Bild in einem separaten Fenster, wenn es schlecht gelesen wird): </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/497/409/cb6/497409cb638a09186c79f0c60e49154c.png" alt="Bild"></p><br><p>  Angenommen, unser Verbraucher ist eine bestimmte Anwendung oder Komponente des "Telefonbuchs", die von unserer API nur die Kennung, den Namen und die Telefonnummer der von uns gespeicherten Benutzer abfragt.  Gleichzeitig ist unsere API viel umfangreicher und ermöglicht den Zugriff auf andere Daten, wie z. B. die physische Adresse des Wohnsitzes und die E-Mail-Adresse der Benutzer. </p><br><p>  Beim Datenaustausch zwischen dem Verbraucher und der API erledigt GraphQL alle erforderlichen Arbeiten perfekt - nur die angeforderten Daten werden als Antwort auf die Anforderung gesendet.  Das Problem liegt in diesem Fall an der Stelle, an der Daten aus der Datenbank abgetastet werden - d. H.  in der internen Implementierung unseres Servers, und es besteht in der Tatsache, dass wir für jede eingehende Anfrage alle Benutzerdaten aus der Datenbank auswählen, obwohl wir einige davon nicht benötigen.  Dies führt zu einer übermäßigen Belastung der Datenbank und zu einer Zirkulation von übermäßigem Datenverkehr innerhalb des Systems.  Bei einer erheblichen Anzahl von Abfragen können Sie eine erhebliche Optimierung erzielen, indem Sie den Ansatz für die Datenerfassung ändern und nur die Felder auswählen, die angefordert wurden.  Gleichzeitig spielt es keine Rolle, was unsere Datenquelle ist - eine relationale Datenbank, NoSQL-Technologie oder ein anderer Dienst (intern oder extern).  Jedes nicht optimale Verhalten kann durch jede Implementierung beeinflusst werden.  In diesem Fall wird MySQL lediglich als Beispiel ausgewählt. </p><br><h3 id="reshenie">  Lösung </h3><br><p> Es ist möglich, dieses Serververhalten zu optimieren, wenn wir die Argumente analysieren, die zur Funktion <code>resolve()</code> : </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">async</span></span> resolve(source, args, context, info) { <span class="hljs-comment"><span class="hljs-comment">// ... }</span></span></code> </pre> <br><p>  Es ist das letzte Argument, <code>info</code> , das in diesem Fall für uns von besonderem Interesse ist.  Wir wenden uns der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Dokumentation zu</a> und analysieren im Detail, woraus die Funktion <code>resolve()</code> und das Argument bestehen, an dem wir interessiert sind: </p><br><pre> <code class="hljs haskell"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">GraphQLFieldResolveFn</span></span></span><span class="hljs-class"> = ( </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">source</span></span></span><span class="hljs-class">?: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">any</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">args</span></span></span><span class="hljs-class">?: {[</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">argName</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">string</span></span></span><span class="hljs-class">]: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">any</span></span></span><span class="hljs-class">}, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">context</span></span></span><span class="hljs-class">?: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">any</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">info</span></span></span><span class="hljs-class">?: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">GraphQLResolveInfo</span></span></span><span class="hljs-class"> ) =&gt; any </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">GraphQLResolveInfo</span></span></span><span class="hljs-class"> = { </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">fieldName</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">string</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">fieldNodes</span></span></span><span class="hljs-class">: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Array</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Field</span></span></span><span class="hljs-class">&gt;, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">returnType</span></span></span><span class="hljs-class">: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">GraphQLOutputType</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">parentType</span></span></span><span class="hljs-class">: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">GraphQLCompositeType</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">schema</span></span></span><span class="hljs-class">: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">GraphQLSchema</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">fragments</span></span></span><span class="hljs-class">: { [</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">fragmentName</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">string</span></span></span><span class="hljs-class">]: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">FragmentDefinition</span></span></span><span class="hljs-class"> }, rootValue: any, operation: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">OperationDefinition</span></span></span><span class="hljs-class">, variableValues: { [</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">variableName</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">string</span></span></span><span class="hljs-class">]: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">any</span></span></span><span class="hljs-class"> }, }</span></span></code> </pre> <br><p>  Die ersten drei Argumente, die an den Resolver übergeben werden, sind <code>source</code> - die vom übergeordneten Knoten im GraphQL-Baum des Schemas übergebenen Daten, Argumente - die Anforderungsargumente (die aus der Abfrage stammen) und der <code>context</code> - das vom Entwickler definierte Ausführungskontextobjekt, das häufig zum Übertragen einiger globaler Daten aufgerufen wird in den "Resolvern".  Und schließlich ist das vierte Argument die Metainformation über die Anfrage. </p><br><p>  Was können wir aus <code>GraphQLResolveInfo</code> extrahieren, um unser Problem zu lösen? </p><br><p>  Die interessantesten Teile sind: </p><br><ul><li>  <code>fieldName</code> ist der aktuelle Feldname des GraphQL-Schemas.  Das heißt,  Es entspricht dem Feldnamen, der im Schema für diesen Resolver angegeben ist.  Wenn wir das <code>info</code> Objekt im <code>users</code> abfangen, wie in unserem obigen Beispiel, werden "Benutzer" als Wert von <code>fieldName</code> </li><li>  <code>fieldNodes</code> - Sammlung (Array) von Knoten, die in der Abfrage angefordert wurden.  Genau das, was benötigt wird! </li><li>  <code>fragments</code> - Eine Sammlung von Fragmenten der Anforderung (falls die Anforderung fragmentiert war).  Auch wichtige Informationen zum Abrufen der endgültigen Datenfelder. </li></ul><br><p>  Als Lösung müssen wir das <code>info</code> Tool analysieren, die Liste der Felder auswählen, die aus der Abfrage zu uns gekommen sind, und sie dann an die SQL-Abfrage übergeben.  Leider gibt uns das GraphQL-Paket von Facebook "out of the box" nichts, um diese Aufgabe zu vereinfachen.  Insgesamt ist diese Aufgabe, wie die Praxis gezeigt hat, angesichts der Tatsache, dass Anforderungen fragmentiert werden können, nicht so trivial.  Außerdem hat eine solche Analyse eine universelle Lösung, die anschließend einfach von Projekt zu Projekt kopiert wird. </p><br><p>  Also habe ich beschlossen, es als Open-Source-Bibliothek unter der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ISC-</a> Lizenz zu schreiben.  Mit seiner Hilfe wird die Lösung zum Parsen eingehender Abfragefelder ganz einfach gelöst, zum Beispiel in unserem Fall wie folgt: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { fieldsList } = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'graphql-fields-list'</span></span>); <span class="hljs-comment"><span class="hljs-comment">// ... async resolve(source, args, context, info) { const requestedFields = fieldsList(info); return await database.query(`SELECT ${requestedFields.join(',')} FROM users`) }</span></span></code> </pre> <br><p>  <code>fieldsList(info)</code> in diesem Fall die gesamte Arbeit für uns und gibt ein "flaches" Array von untergeordneten Feldern für diesen Resolver zurück, d. h.  Unsere letzte SQL-Abfrage sieht folgendermaßen aus: </p><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">id</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">name</span></span>, phone <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> <span class="hljs-keyword"><span class="hljs-keyword">users</span></span>;</code> </pre> <br><p>  Wenn wir die eingehende Anfrage ändern in: </p><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">query</span></span> UserListQuery { <span class="hljs-section"><span class="hljs-section">users</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">id</span></span> name phone email } }</code> </pre> <br><p>  dann wird die SQL-Abfrage zu: </p><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">id</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">name</span></span>, phone, email <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> <span class="hljs-keyword"><span class="hljs-keyword">users</span></span>;</code> </pre> <br><p>  Eine so einfache Herausforderung ist jedoch nicht immer möglich.  Reale Anwendungen sind häufig viel komplexer aufgebaut.  In einigen Implementierungen müssen wir möglicherweise den Resolver auf der oberen Ebene in Bezug auf die Daten im endgültigen GraphQL-Schema beschreiben.  Wenn wir uns beispielsweise für die Verwendung der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Relay-</a> Bibliothek entschieden haben, möchten wir einen vorgefertigten Mechanismus zum Aufteilen von Sammlungen von Datenobjekten in Seiten verwenden, was dazu führt, dass unser GraphQL-Schema nach bestimmten Regeln erstellt wird.  Zum Beispiel überarbeiten wir unser Schema folgendermaßen (TypeScript): </p><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { GraphQLObjectType, GraphQLSchema, GraphQLString } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'graphql'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { connectionDefinitions, connectionArgs, nodeDefinitions, fromGlobalId, globalIdField, connectionFromArray, GraphQLResolveInfo, } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'graphql-relay'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { fieldsList } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'graphql-fields-list'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { nodeInterface, nodeField } = nodeDefinitions(<span class="hljs-keyword"><span class="hljs-keyword">async</span></span> (globalId: string) =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { type, id } = fromGlobalId(globalId); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> node: any = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (type === <span class="hljs-string"><span class="hljs-string">'User'</span></span>) { node = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> database.select(<span class="hljs-string"><span class="hljs-string">`SELECT id FROM user WHERE id="</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${id}</span></span></span><span class="hljs-string">"`</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> node; }); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> User = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> GraphQLObjectType({ <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">'User'</span></span>, <span class="hljs-attr"><span class="hljs-attr">interfaces</span></span>: [nodeInterface], <span class="hljs-attr"><span class="hljs-attr">fields</span></span>: { <span class="hljs-attr"><span class="hljs-attr">id</span></span>: globalIdField(<span class="hljs-string"><span class="hljs-string">'User'</span></span>, (user: any) =&gt; user.id), <span class="hljs-attr"><span class="hljs-attr">name</span></span>: { <span class="hljs-attr"><span class="hljs-attr">type</span></span>: GraphQLString }, <span class="hljs-attr"><span class="hljs-attr">email</span></span>: { <span class="hljs-attr"><span class="hljs-attr">type</span></span>: GraphQLString }, <span class="hljs-attr"><span class="hljs-attr">phone</span></span>: { <span class="hljs-attr"><span class="hljs-attr">type</span></span>: GraphQLString }, <span class="hljs-attr"><span class="hljs-attr">address</span></span>: { <span class="hljs-attr"><span class="hljs-attr">type</span></span>: GraphQLString }, } }); <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-attr"><span class="hljs-attr">connectionType</span></span>: userConnection } = connectionDefinitions({ <span class="hljs-attr"><span class="hljs-attr">nodeType</span></span>: User }); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Query = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> GraphQLObjectType({ <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">'Query'</span></span>, <span class="hljs-attr"><span class="hljs-attr">fields</span></span>: { <span class="hljs-attr"><span class="hljs-attr">node</span></span>: nodeField, <span class="hljs-attr"><span class="hljs-attr">users</span></span>: { <span class="hljs-attr"><span class="hljs-attr">type</span></span>: userConnection, <span class="hljs-attr"><span class="hljs-attr">args</span></span>: { ...connectionArgs }, <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> resolve( source: any, <span class="hljs-attr"><span class="hljs-attr">args</span></span>: {[argName: string]: any}, <span class="hljs-attr"><span class="hljs-attr">context</span></span>: any, <span class="hljs-attr"><span class="hljs-attr">info</span></span>: GraphQLResolveInfo, ) { <span class="hljs-comment"><span class="hljs-comment">// </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">TODO:</span></span></span><span class="hljs-comment"> implement }, }, }); export const schema = new GraphQLSchema({ query: Query });</span></span></code> </pre> <br><p>  In diesem Fall fügt die <code>connectionDefinition</code> von Relais dem Schema <code>edges</code> , <code>node</code> , <code>pageInfo</code> und <code>pageInfo</code> , d. H.  Wir müssen unsere Abfragen jetzt anders neu erstellen (wir werden uns jetzt nicht mit der Paginierung befassen): </p><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">query</span></span> UserListQuery { <span class="hljs-section"><span class="hljs-section">users</span></span> { <span class="hljs-section"><span class="hljs-section">edges</span></span> { <span class="hljs-section"><span class="hljs-section">node</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">id</span></span> name phone email } } } }</code> </pre> <br><p>  <code>resolve()</code> auf dem <code>users</code> implementierte Funktion nun bestimmen, welche Felder nicht für sich selbst angefordert werden, sondern für den verschachtelten <code>edges.node</code> , der, wie wir sehen, relativ zu den <code>users</code> entlang des Pfades <code>edges.node</code> . </p><br><p>  <code>fieldsList</code> aus der Bibliothek <code>graphql-fields-list</code> hilft ebenfalls bei der Lösung dieses Problems. <code>fieldsList</code> die entsprechende <code>graphql-fields-list</code> .  Hier ist zum Beispiel die Implementierung in unserem Fall: </p><br><pre> <code class="hljs pgsql">async resolve( source: <span class="hljs-keyword"><span class="hljs-keyword">any</span></span>, args: {[argName: string]: <span class="hljs-keyword"><span class="hljs-keyword">any</span></span>}, context: <span class="hljs-keyword"><span class="hljs-keyword">any</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">info</span></span>: GraphQLResolveInfo, ) { const fields = fieldsList(<span class="hljs-keyword"><span class="hljs-keyword">info</span></span>, { <span class="hljs-type"><span class="hljs-type">path</span></span>: <span class="hljs-string"><span class="hljs-string">'edges.node'</span></span> }); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> connectionFromArray( await <span class="hljs-keyword"><span class="hljs-keyword">database</span></span>.query(`<span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> ${fields.<span class="hljs-keyword"><span class="hljs-keyword">join</span></span>(<span class="hljs-string"><span class="hljs-string">','</span></span>)} <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> users`), args ); }</code> </pre> <br><p>  Auch in der realen Welt kann es sein, dass wir im GraphQL-Schema nur einen Feldnamen definiert haben und im Datenbankschema andere Feldnamen diesen entsprechen.  Angenommen, die Benutzertabelle in der Datenbank wurde anders definiert: </p><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">users</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">id</span></span> <span class="hljs-built_in"><span class="hljs-built_in">BIGINT</span></span> PRIMARY <span class="hljs-keyword"><span class="hljs-keyword">KEY</span></span> AUTO_INCREMENT, fullName <span class="hljs-built_in"><span class="hljs-built_in">VARCHAR</span></span>(<span class="hljs-number"><span class="hljs-number">255</span></span>), email <span class="hljs-built_in"><span class="hljs-built_in">VARCHAR</span></span>(<span class="hljs-number"><span class="hljs-number">255</span></span>), phoneNumber <span class="hljs-built_in"><span class="hljs-built_in">VARCHAR</span></span>(<span class="hljs-number"><span class="hljs-number">15</span></span>), address <span class="hljs-built_in"><span class="hljs-built_in">VARCHAR</span></span>(<span class="hljs-number"><span class="hljs-number">255</span></span>) );</code> </pre> <br><p>  In diesem Fall sollten die Felder aus der GraphQL-Abfrage umbenannt werden, bevor sie in die SQL-Abfrage eingebettet werden.  <code>fieldsList</code> hilft dabei, wenn Sie eine <code>fieldsList</code> in der entsprechenden <code>transform</code> : </p><br><pre> <code class="hljs pgsql">async resolve( source: <span class="hljs-keyword"><span class="hljs-keyword">any</span></span>, args: {[argName: string]: <span class="hljs-keyword"><span class="hljs-keyword">any</span></span>}, context: <span class="hljs-keyword"><span class="hljs-keyword">any</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">info</span></span>: GraphQLResolveInfo, ) { const fields = fieldsList(<span class="hljs-keyword"><span class="hljs-keyword">info</span></span>, { <span class="hljs-type"><span class="hljs-type">path</span></span>: <span class="hljs-string"><span class="hljs-string">'edges.node'</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">transform</span></span>: { phone: <span class="hljs-string"><span class="hljs-string">'phoneNumber'</span></span>, <span class="hljs-type"><span class="hljs-type">name</span></span>: <span class="hljs-string"><span class="hljs-string">'fullName'</span></span> }, }); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> connectionFromArray( await <span class="hljs-keyword"><span class="hljs-keyword">database</span></span>.query(`<span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> ${fields.<span class="hljs-keyword"><span class="hljs-keyword">join</span></span>(<span class="hljs-string"><span class="hljs-string">','</span></span>)} <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> users`), args ); }</code> </pre> <br><p>  Manchmal reicht die Konvertierung in ein flaches Array von Feldern jedoch nicht aus (z. B. wenn die Datenquelle eine komplexe Struktur mit Verschachtelung zurückgibt).  In diesem Fall <code>fieldsMap</code> Funktion <code>fieldsMap</code> aus der Bibliothek <code>graphql-fields-list</code> , die den gesamten Baum der angeforderten Felder als Objekt zurückgibt: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { fieldsMap } = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">`graphql-fields-list`</span></span>); <span class="hljs-comment"><span class="hljs-comment">// ... some resolver implementation on `users`: resolve(arc, args, ctx, info) { const map = fieldsMap(info); /* RESULT: { edges: { node: { id: false, name: false, phone: false, } } } */ }</span></span></code> </pre> <br><p>  Wenn wir davon ausgehen, dass der Benutzer durch eine komplexe Struktur beschrieben wird, erhalten wir alles.  Diese Methode kann auch das optionale Pfadargument verwenden, mit dem Sie eine Karte nur des erforderlichen Zweigs aus dem gesamten Baum abrufen können, zum Beispiel: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { fieldsMap } = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">`graphql-fields-list`</span></span>); <span class="hljs-comment"><span class="hljs-comment">// ... some resolver implementation on `users`: resolve(arc, args, ctx, info) { const map = fieldsMap(info, 'edges.node'); /* RESULT: { id: false, name: false, phone: false, } */ }</span></span></code> </pre> <br><p>  Die Umwandlung von Namen auf Karten wird derzeit nicht unterstützt und bleibt dem Entwickler ausgeliefert. </p><br><h2 id="fragmentaciya-zaprosov">  Fragmentierung anfordern </h2><br><p>  GraphQL unterstützt die Fragmentierung von Abfragen. Wir können beispielsweise erwarten, dass der Verbraucher uns eine solche Anfrage sendet (hier verweisen wir auf das ursprüngliche Schema, das ein wenig weit hergeholt, aber syntaktisch korrekt ist): </p><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">query</span></span> UsersFragmentedQuery { <span class="hljs-section"><span class="hljs-section">users</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">id</span></span> ...NamesFramgment ...ContactsFragment } } fragment NamesFragment <span class="hljs-literal"><span class="hljs-literal">on</span></span> User { <span class="hljs-attribute"><span class="hljs-attribute">name</span></span> } fragment AddressFragment <span class="hljs-literal"><span class="hljs-literal">on</span></span> User { <span class="hljs-attribute"><span class="hljs-attribute">address</span></span> } fragment ContactsFragment <span class="hljs-literal"><span class="hljs-literal">on</span></span> User { <span class="hljs-attribute"><span class="hljs-attribute">phone</span></span> email ...AddressFragment }</code> </pre> <br><p>  In diesem Fall sollten Sie sich keine Sorgen machen, und <code>fieldsList(info)</code> und <code>fieldsMap(info)</code> in diesem Fall das erwartete Ergebnis zurück, da sie die Möglichkeit der Fragmentierung von Anforderungen berücksichtigen.  <code>fieldsList(info)</code> gibt also <code>['id', 'name', 'phone', 'email', 'address']</code> und <code>fieldsMap(info)</code> zurück: </p><br><pre> <code class="javascript hljs">{ <span class="hljs-attr"><span class="hljs-attr">id</span></span>: <span class="hljs-literal"><span class="hljs-literal">false</span></span>, <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-literal"><span class="hljs-literal">false</span></span>, <span class="hljs-attr"><span class="hljs-attr">phone</span></span>: <span class="hljs-literal"><span class="hljs-literal">false</span></span>, <span class="hljs-attr"><span class="hljs-attr">email</span></span>: <span class="hljs-literal"><span class="hljs-literal">false</span></span>, <span class="hljs-attr"><span class="hljs-attr">address</span></span>: <span class="hljs-literal"><span class="hljs-literal">false</span></span> }</code> </pre> <br><h2 id="ps">  PS </h2><br><p>  Ich hoffe, dieser Artikel hat dazu beigetragen, einige der Nuancen der Arbeit mit GraphQL auf dem Server zu beleuchten, und die Bibliothek <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">graphql-fields-list</a> kann Ihnen helfen, in Zukunft optimale Lösungen zu erstellen. </p><br><h2 id="upd-1">  UPD 1 </h2><br><p>  Version 1.1.0 der Bibliothek wurde veröffentlicht - Unterstützung für die <code>@skip</code> und <code>@include</code> in Anfragen wurde hinzugefügt.  Standardmäßig ist die Option aktiviert, falls erforderlich, deaktivieren Sie sie wie folgt: </p><br><pre> <code class="javascript hljs">fieldsList(info, { <span class="hljs-attr"><span class="hljs-attr">withDirectives</span></span>: <span class="hljs-literal"><span class="hljs-literal">false</span></span> }) fieldsMap(info, <span class="hljs-literal"><span class="hljs-literal">null</span></span>, <span class="hljs-literal"><span class="hljs-literal">false</span></span>);</code> </pre> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de427399/">https://habr.com/ru/post/de427399/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de427389/index.html">Operation Vk 2.0. Ein Gesetzentwurf zu Nachrichtenaggregatoren wurde eingeführt. Yandex.News wird geschlossen, wenn der Dienst den Eigentümer nicht ändert</a></li>
<li><a href="../de427391/index.html">Tipps für Junioren: Gute Gewohnheiten entwickeln</a></li>
<li><a href="../de427393/index.html">Enterprise Wireless-Sicherheitsanalyse</a></li>
<li><a href="../de427395/index.html">"Lassen Sie uns erklären: oder warum sollte ein Mathematiker Programmierer." Ein Buch darüber, wie man Mathe-Vorlesungen nicht verpasst</a></li>
<li><a href="../de427397/index.html">Entwicklung eines akustischen Datensatzes zum Training eines neuronalen Netzwerks</a></li>
<li><a href="../de427401/index.html">Dissolution Shaders und World Exploration</a></li>
<li><a href="../de427403/index.html">ReportingObserver API: Ein Blick auf den Code von Webseiten aus einer neuen Perspektive</a></li>
<li><a href="../de427405/index.html">ES2018 - verspricht endlich Methode</a></li>
<li><a href="../de427407/index.html">Meta-Clustering mit Fehlerminimierung und warum das Gehirn meiner Meinung nach so funktioniert</a></li>
<li><a href="../de427409/index.html">Das Buch "The Brilliant Agile. Flexibles Projektmanagement mit Agile, Scrum und Kanban »</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>