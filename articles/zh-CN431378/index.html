<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🚙 🎪 🧦 关于RTOS的全部真相。 第23条 队列：简介和基本服务 👋🏻 🧝🏻 👰🏼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="在上一篇文章（第5篇）中提到了队列。 与邮箱相比，它们提供了一种更灵活的方式来在任务之间传输简单消息。 

 该系列中的先前文章： 
 第22条 邮箱：辅助服务和数据结构 
 第21条。 邮箱：简介和基本服务 
 第20条 信号量：辅助服务和数据结构 
 第十九条 信号灯：简介和基本服务 
 第十八...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>关于RTOS的全部真相。 第23条 队列：简介和基本服务</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/431378/"><img src="https://habrastorage.org/webt/oy/fg/jv/oyfgjvk1xivp4zfhajjwfzycshs.jpeg"><br><br> 在上一篇文章（第5篇）中提到了队列。 与邮箱相比，它们提供了一种更灵活的方式来在任务之间传输简单消息。 <br><a name="habracut"></a><br> 该系列中的先前文章： <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第22条</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">邮箱：辅助服务和数据结构</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第21条。</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">邮箱：简介和基本服务</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第20条</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">信号量：辅助服务和数据结构</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第十九条</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">信号灯：简介和基本服务</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第十八条</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">事件标志组：助手服务和数据结构</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第十七条</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">事件标志组：简介和基本服务</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第十六条</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">讯号</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第十五条</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">内存分区：服务和数据结构</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第十四条</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">内存部分：简介和基本服务</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第十三条</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">任务数据结构和不受支持的API调用</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第十二条</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">任务处理服务</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第11条</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">任务：API的配置和介绍</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第10条</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">计划程序：高级功能和上下文保留</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第9条。</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">调度程序：实施</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第8条</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Nucleus SE：内部设计和部署</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第7条</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Nucleus SE：简介</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第6条。</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">其他RTOS服务</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第5条</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">任务交互和同步</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第4条</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">任务，上下文切换和中断</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第3条</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">任务与计划</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第2条。</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">RTOS：结构和实时模式</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><br></a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第1条</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">RTOS：简介。</a> <br><br><h2> 使用队列 </h2><br> 在Nucleus SE中，队列是在构建阶段定义的。 一个应用程序最多可以有16个队列。 如果应用程序中没有队列，则与队列相关的数据结构和服务代码都不会包含在应用程序中。 <br><br> 队列是内存中的一组区域，它们足以容纳一个<b>ADDR</b>类型的元素，并且可以安全地访问，以便多个任务可以使用它。 任务可以将数据写入队列，直到所有区域都已满为止。 任务可以从队列中读取数据，数据通常基于FIFO（先进先出）输入。 尝试将数据写入拥挤的队列或从空队列中读取数据会导致错误或任务暂停，具体取决于所选的API调用参数和Nucleus SE配置。 <br><br><h2> 队列和数据链接 </h2><br>  Nucleus SE支持数据通道，在上一篇文章（＃5）中也提到了这一点，下面将对它们进行详细讨论。 队列和通道之间的主要区别在于消息的大小。 队列包含由<b>ADDR</b>类型的单个变量（通常是指针）组成的消息。 该通道包含任意大小的消息，这些消息对于应用程序中的每个通道都是独立的，并在参数设置期间分配。 <br><br><h2> 队列设定 </h2><br><h3> 队列数 </h3><br> 与大多数Nucleus SE对象一样，队列配置主要由<b>nuse_config.h</b>文件中的<b>#define</b>指令控制。 主要参数是<b>NUSE_QUEUE_NUMBER</b> ，它确定在应用程序中配置的队列数。 缺省值为零（即应用程序中没有队列），并且可以接受的值最多为16。不正确的值将导致编译期间发生错误，该错误将在<b>nuse_config_check.h</b>文件的验证过程中生成（包含在<b>nuse_config.c</b>文件中并已编译） ），这将触发<b>#error</b>指令。 <br><br> 选择一个非零值充当队列的主要激活器。 定义数据结构时使用此参数，其大小取决于其值（在下一篇文章中将对此进行更多说明）。 此外，非零值会激活API设置。 <br><br><h3> 激活API调用 </h3><br>  Nucleus SE中的每个API函数（实用程序调用）在<b>nuse_config.h中</b>都有<b>#define</b> enable指令。 对于队列，这些指令是： <br><br><pre><code class="plaintext hljs">NUSE_QUEUE_SEND NUSE_QUEUE_RECEIVE NUSE_QUEUE_JAM NUSE_QUEUE_RESET NUSE_QUEUE_INFORMATION NUSE_QUEUE_COUNT</code> </pre> <br> 默认情况下，它们设置为<b>FALSE</b> ，从而禁用所有服务调用并阻止包含实现它们的代码。 要在应用程序中配置队列，您需要选择必要的API调用并将其设置为<b>TRUE</b> 。 <br><br> 以下是<b>nuse_config.h</b>文件中的代码片段： <br><br><pre> <code class="plaintext hljs">#define NUSE_QUEUE_NUMBER 0 /* Number of queues in the system - 0-16 */ /* Service call enablers */ #define NUSE_QUEUE_SEND FALSE #define NUSE_QUEUE_RECEIVE FALSE #define NUSE_QUEUE_JAM FALSE #define NUSE_QUEUE_RESET FALSE #define NUSE_QUEUE_INFORMATION FALSE #define NUSE_QUEUE_COUNT FALSE</code> </pre><br> 如果队列API的功能已激活，但应用程序中没有队列（ <b>NUSE_Queue_Count（）</b>始终启用），则将出现编译错误。 如果您的代码使用尚未激活的API调用，则将导致布局错误，因为实现代码未包含在应用程序中。 <br><br><h2> 呼叫排队 </h2><br>  Nucleus RTOS支持十个队列服务调用，这些调用提供以下功能： <br><br><ul><li> 排队留言。  Nucleus SE在<b>NUSE_Queue_Send（）</b>函数中实现。 </li><li> 接受来自队列的消息。  Nucleus SE实现了<b>NUSE_Queue_Receive（）</b>函数。 </li><li> 发布到队列的开头。 在Nucleus SE中，在<b>NUSE_Queue_Jam（）中实现</b> 。 </li><li> 通过释放所有挂起的任务（重置）将队列恢复到未使用状态。  Nucleus SE在<b>NUSE_Queue_Reset（）中实现</b> 。 </li><li> 提供有关特定队列的信息。  Nucleus SE在<b>NUSE_Queue_Information（）中实现</b> 。 </li><li> 返回当前在应用程序中配置的队列数。 在Nucleus SE中，在<b>NUSE_Queue_Count（）中实现</b> 。 </li><li> 将新队列添加到应用程序（创建队列）。 未实施Nucleus SE。 </li><li> 从应用程序中删除队列。 未实施Nucleus SE。 </li><li> 返回指向应用程序中所有队列的指针。 未实施Nucleus SE。 </li><li> 向队列中暂停的所有任务发送消息（广播）。 未实施Nucleus SE。 </li></ul><br> 这些开销调用中的每一个的实现将在下面详细描述。 <br><br><h2> 服务呼叫以从队列进行读写 </h2><br> 在队列上执行的基本操作是写入（有时称为排队消息）和读取（也称为接收消息）。 也可以写入队列的开头（阻塞）。  Nucleus RTOS和Nucleus SE为这些操作提供了三个基本的API调用，下面将对其进行讨论。 <br><br><h3> 排队 </h3><br>  Nucleus RTOS API实用程序用于写入队列的调用非常灵活，它允许您隐式暂停任务，或者如果操作无法立即完成（例如，尝试写入完整队列时），则暂停特定的超时。  Nucleus SE提供了相同的功能，但是任务暂停是可选的，并且未实现超时。 <br><br>  <b><i>Nucleus RTOS中的呼叫排队</i></b> <br><br> 服务电话原型： <br><br>  <b>状态NU_Send_To_Queue（NU_QUEUE *队列，VOID *消息，UNSIGNED大小，UNSIGNED挂起）;</b> <br><br> 参数： <br><br>  <b>queue-</b>指向用户提供的队列控制块的指针； <br>  <b>message-</b>指向要发送的消息的指针； <br>  <b>size-</b>消息中<b>UNSIGNED</b>数据元素的数量。 如果队列支持可变长度的消息，则此参数必须等于消息的大小或小于队列支持的消息的大小。 如果队列支持固定大小的消息，则此参数必须与队列支持的消息大小完全匹配； <br>  <b>挂起</b> -任务<b>挂起</b>的规范，可以采用值<b>NU_NO_SUSPEND</b>或<b>NU_SUSPEND</b>或超时值。 <br><br> 返回值： <br><br>  <b>NU_SUCCESS-</b>调用成功完成； <br>  <b>NU_INVALID_QUEUE-</b>无效的队列指针； <br>  <b>NU_INVALID_POINTER-</b>消息的空指针（ <b>NULL</b> ）； <br>  <b>NU_INVALID_SIZE-</b>消息大小与队列支持的消息大小不兼容； <br>  <b>NU_INVALID_SUSPEND-</b>暂停是从与任务无关的线程执行的； <br>  <b>NU_QUEUE_FULL-</b>队列已满，未指定挂起； <br>  <b>NU_TIMEOUT-</b>即使在指定的超时时间内任务被挂起，队列也已满； <br>  <b>NU_QUEUE_DELETED-</b>任务挂起时删除队列； <br>  <b>NU_QUEUE_RESET-</b>任务挂起时重置了队列。 <br><br>  <b><i>在Nucleus SE中排队消息</i></b> <br> 该API服务调用支持Nucleus RTOS API的核心功能。 <br><br> 服务电话原型： <br><br>  <b>状态NUSE_Queue_Send（NUSE_QUEUE队列，ADDR *消息，U8挂起）;</b> <br><br> 参数： <br><br>  <b>队列</b> - <b>队列</b>索引（ID）; <br>  <b>message-</b>指向要发送的消息的指针，是<b>ADDR</b>类型的一个变量； <br>  <b>暂停</b> -暂停任务的规范；它可以采用值<b>NUSE_NO_SUSPEND或NUSE_SUSPEND</b> 。 <br><br> 返回值： <br><br>  <b>NUSE_SUCCESS-</b>呼叫已成功完成； <br>  <b>NUSE_INVALID_QUEUE-</b>无效的队列索引； <br>  <b>NUSE_INVALID_POINTER-</b>消息的空指针（ <b>NULL</b> ）; <br>  <b>NUSE_INVALID_SUSPEND-</b>尝试从与任务无关的线程中暂停任务，或者在禁用API服务调用以阻止任务时暂停该任务； <br>  <b>NUSE_QUEUE_FULL-</b>队列已满，未指定挂起； <br>  <b>NUSE_QUEUE_WAS_RESET-</b>挂起任务时重置了队列。 <br><br>  <b><i>在Nucleus SE中实现排队</i></b> <br> 根据是否激活对任务锁定的支持，使用条件编译选择API函数代码变体<b>NUSE_Queue_Send（）</b> （在检查参数之后）。 我们将考虑这两种选择。 <br><br> 如果未激活任务锁定，则此服务调用的代码非常简单： <br><br><pre> <code class="plaintext hljs">if (NUSE_Queue_Items[queue] == NUSE_Queue_Size[queue]) /* queue full */ { return_value = NUSE_QUEUE_FULL; } else /* queue element available */ { NUSE_Queue_Data[queue][NUSE_Queue_Head[queue]++] = *message; if (NUSE_Queue_Head[queue] == NUSE_Queue_Size[queue]) { NUSE_Queue_Head[queue] = 0; } NUSE_Queue_Items[queue]++; return_value = NUSE_SUCCESS; }</code> </pre><br> 该函数只是检查队列中是否有可用空间，并使用<b>NUSE_Queue_Head []</b>索引将消息存储在队列的数据区域中。 <br><br> 如果激活了任务锁定，则代码将变得更加复杂： <br><br><pre> <code class="plaintext hljs">do { if (NUSE_Queue_Items[queue] == NUSE_Queue_Size[queue]) /* queue full */ { if (suspend == NUSE_NO_SUSPEND) { return_value = NUSE_QUEUE_FULL; } else { /* block task */ NUSE_Queue_Blocking_Count[queue]++; NUSE_Suspend_Task(NUSE_Task_Active, (queue &lt;&lt; 4) | NUSE_QUEUE_SUSPEND); return_value = NUSE_Task_Blocking_Return[NUSE_Task_Active]; if (return_value != NUSE_SUCCESS) { suspend = NUSE_NO_SUSPEND; } } } else { /* queue element available */ NUSE_Queue_Data[queue][NUSE_Queue_Head[queue]++] = *message; if (NUSE_Queue_Head[queue] == NUSE_Queue_Size[queue]) { NUSE_Queue_Head[queue] = 0; } NUSE_Queue_Items[queue]++; if (NUSE_Queue_Blocking_Count[queue] != 0) { U8 index; /* check whether a task is blocked on this queue */ NUSE_Queue_Blocking_Count[queue]--; for (index=0; index&lt;NUSE_TASK_NUMBER; index++) { if ((LONIB(NUSE_Task_Status[index]) == NUSE_QUEUE_SUSPEND) &amp;&amp; (HINIB(NUSE_Task_Status[index]) == queue)) { NUSE_Task_Blocking_Return[index] = NUSE_SUCCESS; NUSE_Wake_Task(index); break; } } } return_value = NUSE_SUCCESS; suspend = NUSE_NO_SUSPEND; } } while (suspend == NUSE_SUSPEND);</code> </pre><br> 一些澄清可能会有所帮助。 <br><br> 该代码包含在<b>do ... while循环中</b> ，该<b>循环</b>在任务暂停参数为<b>NUSE_SUSPEND时运行</b> 。 <br><br> 如果队列已满，并且<b>挂起</b>是<b>NUSE_NO_SUSPEND</b> ，则API调用以<b>NUSE_QUEUE_FULL结尾</b> 。 如果suspend参数为<b>NUSE_SUSPEND</b> ，任务将暂停。 完成后（即，任务恢复时），如果返回值为<b>NUSE_SUCCESS</b> ，即由于读取了消息（而不是因为队列已重置）而恢复了任务，则代码将返回循环的开头。 <br> 如果队列未满，则使用<b>NUSE_Queue_Head []</b>索引将提供的消息存储在队列的数据区域中。 它检查队列中是否有挂起的任务（等待消息）。 如果存在此类任务，则将恢复第一个任务。 暂<b>挂</b>变量设置为<b>NUSE_NO_SUSPEND</b> ，并且API调用以值<b>NUSE_SUCCESS</b>完成。 <br><br><h3> 从队列中读取 </h3><br> 从队列读取的Nucleus RTOS API实用程序调用非常灵活，它允许您隐式暂停任务，或者如果无法立即完成操作（例如，尝试从空队列中读取），则暂停特定的超时。  Nucleus SE提供了相同的功能，但是任务暂停是可选的，并且未实现超时。 <br><br>  <b><i>调用以从Nucleus RTOS中的队列接收消息</i></b> <br> 服务电话原型： <br><br>  <b>状态NU_Receive_From_Queue（NU_QUEUE *队列，VOID *消息，UNSIGNED大小，UNSIGNED * Actual_size，UNSIGNED挂起）;</b> <br><br> 参数： <br><br>  <b>queue-</b>指向用户提供的队列控制块的指针； <br>  <b>message-</b>指向存储已接收消息的指针； <br>  <b>size-</b>消息中<b>UNSIGNED</b>数据元素的数量。 此数字应与创建队列时定义的消息大小相匹配； <br>  <b>挂起</b> -任务<b>挂起</b>的规范，可以采用值<b>NU_NO_SUSPEND</b>或<b>NU_SUSPEND</b>或超时值。 <br><br> 返回值： <br><br>  <b>NU_SUCCESS-</b>调用成功完成； <br>  <b>NU_INVALID_QUEUE-</b>无效的队列指针； <br>  <b>NU_INVALID_POINTER-</b>消息的空指针（ <b>NULL</b> ）； <br>  <b>NU_INVALID_SUSPEND-</b>尝试从与任务无关的线程中暂停任务； <br>  <b>NU_QUEUE_EMPTY-</b>队列为空，未指定挂起； <br>  <b>NU_TIMEOUT-</b>指示队列仍然为空，即使在任务被暂停指定的时间后也是如此； <br>  <b>NU_QUEUE_DELETED-</b>任务挂起时删除队列； <br>  <b>NU_QUEUE_RESET-</b>任务挂起时重置了队列。 <br><br>  <b><i>呼叫以接收来自Nucleus SE队列的消息</i></b> <br> 该API调用支持Nucleus RTOS API的核心功能。 <br><br> 服务电话原型： <br><br>  <b>状态NUSE_Queue_Receive（NUSE_QUEUE队列，ADDR *消息，U8挂起）;</b> <br><br> 参数： <br><br>  <b>队列</b> - <b>队列</b>索引（ID）; <br>  <b>message-</b>指向接收到的消息的存储库的指针；它是<b>ADDR</b>类型的一个变量； <br>  <b>挂起</b> -任务<b>挂起的</b>规范，可以采用值<b>NUSE_NO_SUSPEND</b>或<b>NUSE_SUSPEND</b> 。 <br><br> 返回值： <br><br>  <b>NUSE_SUCCESS-</b>呼叫已成功完成； <br>  <b>NUSE_INVALID_QUEUE-</b>无效的队列索引； <br>  <b>NUSE_INVALID_POINTER-</b>消息的空指针（ <b>NULL</b> ）; <br>  <b>NUSE_INVALID_SUSPEND-</b>尝试从与任务无关或禁用任务阻止支持的线程中挂起任务； <br>  <b>NUSE_QUEUE_EMPTY-</b>队列为空，未指定挂起； <br>  <b>NUSE_QUEUE_WAS_RESET-</b>挂起任务时重置了队列。 <br><br>  <b><i>在Nucleus SE中从队列接收消息的实现</i></b> <br> 使用条件编译选择API函数代码变体<b>NUSE_Queue_Receive（）</b> （在检查参数之后），具体取决于是否激活了对任务锁定的支持。 考虑这两种选择。 <br><br> 如果激活了锁支持，则此API调用的代码非常简单： <br><br><pre> <code class="plaintext hljs">if (NUSE_Queue_Items[queue] == 0) /* queue empty */ { return_value = NUSE_QUEUE_EMPTY; } else { /* message available */ *message = NUSE_Queue_Data[queue][NUSE_Queue_Tail[queue]++]; if (NUSE_Queue_Tail[queue] == NUSE_Queue_Size[queue]) { NUSE_Queue_Tail[queue] = 0; } NUSE_Queue_Items[queue]--; return_value = NUSE_SUCCESS; }</code> </pre><br> 该函数只是检查队列中是否有消息，并使用<b>NUSE_Queue_Tail []</b>索引从队列中检索消息，并使用指向该消息的指针返回数据。 <br><br> 如果激活了任务锁定，则代码将变得更加复杂： <br><br><pre> <code class="plaintext hljs">do { if (NUSE_Queue_Items[queue] == 0) /* queue empty */ { if (suspend == NUSE_NO_SUSPEND) { return_value = NUSE_QUEUE_EMPTY; } else { /* block task */ NUSE_Queue_Blocking_Count[queue]++; NUSE_Suspend_Task(NUSE_Task_Active, (queue &lt;&lt; 4) | NUSE_QUEUE_SUSPEND); return_value = NUSE_Task_Blocking_Return[NUSE_Task_Active]; if (return_value != NUSE_SUCCESS) { suspend = NUSE_NO_SUSPEND; } } } else { /* message available */ *message = NUSE_Queue_Data[queue][NUSE_Queue_Tail[queue]++]; if (NUSE_Queue_Tail[queue] == NUSE_Queue_Size[queue]) { NUSE_Queue_Tail[queue] = 0; } NUSE_Queue_Items[queue]--; if (NUSE_Queue_Blocking_Count[queue] != 0) { U8 index; /* check whether a task is blocked */ /* on this queue */ NUSE_Queue_Blocking_Count[queue]--; for (index=0; index&lt;NUSE_TASK_NUMBER; index++) { if ((LONIB(NUSE_Task_Status[index]) == NUSE_QUEUE_SUSPEND) &amp;&amp; (HINIB(NUSE_Task_Status[index]) == queue)) { NUSE_Task_Blocking_Return[index] = NUSE_SUCCESS; NUSE_Wake_Task(index); break; } } } return_value = NUSE_SUCCESS; suspend = NUSE_NO_SUSPEND; } } while (suspend == NUSE_SUSPEND);</code> </pre><br> 一些澄清将是有帮助的。 <br><br> 该代码包含在<b>do ... while循环中</b> ，该<b>循环</b>在任务暂停参数为<b>NUSE_SUSPEND时运行</b> 。 <br><br> 如果队列为空，并且挂起为<b>NUSE_NO_SUSPEND</b> ，则API调用以<b>NUSE_QUEUE_EMPTY结尾</b> 。 如果<b>suspend</b>参数为<b>NUSE_SUSPEND</b> ，任务将暂停。 完成后（即，任务恢复时），如果返回值为<b>NUSE_SUCCESS</b> ，即，由于已发送消息（而不是因为队列已重置）而恢复了任务，则代码将返回循环的开头。 <br><br> 如果队列中包含消息，则使用<b>NUSE_Queue_Tail []</b>索引返回存储的消息。 它检查此队列中是否有任何暂停（挂起）的任务。 如果存在此类任务，则将恢复第一个任务。 将suspend变量设置为<b>NUSE_NO_SUSPEND</b> ，并且该API调用以<b>NUSE_SUCCESS</b>代码终止。 <br><br><h3> 写到行首 </h3><br>  Nucleus RTOS API实用程序调用非常灵活，可以将消息写入队列头，并且允许您隐式暂停任务，或者如果操作无法立即完成（例如，尝试写入拥挤的队列），则暂停特定的超时。  Nucleus SE提供了相同的功能，但任务暂停是可选的，并且未实现超时。 <br><br>  <b><i>调用以将消息写入Nucleus RTOS队列的头部</i></b> <br> 服务电话原型： <br><br>  <b>状态NU_Send_To_Front_Of_Queue（NU_QUEUE *队列，VOID *消息，UNSIGNED大小，UNSIGNED挂起）;</b> <br><br> 参数： <br><br>  <b>queue-</b>指向用户提供的队列控制块的指针； <br>  <b>message-</b>指向要发送的消息的指针； <br>  <b>size-</b>消息中<b>UNSIGNED</b>数据元素的数量。 如果队列支持可变长度消息，则此参数必须等于消息大小或小于队列支持的消息大小。 如果队列支持固定长度的消息，则此参数必须与队列支持的消息的大小完全匹配； <br>  <b>挂起</b> -任务<b>挂起</b>的规范，可以采用值<b>NU_NO_SUSPEND</b>或<b>NU_SUSPEND</b>或超时值。 <br><br> 返回值： <br><br>  <b>NU_SUCCESS-</b>调用成功完成； <br>  <b>NU_INVALID_QUEUE-</b>无效的队列指针； <br>  <b>NU_INVALID_POINTER-</b>消息的空指针（ <b>NULL</b> ）； <br>  <b>NU_INVALID_SIZE-</b>消息大小与队列支持的消息大小不兼容； <br>  <b>NU_INVALID_SUSPEND-</b>尝试从非任务流暂停 <br>  <b>NU_QUEUE_FULL-</b>队列已满，未指定挂起； <br>  <b>NU_TIMEOUT-</b>队列已满，即使在任务暂停了一定超时后也是如此； <br>  <b>NU_QUEUE_DELETED-</b>任务挂起时删除队列； <br>  <b>NU_QUEUE_RESET-</b>任务挂起时重置了队列。 <br><br>  <b><i>在Nucleus SE中将消息写入消息队列的调用</i></b> <br> 该API调用支持Nucleus RTOS API的核心功能。 <br><br> 服务电话原型： <br><br>  <b>状态NUSE_Queue_Jam（NUSE_QUEUE队列，ADDR *消息，U8挂起）;</b> <br><br> 参数： <br><br>  <b>队列</b> - <b>队列</b>索引（ID）; <br>  <b>message-</b>指向<b>消息</b>的指针，是<b>ADDR</b>类型的一个变量； <br>  <b>挂起</b> -任务<b>挂起的</b>规范，可以采用值<b>NUSE_NO_SUSPEND</b>或<b>NUSE_SUSPEND</b> 。 <br><br> 返回值： <br><br>  <b>NUSE_SUCCESS-</b>呼叫已成功完成； <br>  <b>NUSE_INVALID_QUEUE-</b>无效的队列索引； <br>  <b>NUSE_INVALID_POINTER-</b>消息的空指针（ <b>NULL</b> ）; <br>  <b>NUSE_INVALID_SUSPEND-</b>尝试从与任务无关或禁用任务阻止支持的线程中挂起任务； <br>  <b>NUSE_QUEUE_FULL-</b>队列已满，未指定挂起； <br>  <b>NUSE_QUEUE_WAS_RESET-</b>挂起任务时重置了队列。 <br><br>  <b><i>在Nucleus SE中实现队列最高记录</i></b> <br>  API函数代码变体<b>NUSE_Queue_Jam（）</b>与<b>NUSE_Queue_Send（）</b>非常相似，仅使用<b>NUSE_Queue_Tail []</b>索引存储数据，因此： <br><br><pre> <code class="plaintext hljs">if (NUSE_Queue_Items[queue] == NUSE_Queue_Size[queue]) /* queue full */ { return_value = NUSE_QUEUE_FULL; } else /* queue element available */ { if (NUSE_Queue_Tail[queue] == 0) { NUSE_Queue_Tail[queue] = NUSE_Queue_Size[queue] - 1; } else { NUSE_Queue_Tail[queue]--; } NUSE_Queue_Data[queue][NUSE_Queue_Tail[queue]] = *message; NUSE_Queue_Items[queue]++; return_value = NUSE_SUCCESS; }</code> </pre><br> 下一篇文章将研究与队列关联的其他API调用以及数据结构。 <br><br>  <b>关于作者：</b> Colin Walls在电子行业工作了30多年，大部分时间用于固件。 他现在是Mentor Embedded（Mentor Graphics的一个部门）的固件工程师。  Colin Walls经常在会议和研讨会上发表演讲，他撰写了许多技术文章并撰写了两本有关固件的书。 居住在英国。  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Colin的</a>专业<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">博客</a> ，电子邮件：colin_walls@mentor.com。 </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN431378/">https://habr.com/ru/post/zh-CN431378/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN431362/index.html">设计师如何摆脱日常工作并保持对工作的兴趣？</a></li>
<li><a href="../zh-CN431370/index.html">西部荒野中最快的报道。 还有一些错误...</a></li>
<li><a href="../zh-CN431372/index.html">来自x86系统中的外部设备的中断。 第2部分。Linux内核引导选项</a></li>
<li><a href="../zh-CN431374/index.html">最后判断：分析早期使用中游戏的财务指标</a></li>
<li><a href="../zh-CN431376/index.html">血腥企业中的数据迁移：要分析什么，以免使项目不堪重负</a></li>
<li><a href="../zh-CN431380/index.html">Mitap Netologiya和Skyeng谈软技能“开发人员除了代码需要知道的东西”</a></li>
<li><a href="../zh-CN431382/index.html">JVM生态系统调查结果</a></li>
<li><a href="../zh-CN431384/index.html">CLion 2018.3：远程开发，代码分析，性能等</a></li>
<li><a href="../zh-CN431388/index.html">通过汽车的眼睛看世界。 无人机如何看到他？</a></li>
<li><a href="../zh-CN431390/index.html">2019年数字趋势及其对改变消费者行为的影响</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>