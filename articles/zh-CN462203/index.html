<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🌀 🧙🏾 👏🏿 使用bash的一次性虚拟机的KVM（低于）VDI 🕉️ 🍷 👍🏾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="本文适用于谁？ 
 面对创建“一次性”工作服务这一任务的系统管理员，本文可能会感兴趣。 

 序言 
 一个年轻的，动态发展的公司（具有小型区域网络）的IT支持部门被要求组织“自助服务站”，以供其外部客户使用。 该站数据应该用于在公司的外部门户网站上注册，从外部设备下载数据以及与政府门户网站一起使用...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>使用bash的一次性虚拟机的KVM（低于）VDI</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/462203/"><h4> 本文适用于谁？ </h4><br> 面对创建“一次性”工作服务这一任务的系统管理员，本文可能会感兴趣。 <br><br><h4> 序言 </h4><br> 一个年轻的，动态发展的公司（具有小型区域网络）的IT支持部门被要求组织“自助服务站”，以供其外部客户使用。 该站数据应该用于在公司的外部门户网站上注册，从外部设备下载数据以及与政府门户网站一起使用。 <br><br> 一个重要的方面是，大多数软件在MS Windows下（例如，“声明”）已“锐化”，尽管朝着开放格式迈进，MS Office仍然是交换电子文档的主要标准。 因此，解决此问题时我们不能拒绝MS Windows。 <br><a name="habracut"></a><br> 主要问题是有可能从用户会话中收集各种数据，这可能导致它们泄露给第三方。  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">这种情况已经让MFC崩溃了</a> 。 但是与准司法（国家自治机构）MFC不同，非国家组织将因此类缺陷而受到更多的惩罚。 下一个关键问题是需要使用外部存储介质，在这些存储介质上肯定会存在大量恶意软件。 由于通过白名单访问互联网受到限制，因此认为从Internet进入恶意软件的可能性较小，其他部门的员工共同制定了要求，提出要求和希望，最终要求如下： <br><br>  <b>IS要求</b> <br><br><ul><li> 使用后，应删除所有用户数据（包括临时文件和注册表项）。 </li><li> 用户启动的所有过程都应在工作结束时完成。 </li><li> 通过白名单访问Internet。 </li><li> 对运行第三方代码的能力的限制。 </li><li> 如果会话闲置超过5分钟，则会话应自动结束，工作站应执行清理操作。 </li></ul><br>  <b>客户要求</b> <br><br><ul><li> 每个分支的客户站数量不超过4。 </li><li> 从我“坐在椅子上”到开始使用客户端软件的那一刻，系统就绪所需的最短等待时间。 </li><li> 可以直接从“自助服务站”的安装站点连接外围设备（扫描仪，闪存驱动器）。 </li><li> 客户的愿望 </li><li> 大楼关闭时的广告资料（图片）演示。 </li></ul><cut></cut><br><h4> 创意面粉 </h4><br> 在Windows livecd上玩了足够的游戏后，我们得出了一个一致的结论，即最终的解决方案至少不能满足3个关键点。 它们要么加载时间很长，要么加载时间不长，或者它们的自定义伴随着狂野的痛苦。 也许我们搜索不力，您可以建议一些工具，我将不胜感激。 <br><br> 此外，我们开始着眼于VDI，但是对于此任务，大多数解决方案要么太昂贵，要么需要密切关注。 我想要一个简单的工具，只需很少的魔力，只需重新启动/重新启动服务即可解决大多数问题。 幸运的是，我们从退役服务中获得了分支机构中低端级别的服务器设备，可以将其用作技术基础。 <br><br> 结果如何？ 但是我无法告诉您最终发生了什么事情，因为NDA，但是在搜索过程中，我们开发了一个有趣的方案，尽管没有进行批量试验，但它在实验室测试中表现得很好。 <br><br> 几项免责声明：作者并没有声称所提出的解决方案完全解决了所有任务，并且自愿并随歌曲一起执行。 作者事先同意“英语（Sein English）sprache是​​zehr schlecht”的说法。 由于该解决方案不再开发，您无法指望错误修复或功能更改，一切都在您的手中。 作者假设您至少对KVM有点熟悉，并阅读了有关Spice协议的评论文章，并且您对Centos或其他GNU Linux发行版进行了一些工作。 <br><br> 在本文中，我想分析最终解决方案的主干，即客户端和服务器之间的交互以及所讨论解决方案框架内虚拟机生命周期中流程的本质。 如果这篇文章对公众感兴趣，我将描述为基于Fedora创建瘦客户机而实现实时映像的细节，并介绍调整虚拟机和KVM服务器以优化性能和安全性的细节。 <br><br> 如果您带彩色纸， <br> 油漆，刷子和胶水， <br> 还有更多的灵活性... <br> 你可以赚一百卢布！ <br><br><h4> 测试台的方案和说明 </h4><br><img src="https://habrastorage.org/webt/pu/tu/rk/puturkaiwqcpbp4wld7ezdk_lcw.png"><br><br> 所有设备都位于分支网络内部，只有Internet通道断开。 从历史上看，已经有一个代理服务器，这不是什么特别的事情。 但是，除其他外，来自虚拟机的流量将被过滤掉（本文后面简称为VM）。 没有什么可以阻止将此服务放置在KVM服务器上的，您唯一需要注意的是磁盘子系统上来自该服务的负载如何变化。 <br><br> 客户站-实际上是我们服务的“自助服务站”，“前端”。 是Lenovo IdeaCentre的上网本。 这个单元有什么用？ 是的，几乎每个人都对前面板上的大量USB连接器和读卡器感到特别满意。 在我们的方案中，将具有硬件写保护的SD卡插入读卡器中，上面记录了Fedora 28的修改后的实时图像，当然，监视器，键盘和鼠标也连接到了上网本上。 <br><br> 开关-第二层的不起眼的硬件开关，它在服务器机房中，并且闪烁并带有指示灯。 除“自助服务站”的网络外，它未连接到任何网络。 <br><br>  KVM_Server是电路的核心，在台式测试中，具有8 GB RAM的Core 2 Quad Q9650可以自信地将3个Windows 10虚拟机拉上。 磁盘子系统-Adaptec 3405 2驱动器RAID 1 + SSD。 在至强1220的现场试验中，更严重的LSI 9260 + SSD轻松拉出5-6个VM。 我们将从退役的服务中获取服务器，因此不会有很多资本成本。 具有pool_Vm虚拟机池的KVM虚拟化系统已部署在该服务器上。 <br><br>  Vm是虚拟机，是我们服务的后端。 这是用户的工作。 <br><br>  Enp5s0是一个网络接口，它面向“自助服务站”，dhcpd，ntpd，httpd生活在其上的网络，并且xinetd侦听“信号”端口。 <br><br>  Lo0是回送伪接口。 标准。 <br><br>  Spice_console-一个非常有趣的事情，事实是，与传统的RDP不同，当您打开KVM + Spice协议捆绑包时，会出现一个附加实体-虚拟机控制台端口。 实际上，连接到此TCP端口后，我们得到了Vm控制台，而无需通过其网络接口连接到Vm。 与Vm的所有交互用于信号传输，服务器接管。 功能上最接近的模拟是IPKVM。 即  VM监视器的映像已传输到此端口，鼠标移动的数据也已传输到该端口，并且（最重要的是）通过Spice协议进行的交互使您可以将USB设备无缝重定向到虚拟机，就好像该设备已连接到Vm本身一样。 已测试闪存驱动器，扫描仪，网络摄像头。 <br><br>  Vnet0，virbr0和虚拟网卡Vm形成虚拟机网络。 <br><br><h4> 如何运作 </h4><br> 从客户站 <br><br> 从Fedora 28的修改后的实时映像以图形方式加载客户站，并通过dhcp从网络地址空间169.254.24.0/24接收IP地址。 在引导过程中，将创建防火墙规则，以允许连接“信号”和“香料”服务器端口。 下载完成后，工作站将等待客户端用户的授权。 用户授权后，将启动“ openbox”桌面管理器，并代表授权用户执行自动启动自动启动脚本。 除其他外，自动运行脚本运行remote.sh脚本。 <br><br><div class="spoiler">  <b class="spoiler_title">$ HOME / .config / openbox /脚本/ remote.sh</b> <div class="spoiler_text"><pre><code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#!/bin/sh server_ip=$(/usr/bin/cat /etc/client.conf |/usr/bin/grep "server_ip" \ |/usr/bin/cut -d "=" -f2) vdi_signal_port=$(/usr/bin/cat /etc/client.conf |/usr/bin/grep "vdi_signal_port" \ |/usr/bin/cut -d "=" -f2) vdi_spice_port=$(/usr/bin/cat /etc/client.conf |/usr/bin/grep "vdi_spice_port" \ |/usr/bin/cut -d "=" -f2) animation_folder=$(/usr/bin/cat /etc/client.conf |/usr/bin/grep "animation_folder" \ |/usr/bin/cut -d "=" -f2) process=/usr/bin/remote-viewer while true do if [ -z `/usr/bin/pidof feh` ] then /usr/bin/echo $animation_folder /usr/bin/feh -N -x -D1 $animation_folder &amp; else /usr/bin/echo fi /usr/bin/nc -i 1 $server_ip $vdi_signal_port |while read line do if /usr/bin/echo "$line" |/usr/bin/grep "RULE ADDED, CONNECT NOW!" then /usr/bin/killall feh pid_process=$($process "spice://$server_ip:$vdi_spice_port" \ "--spice-disable-audio" "--spice-disable-effects=animation" \ "--spice-preferred-compression=auto-glz" "-k" \ "--kiosk-quit=on-disconnect" | /bin/echo $!) /usr/bin/wait $pid_process /usr/bin/killall -u $USER exit else /usr/bin/echo $line &gt;&gt; /var/log/remote.log fi done done</span></span></code> </pre> <br></div></div><br><div class="spoiler">  <b class="spoiler_title">/etc/client.conf</b> <div class="spoiler_text"><pre> <code class="bash hljs">server_ip=169.254.24.1 vdi_signal_port=5905 vdi_spice_port=5906 animation_folder=/usr/share/backgrounds/animation background_folder=/usr/share/backgrounds2/fedora-workstation</code> </pre><br></div></div><br>  client.conf文件的变量说明 <br>  server_ip-地址KVM_Server <br>  vdi_signal_port-xinetd“坐在”的端口KVM_Server <br>  vdi_spice_port-网络端口KVM_Server，连接请求将从网络端口KVM_Server重定向到远程查看器客户端到所选Vm的spice端口（详细信息如下） <br>  animation_folder-用于演示废话动画的图像的文件夹 <br>  background_folder-备用演示文稿从中获取图像的文件夹。 本文下半部分将详细介绍动画。 <br><br>  remote.sh脚本从配置文件/etc/client.conf中获取设置，并使用nc连接到KVM服务器的“ vdi_signal_port”端口，并从服务器接收数据流，其中需要字符串“ RULE ADDED，CONNECT NOW”。 接收到所需的线路后，远程查看器进程将以信息亭模式启动，并建立与“ vdi_spice_port”服务器端口的连接。 脚本的执行被挂起，直到远程查看器执行结束。 <br><br> 由于服务器端的重定向，连接到“ vdi_spice_port”端口的远程查看器到达lo0接口的“ spice_console”端口，即 到虚拟机的控制台，用户的工作就直接进行了。 在等待连接时，以jpeg文件的幻灯片形式向用户显示废话动画，带有图片的目录的路径由配置文件中的animation_folder变量的值确定。 <br><br> 如果与虚拟机的“ spice_console”端口的连接丢失，这表明虚拟机已关闭/重新启动（即，用户会话的实际结束），则代表授权用户运行的所有进程都将终止，这将导致lightdm重新启动并返回到授权屏幕。 <br><br><h4> 从KVM服务器的侧面 </h4><br> 在网卡的“信号”端口上，enp5s0正在等待xinetd连接。 连接到“信号”端口后，xinetd会在不传递任何输入参数的情况下运行vm_manager.sh脚本，并将脚本结果重定向到Client Station的nc会话。 <br><br><div class="spoiler">  <b class="spoiler_title">/etc/xinetd.d/test-server</b> <div class="spoiler_text"><pre> <code class="bash hljs">service vdi_signal { port = 5905 socket_type = stream protocol = tcp <span class="hljs-built_in"><span class="hljs-built_in">wait</span></span> = no user = root server = /home/admin/scripts_vdi_new/vm_manager.sh }</code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">/home/admin/scripts_vdi_new/vm_manager.sh</b> <div class="spoiler_text"><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#!/usr/bin/sh #&lt;SET LOCAL VARIABLES FOR SCRIPT&gt;# SRV_SCRIPTS_DIR=$(/usr/bin/cat /etc/vm_manager.conf \ |/usr/bin/grep "srv_scripts_dir" |/usr/bin/cut -d "=" -f2) /usr/bin/echo "SRV_SCRIPTS_DIR=$SRV_SCRIPTS_DIR" export SRV_SCRIPTS_DIR=$SRV_SCRIPTS_DIR SRV_POOL_SIZE=$(/usr/bin/cat /etc/vm_manager.conf \ |/usr/bin/grep "srv_pool_size" |/usr/bin/cut -d "=" -f2) /usr/bin/echo "SRV_POOL_SIZE=$SRV_POOL_SIZE" export "SRV_POOL_SIZE=$SRV_POOL_SIZE" SRV_START_PORT_POOL=$(/usr/bin/cat /etc/vm_manager.conf \ |/usr/bin/grep "srv_start_port_pool" |/usr/bin/cut -d "=" -f2) /usr/bin/echo SRV_START_PORT_POOL=$SRV_START_PORT_POOL export SRV_START_PORT_POOL=$SRV_START_PORT_POOL SRV_TMP_DIR=$(/usr/bin/cat /etc/vm_manager.conf \ |/usr/bin/grep "srv_tmp_dir" |/usr/bin/cut -d "=" -f2) /usr/bin/echo "SRV_TMP_DIR=$SRV_TMP_DIR" export SRV_TMP_DIR=$SRV_TMP_DIR date=$(/usr/bin/date) #&lt;/SET LOCAL VARIABLES FOR SCRIPT&gt;# /usr/bin/echo "# $date START EXECUTE VM_MANAGER.SH #" make_connect_to_vm() { #&lt;READING CLEAR.LIST AND CHECK PORT FOR NETWORK STATE&gt;# /usr/bin/echo "READING CLEAN.LIST AND CHECK PORT STATE" #&lt;CHECK FOR NO ONE PORT IN CLEAR.LIST&gt;# if [ -z `/usr/bin/cat $SRV_TMP_DIR/clear.list` ] then /usr/bin/echo "NO AVALIBLE PORTS IN CLEAN.LIST FOUND" /usr/bin/echo "Will try to make housekeeper, and create new vm" make_housekeeper else #&lt;MINIMUN ONE PORT IN CLEAR.LIST FOUND&gt;# /usr/bin/cat $SRV_TMP_DIR/clear.list |while read line do clear_vm_port=$(($line)) /bin/echo "FOUND PORT $clear_vm_port IN CLEAN.LIST. TRY NETSTAT" \ "CHECK FOR PORT=$clear_vm_port" #&lt;NETSTAT LISTEN CHECK FOR PORT FROM CLEAN.LIST&gt;# if /usr/bin/netstat -lnt |/usr/bin/grep ":$clear_vm_port" &gt; /dev/null then /bin/echo "$clear_vm_port IS LISTEN" #&lt;PORT IS LISTEN. CHECK FOR IS CONNECTED NOW&gt;# if /usr/bin/netstat -nt |/usr/bin/grep ":$clear_vm_port" \ |/usr/bin/grep "ESTABLISHED" &gt; /dev/null then #&lt;PORT LISTEN AND ALREADY CONNECTED! MOVE PORT FROM CLEAR.LIST # TO WASTE.LIST&gt;# /bin/echo "$clear_vm_port IS ALREADY CONNECTED, MOVE PORT TO WASTE.LIST" /usr/bin/sed -i "/$clear_vm_port/d" $SRV_TMP_DIR/clear.list /usr/bin/echo $clear_vm_port &gt;&gt; $SRV_TMP_DIR/waste.list else #&lt;PORT LISTEN AND NO ONE CONNECT NOW. MOVE PORT FROM CLEAR.LIST TO # CONN_WAIT.LIST AND CREATE IPTABLES RULES&gt;## /usr/bin/echo "OK, $clear_vm_port IS NOT ALREADY CONNECTED" /usr/bin/sed -i "/$clear_vm_port/d" $SRV_TMP_DIR/clear.list /usr/bin/echo $clear_vm_port &gt;&gt; $SRV_TMP_DIR/conn_wait.list $SRV_SCRIPTS_DIR/vm_connect.sh $clear_vm_port #&lt;TRY TO CLEAN VM IN WASTE.LIST AND CREATE NEW WM&gt;# /bin/echo "TRY TO CLEAN VM IN WASTE.LIST AND CREATE NEW VM" make_housekeeper /usr/bin/echo "# $date STOP EXECUTE VM_MANAGER.SH#" exit fi else #&lt;PORT IS NOT A LISTEN. MOVE PORT FROM CLEAR.LIST TO WASTE.LIST&gt;# /bin/echo " "$clear_vm_port" is NOT LISTEN. REMOVE PORT FROM CLEAR.LIST" /usr/bin/sed -i "/$clear_vm_port/d" $SRV_TMP_DIR/clear.list /usr/bin/echo $clear_vm_port &gt;&gt; $SRV_TMP_DIR/waste.list make_housekeeper fi done fi } make_housekeeper() { /usr/bin/echo "=Execute housekeeper=" /usr/bin/cat $SRV_TMP_DIR/waste.list |while read line do /usr/bin/echo "$line" if /usr/bin/netstat -lnt |/usr/bin/grep ":$line" &gt; /dev/null then /bin/echo "port_alive, vm is running" if /usr/bin/netstat -nt |/usr/bin/grep ":$line" \ |/usr/bin/grep "ESTABLISHED" &gt; /dev/null then /bin/echo "port_in_use can't delete vm!!!" else /bin/echo "port_not in use. Deleting vm" /usr/bin/sed -i "/$line/d" $SRV_TMP_DIR/waste.list /usr/bin/echo $line &gt;&gt; $SRV_TMP_DIR/recycle.list $SRV_SCRIPTS_DIR/vm_delete.sh $line fi else /usr/bin/echo "posible vm is already off. Deleting vm" /usr/bin/echo "MOVE VM IN OFF STATE $line FROM WASTE.LIST TO" \ "RECYCLE.LIST AND DELETE VM" /usr/bin/sed -i "/$line/d" $SRV_TMP_DIR/waste.list /usr/bin/echo $line &gt;&gt; $SRV_TMP_DIR/recycle.list $SRV_SCRIPTS_DIR/vm_delete.sh "$line" fi done create_clear_vm } create_clear_vm() { /usr/bin/echo "=Create new VM=" while [ $SRV_POOL_SIZE -gt 0 ] do new_vm_port=$(($SRV_START_PORT_POOL+$SRV_POOL_SIZE)) /usr/bin/echo "new_vm_port=$new_vm_port" if /usr/bin/grep "$new_vm_port" $SRV_TMP_DIR/clear.list &gt; /dev/null then /usr/bin/echo "$new_vm_port port is already defined in clear.list" else if /usr/bin/grep "$new_vm_port" $SRV_TMP_DIR/waste.list &gt; /dev/null then /usr/bin/echo "$new_vm_port port is already defined in waste.list" else if /usr/bin/grep "$new_vm_port" $SRV_TMP_DIR/recycle.list &gt; /dev/null then /usr/bin/echo "$new_vm_port PORT IS ALREADY DEFINED IN RECYCLE LIST" else if /usr/bin/grep "$new_vm_port" $SRV_TMP_DIR/conn_wait.list &gt; /dev/null then /usr/bin/echo "$new_vm_port PORT IS ALREADY DEFINED IN CONN_WAIT LIST" else /usr/bin/echo "PORT IN NOT DEFINED IN NO ONE LIST WILL CREATE" \ "VM ON PORT $new_vm_port" /usr/bin/echo $new_vm_port &gt;&gt; $SRV_TMP_DIR/recycle.list $SRV_SCRIPTS_DIR/vm_create.sh $new_vm_port fi fi fi fi SRV_POOL_SIZE=$(($SRV_POOL_SIZE-1)) done /usr/bin/echo "# $date STOP EXECUTE VM_MANAGER.SH #" } make_connect_to_vm |/usr/bin/tee -a /var/log/vm_manager.log</span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">/etc/vm_manager.conf</b> <div class="spoiler_text">  srv_scripts_dir = /主页/管理员/ scripts_vdi_new <br>  srv_pool_size = 4 <br>  srv_start_port_pool = 5920 <br>  srv_tmp_dir = / tmp / vm_state <br>  base_host = win10_2 <br>  input_iface = enp5s0 <br>  vdi_spice_port = 5906 <br>  count_conn_tryes = 10 <br></div></div><br><br> 配置文件vm_manager.conf的变量说明 <br>  srv_scripts_dir-脚本位置文件夹vm_manager.sh，vm_connect.sh，vm_delete.sh，vm_create.sh，vm_clear.sh <br>  srv_pool_size-Vm池大小 <br>  srv_start_port_pool-初始端口，之后将启动虚拟机控制台的香料端口 <br>  srv_tmp_dir-临时文件的文件夹 <br>  base_host-基本Vm（黄金映像），将从该基本Vm克隆到池中 <br>  input_iface-服务器的网络接口，面向客户端工作站 <br>  vdi_spice_port-服务器的网络端口，连接请求将从该服务器的网络端口从远程查看器客户端重定向到所选Vm的spice端口 <br>  count_conn_tryes-等待计时器，在此之后认为尚未与Vm建立连接（有关详细信息，请参阅vm_connect.sh） <br><br>  vm_manager.sh脚本从vm_manager.conf文件中读取配置文件，并根据多个参数评估池中虚拟机的状态，即：已部署了多少个VM，是否有免费的干净VM。 为此，他读取了clear.list文件，其中包含“新创建”（请参见下面的VM创建周期）虚拟机的“ spice_console”端口号，并检查与它们的已建立连接。 如果检测到具有已建立网络连接的端口（绝对不应），则将显示警告，并将该端口转移到waste.list。如果从clear.list文件中找到当前没有连接的第一个端口，则vm_manager.sh调用vm_connect.sh脚本并通过他作为该端口号的参数。 <br><br><div class="spoiler">  <b class="spoiler_title">/home/admin/scripts_vdi_new/vm_connect.sh</b> <div class="spoiler_text"><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#!/bin/sh date=$(/usr/bin/date) /usr/bin/echo "#" "$date" "START EXECUTE VM_CONNECT.SH#" #&lt;SET LOCAL VARIABLES FOR SCRIPT&gt;# free_port="$1" input_iface=$(/usr/bin/cat /etc/vm_manager.conf |/usr/bin/grep "input_iface" \ |/usr/bin/cut -d "=" -f2) /usr/bin/echo "input_iface=$input_iface" vdi_spice_port=$(/usr/bin/cat /etc/vm_manager.conf \ |/usr/bin/grep "vdi_spice_port" |/usr/bin/cut -d "=" -f2) /usr/bin/echo "vdi_spice_port=$vdi_spice_port" count_conn_tryes=$(/usr/bin/cat /etc/vm_manager.conf \ |/usr/bin/grep "count_conn_tryes" |/usr/bin/cut -d "=" -f2) /usr/bin/echo "count_conn_tryes=$count_conn_tryes" #&lt;/SET LOCAL VARIABLES FOR SCRIPT&gt;# #&lt;CREATE IPTABLES RULES AND SEND SIGNAL TO CONNECT&gt;# /usr/bin/echo "create rule for port" $free_port /usr/sbin/iptables -I INPUT -i $input_iface -p tcp -m tcp --dport \ $free_port -j ACCEPT /usr/sbin/iptables -I OUTPUT -o $input_iface -p tcp -m tcp --sport \ $free_port -j ACCEPT /usr/sbin/iptables -t nat -I PREROUTING -p tcp -i $input_iface --dport \ $vdi_spice_port -j DNAT --to-destination 127.0.0.1:$free_port /usr/bin/echo "RULE ADDED, CONNECT NOW!" #&lt;/CREATE IPTABLES RULES AND SEND SIGNAL TO CONNECT&gt;# #&lt;WAIT CONNECT ESTABLISHED AND ACTIVATE CONNECT TIMER&gt;# while [ $count_conn_tryes -gt 0 ] do if /usr/bin/netstat -nt |/usr/bin/grep ":$free_port" \ |/usr/bin/grep "ESTABLISHED" &gt; /dev/null then /bin/echo "$free_port NOW in use!!!" /usr/bin/sleep 1s /usr/sbin/iptables -t nat -D PREROUTING -p tcp -i $input_iface --dport \ $vdi_spice_port -j DNAT --to-destination 127.0.0.1:$free_port /usr/sbin/iptables -D INPUT -i $input_iface -p tcp -m tcp --dport \ $free_port -j ACCEPT /usr/sbin/iptables -D OUTPUT -o $input_iface -p tcp -m tcp --sport \ $free_port -j ACCEPT /usr/bin/sed -i "/$free_port/d" $SRV_TMP_DIR/conn_wait.list /usr/bin/echo $free_port &gt;&gt; $SRV_TMP_DIR/waste.list return else /usr/bin/echo "$free_port NOT IN USE" /usr/bin/echo "RULE ADDED, CONNECT NOW!" /usr/bin/sleep 1s fi count_conn_tryes=$((count_conn_tryes-1)) done #&lt;/WAIT CONNECT ESTABLISED AND ACTIVATE CONNECT TIMER&gt;# #&lt;IF COUNT HAS EXPIRED. REMOVE IPTABLES RULE AND REVERT \ # VM TO CLEAR.LIST&gt;# /usr/bin/echo "REVERT IPTABLES RULE AND REVERT VM TO CLEAN \ LIST $free_port" /usr/sbin/iptables -t nat -D PREROUTING -p tcp -i $input_iface --dport \ $vdi_spice_port -j DNAT --to-destination 127.0.0.1:$free_port /usr/sbin/iptables -D INPUT -i $input_iface -p tcp -m tcp --dport $free_port \ -j ACCEPT /usr/sbin/iptables -D OUTPUT -o $input_iface -p tcp -m tcp --sport \ $free_port -j ACCEPT /usr/bin/sed -i "/$free_port/d" $SRV_TMP_DIR/conn_wait.list /usr/bin/echo $free_port &gt;&gt; $SRV_TMP_DIR/clear.list #&lt;/COUNT HAS EXPIRED. REMOVE IPTABLES RULE AND REVERT VM \ #TO CLEAR.LIST&gt;# /usr/bin/echo "#" "$date" "END EXECUTE VM_CONNECT.SH#" # Attention! Must Be! sysctl net.ipv4.conf.all.route_localnet=1</span></span></code> </pre><br></div></div><br>  vm_connect.sh脚本引入了防火墙规则，这些规则创建了enp5s0接口的服务器端口到位于lo0服务器接口上的VM的“ spice控制台端口”的重定向“ vdi_spice_port”，并作为启动参数传递。 该端口已转移到conn_wait.list，该VM被视为挂起连接。 已将规则添加，立即连接行发送到服务器“信号”端口上的Client Station会话，这是运行在其上的remote.sh脚本所期望的。 连接等待周期以尝试次数开始，尝试次数由配置文件中的变量“ count_conn_tryes”的值确定。 在nc会话中，每秒钟都会给出字符串“ RULE ADDED，CONNECT NOW”，并检查与“ spice_console”端口建立的连接。 <br><br> 如果由于设置的尝试次数而连接失败，则将spice_console端口传送回clear.list。vm_connect.sh的执行已完成，vm_manager.sh的执行已恢复，从而开始了清洁周期。 <br><br> 如果客户端工作站连接到lo0接口上的spice_console端口，则将删除在spice服务器端口和spice_console端口之间创建重定向的防火墙规则，并通过确定防火墙状态的机制进一步维护该连接。 如果连接断开，则重新连接到spice_console端口将失败。  spice_console端口已转移到waste.list，该VM被认为是脏的，并且如果不进行清理，就无法返回到干净的虚拟机池。 完成vm_connect.sh的执行，恢复执行vm_manager.sh，这将启动清理周期。 <br><br> 清理周期通过查看waste.list文件开始，将建立连接的虚拟机端口的spice_console编号传输到该文件中。 从列表中的每个spice_console端口确定活动连接的存在。 如果没有连接，则认为该虚拟机已不再使用，并且该端口已转移到recycle.list，并且开始删除该端口所属的虚拟机（请参见下文）的过程。 如果在端口上检测到活动的网络连接，则假定正在使用虚拟机，则不会对其执行任何操作。 如果未敲击该端口，则认为该VM已关闭且不再需要。 端口已转移到recycle.list，并且删除虚拟机的过程开始。 为此，将调用vm_delete.sh脚本，并将“ spice_console”号作为参数传输到VM端口，该脚本必须删除。 <br><br><div class="spoiler">  <b class="spoiler_title">/home/admin/scripts_vdi_new/vm_delete.sh</b> <div class="spoiler_text"><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#!/bin/sh #&lt;Set local VARIABLES&gt;# port_to_delete="$1" date=$(/usr/bin/date) #&lt;/Set local VARIABLES&gt;# /usr/bin/echo "# $date START EXECUTE VM_DELETE.SH#" /usr/bin/echo "TRY DELETE VM ON PORT: $vm_port" #&lt;VM NAME SETUP&gt;# vm_name_part1=$(/usr/bin/cat /etc/vm_manager.conf |/usr/bin/grep 'base_host' \ |/usr/bin/cut -d'=' -f2) vm_name=$(/usr/bin/echo "$vm_name_part1""-""$port_to_delete") #&lt;/VM NAME SETUP&gt;# #&lt;SHUTDOWN AND DELETE VM&gt;# /usr/bin/virsh destroy $vm_name /usr/bin/virsh undefine $vm_name /usr/bin/rm -f /var/lib/libvirt/images_write/$vm_name.qcow2 /usr/bin/sed -i "/$port_to_delete/d" $SRV_TMP_DIR/recycle.list #&lt;/SHUTDOWN AND DELETE VM&gt;# /usr/bin/echo "VM ON PORT $vm_port HAS BEEN DELETE AND REMOVE" \ "FROM RECYCLE.LIST. EXIT FROM VM_DELETE.SH" /usr/bin/echo "# $date STOP EXECUTE VM_DELETE.SH#" exit</span></span></code> </pre><br></div></div><br> 删除虚拟机是一项非常简单的操作，vm_delete.sh脚本确定拥有作为启动参数传递的端口的虚拟机的名称。 强制虚拟机停止，将虚拟机从虚拟机管理程序中删除，并删除该虚拟机的虚拟硬盘。 从recycle.list中删除了spice_console端口。 结束vm_delete.sh的执行，恢复执行vm_manager.sh <br><br> 在从清单waste.list清除不必要的虚拟机的操作结束时，脚本vm_manager.sh开始在池中创建虚拟机的周期。 <br><br> 该过程从确定可用于托管的spice_console端口开始。 为此，根据配置文件“ srv_start_port_pool”的参数（该参数设置虚拟机池“ spice_console”的起始端口）和参数“ srv_pool_size”（确定虚拟机数量的限制），依次枚举所有可能的端口变量。 对于每个特定端口，将在clear.list，waste.list，conn_wait.list，recycle.list中进行搜索。 如果在这些文件中的任何一个文件中都找到了端口，则该端口被认为是繁忙的并且被跳过。 如果在指定文件中找不到该端口，则将其输入到recycle.list文件中，然后开始创建新虚拟机的过程。 为此，调用vm_create.sh脚本，您要为其创建VM的端口的spice_console号作为参数传递给该脚本。 <br><br><div class="spoiler">  <b class="spoiler_title">/home/admin/scripts_vdi_new/vm_create.sh</b> <div class="spoiler_text"><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#!/bin/sh /usr/bin/echo "#" "$date" "START RUNNING VM_CREATE.SH#" new_vm_port=$1 date=$(/usr/bin/date) a=0 /usr/bin/echo SRV_TMP_DIR=$SRV_TMP_DIR #&lt;SET LOCAL VARIABLES FOR SCRIPT&gt;# base_host=$(/usr/bin/cat /etc/vm_manager.conf |/usr/bin/grep "base_host" \ |/usr/bin/cut -d "=" -f2) /usr/bin/echo "base_host=$base_host" #&lt;/SET LOCAL VARIABLES FOR SCRIPT&gt;# hdd_image_locate() { /bin/echo "Run STEP 1 - hdd_image_locate" hdd_base_image=$(/usr/bin/virsh dumpxml $base_host \ |/usr/bin/grep "source file" |/usr/bin/grep "qcow2" |/usr/bin/head -n 1 \ |/usr/bin/cut -d "'" -f2) if [ -z "$hdd_base_image" ] then /bin/echo "base hdd image not found!" else /usr/bin/echo "hdd_base_image found is a $hdd_base_image. Run next step 2" #&lt; CHECK FOR SNAPSHOT ON BASE HDD &gt;# if [ 0 -eq `/usr/bin/qemu-img info "$hdd_base_image" | /usr/bin/grep -c "Snapshot"` ] then /usr/bin/echo "base image haven't snapshot, run NEXT STEP 3" else /usr/bin/echo "base hdd image have a snapshot, can't use this image" exit fi #&lt;/ CHECK FOR SNAPSHOT ON BASE HDD &gt;# #&lt; CHECK FOR HDD IMAGE IS LINK CLONE &gt;# if [ 0 -eq `/usr/bin/qemu-img info "$hdd_base_image" |/usr/bin/grep -c "backing file" then /usr/bin/echo "base image is not a linked clone, NEXT STEP 4" /usr/bin/echo "Base image check complete!" else /usr/bin/echo "base hdd image is a linked clone, can't use this image" exit fi fi #&lt;/ CHECK FOR HDD IMAGE IS LINK CLONE &gt;# cloning } cloning() { # &lt;Step_1 turn the base VM off &gt;# /usr/bin/virsh shutdown $base_host &gt; /dev/null 2&gt;&amp;1 # &lt;/Step_1 turn the base VM off &gt;# #&lt;Create_vm_config&gt;# /usr/bin/echo "Free port for Spice VM is $new_vm_port" #&lt;Setup_name_for_new_VM&gt;# new_vm_name=$(/bin/echo $base_host"-"$new_vm_port) #&lt;/Setup_name_for_new_VM&gt;# #&lt;Make_base_config_as_clone_base_VM&gt;# /usr/bin/virsh dumpxml $base_host &gt; $SRV_TMP_DIR/$new_vm_name.xml #&lt;Make_base_config_as_clone_base_VM&gt;# ##&lt;Setup_New_VM_Name_in_config&gt;## /usr/bin/sed -i "s%&lt;name&gt;$base_host&lt;/name&gt;%&lt;name&gt;$new_vm_name&lt;/name&gt;%g" $SRV_TMP_DIR/$new_vm_name.xml #&lt;/Setup_New_VM_Name_in_config&gt;# #&lt;UUID Changing&gt;# old_uuid=$(/usr/bin/cat $SRV_TMP_DIR/$new_vm_name.xml |/usr/bin/grep "&lt;uuid&gt;") /usr/bin/echo old UUID $old_uuid new_uuid_part1=$(/usr/bin/echo "$old_uuid" |/usr/bin/cut -d "-" -f 1,2) new_uuid_part2=$(/usr/bin/echo "$old_uuid" |/usr/bin/cut -d "-" -f 4,5) new_uuid=$(/bin/echo $new_uuid_part1"-"$new_vm_port"-"$new_uuid_part2) /usr/bin/echo $new_uuid /usr/bin/sed -i "s%$old_uuid%$new_uuid%g" $SRV_TMP_DIR/$new_vm_name.xml #&lt;/UUID Changing&gt;# #&lt;Spice port replace&gt;# old_spice_port=$(/usr/bin/cat $SRV_TMP_DIR/$new_vm_name.xml \ |/usr/bin/grep "graphics type='spice' port=") /bin/echo old spice port $old_spice_port new_spice_port=$(/usr/bin/echo "&lt;graphics type='spice' port='$new_vm_port' autoport='no' listen='127.0.0.1'&gt;") /bin/echo $new_spice_port /usr/bin/sed -i "s%$old_spice_port%$new_spice_port%g" $SRV_TMP_DIR/$new_vm_name.xml #&lt;/Spice port replace&gt;# #&lt;MAC_ADDR_GENERATE&gt;# mac_new=$(/usr/bin/hexdump -n6 -e '/1 ":%02X"' /dev/random|/usr/bin/sed s/^://g) /usr/bin/echo New Mac is $mac_new #&lt;/MAC_ADDR_GENERATE&gt;# #&lt;GET OLD MAC AND REPLACE&gt;# mac_old=$(/usr/bin/cat $SRV_TMP_DIR/$new_vm_name.xml |/usr/bin/grep "mac address=") /usr/bin/echo old mac is $mac_old /usr/bin/sed -i "s%$mac_old%$mac_new%g" $SRV_TMP_DIR/$new_vm_name.xml #&lt;GET OLD MAC AND REPLACE&gt;# #&lt;new_disk_create&gt;# /usr/bin/qemu-img create -f qcow2 -b $hdd_base_image /var/lib/libvirt/images_write/$new_vm_name.qcow2 #&lt;/new_disk_create&gt;# #&lt;attach_new_disk_in_confiig&gt;# /usr/bin/echo hdd base image is $hdd_base_image /usr/bin/sed -i "s%&lt;source file='$hdd_base_image'/&gt;%&lt;source file='/var/lib/libvirt/images_write/$new_vm_name.qcow2'/&gt;%g" $SRV_TMP_DIR/$new_vm_name.xml #&lt;/attach_new_disk_in_confiig&gt;# starting_vm #&lt;/Create_vm config&gt;# } starting_vm() { /usr/bin/virsh define $SRV_TMP_DIR/$new_vm_name.xml /usr/bin/virsh start $new_vm_name while [ $a -ne 1 ] do if /usr/bin/virsh list --all |/usr/bin/grep "$new_vm_name" |/usr/bin/grep "running" &gt; /dev/null 2&gt;&amp;1 then a=1 /usr/bin/sed -i "/$new_vm_port/d" $SRV_TMP_DIR/recycle.list /usr/bin/echo $new_vm_port &gt;&gt; $SRV_TMP_DIR/clear.list /usr/bin/echo "#" "$date" "VM $new_vm_name IS STARTED #" else /usr/bin/echo "#VM $new_vm_name is not ready#" a=0 /usr/bin/sleep 2s fi done /usr/bin/echo "#$date EXIT FROM VM_CREATE.SH#" exit } hdd_image_locate</span></span></code> </pre><br></div></div><br> 创建新虚拟机的过程 <br><br>  vm_create.sh脚本从配置文件中读取变量“ base_host”的值，该变量确定将基于其进行克隆的示例虚拟机。 它从虚拟机监控程序数据库中卸载VM的xml配置，对VM磁盘映像执行一系列检查qcow，并在成功完成后为新VM和新VM的“链接克隆”磁盘映像创建xml配置文件。 然后，将新VM的xml配置加载到管理程序数据库中，然后VM启动。  spice_console端口从recycle.list转移到clear.list。  vm_create.sh的执行结束，并且vm_manager.sh的执行结束。 <br> 下次连接时，将从头开始。 <br><br> 对于紧急情况，该工具包包含脚本vm_clear.sh，该脚本会强制运行池中的所有VM，并通过将列表的值清零来删除它们。 在加载阶段调用它可以使您从头开始（在VDI下）。 <br><br><div class="spoiler">  <b class="spoiler_title">/home/admin/scripts_vdi_new/vm_clear.sh</b> <div class="spoiler_text"><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#!/usr/bin/sh #set VARIABLES# SRV_SCRIPTS_DIR=$(/usr/bin/cat /etc/vm_manager.conf \ |/usr/bin/grep "srv_scripts_dir" |/usr/bin/cut -d "=" -f2) /usr/bin/echo "SRV_SCRIPTS_DIR=$SRV_SCRIPTS_DIR" export SRV_SCRIPTS_DIR=$SRV_SCRIPTS_DIR SRV_TMP_DIR=$(/usr/bin/cat /etc/vm_manager.conf \ |/usr/bin/grep "srv_tmp_dir" |/usr/bin/cut -d "=" -f2) /usr/bin/echo "SRV_TMP_DIR=$SRV_TMP_DIR" export SRV_TMP_DIR=$SRV_TMP_DIR SRV_POOL_SIZE=$(/usr/bin/cat /etc/vm_manager.conf \ |/usr/bin/grep "srv_pool_size" |/usr/bin/cut -d "=" -f2) /usr/bin/echo "SRV_POOL_SIZE=$SRV_POOL_SIZE" SRV_START_PORT_POOL=$(/usr/bin/cat /etc/vm_manager.conf \ |/usr/bin/grep "srv_start_port_pool" |/usr/bin/cut -d "=" -f2) /usr/bin/echo SRV_START_PORT_POOL=$SRV_START_PORT_POOL #Set VARIABLES# /usr/bin/echo "= Cleanup ALL VM=" /usr/bin/mkdir $SRV_TMP_DIR /usr/sbin/service iptables restart /usr/bin/cat /dev/null &gt; $SRV_TMP_DIR/clear.list /usr/bin/cat /dev/null &gt; $SRV_TMP_DIR/waste.list /usr/bin/cat /dev/null &gt; $SRV_TMP_DIR/recycle.list /usr/bin/cat /dev/null &gt; $SRV_TMP_DIR/conn_wait.list port_to_delete=$(($SRV_START_PORT_POOL+$SRV_POOL_SIZE)) while [ "$port_to_delete" -gt "$SRV_START_PORT_POOL" ] do $SRV_SCRIPTS_DIR/vm_delete.sh $port_to_delete port_to_delete=$(($port_to_delete-1)) done /usr/bin/echo "= EXIT FROM VM_CLEAR.SH="</span></span></code> </pre><br></div></div><br> 在此，我想结束我的故事的第一部分。 以上内容足以让系统管理员尝试在业务中使用underVDI。 如果社区觉得这个话题很有趣，那么在第二部分中，我将讨论livecd Fedora的修改及其向自助服务亭的转变。 </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN462203/">https://habr.com/ru/post/zh-CN462203/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN462181/index.html">在群聊中进行有效交流的规则</a></li>
<li><a href="../zh-CN462185/index.html">革命结束了。 有锂离子电池的替代品吗？</a></li>
<li><a href="../zh-CN462189/index.html">使用travajs蚀刻数据</a></li>
<li><a href="../zh-CN462191/index.html">数据艺术博物馆：意大利北部之旅</a></li>
<li><a href="../zh-CN462197/index.html">有关如何解放思想并提高创造力的提示</a></li>
<li><a href="../zh-CN462205/index.html">赢得PHDays 9僵局：True0xA3团队的编年史</a></li>
<li><a href="../zh-CN462209/index.html">宝利通视频会议解决方案。 6年后的回忆...第2阶段。第1部分。RMX1500</a></li>
<li><a href="../zh-CN462213/index.html">学习和工作：信息技术与编程学院的本科生经验</a></li>
<li><a href="../zh-CN462221/index.html">我对Google Play感到多么失望</a></li>
<li><a href="../zh-CN462227/index.html">莫斯科，8月9日-后端故事4.0</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>