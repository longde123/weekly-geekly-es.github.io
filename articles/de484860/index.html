<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üéã üîã üéä Implementierungsname und Ergebnisname üì® üìà ü•´</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ich wollte diesen Beitrag schon im Juli schreiben, konnte mich aber, oh Ironie , nicht entscheiden, wie ich ihn nennen soll. Erst nach Kate Gregorys V...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Implementierungsname und Ergebnisname</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/484860/"><p><img src="https://habrastorage.org/webt/sw/9a/fb/sw9afbxo38dofpspvffb0c_jrq4.jpeg"></p><br><p>  Ich wollte diesen Beitrag schon im Juli schreiben, konnte mich aber, <em>oh Ironie</em> , nicht entscheiden, wie ich ihn nennen soll.  Erst nach <a href="https://www.youtube.com/watch%3Fv%3DMBRoCdtZOYg">Kate Gregorys Vortrag auf der CppCon</a> kamen mir gute Begriffe in den Sinn, und jetzt kann ich Ihnen endlich sagen, wie man Funktionen <a href="https://www.youtube.com/watch%3Fv%3DMBRoCdtZOYg">aufruft</a> . </p><br><p> Nat√ºrlich gibt es Namen, die √ºberhaupt keine Informationen enthalten, wie z. B. <code>int f(int x)</code> .  Sie m√ºssen auch nicht verwendet werden, aber es geht nicht um sie.  Manchmal scheint es, dass die Informationen im Titel voll sind, aber es gibt absolut keinen Nutzen daraus. </p><a name="habracut"></a><br><h2 id="primer-1-stdlog2p1">  Beispiel 1: std :: log2p1 () </h2><br><p>  In C ++ 20 wurden dem Header mehrere neue Funktionen f√ºr Bitoperationen hinzugef√ºgt, unter anderem <code>std::log2p1</code> .  Es sieht so aus: <br><br><br></p><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">log2p1</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> i)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (i == <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> + <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::log2(x)); }</code> </pre><br><p>  Das hei√üt, f√ºr jede nat√ºrliche Zahl gibt die Funktion ihren bin√§ren Logarithmus plus 1 zur√ºck, und f√ºr 0 gibt sie 0 zur√ºck. Und dies ist keine Schulaufgabe f√ºr den Operator if / else, das ist wirklich n√ºtzlich - die minimale Anzahl von Bits, in die dieser Wert passt.  Es ist fast unm√∂glich, nur den Namen der Funktion zu erraten. </p><br><h2 id="primer-2-stdbless">  Beispiel 2: std :: bless () </h2><br><p>  <em>Jetzt geht es nicht mehr um den Namen</em> </p><br><p>  Ein kleiner Exkurs: In C ++ funktioniert Zeigerarithmetik nur mit Zeigern auf Array-Elemente.  Was im Prinzip logisch ist: Im allgemeinen Fall ist die Menge der Nachbarobjekte unbekannt und "in zehn Bytes rechts von der Variablen <code>i</code> kann alles passieren".  Dies ist eindeutig vages Verhalten. </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> obj = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>* ptr = &amp;obj; ++ptr; <span class="hljs-comment"><span class="hljs-comment">//  </span></span></code> </pre> <br><p>  Eine solche Einschr√§nkung deklariert jedoch einen gro√üen Teil des vorhandenen Codes als unbestimmt.  Hier ist zum Beispiel eine vereinfachte Implementierung von <code>std::vector&lt;T&gt;::reserve()</code> : </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">reserve</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> n)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//      auto new_memory = (T*) ::operator new(n * sizeof(T)); //    ‚Ä¶ //   auto size = this-&gt;size(); begin_ = new_memory; //   end_ = new_memory + size; //     end_capacity_ = new_memory + n; //    }</span></span></code> </pre> <br><p>  Wir haben Speicher zugewiesen, alle Objekte verschoben und versuchen nun sicherzustellen, dass die Zeiger angeben, wohin sie gehen sollen.  Hier sind nur die letzten drei Zeilen undefiniert, da sie arithmetische Operationen auf Zeiger au√üerhalb des Arrays enthalten! </p><br><p>  Nat√ºrlich ist nicht der Programmierer schuld.  Das Problem liegt im C ++ - Standard selbst, der dieses offensichtlich vern√ºnftige St√ºck Code als undefiniertes Verhalten deklariert.  Daher schl√§gt <a href="https://wg21.link/p0593">P0593</a> vor, den Standard zu korrigieren, indem einige Funktionen (wie <code>::operator new</code> und <code>std::malloc</code> ) hinzugef√ºgt werden, mit denen Arrays nach Bedarf erstellt werden k√∂nnen.  Alle von ihnen erstellten Zeiger werden auf magische Weise zu Zeigern auf Arrays, und arithmetische Operationen k√∂nnen mit ihnen ausgef√ºhrt werden. </p><br><p>  <em>Noch immer nicht √ºber die Namen, warte eine Sekunde.</em> </p><br><p>  Manchmal sind jedoch Operationen an Zeigern erforderlich, wenn mit Speicher gearbeitet wird, den eine dieser Funktionen nicht zugewiesen hat.  Beispielsweise funktioniert die Funktion <code>deallocate()</code> Wesentlichen mit totem Speicher, in dem sich √ºberhaupt keine Objekte befinden, der Zeiger und die Gr√∂√üe des Bereichs jedoch addiert werden m√ºssen.  F√ºr diesen Fall bot P0593 die Funktion <code>std::bless(void* ptr, std::size_t n)</code> (es gab dort eine andere Funktion, die auch <code>bless</code> , aber darum geht es nicht).  Es hat keine Auswirkung auf einen realen physischen Computer, erstellt jedoch Objekte f√ºr eine abstrakte Maschine, die die Verwendung von Zeigerarithmetik erm√∂glichen. </p><br><p>  Der Name <code>std::bless</code> war vor√ºbergehend. </p><br><p>  <em>Also der Name.</em> </p><br><p>  In K√∂ln wurde die LEWG beauftragt, einen Namen f√ºr diese Funktion zu finden.  Die Optionen <code>implicitly_create_objects()</code> und <code>implicitly_create_objects_as_needed()</code> wurden vorgeschlagen, da dies die Funktion ausf√ºhrt. </p><br><p>  Diese Optionen haben mir nicht gefallen. </p><br><h2 id="primer-3-stdpartial_sort_copy">  Beispiel 3: std :: partial_sort_copy () </h2><br><p>  <em>Beispiel aus <a href="https://www.youtube.com/watch%3Fv%3DMBRoCdtZOYg">Kates Pr√§sentation</a></em> </p><br><p>  Es gibt eine Funktion <code>std::sort</code> , die die Elemente des Containers sortiert: </p><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; vec = {<span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>}; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::sort(vec.begin(), vec.end()); <span class="hljs-comment"><span class="hljs-comment">// vec == {1, 2, 3, 4, 5}</span></span></code> </pre> <br><p>  Es gibt auch <code>std::partial_sort</code> , das nur einen Teil der Elemente sortiert: </p><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; vec = {<span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>}; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::partial_sort(vec.begin(), vec.begin() + <span class="hljs-number"><span class="hljs-number">3</span></span>, vec.end()); <span class="hljs-comment"><span class="hljs-comment">// vec == {1, 2, 3, ?, ?} ( ...4,5,  ...5,4)</span></span></code> </pre> <br><p>  Und trotzdem gibt es <code>std::partial_sort_copy</code> , das auch einen Teil der Elemente sortiert, gleichzeitig aber den alten Container nicht √§ndert, sondern die Werte in den neuen √ºbertr√§gt: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; vec = {<span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>}; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; out; out.resize(<span class="hljs-number"><span class="hljs-number">3</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::partial_sort_copy(vec.begin(), vec.end(), out.begin(), out.end()); <span class="hljs-comment"><span class="hljs-comment">// out == {1, 2, 3}</span></span></code> </pre> <br><p>  Kate behauptet, dass <code>std::partial_sort_copy</code> ein <code>std::partial_sort_copy</code> Name ist, und ich stimme ihr zu. </p><br><h2 id="nazvanie-implementacii-i-nazvanie-rezultata">  Implementierungsname und Ergebnisname </h2><br><p>  Keiner der aufgelisteten Namen ist streng genommen <em>falsch</em> : Sie alle beschreiben perfekt, was die Funktion tut.  <code>std::log2p1()</code> z√§hlt wirklich den bin√§ren Logarithmus und addiert einen dazu;  <code>implicitly_create_objects()</code> erstellt implizit Objekte, und <code>std::partial_sort_copy()</code> sortiert den Container teilweise und kopiert das Ergebnis.  Ich mag jedoch nicht alle diese Namen, weil sie <em>unbrauchbar sind</em> . </p><br><p>  Kein Programmierer sitzt und denkt: "Ich w√ºnschte, ich k√∂nnte den bin√§ren Logarithmus nehmen und einen hinzuf√ºgen."  Er muss wissen, wie viele Bits der angegebene Wert passen wird, und er durchsucht die Docks erfolglos nach etwas wie <code>bit_width</code> .  Als er den Bibliotheksbenutzer erreicht, hat er bereits seine Implementierung geschrieben (und h√∂chstwahrscheinlich die Pr√ºfung auf Null verpasst), was der bin√§re Logarithmus damit zu tun hat.  Auch wenn sich <code>std::log2p1</code> als ein Wunder im Code herausstellte, sollte der n√§chste, der diesen Code sieht, wieder verstehen, was es ist und warum es ben√∂tigt wird.  <code>bit_width(max_value)</code> h√§tte ein solches Problem nicht. </p><br><p>  Ebenso muss niemand "implizit Objekte erstellen" oder "die Kopie des Vektors teilweise sortieren" - er muss den Speicher wiederverwenden oder die 5 gr√∂√üten Werte in absteigender Reihenfolge abrufen.  Etwas wie <code>recycle_storage()</code> (was auch als Name <code>std::bless</code> ) und <code>top_n_sorted()</code> w√§ren viel klarer. </p><br><p>  Kate verwendet den Begriff <em>Implementierungsname</em> f√ºr <code>std::partial_sort_copy()</code> , passt aber auch auf zwei andere Funktionen.  Die Umsetzung ihres Namens ist wirklich perfekt beschrieben.  Der Benutzer ben√∂tigt lediglich den Namen des Ergebnisses - das, was er durch Aufrufen der Funktion erh√§lt.  Um ihre interne Struktur k√ºmmert es ihn nicht, er will nur die Gr√∂√üe in Bits herausfinden oder den Speicher wiederverwenden. </p><br><p>  <strong>Eine Funktion anhand ihrer Spezifikation zu benennen, bedeutet, aus heiterem Himmel ein Missverst√§ndnis zwischen dem Entwickler der Bibliothek und ihrem Benutzer zu schaffen.</strong>  <strong>Sie m√ºssen sich immer daran erinnern, wann und wie die Funktion verwendet wird.</strong> </p><br><p>  Das klingt bl√∂d, ja.  Aber nach <code>std::log2p1()</code> urteilen, ist dies <code>std::log2p1()</code> f√ºr jedermann offensichtlich.  Au√üerdem ist es manchmal nicht so einfach. </p><br><h2 id="primer-4-stdpopcount">  Beispiel 4: std :: popcount () </h2><br><p>  <code>std::popcount()</code> wird wie <code>std::log2p1()</code> in C ++ 20 vorgeschlagen, <code>&lt;bit&gt;</code> hinzuzuf√ºgen.  Und das ist nat√ºrlich ein ungeheuer schlechter Name.  Wenn Sie nicht wissen, was diese Funktion bewirkt, k√∂nnen Sie sie nicht erraten.  Nicht nur die Abk√ºrzung ist verwirrend (es gibt Pop im Namen, aber Pop / Push hat nichts damit zu tun) - Entschl√ºsselung der Bev√∂lkerungszahl (Z√§hlung der Bev√∂lkerung? Die Anzahl der Populationen?) Auch nicht hilfreich. </p><br><p>  Auf der anderen Seite ist <code>std::popcount()</code> ideal f√ºr diese Funktion, da es die Assembler-Anweisung popcount aufruft.  Dies ist nicht nur der <em>Name der</em> Implementierung, sondern deren vollst√§ndige Beschreibung. </p><br><p>  In diesem Fall ist die Kluft zwischen Sprachentwicklern und Programmierern jedoch nicht so gro√ü.  Eine Anweisung, die die Anzahl der Einheiten in einem Bin√§rwort z√§hlt, wird als Popcount aus den sechziger Jahren bezeichnet.  F√ºr eine Person, die etwas √ºber Bitoperationen wei√ü, ist ein solcher Name absolut offensichtlich. </p><br><p>  <em>√úbrigens eine gute Frage: Findest du Namen, die f√ºr Anf√§nger geeignet sind, oder kennst du sie f√ºr Oldfags?</em> </p><br><h2 id="heppi-end">  Happy End? </h2><br><p>  <a href="https://wg21.link/P1956">P1956</a> schl√§gt vor, <code>std::log2p1()</code> in <code>std::bit_width()</code> .  Dieser Vorschlag wird wahrscheinlich in C ++ 20 angenommen.  <code>std::ceil2</code> und <code>std::floor2</code> werden ebenfalls in std :: bit_ceil () bzw. std :: bit_floor () umbenannt.  Ihre alten Namen waren auch nicht sehr, aber aus anderen Gr√ºnden. </p><br><p>  Die LEWG in K√∂ln w√§hlte weder <code>implicitly_create_objects[_as_needed]</code> noch <code>recycle_storage</code> als Namen f√ºr <code>std::bless</code> .  Sie beschlossen, diese Funktion √ºberhaupt nicht in den Standard aufzunehmen.  Der gleiche Effekt kann erzielt werden, indem explizit ein Array von Bytes erstellt wird. Daher wird die Funktion nicht ben√∂tigt.  Das gef√§llt mir nicht, weil der Aufruf von <code>std::recycle_storage()</code> besser lesbar w√§re.  Ein weiteres <code>std::bless()</code> existiert noch, hei√üt aber jetzt <code>start_lifetime_as</code> .  Das gef√§llt mir  Es sollte in C ++ 23 gehen. </p><br><p>  Nat√ºrlich wird <code>std::partial_sort_copy()</code> nicht mehr umbenannt - unter diesem Namen wurde es 1998 zum Standard. Aber zumindest wurde <code>std::log2p1</code> behoben, und das ist nicht schlecht. </p><br><p>  Wenn Sie die Namen von Funktionen festlegen, m√ºssen Sie dar√ºber nachdenken, wer sie verwenden wird und was er von ihnen will.  Wie Kate es ausdr√ºckte, <strong>erfordert das Benennen Einf√ºhlungsverm√∂gen</strong> . </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de484860/">https://habr.com/ru/post/de484860/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de484836/index.html">Berechnung der Rentabilit√§t aus dem Gr√ºnen Tarif 2020, Ukraine</a></li>
<li><a href="../de484838/index.html">13 Beispiele f√ºr das Einrichten von Regeln in Google Ads [Anleitung]</a></li>
<li><a href="../de484840/index.html">GOTO Return</a></li>
<li><a href="../de484846/index.html">Meine Beziehung zu Open Source</a></li>
<li><a href="../de484854/index.html">F√ºhren Sie das Spiel in C # unter MS-DOS aus</a></li>
<li><a href="../de484862/index.html">Migration von AngularJS nach Angular7 √ºber eine Hybridanwendung</a></li>
<li><a href="../de484866/index.html">Verwenden von Astra Linux auf einem ARM Embedded-Computer</a></li>
<li><a href="../de484868/index.html">Wie kann man die Teamverbesserung messen? Teil 2</a></li>
<li><a href="../de484870/index.html">Wie die Engl√§nder Ilona Mask seit 20 Jahren ver√§ndert haben</a></li>
<li><a href="../de484874/index.html">"Ihr IT-Spezialist ist kaputt, bringen Sie einen neuen": So bauen Sie eine Karriere in der IT auf und werden nicht verr√ºckt</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>