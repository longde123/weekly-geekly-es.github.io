<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üíö üëò üêé Sistema de trabajo. Resumen desde el otro lado üåº ü•• üë©üèª‚Äçüéì</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="En la nueva versi√≥n de unity en 2018, finalmente agregaron oficialmente el nuevo sistema de componentes Entity, o ECS para abreviar, que en lugar del ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Sistema de trabajo. Resumen desde el otro lado</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/420829/">  En la nueva versi√≥n de <b>unity en</b> 2018, finalmente agregaron oficialmente el nuevo <b>sistema de componentes Entity,</b> o <b>ECS para</b> abreviar, que en lugar del trabajo habitual con los componentes del objeto solo puede funcionar con sus datos. <br><br>  Un sistema de tareas adicional le ofrece el uso de potencia inform√°tica paralela para mejorar el rendimiento de su c√≥digo. <br><a name="habracut"></a><br>  Juntos, estos dos nuevos sistemas ( <b>ECS</b> y <b>Job System</b> ) ofrecen un nuevo nivel de procesamiento de datos. <br><br>  Espec√≠ficamente, en este art√≠culo no analizar√© todo el sistema <b>ECS</b> , que actualmente est√° disponible como un conjunto de herramientas descargadas por separado en la <b>unidad</b> , sino que solo considerar√© el sistema de tareas y c√≥mo se puede usar fuera del paquete <b>ECS</b> . <br><br><h3>  Nuevo sistema </h3><br>  Inicialmente, la <b>unidad</b> podr√≠a haber utilizado la computaci√≥n de subprocesos m√∫ltiples antes, pero todo esto tuvo que ser creado por el desarrollador por su cuenta, para resolver los problemas √©l mismo y sortear las dificultades.  Y si antes era necesario trabajar directamente con cosas como crear subprocesos, cerrar subprocesos, grupos, sincronizaci√≥n, ahora todo este trabajo reca√≠a en los hombros del motor, y el desarrollador solo necesitaba crear tareas y completarlas. <br><br><h3>  Las tareas </h3><br>  Para realizar cualquier c√°lculo en el nuevo sistema, es necesario utilizar tareas que son objetos que consisten en m√©todos y datos para el c√°lculo. <br><br>  Al igual que cualquier otro dato en el sistema <b>ECS</b> , las tareas en el <b>sistema de trabajo</b> tambi√©n se representan como estructuras que heredan una de las tres interfaces. <br><br><h4>  Trabajo </h4><br>  La interfaz de tareas m√°s simple que contiene un m√©todo <b>Execute</b> que no toma nada en forma de par√°metros y no devuelve nada. <br><br>  La tarea en s√≠ se ve as√≠: <br><br><div class="spoiler">  <b class="spoiler_title">Trabajo</b> <div class="spoiler_text"><pre><code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> struct JobStruct : IJob { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Execute() {} }</code> </pre> <br></div></div><br>  En el m√©todo <b>Ejecutar</b> , puede realizar los c√°lculos necesarios. <br><br><h4>  IJobParallelFor </h4><br>  Otra interfaz con el mismo m√©todo de <b>ejecuci√≥n</b> , que a su vez ya acepta el <b>√≠ndice de</b> par√°metro num√©rico. <br><br><div class="spoiler">  <b class="spoiler_title">IJobParallelFor</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> struct JobStruct : IJobParallelFor { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Execute(int index) {} }</code> </pre> <br></div></div><br>  Esta interfaz <b>IJobParallelFor</b> , a diferencia de la interfaz <b>IJob</b> , ofrece ejecutar una tarea varias veces y no solo ejecutarla, sino dividir esta ejecuci√≥n en bloques que se distribuir√°n entre subprocesos. <br><br>  <i>No est√° claro</i>  <i>No te preocupes por esto, te contar√© m√°s.</i> <br><br><h4>  IJobParallelForTransform </h4><br>  Y la √∫ltima interfaz especial, que, como su nombre lo indica, est√° dise√±ada para funcionar con estas transformaciones del objeto.  Tambi√©n contiene el m√©todo <b>Execute</b> , con el <b>√≠ndice del</b> par√°metro num√©rico y el par√°metro <b>TransformAccess</b> donde se ubican la posici√≥n, el tama√±o y la rotaci√≥n de la transformaci√≥n. <br><br><div class="spoiler">  <b class="spoiler_title">IJobParallelForTransform</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> struct JobStruct : IJobParallelForTransform { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Execute(int index, TransformAccess transform) {} }</code> </pre> <br></div></div><br>  Debido al hecho de que no puede trabajar con objetos de la <b>unidad</b> directamente en la tarea, esta interfaz solo puede procesar datos de transformaci√≥n como una estructura <b>TransformAccess</b> separada. <br><br>  Hecho, ahora que sabe c√≥mo se crean las estructuras de tareas, puede proceder a practicar. <br><br><h3>  Tarea completada </h3><br>  Vamos a crear una tarea simple heredada de la interfaz <b>IJob</b> y completarla.  Para esto necesitamos cualquier script <b>MonoBehaviour</b> simple y la estructura de la tarea misma. <br><br><div class="spoiler">  <b class="spoiler_title">Testjob</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TestJob</span></span></span><span class="hljs-class"> : </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MonoBehaviour</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Start() {} }</code> </pre> <br></div></div><br>  Ahora suelte este script en alg√∫n objeto en la escena.  En el mismo script ( <b>TestJob</b> ) a continuaci√≥n, escribiremos la estructura de la tarea y no olvidemos importar las bibliotecas necesarias. <br><br><div class="spoiler">  <b class="spoiler_title">Trabajo simple</b> <div class="spoiler_text"><pre> <code class="actionscript hljs">using Unity.Jobs; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> struct SimpleJob : IJob { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Execute() { Debug.Log(<span class="hljs-string"><span class="hljs-string">"Hello parallel world!"</span></span>); } }</code> </pre> <br></div></div><br>  En el m√©todo <b>Ejecutar</b> , por ejemplo, imprima una l√≠nea simple en la consola. <br><br>  Ahora pasemos al m√©todo <b>Start</b> del script <b>TestJob</b> , donde crearemos una instancia de la tarea y luego la ejecutaremos. <br><br><div class="spoiler">  <b class="spoiler_title">Testjob</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TestJob</span></span></span><span class="hljs-class"> : </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MonoBehaviour</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Start() { SimpleJob job = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SimpleJob(); job.Schedule().Complete(); } }</code> </pre> <br></div></div><br>  Si hiciste todo como en el ejemplo, luego de comenzar el juego recibir√°s un mensaje simple en la consola como en la imagen. <br><br><img src="https://lh6.googleusercontent.com/QQeMBMeZy0HVw0r_D5Q_cH4k6Zzt-HAC6uev1O4pR--mOh96C2TQvw5DTH1X3ZPE7LORJ4wdV5kyKjGiJzVWLFm-HBi8HzSP4-DlbrYa65eRV1RF672uwsLsZvrCKtF5CdaGJ5tj" alt="imagen"><br><br>  Lo que sucede aqu√≠: despu√©s de llamar al m√©todo <b>Schedule</b> , el planificador coloca la tarea en el controlador y ahora puede completarse llamando al m√©todo <b>Complete</b> . <br><br>  Este fue un ejemplo de una tarea que simplemente imprimi√≥ texto en la consola.  Para que una tarea realice c√°lculos paralelos, es necesario llenarla con datos. <br><br><h3>  Datos en la tarea </h3><br>  Al igual que en el sistema <b>ECS</b> , en las tareas no hay acceso a los objetos de la <b>unidad</b> , no puede obtener el <b>GameObject</b> en la tarea y cambiar su nombre all√≠.  Todo lo que puede hacer es transferir algunos par√°metros de objeto separados a la tarea, cambiar estos par√°metros y, despu√©s de completar la tarea, aplicar estos cambios nuevamente al objeto. <br><br>  Existen varias limitaciones en los datos de la tarea en s√≠: en primer lugar, deben ser estructuras y, en segundo lugar, no deben ser tipos de datos <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">convertibles</a> , es decir, no puede pasar el mismo <b>booleano</b> o <b>cadena</b> a la tarea. <br><br><div class="spoiler">  <b class="spoiler_title">Trabajo simple</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> struct SimpleJob : IJob { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> float a, b; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Execute() { float result = a + b; Debug.Log(result); } }</code> </pre> <br></div></div><br>  Y la condici√≥n principal: ¬°los datos no incluidos en un contenedor solo se pueden acceder dentro de la tarea! <br><br><h3>  Contenedores </h3><br>  Cuando se trabaja con computaci√≥n de subprocesos m√∫ltiples, es necesario intercambiar datos de alguna manera entre subprocesos.  Para poder transferir datos a ellos y volver a leerlos en el sistema de tareas, para estos fines hay contenedores.  Estos contenedores se presentan en forma de estructuras ordinarias y trabajo seg√∫n el principio de un puente mediante el cual los datos elementales se sincronizan entre flujos. <br><br>  Existen varios tipos de contenedores: <br>  <b>NativeArray</b> .  El tipo de contenedor m√°s simple y m√°s utilizado se presenta como una matriz simple con un tama√±o fijo. <br>  <b>NativeSlice</b> .  Otro contenedor, una matriz, como se desprende de la traducci√≥n, est√° dise√±ada para cortar el NativeArray en pedazos. <br><br>  Estos son los dos contenedores principales disponibles sin conectar un sistema <b>ECS</b> .  En una versi√≥n m√°s avanzada, hay varios tipos de contenedores. <br><br>  <b>NativeList</b> .  Es una lista regular de datos. <br>  <b>NativeHashMap</b> .  Un an√°logo de un diccionario con una clave y un valor. <br>  <b>NativeMultiHashMap</b> .  El mismo <b>NativeHashMap</b> con solo unos pocos valores bajo una clave. <br>  <b>NativeQueue</b>  Lista de colas de datos. <br><br>  Como trabajamos sin conectar un sistema <b>ECS</b> , solo <b>NativeArray</b> y <b>NativeSlice</b> est√°n disponibles para <b>nosotros</b> . <br><br>  Antes de pasar a la parte pr√°ctica, es necesario analizar el punto m√°s importante: la creaci√≥n de instancias. <br><br><h3>  Crear contenedores </h3><br>  Como dije antes, estos contenedores representan un puente sobre el cual los datos se sincronizan entre hilos.  El sistema de tareas abre este puente antes de comenzar a trabajar y lo cierra despu√©s de su finalizaci√≥n.  El proceso de apertura se llama " <i>asignaci√≥n</i> " ( <b>asignaci√≥n</b> ) o <i>"asignaci√≥n de memoria"</i> , el proceso de cierre se llama " <i>liberaci√≥n de recursos</i> " ( <b>desechar</b> ). <br><br>  Es la asignaci√≥n la que determina cu√°nto tiempo la tarea puede usar los datos en el contenedor; en otras palabras, cu√°nto tiempo estar√° abierto el puente. <br><br>  Para comprender mejor estos dos procesos, echemos un vistazo a la imagen a continuaci√≥n. <br><br><img src="https://lh4.googleusercontent.com/6yL2x_ynGZj1C1ukkQlfDZuYKzlvJ4ceAYU9Zyb40xwDzuASeUNB__Od067_3xZkYANEOPl84JoKLyqTPn4hrvQNogbksb7akoQvcWjDLg2yyUJY9eF37uj7TO0YkOL3cQyMsXPu" alt="imagen"><br><br>  La parte inferior muestra el ciclo de vida del hilo principal (hilo <b>principal</b> ), que se calcula en el n√∫mero de cuadros; en el primer cuadro, creamos otro hilo paralelo ( <b>hilo nuevo)</b> que existe para un cierto n√∫mero de cuadros y luego se cierra de forma segura. <br>  En el mismo <b>hilo nuevo</b> llega <b>la</b> tarea con el contenedor. <br><br>  Ahora mire la parte superior de la imagen. <br><br><img src="https://lh5.googleusercontent.com/1IZ_CMZhX4JfBWBLEuAijf1st_6e7p96EncPomR_jLNhQVbJDvS_o_-gf1emw3glwEGt8y3xXARp4xJJ9qu0WjYTH4asrblwul2rHa_SqQiLzrTTOoDJ5DlomcPBP8qkfCI3w9R8" alt="imagen"><br><br>  La barra blanca <b>Asignaci√≥n</b> muestra la vida √∫til del contenedor.  En el primer cuadro, se <i>asigna</i> el contenedor: el puente se abre, hasta este momento el contenedor no exist√≠a, despu√©s de que se hayan completado todos los c√°lculos en la tarea, el contenedor se libera de la memoria y en el noveno cuadro se cierra el puente. <br><br>  Tambi√©n en esta tira ( <b>Asignaci√≥n</b> ) hay segmentos de tiempo ( <b>Temp</b> , <b>TempJob</b> y <b>Presistent</b> ), cada uno de estos segmentos muestra la vida √∫til estimada del contenedor. <br><br>  ¬øPor qu√© se necesitan estos segmentos?  El hecho es que la ejecuci√≥n de una tarea por duraci√≥n puede ser diferente, podemos ejecutarla directamente en el mismo m√©todo donde la creamos, o podemos extender el tiempo de ejecuci√≥n de la tarea si es bastante complicada, y estos segmentos muestran qu√© tan urgente y cu√°nto tiempo la tarea puede usar los datos en el contenedor <br><br>  <i>Si a√∫n no est√° claro, analizar√© cada tipo de asignaci√≥n utilizando un ejemplo.</i> <br><br>  Ahora podemos pasar a la parte pr√°ctica de crear contenedores, para esto volvemos al m√©todo <b>Start</b> del script <b>TestJob</b> y creamos una nueva instancia del contenedor <b>NativeArray</b> y no nos olvidamos de conectar las bibliotecas necesarias. <br><br><h3>  Temp </h3><br><div class="spoiler">  <b class="spoiler_title">Testjob</b> <div class="spoiler_text"><pre> <code class="actionscript hljs">using Unity.Jobs; using Unity.Collections; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TestJob</span></span></span><span class="hljs-class"> : </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MonoBehaviour</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Start() { NativeArray&lt;int&gt; array = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> NativeArray&lt;int&gt;(<span class="hljs-number"><span class="hljs-number">10</span></span>, Allocator.Temp); } }</code> </pre> <br></div></div><br>  Para crear una nueva instancia de contenedor, debe especificar el tama√±o y el tipo de asignaci√≥n en su constructor.  Este ejemplo usa el tipo <b>Temp</b> , ya que la tarea se realizar√° solo en el m√©todo <b>Start</b> . <br><br>  Ahora inicialice exactamente la misma variable de matriz en la estructura de la tarea <b>SimpleJob</b> . <br><br><div class="spoiler">  <b class="spoiler_title">Trabajo simple</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> struct SimpleJob : IJob { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> NativeArray&lt;int&gt; array; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Execute() {} }</code> </pre> <br></div></div><br>  Listo  Ahora puede crear la tarea en s√≠ misma y pasarle una instancia de matriz. <br><br><div class="spoiler">  <b class="spoiler_title">Inicio</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Start() { NativeArray&lt;int&gt; array = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> NativeArray&lt;int&gt;(<span class="hljs-number"><span class="hljs-number">10</span></span>, Allocator.Temp); SimpleJob job = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SimpleJob(); job.array = array; }</code> </pre> <br></div></div><br>  Para ejecutar la tarea esta vez, utilizaremos su identificador <b>JobHandle</b> para obtenerla llamando al mismo m√©todo <b>Schedule</b> . <br><br><div class="spoiler">  <b class="spoiler_title">Inicio</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Start() { NativeArray&lt;int&gt; array = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> NativeArray&lt;int&gt;(<span class="hljs-number"><span class="hljs-number">10</span></span>, Allocator.Temp); SimpleJob job = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SimpleJob(); job.array = array; JobHandle handle = job.Schedule(); }</code> </pre> <br></div></div><br>  Ahora puede llamar al m√©todo <b>Completo</b> en su identificador y verificar si la tarea se ha completado para mostrar el texto en la consola. <br><br><div class="spoiler">  <b class="spoiler_title">Inicio</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Start() { NativeArray&lt;int&gt; array = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> NativeArray&lt;int&gt;(<span class="hljs-number"><span class="hljs-number">10</span></span>, Allocator.Temp); SimpleJob job = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SimpleJob(); job.array = array; JobHandle handle = job.Schedule(); handle.Complete(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (handle.IsCompleted) print(<span class="hljs-string"><span class="hljs-string">" "</span></span>); }</code> </pre> <br></div></div><br>  Si ejecuta la tarea de esta forma, luego de comenzar el juego obtendr√° un error rojo que dice que no liber√≥ el contenedor de matriz de los recursos despu√©s de que se complet√≥ la tarea. <br><br>  Algo asi. <br><br><img src="https://lh3.googleusercontent.com/EewKhLiPm0_qidpB0-YnlUfbTcIlzOhPw_OXgJqcmm-m9MpAaq96PHSc-FlN7GNArl9JkThBUZEGM9YFIHR5BkkMRUBwTAM6awQAEYGOw45i31irFlXtkT7peTOmjFfoEq_ASONA" alt="imagen"><br><br>  Para evitar esto, llame al m√©todo <b>Dispose</b> en el contenedor despu√©s de completar la tarea. <br><br><div class="spoiler">  <b class="spoiler_title">Inicio</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Start() { NativeArray&lt;int&gt; array = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> NativeArray&lt;int&gt;(<span class="hljs-number"><span class="hljs-number">10</span></span>, Allocator.Temp); SimpleJob job = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SimpleJob(); job.array = array; JobHandle handle = job.Schedule(); handle.Complete(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (handle.IsCompleted) print(<span class="hljs-string"><span class="hljs-string">"Complete"</span></span>); array.Dispose(); }</code> </pre> <br></div></div><br>  Entonces puede reiniciarlo de forma segura. <br>  ¬°Pero la tarea no hace nada!  - luego agregue un par de acciones. <br><br><div class="spoiler">  <b class="spoiler_title">Trabajo simple</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> struct SimpleJob : IJob { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> NativeArray&lt;int&gt; array; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Execute() { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(int i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; array.Length; i++) { array[i] = i * i; } } }</code> </pre> <br></div></div><br>  En el m√©todo <b>Ejecutar</b> , multiplico el √≠ndice de cada elemento de la matriz por m√≠ mismo y lo escribo de nuevo en la matriz de la <b>matriz</b> para imprimir el resultado en la consola en el m√©todo de <b>Inicio</b> . <br><br><div class="spoiler">  <b class="spoiler_title">Inicio</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Start() { NativeArray&lt;int&gt; array = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> NativeArray&lt;int&gt;(<span class="hljs-number"><span class="hljs-number">10</span></span>, Allocator.Temp); SimpleJob job = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SimpleJob(); job.array = array; JobHandle handle = job.Schedule(); handle.Complete(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (handle.IsCompleted) print(job.array[job.array.Length - <span class="hljs-number"><span class="hljs-number">1</span></span>]); array.Dispose(); }</code> </pre> <br></div></div><br><blockquote>  ¬øCu√°l ser√° el resultado en la consola si imprimimos el √∫ltimo elemento de la matriz al cuadrado? </blockquote><br>  As√≠ es como puede crear contenedores, ponerlos en tareas y realizar acciones en ellos. <br><br>  Este fue un ejemplo utilizando el tipo de asignaci√≥n <b>Temp</b> , lo que implica completar una tarea dentro de un marco.  Este tipo se utiliza mejor cuando necesita realizar c√°lculos r√°pidamente sin cargar el subproceso principal, pero debe tener cuidado si la tarea es demasiado complicada o si habr√° muchos de ellos, puede producirse una ca√≠da, en este caso es mejor usar el tipo <b>TempJob,</b> que analizar√© m√°s adelante. <br><br><h3>  Trabajo temporal </h3><br>  En este ejemplo, <b>modificar√©</b> ligeramente <b>la</b> estructura de la tarea <b>SimpleJob</b> y la heredar√© de otra interfaz <b>IJobParallelFor</b> . <br><br><div class="spoiler">  <b class="spoiler_title">Trabajo simple</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> struct SimpleJob : IJobParallelFor { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> NativeArray&lt;Vector2&gt; array; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Execute(int index) {} }</code> </pre> <br></div></div><br>  Adem√°s, dado que la tarea durar√° m√°s de un fotograma, ejecutaremos y recopilaremos los resultados de la tarea en diferentes m√©todos <b>Despertar</b> e <b>Iniciar</b> presentados en forma de rutina.  Para hacer esto, cambie un <b>poco</b> la apariencia de la clase <b>TestJob</b> . <br><br><div class="spoiler">  <b class="spoiler_title">Testjob</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TestJob</span></span></span><span class="hljs-class"> : </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MonoBehaviour</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> NativeArray&lt;Vector2&gt; array; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> JobHandle handle; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Awake() {} IEnumerator Start() {} }</code> </pre> <br></div></div><br>  En el m√©todo <b>Despertar</b> , crearemos una tarea y un contenedor de vectores, y en el m√©todo <b>Inicio</b> , enviaremos los datos recibidos y liberaremos recursos. <br><br><div class="spoiler">  <b class="spoiler_title">Despierto</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Awake() { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.array = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> NativeArray&lt;Vector2&gt;(<span class="hljs-number"><span class="hljs-number">100</span></span>, Allocator.TempJob); SimpleJob job = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SimpleJob(); job.array = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.array; }</code> </pre> <br></div></div><br>  Una vez m√°s, se crea un contenedor de <b>matriz</b> con el tipo de asignaci√≥n <b>TempJob</b> , despu√©s de lo cual creamos una tarea y obtenemos su manejo llamando al m√©todo <b>Schedule</b> con cambios menores. <br><br><div class="spoiler">  <b class="spoiler_title">Despierto</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Awake() { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.array = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> NativeArray&lt;Vector2&gt;(<span class="hljs-number"><span class="hljs-number">100</span></span>, Allocator.TempJob); SimpleJob job = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SimpleJob(); job.array = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.array; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.handle = job.Schedule(<span class="hljs-number"><span class="hljs-number">100</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>) }</code> </pre> <br></div></div><br>  El primer par√°metro en el m√©todo <b>Schedule</b> indica cu√°ntas veces se ejecutar√° la tarea, aqu√≠ est√° el mismo n√∫mero que el tama√±o de la matriz de <b>matriz</b> . <br>  El segundo par√°metro indica cu√°ntos bloques compartir la tarea. <br><br>  <i>¬øQu√© otros bloques?</i> <br>  Anteriormente, para completar una tarea, un subproceso simplemente llamaba al m√©todo <b>Execute</b> una vez, ahora es necesario llamar a este m√©todo 100 veces, por lo que el planificador divide estas 100 veces de repeticiones en bloques que distribuye entre los subprocesos para no cargar ning√∫n subproceso separado.  En el ejemplo, cien repeticiones se dividir√°n en 5 bloques de 20 repeticiones cada una, es decir, el programador presumiblemente distribuir√° estos 5 bloques en 5 hilos, donde cada hilo llamar√° al m√©todo <b>Ejecutar</b> 20 veces.  En la pr√°ctica, por supuesto, no es un hecho que el planificador haga exactamente eso, todo depende de la carga de trabajo del sistema, por lo que tal vez las 100 repeticiones sucedan en un hilo. <br><br>  Ahora puede llamar al m√©todo <b>Completo</b> en el controlador de tareas. <br><br><div class="spoiler">  <b class="spoiler_title">Despierto</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Awake() { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.array = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> NativeArray&lt;Vector2&gt;(<span class="hljs-number"><span class="hljs-number">100</span></span>, Allocator.TempJob); SimpleJob job = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SimpleJob(); job.array = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.array; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.handle = job.Schedule(<span class="hljs-number"><span class="hljs-number">100</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.handle.Complete(); }</code> </pre> <br></div></div><br>  En la rutina de <b>Inicio</b> , verificaremos la ejecuci√≥n de la tarea y luego limpiaremos el contenedor. <br><br><div class="spoiler">  <b class="spoiler_title">Inicio</b> <div class="spoiler_text"><pre> <code class="actionscript hljs">IEnumerator Start() { <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.handle.isCompleted == <span class="hljs-literal"><span class="hljs-literal">false</span></span>){ yield <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> WaitForEndOfFrame(); } <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.array.Dispose(); }</code> </pre> <br></div></div><br>  Ahora pasemos a las acciones en la tarea misma. <br><br><div class="spoiler">  <b class="spoiler_title">Trabajo simple</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> struct SimpleJob : IJobParallelFor { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> NativeArray&lt;Vector2&gt; array; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Execute(int index) { float x = index; float y = index; Vector2 vector = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(x * x, y * y / (y * <span class="hljs-number"><span class="hljs-number">2</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.array[index] = vector; } }</code> </pre> <br></div></div><br>  Despu√©s de completar la tarea en el m√©todo de <b>Inicio</b> , muestre todos los elementos de la matriz en la consola. <br><br><div class="spoiler">  <b class="spoiler_title">Inicio</b> <div class="spoiler_text"><pre> <code class="actionscript hljs">IEnumerator Start() { <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.handle.IsCompleted == <span class="hljs-literal"><span class="hljs-literal">false</span></span>){ yield <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> WaitForEndOfFrame(); } foreach(Vector2 vector <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.array) { print(vector); } <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.array.Dispose(); }</code> </pre> <br></div></div><br>  Listo, puedes correr y mirar el resultado. <br><br>  Para comprender la diferencia entre <b>IJob</b> e <b>IJobParallelFor,</b> eche un vistazo a las im√°genes a continuaci√≥n. <br>  Por ejemplo, <b>IJob</b> tambi√©n puede usar un bucle simple <b>para</b> realizar c√°lculos varias veces, pero en cualquier caso, un hilo solo puede llamar al m√©todo <b>Ejecutar</b> una vez durante toda la tarea: as√≠ es como hacer que una persona realice cientos de las mismas acciones seguidas. <br><br><img src="https://lh3.googleusercontent.com/qUadSqRojz1W8kiqtm-xgi-TYeJ9IlVh38o0MrG0mTWnU3j0qTjtTOWa8pkPc0kjPQcTKoqOJtNl6E4Olb5MKCNgUhrsAXGujN0flm_YVoFfEVS9kCCjFOucANAw74Kjq2W_Zzho" alt="imagen"><br><br>  <b>IJobParallelFor</b> ofrece no solo ejecutar una tarea en un hilo varias veces, sino tambi√©n distribuir estas repeticiones entre otros hilos. <br><br><img src="https://lh5.googleusercontent.com/-5ggH4tUKWvhz6I8UUi2eGzqY_B_QqA1PA_298vp89xg4v2yC3wn3N9D8TlVOMwWuDM593H_Aw9WZOU-_esyT7vyL4MM17bZaevfiOiYSEUb0I1oT2Fi3cXbBtoc9SuMYIhVnMc7" alt="imagen"><br><br>  En general, el tipo de asignaci√≥n <b>TempJob es</b> perfecto para la mayor√≠a de las tareas que se realizan en varios marcos. <br><br>  Pero, ¬øqu√© sucede si necesita almacenar datos incluso despu√©s de completar una tarea? ¬øQu√© sucede si despu√©s de recibir el resultado no necesita destruirlo de inmediato?  Para esto, es necesario usar el tipo de asignaci√≥n <b>Persistente</b> , lo que implica la liberaci√≥n de recursos y luego " <i>cuando sea necesario".</i>  . <br><br><h3>  Persistente </h3><br>  <b>Volvamos</b> a la clase <b>TestJob</b> y c√°mbiela.  Ahora crearemos tareas en el m√©todo <b>OnEnable</b> , verificaremos su ejecuci√≥n en el m√©todo <b>Actualizar</b> y <b>limpiaremos</b> los recursos en el m√©todo <b>OnDisable</b> . <br>  En el ejemplo, moveremos el objeto en el m√©todo <b>Actualizar</b> , para calcular la trayectoria usaremos dos contenedores de vectores: <b>inputArray</b> en el que <b>colocaremos</b> la posici√≥n actual y <b>outputArray</b> desde donde recibiremos los resultados. <br><br><div class="spoiler">  <b class="spoiler_title">Testjob</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TestJob</span></span></span><span class="hljs-class"> : </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MonoBehaviour</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> NativeArray&lt;Vector2&gt; inputArray; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> NativeArray&lt;Vector2&gt; outputArray; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> JobHandle handle; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> OnEnable() {} <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Update() {} <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> OnDisable() {} }</code> </pre> <br></div></div><br>  Tambi√©n <b>modificaremos</b> ligeramente <b>la</b> estructura de la tarea <b>SimpleJob</b> al heredarla de la interfaz <b>IJob</b> para ejecutarla una vez. <br><br><div class="spoiler">  <b class="spoiler_title">Trabajo simple</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> struct SimpleJob : IJob { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Execute() {} }</code> </pre> <br></div></div><br>  En la tarea misma, tambi√©n traicionaremos dos contenedores de vectores, un vector de posici√≥n y un delta num√©rico, que mover√°n el objeto al objetivo. <br><br><div class="spoiler">  <b class="spoiler_title">Trabajo simple</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> struct SimpleJob : IJob { [ReadOnly] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> NativeArray&lt;Vector2&gt; inputArray; [WriteOnly] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> NativeArray&lt;Vector2&gt; outputArray; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Vector2 position; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> float delta; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Execute() {} }</code> </pre> <br></div></div><br>  Los atributos <b>ReadOnly</b> y <b>WriteOnly</b> muestran las restricciones de flujo en las acciones asociadas con los datos dentro de los contenedores.  <b>ReadOnly</b> ofrece la secuencia solo para leer datos del contenedor, el atributo <b>WriteOnly</b> , por el contrario, permite que la secuencia solo escriba datos en el contenedor.  Si necesita realizar estas dos acciones a la vez con un contenedor, no necesita marcarlo con un atributo. <br><br>  Pasemos al m√©todo <b>OnEnable</b> de la clase <b>TestJob</b> donde se inicializar√°n los contenedores. <br><br><div class="spoiler">  <b class="spoiler_title">Onenable</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> OnEnable() { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.inputArray = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> NativeArray&lt;Vector2&gt;(<span class="hljs-number"><span class="hljs-number">1</span></span>, Allocator.Persistent); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.outputArray = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> NativeArray&lt;Vector2&gt;(<span class="hljs-number"><span class="hljs-number">1</span></span>, Allocator.Persistent); }</code> </pre> <br></div></div><br>  Las dimensiones de los contenedores ser√°n √∫nicas ya que es necesario transmitir y recibir par√°metros solo una vez.  El tipo de asignaci√≥n ser√° <b>persistente</b> . <br>  En el m√©todo <b>OnDisable</b> , <b>liberaremos</b> los recursos de los contenedores. <br><br><div class="spoiler">  <b class="spoiler_title">Ondisable</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> OnDisable() { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.inputArray.Dispose(); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.outputArray.Dispose(); }</code> </pre> <br></div></div><br>  <b>Creemos un</b> m√©todo <b>CreateJob</b> separado donde crearemos una tarea con su identificador y all√≠ la <b>llenaremos</b> con datos. <br><br><div class="spoiler">  <b class="spoiler_title">CreateJob</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> CreateJob() { SimpleJob job = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SimpleJob(); job.delta = Time.deltaTime; Vector2 position = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.transform.position; job.position = position; Vector2 newPosition = position + Vector2.right; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.inputArray[<span class="hljs-number"><span class="hljs-number">0</span></span>] = newPosition; job.inputArray = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.inputArray; job.outputArray = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.outputArray; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.handle = job.Schedule(); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.handle.Complete(); }</code> </pre> <br></div></div><br>  <i>En realidad, <b>inputArray</b> no es realmente necesario aqu√≠, ya que es posible transferir un vector de direcci√≥n solo a la tarea, pero creo que ser√° mejor entender por qu√© estos atributos <b>ReadOnly</b> y <b>WriteOnly</b> son necesarios.</i> <br><br>  En el m√©todo de <b>actualizaci√≥n</b> , comprobaremos si la tarea se ha completado, despu√©s de lo cual aplicaremos el resultado obtenido a la transformaci√≥n del objeto y lo ejecutaremos nuevamente. <br><br><div class="spoiler">  <b class="spoiler_title">Actualizaci√≥n</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Update() { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.handle.IsCompleted) { Vector2 newPosition = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.outputArray[<span class="hljs-number"><span class="hljs-number">0</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.transform.position = newPosition; CreateJob(); } }</code> </pre> <br></div></div><br>  Antes de comenzar, modificaremos ligeramente el m√©todo <b>OnEnable</b> para que la tarea se cree inmediatamente despu√©s de que se inicialicen los contenedores. <br><br><div class="spoiler">  <b class="spoiler_title">Onenable</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> OnEnable() { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.inputArray = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> NativeArray&lt;Vector2&gt;(<span class="hljs-number"><span class="hljs-number">1</span></span>, Allocator.Persistent); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.outputArray = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> NativeArray&lt;Vector2&gt;(<span class="hljs-number"><span class="hljs-number">1</span></span>, Allocator.Persistent); CreateJob(); }</code> </pre> <br></div></div><br>  Hecho, ahora puede ir a la tarea misma y realizar los c√°lculos necesarios en el m√©todo <b>Ejecutar</b> . <br><br><div class="spoiler">  <b class="spoiler_title">Ejecutar</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Execute() { Vector2 newPosition = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.inputArray[<span class="hljs-number"><span class="hljs-number">0</span></span>]; newPosition = Vector2.Lerp(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.position, newPosition, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.delta); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.outputArray[<span class="hljs-number"><span class="hljs-number">0</span></span>] = newPosition; }</code> </pre> <br></div></div><br>  Para ver el resultado del trabajo, puede lanzar el script <b>TestJob</b> en alg√∫n objeto y ejecutar el juego. <br><br>  Por ejemplo, mi sprite se desplaza gradualmente hacia la derecha. <br><br><div class="spoiler">  <b class="spoiler_title">Animaci√≥n</b> <div class="spoiler_text"><img src="https://lh3.googleusercontent.com/YCf68msYSI0w6ARjOAeAWsPPhpPOrXC-3jWTfqtlnu1pS1xa9m6FCjTD3DdvcvWi5KSEh_-q6X2yUf62j1FOgSU6d0plX603FOQiydF-yLRQFvbd2YBY-mp8I5p5V4cQH9t7SKPR" alt="imagen"><br></div></div><br>  En general, el tipo de asignaci√≥n <b>Persistente es</b> ideal para contenedores reutilizables que no necesitan ser destruidos y recreados cada vez. <br><br>  <i>Entonces, ¬øqu√© tipo usar?</i> <br>  El tipo <b>Temp</b> se usa mejor para realizar c√°lculos r√°pidamente, pero si la tarea es demasiado compleja y grande, puede producirse una holgura. <br>  El tipo <b>TempJob es</b> ideal para trabajar con objetos de <b>unidad</b> , por lo que puede cambiar los par√°metros de los objetos y aplicarlos, por ejemplo, en el siguiente cuadro. <br>  El tipo <b>Persistente</b> se puede usar cuando la velocidad no es importante para usted, pero solo necesita calcular constantemente alg√∫n tipo de datos adicionales, por ejemplo, procesar datos a trav√©s de una red o el trabajo de una IA. <br><br><div class="spoiler">  <b class="spoiler_title">Inv√°lido y ninguno</b> <div class="spoiler_text">  <i>Hay dos tipos m√°s de asignaci√≥n <b>no v√°lidos</b> y <b>ninguno</b> , pero se necesitan m√°s para la depuraci√≥n y no participan en el trabajo.</i> <br></div></div><br><br><h3>  Jobhandle </h3><br>  Por separado, vale la pena analizar las capacidades del manejador de tareas, porque adem√°s de verificar el proceso de ejecuci√≥n de tareas, este peque√±o manejador a√∫n puede crear redes enteras de tareas a trav√©s de dependencias (aunque prefiero llamarlas m√°s colas). <br><br>  Por ejemplo, si necesita realizar dos tareas en una secuencia determinada, para esto solo necesita adjuntar el identificador de una tarea al identificador de otra. <br><br>  Se ve algo como esto. <br><br><img src="https://lh3.googleusercontent.com/K62BSMljveR8lED8wCuCUCuLN6zyNlXS8RQybQuztrT_FMalHHSP7oMGIDf6xUcjXAMqRG3njvHIJ4FPL_tU1uSZr5XQDmCOPyM_YJye2i_z58lIPAkflcia511L2ILI72In61aT" alt="imagen"><br><br>  Cada identificador individual contiene inicialmente su propia tarea, pero cuando se combinan, obtenemos un nuevo identificador con dos tareas. <br><br><div class="spoiler">  <b class="spoiler_title">Inicio</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Start() { Job jobA = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Job(); JobHandle handleA = jobA.Schedule(); Job jobB = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Job(); JobHandle handleB = jobB.Schedule(); JobHandle result = JobHandle.CombineDependecies(handleA, handleB); result.Complete(); }</code> </pre> <br></div></div><br>  O eso. <br><br><div class="spoiler">  <b class="spoiler_title">Inicio</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Start() { JobHandle handle; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(int i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">10</span></span>; i++) { Job job = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Job(); handle = job.Schedule(handle); } handle.Complete(); }</code> </pre> <br></div></div><br>  La secuencia de ejecuci√≥n se guarda y el planificador no iniciar√° la siguiente tarea hasta que est√© convencido de la anterior, pero es importante recordar que la propiedad del <b>controlador</b> IsCompleted esperar√° a que se completen todas las tareas. <br><br><h2>  Conclusi√≥n </h2><br><h3>  Contenedores </h3><br><ol><li>  Cuando trabaje con datos en contenedores, no olvide que se trata de estructuras, por lo que cualquier sobrescritura de datos en el contenedor no los cambia, sino que los crea de nuevo. </li><li>  <i>¬øQu√© sucede si establece el tipo de asignaci√≥n Temp y no borra los recursos despu√©s de completar la tarea?</i>  El error </li><li>  <i>¬øPuedo crear mis propios contenedores?</i>  Es posible que las unidades describan en detalle <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">el</a> proceso de creaci√≥n de contenedores personalizados aqu√≠, pero es mejor pensar algunas veces: ¬øvale la pena, tal vez habr√° suficientes contenedores normales? </li></ol><br><h4>  Seguridad! </h4><br>  <i>Datos est√°ticos</i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">No intente utilizar datos est√°ticos en una tarea ( </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aleatorio</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> y otros), cualquier acceso a datos est√°ticos violar√° la seguridad del sistema. En realidad, en este momento puede acceder a datos est√°ticos, pero solo si est√° seguro de que no cambian durante el trabajo, es decir, son completamente est√°ticos y de solo lectura. </font></font><br><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¬øCu√°ndo usar el sistema de tareas?</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Todos estos ejemplos que se dan aqu√≠ en el art√≠culo son solo condicionales y muestran c√≥mo trabajar con este sistema, y ‚Äã‚Äãno cu√°ndo usarlo. El sistema de tareas se puede usar sin </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ECS,</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">debe comprender que el sistema tambi√©n consume recursos en el trabajo y que, por cualquier motivo, escribir tareas de inmediato, crear montones de contenedores simplemente no tiene sentido: todo empeorar√° a√∫n m√°s. Por ejemplo, volver a calcular una matriz de 10 mil elementos de tama√±o no ser√° correcto: le llevar√° m√°s tiempo trabajar como programador, pero recalcular todos los pol√≠gonos de un gran terreno o incluso generarlo es la soluci√≥n correcta, puede dividir el terreno en tareas y procesar cada uno en una secuencia separada. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En general, si participa constantemente en c√°lculos complejos en proyectos y busca constantemente nuevas oportunidades para hacer que este proceso sea menos intensivo en recursos, entonces </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Job System</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Esto es exactamente lo que necesitas. </font><font style="vertical-align: inherit;">Si trabajas constantemente con c√°lculos complejos inseparables de los objetos y quieres que tu c√≥digo funcione m√°s r√°pido y sea compatible con la mayor√≠a de las plataformas, entonces </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ECS</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> definitivamente te ayudar√° con esto. </font><font style="vertical-align: inherit;">Si crea proyectos solo para </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">WebGL,</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> entonces esto no es para usted, en este momento </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Job System</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> no admite trabajar en navegadores, aunque esto no es un problema para unitecs, sino para los desarrolladores de navegadores. </font></font><br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://www.google.com/url%3Fq%3D"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fuente con todos los ejemplos</font></font></a> <cut></cut></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es420829/">https://habr.com/ru/post/es420829/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es420815/index.html">C√≥mo "decodificar el mundo digital" hizo volar la sala: los 10 mejores informes de DotNext 2018 Piter</a></li>
<li><a href="../es420819/index.html">Las 10 mejores herramientas de Python para aprendizaje autom√°tico y ciencia de datos</a></li>
<li><a href="../es420821/index.html">Regla 10: 1 en programaci√≥n y escritura</a></li>
<li><a href="../es420825/index.html">Hoy ser√° el primer partido entre los profesionales de OpenAI y Dota 2 (la gente gan√≥). Entendemos c√≥mo funciona el bot</a></li>
<li><a href="../es420827/index.html">Cree un proyecto maven simple utilizando Java EE + WildFly10 + JPA (Hibernate) + Postgresql + EJB + IntelliJ IDEA</a></li>
<li><a href="../es420831/index.html">El dispositivo para la emisi√≥n de cookies "Cook 3000"</a></li>
<li><a href="../es420833/index.html">Errores importantes de monetizaci√≥n de aplicaciones [y c√≥mo solucionarlos]</a></li>
<li><a href="../es420837/index.html">Prueba de matrices RAID de software para dispositivos NVMe utilizando la metodolog√≠a SNIA</a></li>
<li><a href="../es420841/index.html">Revisi√≥n prehospitalaria o "¬°Hola, Swagger! ¬øD√≥nde est√°n mis errores?</a></li>
<li><a href="../es420843/index.html">7 de septiembre, Ekaterimburgo: una reuni√≥n para desarrolladores de .NET</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>