<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë≤üèΩ üé© üë©üèª‚Äçüåæ Travail de type s√©curis√© avec des registres sans surcharge en C ++ 17: m√©taprogrammation bas√©e sur les valeurs üìÄ üì∏ üê§</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="C ++, en raison de son typage strict, peut aider le programmeur au stade de la compilation. Il y a d√©j√† beaucoup d'articles sur le hub qui d√©crivent c...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Travail de type s√©curis√© avec des registres sans surcharge en C ++ 17: m√©taprogrammation bas√©e sur les valeurs</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/483378/"><p>  C ++, en raison de son typage strict, peut aider le programmeur au stade de la compilation.  Il y a d√©j√† beaucoup d'articles sur le hub qui d√©crivent comment, en utilisant des types, pour y parvenir, et c'est tr√®s bien.  Mais dans tout ce que j'ai lu, il y a un d√©faut.  Comparez avec l'approche ++ et l'approche C en utilisant CMSIS, qui est familier dans le monde de la programmation des microcontr√¥leurs: </p><br><pre><code class="cpp hljs">some_stream.<span class="hljs-built_in"><span class="hljs-built_in">set</span></span> (Direction::to_periph) SOME_STREAM-&gt;CR |= DMA_SxCR_DIR_0 .inc_memory() | DMA_SxCR_MINC_Msk .size_memory (DataSize::word16) | DMA_SxCR_MSIZE_0 .size_periph (DataSize::word16) | DMA_SxCR_PSIZE_0 .enable_transfer_complete_interrupt(); | DMA_SxCR_TCIE_Msk;</code> </pre> <br><p>  Il est imm√©diatement √©vident que l'approche C ++ est plus lisible, et comme chaque fonction prend un type sp√©cifique, on ne peut pas se tromper.  L'approche C ne v√©rifie pas la validit√© des donn√©es, elle appartient au programmeur.  En r√®gle g√©n√©rale, une erreur n'est reconnue que lors du d√©bogage.  Mais l'approche c ++ n'est pas gratuite.  En fait, chaque fonction a son propre acc√®s au registre, tandis qu'en C le masque est d'abord collect√© √† partir de tous les param√®tres au stade de la compilation, car ce sont toutes des constantes, et sont √©crites dans le registre √† la fois.  Ensuite, je vais d√©crire comment j'ai essay√© de combiner la s√©curit√© de type avec ++ avec la minimisation de l'acc√®s aux cas.  Vous verrez que c'est beaucoup plus simple qu'il n'y para√Æt. </p><a name="habracut"></a><br><p>  Je vais d'abord donner un exemple de la fa√ßon dont j'aimerais qu'il ressemble.  Il est souhaitable que cela ne diff√®re pas beaucoup de l'approche C ++ d√©j√† famili√®re. </p><br><pre> <code class="cpp hljs">some_stream.<span class="hljs-built_in"><span class="hljs-built_in">set</span></span>( dma_stream::direction::to_periph , dma_stream::inc_memory , dma_stream::memory_size::byte16 , dma_stream::periph_size::byte16 , dma_stream::transfer_complete_interrupt::enable );</code> </pre> <br><p>  Chaque param√®tre de la m√©thode set est un type distinct par lequel vous pouvez comprendre dans quel registre vous souhaitez √©crire la valeur, ce qui signifie que lors de la compilation, vous pouvez optimiser l'acc√®s aux registres.  La m√©thode est variadique, donc il peut y avoir n'importe quel nombre d'arguments, mais il doit y avoir une v√©rification que tous les arguments appartiennent √† cette p√©riph√©rie. </p><br><p>  Plus t√¥t, cette t√¢che m'a sembl√© plut√¥t compliqu√©e, jusqu'√† ce que je tombe sur <a href="https://youtu.be/ZUmc45Njs9U" rel="nofollow">cette vid√©o sur la m√©taprogrammation bas√©e sur la valeur</a> .  Cette approche de la m√©taprogrammation vous permet d'√©crire des algorithmes g√©n√©ralis√©s comme s'il s'agissait d'un code plus ordinaire.  Dans cet article, je ne donnerai que le plus n√©cessaire de la vid√©o pour r√©soudre le probl√®me, il existe des algorithmes beaucoup plus g√©n√©ralis√©s. </p><br><p>  Je vais r√©soudre le probl√®me dans un r√©sum√©, pas pour une p√©riph√©rie sp√©cifique.  Donc, il y a plusieurs champs de registre, je les √©crirai conditionnellement sous forme d'√©num√©rations. </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Enum1</span></span></span><span class="hljs-class"> {</span></span> _0, _1, _2, _3 }; <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Enum2</span></span></span><span class="hljs-class"> {</span></span> _0, _1, _2, _3 }; <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Enum3</span></span></span><span class="hljs-class"> {</span></span> _0, _1, _2, _3, _4 }; <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Enum4</span></span></span><span class="hljs-class"> {</span></span> _0, _1, _2, _3 };</code> </pre> <br><p>  Les trois premiers concerneront une p√©riph√©rie, le quatri√®me une autre.  Ainsi, si vous entrez la valeur de la quatri√®me √©num√©ration dans la m√©thode de la premi√®re p√©riph√©rie, il devrait y avoir une erreur de compilation, de pr√©f√©rence compr√©hensible.  De plus, les 2 premi√®res inscriptions porteront sur un registre, la troisi√®me sur un autre. </p><br><p>  √âtant donn√© que les valeurs des √©num√©rations ne stockent en elles-m√™mes rien d'autre que les valeurs r√©elles, un type suppl√©mentaire est n√©cessaire qui stockera, par exemple, un masque pour d√©terminer dans quelle partie du registre cette √©num√©ration sera √©crite. </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Enum1_traits</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> mask = <span class="hljs-number"><span class="hljs-number">0b00111</span></span>; }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Enum2_traits</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> mask = <span class="hljs-number"><span class="hljs-number">0b11000</span></span>; }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Enum3_traits</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> mask = <span class="hljs-number"><span class="hljs-number">0b00111</span></span>; }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Enum4_traits</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> mask = <span class="hljs-number"><span class="hljs-number">0b00111</span></span>; };</code> </pre> <br><p>  Reste √† connecter ces 2 types.  Ici, la <a href="https://en.cppreference.com/w/cpp/types/type_identity" rel="nofollow">puce est d√©j√†</a> utile <a href="https://en.cppreference.com/w/cpp/types/type_identity" rel="nofollow">pour 20 normes</a> , mais elle est assez banale et vous pouvez l'impl√©menter vous-m√™me. </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">type_identity</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> type = T; }; <span class="hljs-comment"><span class="hljs-comment">//    constexpr auto some_type = type_identity&lt;Some_type&gt;{}; //      using some_type_t = typename decltype(some_type)::type; #define TYPE(type_identity) typename decltype(type_identity)::type</span></span></code> </pre> <br><p>  L'essentiel est que vous pouvez cr√©er une valeur √† partir de n'importe quel type et la transmettre √† la fonction comme argument.  Il s'agit de la brique principale de l'approche de m√©taprogrammation bas√©e sur les valeurs, dans laquelle vous devez essayer de transmettre des informations de type via des valeurs, et non en tant que param√®tre de mod√®le.  Ici, j'ai d√©fini une macro, mais j'en suis un adversaire en c ++.  Mais il autorise davantage l'√©criture.  Ensuite, je donnerai une √©num√©ration de liens et ses propri√©t√©s √† une fonction et √† une autre macro qui permet de r√©duire le nombre de copier-coller. </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constexpr</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">auto</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">traits</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(type_identity&lt;Enum1&gt;)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> type_identity&lt;Enum1_traits&gt;{}; } <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MAKE_TRAITS_WITH_MASK(enum, mask_) struct enum##_traits { \ static constexpr std::size_t mask = mask_; \ }; \ constexpr auto traits(type_identity</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;enum&gt;) { \ return type_identity&lt;enum##_traits&gt;{}; \ }</span></span></span></span></code> </pre> <br><p>  Il est n√©cessaire d'associer les champs aux registres correspondants.  J'ai choisi la relation par h√©ritage, car le standard a d√©j√† la m√©tafonction <code>std::is_base_of</code> , qui vous permettra de d√©finir la relation entre les champs et les registres d√©j√† sous une forme g√©n√©ralis√©e.  Vous ne pouvez pas h√©riter des √©num√©rations, nous h√©ritons donc de leurs propri√©t√©s. </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Register1</span></span></span><span class="hljs-class"> :</span></span> Enum1_traits, Enum2_traits { <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> offset = <span class="hljs-number"><span class="hljs-number">0x0</span></span>; };</code> </pre> <br><p>  L'adresse o√π se trouve le registre est stock√©e comme d√©calage par rapport au d√©but de la p√©riph√©rie. </p><br><p>  Avant de d√©crire la p√©riph√©rie, il est n√©cessaire de parler de la liste des types de m√©taprogrammation bas√©e sur les valeurs.  Il s'agit d'une structure assez simple qui vous permet d'enregistrer plusieurs types et de les transmettre par valeur.  Un peu comme <code>type_identity</code> , mais pour quelques types. </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class">...</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Ts</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">type_pack</span></span></span><span class="hljs-class">{</span></span>}; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> empty_pack = type_pack&lt;&gt;;</code> </pre> <br><p>  Vous pouvez impl√©menter de nombreuses fonctions constexpr pour cette liste.  Leur impl√©mentation est beaucoup plus facile √† comprendre que les fameuses listes de types Alexandrescu (biblioth√®que Loki).  Voici des exemples. </p><br><p>  La deuxi√®me propri√©t√© importante de la p√©riph√©rie devrait √™tre la capacit√© de la localiser √† la fois √† une adresse sp√©cifique (dans le microcontr√¥leur) et de passer l'adresse dynamiquement pour les tests.  Par cons√©quent, la structure de la p√©riph√©rie sera passe-partout, et en tant que param√®tre, prendre un type qui stockera une adresse sp√©cifique de la p√©riph√©rie dans le champ de valeur.  Le param√®tre de mod√®le sera d√©termin√© √† partir du constructeur.  Eh bien, la m√©thode set, qui a √©t√© mentionn√©e plus t√¥t. </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Address</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Periph1</span></span></span><span class="hljs-class"> {</span></span> Periph1(Address) {} <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> registers = type_pack&lt;Register1, Register2&gt;{}; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class">...</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Ts</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">static</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">constexpr</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">void</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">set</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Ts</span></span></span><span class="hljs-class">...</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">args</span></span></span><span class="hljs-class">) {</span></span> ::<span class="hljs-built_in"><span class="hljs-built_in">set</span></span>(registers, Address::value, args...); } };</code> </pre> <br><p>  La m√©thode set ne fait qu'appeler une fonction libre, en lui transmettant toutes les informations n√©cessaires √† l'algorithme g√©n√©ralis√©. </p><br><p>  Je vais donner des exemples de types qui fournissent une adresse √† la p√©riph√©rie. </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//    struct Address { static constexpr std::size_t value = SOME_PERIPH_BASE; }; //    ,    struct Address { static inline std::size_t value; template&lt;class Pointer&gt; Address(Pointer address) { value = reinterpret_cast&lt;std::size_t&gt;(address); } };</span></span></code> </pre> <br><p>  Toutes les informations pour l'algorithme g√©n√©ralis√© sont pr√©par√©es, il reste √† le mettre en ≈ìuvre.  Je vais donner le texte de cette fonction. </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class">...</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Registers</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class">...</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Args</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">constexpr</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">void</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">set</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">type_pack</span></span></span><span class="hljs-class">&lt;Registers...&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">registers</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">std</span></span></span><span class="hljs-class">:</span></span>:<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> address, Args...args) { <span class="hljs-comment"><span class="hljs-comment">//       ,  value based  constexpr auto args_traits = make_type_pack(traits(type_identity&lt;Args&gt;{})...); //              static_assert(all_of(args_traits, [](auto arg){ return (std::is_base_of_v&lt;TYPE(arg), Registers&gt; || ...); }), "one of arguments in set method don`t belong to periph type"); //   ,      constexpr auto registers_for_write = filter(registers, [](auto reg){ return any_of(args_traits, [](auto arg){ //       o  reg? return std::is_base_of_v&lt;TYPE(arg), TYPE(reg)&gt;; }); }); //           foreach(registers_for_write, [=](auto reg){ auto value = register_value(reg, args...); auto offset = decltype(reg)::type::offset; write(address + offset, value); }); };</span></span></code> </pre> <br><p>  L'impl√©mentation d'une fonction qui convertit les arguments (champs de registre sp√©cifiques) en <code>type_pack</code> est assez triviale.  Permettez-moi de vous rappeler que les points de suspension de la liste des types de mod√®les r√©v√®lent une liste de types s√©par√©s par des virgules. </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class">...</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Ts</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">constexpr</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">auto</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">make_type_pack</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">type_identity</span></span></span><span class="hljs-class">&lt;Ts&gt;...) {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> type_pack&lt;Ts...&gt;{}; }</code> </pre> <br><p>  Pour v√©rifier que tous les arguments se rapportent aux registres transf√©r√©s, et donc √† des p√©riph√©riques sp√©cifiques, il est n√©cessaire d'impl√©menter l'algorithme all_of.  Par analogie avec la biblioth√®que standard, l'algorithme re√ßoit en entr√©e une liste de types et une fonction de pr√©dicat.  Nous utilisons un lambda comme fonction. </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">F</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class">...</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Ts</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">constexpr</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">auto</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">all_of</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">type_pack</span></span></span><span class="hljs-class">&lt;Ts...&gt;, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">F</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">f</span></span></span><span class="hljs-class">) {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (f(type_identity&lt;Ts&gt;{}) <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> ...); }</code> </pre> <br><p>  Ici, pour la premi√®re fois, une <a href="https://ru.cppreference.com/w/cpp/language/fold" rel="nofollow">expression de balayage de 17 standard est</a> appliqu√©e.  C'est cette innovation qui a grandement simplifi√© la vie de ceux qui aiment la m√©taprogrammation.  Dans cet exemple, la fonction f est appliqu√©e √† chacun des types de la liste Ts, en la convertissant en <code>type_identity</code> , et le r√©sultat de chaque appel est collect√© par I. </p><br><p>  √Ä l'int√©rieur de <code>static_assert</code> , cet algorithme est appliqu√©.  <code>args_traits</code> envelopp√© dans <code>type_identity</code> est transmis au lambda √† son tour.  √Ä l'int√©rieur du lambda, la m√©tafonction standard std :: is_base_of est utilis√©e, mais comme il peut y avoir plus d'un registre, une expression de balayage est utilis√©e pour l'ex√©cuter pour chacun des registres selon la logique OU.  Par cons√©quent, s'il existe au moins un argument dont les propri√©t√©s ne sont pas basiques pour au moins un registre, l' <code>static assert</code> fonctionnera et affichera un message d'erreur clair.  Il est facile de comprendre d'o√π provient l'erreur (elle a transmis le mauvais argument √† la m√©thode <code>set</code> ) et de la corriger. </p><br><p>  L'impl√©mentation de l'algorithme <code>any_of</code> , qui sera n√©cessaire ult√©rieurement, est tr√®s similaire: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">F</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class">...</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Ts</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">constexpr</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">auto</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">any_of</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">type_pack</span></span></span><span class="hljs-class">&lt;Ts...&gt;, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">F</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">f</span></span></span><span class="hljs-class">) {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (f(type_identity&lt;Ts&gt;{}) <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> ...); }</code> </pre> <br><p>  La t√¢che suivante de l'algorithme g√©n√©ralis√© consiste √† d√©terminer quels registres devront √™tre √©crits.  Pour ce faire, filtrez la liste initiale des registres et ne laissez que ceux pour lesquels il existe des arguments dans notre fonction.  Nous avons besoin d'un algorithme de <code>filter</code> qui prend le <code>type_pack</code> origine, applique la fonction de pr√©dicat pour chaque type de la liste et l'ajoute √† la nouvelle liste si le pr√©dicat renvoie vrai. </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">F</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class">...</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Ts</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">constexpr</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">auto</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">filter</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">type_pack</span></span></span><span class="hljs-class">&lt;Ts...&gt;, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">F</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">f</span></span></span><span class="hljs-class">) {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> filter_one = [](<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> v, <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> f) { <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> T = <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> <span class="hljs-keyword"><span class="hljs-keyword">decltype</span></span>(v)::type; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">if</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">constexpr</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(f(v))</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">return</span></span></span><span class="hljs-function"> type_pack&lt;T&gt;</span></span>{}; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> empty_pack{}; }; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (empty_pack{} + ... + filter_one(type_identity&lt;Ts&gt;{}, f)); }</code> </pre> <br><p>  Tout d'abord, un lambda est d√©crit qui ex√©cute la fonction d'un pr√©dicat sur un type et renvoie <code>type_pack</code> avec lui si le pr√©dicat a renvoy√© true, ou vide <code>type_pack</code> si le pr√©dicat a renvoy√© <code>false</code> .  Une autre nouvelle fonctionnalit√© des derniers avantages aide ici - constexpr if.  Son essence est que dans le code r√©sultant, il n'y a qu'une seule branche if, la seconde est lev√©e.  Et puisque diff√©rents types reviennent dans diff√©rentes branches, sans constexpr, il y aurait une erreur de compilation.  Le r√©sultat de l'ex√©cution de ce lambda pour chaque type de la liste est concat√©n√© dans un <code>type_pack</code> r√©sultant, toujours gr√¢ce √† l'expression d' <code>type_pack</code> .  Il n'y a pas suffisamment de surcharge de l'op√©rateur d'addition pour <code>type_pack</code> .  Sa mise en ≈ìuvre est √©galement assez simple: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class">...</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Ts</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class">...</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Us</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">constexpr</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">auto</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">operator</span></span></span><span class="hljs-class">+ (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">type_pack</span></span></span><span class="hljs-class">&lt;Ts...&gt;, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">type_pack</span></span></span><span class="hljs-class">&lt;Us...&gt;) {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> type_pack&lt;Ts..., Us...&gt;{}; }</code> </pre> <br><p>  En appliquant le nouvel algorithme sur la liste des registres, seuls ceux dans lesquels les arguments transf√©r√©s doivent √™tre √©crits restent dans la nouvelle liste. </p><br><p>  Le prochain algorithme qui sera n√©cessaire est <code>foreach</code> .  Il applique simplement une fonction √† chaque type de la liste, en l'enveloppant dans <code>type_identity</code> .  Ici, un op√©rateur virgule est utilis√© dans l'expression d'analyse, qui ex√©cute toutes les actions d√©crites par une virgule et renvoie le r√©sultat de la derni√®re action. </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">F</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class">...</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Ts</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">constexpr</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">void</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">foreach</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">type_pack</span></span></span><span class="hljs-class">&lt;Ts...&gt;, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">F</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">f</span></span></span><span class="hljs-class">) {</span></span> (f(type_identity&lt;Ts&gt;{}), ...); }</code> </pre> <br><p>  La fonction vous permet d'acc√©der √† chacun des registres o√π vous souhaitez √©crire.  Le lambda calcule la valeur d'√©criture dans le registre, d√©termine l'adresse o√π vous souhaitez √©crire et √©crit directement dans le registre. </p><br><p>  Afin de calculer la valeur d'un registre, la valeur de chaque argument auquel appartient ce registre est calcul√©e et le r√©sultat est combin√© par OR. </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Register</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class">...</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Args</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">constexpr</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">std</span></span></span><span class="hljs-class">:</span></span>:<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> register_value(type_identity&lt;Register&gt; reg, Args...args) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (arg_value(reg, args) | ...); }</code> </pre> <br><p>  Le calcul d'une valeur pour un champ sp√©cifique doit √™tre effectu√© uniquement pour les arguments dont ce registre est h√©rit√©.  Pour l'argument, nous extrayons un masque de sa propri√©t√©, d√©terminons le d√©calage de la valeur √† l'int√©rieur du registre √† partir du masque. </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Register</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Arg</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">constexpr</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">std</span></span></span><span class="hljs-class">:</span></span>:<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> arg_value(type_identity&lt;Register&gt;, Arg arg) { <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> arg_traits = traits(type_identity&lt;Arg&gt;{}); <span class="hljs-comment"><span class="hljs-comment">//   ,     if constexpr (not std::is_base_of_v&lt;TYPE(arg_traits), Register&gt;) return 0; constexpr auto mask = decltype(arg_traits)::type::mask; constexpr auto arg_shift = shift(mask); return static_cast&lt;std::size_t&gt;(arg) &lt;&lt; arg_shift; }</span></span></code> </pre> <br><p>  Vous pouvez √©crire l'algorithme pour d√©terminer le d√©calage du masque vous-m√™me, mais j'ai utilis√© la fonction int√©gr√©e existante. </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constexpr</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">auto</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">shift</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> mask)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> __builtin_ffs(mask) - <span class="hljs-number"><span class="hljs-number">1</span></span>; }</code> </pre> <br><p>  La derni√®re fonction qui √©crit la valeur dans une adresse sp√©cifique reste. </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">write</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> address, </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> v)</span></span></span><span class="hljs-function"> </span></span>{ *<span class="hljs-keyword"><span class="hljs-keyword">reinterpret_cast</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span>*&gt;(address) |= v; }</code> </pre> <br><p>  Pour tester la t√¢che, un petit test est √©crit: </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// ,    volatile std::size_t arr[3]; int main() { //     ( ) //   ,         auto address = Address{arr}; auto mock_periph = Periph1{address}; //  1      //  3       3 //  4      //     0b00011001 (25) //    0b00000100 (4) mock_periph.set(Enum1::_1, Enum2::_3, Enum3::_4); // all ok // mock_periph.set(Enum4::_0); // must be compilation error }</span></span></code> </pre> <br><p>  Tout ce qui est √©crit ici a √©t√© combin√© et <a href="https://godbolt.org/z/9KTJLN" rel="nofollow">compil√© en godbolt</a> .  N'importe qui peut exp√©rimenter cette approche.  On voit que l'objectif est atteint: il n'y a pas d'acc√®s m√©moire inutile.  La valeur qui doit √™tre √©crite dans les registres est calcul√©e au stade de la compilation: </p><br><pre> <code class="cpp hljs">main: mov QWORD PTR Address::value[rip], OFFSET FLAT:arr <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> QWORD PTR arr[rip], <span class="hljs-number"><span class="hljs-number">25</span></span> <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> QWORD PTR arr[rip+<span class="hljs-number"><span class="hljs-number">8</span></span>], <span class="hljs-number"><span class="hljs-number">4</span></span> mov eax, <span class="hljs-number"><span class="hljs-number">0</span></span> ret</code> </pre> <br><hr><br><p>  PS: <br>  Merci √† tous pour les commentaires, gr√¢ce √† eux, j'ai l√©g√®rement modifi√© l'approche.  Vous pouvez voir la nouvelle option <a href="https://godbolt.org/z/d6xt_A" rel="nofollow">ici.</a> </p><br><ul><li>  types d'aides supprim√©s * _traits, le masque peut √™tre enregistr√© directement dans la liste. <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Enum1</span></span></span><span class="hljs-class"> {</span></span> _0, _1, _2, _3, mask = <span class="hljs-number"><span class="hljs-number">0b00111</span></span> };</code> </pre> </li><li>  la connexion de registre avec les arguments se fait maintenant non pas par h√©ritage, maintenant c'est un champ de registre statique <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> params = type_pack&lt;Enum1, Enum2&gt;{};</code> </pre> </li><li>  comme la connexion n'est plus par h√©ritage, j'ai d√ª √©crire la fonction contains: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class">...</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Ts</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">constexpr</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">auto</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">contains</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">type_pack</span></span></span><span class="hljs-class">&lt;Ts...&gt;, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">type_identity</span></span></span><span class="hljs-class">&lt;T&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">v</span></span></span><span class="hljs-class">) {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ((type_identity&lt;Ts&gt;{} == v) <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> ...); }</code> </pre> </li><li>  sans types superflus toutes les macros ont disparu </li><li>  Je passe des arguments √† la m√©thode via les param√®tres du mod√®le pour les utiliser dans un contexte constexpr </li><li>  maintenant dans la m√©thode set, la logique constexpr est clairement s√©par√©e de la logique de l'enregistrement lui-m√™me <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span>...args&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">set</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> values_for_write = extract(registers, args...); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> [value, offset] : values_for_write) { write(Address::value + offset, value); } }</code> </pre> </li><li>  La fonction d'extraction alloue dans constexpr un tableau de valeurs pour l'√©criture dans les registres.  Son impl√©mentation est tr√®s similaire √† la fonction set pr√©c√©dente, sauf qu'elle n'√©crit pas directement dans le registre. </li><li>  J'ai d√ª ajouter une autre m√©tafonction qui convertit type_pack en un tableau en fonction de la fonction lambda. <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">F</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class">...</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Ts</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">constexpr</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">auto</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">to_array</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">type_pack</span></span></span><span class="hljs-class">&lt;Ts...&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">pack</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">F</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">f</span></span></span><span class="hljs-class">) {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">array</span></span>{f(type_identity&lt;Ts&gt;{})...}; }</code> </pre> </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr483378/">https://habr.com/ru/post/fr483378/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr483366/index.html">Histoire d'Internet: R√©seautage</a></li>
<li><a href="../fr483368/index.html">Cr√©ation du packer de fichiers ELF x86_64 pour Linux</a></li>
<li><a href="../fr483372/index.html">Comment former un r√©seau neuronal DeepPavlov sur un ordinateur portable √† l'aide d'un GPU</a></li>
<li><a href="../fr483374/index.html">Recommandations de l'API REST - Exemples de conception de services Web dans Java et Spring</a></li>
<li><a href="../fr483376/index.html">√Ä la surface d'un trou noir</a></li>
<li><a href="../fr483380/index.html">Microservices: comment respecter le contrat</a></li>
<li><a href="../fr483382/index.html">Kali Linux 2020.1</a></li>
<li><a href="../fr483384/index.html">Quels mots anglais du lexique informatique pronon√ßons-nous le plus souvent incorrectement</a></li>
<li><a href="../fr483386/index.html">La collision galactique √† venir de la Voie lact√©e donne d√©j√† naissance √† de nouvelles √©toiles</a></li>
<li><a href="../fr483388/index.html">Ma copine et le premier jeu vid√©o. D√©veloppement de l'unit√©. 2e partie</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>