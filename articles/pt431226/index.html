<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üîì ‚ôøÔ∏è üë®‚Äç‚öñÔ∏è O jogo Snake para FPGA Cyclone IV (com joystick VGA e SPI) üëçüèº üòá ü§∏üèø</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="1. Introdu√ß√£o 


 Voc√™ se lembra do jogo de cobras desde a inf√¢ncia, onde uma cobra corre na tela tentando comer uma ma√ß√£? Este artigo descreve nossa ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>O jogo Snake para FPGA Cyclone IV (com joystick VGA e SPI)</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/431226/"><h2 id="introduction">  1. Introdu√ß√£o </h2><br><p>  Voc√™ se lembra do <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">jogo de cobras</a> desde a inf√¢ncia, onde uma cobra corre na tela tentando comer uma ma√ß√£?  Este artigo descreve nossa implementa√ß√£o do jogo em um FPGA <sup><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">1</a></sup> . </p><br><p><img src="https://github.com/Sitiritis/SnakeGame_FPGA/blob/master/text/img/gameplay.gif?raw=true" alt="Gameplay.gif"><br>  <strong>Figura 1.</strong> Jogabilidade </p><a name="habracut"></a><br><p>  Primeiro, vamos nos apresentar e explicar a raz√£o pela qual trabalhamos no projeto.  Somos tr√™s: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Tymur Lysenko</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Daniil Manakovskiy</a> e <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Sergey Makarov</a> .  Como alunos do primeiro ano da <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Universidade</a> de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Innopolis</a> , tivemos um curso de "Arquitetura de Computadores", que √© ministrado profissionalmente e permite que o aluno compreenda a estrutura de baixo n√≠vel de um computador.  Em algum momento do curso, os instrutores nos deram a oportunidade de desenvolver um projeto para um FPGA para obter pontos adicionais no curso.  Nossa motiva√ß√£o n√£o √© apenas a nota, mas nosso interesse em ganhar mais experi√™ncia no design de hardware, compartilhar os resultados e, finalmente, ter um jogo agrad√°vel. </p><br><p>  Agora, vamos entrar em detalhes profundos e sombrios. </p><br><h2 id="project-overview">  Vis√£o geral do projeto </h2><br><p>  Para o nosso projeto, selecionamos um jogo f√°cil de implementar e divertido, o "Snake".  A estrutura da implementa√ß√£o √© a seguinte: primeiro, uma entrada √© obtida de um joystick SPI, depois processada e, finalmente, uma imagem √© enviada para um monitor VGA e uma pontua√ß√£o √© exibida em um display de 7 segmentos (em hexadecimal).  Embora a l√≥gica do jogo seja intuitiva e direta, o VGA e o joystick foram desafios interessantes e sua implementa√ß√£o levou a uma boa experi√™ncia de jogo. </p><br><p>  O jogo tem as seguintes regras.  Um jogador come√ßa com a cabe√ßa de uma √∫nica cobra.  O objetivo √© comer ma√ß√£s, que s√£o geradas aleatoriamente na tela depois que a anterior foi comida.  Al√©m disso, a cobra est√° sendo estendida por 1 cauda ap√≥s satisfazer a fome.  As caudas se movem uma ap√≥s a outra, seguindo a cabe√ßa.  A cobra est√° sempre em movimento.  Se as bordas da tela forem atingidas, a cobra est√° sendo transferida para outro lado da tela.  Se a cabe√ßa bate no rabo, o jogo acaba. </p><br><h2 id="tools-used">  Ferramentas utilizadas </h2><br><ul><li>  Altera Cyclone IV (EP4CE6E22C8N) com 6272 elementos l√≥gicos, rel√≥gio interno de 50 MHz, VGA colorido de 3 bits, display de 8 d√≠gitos e 7 segmentos.  O FPGA n√£o pode levar uma entrada anal√≥gica para seus pinos. </li><li>  Joystick SPI (KY-023) </li><li>  Um monitor VGA que suporta taxa de atualiza√ß√£o de 60 Hz </li><li>  Quartus Prime Lite Edition 18.0.0 Build 614 </li><li>  Verilog HDL IEEE 1364-2001 </li><li>  Breadboard </li><li>  Elementos el√©tricos: <br><ul><li>  8 conectores macho-f√™mea </li><li>  1 conector f√™mea-f√™mea </li><li>  1 conector macho-macho </li><li>  4 resistores (4,7 KŒ©) </li></ul></li></ul><br><h2 id="architecture-overview">  Vis√£o geral da arquitetura </h2><br><p>  A arquitetura do projeto √© um fator significativo a considerar.  A Figura 2 mostra essa arquitetura do ponto de vista de n√≠vel superior: </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/c92/2a4/4b2/c922a44b20cdc085b7061e7b5c5f8cd4.png" alt="Design.png"><br>  <strong>Figura 2.</strong> Visualiza√ß√£o de n√≠vel superior do design ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">pdf</a> ) </p><br><p>  Como voc√™ pode ver, existem muitas entradas, sa√≠das e alguns m√≥dulos.  Esta se√ß√£o descreve o que cada elemento significa e especifica quais pinos s√£o usados ‚Äã‚Äãna placa para as portas. </p><br><h3 id="main-inputs">  Entradas principais </h3><br><p>  As principais entradas necess√°rias para a implementa√ß√£o s√£o <em>res_x_one</em> , <em>res_x_two</em> , <em>res_y_one</em> , <em>res_y_two</em> , que s√£o usadas para receber uma dire√ß√£o atual de um joystick.  A Figura 3 mostra o mapeamento entre seus valores e as dire√ß√µes. </p><br><table><thead><tr><th>  Entrada </th><th>  Esquerda </th><th>  Direito </th><th>  Para cima </th><th>  Para baixo </th><th>  Nenhuma mudan√ßa de dire√ß√£o </th></tr></thead><tbody><tr><td>  res_x_one (PIN_30) </td><td>  1 </td><td>  0 0 </td><td>  x </td><td>  x </td><td>  1 </td></tr><tr><td>  res_x_two (PIN_52) </td><td>  1 </td><td>  0 0 </td><td>  x </td><td>  x </td><td>  0 0 </td></tr><tr><td>  res_y_one (PIN_39) </td><td>  x </td><td>  x </td><td>  1 </td><td>  0 0 </td><td>  1 </td></tr><tr><td>  res_y_two (PIN_44) </td><td>  x </td><td>  x </td><td>  1 </td><td>  0 0 </td><td>  0 0 </td></tr></tbody></table><br><p>  <strong>Figura 3.</strong> Mapeamento de entradas e dire√ß√µes do joystick </p><br><h3 id="other-inputs">  Outras entradas </h3><br><ul><li>  <em>clk</em> - o rel√≥gio do quadro (PIN_23) </li><li>  <em>reset</em> - sinal para reiniciar o jogo e parar de imprimir (PIN_58) </li><li>  <em>cor</em> - quando 1, todas as cores poss√≠veis s√£o exibidas na tela e usadas apenas para fins de demonstra√ß√£o (PIN_68) </li></ul><br><h3 id="main-modules">  M√≥dulos principais </h3><br><h4 id="joystick_input">  joystick_input </h4><br><p>  <em>O joystick_input</em> √© usado para produzir um c√≥digo de dire√ß√£o com base em uma entrada do joystick. </p><br><h4 id="game_logic">  game_logic </h4><br><p>  <em>game_logic</em> cont√©m toda a l√≥gica necess√°ria para jogar um jogo.  O m√≥dulo move uma cobra em uma determinada dire√ß√£o.  Al√©m disso, √© respons√°vel por comer ma√ß√£ e detectar colis√µes.  Al√©m disso, ele recebe as coordenadas xey atuais de um pixel na tela e retorna uma entidade colocada na posi√ß√£o. </p><br><h4 id="vga_draw">  VGA_Draw </h4><br><p>  A gaveta define a cor de um pixel para um valor espec√≠fico com base na posi√ß√£o atual ( <em>iVGA_X, iVGA_Y</em> ) e na entidade atual ( <em>ent</em> ). </p><br><h4 id="vga_ctrl">  VGA_Ctrl </h4><br><p>  Gera um fluxo de bits de controle para a sa√≠da VGA ( <em>V_Sync, H_Sync, R, G, B</em> ). </p><br><h4 id="sseg_displaysup22sup">  SSEG_Display <sup><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">2</a></sup> </h4><br><p>  <em>SSEG_Display</em> √© um driver para <em>gerar</em> a pontua√ß√£o atual na tela de 7 segmentos. </p><br><h4 id="vga_clk">  Vga_clk </h4><br><p>  <em>O VGA_clk</em> recebe um rel√≥gio de 50 MHz e reduz para 25,175 MHz. </p><br><h4 id="game_upd_clk">  game_upd_clk </h4><br><p>  <em>game_upd_clk</em> √© um m√≥dulo que gera um rel√≥gio especial que aciona uma atualiza√ß√£o do estado do jogo. </p><br><h3 id="outputs">  Sa√≠das </h3><br><ul><li>  <em>VGA_B</em> - Pino azul VGA (PIN_144) </li><li>  <em>VGA_G</em> - Pino verde VGA (PIN_1) </li><li>  <em>VGA_R</em> - Pino vermelho VGA (PIN_2) </li><li>  <em>VGA_HS</em> - sincroniza√ß√£o horizontal VGA (PIN_142) </li><li>  <em>VGA_VS</em> - sincroniza√ß√£o vertical VGA (PIN_143) </li><li>  <em>sseg_a_to_dp</em> - especifica qual dos 8 segmentos deve ser iluminado (PIN_115, PIN_119, PIN_120, PIN_121, PIN_124, PIN_125, PIN_126, PIN_127) </li><li>  <em>sseg_an</em> - especifica qual dos 4 displays de 7 segmentos deve ser usado (PIN_128, PIN_129, PIN_132, PIN_133) </li></ul><br><h2 id="implementation">  Implementa√ß√£o </h2><br><h3 id="input-with-spi-joystick">  Entrada com joystick SPI </h3><br><p><img src="https://habrastorage.org/getpro/habr/post_images/e3f/4ab/fc4/e3f4abfc45c5a87151db34738e9c3a92.jpg" alt="stick.jpg"></p><br><p>  <strong>Figura 4.</strong> Joystick SPI (KY-023) </p><br><p>  Ao implementar um m√≥dulo de entrada, descobrimos que o stick produz um sinal anal√≥gico.  O joystick possui 3 posi√ß√µes para cada eixo: </p><br><ul><li>  top - sa√≠da de ~ 5V </li><li>  mid - sa√≠da de ~ 2.5V </li><li>  baixa - sa√≠da de ~ 0V </li></ul><br><p> A entrada √© muito semelhante ao sistema tern√°rio: para o eixo X, temos um estado <code>true</code> (esquerdo), <code>false</code> (direito) e <code>undetermined</code> , onde o joystick n√£o est√° √† esquerda nem √† direita.  O problema √© que a placa FPGA pode processar apenas uma entrada digital.  Portanto, n√£o podemos converter essa l√≥gica tern√°ria em bin√°ria apenas escrevendo algum c√≥digo.  A primeira solu√ß√£o sugerida foi encontrar um conversor Anal√≥gico-Digital, mas decidimos usar nosso conhecimento escolar de f√≠sica e implementar o divisor de tens√£o <sup><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">3</a></sup> .  Para definir os tr√™s estados, precisaremos de dois bits: 00 √© <code>false</code> , 01 √© <code>undefined</code> e 11 √© <code>true</code> .  Ap√≥s algumas medi√ß√µes, descobrimos que em nosso quadro, a fronteira entre zero e um √© de aproximadamente 1,7V.  Assim, constru√≠mos o seguinte esquema (imagem criada usando o circuitlab <sup><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">4</a></sup> ): </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/009/36c/a43/00936ca435f219d64f7078bec64e9b8c.png" alt="Stick_connection.png"></p><br><p>  <strong>Figura 5.</strong> Circuito para ADC para joystick </p><br><p>  A implementa√ß√£o f√≠sica √© criada usando os itens do kit Arduino e tem a seguinte apar√™ncia: </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/3eb/34b/c9e/3eb34bc9e0210b8f336a7fd8ba89f1a9.jpg" alt="stick_imp"></p><br><p>  <strong>Figura 6.</strong> Implementa√ß√£o do ADC </p><br><p>  Nosso circuito recebe uma entrada para cada eixo e produz duas sa√≠das: a primeira vem diretamente do man√≠pulo e se torna zero somente se o joystick gerar <code>zero</code> .  O segundo √© 0 no estado <code>undetermined</code> , mas ainda 1 no <code>true</code> .  Este √© o resultado exato que esper√°vamos. </p><br><p>  A l√≥gica do m√≥dulo de entrada √©: </p><br><ol><li>  Traduzimos nossa l√≥gica tern√°ria em fios bin√°rios simples para cada dire√ß√£o; </li><li>  A cada ciclo do rel√≥gio, verificamos se apenas uma dire√ß√£o √© <code>true</code> (a cobra n√£o pode ir na diagonal); </li><li>  Comparamos nossa nova dire√ß√£o com a anterior para impedir que a cobra se coma, n√£o permitindo que o jogador mude a dire√ß√£o na dire√ß√£o oposta. </li></ol><br><div class="spoiler">  <b class="spoiler_title">Parte do c√≥digo do m√≥dulo de entrada</b> <div class="spoiler_text"><pre> <code class="vhdl hljs">reg left, right, up, down; initial <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> direction = `TOP_DIR; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> always @(posedge clk) <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> //<span class="hljs-number"><span class="hljs-number">1</span></span> left = two_resistors_x; right = ~one_resistor_x; up = two_resistors_y; down = ~one_resistor_y; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (left + right + up + down == <span class="hljs-number"><span class="hljs-number">3</span></span><span class="hljs-symbol"><span class="hljs-symbol">'b001</span></span>) //<span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (left &amp;&amp; (direction != `RIGHT_DIR)) //<span class="hljs-number"><span class="hljs-number">3</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> direction = `LEFT_DIR; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> //same code <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> other directions <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> </div></div><br><h3 id="output-to-vga">  Sa√≠da para VGA </h3><br><p>  Decidimos fazer uma sa√≠da com resolu√ß√£o 640x480 em uma tela de 60Hz rodando a 60 FPS. </p><br><p>  O m√≥dulo VGA consiste em 2 partes principais: um <strong>driver</strong> e uma <strong>gaveta</strong> .  O driver gera um fluxo de bits que consiste em sinais de sincroniza√ß√£o vertical e horizontal e uma cor que √© dada √†s sa√≠das VGA.  Um artigo <sup><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">5</a></sup> escrito por <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">@SlavikMIPT</a> descreve os princ√≠pios b√°sicos do trabalho com VGA.  N√≥s adaptamos o driver do artigo ao nosso quadro. </p><br><p>  Decidimos dividir a tela em uma grade de elementos de 40x30, composta por quadrados de 16x16 pixels.  Cada elemento representa 1 entidade do jogo: uma ma√ß√£, uma cabe√ßa de cobra, um rabo ou nada. </p><br><p>  O pr√≥ximo passo em nossa implementa√ß√£o foi criar sprites para as entidades. </p><br><p>  O ciclone IV possui apenas 3 bits para representar uma cor no VGA (1 para vermelho, 1 para verde e 1 para azul).  Devido a essa limita√ß√£o, precis√°vamos implementar um conversor para ajustar as cores das imagens √†s dispon√≠veis.  Para isso, criamos um script python que divide um valor RGB de cada pixel por 128. </p><br><div class="spoiler">  <b class="spoiler_title">O script python</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> PIL <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Image, ImageDraw filename = <span class="hljs-string"><span class="hljs-string">"snake_head"</span></span> index = <span class="hljs-number"><span class="hljs-number">1</span></span> im = Image.open(filename + <span class="hljs-string"><span class="hljs-string">".png"</span></span>) n = Image.new(<span class="hljs-string"><span class="hljs-string">'RGB'</span></span>, (<span class="hljs-number"><span class="hljs-number">16</span></span>, <span class="hljs-number"><span class="hljs-number">16</span></span>)) d = ImageDraw.Draw(n) pix = im.load() size = im.size data = [] code = <span class="hljs-string"><span class="hljs-string">"sp["</span></span> + str(index) + <span class="hljs-string"><span class="hljs-string">"][{i}][{j}] = 3'b{RGB};\\\n"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> open(<span class="hljs-string"><span class="hljs-string">"code_"</span></span> + filename + <span class="hljs-string"><span class="hljs-string">".txt"</span></span>, <span class="hljs-string"><span class="hljs-string">'w'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> f: <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(size[<span class="hljs-number"><span class="hljs-number">0</span></span>]): tmp = [] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> j <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(size[<span class="hljs-number"><span class="hljs-number">1</span></span>]): clr = im.getpixel((i, j)) vg = <span class="hljs-string"><span class="hljs-string">"{0}{1}{2}"</span></span>.format(int(clr[<span class="hljs-number"><span class="hljs-number">0</span></span>] / <span class="hljs-number"><span class="hljs-number">128</span></span>), <span class="hljs-comment"><span class="hljs-comment"># an array representation for pixel int(clr[1] / 128), # since clr[*] in range [0, 255], int(clr[2] / 128)) # clr[*]/128 is either 0 or 1 tmp.append(vg) f.write(code.format(i=i, j=j, RGB=vg)) # Verilog code to initialization d.point((i, j), tuple([int(vg[0]) * 255, int(vg[1]) * 255, int(vg[2]) * 255])) # Visualize final image data.append(tmp) n.save(filename + "_3bit.png") for el in data: print(" ".join(el))</span></span></code> </pre></div></div><br><table><tbody><tr><td align="center">  Original </td><td align="center">  Ap√≥s o script </td></tr><tr><td align="center" width="150"><img src="https://habrastorage.org/getpro/habr/post_images/720/34d/b40/72034db4092a25711654562bc4523661.png" width="128" height="128"><br></td><td align="center" width="150"><img src="https://habrastorage.org/getpro/habr/post_images/529/254/02e/52925402e158986901bc6278d7d0bb28.png" width="128" height="128"><br></td></tr></tbody></table><br><p>  <strong>Figura 7.</strong> Compara√ß√£o entre entrada e sa√≠da </p><br><p>  O principal objetivo da gaveta √© enviar uma cor de pixel ao VGA com base na posi√ß√£o atual ( <em>iVGA_X, iVGA_Y</em> ) e na entidade atual ( <em>ent</em> ).  Todos os sprites s√£o codificados, mas podem ser facilmente alterados gerando um novo c√≥digo usando o script acima. </p><br><div class="spoiler">  <b class="spoiler_title">L√≥gica da gaveta</b> <div class="spoiler_text"><pre> <code class="vhdl hljs">always @(posedge iVGA_CLK <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> posedge reset) <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(reset) <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> oRed &lt;= <span class="hljs-number"><span class="hljs-number">0</span></span>; oGreen &lt;= <span class="hljs-number"><span class="hljs-number">0</span></span>; oBlue &lt;= <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> // DRAW CURRENT STATE <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ent == `ENT_NOTHING) <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> oRed &lt;= <span class="hljs-number"><span class="hljs-number">1</span></span>; oGreen &lt;= <span class="hljs-number"><span class="hljs-number">1</span></span>; oBlue &lt;= <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> // Drawing a particular pixel from sprite oRed &lt;= sp[ent][iVGA_X % `H_SQUARE][iVGA_Y % `V_SQUARE][<span class="hljs-number"><span class="hljs-number">0</span></span>]; oGreen &lt;= sp[ent][iVGA_X % `H_SQUARE][iVGA_Y % `V_SQUARE][<span class="hljs-number"><span class="hljs-number">1</span></span>]; oBlue &lt;= sp[ent][iVGA_X % `H_SQUARE][iVGA_Y % `V_SQUARE][<span class="hljs-number"><span class="hljs-number">2</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> </div></div><br><h3 id="output-to-the-7-segment-display">  Sa√≠da para a tela de 7 segmentos </h3><br><p>  Com o objetivo de permitir que o jogador veja sua pontua√ß√£o, decidimos produzir uma pontua√ß√£o do jogo na tela de 7 segmentos.  Devido √† falta de tempo, usamos o c√≥digo da documenta√ß√£o do EP4CE6 Starter Board <sup><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">2</a></sup> .  Este m√≥dulo gera um n√∫mero hexadecimal no display. </p><br><h3 id="game-logic">  L√≥gica do jogo </h3><br><p>  Durante o desenvolvimento, tentamos v√°rias abordagens, no entanto, acabamos com a que requer uma quantidade m√≠nima de mem√≥ria, √© f√°cil de implementar em hardware e pode se beneficiar de c√°lculos paralelos. </p><br><p>  O m√≥dulo executa v√°rias fun√ß√µes.  Como o VGA desenha um pixel em cada ciclo do rel√≥gio, come√ßando do canto superior esquerdo, movendo-se para o canto inferior direito, o m√≥dulo VGA_Draw, respons√°vel pela produ√ß√£o de uma cor para um pixel, precisa identificar qual cor usar nas coordenadas atuais.  √â isso que o m√≥dulo de l√≥gica do jogo deve produzir - um c√≥digo de entidade para as coordenadas fornecidas. <br>  Al√©m disso, ele precisa atualizar o estado do jogo somente depois que a tela cheia foi desenhada.  Um sinal produzido pelo m√≥dulo <em>game_upd_clk</em> √© usado para determinar quando atualizar. </p><br><h4 id="game-state">  Estado do jogo </h4><br><p>  O estado do jogo consiste em: </p><br><ul><li>  Coordenadas da cabe√ßa da cobra </li><li>  Uma matriz de coordenadas da cauda da cobra.  A matriz √© limitada por 128 elementos em nossa implementa√ß√£o </li><li>  N√∫mero de caudas </li><li>  Coordenadas de uma ma√ß√£ </li><li>  Bandeira do fim do jogo </li><li>  Bandeira do jogo ganho </li></ul><br><p>  A atualiza√ß√£o do estado do jogo inclui v√°rios est√°gios: </p><br><ol><li>  Mova a cabe√ßa da cobra para novas coordenadas, com base em uma determinada dire√ß√£o.  Se uma coordenada estiver na sua extremidade e precisar ser alterada ainda mais, a cabe√ßa ter√° que pular para outra extremidade da tela.  Por exemplo, uma dire√ß√£o √© definida para a esquerda e a coordenada X atual √© 0. Portanto, a nova coordenada X deve se tornar igual ao √∫ltimo endere√ßo horizontal. </li><li>  Novas coordenadas da cabe√ßa da cobra s√£o testadas contra as coordenadas da ma√ß√£: <br>  2.1  Caso sejam iguais e a matriz n√£o esteja cheia, adicione uma nova cauda √† matriz e aumente o contador da cauda.  Quando o contador atinge seu valor mais alto (128 no nosso caso), a bandeira do jogo ganho est√° sendo configurada e isso significa que a cobra n√£o pode mais crescer e o jogo ainda continua.  A nova cauda √© colocada nas coordenadas anteriores da cabe√ßa da cobra.  Coordenadas aleat√≥rias para X e Y devem ser tomadas para colocar uma ma√ß√£ l√°. <br>  2.2  Caso n√£o sejam iguais, troque sequencialmente as coordenadas das caudas adjacentes.  (n + 1) -√©sima cauda deve receber coordenadas de n-√©sima, caso a n-√©sima cauda tenha sido adicionada antes (n + 1) -√©sima.  A primeira cauda recebe coordenadas antigas da cabe√ßa. </li><li>  Verifique se as novas coordenadas da cabe√ßa da cobra coincidem com as coordenadas de qualquer cauda.  Se for esse o caso, a bandeira do fim do jogo √© levantada e o jogo para. </li></ol><br><h4 id="random-coordinate-generation">  Gera√ß√£o aleat√≥ria de coordenadas </h4><br><p>  N√∫meros aleat√≥rios produzidos tomando bits aleat√≥rios gerados pelos <em>registros de deslocamento de deslocamento linear de realimenta√ß√£o de</em> 6 bits <em>(LFSR)</em> <sup><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">6</a></sup> .  Para ajustar os n√∫meros em uma tela, eles est√£o sendo divididos pelas dimens√µes da grade do jogo e o restante √© obtido. </p><br><h2 id="conclusion">  Conclus√£o </h2><br><p>  Ap√≥s 8 semanas de trabalho, o projeto foi implementado com sucesso.  Tivemos alguma experi√™ncia em desenvolvimento de jogos e acabamos com uma vers√£o agrad√°vel de um jogo "Snake" para um FPGA.  O jogo √© jog√°vel e nossas habilidades em programa√ß√£o, design de arquitetura e soft-skills melhoraram. </p><br><h2 id="acknowledgments">  Segmentos reconhecidos </h2><br><p>  Gostar√≠amos de expressar nossos agradecimentos e gratid√£o especial aos professores <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Muhammad Fahim</a> e <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Alexander Tormasov</a> por nos fornecerem o conhecimento profundo e a oportunidade de coloc√°-lo em pr√°tica.  Agradecemos sinceramente a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Vladislav Ostankovich</a> por nos fornecer o hardware essencial usado no projeto e a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Temur Kholmatov</a> por ajudar na depura√ß√£o.  N√£o esquecer√≠amos de lembrar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Anastassiya Boiko</a> desenhando sprites bonitos para o jogo.  Al√©m disso, gostar√≠amos de estender nossas sinceras estima a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Rabab Marouf</a> pela revis√£o e edi√ß√£o deste artigo. </p><br><p>  Obrigado por todos aqueles que nos ajudaram a testar o jogo e tentaram estabelecer um recorde.  Espero que voc√™ goste de jogar! </p><br><h2 id="references">  Refer√™ncias </h2><br><p>  [1]: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Projeto no Github</a> <br>  [2]: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">[FPGA] Documenta√ß√£o da placa de inicia√ß√£o EP4CE6</a> <br>  [3]: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Divisor de tens√£o</a> <br>  [4]: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Ferramenta para modelagem de circuitos</a> <br>  [5]: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">adaptador VGA para FPGA Altera Cyclone III</a> <br>  [6]: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Registro de deslocamento de feedback linear (LFSR) na Wikipedia</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">LFSR em um FPGA - VHDL e c√≥digo Verilog</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Uma textura de ma√ß√£</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Ideia para gerar n√∫meros aleat√≥rios</a> <br>  Palnitkar, S. (2003).  <em>Verilog HDL: Um Guia para Design e S√≠ntese Digital, Segunda Edi√ß√£o.</em> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt431226/">https://habr.com/ru/post/pt431226/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt431212/index.html">Cache de pagina√ß√£o no Android</a></li>
<li><a href="../pt431216/index.html">Revis√£o do telefone IP Snom D345</a></li>
<li><a href="../pt431218/index.html">Como eu fiz um jogo de quadrinhos Lovecraft</a></li>
<li><a href="../pt431220/index.html">O olhar de um bi√≥logo sobre as ra√≠zes do nosso envelhecimento</a></li>
<li><a href="../pt431222/index.html">Arquivamento de sites</a></li>
<li><a href="../pt431228/index.html">Obst√°culo para luz: cristais l√≠quidos ajudam</a></li>
<li><a href="../pt431230/index.html">Armazenamento para infraestrutura HPC, ou como coletamos 65 PB de armazenamento no RIKEN Japan Research Center</a></li>
<li><a href="../pt431232/index.html">Geramos marcadores SVG bonitos no Node.js</a></li>
<li><a href="../pt431234/index.html">11 de dezembro de Moscou - Alfa JS MeetUp</a></li>
<li><a href="../pt431236/index.html">Como escrever no Objective-C em 2018. Parte 1</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>