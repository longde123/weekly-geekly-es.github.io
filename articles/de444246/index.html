<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üññ üß£ üì≠ √úberpr√ºfen von FreeRDP mit PVS-Studio üåå üë®üèª‚ÄçüöÄ üë®üèø‚Äçüíº</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="FreeRDP ist eine Open-Source-Implementierung des Remote Desktop Protocol (RDP), eines propriet√§ren Protokolls von Microsoft. Das Projekt unterst√ºtzt m...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>√úberpr√ºfen von FreeRDP mit PVS-Studio</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/pvs-studio/blog/444246/"><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1c7/bfa/fbf/1c7bfafbf3fc0d709f2725ea92fd830f.png" alt="Bild 2"></div><br>  FreeRDP ist eine Open-Source-Implementierung des Remote Desktop Protocol (RDP), eines propriet√§ren Protokolls von Microsoft.  Das Projekt unterst√ºtzt mehrere Plattformen, darunter Windows, Linux, MacOS und sogar iOS und Android.  Wir haben es als erstes Projekt ausgew√§hlt, das mit dem statischen Code-Analysator PVS-Studio f√ºr eine Reihe von Artikeln √ºber die √úberpr√ºfungen von RDP-Clients analysiert wurde. <br><a name="habracut"></a><br><h2>  Etwas Geschichte </h2><br>  Das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">FreeRDP-</a> Projekt wurde gestartet, nachdem Microsoft die Spezifikationen f√ºr das propriet√§re Protokoll RDP ge√∂ffnet hatte.  Zu diesem Zeitpunkt war bereits ein Client namens rdesktop im Einsatz, der haupts√§chlich auf Reverse Engineering-Arbeiten beruhte. <br><br>  Bei der Implementierung des Protokolls fiel es den Entwicklern aufgrund von Architekturproblemen schwer, neue Funktionen hinzuzuf√ºgen.  √Ñnderungen an der Architektur f√ºhrten zu einem Konflikt zwischen den Entwicklern und f√ºhrten zur Schaffung einer Verzweigung von rdesktop, die als FreeRDP bekannt ist.  Die weitere Verbreitung wurde durch die GPLv2-Lizenz eingeschr√§nkt, und die Autoren entschieden sich f√ºr eine erneute Lizenzierung an Apache License v2.  Einige waren jedoch nicht bereit, die Lizenz zu √§ndern, und so beschlossen die Entwickler, die Codebasis von Grund auf neu zu schreiben, und so entstand das Projekt, wie wir es heute kennen. <br><br>  Die vollst√§ndige Geschichte des Projekts finden Sie im offiziellen Blog: " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Die Geschichte des FreeRDP-Projekts</a> ". <br><br>  Ich habe <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">PVS-Studio verwendet</a> , um das Projekt nach Fehlern und potenziellen Schwachstellen zu durchsuchen.  PVS-Studio ist ein statischer Analysator f√ºr Code, der in C, C ++, C # und Java geschrieben wurde und unter Windows, Linux und macOS ausgef√ºhrt wird. <br><br>  Beachten Sie, dass ich nur die Fehler besprechen werde, die f√ºr mich am interessantesten waren. <br><br><h2>  Speicherverlust </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V773</a> Die Funktion wurde beendet, ohne den Zeiger 'cwd' loszulassen.  Ein Speicherverlust ist m√∂glich.  Umwelt.c 84 <br><br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">DWORD </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetCurrentDirectoryA</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(DWORD nBufferLength, LPSTR lpBuffer)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>* cwd; .... cwd = getcwd(<span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (lpBuffer == <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>) { <span class="hljs-built_in"><span class="hljs-built_in">free</span></span>(cwd); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((length + <span class="hljs-number"><span class="hljs-number">1</span></span>) &gt; nBufferLength) { <span class="hljs-built_in"><span class="hljs-built_in">free</span></span>(cwd); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (DWORD) (length + <span class="hljs-number"><span class="hljs-number">1</span></span>); } <span class="hljs-built_in"><span class="hljs-built_in">memcpy</span></span>(lpBuffer, cwd, length + <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> length; .... }</code> </pre> <br>  Dieses Snippet stammt aus dem winpr-Subsystem, das einen WINAPI-Wrapper f√ºr Nicht-Windows-Systeme implementiert, dh als leichteres √Ñquivalent zu Wine fungiert.  Der obige Code enth√§lt einen Speicherverlust: Der von der Funktion <i>getcwd</i> zugewiesene Speicher wird nur in Sonderfallzweigen freigegeben.  Um dies zu beheben, sollten die Autoren nach dem Aufruf von <i>memcpy</i> einen <i>kostenlosen</i> Aufruf hinzuf√ºgen. <br><br><h2>  Array-Index au√üerhalb der Grenzen </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V557</a> Array-√úberlauf ist m√∂glich.  Der Wert des Index 'event-&gt; EventHandlerCount' k√∂nnte 32 erreichen. PubSub.c 117 <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MAX_EVENT_HANDLERS 32 struct _wEventType { .... int EventHandlerCount; pEventHandler EventHandlers[MAX_EVENT_HANDLERS]; }; int PubSub_Subscribe(wPubSub* pubSub, const char* EventName, pEventHandler EventHandler) { .... </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (event-&gt;EventHandlerCount </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;= MAX_EVENT_HANDLERS) { event-&gt;EventHandlers[event-&gt;EventHandlerCount] = EventHandler; event-&gt;EventHandlerCount++; } .... }</span></span></span></span></code> </pre> <br>  In diesem Beispiel wird der Liste ein neues Element hinzugef√ºgt, auch wenn dieses bereits die maximale Anzahl von Elementen erreicht hat.  Dieser Fehler kann behoben werden, indem einfach der Operator <i>&lt;=</i> durch <i>&lt;ersetzt wird</i> . <br><br>  Der Analysator hat einen weiteren Fehler dieses Typs gefunden: <br><br><ul><li>  V557 Array-√úberlauf ist m√∂glich.  Der Wert des 'iBitmapFormat'-Index k√∂nnte 8 Bestellungen erreichen.c 2623 </li></ul><br><h2>  Tippfehler </h2><br><h3>  Snippet 1 </h3><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V547</a> Ausdruck '! Pipe-&gt; In' ist immer falsch.  MessagePipe.c 63 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">wMessagePipe* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MessagePipe_New</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ .... pipe-&gt;In = MessageQueue_New(<span class="hljs-literal"><span class="hljs-literal">NULL</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!pipe-&gt;In) <span class="hljs-keyword"><span class="hljs-keyword">goto</span></span> error_in; pipe-&gt;Out = MessageQueue_New(<span class="hljs-literal"><span class="hljs-literal">NULL</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!pipe-&gt;In) <span class="hljs-comment"><span class="hljs-comment">// &lt;= goto error_out; ....</span></span></code> </pre> <br>  }} <br><br>  Was wir hier sehen, ist ein gew√∂hnlicher Tippfehler: Sowohl die erste als auch die zweite Bedingung pr√ºfen dieselbe Variable.  Es sieht aus wie ein Produkt von schlechtem Copy-Paste. <br><br><h3>  Snippet 2 </h3><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V760 Es wurden</a> zwei identische Textbl√∂cke gefunden.  Der zweite Block beginnt in Zeile 771. tsg.c 770 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TSG_PACKET_VERSIONCAPS</span></span></span><span class="hljs-class"> {</span></span> .... UINT16 majorVersion; UINT16 minorVersion; .... } TSG_PACKET_VERSIONCAPS, *PTSG_PACKET_VERSIONCAPS; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> BOOL </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TsProxyCreateTunnelReadResponse</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ .... PTSG_PACKET_VERSIONCAPS versionCaps = <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; .... <span class="hljs-comment"><span class="hljs-comment">/* MajorVersion (2 bytes) */</span></span> Stream_Read_UINT16(pdu-&gt;s, versionCaps-&gt;majorVersion); <span class="hljs-comment"><span class="hljs-comment">/* MinorVersion (2 bytes) */</span></span> Stream_Read_UINT16(pdu-&gt;s, versionCaps-&gt;majorVersion); .... }</code> </pre> <br>  Ein weiterer Tippfehler: Der Kommentar besagt, dass wir erwarten sollten, dass die Variable <i>minorVersion</i> aus dem Stream gelesen wird, w√§hrend der Wert in die Variable <i>majorVersion eingelesen wird</i> .  Ich bin mit dem Projekt jedoch nicht gut genug vertraut, um es mit Sicherheit zu sagen. <br><br><h3>  Snippet 3 </h3><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V524</a> Es ist seltsam, dass der Hauptteil der Funktion 'trio_index_last' dem Hauptteil der Funktion 'trio_index' vollst√§ndig entspricht.  triostr.c 933 <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/** Find first occurrence of a character in a string. .... */</span></span> <span class="hljs-function"><span class="hljs-function">TRIO_PUBLIC_STRING </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">char</span></span></span><span class="hljs-function"> * trio_index </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TRIO_ARGS2</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">((</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">, character), TRIO_CONST </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> character)</span></span></span><span class="hljs-function"> </span></span>{ assert(<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">strchr</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>, character); } <span class="hljs-comment"><span class="hljs-comment">/** Find last occurrence of a character in a string. .... */</span></span> <span class="hljs-function"><span class="hljs-function">TRIO_PUBLIC_STRING </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">char</span></span></span><span class="hljs-function"> * trio_index_last </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TRIO_ARGS2</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">((</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">, character), TRIO_CONST </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> character)</span></span></span><span class="hljs-function"> </span></span>{ assert(<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">strchr</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>, character); }</code> </pre> <br>  Wie aus dem Kommentar hervorgeht, findet die Funktion <i>trio_index</i> das erste Zeichen in der Zeichenfolge, w√§hrend die Funktion <i>trio_index_last</i> das letzte Vorkommen findet.  Die K√∂rper dieser beiden Funktionen sind jedoch genau gleich!  Dies muss ein Tippfehler sein und die Funktion <i>trio_index_last</i> sollte wahrscheinlich <i>strrchr</i> anstelle von <i>strchr zur√ºckgeben.</i> In diesem Fall w√ºrde sich das Programm wie erwartet verhalten. <br><br><h3>  Snippet 4 </h3><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V769</a> Der ' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Daten'</a> -Zeiger im Ausdruck entspricht nullptr.  Der resultierende Wert von arithmetischen Operationen f√ºr diesen Zeiger ist sinnlos und sollte nicht verwendet werden.  nsc_encode.c 124 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> BOOL </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">nsc_encode_argb_to_aycocg</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(NSC_CONTEXT* context, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> BYTE* data, UINT32 scanline)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!context || data || (scanline == <span class="hljs-number"><span class="hljs-number">0</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> FALSE; .... src = data + (context-&gt;height - <span class="hljs-number"><span class="hljs-number">1</span></span> - y) * scanline; .... }</code> </pre> <br>  Der Entwickler muss versehentlich den Negationsoperator ausgelassen haben <i>!</i>  vor <i>Daten</i> .  Ich frage mich, warum es niemand fr√ºher bemerkt hat. <br><br><h3>  Snippet 5 </h3><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V517</a> Die Verwendung des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Musters</a> 'if (A) {...} else if (A) {...}' wurde erkannt.  Es besteht die Wahrscheinlichkeit eines logischen Fehlers.  √úberpr√ºfen Sie die Zeilen: 213, 222. rdpei_common.c 213 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">BOOL </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">rdpei_write_4byte_unsigned</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(wStream* s, UINT32 value)</span></span></span><span class="hljs-function"> </span></span>{ BYTE byte; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (value &lt;= <span class="hljs-number"><span class="hljs-number">0x3F</span></span>) { .... } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (value &lt;= <span class="hljs-number"><span class="hljs-number">0x3FFF</span></span>) { .... } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (value &lt;= <span class="hljs-number"><span class="hljs-number">0x3FFFFF</span></span>) { byte = (value &gt;&gt; <span class="hljs-number"><span class="hljs-number">16</span></span>) &amp; <span class="hljs-number"><span class="hljs-number">0x3F</span></span>; Stream_Write_UINT8(s, byte | <span class="hljs-number"><span class="hljs-number">0x80</span></span>); byte = (value &gt;&gt; <span class="hljs-number"><span class="hljs-number">8</span></span>) &amp; <span class="hljs-number"><span class="hljs-number">0xFF</span></span>; Stream_Write_UINT8(s, byte); byte = (value &amp; <span class="hljs-number"><span class="hljs-number">0xFF</span></span>); Stream_Write_UINT8(s, byte); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (value &lt;= <span class="hljs-number"><span class="hljs-number">0x3FFFFF</span></span>) { byte = (value &gt;&gt; <span class="hljs-number"><span class="hljs-number">24</span></span>) &amp; <span class="hljs-number"><span class="hljs-number">0x3F</span></span>; Stream_Write_UINT8(s, byte | <span class="hljs-number"><span class="hljs-number">0xC0</span></span>); byte = (value &gt;&gt; <span class="hljs-number"><span class="hljs-number">16</span></span>) &amp; <span class="hljs-number"><span class="hljs-number">0xFF</span></span>; Stream_Write_UINT8(s, byte); byte = (value &gt;&gt; <span class="hljs-number"><span class="hljs-number">8</span></span>) &amp; <span class="hljs-number"><span class="hljs-number">0xFF</span></span>; Stream_Write_UINT8(s, byte); byte = (value &amp; <span class="hljs-number"><span class="hljs-number">0xFF</span></span>); Stream_Write_UINT8(s, byte); } .... }</code> </pre> <br>  Die letzten beiden Bedingungen sind dieselben: Der Programmierer muss vergessen haben, die Kopie zu √§ndern.  Nach der Logik des Codes zu urteilen, behandelt der letzte Teil Vier-Byte-Werte, sodass wir davon ausgehen k√∂nnen, dass die letzte Bedingung pr√ºfen sollte, ob der <i>Wert &lt;= 0x3FFFFFFF ist</i> . <br><br>  Ein weiterer Fehler dieses Typs: <br><br><ul><li>  V517 Die Verwendung des Musters 'if (A) {...} else if (A) {...}' wurde erkannt.  Es besteht die Wahrscheinlichkeit eines logischen Fehlers.  √úberpr√ºfen Sie die Zeilen: 169, 173. file.c 169 </li></ul><br><h2>  Eingabedaten √ºberpr√ºfen </h2><br><h3>  Snippet 1 </h3><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V547 Der</a> Ausdruck 'strcat (Ziel, Quelle)! = NULL' ist immer wahr.  triostr.c 425 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">TRIO_PUBLIC_STRING </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> trio_append </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TRIO_ARGS2</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">((target, source), </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *target, TRIO_CONST </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *source)</span></span></span><span class="hljs-function"> </span></span>{ assert(target); assert(source); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">strcat</span></span>(target, source) != <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>); }</code> </pre> <br>  Die √úberpr√ºfung des R√ºckgabewerts der Funktion ist fehlerhaft.  Die <i>strcat-</i> Funktion gibt einen Zeiger auf die Zielzeichenfolge zur√ºck, d. H. Den ersten Parameter, der in diesem Fall <i>target ist</i> .  Wenn es jedoch gleich NULL ist, ist es zu sp√§t, dies zu √ºberpr√ºfen, da es in der <i>strcat-</i> Funktion bereits dereferenziert wurde. <br><br><h3>  Snippet 2 </h3><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V547</a> Ausdruck 'Cache' ist immer wahr.  Glyphe c 730 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">rdp_glyph_cache</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">rdpGlyphCache</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">rdp_glyph_cache</span></span></span><span class="hljs-class"> {</span></span> .... GLYPH_CACHE glyphCache[<span class="hljs-number"><span class="hljs-number">10</span></span>]; .... }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">glyph_cache_free</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(rdpGlyphCache* glyphCache)</span></span></span><span class="hljs-function"> </span></span>{ .... GLYPH_CACHE* cache = glyphCache-&gt;glyphCache; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cache) { .... } .... }</code> </pre> <br>  In diesem Snippet wird der <i>Cache-</i> Variablen die Adresse des statischen Arrays <i>glyphCache-&gt; glyphCache zugewiesen</i> .  Die Pr√ºfung <i>ob (Cache)</i> kann daher entfernt werden. <br><br><h2>  Ressourcenverwaltungsfehler </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V1005</a> Die Ressource wurde mit der Funktion 'CreateFileA' erfasst, aber mit der inkompatiblen Funktion 'fclose' freigegeben.  Zertifikat.c 447 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">BOOL </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">certificate_data_replace</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(rdpCertificateStore* certificate_store, rdpCertificateData* certificate_data)</span></span></span><span class="hljs-function"> </span></span>{ HANDLE fp; .... fp = CreateFileA(certificate_store-&gt;file, GENERIC_READ | GENERIC_WRITE, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>); .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (size &lt; <span class="hljs-number"><span class="hljs-number">1</span></span>) { CloseHandle(fp); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> FALSE; } .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!data) { fclose(fp); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> FALSE; } .... }</code> </pre> <br>  Das <i>fp-</i> Handle f√ºr die von der Funktion <i>CreateFile</i> erstellte Datei wurde versehentlich geschlossen, indem die Funktion <i>fclose</i> aus der Standardbibliothek anstelle der Funktion <i>CloseHandle aufgerufen wurde</i> . <br><br><h2>  Identische Bedingungen </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V581</a> Die bedingten Ausdr√ºcke der nebeneinander angeordneten if-Anweisungen sind identisch.  √úberpr√ºfen Sie die Zeilen: 269, 283. ndr_structure.c 283 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">NdrComplexStructBufferSize</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(PMIDL_STUB_MESSAGE pStubMsg, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params">* pMemory, PFORMAT_STRING pFormat)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (conformant_array_description) { ULONG size; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> array_type; array_type = conformant_array_description[<span class="hljs-number"><span class="hljs-number">0</span></span>]; size = NdrComplexStructMemberSize(pStubMsg, pFormat); WLog_ERR(TAG, <span class="hljs-string"><span class="hljs-string">"warning: NdrComplexStructBufferSize array_type: "</span></span> <span class="hljs-string"><span class="hljs-string">"0x%02X unimplemented"</span></span>, array_type); NdrpComputeConformance(pStubMsg, pMemory + size, conformant_array_description); NdrpComputeVariance(pStubMsg, pMemory + size, conformant_array_description); MaxCount = pStubMsg-&gt;MaxCount; ActualCount = pStubMsg-&gt;ActualCount; Offset = pStubMsg-&gt;Offset; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (conformant_array_description) { <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> array_type; array_type = conformant_array_description[<span class="hljs-number"><span class="hljs-number">0</span></span>]; pStubMsg-&gt;MaxCount = MaxCount; pStubMsg-&gt;ActualCount = ActualCount; pStubMsg-&gt;Offset = Offset; WLog_ERR(TAG, <span class="hljs-string"><span class="hljs-string">"warning: NdrComplexStructBufferSize array_type: "</span></span> <span class="hljs-string"><span class="hljs-string">"0x%02X unimplemented"</span></span>, array_type); } .... }</code> </pre> <br>  Dieses Snippet mag korrekt sein, aber es ist verd√§chtig, dass beide Bedingungen identische Nachrichten enthalten - eine davon ist wahrscheinlich nicht erforderlich. <br><br><h2>  Nullzeiger freigeben </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V575</a> Der Nullzeiger wird an die Funktion 'frei' √ºbergeben.  √úberpr√ºfen Sie das erste Argument.  smartcard_pcsc.c 875 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">WINSCARDAPI LONG WINAPI </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PCSC_SCardListReadersW</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( SCARDCONTEXT hContext, LPCWSTR mszGroups, LPWSTR mszReaders, LPDWORD pcchReaders)</span></span></span><span class="hljs-function"> </span></span>{ LPSTR mszGroupsA = <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; .... mszGroups = <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; <span class="hljs-comment"><span class="hljs-comment">/* mszGroups is not supported by pcsc-lite */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (mszGroups) ConvertFromUnicode(CP_UTF8,<span class="hljs-number"><span class="hljs-number">0</span></span>, mszGroups, <span class="hljs-number"><span class="hljs-number">-1</span></span>, (<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>**) &amp;mszGroupsA, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>); status = PCSC_SCardListReaders_Internal(hContext, mszGroupsA, (LPSTR) &amp;mszReadersA, pcchReaders); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (status == SCARD_S_SUCCESS) { .... } <span class="hljs-built_in"><span class="hljs-built_in">free</span></span>(mszGroupsA); .... }</code> </pre> <br>  Die <i>freie</i> Funktion kann auf einem Nullzeiger aufgerufen werden, und PVS-Studio wei√ü das.  Wenn sich herausstellt, dass der Zeiger wie in diesem Snippet immer null ist, gibt der Analysator eine Warnung aus. <br><br>  Der Zeiger <i>mszGroupsA</i> wird anf√§nglich auf <i>NULL gesetzt</i> und nirgendwo anders initialisiert.  Der einzige Zweig, in dem es initialisiert werden k√∂nnte, ist nicht erreichbar. <br><br>  Einige andere Warnungen dieses Typs: <br><br><ul><li>  V575 Der Nullzeiger wird an die Funktion 'frei' √ºbergeben.  √úberpr√ºfen Sie das erste Argument.  Lizenz.c 790 </li><li>  V575 Der Nullzeiger wird an die Funktion 'frei' √ºbergeben.  √úberpr√ºfen Sie das erste Argument.  rdpsnd_alsa.c 575 </li></ul><br>  Solche verlassenen Variablen scheinen R√ºckst√§nde zu sein, die nach dem Refactoring zur√ºckgeblieben sind und entfernt werden k√∂nnen. <br><br><h2>  M√∂glicher √úberlauf </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V1028</a> M√∂glicher √úberlauf.  Betrachten Sie das Casting von Operanden, nicht das Ergebnis.  makecert.c 1087 <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// openssl/x509.h ASN1_TIME *X509_gmtime_adj(ASN1_TIME *s, long adj); struct _MAKECERT_CONTEXT { .... int duration_years; int duration_months; }; typedef struct _MAKECERT_CONTEXT MAKECERT_CONTEXT; int makecert_context_process(MAKECERT_CONTEXT* context, ....) { .... if (context-&gt;duration_months) X509_gmtime_adj(after, (long)(60 * 60 * 24 * 31 * context-&gt;duration_months)); else if (context-&gt;duration_years) X509_gmtime_adj(after, (long)(60 * 60 * 24 * 365 * context-&gt;duration_years)); .... }</span></span></code> </pre> <br>  Wenn Sie das Ausdrucksergebnis zu <i>lang setzen,</i> wird ein √úberlauf nicht verhindert, da die Auswertung des Werts erfolgt, solange dieser noch vom Typ <i>int ist</i> . <br><br><h2>  Dereferenzierungszeiger bei der Initialisierung </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V595</a> Der ' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Kontext'</a> -Zeiger wurde verwendet, bevor er gegen nullptr verifiziert wurde.  √úberpr√ºfen Sie die Zeilen: 746, 748. gfx.c 746 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> UINT </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">gdi_SurfaceCommand</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(RdpgfxClientContext* context, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> RDPGFX_SURFACE_COMMAND* cmd)</span></span></span><span class="hljs-function"> </span></span>{ .... rdpGdi* gdi = (rdpGdi*) context-&gt;custom; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!context || !cmd) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ERROR_INVALID_PARAMETER; .... }</code> </pre> <br>  Der <i>Kontextzeiger</i> wird w√§hrend seiner Initialisierung, dh vor der Pr√ºfung, dereferenziert. <br><br>  Andere Fehler dieses Typs: <br><br><ul><li>  V595 Der Zeiger 'ntlm' wurde verwendet, bevor er gegen nullptr verifiziert wurde.  √úberpr√ºfen Sie die Zeilen: 236, 255. ntlm.c 236 </li><li>  V595 Der 'Kontext'-Zeiger wurde verwendet, bevor er gegen nullptr verifiziert wurde.  √úberpr√ºfen Sie die Zeilen: 1003, 1007. rfx.c 1003 </li><li>  V595 Der Zeiger 'rdpei' wurde verwendet, bevor er gegen nullptr verifiziert wurde.  √úberpr√ºfen Sie die Zeilen: 176, 180. rdpei_main.c 176 </li><li>  V595 Der Zeiger 'gdi' wurde verwendet, bevor er gegen nullptr verifiziert wurde.  √úberpr√ºfen Sie die Zeilen: 121, 123. xf_gfx.c 121 </li></ul><br><h2>  Sinnloser Zustand </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V547 Der</a> Ausdruck 'rdp-&gt; state&gt; = CONNECTION_STATE_ACTIVE' ist immer wahr.  Verbindung.c 1489 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">rdp_server_transition_to_state</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(rdpRdp* rdp, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> state)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (state) { .... <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> CONNECTION_STATE_ACTIVE: rdp-&gt;state = CONNECTION_STATE_ACTIVE; <span class="hljs-comment"><span class="hljs-comment">// &lt;= .... if (rdp-&gt;state &gt;= CONNECTION_STATE_ACTIVE) // &lt;= { IFCALLRET(client-&gt;Activate, client-&gt;activated, client); if (!client-&gt;activated) return -1; } .... } .... }</span></span></code> </pre> <br>  Es ist leicht zu erkennen, dass die erste Bedingung keinen Sinn ergibt, da der betreffende Wert bereits zuvor zugewiesen wurde. <br><br><h2>  Falsche Zeichenfolgenbehandlung </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V576</a> Falsches Format.  √úberpr√ºfen Sie das dritte tats√§chliche Argument der Funktion 'sscanf'.  Ein Zeiger auf den vorzeichenlosen int-Typ wird erwartet.  proxy.c 220 <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V560</a> Ein Teil des bedingten Ausdrucks ist immer wahr: (rc&gt; = 0).  proxy.c 222 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> BOOL </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">check_no_proxy</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> sub; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> rc = <span class="hljs-built_in"><span class="hljs-built_in">sscanf</span></span>(range, <span class="hljs-string"><span class="hljs-string">"%u"</span></span>, &amp;sub); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((rc == <span class="hljs-number"><span class="hljs-number">1</span></span>) &amp;&amp; (rc &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span>)) { .... } .... }</code> </pre> <br>  Dieser Code l√∂st zwei Warnungen gleichzeitig aus.  Der Platzhalter <i>% u</i> wird f√ºr Variablen vom Typ <i>int ohne Vorzeichen verwendet</i> , w√§hrend die <i>Untervariable</i> vom Typ <i>int ist</i> .  Die zweite Warnung weist auf eine verd√§chtige Pr√ºfung hin: Der rechte Teil des bedingten Ausdrucks ist nicht sinnvoll, da die Variable im linken Teil bereits auf 1 gepr√ºft wurde.  Ich bin mir √ºber die Absichten des Autors nicht sicher, aber mit diesem Code stimmt offensichtlich etwas nicht. <br><br><h2>  √úberpr√ºft in der falschen Reihenfolge </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V547 Der</a> Ausdruck 'status == 0x00090314' ist immer falsch.  ntlm.c 299 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">BOOL </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ntlm_authenticate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(rdpNtlm* ntlm, BOOL* pbContinueNeeded)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (status != SEC_E_OK) { .... <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> FALSE; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (status == SEC_I_COMPLETE_NEEDED) <span class="hljs-comment"><span class="hljs-comment">// &lt;= status = SEC_E_OK; else if (status == SEC_I_COMPLETE_AND_CONTINUE) // &lt;= status = SEC_I_CONTINUE_NEEDED; .... }</span></span></code> </pre> <br>  Die markierten Bedingungen sind immer falsch, da die zweite Bedingung nur ausgef√ºhrt werden kann, wenn <i>status == SEC_E_OK</i> .  So k√∂nnte die richtige Version aussehen: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (status == SEC_I_COMPLETE_NEEDED) status = SEC_E_OK; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (status == SEC_I_COMPLETE_AND_CONTINUE) status = SEC_I_CONTINUE_NEEDED; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (status != SEC_E_OK) { .... <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> FALSE; }</code> </pre> <br><h2>  Fazit </h2><br>  Die √úberpr√ºfung ergab viele Fehler, und die oben diskutierten sind nur die interessantesten.  Die Projektentwickler k√∂nnen gerne ein Formular f√ºr einen tempor√§ren Lizenzschl√ºssel auf der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">PVS-Studio-</a> Website einreichen, um ihre eigene Pr√ºfung durchzuf√ºhren.  Der Analysator hat auch eine Reihe von Fehlalarmen erzeugt, die wir beheben werden, um seine Leistung zu verbessern.  Beachten Sie, dass eine statische Analyse unabdingbar ist, wenn Sie nicht nur die Codequalit√§t verbessern, sondern auch die Fehlersuche weniger zeitaufw√§ndig machen m√∂chten - und hier ist PVS-Studio hilfreich. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de444246/">https://habr.com/ru/post/de444246/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de444234/index.html">DeepMind und Google: Der Kampf um die Kontrolle √ºber starke KI</a></li>
<li><a href="../de444238/index.html">Verweigern Sie mit einem Klick, oder wie ein Designer einen Traumjob bekommt</a></li>
<li><a href="../de444240/index.html">Spring Data JPA: Dateien bringen</a></li>
<li><a href="../de444242/index.html">√úberpr√ºfen von FreeRDP mit dem PVS-Studio-Analyseger√§t</a></li>
<li><a href="../de444244/index.html">Bewegung durch Raum und Zeit</a></li>
<li><a href="../de444248/index.html">Kopfloses Testen in einem Browser. Vorteile und Nachteile</a></li>
<li><a href="../de444250/index.html">Sind die Leute nicht bereit f√ºr Bitcoin oder Bitcoin f√ºr die Massenadoption?</a></li>
<li><a href="../de444252/index.html">AMD k√ºndigt seine 3D-Chip-Architektur an, um mit Intel Foveros 3D Schritt zu halten</a></li>
<li><a href="../de444254/index.html">Serveranalysesysteme</a></li>
<li><a href="../de444256/index.html">Mein erster Sharp PC3000 Reader</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>