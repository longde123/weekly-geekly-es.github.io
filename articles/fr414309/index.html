<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨🏽‍🏭 🤘🏿 🧕🏼 Mode non canonique du terminal et entrée non bloquante sur nasm 🕒 ☸️ 💇🏽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="L'idée d'écrire un jeu en langage assembleur, bien sûr, est peu susceptible de venir à l'esprit de quelqu'un par lui-même, cependant, une telle forme ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Mode non canonique du terminal et entrée non bloquante sur nasm</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/414309/">  L'idée d'écrire un jeu en langage assembleur, bien sûr, est peu susceptible de venir à l'esprit de quelqu'un par lui-même, cependant, une telle forme sophistiquée de reportage est pratiquée depuis longtemps au cours de la première année du VMK de l'Université d'État de Moscou.  Mais comme les progrès ne s'arrêtent pas, DOS et Masm entrent dans l'histoire, et Nasm et Linux arrivent au premier plan de la préparation des bachelors.  Peut-être que dans dix ans, la direction de la faculté découvrira le python, mais ce n'est plus le sujet maintenant. <br><br>  La programmation de l'assembleur sous Linux, avec tous ses avantages, rend impossible l'utilisation des interruptions du BIOS et, par conséquent, les prive de fonctionnalités.  Au lieu de cela, ils doivent utiliser les appels système et contacter l'API du terminal.  Par conséquent, écrire un simulateur de blackjack ou de bataille navale ne pose pas de grandes difficultés, et il y a des problèmes avec le serpent le plus ordinaire.  Le fait est que le système d'entrée-sortie est contrôlé par le terminal, et les fonctions du système C ne peuvent pas être utilisées directement.  Par conséquent, lors de l'écriture de jeux même assez simples, deux pierres d'achoppement sont nées: comment faire passer le terminal en mode non canonique et comment rendre l'entrée clavier non bloquante.  Cela sera discuté dans l'article. <br><a name="habracut"></a><br><h3>  1. Mode non canonique du terminal </h3><br>  Comme vous le savez, pour comprendre ce que fait une fonction en C, vous devez penser comme une fonction en C.  Heureusement, le passage du terminal en mode non canonique n'est pas si difficile.  Voici ce que l' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">exemple de la documentation officielle de GNU</a> nous donne si vous en supprimez le code d'assistance: <br><br><pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">termios</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">saved_attributes</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">reset_input_mode</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ tcsetattr (STDIN_FILENO, TCSANOW, &amp;saved_attributes); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">set_input_mode</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">termios</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">tattr</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-comment"><span class="hljs-comment">/* Save the terminal attributes so we can restore them later. */</span></span> tcgetattr (STDIN_FILENO, &amp;saved_attributes); <span class="hljs-comment"><span class="hljs-comment">/* Set the funny terminal modes. */</span></span> tcgetattr (STDIN_FILENO, &amp;tattr); tattr.c_lflag &amp;= ~(ICANON|ECHO); <span class="hljs-comment"><span class="hljs-comment">/* Clear ICANON and ECHO. */</span></span> tcsetattr (STDIN_FILENO, TCSAFLUSH, &amp;tattr); }</code> </pre> <br>  Dans ce code, STDIN_FILENO signifie la poignée du flux d'entrée avec lequel nous travaillons (par défaut, il est 0), ICANON est le drapeau d'activation pour la même entrée canonique, ECHO est le drapeau pour afficher les caractères d'entrée à l'écran et TCSANOW et TCSAFLUSH sont des macros définies par la bibliothèque.  Ainsi, l'algorithme «nu», dépourvu de contrôles de sécurité, ressemble à ceci: <br><br><ol><li>  conserver la structure d'origine des termios; </li><li>  copier son contenu avec le changement des drapeaux ICANON et ECHO; </li><li>  envoyer la structure modifiée au terminal; </li><li>  à la fin des travaux, restituer au terminal la structure enregistrée. </li></ol><br>  Reste à comprendre ce que font les fonctions de bibliothèque tcsetattr et tcgetattr.  <a href="">En fait,</a> ils font beaucoup de choses, mais l' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">appel</a> système <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ioctl</a> est la clé de leur travail.  Le premier argument qu'il prend est un descripteur de flux (0 dans notre cas), le second est un ensemble d'indicateurs qui sont juste définis par les macros TCSANOW et TCSAFLUSH, et le troisième est un pointeur sur la structure (dans notre cas termios).  Sur la syntaxe nasm et sous la convention des appels système sur linux, elle prendra la forme suivante: <br><br><pre> <code class="hljs perl"> mov rax, <span class="hljs-number"><span class="hljs-number">16</span></span> ;   ioctl mov rdi, <span class="hljs-number"><span class="hljs-number">0</span></span> ;    mov rsi, TCGETS ;  mov rdx, tattr ;     <span class="hljs-keyword"><span class="hljs-keyword">syscall</span></span></code> </pre><br>  En général, c'est tout l'intérêt des fonctions tcsetattr et tcgetattr.  Pour le reste du code, nous devons connaître la taille et la structure de la structure termios, qui est également facile à trouver dans la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">documentation officielle</a> .  Sa taille par défaut est de 60 octets, et le tableau d'indicateurs dont nous avons besoin est de 4 octets et est situé quatrième dans une rangée.  Il reste à écrire deux procédures et à les combiner en un seul code. <br><br>  Sous le spoiler, sa mise en œuvre la plus simple n'est en aucun cas la plus sécurisée, mais elle fonctionne assez bien sur tout système d'exploitation prenant en charge les normes POSIX.  Les valeurs macro ont été tirées des sources susmentionnées de la bibliothèque C standard. <br><br><div class="spoiler">  <b class="spoiler_title">Transfert en mode non canonique</b> <div class="spoiler_text"><pre> <code class="hljs perl">%define ICANON <span class="hljs-number"><span class="hljs-number">2</span></span> %define ECHO <span class="hljs-number"><span class="hljs-number">8</span></span> %define TCGETS <span class="hljs-number"><span class="hljs-number">21505</span></span> ;    %define TCPUTS <span class="hljs-number"><span class="hljs-number">21506</span></span> ;    global setcan ;     global setnoncan ;     section .bss stty resb <span class="hljs-number"><span class="hljs-number">12</span></span> ; termios - <span class="hljs-number"><span class="hljs-number">60</span></span>  slflag resb <span class="hljs-number"><span class="hljs-number">4</span></span> ;slflag    <span class="hljs-number"><span class="hljs-number">3</span></span>*<span class="hljs-number"><span class="hljs-number">4</span></span>   srest resb <span class="hljs-number"><span class="hljs-number">44</span></span> tty resb <span class="hljs-number"><span class="hljs-number">12</span></span> lflag resb <span class="hljs-number"><span class="hljs-number">4</span></span> brest resb <span class="hljs-number"><span class="hljs-number">44</span></span> section .text setnoncan: <span class="hljs-keyword"><span class="hljs-keyword">push</span></span> stty call tcgetattr <span class="hljs-keyword"><span class="hljs-keyword">push</span></span> tty call tcgetattr <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> dword[lflag], (~ICANON) <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> dword[lflag], (~ECHO) call tcsetattr add rsp, <span class="hljs-number"><span class="hljs-number">16</span></span> ret setcan: <span class="hljs-keyword"><span class="hljs-keyword">push</span></span> stty call tcsetattr add rsp, <span class="hljs-number"><span class="hljs-number">8</span></span> ret tcgetattr: mov rdx, qword[rsp+<span class="hljs-number"><span class="hljs-number">8</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">push</span></span> rax <span class="hljs-keyword"><span class="hljs-keyword">push</span></span> rbx <span class="hljs-keyword"><span class="hljs-keyword">push</span></span> rcx <span class="hljs-keyword"><span class="hljs-keyword">push</span></span> rdi <span class="hljs-keyword"><span class="hljs-keyword">push</span></span> rsi mov rax, <span class="hljs-number"><span class="hljs-number">16</span></span> ;ioctl <span class="hljs-keyword"><span class="hljs-keyword">system</span></span> call mov rdi, <span class="hljs-number"><span class="hljs-number">0</span></span> mov rsi, TCGETS <span class="hljs-keyword"><span class="hljs-keyword">syscall</span></span> <span class="hljs-keyword"><span class="hljs-keyword">pop</span></span> rsi <span class="hljs-keyword"><span class="hljs-keyword">pop</span></span> rdi <span class="hljs-keyword"><span class="hljs-keyword">pop</span></span> rcx <span class="hljs-keyword"><span class="hljs-keyword">pop</span></span> rbx <span class="hljs-keyword"><span class="hljs-keyword">pop</span></span> rax ret tcsetattr: mov rdx, qword[rsp+<span class="hljs-number"><span class="hljs-number">8</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">push</span></span> rax <span class="hljs-keyword"><span class="hljs-keyword">push</span></span> rbx <span class="hljs-keyword"><span class="hljs-keyword">push</span></span> rcx <span class="hljs-keyword"><span class="hljs-keyword">push</span></span> rdi <span class="hljs-keyword"><span class="hljs-keyword">push</span></span> rsi mov rax, <span class="hljs-number"><span class="hljs-number">16</span></span> ;ioctl <span class="hljs-keyword"><span class="hljs-keyword">system</span></span> call mov rdi, <span class="hljs-number"><span class="hljs-number">0</span></span> mov rsi, TCPUTS <span class="hljs-keyword"><span class="hljs-keyword">syscall</span></span> <span class="hljs-keyword"><span class="hljs-keyword">pop</span></span> rsi <span class="hljs-keyword"><span class="hljs-keyword">pop</span></span> rdi <span class="hljs-keyword"><span class="hljs-keyword">pop</span></span> rcx <span class="hljs-keyword"><span class="hljs-keyword">pop</span></span> rbx <span class="hljs-keyword"><span class="hljs-keyword">pop</span></span> rax ret</code> </pre><br></div></div><br><h3>  2. Entrée non bloquante dans le terminal </h3><br>  Pour une entrée de fonds non bloquante, le terminal ne nous suffit pas.  Nous allons écrire une fonction qui vérifiera si le tampon de flux standard est prêt à transmettre des informations: s'il y a un symbole dans le tampon, il retournera son code;  si le tampon est vide, il retournera 0. Pour cela, vous pouvez utiliser deux appels système - poll () ou select ().  Les deux sont capables de visualiser divers flux d'entrée-sortie sur le fait de n'importe quel événement.  Par exemple, si des informations sont arrivées dans l'un des flux, ces deux appels système peuvent les capturer et les afficher dans les données renvoyées.  Cependant, le second d'entre eux est essentiellement une version améliorée du premier et est utile lorsque vous travaillez avec plusieurs threads.  Nous n'avons pas un tel objectif (nous ne travaillons qu'avec le flux standard), nous allons donc utiliser l'appel poll (). <br><br>  Il accepte également trois paramètres en entrée: <br><br><ol><li>  un pointeur sur la structure des données, qui contient des informations sur les descripteurs des flux surveillés (nous en discuterons ci-dessous); </li><li>  le nombre de threads traités (nous en avons un); </li><li>  temps en millisecondes pendant lequel un événement peut être attendu (nous avons besoin qu'il se produise immédiatement, donc ce paramètre est 0). </li></ol><br>  Dans la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">documentation,</a> vous pouvez découvrir que la structure de données requise possède le périphérique suivant: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">pollfd</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> fd; <span class="hljs-comment"><span class="hljs-comment">/*   */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">short</span></span> events; <span class="hljs-comment"><span class="hljs-comment">/*   */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">short</span></span> revents; <span class="hljs-comment"><span class="hljs-comment">/*   */</span></span> };</code> </pre><br>  Son descripteur est utilisé comme descripteur de fichier (nous travaillons avec un flux standard, donc c'est 0), et comme événements demandés nous utilisons différents drapeaux, dont nous n'avons besoin que du drapeau pour la présence de données dans le tampon.  Il a le nom POLLIN et est égal à 1. Nous ignorons le champ des événements retournés, car nous ne donnons aucune information au flux d'entrée.  L'appel système souhaité ressemblera alors à ceci: <br><br><pre> <code class="hljs perl">section .data fd dd <span class="hljs-number"><span class="hljs-number">0</span></span> ;    eve dw <span class="hljs-number"><span class="hljs-number">1</span></span> ;   - POLLIN rev dw <span class="hljs-number"><span class="hljs-number">0</span></span> ;  section .text poll: nop <span class="hljs-keyword"><span class="hljs-keyword">push</span></span> rbx <span class="hljs-keyword"><span class="hljs-keyword">push</span></span> rcx <span class="hljs-keyword"><span class="hljs-keyword">push</span></span> rdx <span class="hljs-keyword"><span class="hljs-keyword">push</span></span> rdi <span class="hljs-keyword"><span class="hljs-keyword">push</span></span> rsi mov rax, <span class="hljs-number"><span class="hljs-number">7</span></span> ;   poll mov rdi, fd ;   mov rsi, <span class="hljs-number"><span class="hljs-number">1</span></span> ;   mov rdx, <span class="hljs-number"><span class="hljs-number">0</span></span> ;     <span class="hljs-keyword"><span class="hljs-keyword">syscall</span></span></code> </pre><br>  L'appel système poll () renvoie le nombre de threads dans lesquels des événements "intéressants" se sont produits.  Comme nous n'avons qu'un seul thread, la valeur de retour est soit 1 (il y a des données entrées) ou 0 (il n'y en a pas).  Si, néanmoins, le tampon n'est pas vide, alors nous faisons immédiatement un autre appel système - lire - et lire le code du caractère entré.  En conséquence, nous obtenons le code suivant. <br><br><div class="spoiler">  <b class="spoiler_title">Entrée non bloquante dans le terminal</b> <div class="spoiler_text"><pre> <code class="hljs perl">section .data fd dd <span class="hljs-number"><span class="hljs-number">0</span></span> ;    eve dw <span class="hljs-number"><span class="hljs-number">1</span></span> ;   - POLLIN rev dw <span class="hljs-number"><span class="hljs-number">0</span></span> ;  sym db <span class="hljs-number"><span class="hljs-number">1</span></span> section .text poll: nop <span class="hljs-keyword"><span class="hljs-keyword">push</span></span> rbx <span class="hljs-keyword"><span class="hljs-keyword">push</span></span> rcx <span class="hljs-keyword"><span class="hljs-keyword">push</span></span> rdx <span class="hljs-keyword"><span class="hljs-keyword">push</span></span> rdi <span class="hljs-keyword"><span class="hljs-keyword">push</span></span> rsi mov rax, <span class="hljs-number"><span class="hljs-number">7</span></span> ;   poll mov rdi, fd ;   mov rsi, <span class="hljs-number"><span class="hljs-number">1</span></span> ;   mov rdx, <span class="hljs-number"><span class="hljs-number">0</span></span> ;     <span class="hljs-keyword"><span class="hljs-keyword">syscall</span></span> test rax, rax ;    <span class="hljs-number"><span class="hljs-number">0</span></span> jz .e mov rax, <span class="hljs-number"><span class="hljs-number">0</span></span> mov rdi, <span class="hljs-number"><span class="hljs-number">0</span></span> ;   mov rsi, sym ;   <span class="hljs-keyword"><span class="hljs-keyword">read</span></span> mov rdx, <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">syscall</span></span> <span class="hljs-keyword"><span class="hljs-keyword">xor</span></span> rax, rax mov al, byte[sym] ;  ,     .e: <span class="hljs-keyword"><span class="hljs-keyword">pop</span></span> rsi <span class="hljs-keyword"><span class="hljs-keyword">pop</span></span> rdi <span class="hljs-keyword"><span class="hljs-keyword">pop</span></span> rdx <span class="hljs-keyword"><span class="hljs-keyword">pop</span></span> rcx <span class="hljs-keyword"><span class="hljs-keyword">pop</span></span> rbx ret</code> </pre><br></div></div><br>  Ainsi, vous pouvez maintenant utiliser la fonction d'interrogation pour lire des informations.  Si aucune donnée n'est entrée, c'est-à-dire qu'aucun bouton n'a été enfoncé, alors il retournera 0 et ne bloquera donc pas notre processus.  Bien sûr, cette implémentation a des défauts, en particulier, elle ne peut fonctionner qu'avec des caractères ascii, mais elle peut facilement être modifiée en fonction de la tâche. <br><br>  Les trois fonctions décrites ci-dessus (setcan, setnoncan et poll) suffisent pour affiner l'entrée du terminal pour vous et les vôtres.  Ils sont extrêmement simples à comprendre et à utiliser.  Cependant, dans un vrai jeu, ce serait bien de les sécuriser conformément à l'approche C habituelle, mais c'est déjà l'affaire d'un programmeur. <br><br><h3>  Les sources </h3><br>  1) Les <a href="">sources des fonctions tcgetattr et tcsetattr</a> ; <br>  2) <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">documentation des appels système ioctl</a> ; <br>  3) <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">documentation sur l'appel du système de sondage</a> ; <br>  4) <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Documentation sur les termios</a> ; <br>  5) <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Table d'appels système sous Linux x64</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr414309/">https://habr.com/ru/post/fr414309/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr414293/index.html">Le troisième ReactOS Hackfest annuel se tiendra du 14 au 21 août 2018 à Berlin</a></li>
<li><a href="../fr414295/index.html">«C'était possible»: des moyens inhabituels mais efficaces d'utiliser les technologies «audio»</a></li>
<li><a href="../fr414299/index.html">Upgrade roomba 780</a></li>
<li><a href="../fr414303/index.html">Le Royaume-Uni dépense 6 millions de livres sterling pour les scientifiques des données</a></li>
<li><a href="../fr414307/index.html">Des astronomes découvrent les traces d'un festin supermassif de trous noirs au centre de fusion de deux galaxies</a></li>
<li><a href="../fr414311/index.html">Feuille de route Euro NCAP 2025. Sécurité des voitures neuves</a></li>
<li><a href="../fr414313/index.html">Le journaliste américain a tenté de découvrir l'identité de Satoshi Nakamoto en interrogeant la CIA et le FBI</a></li>
<li><a href="../fr414315/index.html">Le sport enrichit les gens: pédalé - mes jetons</a></li>
<li><a href="../fr414317/index.html">Organisation d'un cours universitaire en traitement du signal</a></li>
<li><a href="../fr414319/index.html">Un jour dans la vie d'un aigle en quelques secondes</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>