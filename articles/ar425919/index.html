<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🏇🏾 🎠 👐🏿 خرائط مسدس في الوحدة: الحفظ والتحميل ، القوام ، المسافات 🖖🏽 👨‍👨‍👧 🌆</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="الأجزاء 1-3: الشبكة والألوان وارتفاعات الخلية 

 الأجزاء 4-7: المطبات والأنهار والطرق 

 الأجزاء 8-11: الماء والأشكال الأرضية والأسوار 

 الأجزاء 12-1...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>خرائط مسدس في الوحدة: الحفظ والتحميل ، القوام ، المسافات</h1><div class="post__body post__body_full" style=";text-align:right;direction:rtl"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/425919/" style=";text-align:right;direction:rtl">  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">الأجزاء 1-3: الشبكة والألوان وارتفاعات الخلية</a> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">الأجزاء 4-7: المطبات والأنهار والطرق</a> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">الأجزاء 8-11: الماء والأشكال الأرضية والأسوار</a> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">الأجزاء 12-15: الحفظ والتحميل ، القوام ، المسافات</a> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">الأجزاء 16-19: إيجاد الطريق وفرق اللاعبين والرسوم المتحركة</a> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">الأجزاء 20-23: ضباب الحرب ، بحث الخرائط ، الجيل الإجرائي</a> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">الأجزاء 24-27: دورة الماء ، التآكل ، المناطق الأحيائية ، الخريطة الأسطوانية</a> <br><br><h1 style=";text-align:right;direction:rtl">  الجزء 12: حفظ وتحميل </h1><br><ul style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl">  تتبع نوع التضاريس بدلاً من اللون. </li><li style=";text-align:right;direction:rtl">  قم بإنشاء ملف. </li><li style=";text-align:right;direction:rtl">  نكتب البيانات في ملف ، ثم نقرأه. </li><li style=";text-align:right;direction:rtl">  نقوم بتسلسل بيانات الخلية. </li><li style=";text-align:right;direction:rtl">  إنقاص حجم الملف. </li></ul><br>  نحن نعرف بالفعل كيفية إنشاء خرائط مثيرة للاهتمام.  الآن أنت بحاجة إلى تعلم كيفية حفظها. <br><br><div style="text-align:center;;text-align:right;direction:rtl"><img src="https://habrastorage.org/getpro/habr/post_images/7bb/2ce/740/7bb2ce7409d37733e3b6f96c237ce1e9.jpg"></div><a name="habracut"></a><br>  <i>تم <a href="">تحميله</a> من ملف <a href="">test.map</a> .</i> <br><br><h2 style=";text-align:right;direction:rtl">  نوع التضاريس </h2><br>  عند حفظ خريطة ، لا نحتاج إلى تخزين جميع البيانات التي نتتبعها أثناء تنفيذ التطبيق.  على سبيل المثال ، نحتاج فقط إلى تذكر مستوى ارتفاع الخلية.  يتم أخذ موضعه الرأسي نفسه من هذه البيانات ، لذلك لا تحتاج إلى تخزينه.  في الواقع ، من الأفضل إذا لم نخزن هذه المقاييس المحسوبة.  وبالتالي ، ستظل بيانات الخريطة صحيحة ، حتى إذا قررنا في وقت لاحق تغيير إزاحة الارتفاع.  البيانات منفصلة عن عرضها. <br><br>  وبالمثل ، لا نحتاج إلى تخزين اللون الدقيق للخلية.  يمكنك كتابة أن الخلية خضراء.  لكن الظل الأخضر الدقيق يمكن أن يتغير مع تغيير في النمط البصري.  للقيام بذلك ، يمكننا حفظ فهرس الألوان ، وليس الألوان نفسها.  في الواقع ، قد يكون كافياً بالنسبة لنا تخزين هذا الفهرس بدلاً من الألوان الحقيقية في الخلايا في وقت التشغيل.  سيسمح هذا لاحقًا بالانتقال إلى تصور أكثر تعقيدًا للإغاثة. <br><br><h3 style=";text-align:right;direction:rtl">  تحريك مصفوفة من الألوان </h3><br>  إذا لم تعد الخلايا تحتوي على بيانات ملونة ، فيجب تخزينها في مكان آخر.  هو الأكثر ملاءمة لتخزينه في <code>HexMetrics</code> .  لذلك دعونا نضيف مجموعة من الألوان إليها. <br><br><pre style=";text-align:right;direction:rtl"> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> Color[] colors;</code> </pre> <br>  مثل جميع البيانات العالمية الأخرى ، مثل الضوضاء ، يمكننا تهيئة هذه الألوان باستخدام <code>HexGrid</code> . <br><br><pre style=";text-align:right;direction:rtl"> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Color[] colors; … <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Awake</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { HexMetrics.noiseSource = noiseSource; HexMetrics.InitializeHashGrid(seed); HexMetrics.colors = colors; … } … <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnEnable</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!HexMetrics.noiseSource) { HexMetrics.noiseSource = noiseSource; HexMetrics.InitializeHashGrid(seed); HexMetrics.colors = colors; } }</code> </pre> <br>  وبما أننا لا نقوم الآن بتعيين الألوان مباشرة للخلايا ، فسوف نتخلص من اللون الافتراضي. <br><br><pre style=";text-align:right;direction:rtl"> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// public Color defaultColor = Color.white; … void CreateCell (int x, int z, int i) { … HexCell cell = cells[i] = Instantiate&lt;HexCell&gt;(cellPrefab); cell.transform.localPosition = position; cell.coordinates = HexCoordinates.FromOffsetCoordinates(x, z); // cell.Color = defaultColor; … }</span></span></code> </pre> <br>  اضبط الألوان الجديدة لتتناسب مع الصفيف العام لمحرر الخرائط السداسي. <br><br><div style="text-align:center;;text-align:right;direction:rtl"><img src="https://habrastorage.org/getpro/habr/post_images/4bf/3cb/002/4bf3cb002342f9ab3aa482cf3a526042.png"></div><br>  <i>تمت إضافة الألوان إلى الشبكة.</i> <br><br><h3 style=";text-align:right;direction:rtl">  إعادة بناء الخلية </h3><br>  قم بإزالة حقل اللون من <code>HexCell</code> .  بدلاً من ذلك ، سنقوم بتخزين الفهرس.  بدلاً من فهرس الألوان ، نستخدم فهرس نوع إغاثة أكثر عمومية. <br><br><pre style=";text-align:right;direction:rtl"> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// Color color; int terrainTypeIndex;</span></span></code> </pre> <br>  يمكن لخاصية اللون استخدام هذا الفهرس فقط للحصول على اللون المقابل.  الآن لم يتم تعيينه مباشرة ، لذا احذف هذا الجزء.  في هذه الحالة ، نحصل على خطأ في الترجمة ، والذي سنقوم بإصلاحه قريبًا. <br><br><pre style=";text-align:right;direction:rtl"> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Color Color { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> HexMetrics.colors[terrainTypeIndex]; } <span class="hljs-comment"><span class="hljs-comment">// set { // … // } }</span></span></code> </pre> <br>  أضف خاصية جديدة للحصول على مؤشر نوع ارتفاع جديد وتعيينه. <br><br><pre style=";text-align:right;direction:rtl"> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> TerrainTypeIndex { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> terrainTypeIndex; } <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (terrainTypeIndex != <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>) { terrainTypeIndex = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; Refresh(); } } }</code> </pre> <br><h3 style=";text-align:right;direction:rtl">  إعادة هيكلة محرر </h3><br>  داخل <code>HexMapEditor</code> نحذف جميع التعليمات البرمجية المتعلقة بالألوان.  سيؤدي هذا إلى إصلاح خطأ الترجمة. <br><br><pre style=";text-align:right;direction:rtl"> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// public Color[] colors; … // Color activeColor; … // bool applyColor; … // public void SelectColor (int index) { // applyColor = index &gt;= 0; // if (applyColor) { // activeColor = colors[index]; // } // } … // void Awake () { // SelectColor(0); // } … void EditCell (HexCell cell) { if (cell) { // if (applyColor) { // cell.Color = activeColor; // } … } }</span></span></code> </pre> <br>  أضف الآن حقل وطريقة للتحكم في فهرس نوع الارتفاع النشط. <br><br><pre style=";text-align:right;direction:rtl"> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> activeTerrainTypeIndex; … <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetTerrainTypeIndex</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> index</span></span></span><span class="hljs-function">)</span></span> { activeTerrainTypeIndex = index; }</code> </pre> <br>  نستخدم هذه الطريقة كبديل لطريقة <code>SelectColor</code> المفقودة الآن.  قم بتوصيل أدوات الألوان في واجهة المستخدم باستخدام <code>SetTerrainTypeIndex</code> ، مع ترك كل شيء آخر دون تغيير.  هذا يعني أن المؤشر السلبي لا يزال قيد الاستخدام ويعني أنه لا يجب تغيير اللون. <br><br>  قم بتغيير <code>EditCell</code> بحيث يتم تعيين فهرس نوع الارتفاع للخلية التي يتم تحريرها. <br><br><pre style=";text-align:right;direction:rtl"> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EditCell</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (activeTerrainTypeIndex &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span>) { cell.TerrainTypeIndex = activeTerrainTypeIndex; } … } }</code> </pre> <br>  على الرغم من أننا أزلنا بيانات اللون من الخلايا ، يجب أن تعمل الخريطة بالطريقة نفسها كما كانت من قبل.  الاختلاف الوحيد هو أن اللون الافتراضي هو الآن الأول في الصفيف.  في حالتي هو أصفر. <br><br><div style="text-align:center;;text-align:right;direction:rtl"><img src="https://habrastorage.org/getpro/habr/post_images/8cc/e7e/6ac/8cce7e6acb202e119a6e7d5cdae2db74.png"></div><br>  <i>الأصفر هو اللون الافتراضي الجديد.</i> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=" rel="nofollow">حزمة الوحدة</a> <br><br><h2 style=";text-align:right;direction:rtl">  حفظ البيانات في ملف </h2><br>  للتحكم في حفظ وتحميل الخريطة ، نستخدم <code>HexMapEditor</code> .  سننشئ طريقتين للقيام بذلك ، ونتركهما فارغتين الآن. <br><br><pre style=";text-align:right;direction:rtl"> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Save</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Load</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { }</code> </pre> <br>  أضف زرين إلى واجهة المستخدم ( <em>GameObject / UI / Button</em> ).  قم بتوصيلها بالأزرار وإعطاء الملصقات المناسبة.  لقد وضعتهم في أسفل اللوحة اليمنى. <br><br><div style="text-align:center;;text-align:right;direction:rtl"><img src="https://habrastorage.org/getpro/habr/post_images/6ec/eba/96b/6eceba96bb5ff18fd0b4ad9472a19695.png"></div><br>  <i>أزرار الحفظ والتحميل.</i> <br><br><h3 style=";text-align:right;direction:rtl">  موقع الملف </h3><br>  لتخزين بطاقة ، تحتاج إلى حفظها في مكان ما.  كما هو الحال في معظم الألعاب ، سوف نقوم بتخزين البيانات في ملف.  ولكن أين يضع هذا الملف في نظام الملفات؟  تعتمد الإجابة على نظام التشغيل الذي تعمل فيه اللعبة.  لكل نظام تشغيل معايير خاصة به لتخزين الملفات المتعلقة بالتطبيقات. <br><br>  لسنا بحاجة لمعرفة هذه المعايير.  يعرف Unity المسار الصحيح الذي يمكن أن نحصل عليه مع <code>Application.persistentDataPath</code> .  يمكنك التحقق من كيف سيكون معك ، في طريقة <code>Save</code> ، عرضه في وحدة التحكم والضغط على الزر في وضع التشغيل. <br><br><pre style=";text-align:right;direction:rtl"> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Save</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Debug.Log(Application.persistentDataPath); }</code> </pre> <br>  في أنظمة سطح المكتب ، سيحتوي المسار على اسم الشركة والمنتج.  يتم استخدام هذا المسار من قبل كل من المحرر والتجميع.  يمكن تكوين الأسماء في <em>تحرير / إعدادات المشروع / لاعب</em> . <br><br><div style="text-align:center;;text-align:right;direction:rtl"><img src="https://habrastorage.org/getpro/habr/post_images/656/a60/056/656a60056f9d51c5a5f3d81762135b87.png"></div><br>  <i>اسم الشركة والمنتج.</i> <br><br><div class="spoiler" style=";text-align:right;direction:rtl">  <b class="spoiler_title">لماذا لا يمكنني العثور على مجلد Library على جهاز Mac؟</b> <div class="spoiler_text" style=";text-align:right;direction:rtl">  غالبًا ما يكون مجلد <em>المكتبة</em> مخفيًا.  تعتمد طريقة عرضه على إصدار OS X. إذا لم يكن لديك إصدار قديم ، فحدد المجلد الرئيسي في Finder وانتقل إلى <em>Show View Options</em> .  يوجد مربع اختيار لمجلد <em>المكتبة</em> . </div></div><br><div class="spoiler" style=";text-align:right;direction:rtl">  <b class="spoiler_title">ماذا عن WebGL؟</b> <div class="spoiler_text" style=";text-align:right;direction:rtl">  لا يمكن لألعاب WebGL الوصول إلى نظام ملفات المستخدم.  بدلاً من ذلك ، يتم إعادة توجيه جميع عمليات الملفات إلى نظام ملفات موجود في الذاكرة.  إنها شفافة بالنسبة لنا.  ومع ذلك ، لحفظ البيانات ، ستحتاج إلى طلب صفحة الويب يدويًا لإلقاء البيانات في تخزين المتصفح. </div></div><br><h3 style=";text-align:right;direction:rtl">  إنشاء ملف </h3><br>  لإنشاء ملف ، نحتاج إلى استخدام فئات من مساحة الاسم <code>System.IO</code> .  لذلك ، نضيف عبارة <code>using</code> لها عبر فئة <code>HexMapEditor</code> . <br><br><pre style=";text-align:right;direction:rtl"> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine.EventSystems; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.IO; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">HexMapEditor</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> { … }</code> </pre> <br>  نحتاج أولاً إلى إنشاء المسار الكامل للملف.  نستخدم <em>test.map</em> كاسم للملف.  يجب إضافته إلى مسار البيانات المخزنة.  يعتمد ما إذا كنت بحاجة إلى إدخال خط مائل أم مائل (خط مائل أو مائل) على النظام الأساسي.  <code>Path.Combine</code> طريقة <code>Path.Combine</code> . <br><br><pre style=";text-align:right;direction:rtl"> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Save</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> path = Path.Combine(Application.persistentDataPath, <span class="hljs-string"><span class="hljs-string">"test.map"</span></span>); }</code> </pre> <br>  بعد ذلك ، نحتاج إلى الوصول إلى الملف في هذا الموقع.  نقوم بذلك باستخدام طريقة <code>File.Open</code> .  نظرًا لأننا نريد كتابة البيانات في هذا الملف ، نحتاج إلى استخدام وضع الإنشاء الخاص به.  في هذه الحالة ، سيتم إنشاء ملف جديد على المسار المحدد ، أو سيتم استبدال ملف موجود. <br><br><pre style=";text-align:right;direction:rtl"> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> path = Path.Combine(Application.persistentDataPath, <span class="hljs-string"><span class="hljs-string">"test.map"</span></span>); File.Open(path, FileMode.Create);</code> </pre> <br>  ستكون نتيجة استدعاء هذه الطريقة تدفق بيانات مفتوح مرتبط بهذا الملف.  يمكننا استخدامه لكتابة البيانات إلى ملف.  ويجب ألا ننسى إغلاق الدفق عندما لم نعد بحاجة إليه. <br><br><pre style=";text-align:right;direction:rtl"> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> path = Path.Combine(Application.persistentDataPath, <span class="hljs-string"><span class="hljs-string">"test.map"</span></span>); Stream fileStream = File.Open(path, FileMode.Create); fileStream.Close();</code> </pre> <br>  في هذه المرحلة ، عند النقر فوق الزر <em>حفظ</em> ، سيتم إنشاء ملف <em>test.map</em> في المجلد المحدد <em>كمسار</em> للبيانات المخزنة.  إذا درست هذا الملف ، سيكون فارغًا ويبلغ حجمه 0 بايت ، لأننا حتى الآن لم نكتب أي شيء إليه. <br><br><h3 style=";text-align:right;direction:rtl">  اكتب إلى الملف </h3><br>  لكتابة البيانات إلى ملف ، نحتاج إلى طريقة لدفق البيانات إليه.  أسهل طريقة للقيام بذلك هي باستخدام <code>BinaryWriter</code> .  تسمح لك هذه الكائنات بكتابة البيانات البدائية إلى أي دفق. <br><br>  قم <code>BinaryWriter</code> كائن <code>BinaryWriter</code> جديد ، وسيكون دفق الملف الخاص بنا <code>BinaryWriter</code> .  إغلاق الكاتب يغلق الدفق الذي يستخدمه.  لذلك ، لم نعد بحاجة إلى تخزين رابط مباشر للدفق. <br><br><pre style=";text-align:right;direction:rtl"> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> path = Path.Combine(Application.persistentDataPath, <span class="hljs-string"><span class="hljs-string">"test.map"</span></span>); BinaryWriter writer = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BinaryWriter(File.Open(path, FileMode.Create)); writer.Close();</code> </pre> <br>  لنقل البيانات إلى دفق ، يمكننا استخدام طريقة <code>BinaryWriter.Write</code> .  هناك نوع مختلف من طريقة <code>Write</code> لجميع الأنواع البدائية ، مثل الأعداد الصحيحة والعائمة.  يمكنه أيضًا تسجيل الخطوط.  لنحاول كتابة العدد الصحيح 123. <br><br><pre style=";text-align:right;direction:rtl"> <code class="cs hljs"> BinaryWriter writer = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BinaryWriter(File.Open(path, FileMode.Create)); writer.Write(<span class="hljs-number"><span class="hljs-number">123</span></span>); writer.Close();</code> </pre> <br>  انقر فوق الزر <em>حفظ</em> وفحص <em>خريطة الاختبار</em> مرة أخرى.  الآن حجمها 4 بايت ، لأن الحجم الصحيح هو 4 بايت. <br><br><div class="spoiler" style=";text-align:right;direction:rtl">  <b class="spoiler_title">لماذا يُظهر مدير الملفات أن الملف يشغل مساحة أكبر؟</b> <div class="spoiler_text" style=";text-align:right;direction:rtl">  لأن أنظمة الملفات تقسم المساحة إلى كتل البايت.  لا تتعقب وحدات البايت الفردية.  نظرًا لأن <em>test.map</em> يستغرق أربعة بايتات فقط حتى الآن ، فإنه يتطلب كتلة واحدة من مساحة التخزين. </div></div><br>  لاحظ أننا نقوم بتخزين البيانات الثنائية ، وليس نصًا يمكن قراءته بواسطة الإنسان.  لذلك ، إذا فتحنا الملف في محرر نصوص ، فسوف نرى مجموعة من الأحرف غير المميزة.  من المحتمل أن ترى الرمز <em>{</em> متبوعًا بشيء أو بعض العناصر النائبة. <br><br>  يمكنك فتح الملف في محرر ست عشري.  في هذه الحالة ، سنرى <em>7b 00 00 00</em> .  هذه أربعة بايتات من عددنا الصحيح ، تم تعيينها بترميز سداسي عشري.  في الأرقام العشرية العادية ، تكون هذه القيمة <em>123 0 0 0</em> .  في ثنائي ، البايت الأول يشبه <em>01111011</em> . <br><br>  رمز ASCII لـ <em>{</em> هو 123 ، لذا يمكن عرض هذا الحرف في محرر نصوص.  ASCII 0 هو حرف فارغ لا يطابق أي أحرف مرئية. <br><br>  البايتات الثلاثة المتبقية تساوي صفر ، لأننا كتبنا رقمًا أقل من 256. إذا كتبنا 256 ، فسنرى <em>00 01 00 00</em> في محرر السداسي. <br><br><div class="spoiler" style=";text-align:right;direction:rtl">  <b class="spoiler_title">ألا يجب تخزين 123 كـ 00 00 00 7b؟</b> <div class="spoiler_text" style=";text-align:right;direction:rtl">  يستخدم <code>BinaryWriter</code> تنسيق النهاية الصغيرة لحفظ الأرقام.  هذا يعني أنه يتم كتابة البايت الأقل أهمية أولاً.  تم استخدام هذا التنسيق بواسطة Microsoft في تطوير إطار عمل .NET.  ربما تم اختياره لأن وحدة المعالجة المركزية Intel تستخدم تنسيق النهاية الصغيرة. <br><br>  بديل لها هو نهاية كبيرة ، حيث يتم تخزين البايتات الأكثر أهمية أولاً.  هذا يتوافق مع الترتيب المعتاد للأرقام في الأرقام.  123 مائة وثلاثة وعشرون لأننا نعني الرقم القياسي الكبير.  إذا كانت صغيرة للغاية ، فإن 123 يعني ثلاثمائة وواحد وعشرون. </div></div><br><h3 style=";text-align:right;direction:rtl">  نحن نجعل الموارد مجانية </h3><br>  من المهم أن نغلق الكاتب.  أثناء فتحه ، يقوم نظام الملفات بتأمين الملف ، مما يمنع العمليات الأخرى من الكتابة إليه.  إذا نسينا إغلاقها ، فسنحجب أنفسنا أيضًا.  إذا ضغطنا على زر الحفظ مرتين ، في المرة الثانية لن نتمكن من فتح الدفق. <br><br>  بدلاً من إغلاق الكاتب يدويًا ، يمكننا إنشاء كتلة <code>using</code> لهذا الغرض.  وهي تحدد النطاق الذي يكون فيه الكاتب صالحًا.  عندما يتجاوز الكود القابل للتنفيذ هذا النطاق ، يتم حذف الكاتب وإغلاق مؤشر الترابط. <br><br><pre style=";text-align:right;direction:rtl"> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> ( BinaryWriter writer = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BinaryWriter(File.Open(path, FileMode.Create)) ) { writer.Write(<span class="hljs-number"><span class="hljs-number">123</span></span>); } <span class="hljs-comment"><span class="hljs-comment">// writer.Close();</span></span></code> </pre> <br>  سيعمل ذلك لأن فئتي الكاتب وتدفق الملف تطبق واجهة <code>IDisposable</code> .  تحتوي هذه الكائنات على طريقة <code>Dispose</code> ، والتي يتم استدعاؤها بشكل غير مباشر عندما تتجاوز نطاق <code>using</code> . <br><br>  الميزة الكبرى <code>using</code> هي أنه يعمل بغض النظر عن كيفية نفاد نطاق البرنامج.  العودة المبكرة والاستثناءات والأخطاء لا تزعجه.  بالإضافة إلى ذلك ، فهو موجز للغاية. <br><br><h3 style=";text-align:right;direction:rtl">  استرجاع البيانات </h3><br>  لقراءة البيانات المكتوبة مسبقًا ، نحتاج إلى إدراج الرمز في طريقة <code>Load</code> .  كما في حالة الحفظ ، نحتاج إلى إنشاء مسار وفتح دفق الملف.  الفرق هو أننا الآن نفتح الملف للقراءة وليس للكتابة.  وبدلاً من الكاتب نحتاج إلى <code>BinaryReader</code> . <br><br><pre style=";text-align:right;direction:rtl"> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Load</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> path = Path.Combine(Application.persistentDataPath, <span class="hljs-string"><span class="hljs-string">"test.map"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> ( BinaryReader reader = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BinaryReader(File.Open(path, FileMode.Open)) ) { } }</code> </pre> <br>  في هذه الحالة ، يمكننا استخدام طريقة <code>File.OpenRead</code> لفتح الملف للقراءة. <br><br><pre style=";text-align:right;direction:rtl"> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> (BinaryReader reader = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BinaryReader(File.OpenRead(path))) { }</code> </pre> <br><div class="spoiler" style=";text-align:right;direction:rtl">  <b class="spoiler_title">لماذا لا نستخدم File.OpenWrite عند الكتابة؟</b> <div class="spoiler_text" style=";text-align:right;direction:rtl">  تقوم هذه الطريقة بإنشاء دفق يضيف بيانات إلى الملفات الموجودة ، بدلاً من استبدالها. </div></div><br>  عند القراءة ، نحتاج إلى الإشارة بشكل صريح إلى نوع البيانات المستلمة.  لقراءة عدد صحيح من دفق ، نحتاج إلى استخدام <code>BinaryReader.ReadInt32</code> .  يقرأ هذا الأسلوب عددًا صحيحًا 32 بت ، أي أربعة بايت. <br><br><pre style=";text-align:right;direction:rtl"> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> (BinaryReader reader = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BinaryReader(File.OpenRead(path))) { Debug.Log(reader.ReadInt32()); }</code> </pre> <br>  وتجدر الإشارة إلى أنه عند تلقي <em>123 ،</em> سيكون كافياً بالنسبة لنا قراءة بايت واحد.  ولكن في الوقت نفسه ، ستبقى ثلاث وحدات بايت تنتمي إلى هذا العدد الصحيح في الدفق.  بالإضافة إلى ذلك ، لن يعمل هذا للأرقام خارج الفاصل الزمني 0-255.  لذلك ، لا تفعل ذلك. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=" rel="nofollow">حزمة الوحدة</a> <br><br><h2 style=";text-align:right;direction:rtl">  كتابة بيانات الخرائط وقراءتها </h2><br>  عند حفظ البيانات ، فإن السؤال المهم هو ما إذا كان يجب استخدام تنسيق يمكن قراءته بواسطة الإنسان.  عادةً ما تكون التنسيقات التي يمكن قراءتها بواسطة الإنسان هي JSON و XML و ASCII العادي مع نوع من البنية.  يمكن فتح هذه الملفات وتفسيرها وتحريرها في محرري النصوص.  بالإضافة إلى ذلك ، فإنها تبسط تبادل البيانات بين التطبيقات المختلفة. <br><br>  ومع ذلك ، فإن هذه التنسيقات لها متطلباتها الخاصة.  ستستهلك الملفات مساحة أكبر (أحيانًا أكبر بكثير) من استخدام البيانات الثنائية.  يمكنهم أيضًا زيادة تكلفة تشفير وفك تشفير البيانات بشكل كبير ، من حيث كل من وقت التشغيل وبصمة الذاكرة. <br><br>  في المقابل ، البيانات الثنائية مضغوطة وسريعة.  هذا مهم عند تسجيل كميات كبيرة من البيانات.  على سبيل المثال ، عند الحفظ التلقائي لخريطة كبيرة في كل دورة من اللعبة.  لذلك <br>  سنستخدم التنسيق الثنائي.  إذا كان بإمكانك معالجة ذلك ، يمكنك العمل بتنسيقات أكثر تفصيلاً. <br><br><div class="spoiler" style=";text-align:right;direction:rtl">  <b class="spoiler_title">ماذا عن التسلسل التلقائي؟</b> <div class="spoiler_text" style=";text-align:right;direction:rtl">  مباشرة أثناء عملية تسلسل بيانات الوحدة ، يمكننا كتابة فئات متسلسلة مباشرة إلى الدفق.  سيتم إخفاء تفاصيل تسجيل الحقول الفردية منا.  ومع ذلك ، لا يمكننا إجراء تسلسل مباشر للخلايا.  إنها فئات <code>MonoBehaviour</code> التي تحتوي على بيانات لا نحتاج إلى حفظها.  لذلك ، نحتاج إلى استخدام تسلسل هرمي منفصل للكائنات ، مما يقضي على بساطة التسلسل التلقائي.  بالإضافة إلى ذلك ، سيكون من الصعب دعم تغييرات التعليمات البرمجية المستقبلية.  لذلك ، سوف نحافظ على التحكم الكامل بالتسلسل اليدوي.  بالإضافة إلى ذلك ، سيجعلنا نفهم حقًا ما يحدث. </div></div><br>  لتسلسل الخريطة ، نحتاج إلى تخزين بيانات كل خلية.  لحفظ وتحميل خلية واحدة ، أضف طرق <code>Save</code> <code>Load</code> إلى <code>HexCell</code> .  نظرًا لأنها تحتاج إلى كاتب أو قارئ للعمل ، فسوف نضيفها كمعلمات. <br><br><pre style=";text-align:right;direction:rtl"> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.IO; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">HexCell</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> { … <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Save</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">BinaryWriter writer</span></span></span><span class="hljs-function">)</span></span> { } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Load</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">BinaryReader reader</span></span></span><span class="hljs-function">)</span></span> { } }</code> </pre> <br>  أضف طرق <code>Save</code> <code>Load</code> إلى <code>HexGrid</code> .  تتخطى هذه الطرق جميع الخلايا ببساطة عن طريق استدعاء طرق <code>Load</code> الخاصة بها. <br><br><pre style=";text-align:right;direction:rtl"> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine.UI; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.IO; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">HexGrid</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> { … <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Save</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">BinaryWriter writer</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cells.Length; i++) { cells[i].Save(writer); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Load</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">BinaryReader reader</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cells.Length; i++) { cells[i].Load(reader); } } }</code> </pre> <br>  إذا قمنا بتنزيل خريطة ، فيجب تحديثها بعد تغيير بيانات الخلية.  للقيام بذلك ، فقط قم بتحديث جميع الأجزاء. <br><br><pre style=";text-align:right;direction:rtl"> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Load</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">BinaryReader reader</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cells.Length; i++) { cells[i].Load(reader); } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; chunks.Length; i++) { chunks[i].Refresh(); } }</code> </pre> <br>  أخيرًا ، نقوم باستبدال رمز الاختبار الخاص بنا في <code>HexMapEditor</code> بمكالمات إلى طرق <code>Save</code> <code>Load</code> الشبكة ، وتمرير الكاتب أو القارئ معهم. <br><br><pre style=";text-align:right;direction:rtl"> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Save</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> path = Path.Combine(Application.persistentDataPath, <span class="hljs-string"><span class="hljs-string">"test.map"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> ( BinaryWriter writer = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BinaryWriter(File.Open(path, FileMode.Create)) ) { hexGrid.Save(writer); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Load</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> path = Path.Combine(Application.persistentDataPath, <span class="hljs-string"><span class="hljs-string">"test.map"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> (BinaryReader reader = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BinaryReader(File.OpenRead(path))) { hexGrid.Load(reader); } }</code> </pre> <br><h3 style=";text-align:right;direction:rtl">  حفظ نوع الإغاثة </h3><br>  في المرحلة الحالية ، تؤدي إعادة الحفظ إلى إنشاء ملف فارغ ، ولا يؤدي التنزيل إلى أي شيء.  لنبدأ تدريجياً بتسجيل وتحميل فهرس نوع الارتفاع <code>HexCell</code> فقط. <br><br>  قم بتعيين القيمة مباشرة إلى حقل terrainTypeIndex.  لن نستخدم الخصائص.  نظرًا لأننا نقوم بتحديث جميع الأجزاء بشكل صريح ، فلا حاجة لإجراء مكالمات إلى خصائص <code>Refresh</code> .  بالإضافة إلى ذلك ، نظرًا لأننا نحفظ الخرائط الصحيحة فقط ، سنفترض أن جميع الخرائط التي تم تنزيلها صحيحة أيضًا.  لذلك ، على سبيل المثال ، لن نتحقق مما إذا كان النهر أو الطريق مسموحًا به. <br><br><pre style=";text-align:right;direction:rtl"> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Save</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">BinaryWriter writer</span></span></span><span class="hljs-function">)</span></span> { writer.Write(terrainTypeIndex); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Load</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">BinaryReader reader</span></span></span><span class="hljs-function">)</span></span> { terrainTypeIndex = reader.ReadInt32(); }</code> </pre> <br>  عند الحفظ في هذا الملف ، سيُكتب فهرس واحد تلو الآخر لجميع أنواع الخلايا.  نظرًا لأن الفهرس عدد صحيح ، فإن حجمه هو أربعة بايت.  تحتوي بطاقتي على 300 خلية ، أي أن حجم الملف سيكون 1200 بايت. <br><br>  يقرأ الحمل الفهارس بنفس الترتيب الذي كُتبت به.  إذا قمت بتغيير ألوان الخلايا بعد الحفظ ، فإن تحميل الخريطة سيعيد الألوان إلى الحالة عند الحفظ.  نظرًا لأننا لم نعد نحتفظ بأي شيء ، فستظل بقية بيانات الخلية كما هي.  أي أن التحميل سيغير نوع التضاريس ، ولكن ليس ارتفاعها ، ومستوى المياه ، وميزات التضاريس ، وما إلى ذلك. <br><br><h3 style=";text-align:right;direction:rtl">  حفظ كل عدد صحيح </h3><br>  لا يكفي حفظ مؤشر نوع الإغاثة.  تحتاج إلى حفظ جميع البيانات الأخرى.  لنبدأ بجميع الحقول الصحيحة.  هذا مؤشر لنوع الإغاثة ، ارتفاع الخلية ، مستوى المياه ، مستوى المدينة ، مستوى المزرعة ، مستوى الغطاء النباتي ومؤشر الأشياء الخاصة.  يجب قراءتها بنفس الترتيب الذي تم تسجيلها به. <br><br><pre style=";text-align:right;direction:rtl"> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Save</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">BinaryWriter writer</span></span></span><span class="hljs-function">)</span></span> { writer.Write(terrainTypeIndex); writer.Write(elevation); writer.Write(waterLevel); writer.Write(urbanLevel); writer.Write(farmLevel); writer.Write(plantLevel); writer.Write(specialIndex); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Load</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">BinaryReader reader</span></span></span><span class="hljs-function">)</span></span> { terrainTypeIndex = reader.ReadInt32(); elevation = reader.ReadInt32(); waterLevel = reader.ReadInt32(); urbanLevel = reader.ReadInt32(); farmLevel = reader.ReadInt32(); plantLevel = reader.ReadInt32(); specialIndex = reader.ReadInt32(); }</code> </pre> <br>  حاول الآن حفظ وتحميل الخريطة ، وإجراء التغييرات بين هذه العمليات.  تم استعادة كل ما قمنا بتضمينه في البيانات المخزنة بأفضل ما نستطيع ، باستثناء ارتفاع الخلية.  حدث هذا لأنه عند تغيير مستوى الارتفاع ، تحتاج إلى تحديث الوضع الرأسي للخلية.  يمكن القيام بذلك عن طريق تعيين قيمة الارتفاع المحملة إلى الخاصية ، وليس إلى الحقل.  لكن هذه الخاصية تقوم بعمل إضافي لا نحتاجه.  لذلك ، دعنا نستخرج الكود الذي يقوم بتحديث موضع الخلية من محدد <code>Elevation</code> <code>RefreshPosition</code> طريقة <code>RefreshPosition</code> منفصلة.  التغيير الوحيد الذي تحتاج إلى إجرائه هنا هو استبدال <code>value</code> بمرجع إلى حقل <code>elevation</code> . <br><br><pre style=";text-align:right;direction:rtl"> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RefreshPosition</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Vector3 position = transform.localPosition; position.y = elevation * HexMetrics.elevationStep; position.y += (HexMetrics.SampleNoise(position).y * <span class="hljs-number"><span class="hljs-number">2f</span></span> - <span class="hljs-number"><span class="hljs-number">1f</span></span>) * HexMetrics.elevationPerturbStrength; transform.localPosition = position; Vector3 uiPosition = uiRect.localPosition; uiPosition.z = -position.y; uiRect.localPosition = uiPosition; }</code> </pre> <br>  الآن يمكننا استدعاء الأسلوب عند تعيين الخاصية ، وكذلك بعد تحميل بيانات الارتفاع. <br><br><pre style=";text-align:right;direction:rtl"> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Elevation { … <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (elevation == <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } elevation = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; RefreshPosition(); ValidateRivers(); … } } … <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Load</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">BinaryReader reader</span></span></span><span class="hljs-function">)</span></span> { terrainTypeIndex = reader.ReadInt32(); elevation = reader.ReadInt32(); RefreshPosition(); … }</code> </pre> <br>  بعد هذا التغيير ، ستغير الخلايا ارتفاعها الظاهري بشكل صحيح عند التحميل. <br><br><h3 style=";text-align:right;direction:rtl">  حفظ جميع البيانات </h3><br>  يتم تخزين وجود الجدران والأنهار الواردة / الصادرة في الخلية في الحقول المنطقية.  يمكننا كتابتها ببساطة كعدد صحيح.  بالإضافة إلى ذلك ، فإن بيانات الطريق عبارة عن مصفوفة من ست قيم منطقية يمكننا كتابتها بحلقة. <br><br><pre style=";text-align:right;direction:rtl"> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Save</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">BinaryWriter writer</span></span></span><span class="hljs-function">)</span></span> { writer.Write(terrainTypeIndex); writer.Write(elevation); writer.Write(waterLevel); writer.Write(urbanLevel); writer.Write(farmLevel); writer.Write(plantLevel); writer.Write(specialIndex); writer.Write(walled); writer.Write(hasIncomingRiver); writer.Write(hasOutgoingRiver); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; roads.Length; i++) { writer.Write(roads[i]); } }</code> </pre> <br>  يتم تخزين <code>HexDirection</code> الأنهار الواردة والصادرة في حقول <code>HexDirection</code> .  نوع <code>HexDirection</code> هو تعداد يتم تخزينه داخليًا كقيم صحيحة متعددة.  لذلك ، يمكننا أيضًا إجراء تسلسل لها كعدد صحيح باستخدام تحويل صريح. <br><br><pre style=";text-align:right;direction:rtl"> <code class="cs hljs"> writer.Write(hasIncomingRiver); writer.Write((<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)incomingRiver); writer.Write(hasOutgoingRiver); writer.Write((<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)outgoingRiver);</code> </pre> <br>  تتم قراءة القيم المنطقية باستخدام طريقة <code>BinaryReader.ReadBoolean</code> .  اتجاهات الأنهار صحيحة ، ويجب علينا تحويلها إلى <code>HexDirection</code> . <br><br><pre style=";text-align:right;direction:rtl"> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Load</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">BinaryReader reader</span></span></span><span class="hljs-function">)</span></span> { terrainTypeIndex = reader.ReadInt32(); elevation = reader.ReadInt32(); RefreshPosition(); waterLevel = reader.ReadInt32(); urbanLevel = reader.ReadInt32(); farmLevel = reader.ReadInt32(); plantLevel = reader.ReadInt32(); specialIndex = reader.ReadInt32(); walled = reader.ReadBoolean(); hasIncomingRiver = reader.ReadBoolean(); incomingRiver = (HexDirection)reader.ReadInt32(); hasOutgoingRiver = reader.ReadBoolean(); outgoingRiver = (HexDirection)reader.ReadInt32(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; roads.Length; i++) { roads[i] = reader.ReadBoolean(); } }</code> </pre> <br>  الآن نقوم بحفظ جميع بيانات الخلية اللازمة للحفظ الكامل واستعادة الخريطة.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">وهذا يتطلب تسعة أعداد صحيحة وتسع قيم منطقية لكل خلية. </font><font style="vertical-align: inherit;">تأخذ كل قيمة منطقية بايتًا واحدًا ، لذلك نستخدم إجمالي 45 بايت لكل خلية. </font><font style="vertical-align: inherit;">بمعنى ، تتطلب البطاقة التي تحتوي على 300 خلية إجمالي 13،500 بايت. </font></font><br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">حزمة الوحدة</font></font></a> <br><br><h2 style=";text-align:right;direction:rtl"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> تقليل حجم الملف </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">على الرغم من أنه يبدو أن 13500 بايت ليست كبيرة لـ 300 خلية ، ربما يمكننا القيام بذلك بكمية أقل. </font><font style="vertical-align: inherit;">في النهاية ، لدينا سيطرة كاملة على كيفية تسلسل البيانات. </font><font style="vertical-align: inherit;">دعونا نرى ما إذا كانت هناك طريقة أكثر إحكاما لتخزينها.</font></font><br><br><h3 style=";text-align:right;direction:rtl"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> اختزال الفاصل الرقمي </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">يتم تخزين مستويات الخلية والمؤشرات المختلفة كعدد صحيح. </font><font style="vertical-align: inherit;">ومع ذلك ، فإنها تستخدم فقط مجموعة صغيرة من القيم. </font><font style="vertical-align: inherit;">كل منهم سيبقى بالتأكيد في حدود 0-255. </font><font style="vertical-align: inherit;">هذا يعني أنه سيتم استخدام البايت الأول فقط من كل عدد صحيح. </font><font style="vertical-align: inherit;">الثلاثة المتبقية ستكون دائما صفر. </font><font style="vertical-align: inherit;">لا معنى لتخزين هذه البايتات الفارغة. </font><font style="vertical-align: inherit;">يمكننا تجاهلها عن طريق كتابة عدد صحيح للبايت قبل الكتابة إلى الدفق.</font></font><br><br><pre style=";text-align:right;direction:rtl"> <code class="cs hljs"> writer.Write((<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)terrainTypeIndex); writer.Write((<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)elevation); writer.Write((<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)waterLevel); writer.Write((<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)urbanLevel); writer.Write((<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)farmLevel); writer.Write((<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)plantLevel); writer.Write((<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)specialIndex); writer.Write(walled); writer.Write(hasIncomingRiver); writer.Write((<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)incomingRiver); writer.Write(hasOutgoingRiver); writer.Write((<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)outgoingRiver);</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">الآن ، لإرجاع هذه الأرقام ، يجب أن نستخدمها </font></font><code>BinaryReader.ReadByte</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">يتم التحويل من البايت إلى العدد الصحيح ضمنياً ، لذلك لا نحتاج إلى إضافة تحويلات صريحة.</font></font><br><br><pre style=";text-align:right;direction:rtl"> <code class="cs hljs"> terrainTypeIndex = reader.ReadByte(); elevation = reader.ReadByte(); RefreshPosition(); waterLevel = reader.ReadByte(); urbanLevel = reader.ReadByte(); farmLevel = reader.ReadByte(); plantLevel = reader.ReadByte(); specialIndex = reader.ReadByte(); walled = reader.ReadBoolean(); hasIncomingRiver = reader.ReadBoolean(); incomingRiver = (HexDirection)reader.ReadByte(); hasOutgoingRiver = reader.ReadBoolean(); outgoingRiver = (HexDirection)reader.ReadByte();</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">لذلك نتخلص من ثلاثة بايت لكل عدد صحيح ، مما يوفر 27 بايت لكل خلية. الآن ننفق 18 بايت لكل خلية ، و 5400 بايت فقط لكل 300 خلية. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">تجدر الإشارة إلى أن بيانات البطاقة القديمة تصبح بلا معنى في هذه المرحلة. عند تحميل الحفظ القديم ، يتم خلط البيانات ونحصل على خلايا مشوشة. هذا لأننا نقرأ الآن بيانات أقل. إذا قرأنا بيانات أكثر من ذي قبل ، فسنحصل على خطأ عند محاولة القراءة بعد نهاية الملف.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">إن عدم القدرة على معالجة البيانات القديمة يناسبنا ، لأننا بصدد تحديد التنسيق. </font><font style="vertical-align: inherit;">ولكن عندما نقرر تنسيق الحفظ ، سنحتاج إلى التأكد من أن التعليمات البرمجية المستقبلية يمكنها قراءتها دائمًا. </font><font style="vertical-align: inherit;">حتى إذا قمنا بتغيير التنسيق ، فمن الأفضل أن يظل بإمكاننا قراءة التنسيق القديم.</font></font><br><br><h3 style=";text-align:right;direction:rtl"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> اتحاد نهر بايت </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">في هذه المرحلة ، نستخدم أربعة بايت لتخزين بيانات النهر ، اثنان لكل اتجاه. </font><font style="vertical-align: inherit;">لكل اتجاه ، نقوم بتخزين وجود النهر والاتجاه الذي يتدفق فيه </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">، يبدو من الواضح أننا لسنا بحاجة إلى تخزين اتجاه النهر إذا لم يكن كذلك. </font><font style="vertical-align: inherit;">وهذا يعني أن الخلايا بدون نهر تحتاج إلى وحدتي بايت أقل. </font><font style="vertical-align: inherit;">في الواقع ، يكفي بايت واحد في اتجاه النهر ، بغض النظر عن وجوده.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">لدينا ستة اتجاهات محتملة ، يتم تخزينها كأرقام في الفاصل الزمني 0-5. </font><font style="vertical-align: inherit;">يكفي ثلاث بتات لهذا ، لأنه في أرقام النماذج الثنائية من 0 إلى 5 تبدو مثل 000 ، 001 ، 010 ، 011 ، 100 ، 101 و 110. وهذا يعني أن بايتة أخرى لا تزال غير مستخدمة وخمس بتات أخرى. </font><font style="vertical-align: inherit;">يمكننا استخدام واحد منهم للإشارة إلى وجود نهر. </font><font style="vertical-align: inherit;">على سبيل المثال ، يمكنك استخدام البت الثامن ، المقابل للرقم 128. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">للقيام بذلك ، سنضيف 128 إليه قبل تحويل الاتجاه إلى بايت. أي ، إذا كان لدينا نهر يتدفق إلى الشمال الغربي ، فسوف نكتب 133 ، وهو في شكل ثنائي هو 10000101. وإذا لم يكن هناك نهر ، فإننا نكتب صفر بايت فقط.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">في الوقت نفسه ، لا تزال أربعة بتات أخرى غير مستخدمة ، ولكن هذا أمر طبيعي. </font><font style="vertical-align: inherit;">يمكننا دمج كلا الاتجاهين للنهر في بايت واحد ، لكن هذا سيكون بالفعل مربكًا للغاية.</font></font><br><br><pre style=";text-align:right;direction:rtl"> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// writer.Write(hasIncomingRiver); // writer.Write((byte)incomingRiver); if (hasIncomingRiver) { writer.Write((byte)(incomingRiver + 128)); } else { writer.Write((byte)0); } // writer.Write(hasOutgoingRiver); // writer.Write((byte)outgoingRiver); if (hasOutgoingRiver) { writer.Write((byte)(outgoingRiver + 128)); } else { writer.Write((byte)0); }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">لفك شفرة بيانات النهر ، نحتاج أولاً إلى قراءة البايت مرة أخرى. </font><font style="vertical-align: inherit;">إذا كانت قيمتها لا تقل عن 128 ، فهذا يعني أن هناك نهر. </font><font style="vertical-align: inherit;">للحصول على اتجاهه ، اطرح 128 ، ثم اعتنق </font></font><code>HexDirection</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre style=";text-align:right;direction:rtl"> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// hasIncomingRiver = reader.ReadBoolean(); // incomingRiver = (HexDirection)reader.ReadByte(); byte riverData = reader.ReadByte(); if (riverData &gt;= 128) { hasIncomingRiver = true; incomingRiver = (HexDirection)(riverData - 128); } else { hasIncomingRiver = false; } // hasOutgoingRiver = reader.ReadBoolean(); // outgoingRiver = (HexDirection)reader.ReadByte(); riverData = reader.ReadByte(); if (riverData &gt;= 128) { hasOutgoingRiver = true; outgoingRiver = (HexDirection)(riverData - 128); } else { hasOutgoingRiver = false; }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ونتيجة لذلك ، حصلنا على 16 بايت لكل خلية. </font><font style="vertical-align: inherit;">يبدو أن التحسين ليس كبيرًا ، ولكن هذه إحدى الحيل التي يتم استخدامها لتقليل حجم البيانات الثنائية.</font></font><br><br><h3 style=";text-align:right;direction:rtl"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> حفظ الطرق في بايت واحد </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">يمكننا استخدام حيلة مماثلة لضغط بيانات الطريق. </font><font style="vertical-align: inherit;">لدينا ست قيم منطقية يمكن تخزينها في البتات الستة الأولى من البايت. </font><font style="vertical-align: inherit;">أي أن كل اتجاه للطريق يتم تمثيله برقم بقوة اثنين. </font><font style="vertical-align: inherit;">هذه هي 1 و 2 و 4 و 8 و 16 و 32 أو في شكل ثنائي 1 و 10 و 100 و 1000 و 10000 و 100000. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">لإنشاء بايت نهائي ، نحتاج إلى تعيين البتات التي تتوافق مع الاتجاهات المستخدمة للطرق. </font><font style="vertical-align: inherit;">للحصول على الاتجاه الصحيح للاتجاه ، يمكننا استخدام عامل التشغيل </font></font><code>&lt;&lt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">ثم ضمها باستخدام عامل تشغيل أحادي المعامل OR. </font><font style="vertical-align: inherit;">على سبيل المثال ، إذا تم استخدام الطرق الأولى والثانية والثالثة والسادسة ، فسيكون البايت النهائي 100111.</font></font><br><br><pre style=";text-align:right;direction:rtl"> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> roadFlags = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; roads.Length; i++) { <span class="hljs-comment"><span class="hljs-comment">// writer.Write(roads[i]); if (roads[i]) { roadFlags |= 1 &lt;&lt; i; } } writer.Write((byte)roadFlags);</span></span></code> </pre> <br><div class="spoiler" style=";text-align:right;direction:rtl"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">كيف يعمل &lt;&lt;؟</font></font></b> <div class="spoiler_text" style=";text-align:right;direction:rtl">     .   integer      .  .     integer .    ,          .   <code>1 &lt;&lt; n</code>  2 <sup>n</sup> ,    . </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">للحصول على القيمة المنطقية للطريق للخلف ، تحتاج إلى التحقق مما إذا تم تعيين البت. </font><font style="vertical-align: inherit;">إذا كان الأمر كذلك ، فقم بإخفاء كل البتات الأخرى باستخدام عامل تشغيل أحادي المعامل AND بالرقم المناسب. </font><font style="vertical-align: inherit;">إذا لم تكن النتيجة مساوية للصفر ، فسيتم تعيين البت ووجود الطريق.</font></font><br><br><pre style=";text-align:right;direction:rtl"> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> roadFlags = reader.ReadByte(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; roads.Length; i++) { roads[i] = (roadFlags &amp; (<span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; i)) != <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">بعد أن ضغطنا 6 بايت في واحدة ، تلقينا 11 بايت لكل خلية. </font><font style="vertical-align: inherit;">مع 300 خلية ، هذا هو فقط 3300 بايت. </font><font style="vertical-align: inherit;">أي ، بعد أن عملنا قليلاً مع البايت ، قللنا حجم الملف بنسبة 75٪.</font></font><br><br><h3 style=";text-align:right;direction:rtl"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> الاستعداد للمستقبل </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">قبل الإعلان عن اكتمال تنسيق الحفظ ، نضيف تفاصيل أخرى. </font><font style="vertical-align: inherit;">قبل حفظ بيانات الخريطة ، سنضطر </font></font><code>HexMapEditor</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">لكتابة عدد صحيح صفر.</font></font><br><br><pre style=";text-align:right;direction:rtl"> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Save</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> path = Path.Combine(Application.persistentDataPath, <span class="hljs-string"><span class="hljs-string">"test.map"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> ( BinaryWriter writer = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BinaryWriter(File.Open(path, FileMode.Create)) ) { writer.Write(<span class="hljs-number"><span class="hljs-number">0</span></span>); hexGrid.Save(writer); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">سيؤدي ذلك إلى إضافة أربعة بايتات فارغة إلى بداية بياناتنا. </font><font style="vertical-align: inherit;">أي قبل تحميل البطاقة ، يجب أن نقرأ هذه البايت الأربعة.</font></font><br><br><pre style=";text-align:right;direction:rtl"> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Load</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> path = Path.Combine(Application.persistentDataPath, <span class="hljs-string"><span class="hljs-string">"test.map"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> (BinaryReader reader = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BinaryReader(File.OpenRead(path))) { reader.ReadInt32(); hexGrid.Load(reader); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">على الرغم من أن هذه البايتات غير مجدية حتى الآن ، إلا أنها تستخدم كعنوان يوفر التوافق العكسي في المستقبل. </font><font style="vertical-align: inherit;">إذا لم نقم بإضافة هذه البايتات الفارغة ، فستعتمد محتويات البايتات القليلة الأولى على الخلية الأولى من الخريطة. </font><font style="vertical-align: inherit;">لذلك ، سيكون من الصعب علينا في المستقبل معرفة أي إصدار من تنسيق الحفظ الذي نتعامل معه. </font><font style="vertical-align: inherit;">الآن يمكننا التحقق من البايتات الأربعة الأولى. </font><font style="vertical-align: inherit;">إذا كانت فارغة ، فإننا نتعامل مع إصدار من التنسيق 0. في الإصدارات المستقبلية ، سيكون من الممكن إضافة شيء آخر هناك. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">أي ، إذا كان العنوان غير صفري ، فنحن نتعامل مع نسخة غير معروفة. </font><font style="vertical-align: inherit;">نظرًا لأنه لا يمكننا معرفة البيانات الموجودة ، يجب علينا رفض تنزيل الخريطة.</font></font><br><br><pre style=";text-align:right;direction:rtl"> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> (BinaryReader reader = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BinaryReader(File.OpenRead(path))) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> header = reader.ReadInt32(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (header == <span class="hljs-number"><span class="hljs-number">0</span></span>) { hexGrid.Load(reader); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { Debug.LogWarning(<span class="hljs-string"><span class="hljs-string">"Unknown map format "</span></span> + header); } }</code> </pre> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">حزمة الوحدة</font></font></a> <br><br><h1 style=";text-align:right;direction:rtl"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> الجزء 13: إدارة البطاقة </font></font></h1><br><ul style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> نقوم بإنشاء بطاقات جديدة في وضع التشغيل. </font></font></li><li style=";text-align:right;direction:rtl"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> أضف الدعم لمختلف أحجام البطاقات. </font></font></li><li style=";text-align:right;direction:rtl"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> أضف حجم الخريطة إلى البيانات المحفوظة. </font></font></li><li style=";text-align:right;direction:rtl"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> حفظ وتحميل الخرائط العشوائية. </font></font></li><li style=";text-align:right;direction:rtl"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> عرض قائمة البطاقات. </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">في هذا الجزء ، سنضيف دعمًا لأحجام مختلفة من البطاقات ، بالإضافة إلى حفظ ملفات مختلفة. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">بدءًا من هذا الجزء ، سيتم إنشاء البرامج التعليمية في Unity 5.5.0.</font></font><br><br><div style="text-align:center;;text-align:right;direction:rtl"><img src="https://habrastorage.org/getpro/habr/post_images/abd/9e2/1e4/abd9e21e467d0b291c33f4ad31e96c51.jpg"></div><br> <i><a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">بداية</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> مكتبة الخرائط.</font></font></i> <br><br><h2 style=";text-align:right;direction:rtl"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> إنشاء خرائط جديدة </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">حتى هذه اللحظة ، أنشأنا الشبكة السداسية مرة واحدة فقط - عند تحميل المشهد. </font><font style="vertical-align: inherit;">الآن سنجعل من الممكن بدء خريطة جديدة في أي وقت. </font><font style="vertical-align: inherit;">ستستبدل البطاقة الجديدة ببساطة البطاقة الحالية. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">في Awake </font></font><code>HexGrid</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">، تتم تهيئة بعض المقاييس ، ومن ثم يتم تحديد عدد الخلايا وإنشاء الأجزاء والخلايا اللازمة. </font><font style="vertical-align: inherit;">من خلال إنشاء مجموعة جديدة من الأجزاء والخلايا ، نقوم بإنشاء خريطة جديدة. </font><font style="vertical-align: inherit;">دعنا ننقسم </font></font><code>HexGrid.Awake</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">إلى قسمين - كود مصدر التهيئة والطريقة العامة </font></font><code>CreateMap</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre style=";text-align:right;direction:rtl"> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Awake</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { HexMetrics.noiseSource = noiseSource; HexMetrics.InitializeHashGrid(seed); HexMetrics.colors = colors; CreateMap(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateMap</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { cellCountX = chunkCountX * HexMetrics.chunkSizeX; cellCountZ = chunkCountZ * HexMetrics.chunkSizeZ; CreateChunks(); CreateCells(); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">أضف زرًا في واجهة المستخدم لإنشاء خريطة جديدة. </font><font style="vertical-align: inherit;">لقد جعلتها كبيرة ووضعها تحت أزرار الحفظ والتحميل.</font></font><br><br><div style="text-align:center;;text-align:right;direction:rtl"><img src="https://habrastorage.org/getpro/habr/post_images/203/c02/ff4/203c02ff4ca668836064c72ad770328c.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">زر خريطة جديد. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">دعنا نربط حدث </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">On Click</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> لهذا الزر بطريقة </font></font><code>CreateMap</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">كائننا </font></font><code>HexGrid</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">بمعنى ، لن </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">نتصفح محرر خرائط Hex</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ، ولكننا ندعو مباشرة طريقة كائن </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hex Grid</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><div style="text-align:center;;text-align:right;direction:rtl"><img src="https://habrastorage.org/getpro/habr/post_images/36a/d04/a3e/36ad04a3ebf94b00faf7aebe8c783b2f.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">قم بإنشاء خريطة بالنقر.</font></font></i> <br><br><h3 style=";text-align:right;direction:rtl"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> مسح البيانات القديمة </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">الآن ، عند النقر فوق الزر </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">خريطة جديدة</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ، سيتم إنشاء مجموعة جديدة من الأجزاء والخلايا. </font><font style="vertical-align: inherit;">ومع ذلك ، لا يتم حذف القديمة منها تلقائيًا. </font><font style="vertical-align: inherit;">لذلك ، ونتيجة لذلك ، نحصل على عدة شبكات خريطة متراكبة على بعضها البعض. </font><font style="vertical-align: inherit;">لتجنب ذلك ، نحتاج أولاً إلى التخلص من الأشياء القديمة. </font><font style="vertical-align: inherit;">يمكن القيام بذلك عن طريق تدمير جميع الأجزاء الحالية في البداية </font></font><code>CreateMap</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre style=";text-align:right;direction:rtl"> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateMap</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (chunks != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; chunks.Length; i++) { Destroy(chunks[i].gameObject); } } … }</code> </pre> <br><div class="spoiler" style=";text-align:right;direction:rtl"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">هل يمكننا إعادة استخدام الأشياء الموجودة؟</font></font></b> <div class="spoiler_text" style=";text-align:right;direction:rtl">  ,         .     ,       .  ,    —    ,      . </div></div><br><div class="spoiler" style=";text-align:right;direction:rtl"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">هل من الممكن تدمير عناصر تابعة مثل هذه في حلقة؟</font></font></b> <div class="spoiler_text" style=";text-align:right;direction:rtl">  بالطبع.         . </div></div><br><h3 style=";text-align:right;direction:rtl"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> حدد الحجم في الخلايا بدلاً من الأجزاء </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">بينما نطلب من حجم بطاقة من خلال الميدان </font></font><code>chunkCountX</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">و </font></font><code>chunkCountZ</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">جوه </font></font><code>HexGrid</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">ولكن سيكون من الأنسب الإشارة إلى حجم الخريطة في الخلايا. </font><font style="vertical-align: inherit;">في الوقت نفسه ، يمكننا حتى تغيير حجم القطعة في المستقبل دون تغيير حجم البطاقات. </font><font style="vertical-align: inherit;">لذلك ، دعنا نتبادل أدوار عدد الخلايا وعدد حقول الأجزاء.</font></font><br><br><pre style=";text-align:right;direction:rtl"> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// public int chunkCountX = 4, chunkCountZ = 3; public int cellCountX = 20, cellCountZ = 15; … // int cellCountX, cellCountZ; int chunkCountX, chunkCountZ; … public void CreateMap () { … // cellCountX = chunkCountX * HexMetrics.chunkSizeX; // cellCountZ = chunkCountZ * HexMetrics.chunkSizeZ; chunkCountX = cellCountX / HexMetrics.chunkSizeX; chunkCountZ = cellCountZ / HexMetrics.chunkSizeZ; CreateChunks(); CreateCells(); }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">سيؤدي هذا إلى خطأ في التجميع ، لأنه </font></font><code>HexMapCamera</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">يستخدم أحجام تجزئة </font><font style="vertical-align: inherit;">لتحديد موقعه </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">التغيير </font></font><code>HexMapCamera.ClampPosition</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">بحيث يستخدم مباشرة عدد الخلايا التي لا يزال بحاجة إليها.</font></font><br><br><pre style=";text-align:right;direction:rtl"> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-function">Vector3 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ClampPosition</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 position</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> xMax = (grid.cellCountX - <span class="hljs-number"><span class="hljs-number">0.5f</span></span>) * (<span class="hljs-number"><span class="hljs-number">2f</span></span> * HexMetrics.innerRadius); position.x = Mathf.Clamp(position.x, <span class="hljs-number"><span class="hljs-number">0f</span></span>, xMax); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> zMax = (grid.cellCountZ - <span class="hljs-number"><span class="hljs-number">1</span></span>) * (<span class="hljs-number"><span class="hljs-number">1.5f</span></span> * HexMetrics.outerRadius); position.z = Mathf.Clamp(position.z, <span class="hljs-number"><span class="hljs-number">0f</span></span>, zMax); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> position; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">يبلغ حجم الجزء 5 × 5 خلايا ، والخرائط افتراضيًا بحجم 4 × 3 أجزاء. </font><font style="vertical-align: inherit;">لذلك ، للحفاظ على البطاقات نفسها ، سيتعين علينا استخدام حجم 20 × 15 خلية. </font><font style="vertical-align: inherit;">وعلى الرغم من أننا قمنا بتعيين قيم افتراضية في الكود ، إلا أن كائن الشبكة لن يستخدمها تلقائيًا ، لأن الحقول موجودة بالفعل وتصبح افتراضيًا صفر.</font></font><br><br><div style="text-align:center;;text-align:right;direction:rtl"><img src="https://habrastorage.org/getpro/habr/post_images/399/2e3/da6/3992e3da66fb278c396e15a3d339707a.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">بشكل افتراضي ، يبلغ حجم البطاقة 20 × 15.</font></font></i> <br><br><h3 style=";text-align:right;direction:rtl"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> أحجام بطاقات مخصصة </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ستكون الخطوة التالية دعم إنشاء بطاقات من أي حجم ، وليس فقط الحجم الافتراضي. </font><font style="vertical-align: inherit;">للقيام بذلك ، أضف </font></font><code>HexGrid.CreateMap</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">X و Z </font><font style="vertical-align: inherit;">إلى </font><font style="vertical-align: inherit;">المعلمات. ستحل محل عدد الخلايا الحالي. </font><font style="vertical-align: inherit;">في الداخل ، </font></font><code>Awake</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">سنتصل بهم فقط مع العدد الحالي من الخلايا.</font></font><br><br><pre style=";text-align:right;direction:rtl"> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Awake</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { HexMetrics.noiseSource = noiseSource; HexMetrics.InitializeHashGrid(seed); HexMetrics.colors = colors; CreateMap(cellCountX, cellCountZ); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateMap</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z</span></span></span><span class="hljs-function">)</span></span> { … cellCountX = x; cellCountZ = z; chunkCountX = cellCountX / HexMetrics.chunkSizeX; chunkCountZ = cellCountZ / HexMetrics.chunkSizeZ; CreateChunks(); CreateCells(); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ومع ذلك ، سيعمل هذا بشكل صحيح فقط مع عدد الخلايا التي تعد مضاعفًا لحجم الجزء. </font><font style="vertical-align: inherit;">خلافًا لذلك ، سيؤدي القسمة الصحيحة إلى إنشاء عدد قليل جدًا من الأجزاء. </font><font style="vertical-align: inherit;">على الرغم من أنه يمكننا إضافة دعم للأجزاء المملوءة جزئيًا بالخلايا ، فلنحظر فقط استخدام الأحجام التي لا تتوافق مع الأجزاء. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">يمكننا استخدام عامل التشغيل </font></font><code>%</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">لحساب ما تبقى من قسمة عدد الخلايا على عدد الأجزاء. </font><font style="vertical-align: inherit;">إذا لم يكن يساوي الصفر ، فهناك تناقض ولن نقوم بإنشاء خريطة جديدة. </font><font style="vertical-align: inherit;">وبينما نقوم بذلك ، دعنا نضيف حماية ضد الصفر والأحجام السلبية.</font></font><br><br><pre style=";text-align:right;direction:rtl"> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateMap</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( x &lt;= <span class="hljs-number"><span class="hljs-number">0</span></span> || x % HexMetrics.chunkSizeX != <span class="hljs-number"><span class="hljs-number">0</span></span> || z &lt;= <span class="hljs-number"><span class="hljs-number">0</span></span> || z % HexMetrics.chunkSizeZ != <span class="hljs-number"><span class="hljs-number">0</span></span> ) { Debug.LogError(<span class="hljs-string"><span class="hljs-string">"Unsupported map size."</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } … }</code> </pre> <br><h3 style=";text-align:right;direction:rtl"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> قائمة بطاقة جديدة </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">في المرحلة الحالية ، </font><font style="vertical-align: inherit;">لم يعد </font><font style="vertical-align: inherit;">زر </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">الخريطة الجديدة</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> يعمل ، لأن الطريقة </font></font><code>HexGrid.CreateMap</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">تحتوي الآن على معلمتين. لا يمكننا ربط أحداث الوحدة مباشرة بهذه الأساليب. بالإضافة إلى ذلك ، لدعم أحجام مختلفة من البطاقات ، نحتاج إلى بعض الأزرار. بدلاً من إضافة كل هذه الأزرار إلى واجهة المستخدم الرئيسية ، دعنا ننشئ قائمة منبثقة منفصلة. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">أضف لوحة قماشية جديدة إلى المشهد ( </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GameObject / UI / Canvas</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). سنستخدم نفس الإعدادات الموجودة في اللوحة الحالية ، باستثناء أن </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ترتيب الفرز</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> يجب أن يكون مساوياً لـ 1. وبفضل هذا ، سيكون أعلى واجهة المستخدم الخاصة بالمحرر الرئيسي. لقد جعلت كل من اللوحة القماشية ونظام الأحداث تابعًا لكائن واجهة المستخدم الجديد بحيث يظل التسلسل الهرمي للمشهد نظيفًا.</font></font><br><br><div style="text-align:center;;text-align:right;direction:rtl"><img src="https://habrastorage.org/getpro/habr/post_images/c91/6c5/c2c/c916c5c2cee3f58576b12ac1a052bd64.png"></div><br><div style="text-align:center;;text-align:right;direction:rtl"><img src="https://habrastorage.org/getpro/habr/post_images/3be/a8b/79b/3bea8b79bae11a493aea43590394b0a3.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">قائمة لوحة خريطة جديدة. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">أضف </font><font style="vertical-align: inherit;">لوحة </font><font style="vertical-align: inherit;">إلى </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">قائمة الخريطة الجديدة</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> تغلق الشاشة بأكملها. </font><font style="vertical-align: inherit;">هناك حاجة إلى تعتيم الخلفية وعدم السماح للمؤشر بالتفاعل مع كل شيء آخر عندما تكون القائمة مفتوحة. </font><font style="vertical-align: inherit;">أعطى ذلك في لون موحد، وتنظيفه </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">الصورة المصدر</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ، فضلا عن </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">اللون</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> مجموعة (0، 0، 0، 200).</font></font><br><br><div style="text-align:center;;text-align:right;direction:rtl"><img src="https://habrastorage.org/getpro/habr/post_images/16c/1f0/a4f/16c1f0a4f31e0769099b845794a83b4a.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">إعدادات صورة الخلفية. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">أضف شريط قائمة إلى وسط اللوحة ، على غرار لوحات </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hex Map Editor</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">لنقم بإنشاء تسمية واضحة وأزرار لبطاقاتها الصغيرة والمتوسطة والكبيرة. </font><font style="vertical-align: inherit;">سنضيف أيضًا زر إلغاء لها في حالة تغيير اللاعب رأيها. </font><font style="vertical-align: inherit;">بعد الانتهاء من إنشاء التصميم ، قم بإلغاء تنشيط </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">قائمة الخريطة الجديدة</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> بالكامل </font><font style="vertical-align: inherit;">.</font></font><br><br><div style="text-align:center;;text-align:right;direction:rtl"><img src="https://habrastorage.org/getpro/habr/post_images/c0a/0d9/584/c0a0d95847337d91b97a823312c98a43.png"></div><br><div style="text-align:center;;text-align:right;direction:rtl"><img src="https://habrastorage.org/getpro/habr/post_images/917/3a1/7c3/9173a17c38f4c6e35f258c407b44d710.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">قائمة خريطة جديدة. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">لإدارة القائمة ، قم بإنشاء مكون </font></font><code>NewMapMenu</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">وإضافته إلى كائن </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">قائمة خريطة خريطة جديدة</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">لإنشاء خريطة جديدة ، نحتاج إلى الوصول إلى كائن </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hex Grid</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">لذلك ، نقوم بإضافة حقل مشترك إليه وربطه.</font></font><br><br><pre style=";text-align:right;direction:rtl"> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">NewMapMenu</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> HexGrid hexGrid; }</code> </pre> <br><div style="text-align:center;;text-align:right;direction:rtl"><img src="https://habrastorage.org/getpro/habr/post_images/f7d/a25/c3e/f7da25c3ed3ebf12ba9f4785b19ec8e1.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">مكون قائمة الخريطة الجديدة.</font></font></i> <br><br><h3 style=";text-align:right;direction:rtl"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> الافتتاح والختام </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">يمكننا فتح وإغلاق القائمة المنبثقة ببساطة عن طريق تنشيط وإلغاء تنشيط كائن اللوحة. </font><font style="vertical-align: inherit;">دعنا نضيف </font></font><code>NewMapMenu</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">طريقتين شائعتين للقيام بذلك.</font></font><br><br><pre style=";text-align:right;direction:rtl"> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Open</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { gameObject.SetActive(<span class="hljs-literal"><span class="hljs-literal">true</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Close</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { gameObject.SetActive(<span class="hljs-literal"><span class="hljs-literal">false</span></span>); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">الآن قم بتوصيل زر </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">New Map</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> UI </font><font style="vertical-align: inherit;">الخاص </font><font style="vertical-align: inherit;">بالمحرر بالطريقة </font></font><code>Open</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">في كائن </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">قائمة الخريطة الجديدة</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><div style="text-align:center;;text-align:right;direction:rtl"><img src="https://habrastorage.org/getpro/habr/post_images/b84/100/590/b841005902c164f5eb1dcab4f39c4221.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">فتح القائمة بالضغط. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">قم أيضًا بتوصيل زر " </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">إلغاء</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> الأمر" بالطريقة </font></font><code>Close</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">سيتيح لنا ذلك فتح القائمة المنبثقة وإغلاقها.</font></font><br><br><h3 style=";text-align:right;direction:rtl"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> إنشاء خرائط جديدة </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">لإنشاء خرائط جديدة ، نحتاج إلى استدعاء </font><font style="vertical-align: inherit;">الأسلوب </font><font style="vertical-align: inherit;">في كائن </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hex Grid</font></font></em><font style="vertical-align: inherit;"></font><code>CreateMap</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">بالإضافة إلى ذلك ، نحتاج بعد ذلك إلى إغلاق القائمة المنبثقة. </font><font style="vertical-align: inherit;">أضف إلى </font></font><code>NewMapMenu</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">الطريقة التي ستتعامل مع هذا ، مع مراعاة الحجم التعسفي.</font></font><br><br><pre style=";text-align:right;direction:rtl"> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateMap</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z</span></span></span><span class="hljs-function">)</span></span> { hexGrid.CreateMap(x, z); Close(); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">يجب ألا تكون هذه الطريقة عامة ، لأننا ما زلنا لا نستطيع توصيلها مباشرة بأحداث الأزرار. </font><font style="vertical-align: inherit;">بدلاً من ذلك ، قم بإنشاء طريقة واحدة لكل زر سيتم الاتصال </font></font><code>CreateMap</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">بالحجم المحدد. </font><font style="vertical-align: inherit;">بالنسبة للخريطة الصغيرة ، استخدمت حجم 20 × 15 ، يتوافق مع الحجم الافتراضي للخريطة. </font><font style="vertical-align: inherit;">بالنسبة للبطاقة المتوسطة ، قررت مضاعفة هذا الحجم ، والحصول على 40 × 30 ، ومضاعفته مرة أخرى للبطاقة الكبيرة. </font><font style="vertical-align: inherit;">قم بتوصيل الأزرار بالطرق المناسبة.</font></font><br><br><pre style=";text-align:right;direction:rtl"> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateSmallMap</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { CreateMap(<span class="hljs-number"><span class="hljs-number">20</span></span>, <span class="hljs-number"><span class="hljs-number">15</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateMediumMap</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { CreateMap(<span class="hljs-number"><span class="hljs-number">40</span></span>, <span class="hljs-number"><span class="hljs-number">30</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateLargeMap</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { CreateMap(<span class="hljs-number"><span class="hljs-number">80</span></span>, <span class="hljs-number"><span class="hljs-number">60</span></span>); }</code> </pre> <br><h3 style=";text-align:right;direction:rtl"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> قفل الكاميرا </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">يمكننا الآن استخدام القائمة المنبثقة لإنشاء خرائط جديدة بثلاثة أحجام مختلفة! كل شيء يعمل بشكل جيد ، لكننا بحاجة إلى الاهتمام ببعض التفاصيل. عندما تكون </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">قائمة الخريطة الجديدة</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> نشطة ، لم يعد بإمكاننا التفاعل مع واجهة مستخدم المحرر وتحرير الخلايا. ومع ذلك ، لا يزال بإمكاننا التحكم في الكاميرا. من الناحية المثالية ، مع فتح القائمة ، يجب أن تقفل الكاميرا. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">نظرًا لأن لدينا كاميرا واحدة فقط ، فإن الحل السريع والعملي هو ببساطة إضافة خاصية ثابتة إليها </font></font><code>Locked</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. للاستخدام على نطاق واسع ، هذا الحل ليس مناسبًا جدًا ، ولكن بالنسبة إلى واجهتنا البسيطة يكفي. هذا يتطلب أن نتتبع الحالة الثابتة بالداخل </font></font><code>HexMapCamera</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">، والتي يتم تعيينها عند كاميرا Awake.</font></font><br><br><pre style=";text-align:right;direction:rtl"> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> HexMapCamera instance; … <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Awake</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { instance = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; swivel = transform.GetChild(<span class="hljs-number"><span class="hljs-number">0</span></span>); stick = swivel.GetChild(<span class="hljs-number"><span class="hljs-number">0</span></span>); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">الخاصية </font></font><code>Locked</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">يمكن أن يكون خاصية منطقية ثابتة بسيطة فقط مع واضع. </font><font style="vertical-align: inherit;">كل ما يفعله هو إيقاف تشغيل المثيل </font></font><code>HexMapCamera</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">عندما يكون مقفلاً ، وتشغيله عندما يكون غير مؤمن.</font></font><br><br><pre style=";text-align:right;direction:rtl"> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> Locked { <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { instance.enabled = !<span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">الآن </font></font><code>NewMapMenu.Open</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">يمكنها حجب الكاميرا </font></font><code>NewMapMenu.Close</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">و- فتحها.</font></font><br><br><pre style=";text-align:right;direction:rtl"> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Open</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { gameObject.SetActive(<span class="hljs-literal"><span class="hljs-literal">true</span></span>); HexMapCamera.Locked = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Close</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { gameObject.SetActive(<span class="hljs-literal"><span class="hljs-literal">false</span></span>); HexMapCamera.Locked = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; }</code> </pre> <br><h3 style=";text-align:right;direction:rtl"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> الحفاظ على وضع الكاميرا الصحيح </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">هناك مشكلة أخرى محتملة في الكاميرا. </font><font style="vertical-align: inherit;">عند إنشاء خريطة جديدة أصغر من الخريطة الحالية ، قد تظهر الكاميرا خارج حدود الخريطة. </font><font style="vertical-align: inherit;">ستبقى هناك حتى يحاول اللاعب تحريك الكاميرا. </font><font style="vertical-align: inherit;">وعندها فقط ستصبح محدودة بحدود الخريطة الجديدة. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">لحل هذه المشكلة ، يمكننا إضافة </font></font><code>HexMapCamera</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">طريقة ثابتة </font></font><code>ValidatePosition</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><code>AdjustPosition</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">سيؤدي </font><font style="vertical-align: inherit;">استدعاء طريقة </font><font style="vertical-align: inherit;">مثيل مع إزاحة صفرية إلى إجبار الكاميرا على الانتقال إلى حدود الخريطة. </font><font style="vertical-align: inherit;">إذا كانت الكاميرا موجودة بالفعل داخل حدود الخريطة الجديدة ، فستبقى في مكانها.</font></font><br><br><pre style=";text-align:right;direction:rtl"> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ValidatePosition</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { instance.AdjustPosition(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">استدعاء الطريقة بالداخل </font></font><code>NewMapMenu.CreateMap</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">بعد إنشاء خريطة جديدة.</font></font><br><br><pre style=";text-align:right;direction:rtl"> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateMap</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z</span></span></span><span class="hljs-function">)</span></span> { hexGrid.CreateMap(x, z); HexMapCamera.ValidatePosition(); Close(); }</code> </pre> <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">حزمة الوحدة</font></font></a> <br><br><h2 style=";text-align:right;direction:rtl"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> حفظ حجم الخريطة </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">على الرغم من أنه يمكننا إنشاء بطاقات بأحجام مختلفة ، إلا أنها لا تؤخذ في الاعتبار عند الحفظ والتحميل. </font><font style="vertical-align: inherit;">هذا يعني أن تحميل الخريطة سيؤدي إلى خطأ أو خريطة غير صحيحة إذا كان حجم الخريطة الحالية لا يتطابق مع حجم الخريطة المحملة. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">لحل هذه المشكلة ، قبل تحميل بيانات الخلية ، نحتاج إلى إنشاء خريطة جديدة بالحجم المناسب. </font><font style="vertical-align: inherit;">لنفترض أن لدينا خريطة صغيرة محفوظة. </font><font style="vertical-align: inherit;">في هذه الحالة ، سيكون كل شيء على ما يرام إذا أنشأنا </font></font><code>HexGrid.Load</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">خريطة 20 × 15 </font><font style="vertical-align: inherit;">في البداية </font><font style="vertical-align: inherit;">.</font></font><br><br><pre style=";text-align:right;direction:rtl"> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Load</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">BinaryReader reader</span></span></span><span class="hljs-function">)</span></span> { CreateMap(<span class="hljs-number"><span class="hljs-number">20</span></span>, <span class="hljs-number"><span class="hljs-number">15</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cells.Length; i++) { cells[i].Load(reader); } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; chunks.Length; i++) { chunks[i].Refresh(); } }</code> </pre> <br><h3 style=";text-align:right;direction:rtl"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> تخزين بحجم البطاقة </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">بالطبع ، يمكننا تخزين بطاقة بأي حجم. </font><font style="vertical-align: inherit;">لذلك ، سيكون الحل العام هو حفظ حجم الخريطة أمام هذه الخلايا.</font></font><br><br><pre style=";text-align:right;direction:rtl"> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Save</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">BinaryWriter writer</span></span></span><span class="hljs-function">)</span></span> { writer.Write(cellCountX); writer.Write(cellCountZ); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cells.Length; i++) { cells[i].Save(writer); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ثم يمكننا الحصول على الحجم الحقيقي واستخدامه لإنشاء خريطة بالأحجام الصحيحة. </font></font><br><br><pre style=";text-align:right;direction:rtl"> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Load</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">BinaryReader reader</span></span></span><span class="hljs-function">)</span></span> { CreateMap(reader.ReadInt32(), reader.ReadInt32()); … }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">نظرًا لأنه يمكننا الآن تحميل خرائط بأحجام مختلفة ، فإننا نواجه مرة أخرى مشكلة وضع الكاميرا. </font><font style="vertical-align: inherit;">سنقوم بحلها عن طريق التحقق من موقعها </font></font><code>HexMapEditor.Load</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">بعد تحميل الخريطة.</font></font><br><br><pre style=";text-align:right;direction:rtl"> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Load</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> path = Path.Combine(Application.persistentDataPath, <span class="hljs-string"><span class="hljs-string">"test.map"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> (BinaryReader reader = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BinaryReader(File.OpenRead(path))) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> header = reader.ReadInt32(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (header == <span class="hljs-number"><span class="hljs-number">0</span></span>) { hexGrid.Load(reader, header); HexMapCamera.ValidatePosition(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { Debug.LogWarning(<span class="hljs-string"><span class="hljs-string">"Unknown map format "</span></span> + header); } } }</code> </pre> <br><h3 style=";text-align:right;direction:rtl"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> تنسيق ملف جديد </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">على الرغم من أن هذا النهج يعمل مع البطاقات التي سنحتفظ بها في المستقبل ، إلا أنها لن تعمل مع البطاقات القديمة. </font><font style="vertical-align: inherit;">والعكس بالعكس - لن يتمكن الرمز من الجزء السابق من البرنامج التعليمي من تحميل ملفات الخرائط الجديدة بشكل صحيح. </font><font style="vertical-align: inherit;">للتمييز بين التنسيقات القديمة والجديدة ، سنزيد القيمة الصحيحة للرأس. </font><font style="vertical-align: inherit;">كان تنسيق الحفظ القديم بدون حجم الخريطة لديه الإصدار 0. سيكون التنسيق الجديد بحجم الخريطة لديه الإصدار 1. لذلك ، عند التسجيل ، </font></font><code>HexMapEditor.Save</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">يجب أن يكتب 1 بدلاً من 0.</font></font><br><br><pre style=";text-align:right;direction:rtl"> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Save</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> path = Path.Combine(Application.persistentDataPath, <span class="hljs-string"><span class="hljs-string">"test.map"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> ( BinaryWriter writer = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BinaryWriter(File.Open(path, FileMode.Create)) ) { writer.Write(<span class="hljs-number"><span class="hljs-number">1</span></span>); hexGrid.Save(writer); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">من الآن فصاعدًا ، سيتم حفظ البطاقات كإصدار 1. إذا حاولنا فتحها في التجميع من البرنامج التعليمي السابق ، فسوف يرفضون التحميل والإبلاغ عن تنسيق بطاقة غير معروف. </font><font style="vertical-align: inherit;">في الواقع ، سيحدث هذا إذا حاولنا بالفعل تحميل مثل هذه البطاقة. </font><font style="vertical-align: inherit;">تحتاج إلى تغيير الطريقة </font></font><code>HexMapEditor.Load</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">بحيث تقبل الإصدار الجديد.</font></font><br><br><pre style=";text-align:right;direction:rtl"> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Load</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> path = Path.Combine(Application.persistentDataPath, <span class="hljs-string"><span class="hljs-string">"test.map"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> (BinaryReader reader = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BinaryReader(File.OpenRead(path))) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> header = reader.ReadInt32(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (header == <span class="hljs-number"><span class="hljs-number">1</span></span>) { hexGrid.Load(reader); HexMapCamera.ValidatePosition(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { Debug.LogWarning(<span class="hljs-string"><span class="hljs-string">"Unknown map format "</span></span> + header); } } }</code> </pre> <br><h3 style=";text-align:right;direction:rtl"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> التوافق مع الإصدارات السابقة </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">في الواقع ، إذا أردنا ، لا يزال بإمكاننا تنزيل خرائط الإصدار 0 ، بافتراض أن جميعها لها نفس الحجم 20 × 15. أي أنه لا يجب أن يكون العنوان 1 ، يمكن أن يكون صفرًا أيضًا. </font><font style="vertical-align: inherit;">نظرًا لأن كل إصدار يتطلب منهجًا خاصًا به ، </font></font><code>HexMapEditor.Load</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">يجب أن يمرر الرأس إلى الطريقة </font></font><code>HexGrid.Load</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre style=";text-align:right;direction:rtl"> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (header &lt;= <span class="hljs-number"><span class="hljs-number">1</span></span>) { hexGrid.Load(reader, header); HexMapCamera.ValidatePosition(); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">أضف </font></font><code>HexGrid.Load</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">عنوانًا </font><font style="vertical-align: inherit;">إلى </font><font style="vertical-align: inherit;">المعلمة واستخدمه لاتخاذ قرارات بشأن إجراءات أخرى. </font><font style="vertical-align: inherit;">إذا لم يكن الرأس أقل من 1 ، فأنت بحاجة إلى قراءة بيانات حجم البطاقة. </font><font style="vertical-align: inherit;">وإلا ، فإننا نستخدم حجم البطاقة الثابت القديم البالغ 20 × 15 ونتخطى قراءة بيانات الحجم.</font></font><br><br><pre style=";text-align:right;direction:rtl"> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Load</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">BinaryReader reader, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> header</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x = <span class="hljs-number"><span class="hljs-number">20</span></span>, z = <span class="hljs-number"><span class="hljs-number">15</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (header &gt;= <span class="hljs-number"><span class="hljs-number">1</span></span>) { x = reader.ReadInt32(); z = reader.ReadInt32(); } CreateMap(x, z); … }</code> </pre> <br> <a href="" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">إصدار ملف الخريطة 0</font></font></a> <br><br><h3 style=";text-align:right;direction:rtl"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> فحص حجم البطاقة </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">كما هو الحال مع إنشاء خريطة جديدة ، من الممكن نظريًا أن نضطر إلى تحميل خريطة غير متوافقة مع حجم الجزء. </font><font style="vertical-align: inherit;">عندما يحدث هذا ، يجب أن نقطع تحميل البطاقة. </font></font><code>HexGrid.CreateMap</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">يرفض بالفعل إنشاء خريطة ويعرض خطأ في وحدة التحكم. </font><font style="vertical-align: inherit;">لإخبار المتصل بالطريقة ، دعنا نرجع منطقية تخبرنا إذا تم إنشاء الخريطة.</font></font><br><br><pre style=";text-align:right;direction:rtl"> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateMap</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( x &lt;= <span class="hljs-number"><span class="hljs-number">0</span></span> || x % HexMetrics.chunkSizeX != <span class="hljs-number"><span class="hljs-number">0</span></span> || z &lt;= <span class="hljs-number"><span class="hljs-number">0</span></span> || z % HexMetrics.chunkSizeZ != <span class="hljs-number"><span class="hljs-number">0</span></span> ) { Debug.LogError(<span class="hljs-string"><span class="hljs-string">"Unsupported map size."</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } … <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">الآن ، </font></font><code>HexGrid.Load</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">يمكنه أيضًا إيقاف التنفيذ عند فشل إنشاء الخريطة.</font></font><br><br><pre style=";text-align:right;direction:rtl"> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Load</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">BinaryReader reader, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> header</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x = <span class="hljs-number"><span class="hljs-number">20</span></span>, z = <span class="hljs-number"><span class="hljs-number">15</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (header &gt;= <span class="hljs-number"><span class="hljs-number">1</span></span>) { x = reader.ReadInt32(); z = reader.ReadInt32(); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!CreateMap(x, z)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } … }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">نظرًا لأن التحميل يحل محل جميع البيانات في الخلايا الموجودة ، لا نحتاج إلى إنشاء خريطة جديدة إذا تم تحميل خريطة من نفس الحجم. </font><font style="vertical-align: inherit;">لذلك ، يمكن تخطي هذه الخطوة.</font></font><br><br><pre style=";text-align:right;direction:rtl"> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (x != cellCountX || z != cellCountZ) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!CreateMap(x, z)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } }</code> </pre> <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">حزمة الوحدة</font></font></a> <br><br><h2 style=";text-align:right;direction:rtl"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> إدارة الملفات </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">يمكننا حفظ وتحميل البطاقات بأحجام مختلفة ، ولكننا نكتب ونقرأ دائمًا </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">خريطة الاختبار</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">الآن سنضيف دعمًا لملفات مختلفة. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">بدلاً من حفظ الخريطة أو تحميلها مباشرةً ، نستخدم قائمة منبثقة أخرى توفر إدارة ملفات متقدمة. </font><font style="vertical-align: inherit;">قم بإنشاء لوحة رسم أخرى ، كما هو الحال في </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">قائمة الخريطة الجديدة</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ، ولكن هذه المرة سوف نطلق عليها اسم </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">حفظ قائمة التحميل</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">ستقوم هذه القائمة بحفظ الخرائط وتحميلها ، اعتمادًا على الزر الذي تم الضغط عليه لفتحه. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">سنقوم بإنشاء تصميم </font><em><font style="vertical-align: inherit;">Save Load Menu</font></em><font style="vertical-align: inherit;"> .</font></font><em><font style="vertical-align: inherit;"></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">كما لو كانت قائمة حفظ. في وقت لاحق ، سنحولها ديناميكيًا إلى قائمة تمهيد. مثل قائمة أخرى ، يجب أن يكون لها خلفية وشريط قائمة ، تسمية قائمة ، وزر إلغاء. ثم أضف عرض تمرير ( </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GameObject / UI / Scroll View</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) إلى القائمة لعرض قائمة بالملفات. أدناه نقوم بإدراج حقل الإدخال ( </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GameObject / UI / Input Field</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) للإشارة إلى أسماء البطاقات الجديدة. نحتاج أيضًا إلى زر إجراء لحفظ الخريطة. وأخيرًا. إضافة زر </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">حذف</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> لإزالة بطاقات غير المرغوب فيها.</font></font><br><br><div style="text-align:center;;text-align:right;direction:rtl"><img src="https://habrastorage.org/getpro/habr/post_images/c73/279/198/c732791989e1eb6fa53e73ec3435bc74.png"></div><br><div style="text-align:center;;text-align:right;direction:rtl"><img src="https://habrastorage.org/getpro/habr/post_images/176/485/3da/1764853da66092443c0327638dc1803a.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">تصميم قائمة تحميل حفظ.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> افتراضيًا ، يسمح عرض التمرير بالتمرير الأفقي والرأسي ، ولكننا لا نحتاج إلا إلى قائمة بالتمرير الرأسي. ولذلك، تعطيل التمرير </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">الأفقي</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> وافصل الأفقي شريط التمرير. قمنا أيضًا بتعيين </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">نوع الحركة</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> على تثبيط وتعطيل </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">القصور الذاتي</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> لجعل القائمة تبدو أكثر تقييدًا.</font></font><br><br><div style="text-align:center;;text-align:right;direction:rtl"><img src="https://habrastorage.org/getpro/habr/post_images/43f/3a9/e36/43f3a9e36202f436772f54eedcd96c76.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">خيارات قائمة الملفات. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">سنقوم بإزالة الطفل </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Scrollbar Horizontal</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> من كائن </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">قائمة الملفات</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ، لأننا لسنا بحاجة إليه. </font><font style="vertical-align: inherit;">ثم قم بتغيير حجم </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">شريط التمرير العمودي</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> بحيث </font><em><font style="vertical-align: inherit;">يصل إلى</font></em><font style="vertical-align: inherit;"> أسفل القائمة. </font><font style="vertical-align: inherit;">يمكن تغيير </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">نص العنصر النائب لكائن </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">إدخال الاسم</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> في </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">العنصر النائب الخاص به</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">لقد استخدمت نصًا وصفيًا ، ولكن يمكنك تركه فارغًا والتخلص من العنصر النائب.</font></font><br><br><div style="text-align:center;;text-align:right;direction:rtl"><img src="https://habrastorage.org/getpro/habr/post_images/ed5/7d5/d17/ed57d5d17dfb0695fc4b2f5f3f9dc8a5.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">تم تغيير تصميم القائمة. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">لقد انتهينا من التصميم ، والآن نقوم بإلغاء تنشيط القائمة بحيث يتم إخفاؤها بشكل افتراضي.</font></font><br><br><h3 style=";text-align:right;direction:rtl"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> إدارة القائمة </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">لكي تعمل القائمة ، نحتاج إلى برنامج نصي آخر ، في هذه الحالة - </font></font><code>SaveLoadMenu</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">مثل </font></font><code>NewMapMenu</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">، يحتاج إلى ارتباط بالشبكة ، وكذلك الأساليب </font></font><code>Open</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">و </font></font><code>Close</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre style=";text-align:right;direction:rtl"> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">SaveLoadMenu</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> HexGrid hexGrid; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Open</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { gameObject.SetActive(<span class="hljs-literal"><span class="hljs-literal">true</span></span>); HexMapCamera.Locked = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Close</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { gameObject.SetActive(<span class="hljs-literal"><span class="hljs-literal">false</span></span>); HexMapCamera.Locked = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">أضف هذا المكون إلى </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SaveLoadMenu</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> وأعطه ارتباطًا لكائن الشبكة.</font></font><br><br><div style="text-align:center;;text-align:right;direction:rtl"><img src="https://habrastorage.org/getpro/habr/post_images/974/86f/440/97486f440f44d4db9c744cfa9b6acec0.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">مكون SaveLoadMenu. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ستفتح قائمة للحفظ أو التحميل. </font><font style="vertical-align: inherit;">لتبسيط العمل ، أضف </font></font><code>Open</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">معلمة منطقية </font><font style="vertical-align: inherit;">إلى الطريقة </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">يحدد ما إذا كان يجب أن تكون القائمة في وضع الحفظ. </font><font style="vertical-align: inherit;">سنتتبع هذا الوضع في الميدان لمعرفة الإجراء الذي سنقوم به لاحقًا.</font></font><br><br><pre style=";text-align:right;direction:rtl"> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> saveMode; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Open</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> saveMode</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.saveMode = saveMode; gameObject.SetActive(<span class="hljs-literal"><span class="hljs-literal">true</span></span>); HexMapCamera.Locked = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">الآن الجمع بين أزرار </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">حفظ</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> و </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">تحميل</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> كائن </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">عرافة خريطة محرر</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> مع أسلوب </font></font><code>Open</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">الكائن </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">حفظ تحميل القائمة</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">تحقق من المعلمة المنطقية لزر </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">الحفظ</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> فقط </font><font style="vertical-align: inherit;">.</font></font><br><br><div style="text-align:center;;text-align:right;direction:rtl"><img src="https://habrastorage.org/getpro/habr/post_images/38c/59c/44f/38c59c44fa001e97128532d7c7d92168.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">فتح القائمة في وضع الحفظ. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">إذا لم تكن قد فعلت، ربط الحدث أزرار </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">إلغاء</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> الطريقة </font></font><code>Close</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">الآن </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">حفظ تحميل القائمة</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> يمكن أن تفتح وتغلق.</font></font><br><br><h3 style=";text-align:right;direction:rtl"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> تغير في المظهر </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">لقد أنشأنا القائمة كقائمة حفظ ، ولكن يتم تحديد وضعها من خلال الضغط على الزر لفتحها. </font><font style="vertical-align: inherit;">نحتاج إلى تغيير مظهر القائمة حسب الوضع. </font><font style="vertical-align: inherit;">على وجه الخصوص ، نحتاج إلى تغيير تسمية القائمة وتسمية زر الإجراء. </font><font style="vertical-align: inherit;">هذا يعني أننا سنحتاج إلى روابط لهذه العلامات.</font></font><br><br><pre style=";text-align:right;direction:rtl"> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine.UI; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">SaveLoadMenu</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Text menuLabel, actionButtonLabel; … }</code> </pre> <br><div style="text-align:center;;text-align:right;direction:rtl"><img src="https://habrastorage.org/getpro/habr/post_images/e7c/4d3/b8d/e7c4d3b8d55ce8c333d38be996a3ebc1.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">الاتصال بالعلامات. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">عندما تفتح القائمة في وضع الحفظ ، نستخدم التسميات الموجودة ، أي </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">حفظ الخريطة</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> للقائمة </font><font style="vertical-align: inherit;">وزر </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">الحفظ</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> للإجراء. </font><font style="vertical-align: inherit;">خلاف ذلك، ونحن في وضع التحميل، أي استخدام </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">تحميل خريطة</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> و </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">التحميل</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><pre style=";text-align:right;direction:rtl"> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Open</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> saveMode</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.saveMode = saveMode; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (saveMode) { menuLabel.text = <span class="hljs-string"><span class="hljs-string">"Save Map"</span></span>; actionButtonLabel.text = <span class="hljs-string"><span class="hljs-string">"Save"</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { menuLabel.text = <span class="hljs-string"><span class="hljs-string">"Load Map"</span></span>; actionButtonLabel.text = <span class="hljs-string"><span class="hljs-string">"Load"</span></span>; } gameObject.SetActive(<span class="hljs-literal"><span class="hljs-literal">true</span></span>); HexMapCamera.Locked = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> <br><h3 style=";text-align:right;direction:rtl"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> أدخل اسم البطاقة </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">دعنا نترك قائمة الملفات الآن. </font><font style="vertical-align: inherit;">يمكن للمستخدم تحديد الملف المحفوظ أو الذي تم تنزيله عن طريق إدخال اسم البطاقة في حقل الإدخال. </font><font style="vertical-align: inherit;">للحصول على هذه البيانات ، نحتاج إلى مرجع لمكون </font></font><code>InputField</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">كائن </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">إدخال الاسم</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><pre style=";text-align:right;direction:rtl"> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> InputField nameInput;</code> </pre> <br><div style="text-align:center;;text-align:right;direction:rtl"><img src="https://habrastorage.org/getpro/habr/post_images/e49/8e0/021/e498e002162a42103571cfac7cf91221.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">الاتصال بمجال الإدخال. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">لا يلزم إجبار المستخدم على إدخال المسار الكامل لملف الخريطة. </font><font style="vertical-align: inherit;">وسوف يكون فقط اسم البطاقة دون تمديد </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.MAP</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">دعنا نضيف طريقة تأخذ مدخلات المستخدم وتنشئ المسار الصحيح لها. </font><font style="vertical-align: inherit;">هذا غير ممكن عندما يكون الإدخال فارغًا ، لذلك في هذه الحالة سنعود </font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre style=";text-align:right;direction:rtl"> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine.UI; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.IO; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">SaveLoadMenu</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> { … <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetSelectedPath</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> mapName = nameInput.text; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (mapName.Length == <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Path.Combine(Application.persistentDataPath, mapName + <span class="hljs-string"><span class="hljs-string">".map"</span></span>); } }</code> </pre> <br><div class="spoiler" style=";text-align:right;direction:rtl"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ماذا يحدث إذا أدخل المستخدم أحرفًا غير صالحة؟</font></font></b> <div class="spoiler_text" style=";text-align:right;direction:rtl">        ,       .  ,      ,         . <br><br>         <em>Content Type</em>  . ,       - ,     .      ,    ,    . </div></div><br><h3 style=";text-align:right;direction:rtl"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> حفظ وتحميل </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">الآن سوف تشارك في الحفظ والتحميل </font></font><code>SaveLoadMenu</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">لذلك، ونحن نتحرك الطرق </font></font><code>Save</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">و </font></font><code>Load</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">لل </font></font><code>HexMapEditor</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">في </font></font><code>SaveLoadMenu</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">لم تعد هناك حاجة إلى مشاركتها ، وستعمل مع معلمة المسار بدلاً من المسار الثابت.</font></font><br><br><pre style=";text-align:right;direction:rtl"> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Save</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> path</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-comment"><span class="hljs-comment">// string path = Path.Combine(Application.persistentDataPath, "test.map"); using ( BinaryWriter writer = new BinaryWriter(File.Open(path, FileMode.Create)) ) { writer.Write(1); hexGrid.Save(writer); } } void Load (string path) { // string path = Path.Combine(Application.persistentDataPath, "test.map"); using (BinaryReader reader = new BinaryReader(File.OpenRead(path))) { int header = reader.ReadInt32(); if (header &lt;= 1) { hexGrid.Load(reader, header); HexMapCamera.ValidatePosition(); } else { Debug.LogWarning("Unknown map format " + header); } } }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">نظرًا لأننا نقوم الآن بتحميل ملفات عشوائية ، سيكون من الجيد التحقق من وجود الملف بالفعل ، وحينها فقط حاول قراءته. </font><font style="vertical-align: inherit;">إذا لم يكن كذلك ، فإننا نلقي خطأ وننهي العملية.</font></font><br><br><pre style=";text-align:right;direction:rtl"> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Load</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> path</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!File.Exists(path)) { Debug.LogError(<span class="hljs-string"><span class="hljs-string">"File does not exist "</span></span> + path); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } … }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">الآن أضف الطريقة العامة </font></font><code>Action</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">يبدأ بالحصول على المسار المحدد من قبل المستخدم. </font><font style="vertical-align: inherit;">إذا كان هناك مسار ، فقم بحفظه أو تحميله. </font><font style="vertical-align: inherit;">ثم أغلق القائمة.</font></font><br><br><pre style=";text-align:right;direction:rtl"> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Action</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> path = GetSelectedPath(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (path == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (saveMode) { Save(path); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { Load(path); } Close(); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">من خلال إرفاق حدث </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">زر الإجراء</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> بهذه الطريقة </font><font style="vertical-align: inherit;">، يمكننا الحفظ والتحميل باستخدام أسماء الخرائط العشوائية. </font><font style="vertical-align: inherit;">نظرًا لأننا لا نعيد تعيين حقل الإدخال ، سيبقى الاسم المحدد حتى الحفظ أو التحميل التالي. </font><font style="vertical-align: inherit;">هذا مناسب للحفظ أو التحميل من ملف واحد عدة مرات متتالية ، لذلك لن نغير أي شيء.</font></font><br><br><h3 style=";text-align:right;direction:rtl"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> عناصر قائمة الخريطة </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">بعد ذلك ، سنملأ قائمة الملفات بجميع البطاقات الموجودة على مسار تخزين البيانات. </font><font style="vertical-align: inherit;">عند النقر فوق أحد العناصر الموجودة في القائمة ، سيتم استخدامه كنص في </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">إدخال الاسم</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">أضف بطريقة </font></font><code>SaveLoadMenu</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">عامة لهذا.</font></font><br><br><pre style=";text-align:right;direction:rtl"> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SelectItem</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> name</span></span></span><span class="hljs-function">)</span></span> { nameInput.text = name; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">نحن بحاجة إلى شيء ما هو عنصر قائمة. </font><font style="vertical-align: inherit;">الزر المعتاد سيفعل. </font><font style="vertical-align: inherit;">قم بإنشائه وخفض الارتفاع إلى 20 وحدة بحيث لا يأخذ مساحة كبيرة عموديًا. </font><font style="vertical-align: inherit;">يجب ألا يبدو زرًا ، لذلك </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">سنمسح</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> رابط </font><em><font style="vertical-align: inherit;">صورة المصدر</font></em><font style="vertical-align: inherit;"> لمكون </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">الصورة</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> الخاص به </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">في هذه الحالة ، سيصبح أبيض بالكامل. </font><font style="vertical-align: inherit;">بالإضافة إلى ذلك ، سوف نتأكد من محاذاة التسمية إلى اليسار ومن وجود مسافة بين النص والجانب الأيسر من الزر. </font><font style="vertical-align: inherit;">بعد الانتهاء من تصميم الزر ، نحوله إلى الجاهزة.</font></font><br><br><div style="text-align:center;;text-align:right;direction:rtl"><img src="https://habrastorage.org/getpro/habr/post_images/501/0f0/6e5/5010f06e5b380440bca024ffb8c0e307.png"></div><br><div style="text-align:center;;text-align:right;direction:rtl"><img src="https://habrastorage.org/getpro/habr/post_images/67b/60b/21f/67b60b21f34e4ae69846c35ed5583fae.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">الزر عنصر قائمة. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">لا يمكننا ربط حدث الزر مباشرة بقائمة </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">الخريطة الجديدة</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ، لأنها سابقة الإعداد وغير موجودة في المشهد بعد. </font><font style="vertical-align: inherit;">لذلك ، يحتاج عنصر القائمة إلى ارتباط بالقائمة بحيث يمكنه استدعاء أسلوب عند النقر فوقه </font></font><code>SelectItem</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">كما يحتاج إلى تتبع اسم البطاقة التي يمثلها ، وتعيين نصه. </font><font style="vertical-align: inherit;">لنقم بإنشاء مكون صغير لهذا </font></font><code>SaveLoadItem</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre style=";text-align:right;direction:rtl"> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine.UI; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">SaveLoadItem</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> SaveLoadMenu menu; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> MapName { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> mapName; } <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { mapName = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; transform.GetChild(<span class="hljs-number"><span class="hljs-number">0</span></span>).GetComponent&lt;Text&gt;().text = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> mapName; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Select</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { menu.SelectItem(mapName); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">أضف مكونًا إلى عنصر القائمة واجعل الزر يستدعي طريقته </font></font><code>Select</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><div style="text-align:center;;text-align:right;direction:rtl"><img src="https://habrastorage.org/getpro/habr/post_images/249/172/7a0/2491727a0c07b0b92e89db0e3c02fe67.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">مكون العنصر.</font></font></i> <br><br><h3 style=";text-align:right;direction:rtl"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> قائمة التعبئة </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">لملء القائمة ، </font></font><code>SaveLoadMenu</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">تحتاج إلى ارتباط إلى </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">المحتوى</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> داخل إطار </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">العرض</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> لكائن </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">قائمة الملفات</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">كما يحتاج أيضًا إلى رابط إلى العنصر الجاهز.</font></font><br><br><pre style=";text-align:right;direction:rtl"> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> RectTransform listContent; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> SaveLoadItem itemPrefab;</code> </pre> <br><div style="text-align:center;;text-align:right;direction:rtl"><img src="https://habrastorage.org/getpro/habr/post_images/4b6/22a/0eb/4b622a0eb5cf47422ce591dcd5c120e8.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">امزج محتويات القائمة والتجهيز المسبق. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">نستخدم طريقة جديدة لملء هذه القائمة. </font><font style="vertical-align: inherit;">الخطوة الأولى هي تحديد ملفات الخرائط الموجودة. </font><font style="vertical-align: inherit;">للحصول على مصفوفة من جميع مسارات الملفات داخل الدليل ، يمكننا استخدام الطريقة </font></font><code>Directory.GetFiles</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">تحتوي هذه الطريقة على معلمة ثانية تسمح لك بتصفية الملفات. </font><font style="vertical-align: inherit;">في حالتنا ، فقط الملفات المطابقة لقناع </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">* .map</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> مطلوبة </font><font style="vertical-align: inherit;">.</font></font><br><br><pre style=";text-align:right;direction:rtl"> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FillList</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>[] paths = Directory.GetFiles(Application.persistentDataPath, <span class="hljs-string"><span class="hljs-string">"*.map"</span></span>); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">للأسف ، لا يتم ضمان ترتيب الملف. </font><font style="vertical-align: inherit;">لعرضها بالترتيب الأبجدي ، نحتاج إلى فرز الصفيف باستخدام </font></font><code>System.Array.Sort</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre style=";text-align:right;direction:rtl"> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine.UI; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.IO; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">SaveLoadMenu</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> { … <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FillList</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>[] paths = Directory.GetFiles(Application.persistentDataPath, <span class="hljs-string"><span class="hljs-string">"*.map"</span></span>); Array.Sort(paths); } … }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">بعد ذلك ، سننشئ مثيلات مسبقة الصنع لكل عنصر من عناصر المصفوفة. </font><font style="vertical-align: inherit;">قم بربط العنصر بالقائمة ، وقم بتعيين اسم الخريطة الخاصة به وجعله تابعًا لمحتويات القائمة.</font></font><br><br><pre style=";text-align:right;direction:rtl"> <code class="cs hljs"> Array.Sort(paths); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; paths.Length; i++) { SaveLoadItem item = Instantiate(itemPrefab); item.menu = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; item.MapName = paths[i]; item.transform.SetParent(listContent, <span class="hljs-literal"><span class="hljs-literal">false</span></span>); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">نظرًا لأنه </font></font><code>Directory.GetFiles</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">يعيد المسارات الكاملة للملفات ، نحتاج إلى مسحها. </font><font style="vertical-align: inherit;">لحسن الحظ ، هذا هو بالضبط ما يجعل الطريقة المناسبة </font></font><code>Path.GetFileNameWithoutExtension</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre style=";text-align:right;direction:rtl"> <code class="cs hljs"> item.MapName = Path.GetFileNameWithoutExtension(paths[i]);</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">قبل عرض القائمة ، نحتاج إلى ملء قائمة. </font><font style="vertical-align: inherit;">ونظرًا لأن الملفات من المحتمل أن تتغير ، فنحن بحاجة إلى القيام بذلك في كل مرة نفتح فيها القائمة.</font></font><br><br><pre style=";text-align:right;direction:rtl"> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Open</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> saveMode</span></span></span><span class="hljs-function">)</span></span> { … FillList(); gameObject.SetActive(<span class="hljs-literal"><span class="hljs-literal">true</span></span>); HexMapCamera.Locked = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> عند إعادة ملء القائمة ، نحتاج إلى حذف جميع العناصر القديمة قبل إضافة عناصر جديدة. </font></font><br><br><pre style=";text-align:right;direction:rtl"> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FillList</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; listContent.childCount; i++) { Destroy(listContent.GetChild(i).gameObject); } … }</code> </pre> <br><div style="text-align:center;;text-align:right;direction:rtl"><img src="https://habrastorage.org/getpro/habr/post_images/c83/4ff/fc3/c834fffc34b03b0d39de0056796fa199.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">عناصر بدون ترتيب.</font></font></i> <br><br><h3 style=";text-align:right;direction:rtl"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ترتيب النقاط </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ستعرض القائمة الآن العناصر ، ولكنها ستتداخل وستكون في وضع سيئ. لتحويلهم إلى قائمة عمودية ، أضف </font><font style="vertical-align: inherit;">مكون </font><em><font style="vertical-align: inherit;">مجموعة التخطيط العمودي</font></em><font style="vertical-align: inherit;"> ( </font><em><font style="vertical-align: inherit;">مكون / تخطيط / مجموعة تخطيط عمودي</font></em><font style="vertical-align: inherit;"> ) </font><font style="vertical-align: inherit;">إلى كائن </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">المحتوى</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> بالقائمة </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">إلى ترتيب للعمل بشكل صحيح، تشغيل </font><em><font style="vertical-align: inherit;">العرض</font></em><font style="vertical-align: inherit;"> من لكل من </font><em><font style="vertical-align: inherit;">الطفل التحكم في حجم</font></em><font style="vertical-align: inherit;"> و </font><em><font style="vertical-align: inherit;">الطفل توسيع القوة</font></em><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">يجب تعطيل </font><font style="vertical-align: inherit;">خياري </font><em><font style="vertical-align: inherit;">الارتفاع</font></em><font style="vertical-align: inherit;"> .</font></font><em><font style="vertical-align: inherit;"></font></em><font style="vertical-align: inherit;"></font><em><font style="vertical-align: inherit;"></font></em><font style="vertical-align: inherit;"></font><br><br><font style="vertical-align: inherit;"></font><em><font style="vertical-align: inherit;"></font></em><font style="vertical-align: inherit;"></font><em><font style="vertical-align: inherit;"></font></em><font style="vertical-align: inherit;"></font><em><font style="vertical-align: inherit;"></font></em><font style="vertical-align: inherit;"></font><em><font style="vertical-align: inherit;"></font></em><font style="vertical-align: inherit;"></font><br><br><div style="text-align:center;;text-align:right;direction:rtl"><img src="https://habrastorage.org/getpro/habr/post_images/392/32e/aac/39232eaac1c1741718d8993aae992bb4.png"></div><br><div style="text-align:center;;text-align:right;direction:rtl"><img src="https://habrastorage.org/getpro/habr/post_images/7dd/aba/ce4/7ddabace4df7d61a274544889de9a3c2.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">باستخدام مجموعة التخطيط الرأسي. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">لقد حصلنا على قائمة جميلة من العناصر. </font><font style="vertical-align: inherit;">ومع ذلك ، لا يتم ضبط حجم محتويات القائمة على العدد الحقيقي للعناصر. </font><font style="vertical-align: inherit;">لذلك ، لا يتغير حجم شريط التمرير أبدًا. </font><font style="vertical-align: inherit;">يمكننا إجبار </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">المحتوى على</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> تغيير الحجم تلقائيًا عن طريق إضافة مكون </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">حجم المحتوى</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ( </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">مكون / تخطيط / مجرب حجم المحتوى</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) إليه. </font><font style="vertical-align: inherit;">يجب ضبط </font><font style="vertical-align: inherit;">وضع </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">الملاءمة العمودي</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> على </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">الحجم المفضل</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><div style="text-align:center;;text-align:right;direction:rtl"><img src="https://habrastorage.org/getpro/habr/post_images/34e/c56/fdb/34ec56fdb61e1d3a2bc71989333a7a8a.png"></div><br><div style="text-align:center;;text-align:right;direction:rtl"><img src="https://habrastorage.org/getpro/habr/post_images/acb/a17/bf1/acba17bf1387ddb89b00ea48c9e31035.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">باستخدام مجرب حجم المحتوى. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">الآن مع عدد قليل من النقاط ، سيختفي شريط التمرير. </font><font style="vertical-align: inherit;">وعندما يكون هناك عدد كبير جدًا من العناصر في القائمة التي لا تتناسب مع إطار العرض ، يظهر شريط التمرير وله حجم مناسب.</font></font><br><br><div style="text-align:center;;text-align:right;direction:rtl"><img src="https://habrastorage.org/getpro/habr/post_images/327/460/6d8/3274606d8e5831f783d282d5122e55cc.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">يظهر شريط التمرير.</font></font></i> <br><br><h3 style=";text-align:right;direction:rtl"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> حذف البطاقة </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">الآن يمكننا العمل بسهولة مع العديد من ملفات الخرائط. </font><font style="vertical-align: inherit;">ومع ذلك ، في بعض الأحيان يكون من الضروري التخلص من بعض البطاقات. </font><font style="vertical-align: inherit;">للقيام بذلك ، يمكنك استخدام الزر </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">حذف</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">دعنا ننشئ طريقة لذلك ونجعل الزر يطلق عليه. </font><font style="vertical-align: inherit;">إذا كان هناك مسار محدد ، فاحذفه ببساطة باستخدام </font></font><code>File.Delete</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre style=";text-align:right;direction:rtl"> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Delete</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> path = GetSelectedPath(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (path == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } File.Delete(path); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">هنا يجب أن نتحقق أيضًا من أننا نعمل مع ملف موجود بالفعل. </font><font style="vertical-align: inherit;">إذا لم يكن الأمر كذلك ، فلا ينبغي لنا محاولة إزالته ، ولكن هذا لا يؤدي إلى حدوث خطأ.</font></font><br><br><pre style=";text-align:right;direction:rtl"> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (File.Exists(path)) { File.Delete(path); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">بعد إزالة البطاقة ، لا نحتاج إلى إغلاق القائمة. </font><font style="vertical-align: inherit;">هذا يجعل من السهل حذف ملفات متعددة في وقت واحد. </font><font style="vertical-align: inherit;">ومع ذلك ، بعد الإزالة ، نحتاج إلى مسح </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">إدخال الاسم</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ، وكذلك تحديث قائمة الملفات.</font></font><br><br><pre style=";text-align:right;direction:rtl"> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (File.Exists(path)) { File.Delete(path); } nameInput.text = <span class="hljs-string"><span class="hljs-string">""</span></span>; FillList();</code> </pre> <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">حزمة الوحدة</font></font></a> <br><br><h1 style=";text-align:right;direction:rtl"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> الجزء 14: مواد الإغاثة </font></font></h1><br><ul style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> استخدم ألوان الذروة لإنشاء خريطة متقطعة. </font></font></li><li style=";text-align:right;direction:rtl"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> إنشاء أصل نسيج المصفوفة. </font></font></li><li style=";text-align:right;direction:rtl"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> إضافة مؤشرات الارتفاع للشبكات. </font></font></li><li style=";text-align:right;direction:rtl"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> التحولات بين مواد الإغاثة. </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">حتى هذه اللحظة ، استخدمنا الألوان الصلبة لبطاقات التلوين. </font><font style="vertical-align: inherit;">الآن سنقوم بتطبيق الملمس.</font></font><br><br><div style="text-align:center;;text-align:right;direction:rtl"><img src="https://habrastorage.org/getpro/habr/post_images/4da/9e8/4fa/4da9e84faf824fdcf3933310de58ff9c.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">رسم القوام.</font></font></i> <br><br><h2 style=";text-align:right;direction:rtl"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> مزيج من ثلاثة أنواع </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">على الرغم من أن الألوان الموحدة يمكن تمييزها بوضوح وتتوافق تمامًا مع المهمة ، إلا أنها لا تبدو مثيرة للاهتمام للغاية. </font><font style="vertical-align: inherit;">سيزيد استخدام القوام بشكل كبير من جاذبية الخرائط. </font><font style="vertical-align: inherit;">بالطبع ، لهذا يجب علينا مزج القوام ، وليس فقط الألوان. </font><font style="vertical-align: inherit;">في البرنامج التعليمي </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rendering 3 ، ضم القوام ،</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> تحدثت عن كيفية مزج مواد متعددة باستخدام خريطة التقسيم. </font><font style="vertical-align: inherit;">في خرائطنا السداسية ، يمكنك استخدام نهج مماثل. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">في البرنامج التعليمي </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">التقديم 3</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">يتم خلط أربعة مواد فقط ، ويمكننا دعم ما يصل إلى خمسة مواد باستخدام خريطة واحدة. </font><font style="vertical-align: inherit;">في الوقت الحالي ، نستخدم خمسة ألوان مختلفة ، لذا فهي مناسبة تمامًا لنا. </font><font style="vertical-align: inherit;">ومع ذلك ، يمكننا لاحقًا إضافة أنواع أخرى. </font><font style="vertical-align: inherit;">لذلك ، هناك حاجة لدعم عدد عشوائي من أنواع الإغاثة. </font><font style="vertical-align: inherit;">عند استخدام خصائص النسيج المحددة بشكل صريح ، هذا غير ممكن ، لذلك يجب عليك استخدام مجموعة من الأنسجة. </font><font style="vertical-align: inherit;">في وقت لاحق سنقوم بإنشائه. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">عند استخدام مصفوفات النسيج ، نحتاج بطريقة ما إلى إخبار التظليل عن الأنسجة التي يجب مزجها. </font><font style="vertical-align: inherit;">الخلط الأصعب ضروري للمثلثات الزاوية ، والتي يمكن أن تكون بين ثلاث خلايا بنوع خاص من التضاريس. </font><font style="vertical-align: inherit;">لذلك ، نحتاج إلى خلط الدعم بين الأنواع الثلاثة لكل مثلث.</font></font><br><br><h3 style=";text-align:right;direction:rtl"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> استخدام ألوان الذروة كخرائط Splat </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">بافتراض أنه يمكننا إخبارك بالأنسجة المراد مزجها ، يمكننا استخدام ألوان الذروة لإنشاء خريطة متقطعة لكل مثلث. </font><font style="vertical-align: inherit;">نظرًا لأنه في كل حالة يتم استخدام ثلاثة مواد كحد أقصى ، نحتاج إلى ثلاث قنوات ألوان فقط. </font><font style="vertical-align: inherit;">يمثل اللون الأحمر النسيج الأول والأخضر - الثاني والأزرق - الثالث.</font></font><br><br><div style="text-align:center;;text-align:right;direction:rtl"><img src="https://habrastorage.org/getpro/habr/post_images/cf1/3fb/603/cf13fb603f1d7ab8e83d9290b483b9ee.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">خريطة المثلث تنبيه.</font></font></i> <br><br><div class="spoiler" style=";text-align:right;direction:rtl"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">هل مجموع خريطة دائرة المثلث يساوي دائمًا واحد؟</font></font></b> <div class="spoiler_text" style=";text-align:right;direction:rtl">  نعم         .     . ,        (1, 0, 0)  ,  (½, ½, 0)     (&amp;frac13;, &amp;frac13;, &amp;frac13;)  . </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">إذا كان المثلث يحتاج إلى نسيج واحد فقط ، فإننا نستخدم القناة الأولى فقط. </font><font style="vertical-align: inherit;">أي أن لونه سيكون أحمر بالكامل. </font><font style="vertical-align: inherit;">في حالة الخلط بين نوعين مختلفين ، نستخدم القناتين الأولى والثانية. </font><font style="vertical-align: inherit;">أي أن لون المثلث سيكون مزيجًا من الأحمر والأخضر. </font><font style="vertical-align: inherit;">وعندما يتم العثور على الأنواع الثلاثة ، سيكون مزيجًا من الأحمر والأخضر والأزرق.</font></font><br><br><div style="text-align:center;;text-align:right;direction:rtl"><img src="https://habrastorage.org/getpro/habr/post_images/aa3/364/890/aa33648906f62a94be8a45aba4bd80de.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ثلاثة تكوينات خريطة تنبيه. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">سوف نستخدم تكوينات خرائط الدوائر النقطية هذه بغض النظر عن المزيج الفعلي الممزوج. </font><font style="vertical-align: inherit;">وهذا يعني أن خريطة الدائرة ستكون دائمًا هي نفسها. </font><font style="vertical-align: inherit;">القوام فقط سيتغير. </font><font style="vertical-align: inherit;">كيف نفعل ذلك ، سنكتشف لاحقًا. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">نحن بحاجة إلى التغيير </font></font><code>HexGridChunk</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">بحيث ينشئ خرائط الدوائر هذه ، بدلاً من استخدام ألوان الخلايا. </font><font style="vertical-align: inherit;">نظرًا لأننا غالبًا ما نستخدم ثلاثة ألوان ، فسننشئ لهم حقولًا ثابتة.</font></font><br><br><pre style=";text-align:right;direction:rtl"> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> Color color1 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Color(<span class="hljs-number"><span class="hljs-number">1f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> Color color2 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Color(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> Color color3 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Color(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>);</code> </pre> <br><h3 style=";text-align:right;direction:rtl"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> مراكز الخلايا </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">لنبدأ باستبدال لون مركز الخلايا افتراضيًا. </font><font style="vertical-align: inherit;">لا يتم المزج هنا ، لذلك نستخدم اللون الأول فقط ، أي الأحمر.</font></font><br><br><pre style=";text-align:right;direction:rtl"> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateWithoutRiver</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> HexDirection direction, HexCell cell, Vector3 center, EdgeVertices e </span></span></span><span class="hljs-function">)</span></span> { TriangulateEdgeFan(center, e, color1); … }</code> </pre> <br><div style="text-align:center;;text-align:right;direction:rtl"><img src="https://habrastorage.org/getpro/habr/post_images/3e9/44b/f10/3e944bf109bb387ab6a620ea680c2772.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">المراكز الحمراء للخلايا. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">تتحول مراكز الخلايا الآن إلى اللون الأحمر. </font><font style="vertical-align: inherit;">جميعهم يستخدمون القوام الأول ، بغض النظر عن الملمس. </font><font style="vertical-align: inherit;">خرائطهم المتقاربة هي نفسها ، بغض النظر عن اللون الذي نلونه الخلايا.</font></font><br><br><h3 style=";text-align:right;direction:rtl"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> حي النهر </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">قمنا بتغيير الأجزاء داخل الخلايا فقط دون أن تتدفق الأنهار على طولها. </font><font style="vertical-align: inherit;">نحن بحاجة إلى أن نفعل الشيء نفسه بالنسبة للأجزاء المجاورة للأنهار. </font><font style="vertical-align: inherit;">في حالتنا ، هذا شريط ضلع ومروحة لمثلثات الضلع. </font><font style="vertical-align: inherit;">هنا ، أيضًا ، الأحمر فقط كافٍ بالنسبة لنا.</font></font><br><br><pre style=";text-align:right;direction:rtl"> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateAdjacentToRiver</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> HexDirection direction, HexCell cell, Vector3 center, EdgeVertices e </span></span></span><span class="hljs-function">)</span></span> { … TriangulateEdgeStrip(m, color1, e, color1); TriangulateEdgeFan(center, m, color1); … }</code> </pre> <br><div style="text-align:center;;text-align:right;direction:rtl"><img src="https://habrastorage.org/getpro/habr/post_images/b7c/846/a8a/b7c846a8a2a4b5a2670b77359d55f9f6.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">المقاطع الحمراء المجاورة للأنهار.</font></font></i> <br><br><h3 style=";text-align:right;direction:rtl">  الأنهار </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">بعد ذلك ، نحتاج إلى الاهتمام بهندسة الأنهار داخل الخلايا. </font><font style="vertical-align: inherit;">كلهم يجب أن يتحولوا إلى اللون الأحمر. </font><font style="vertical-align: inherit;">بادئ ذي بدء ، دعنا نلقي نظرة على بداية الأنهار ونهايتها.</font></font><br><br><pre style=";text-align:right;direction:rtl"> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateWithRiverBeginOrEnd</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> HexDirection direction, HexCell cell, Vector3 center, EdgeVertices e </span></span></span><span class="hljs-function">)</span></span> { … TriangulateEdgeStrip(m, color1, e, color1); TriangulateEdgeFan(center, m, color1); … }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ثم الهندسة التي تتكون منها الضفاف وقاع النهر. </font><font style="vertical-align: inherit;">لقد قمت بتجميع استدعاءات طريقة الألوان لتسهيل قراءة التعليمات البرمجية.</font></font><br><br><pre style=";text-align:right;direction:rtl"> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateWithRiver</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> HexDirection direction, HexCell cell, Vector3 center, EdgeVertices e </span></span></span><span class="hljs-function">)</span></span> { … TriangulateEdgeStrip(m, color1, e, color1); terrain.AddTriangle(centerL, m.v1, m.v2); <span class="hljs-comment"><span class="hljs-comment">// terrain.AddTriangleColor(cell.Color); terrain.AddQuad(centerL, center, m.v2, m.v3); // terrain.AddQuadColor(cell.Color); terrain.AddQuad(center, centerR, m.v3, m.v4); // terrain.AddQuadColor(cell.Color); terrain.AddTriangle(centerR, m.v4, m.v5); // terrain.AddTriangleColor(cell.Color); terrain.AddTriangleColor(color1); terrain.AddQuadColor(color1); terrain.AddQuadColor(color1); terrain.AddTriangleColor(color1); … }</span></span></code> </pre> <br><div style="text-align:center;;text-align:right;direction:rtl"><img src="https://habrastorage.org/getpro/habr/post_images/da8/46a/455/da846a455aa262ddff54429faa207267.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">الأنهار الحمراء على طول الخلايا.</font></font></i> <br><br><h3 style=";text-align:right;direction:rtl"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> الأضلاع </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">تختلف جميع الحواف لأنها بين الخلايا التي يمكن أن تحتوي على أنواع مختلفة من التضاريس. </font><font style="vertical-align: inherit;">نستخدم اللون الأول لنوع الخلية الحالي ، واللون الثاني لنوع الجوار. </font><font style="vertical-align: inherit;">ونتيجة لذلك ، ستصبح خريطة التقسيم متدرجة حمراء وخضراء ، حتى لو كانت كلتا الخليتين من نفس النوع. </font><font style="vertical-align: inherit;">إذا كانت كلتا الخليتين تستخدمان نفس النسيج ، فستصبح مجرد خليط من نفس النسيج على كلا الجانبين.</font></font><br><br><pre style=";text-align:right;direction:rtl"> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateConnection</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> HexDirection direction, HexCell cell, EdgeVertices e1 </span></span></span><span class="hljs-function">)</span></span> { … <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.GetEdgeType(direction) == HexEdgeType.Slope) { TriangulateEdgeTerraces(e1, cell, e2, neighbor, hasRoad); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { TriangulateEdgeStrip(e1, color1, e2, color2, hasRoad); } … }</code> </pre> <br><div style="text-align:center;;text-align:right;direction:rtl"><img src="https://habrastorage.org/getpro/habr/post_images/368/42b/88c/36842b88cd626359ef4adfd4c3b99b13.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ضلوع حمراء وخضراء باستثناء الحواف.</font></font></i> <br><br><div class="spoiler" style=";text-align:right;direction:rtl"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ألن الانتقال الحاد بين الأحمر والأخضر يسبب مشاكل؟</font></font></b> <div class="spoiler_text" style=";text-align:right;direction:rtl">   ,         ,      .        .     splat map,         .            . <br><br>  ,           . </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">الحواف ذات الحواف أكثر تعقيدًا بعض الشيء ، لأنها تحتوي على رؤوس إضافية. </font><font style="vertical-align: inherit;">لحسن الحظ ، يعمل رمز الاستيفاء الحالي بشكل رائع مع ألوان الخريطة المقسمة. </font><font style="vertical-align: inherit;">ما عليك سوى استخدام اللونين الأول والثاني ، وليس ألوان خلايا البداية والنهاية.</font></font><br><br><pre style=";text-align:right;direction:rtl"> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateEdgeTerraces</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> EdgeVertices begin, HexCell beginCell, EdgeVertices end, HexCell endCell, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> hasRoad </span></span></span><span class="hljs-function">)</span></span> { EdgeVertices e2 = EdgeVertices.TerraceLerp(begin, end, <span class="hljs-number"><span class="hljs-number">1</span></span>); Color c2 = HexMetrics.TerraceLerp(color1, color2, <span class="hljs-number"><span class="hljs-number">1</span></span>); TriangulateEdgeStrip(begin, color1, e2, c2, hasRoad); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">2</span></span>; i &lt; HexMetrics.terraceSteps; i++) { EdgeVertices e1 = e2; Color c1 = c2; e2 = EdgeVertices.TerraceLerp(begin, end, i); c2 = HexMetrics.TerraceLerp(color1, color2, i); TriangulateEdgeStrip(e1, c1, e2, c2, hasRoad); } TriangulateEdgeStrip(e2, c2, end, color2, hasRoad); }</code> </pre> <br><div style="text-align:center;;text-align:right;direction:rtl"><img src="https://habrastorage.org/getpro/habr/post_images/450/635/fe1/450635fe13e41a888046f2f7e0cce830.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">حواف أضلاع حمراء حمراء.</font></font></i> <br><br><h3 style=";text-align:right;direction:rtl"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> الزوايا </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">زوايا الخلية هي الأكثر صعوبة لأنها يجب أن تخلط ثلاث مواد مختلفة. </font><font style="vertical-align: inherit;">نستخدم اللون الأحمر للقمة السفلية والأخضر إلى اليسار والأزرق إلى اليمين. </font><font style="vertical-align: inherit;">لنبدأ بزوايا مثلث واحد.</font></font><br><br><pre style=";text-align:right;direction:rtl"> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateCorner</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 bottom, HexCell bottomCell, Vector3 left, HexCell leftCell, Vector3 right, HexCell rightCell </span></span></span><span class="hljs-function">)</span></span> { … <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { terrain.AddTriangle(bottom, left, right); terrain.AddTriangleColor(color1, color2, color3); } features.AddWall(bottom, bottomCell, left, leftCell, right, rightCell); }</code> </pre> <br><div style="text-align:center;;text-align:right;direction:rtl"><img src="https://habrastorage.org/getpro/habr/post_images/10a/d9c/218/10ad9c21858e48e059c92bbed08c779f.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">زوايا حمراء وخضراء وزرقاء باستثناء الحواف. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">يمكننا هنا مرة أخرى استخدام رمز استيفاء اللون الحالي للأركان ذات الحواف. </font><font style="vertical-align: inherit;">فقط يتم الاستيفاء بين ثلاثة ألوان ، وليس لونين. </font><font style="vertical-align: inherit;">أولاً ، ضع في اعتبارك الحواف غير القريبة من المنحدرات.</font></font><br><br><pre style=";text-align:right;direction:rtl"> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateCornerTerraces</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 begin, HexCell beginCell, Vector3 left, HexCell leftCell, Vector3 right, HexCell rightCell </span></span></span><span class="hljs-function">)</span></span> { Vector3 v3 = HexMetrics.TerraceLerp(begin, left, <span class="hljs-number"><span class="hljs-number">1</span></span>); Vector3 v4 = HexMetrics.TerraceLerp(begin, right, <span class="hljs-number"><span class="hljs-number">1</span></span>); Color c3 = HexMetrics.TerraceLerp(color1, color2, <span class="hljs-number"><span class="hljs-number">1</span></span>); Color c4 = HexMetrics.TerraceLerp(color1, color3, <span class="hljs-number"><span class="hljs-number">1</span></span>); terrain.AddTriangle(begin, v3, v4); terrain.AddTriangleColor(color1, c3, c4); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">2</span></span>; i &lt; HexMetrics.terraceSteps; i++) { Vector3 v1 = v3; Vector3 v2 = v4; Color c1 = c3; Color c2 = c4; v3 = HexMetrics.TerraceLerp(begin, left, i); v4 = HexMetrics.TerraceLerp(begin, right, i); c3 = HexMetrics.TerraceLerp(color1, color2, i); c4 = HexMetrics.TerraceLerp(color1, color3, i); terrain.AddQuad(v1, v2, v3, v4); terrain.AddQuadColor(c1, c2, c3, c4); } terrain.AddQuad(v3, v4, left, right); terrain.AddQuadColor(c3, c4, color2, color3); }</code> </pre> <br><div style="text-align:center;;text-align:right;direction:rtl"><img src="https://habrastorage.org/getpro/habr/post_images/504/d1d/6b3/504d1d6b3997b321e0a6e7bf5aa253f2.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">حواف الزاوية الحمراء والخضراء والزرقاء ، باستثناء الحواف على طول المنحدرات. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">عندما يتعلق الأمر بالمنحدرات ، نحتاج إلى استخدام طريقة </font></font><code>TriangulateBoundaryTriangle</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">تلقت هذه الطريقة خلايا البداية والمغادرة كمعلمات. </font><font style="vertical-align: inherit;">ومع ذلك ، نحتاج الآن إلى ألوان الألوان المناسبة ، والتي قد تختلف وفقًا للطوبولوجيا. </font><font style="vertical-align: inherit;">لذلك ، نستبدل هذه المعلمات بألوان.</font></font><br><br><pre style=";text-align:right;direction:rtl"> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateBoundaryTriangle</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 begin, Color beginColor, Vector3 left, Color leftColor, Vector3 boundary, Color boundaryColor </span></span></span><span class="hljs-function">)</span></span> { Vector3 v2 = HexMetrics.Perturb(HexMetrics.TerraceLerp(begin, left, <span class="hljs-number"><span class="hljs-number">1</span></span>)); Color c2 = HexMetrics.TerraceLerp(beginColor, leftColor, <span class="hljs-number"><span class="hljs-number">1</span></span>); terrain.AddTriangleUnperturbed(HexMetrics.Perturb(begin), v2, boundary); terrain.AddTriangleColor(beginColor, c2, boundaryColor); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">2</span></span>; i &lt; HexMetrics.terraceSteps; i++) { Vector3 v1 = v2; Color c1 = c2; v2 = HexMetrics.Perturb(HexMetrics.TerraceLerp(begin, left, i)); c2 = HexMetrics.TerraceLerp(beginColor, leftColor, i); terrain.AddTriangleUnperturbed(v1, v2, boundary); terrain.AddTriangleColor(c1, c2, boundaryColor); } terrain.AddTriangleUnperturbed(v2, HexMetrics.Perturb(left), boundary); terrain.AddTriangleColor(c2, leftColor, boundaryColor); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">قم بتغييره </font></font><code>TriangulateCornerTerracesCliff</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">بحيث يستخدم الألوان الصحيحة.</font></font><br><br><pre style=";text-align:right;direction:rtl"> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateCornerTerracesCliff</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 begin, HexCell beginCell, Vector3 left, HexCell leftCell, Vector3 right, HexCell rightCell </span></span></span><span class="hljs-function">)</span></span> { … Color boundaryColor = Color.Lerp(color1, color3, b); TriangulateBoundaryTriangle( begin, color1, left, color2, boundary, boundaryColor ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (leftCell.GetEdgeType(rightCell) == HexEdgeType.Slope) { TriangulateBoundaryTriangle( left, color2, right, color3, boundary, boundaryColor ); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { terrain.AddTriangleUnperturbed( HexMetrics.Perturb(left), HexMetrics.Perturb(right), boundary ); terrain.AddTriangleColor(color2, color3, boundaryColor); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ونفعل نفس الشيء من أجل </font></font><code>TriangulateCornerCliffTerraces</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre style=";text-align:right;direction:rtl"> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateCornerCliffTerraces</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 begin, HexCell beginCell, Vector3 left, HexCell leftCell, Vector3 right, HexCell rightCell </span></span></span><span class="hljs-function">)</span></span> { … Color boundaryColor = Color.Lerp(color1, color2, b); TriangulateBoundaryTriangle( right, color3, begin, color1, boundary, boundaryColor ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (leftCell.GetEdgeType(rightCell) == HexEdgeType.Slope) { TriangulateBoundaryTriangle( left, color2, right, color3, boundary, boundaryColor ); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { terrain.AddTriangleUnperturbed( HexMetrics.Perturb(left), HexMetrics.Perturb(right), boundary ); terrain.AddTriangleColor(color2, color3, boundaryColor); } }</code> </pre> <br><div style="text-align:center;;text-align:right;direction:rtl"><img src="https://habrastorage.org/getpro/habr/post_images/f89/7e0/e40/f897e0e408335e1e7b198ced5e1dc8ad.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">خريطة إغاثة كاملة. </font></font></i> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">حزمة الوحدة</font></font></a> <br><br><h2 style=";text-align:right;direction:rtl"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> صفائف الملمس </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">الآن بعد أن أصبحت التضاريس لدينا خريطة متقطعة ، يمكننا تمرير مجموعة الملمس إلى التظليل. </font><font style="vertical-align: inherit;">لا يمكننا فقط تعيين جهاز تظليل لصفيف من مواد C # ، لأن الصفيف يجب أن يكون موجودًا في ذاكرة GPU ككيان واحد. </font><font style="vertical-align: inherit;">سيتعين علينا استخدام كائن خاص </font></font><code>Texture2DArray</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">تم دعمه في Unity منذ الإصدار 5.4.</font></font><br><br><div class="spoiler" style=";text-align:right;direction:rtl"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">هل تدعم جميع GPUs المصفوفات النسيجية؟</font></font></b> <div class="spoiler_text" style=";text-align:right;direction:rtl">  GPU  ,         .      <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u="> Unity</a> . <br><ul style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl"> Direct3D 11/12 (Windows, Xbox One) </li><li style=";text-align:right;direction:rtl"> OpenGL Core (Mac OS X, Linux) </li><li style=";text-align:right;direction:rtl"> Metal (iOS, Mac OS X) </li><li style=";text-align:right;direction:rtl"> OpenGL ES 3.0 (Android, iOS, WebGL 2.0) </li><li style=";text-align:right;direction:rtl"> PlayStation 4 </li></ul></div></div><br><br><h3 style=";text-align:right;direction:rtl"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> السيد </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">لسوء الحظ ، فإن دعم Unity لمصفوفات الملمس في الإصدار 5.5 هو الحد الأدنى. </font><font style="vertical-align: inherit;">لا يمكننا فقط إنشاء أصل صفيف نسيج وتعيين مواد له. </font><font style="vertical-align: inherit;">علينا القيام بذلك يدويًا. </font><font style="vertical-align: inherit;">يمكننا إما إنشاء مجموعة من القوام في وضع التشغيل ، أو إنشاء أصل في المحرر. </font><font style="vertical-align: inherit;">دعونا إنشاء أصل.</font></font><br><br><div class="spoiler" style=";text-align:right;direction:rtl"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">لماذا إنشاء أصل؟</font></font></b> <div class="spoiler_text" style=";text-align:right;direction:rtl">     ,         Play    .        ,        . <br><br>     ,    . Unity            .            ,    . ,       . </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">لإنشاء مجموعة من القوام ، سنقوم بتجميع سيدنا. </font><font style="vertical-align: inherit;">قم بإنشاء برنامج نصي </font></font><code>TextureArrayWizard</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ووضعه داخل مجلد </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">المحرر</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">بدلاً من ذلك ، </font></font><code>MonoBehaviour</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">يجب أن يمتد النوع </font></font><code>ScriptableWizard</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">من مساحة الاسم </font></font><code>UnityEditor</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre style=";text-align:right;direction:rtl"> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEditor; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">TextureArrayWizard</span></span> : <span class="hljs-title"><span class="hljs-title">ScriptableWizard</span></span> { }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">يمكننا فتح المعالج من خلال طريقة ثابتة معممة </font></font><code>ScriptableWizard.DisplayWizard</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">معلماته هي أسماء نافذة المعالج وزر إنشاء الخاص به. </font><font style="vertical-align: inherit;">سوف نسمي هذه الطريقة بطريقة ثابتة </font></font><code>CreateWizard</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre style=";text-align:right;direction:rtl"> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateWizard</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { ScriptableWizard.DisplayWizard&lt;TextureArrayWizard&gt;( <span class="hljs-string"><span class="hljs-string">"Create Texture Array"</span></span>, <span class="hljs-string"><span class="hljs-string">"Create"</span></span> ); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">للوصول إلى المعالج من خلال المحرر ، نحتاج إلى إضافة هذه الطريقة إلى قائمة الوحدة. </font><font style="vertical-align: inherit;">يمكن القيام بذلك عن طريق إضافة سمة إلى الأسلوب </font></font><code>MenuItem</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">دعنا نضيفه إلى قائمة </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">الأصول</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ، وبشكل أكثر تحديدًا إلى </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Assets / Create / Texture Array</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><pre style=";text-align:right;direction:rtl"> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">MenuItem(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"Assets/Create/Texture Array"</span></span></span><span class="hljs-meta">)</span></span>] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateWizard</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { … }</code> </pre> <br><div style="text-align:center;;text-align:right;direction:rtl"><img src="https://habrastorage.org/getpro/habr/post_images/f7d/2b4/433/f7d2b44333870be6838dcd48ea3a697f.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">معالجنا المخصص. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">باستخدام عنصر القائمة الجديد ، يمكنك فتح القائمة المنبثقة لمعالجنا المخصص. </font><font style="vertical-align: inherit;">إنها ليست جميلة جدًا ، ولكنها مناسبة لحل المشكلة. </font><font style="vertical-align: inherit;">ومع ذلك ، لا تزال فارغة. </font><font style="vertical-align: inherit;">لإنشاء مجموعة من القوام ، نحتاج إلى مجموعة من القوام. </font><font style="vertical-align: inherit;">أضف حقلًا عامًا إليها للسيد. </font><font style="vertical-align: inherit;">تعرضه واجهة المستخدم الرسومية القياسية للمعالج كما يفعل مفتش قياسي.</font></font><br><br><pre style=";text-align:right;direction:rtl"> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Texture2D[] textures;</code> </pre> <br><div style="text-align:center;;text-align:right;direction:rtl"><img src="https://habrastorage.org/getpro/habr/post_images/beb/aa7/d6d/bebaa7d6dd8e0d995ea485d670ea5a0a.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ماجستير مع مواد.</font></font></i> <br><br><h3 style=";text-align:right;direction:rtl"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> لنقم بإنشاء شيء </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">عند النقر فوق الزر </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">إنشاء</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> المعالج ، يختفي. </font><font style="vertical-align: inherit;">بالإضافة إلى ذلك ، تشكو الوحدة من عدم وجود طريقة </font></font><code>OnWizardCreate</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">هذه هي الطريقة التي يتم استدعاؤها عند النقر فوق الزر إنشاء ، لذلك نحتاج إلى إضافته إلى المعالج.</font></font><br><br><pre style=";text-align:right;direction:rtl"> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnWizardCreate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">هنا سنقوم بإنشاء مجموعة نسيج لدينا. </font><font style="vertical-align: inherit;">على الأقل إذا أضاف المستخدم مواد إلى المعلم. </font><font style="vertical-align: inherit;">إذا لم يكن الأمر كذلك ، فلا يوجد شيء لإنشاءه ويجب إيقاف العمل.</font></font><br><br><pre style=";text-align:right;direction:rtl"> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnWizardCreate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (textures.Length == <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">الخطوة التالية هي طلب الموقع لحفظ أصل صفيف النسيج. </font><font style="vertical-align: inherit;">يمكن فتح لوحة حفظ الملف باستخدام الطريقة </font></font><code>EditorUtility.SaveFilePanelInProject</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">تحدد معلماته اسم اللوحة واسم الملف الافتراضي وملحق الملف والوصف. </font><font style="vertical-align: inherit;">تستخدم صفائف الزخرفة امتداد ملف </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">الأصل</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> العام </font><font style="vertical-align: inherit;">.</font></font><br><br><pre style=";text-align:right;direction:rtl"> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (textures.Length == <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } EditorUtility.SaveFilePanelInProject( <span class="hljs-string"><span class="hljs-string">"Save Texture Array"</span></span>, <span class="hljs-string"><span class="hljs-string">"Texture Array"</span></span>, <span class="hljs-string"><span class="hljs-string">"asset"</span></span>, <span class="hljs-string"><span class="hljs-string">"Save Texture Array"</span></span> );</code> </pre> <br> <code>SaveFilePanelInProject</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">إرجاع مسار الملف المحدد من قبل المستخدم. </font><font style="vertical-align: inherit;">إذا قام المستخدم بالنقر فوق "إلغاء الأمر" في هذه اللوحة ، فسيكون المسار عبارة عن سلسلة فارغة. </font><font style="vertical-align: inherit;">لذلك ، في هذه الحالة ، يجب علينا مقاطعة العمل.</font></font><br><br><pre style=";text-align:right;direction:rtl"> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> path = EditorUtility.SaveFilePanelInProject( <span class="hljs-string"><span class="hljs-string">"Save Texture Array"</span></span>, <span class="hljs-string"><span class="hljs-string">"Texture Array"</span></span>, <span class="hljs-string"><span class="hljs-string">"asset"</span></span>, <span class="hljs-string"><span class="hljs-string">"Save Texture Array"</span></span> ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (path.Length == <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; }</code> </pre> <br><h3 style=";text-align:right;direction:rtl"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> إنشاء مجموعة من القوام </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">إذا كان لدينا المسار الصحيح ، فيمكننا المضي قدمًا وإنشاء كائن جديد </font></font><code>Texture2DArray</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">تتطلب طريقة المُنشئ تحديد عرض وارتفاع النسيج ، وطول المصفوفة ، وتنسيق القوام ، والحاجة إلى تركيب mip. </font><font style="vertical-align: inherit;">يجب أن تكون هذه المعلمات هي نفسها لجميع الأنسجة في الصفيف. </font><font style="vertical-align: inherit;">لتكوين الكائن ، نستخدم النسيج الأول. </font><font style="vertical-align: inherit;">يجب على المستخدم التحقق من أن جميع الأنسجة لها نفس التنسيق.</font></font><br><br><pre style=";text-align:right;direction:rtl"> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (path.Length == <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } Texture2D t = textures[<span class="hljs-number"><span class="hljs-number">0</span></span>]; Texture2DArray textureArray = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Texture2DArray( t.width, t.height, textures.Length, t.format, t.mipmapCount &gt; <span class="hljs-number"><span class="hljs-number">1</span></span> );</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">نظرًا لأن صفيف النسيج هو مورد GPU واحد ، فإنه يستخدم نفس أوضاع التصفية والطي لجميع الأنسجة. </font><font style="vertical-align: inherit;">هنا نستخدم مرة أخرى النسيج الأول لإعداد كل شيء.</font></font><br><br><pre style=";text-align:right;direction:rtl"> <code class="cs hljs"> Texture2DArray textureArray = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Texture2DArray( t.width, t.height, textures.Length, t.format, t.mipmapCount &gt; <span class="hljs-number"><span class="hljs-number">1</span></span> ); textureArray.anisoLevel = t.anisoLevel; textureArray.filterMode = t.filterMode; textureArray.wrapMode = t.wrapMode;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">الآن يمكننا نسخ الأنسجة إلى مصفوفة باستخدام الطريقة </font></font><code>Graphics.CopyTexture</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">تقوم الطريقة بنسخ بيانات النسيج الخام ، مستوى mip واحد في كل مرة. </font><font style="vertical-align: inherit;">لذلك ، نحتاج إلى الالتفاف حول جميع القوام ومستويات mip الخاصة بها. </font><font style="vertical-align: inherit;">معلمات الطريقة هي مجموعتان تتكونان من مورد نسيج وفهرس ومستوى mip. </font><font style="vertical-align: inherit;">نظرًا لأن الأنسجة الأصلية ليست صفائف ، فإن فهرسها دائمًا صفر.</font></font><br><br><pre style=";text-align:right;direction:rtl"> <code class="cs hljs"> textureArray.wrapMode = t.wrapMode; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; textures.Length; i++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> m = <span class="hljs-number"><span class="hljs-number">0</span></span>; m &lt; t.mipmapCount; m++) { Graphics.CopyTexture(textures[i], <span class="hljs-number"><span class="hljs-number">0</span></span>, m, textureArray, i, m); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">في هذه المرحلة ، لدينا في الذاكرة الصفيف الصحيح من القوام ، لكنها ليست أصلًا حتى الآن. </font><font style="vertical-align: inherit;">ستكون الخطوة الأخيرة هي استدعاء </font></font><code>AssetDatabase.CreateAsset</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">الصفيف ومساره. </font><font style="vertical-align: inherit;">في هذه الحالة ، ستتم كتابة البيانات في ملف في مشروعنا ، وستظهر في نافذة المشروع.</font></font><br><br><pre style=";text-align:right;direction:rtl"> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; textures.Length; i++) { … } AssetDatabase.CreateAsset(textureArray, path);</code> </pre> <br><br><h3 style=";text-align:right;direction:rtl"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> القوام </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">لإنشاء مجموعة حقيقية من القوام ، نحتاج إلى القوام الأصلي. فيما يلي خمسة مواد تطابق الألوان التي استخدمناها حتى الآن. يصبح الأصفر رملًا ، والأخضر يصبح عشبًا ، والأزرق يصبح الأرض ، والبرتقال يصبح الحجر ، والأبيض يصبح الثلج.</font></font><br><br><div style="text-align:center;;text-align:right;direction:rtl"><img src="https://habrastorage.org/getpro/habr/post_images/195/104/a40/195104a4070bfa42e6c4e0eaff218d42.png"></div><br><div style="text-align:center;;text-align:right;direction:rtl"><img src="https://habrastorage.org/getpro/habr/post_images/0d7/777/f86/0d7777f865b086c46a1c95a06380c66a.png"></div><br><div style="text-align:center;;text-align:right;direction:rtl"><img src="https://habrastorage.org/getpro/habr/post_images/0f8/30b/55f/0f830b55ffdbc729bc02d013805bb2c3.png"></div><br><div style="text-align:center;;text-align:right;direction:rtl"><img src="https://habrastorage.org/getpro/habr/post_images/347/4eb/37b/3474eb37b3a5404866a6fd384e9c6352.png"></div><br><div style="text-align:center;;text-align:right;direction:rtl"><img src="https://habrastorage.org/getpro/habr/post_images/6de/0eb/fa3/6de0ebfa32b5b0b04c8c082e6cce0c01.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">قوام الرمل والعشب والأرض والحجر والثلج. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">لاحظ أن هذه القوام ليست صورًا لهذا الارتياح. </font><font style="vertical-align: inherit;">هذه هي الأنماط الزائفة العشوائية السهلة التي أنشأتها باستخدام </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NumberFlow</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">لقد سعت إلى إنشاء أنواع وتفاصيل الإغاثة البارزة التي لا تتعارض مع الإغاثة المضلعة المجردة. </font><font style="vertical-align: inherit;">تبين أن الواقعية الواقعية غير مناسبة لذلك. </font><font style="vertical-align: inherit;">بالإضافة إلى ذلك ، على الرغم من أن الأنماط تضيف تنوعًا ، إلا أن هناك ميزات قليلة مميزة فيها تجعل التكرار ملحوظًا على الفور. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">أضف هذه الأنسجة إلى الصفيف الرئيسي ، مع التأكد من أن ترتيبها يطابق الألوان. </font><font style="vertical-align: inherit;">أي الرمال أولاً ، ثم العشب والأرض والحجر وأخيرًا الثلج.</font></font><br><br><div style="text-align:center;;text-align:right;direction:rtl"><img src="https://habrastorage.org/getpro/habr/post_images/5ec/511/2a1/5ec5112a1bdaa4f170ec382b2549ad9d.png"></div><br><div style="text-align:center;;text-align:right;direction:rtl"><img src="https://habrastorage.org/getpro/habr/post_images/a54/4e8/1f0/a544e81f0c74fa36290553a6c6a328df.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">إنشاء مجموعة من القوام. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">بعد إنشاء أصل صفيف النسيج ، حدده وافحصه في المفتش.</font></font><br><br><div style="text-align:center;;text-align:right;direction:rtl"><img src="https://habrastorage.org/getpro/habr/post_images/6e1/8f3/8d6/6e18f38d6682f71b3c8a999823642cd4.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">مفتش مجموعة الملمس.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> هذا هو أبسط عرض لقطعة من بيانات صفيف النسيج. لاحظ أن هناك مفتاح </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Is Readable</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> قيد التشغيل في البداية. نظرًا لأننا لا نحتاج إلى قراءة بيانات البكسل من الصفيف ، فأوقف تشغيلها. لا يمكننا القيام بذلك في المعالج لأنه لا </font></font><code>Texture2DArray</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">توجد طرق أو خصائص للوصول إلى هذه المعلمة. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(في Unity 5.6 ، هناك خطأ يفسد صفائف الملمس في التجميعات على العديد من المنصات. يمكنك الالتفاف حولها دون تعطيل إمكانية </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">القراءة</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .) </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">وتجدر الإشارة أيضًا إلى وجود حقل </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Color Space</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">والتي تم تعيينها للقيمة 1. هذا يعني أن المواد يفترض أنها في مساحة جاما ، وهذا صحيح. </font><font style="vertical-align: inherit;">إذا كان من المفترض أن تكون في مساحة خطية ، فيجب تعيين الحقل على 0. في الواقع ، المصمم </font></font><code>Texture2DArray</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">لديه معلمة إضافية لتحديد مساحة اللون ، لكنه </font></font><code>Texture2D</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">لا يظهر ما إذا كان في مساحة خطية أم لا ، لذلك ، على أي حال ، تحتاج إلى تعيين القيمة يدويًا.</font></font><br><br><h3 style=";text-align:right;direction:rtl"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> شادر </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">الآن بعد أن أصبح لدينا مجموعة من القوام ، نحتاج إلى تعليم shader كيفية العمل معها. </font><font style="vertical-align: inherit;">في الوقت الحالي ، نستخدم تظليل </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">VertexColors</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> لتقديم التضاريس </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">نظرًا لأننا سنستخدم الآن القوام بدلاً من الألوان ، نعيد تسميته إلى </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Terrain</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">ثم نحول معلمة </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">_MainTex</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> إلى مصفوفة من الأنسجة </font><em><font style="vertical-align: inherit;">ونعينها</font></em><font style="vertical-align: inherit;"> مادة عرض.</font></font><br><br><pre style=";text-align:right;direction:rtl"> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">Shader</span></span> <span class="hljs-string"><span class="hljs-string">"Custom/Terrain"</span></span> { <span class="hljs-section"><span class="hljs-section">Properties</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">_Color</span></span> (<span class="hljs-string"><span class="hljs-string">"Color"</span></span>, Color) = (<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>) _MainTex (<span class="hljs-string"><span class="hljs-string">"Terrain Texture Array"</span></span>, 2DArray) = <span class="hljs-string"><span class="hljs-string">"white"</span></span> {} <span class="hljs-attribute"><span class="hljs-attribute">_Glossiness</span></span> (<span class="hljs-string"><span class="hljs-string">"Smoothness"</span></span>, Range(<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>)) = <span class="hljs-number"><span class="hljs-number">0</span></span>.<span class="hljs-number"><span class="hljs-number">5</span></span> _Metallic (<span class="hljs-string"><span class="hljs-string">"Metallic"</span></span>, Range(<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>)) = <span class="hljs-number"><span class="hljs-number">0</span></span>.<span class="hljs-number"><span class="hljs-number">0</span></span> } … }</code> </pre> <br><div style="text-align:center;;text-align:right;direction:rtl"><img src="https://habrastorage.org/getpro/habr/post_images/878/0b2/3de/8780b23ded3ced3ab980a039d0f5753d.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">مواد الإغاثة مع مجموعة من القوام. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">لتمكين صفائف النسيج على جميع الأنظمة الأساسية التي تدعمها ، تحتاج إلى زيادة المستوى المستهدف للتظليل من 3.0 إلى 3.5.</font></font><br><br><pre style=";text-align:right;direction:rtl"> <code class="hljs cs"> <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> target 3.5</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">نظرًا لأن المتغير </font></font><code>_MainTex</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">يشير الآن إلى مجموعة من القوام ، فنحن بحاجة إلى تغيير نوعه. </font><font style="vertical-align: inherit;">يعتمد النوع على النظام الأساسي المستهدف وسيتولى الماكرو هذا الأمر </font></font><code>UNITY_DECLARE_TEX2DARRAY</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre style=";text-align:right;direction:rtl"> <code class="hljs objectivec"><span class="hljs-comment"><span class="hljs-comment">// sampler2D _MainTex; UNITY_DECLARE_TEX2DARRAY(_MainTex);</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">كما هو الحال في تظليل أخرى ، لأخذ عينات من نسيج الإغاثة ، نحتاج إلى إحداثيات عالم XZ. </font><font style="vertical-align: inherit;">لذلك ، سنضيف موضعًا في العالم إلى بنية إدخال تظليل السطح. </font><font style="vertical-align: inherit;">نحذف أيضًا إحداثيات الأشعة فوق البنفسجية الافتراضية ، لأننا لسنا بحاجة إليها.</font></font><br><br><pre style=";text-align:right;direction:rtl"> <code class="hljs swift"> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Input</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// float2 uv_MainTex; float4 color : COLOR; float3 worldPos; };</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">لأخذ عينة من مجموعة من الأنسجة ، نحتاج إلى استخدام ماكرو </font></font><code>UNITY_SAMPLE_TEX2DARRAY</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">لأخذ عينة من صفيف ، يحتاج إلى ثلاثة إحداثيات. </font><font style="vertical-align: inherit;">الأولين هما إحداثيات الأشعة فوق البنفسجية العادية. </font><font style="vertical-align: inherit;">سنستخدم إحداثيات XZ العالمية التي تم تغيير حجمها إلى 0.02. </font><font style="vertical-align: inherit;">لذلك نحصل على دقة نسيج جيدة في التكبير الكامل. </font><font style="vertical-align: inherit;">سيتم تكرار القوام كل أربع خلايا تقريبًا. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">يتم استخدام الإحداثيات الثالثة كمؤشر لصفيف النسيج ، كما هو الحال في الصفيف العادي. </font><font style="vertical-align: inherit;">نظرًا لأن الإحداثيات تطفو ، قبل فهرسة مصفوفة GPU تقريبها. </font><font style="vertical-align: inherit;">منذ أن عرفنا الملمس المطلوب ، دعنا نستخدم الأول دائمًا. </font><font style="vertical-align: inherit;">أيضا ، لن يؤثر لون القمة على النتيجة النهائية ، لأنها خريطة دائرية.</font></font><br><br><pre style=";text-align:right;direction:rtl"> <code class="hljs pgsql"> <span class="hljs-type"><span class="hljs-type">void</span></span> surf (<span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">inout</span></span> SurfaceOutputStandard o) { float2 uv = <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.worldPos.xz * <span class="hljs-number"><span class="hljs-number">0.02</span></span>; fixed4 c = UNITY_SAMPLE_TEX2DARRAY(_MainTex, float3(uv, <span class="hljs-number"><span class="hljs-number">0</span></span>)); Albedo = c.rgb * _Color; o.Metallic = _Metallic; o.Smoothness = _Glossiness; o.Alpha = ca; }</code> </pre> <br><div style="text-align:center;;text-align:right;direction:rtl"><img src="https://habrastorage.org/getpro/habr/post_images/c08/a19/df0/c08a19df0f6c0674406e4922b6595585.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">كل شيء أصبح رمال. </font></font></i> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">حزمة الوحدة</font></font></a> <br><br><h2 style=";text-align:right;direction:rtl"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> اختيار الملمس </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">نحن بحاجة إلى خريطة تضخيم الإغاثة التي تمزج الأنواع الثلاثة في مثلث. </font><font style="vertical-align: inherit;">لدينا مجموعة من القوام مع نسيج لكل نوع من التضاريس. </font><font style="vertical-align: inherit;">لدينا تظليل يختبر مجموعة من القوام. </font><font style="vertical-align: inherit;">ولكن في الوقت الحالي ، ليس لدينا طريقة لإخبار تظليل القوام الذي يجب اختياره لكل مثلث. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">نظرًا لأن كل مثلث يخلط ما يصل إلى ثلاثة أنواع ، نحتاج إلى ربط ثلاثة مؤشرات بكل مثلث. </font><font style="vertical-align: inherit;">لا يمكننا تخزين معلومات للمثلثات ، لذا علينا تخزين فهارس القمم. </font><font style="vertical-align: inherit;">ستخزن جميع رؤوس المثلث الثلاثة ببساطة نفس المؤشرات كما هو الحال مع اللون الصلب.</font></font><br><br><h3 style=";text-align:right;direction:rtl"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> بيانات الشبكات </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">يمكننا استخدام إحدى مجموعات شبكة الأشعة فوق البنفسجية لتخزين المؤشرات. </font><font style="vertical-align: inherit;">نظرًا لأنه يتم تخزين ثلاثة فهارس على كل قمة ، فلن تكون مجموعات الأشعة فوق البنفسجية ثنائية الأبعاد الموجودة كافية. </font><font style="vertical-align: inherit;">لحسن الحظ ، يمكن أن تحتوي مجموعات الأشعة فوق البنفسجية على ما يصل إلى أربعة إحداثيات. </font><font style="vertical-align: inherit;">لذلك ، نضيف إلى </font></font><code>HexMesh</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">القائمة الثانية </font></font><code>Vector3</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">، التي سنشير إليها بأنواع الإغاثة.</font></font><br><br><pre style=";text-align:right;direction:rtl"> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> useCollider, useColors, useUVCoordinates, useUV2Coordinates; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> useTerrainTypes; [NonSerialized] List&lt;Vector3&gt; vertices, terrainTypes;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">تمكين أنواع </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">التضاريس</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> لطفل </font><em><font style="vertical-align: inherit;">التضاريس</font></em><font style="vertical-align: inherit;"> من </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hex Grid Chunk</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> الجاهزة </font><font style="vertical-align: inherit;">.</font></font><br><br><div style="text-align:center;;text-align:right;direction:rtl"><img src="https://habrastorage.org/getpro/habr/post_images/728/0c5/4eb/7280c54ebcd1a6063fb3df9f0328cc5b.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">نستخدم أنواع الإغاثة. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">إذا لزم الأمر ، سنأخذ قائمة أخرى </font></font><code>Vector3</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">لأنواع الإغاثة أثناء تنظيف الشبكة.</font></font><br><br><pre style=";text-align:right;direction:rtl"> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Clear</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { … <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (useTerrainTypes) { terrainTypes = ListPool&lt;Vector3&gt;.Get(); } triangles = ListPool&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;.Get(); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">في عملية تطبيق بيانات الشبكة ، نقوم بحفظ أنواع الإغاثة في مجموعة الأشعة فوق البنفسجية الثالثة. </font><font style="vertical-align: inherit;">وبسبب هذا ، لن يتعارضوا مع مجموعتين أخريين ، إذا قررنا استخدامها معًا.</font></font><br><br><pre style=";text-align:right;direction:rtl"> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Apply</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { … <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (useTerrainTypes) { hexMesh.SetUVs(<span class="hljs-number"><span class="hljs-number">2</span></span>, terrainTypes); ListPool&lt;Vector3&gt;.Add(terrainTypes); } hexMesh.SetTriangles(triangles, <span class="hljs-number"><span class="hljs-number">0</span></span>); … }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">لتعيين أنواع الإغاثة من المثلث ، سوف نستخدمها </font></font><code>Vector3</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">بما أن تلك هي نفسها للمثلث بأكمله ، فإننا نضيف نفس البيانات ثلاث مرات فقط.</font></font><br><br><pre style=";text-align:right;direction:rtl"> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddTriangleTerrainTypes</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 types</span></span></span><span class="hljs-function">)</span></span> { terrainTypes.Add(types); terrainTypes.Add(types); terrainTypes.Add(types); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">الاختلاط في رباعية يعمل بالطريقة نفسها. </font><font style="vertical-align: inherit;">جميع القمم الأربعة من نفس النوع.</font></font><br><br><pre style=";text-align:right;direction:rtl"> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddQuadTerrainTypes</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 types</span></span></span><span class="hljs-function">)</span></span> { terrainTypes.Add(types); terrainTypes.Add(types); terrainTypes.Add(types); terrainTypes.Add(types); }</code> </pre> <br><h3 style=";text-align:right;direction:rtl"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> مراوح مثلثات الأضلاع </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">الآن نحن بحاجة إلى إضافة أنواع إلى بيانات الشبكة في </font></font><code>HexGridChunk</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">لنبدأ </font></font><code>TriangulateEdgeFan</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">أولاً ، من أجل سهولة القراءة ، لنقم بتقسيم استدعاءات أسلوب الرأس واللون. </font><font style="vertical-align: inherit;">تذكر أنه مع كل استدعاء لهذه الطريقة ، نمرره إليه </font></font><code>color1</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">، حتى نتمكن من استخدام هذا اللون مباشرة ، ولا نطبق المعلمة.</font></font><br><br><pre style=";text-align:right;direction:rtl"> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateEdgeFan</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 center, EdgeVertices edge, Color color</span></span></span><span class="hljs-function">)</span></span> { terrain.AddTriangle(center, edge.v1, edge.v2); <span class="hljs-comment"><span class="hljs-comment">// terrain.AddTriangleColor(color); terrain.AddTriangle(center, edge.v2, edge.v3); // terrain.AddTriangleColor(color); terrain.AddTriangle(center, edge.v3, edge.v4); // terrain.AddTriangleColor(color); terrain.AddTriangle(center, edge.v4, edge.v5); // terrain.AddTriangleColor(color); terrain.AddTriangleColor(color1); terrain.AddTriangleColor(color1); terrain.AddTriangleColor(color1); terrain.AddTriangleColor(color1); }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">بعد الألوان ، نضيف أنواع الإغاثة. </font><font style="vertical-align: inherit;">نظرًا لأن الأنواع في المثلث قد تكون مختلفة ، يجب أن تكون هذه معلمة تحل محل اللون. </font><font style="vertical-align: inherit;">استخدم هذا النوع البسيط لإنشاء </font></font><code>Vector3</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">القنوات الأربع الأولى فقط هي المهمة بالنسبة لنا ، لأنه في هذه الحالة تكون خريطة الدائرة الحمراء دائمًا. </font><font style="vertical-align: inherit;">نظرًا لأن جميع مكونات المتجه الثلاثة بحاجة إلى التعيين ، فلنعينها نوعًا واحدًا.</font></font><br><br><pre style=";text-align:right;direction:rtl"> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateEdgeFan</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 center, EdgeVertices edge, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> type</span></span></span><span class="hljs-function">)</span></span> { … Vector3 types; types.x = types.y = types.z = type; terrain.AddTriangleTerrainTypes(types); terrain.AddTriangleTerrainTypes(types); terrain.AddTriangleTerrainTypes(types); terrain.AddTriangleTerrainTypes(types); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">نحتاج الآن إلى تغيير جميع المكالمات لهذه الطريقة ، مع استبدال وسيطة اللون بفهرس من نوع تضاريس الخلية. </font><font style="vertical-align: inherit;">Vnesom هذا التغيير </font></font><code>TriangulateWithoutRiver</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">، </font></font><code>TriangulateAdjacentToRiver</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">و </font></font><code>TriangulateWithRiverBeginOrEnd</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre style=";text-align:right;direction:rtl"> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// TriangulateEdgeFan(center, e, color1); TriangulateEdgeFan(center, e, cell.TerrainTypeIndex);</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">عند هذه النقطة ، عند بدء وضع التشغيل ، ستظهر أخطاء تخبرك أن المجموعات الثالثة من شبكات الأشعة فوق البنفسجية خارج الحدود. </font><font style="vertical-align: inherit;">حدث هذا لأننا لا نضيف أنواع الإغاثة إلى كل مثلث ورباعي حتى الآن. </font><font style="vertical-align: inherit;">لذلك دعونا نواصل التغيير </font></font><code>HexGridChunk</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><h3 style=";text-align:right;direction:rtl"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> خطوط الضلع </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">الآن عند إنشاء شريط حافة ، نحتاج إلى معرفة أنواع التضاريس الموجودة على كلا الجانبين. </font><font style="vertical-align: inherit;">لذلك ، نضيفها كمعلمات ، ثم ننشئ متجهًا للأنواع التي يتم تعيين قناتين لها هذه الأنواع. </font><font style="vertical-align: inherit;">القناة الثالثة ليست مهمة ، لذا فقط قم بتعادلها مع القناة الأولى. </font><font style="vertical-align: inherit;">بعد إضافة الألوان ، أضف الأنواع إلى الرباعي.</font></font><br><br><pre style=";text-align:right;direction:rtl"> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateEdgeStrip</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> EdgeVertices e1, Color c1, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> type1, EdgeVertices e2, Color c2, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> type2, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> hasRoad = </span></span><span class="hljs-literal"><span class="hljs-function"><span class="hljs-params"><span class="hljs-literal">false</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span></span><span class="hljs-function">)</span></span> { terrain.AddQuad(e1.v1, e1.v2, e2.v1, e2.v2); terrain.AddQuad(e1.v2, e1.v3, e2.v2, e2.v3); terrain.AddQuad(e1.v3, e1.v4, e2.v3, e2.v4); terrain.AddQuad(e1.v4, e1.v5, e2.v4, e2.v5); terrain.AddQuadColor(c1, c2); terrain.AddQuadColor(c1, c2); terrain.AddQuadColor(c1, c2); terrain.AddQuadColor(c1, c2); Vector3 types; types.x = types.z = type1; types.y = type2; terrain.AddQuadTerrainTypes(types); terrain.AddQuadTerrainTypes(types); terrain.AddQuadTerrainTypes(types); terrain.AddQuadTerrainTypes(types); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (hasRoad) { TriangulateRoadSegment(e1.v2, e1.v3, e1.v4, e2.v2, e2.v3, e2.v4); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">الآن نحن بحاجة إلى تغيير التحديات </font></font><code>TriangulateEdgeStrip</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">أولا </font></font><code>TriangulateAdjacentToRiver</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">، </font></font><code>TriangulateWithRiverBeginOrEnd</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">و </font></font><code>TriangulateWithRiver</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">يجب استخدام نوع من الخلايا لكلا الجانبين من قطاع الزعانف.</font></font><br><br><pre style=";text-align:right;direction:rtl"> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// TriangulateEdgeStrip(m, color1, e, color1); TriangulateEdgeStrip( m, color1, cell.TerrainTypeIndex, e, color1, cell.TerrainTypeIndex );</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">بعد ذلك ، </font></font><code>TriangulateConnection</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">يجب أن تستخدم </font><font style="vertical-align: inherit;">أبسط حالة للحافة </font><font style="vertical-align: inherit;">نوع الخلية لأقرب حافة ونوع الجوار للحافة البعيدة. </font><font style="vertical-align: inherit;">يمكن أن تكون هي نفسها أو مختلفة.</font></font><br><br><pre style=";text-align:right;direction:rtl"> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateConnection</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> HexDirection direction, HexCell cell, EdgeVertices e1 </span></span></span><span class="hljs-function">)</span></span> { … <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.GetEdgeType(direction) == HexEdgeType.Slope) { TriangulateEdgeTerraces(e1, cell, e2, neighbor, hasRoad); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-comment"><span class="hljs-comment">// TriangulateEdgeStrip(e1, color1, e2, color2, hasRoad); TriangulateEdgeStrip( e1, color1, cell.TerrainTypeIndex, e2, color2, neighbor.TerrainTypeIndex, hasRoad ); } … }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">الأمر نفسه ينطبق على </font></font><code>TriangulateEdgeTerraces</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ما يحفز ثلاث مرات </font></font><code>TriangulateEdgeStrip</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">أنواع الحواف هي نفسها.</font></font><br><br><pre style=";text-align:right;direction:rtl"> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateEdgeTerraces</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> EdgeVertices begin, HexCell beginCell, EdgeVertices end, HexCell endCell, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> hasRoad </span></span></span><span class="hljs-function">)</span></span> { EdgeVertices e2 = EdgeVertices.TerraceLerp(begin, end, <span class="hljs-number"><span class="hljs-number">1</span></span>); Color c2 = HexMetrics.TerraceLerp(color1, color2, <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> t1 = beginCell.TerrainTypeIndex; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> t2 = endCell.TerrainTypeIndex; TriangulateEdgeStrip(begin, color1, t1, e2, c2, t2, hasRoad); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">2</span></span>; i &lt; HexMetrics.terraceSteps; i++) { EdgeVertices e1 = e2; Color c1 = c2; e2 = EdgeVertices.TerraceLerp(begin, end, i); c2 = HexMetrics.TerraceLerp(color1, color2, i); TriangulateEdgeStrip(e1, c1, t1, e2, c2, t2, hasRoad); } TriangulateEdgeStrip(e2, c2, t1, end, color2, t2, hasRoad); }</code> </pre> <br><h3 style=";text-align:right;direction:rtl"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> الزوايا </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">أبسط حالة لزاوية مثلث بسيط. </font><font style="vertical-align: inherit;">تنقل الخلية السفلية النوع الأول ، والنوع الأيسر الثاني ، والنوع الأيمن الثالث. </font><font style="vertical-align: inherit;">باستخدامها ، قم بإنشاء متجه لأنواع وإضافته إلى المثلث.</font></font><br><br><pre style=";text-align:right;direction:rtl"> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateCorner</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 bottom, HexCell bottomCell, Vector3 left, HexCell leftCell, Vector3 right, HexCell rightCell </span></span></span><span class="hljs-function">)</span></span> { … <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { terrain.AddTriangle(bottom, left, right); terrain.AddTriangleColor(color1, color2, color3); Vector3 types; types.x = bottomCell.TerrainTypeIndex; types.y = leftCell.TerrainTypeIndex; types.z = rightCell.TerrainTypeIndex; terrain.AddTriangleTerrainTypes(types); } features.AddWall(bottom, bottomCell, left, leftCell, right, rightCell); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">نحن نستخدم نفس النهج </font></font><code>TriangulateCornerTerraces</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">، هنا فقط نقوم بإنشاء مجموعة من quad-s.</font></font><br><br><pre style=";text-align:right;direction:rtl"> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateCornerTerraces</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 begin, HexCell beginCell, Vector3 left, HexCell leftCell, Vector3 right, HexCell rightCell </span></span></span><span class="hljs-function">)</span></span> { Vector3 v3 = HexMetrics.TerraceLerp(begin, left, <span class="hljs-number"><span class="hljs-number">1</span></span>); Vector3 v4 = HexMetrics.TerraceLerp(begin, right, <span class="hljs-number"><span class="hljs-number">1</span></span>); Color c3 = HexMetrics.TerraceLerp(color1, color2, <span class="hljs-number"><span class="hljs-number">1</span></span>); Color c4 = HexMetrics.TerraceLerp(color1, color3, <span class="hljs-number"><span class="hljs-number">1</span></span>); Vector3 types; types.x = beginCell.TerrainTypeIndex; types.y = leftCell.TerrainTypeIndex; types.z = rightCell.TerrainTypeIndex; terrain.AddTriangle(begin, v3, v4); terrain.AddTriangleColor(color1, c3, c4); terrain.AddTriangleTerrainTypes(types); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">2</span></span>; i &lt; HexMetrics.terraceSteps; i++) { Vector3 v1 = v3; Vector3 v2 = v4; Color c1 = c3; Color c2 = c4; v3 = HexMetrics.TerraceLerp(begin, left, i); v4 = HexMetrics.TerraceLerp(begin, right, i); c3 = HexMetrics.TerraceLerp(color1, color2, i); c4 = HexMetrics.TerraceLerp(color1, color3, i); terrain.AddQuad(v1, v2, v3, v4); terrain.AddQuadColor(c1, c2, c3, c4); terrain.AddQuadTerrainTypes(types); } terrain.AddQuad(v3, v4, left, right); terrain.AddQuadColor(c3, c4, color2, color3); terrain.AddQuadTerrainTypes(types); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">عند خلط الحواف والمنحدرات ، نحتاج إلى استخدامها </font></font><code>TriangulateBoundaryTriangle</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">فقط قم بإعطائها معلمة كتابة متجهة وإضافتها إلى كل مثلثاتها.</font></font><br><br><pre style=";text-align:right;direction:rtl"> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateBoundaryTriangle</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 begin, Color beginColor, Vector3 left, Color leftColor, Vector3 boundary, Color boundaryColor, Vector3 types </span></span></span><span class="hljs-function">)</span></span> { Vector3 v2 = HexMetrics.Perturb(HexMetrics.TerraceLerp(begin, left, <span class="hljs-number"><span class="hljs-number">1</span></span>)); Color c2 = HexMetrics.TerraceLerp(beginColor, leftColor, <span class="hljs-number"><span class="hljs-number">1</span></span>); terrain.AddTriangleUnperturbed(HexMetrics.Perturb(begin), v2, boundary); terrain.AddTriangleColor(beginColor, c2, boundaryColor); terrain.AddTriangleTerrainTypes(types); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">2</span></span>; i &lt; HexMetrics.terraceSteps; i++) { Vector3 v1 = v2; Color c1 = c2; v2 = HexMetrics.Perturb(HexMetrics.TerraceLerp(begin, left, i)); c2 = HexMetrics.TerraceLerp(beginColor, leftColor, i); terrain.AddTriangleUnperturbed(v1, v2, boundary); terrain.AddTriangleColor(c1, c2, boundaryColor); terrain.AddTriangleTerrainTypes(types); } terrain.AddTriangleUnperturbed(v2, HexMetrics.Perturb(left), boundary); terrain.AddTriangleColor(c2, leftColor, boundaryColor); terrain.AddTriangleTerrainTypes(types); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">في </font></font><code>TriangulateCornerTerracesCliff</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">إنشاء ناقلات الأنواع على أساس الخلايا المنقولة. </font><font style="vertical-align: inherit;">ثم أضفه إلى مثلث واحد وأدخله </font></font><code>TriangulateBoundaryTriangle</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre style=";text-align:right;direction:rtl"> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateCornerTerracesCliff</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 begin, HexCell beginCell, Vector3 left, HexCell leftCell, Vector3 right, HexCell rightCell </span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> b = <span class="hljs-number"><span class="hljs-number">1f</span></span> / (rightCell.Elevation - beginCell.Elevation); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (b &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { b = -b; } Vector3 boundary = Vector3.Lerp( HexMetrics.Perturb(begin), HexMetrics.Perturb(right), b ); Color boundaryColor = Color.Lerp(color1, color3, b); Vector3 types; types.x = beginCell.TerrainTypeIndex; types.y = leftCell.TerrainTypeIndex; types.z = rightCell.TerrainTypeIndex; TriangulateBoundaryTriangle( begin, color1, left, color2, boundary, boundaryColor, types ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (leftCell.GetEdgeType(rightCell) == HexEdgeType.Slope) { TriangulateBoundaryTriangle( left, color2, right, color3, boundary, boundaryColor, types ); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { terrain.AddTriangleUnperturbed( HexMetrics.Perturb(left), HexMetrics.Perturb(right), boundary ); terrain.AddTriangleColor(color2, color3, boundaryColor); terrain.AddTriangleTerrainTypes(types); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">وينطبق نفس الشيء </font></font><code>TriangulateCornerCliffTerraces</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre style=";text-align:right;direction:rtl"> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateCornerCliffTerraces</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 begin, HexCell beginCell, Vector3 left, HexCell leftCell, Vector3 right, HexCell rightCell </span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> b = <span class="hljs-number"><span class="hljs-number">1f</span></span> / (leftCell.Elevation - beginCell.Elevation); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (b &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { b = -b; } Vector3 boundary = Vector3.Lerp( HexMetrics.Perturb(begin), HexMetrics.Perturb(left), b ); Color boundaryColor = Color.Lerp(color1, color2, b); Vector3 types; types.x = beginCell.TerrainTypeIndex; types.y = leftCell.TerrainTypeIndex; types.z = rightCell.TerrainTypeIndex; TriangulateBoundaryTriangle( right, color3, begin, color1, boundary, boundaryColor, types ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (leftCell.GetEdgeType(rightCell) == HexEdgeType.Slope) { TriangulateBoundaryTriangle( left, color2, right, color3, boundary, boundaryColor, types ); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { terrain.AddTriangleUnperturbed( HexMetrics.Perturb(left), HexMetrics.Perturb(right), boundary ); terrain.AddTriangleColor(color2, color3, boundaryColor); terrain.AddTriangleTerrainTypes(types); } }</code> </pre> <br><h3 style=";text-align:right;direction:rtl">  الأنهار </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">الطريقة الأخيرة للتغيير هي هذه </font></font><code>TriangulateWithRiver</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">بما أننا هنا في وسط الخلية ، فنحن نتعامل فقط مع نوع الخلية الحالية. </font><font style="vertical-align: inherit;">لذلك ، قم بإنشاء ناقل له وإضافته إلى مثلثات ورباعية.</font></font><br><br><pre style=";text-align:right;direction:rtl"> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateWithRiver</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> HexDirection direction, HexCell cell, Vector3 center, EdgeVertices e </span></span></span><span class="hljs-function">)</span></span> { … terrain.AddTriangleColor(color1); terrain.AddQuadColor(color1); terrain.AddQuadColor(color1); terrain.AddTriangleColor(color1); Vector3 types; types.x = types.y = types.z = cell.TerrainTypeIndex; terrain.AddTriangleTerrainTypes(types); terrain.AddQuadTerrainTypes(types); terrain.AddQuadTerrainTypes(types); terrain.AddTriangleTerrainTypes(types); … }</code> </pre> <br><h3 style=";text-align:right;direction:rtl"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> اكتب مزيج </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">في هذه المرحلة ، تحتوي الشبكات على مؤشرات الارتفاع اللازمة. </font><font style="vertical-align: inherit;">كل ما تبقى لنا هو إجبار تظليل </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">التضاريس</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> على </font><font style="vertical-align: inherit;">استخدامها. </font><font style="vertical-align: inherit;">من أجل أن تقع المؤشرات في جهاز تظليل الجزء ، نحتاج أولاً إلى تمريرها عبر جهاز تظليل القمة. </font><font style="vertical-align: inherit;">يمكننا القيام بذلك في وظيفة الذروة الخاصة بنا ، كما فعلنا في Shader </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Estuary</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">في هذه الحالة ، نقوم بإضافة حقل إلى بنية الإدخال </font></font><code>float3 terrain</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ونسخه إليه </font></font><code>v.texcoord2.xyz</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre style=";text-align:right;direction:rtl"> <code class="hljs pgsql"> #pragma surface surf Standard fullforwardshadows vertex:vert #pragma target <span class="hljs-number"><span class="hljs-number">3.5</span></span> … struct <span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> { <span class="hljs-type"><span class="hljs-type">float4</span></span> color : COLOR; float3 worldPos; float3 terrain; }; <span class="hljs-type"><span class="hljs-type">void</span></span> vert (<span class="hljs-keyword"><span class="hljs-keyword">inout</span></span> appdata_full v, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> data) { UNITY_INITIALIZE_OUTPUT(<span class="hljs-keyword"><span class="hljs-keyword">Input</span></span>, data); data.terrain = v.texcoord2.xyz; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">نحتاج إلى أخذ عينة المصفوفة ثلاث مرات لكل قطعة. </font><font style="vertical-align: inherit;">لذلك ، دعنا ننشئ وظيفة ملائمة لإنشاء إحداثيات النسيج ، وأخذ عينات من صفيف وتعديل عينة بخريطة متقطعة لفهرس واحد.</font></font><br><br><pre style=";text-align:right;direction:rtl"> <code class="hljs pgsql"> <span class="hljs-type"><span class="hljs-type">float4</span></span> GetTerrainColor (<span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>, <span class="hljs-type"><span class="hljs-type">int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span>) { float3 uvw = float3(<span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.worldPos.xz * <span class="hljs-number"><span class="hljs-number">0.02</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.terrain[<span class="hljs-keyword"><span class="hljs-keyword">index</span></span>]); <span class="hljs-type"><span class="hljs-type">float4</span></span> c = UNITY_SAMPLE_TEX2DARRAY(_MainTex, uvw); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> c * <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.color[<span class="hljs-keyword"><span class="hljs-keyword">index</span></span>]; } <span class="hljs-type"><span class="hljs-type">void</span></span> surf (<span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">inout</span></span> SurfaceOutputStandard o) { … }</code> </pre> <br><div class="spoiler" style=";text-align:right;direction:rtl"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">هل يمكننا العمل مع المتجه كمصفوفة؟</font></font></b> <div class="spoiler_text" style=";text-align:right;direction:rtl">  نعم   - <code>color[0]</code>  <code>color.r</code> .  <code>color[1]</code>  <code>color.g</code> ,   . </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> باستخدام هذه الوظيفة ، يمكننا ببساطة تجربة مجموعة الملمس ثلاث مرات ودمج النتائج. </font></font><br><br><pre style=";text-align:right;direction:rtl"> <code class="hljs pgsql"> <span class="hljs-type"><span class="hljs-type">void</span></span> surf (<span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">inout</span></span> SurfaceOutputStandard o) { // float2 uv = <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.worldPos.xz * <span class="hljs-number"><span class="hljs-number">0.02</span></span>; fixed4 c = GetTerrainColor(<span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>) + GetTerrainColor(<span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>) + GetTerrainColor(<span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>); o.Albedo = c.rgb * _Color; o.Metallic = _Metallic; o.Smoothness = _Glossiness; o.Alpha = ca; }</code> </pre> <br><div style="text-align:center;;text-align:right;direction:rtl"><img src="https://habrastorage.org/getpro/habr/post_images/da9/2fa/577/da92fa577510b38d4d0cdb99db83aea0.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">راحة مزخرفة. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">الآن يمكننا أن نرسم النقوش بالزخارف. </font><font style="vertical-align: inherit;">يخلطون مثل الألوان الصلبة. </font><font style="vertical-align: inherit;">نظرًا لأننا نستخدم إحداثيات العالم كمنسق للأشعة فوق البنفسجية ، فإنها لا تتغير مع الارتفاع. </font><font style="vertical-align: inherit;">ونتيجة لذلك ، تمتد على طول المنحدرات الحادة. </font><font style="vertical-align: inherit;">إذا كانت القوام محايدة إلى حد ما ومتغيرة جدًا ، فستكون النتائج مقبولة. </font><font style="vertical-align: inherit;">خلاف ذلك ، نحصل على علامات تمدد قبيحة كبيرة. </font><font style="vertical-align: inherit;">يمكنك محاولة إخفائها باستخدام هندسة أو نسيج إضافي للمنحدرات ، ولكن في البرنامج التعليمي لن نقوم بذلك.</font></font><br><br><h3 style=";text-align:right;direction:rtl"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> اكتساح </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">الآن ، عندما نستخدم الزخارف بدلاً من الألوان ، سيكون من المنطقي تغيير لوحة المحرر. </font><font style="vertical-align: inherit;">يمكننا إنشاء واجهة جميلة يمكنها حتى عرض مواد الإغاثة ، لكنني سأركز على الاختصارات التي تتوافق مع نمط المخطط الحالي.</font></font><br><br><div style="text-align:center;;text-align:right;direction:rtl"><img src="https://habrastorage.org/getpro/habr/post_images/263/c52/c81/263c52c812c97de2b8095b6ca80a8f5d.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">خيارات الإغاثة. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">بالإضافة إلى ذلك ، </font></font><code>HexCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">لم تعد هناك حاجة لخاصية اللون ، لذا احذفها.</font></font><br><br><pre style=";text-align:right;direction:rtl"> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// public Color Color { // get { // return HexMetrics.colors[terrainTypeIndex]; // } // }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">يمكنك </font></font><code>HexGrid</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">أيضًا إزالة مجموعة من الألوان والشفرة المرتبطة بها.</font></font><br><br><pre style=";text-align:right;direction:rtl"> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// public Color[] colors; … void Awake () { HexMetrics.noiseSource = noiseSource; HexMetrics.InitializeHashGrid(seed); // HexMetrics.colors = colors; CreateMap(cellCountX, cellCountZ); } … … void OnEnable () { if (!HexMetrics.noiseSource) { HexMetrics.noiseSource = noiseSource; HexMetrics.InitializeHashGrid(seed); // HexMetrics.colors = colors; } }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">وأخيرًا ، لا حاجة أيضًا إلى مجموعة من الألوان </font></font><code>HexMetrics</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre style=";text-align:right;direction:rtl"> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// public static Color[] colors;</span></span></code> </pre> <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">حزمة الوحدة</font></font></a> <br><br><h1 style=";text-align:right;direction:rtl"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> الجزء 15: المسافات </font></font></h1><br><ul style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> عرض خطوط الشبكة. </font></font></li><li style=";text-align:right;direction:rtl"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> التبديل بين وضعي التحرير والملاحة. </font></font></li><li style=";text-align:right;direction:rtl"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> احسب المسافة بين الخلايا. </font></font></li><li style=";text-align:right;direction:rtl"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> نجد طرق حول العقبات. </font></font></li><li style=";text-align:right;direction:rtl"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> نحن نأخذ بعين الاعتبار التكاليف المتغيرة للنقل. </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> بعد إنشاء خرائط عالية الجودة ، سنبدأ التنقل. </font></font><br><br><div style="text-align:center;;text-align:right;direction:rtl"><img src="https://habrastorage.org/getpro/habr/post_images/15b/b5d/65d/15bb5d65de19358da88e581cedad71cb.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">أقصر مسار ليس دائما مستقيما.</font></font></i> <br><br><h2 style=";text-align:right;direction:rtl"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> عرض الشبكة </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">يتم تنفيذ التنقل على الخريطة بالانتقال من خلية إلى أخرى. </font><font style="vertical-align: inherit;">للوصول إلى مكان ما ، تحتاج إلى المرور عبر سلسلة من الخلايا. </font><font style="vertical-align: inherit;">لتسهيل تقدير المسافات ، دعنا نضيف خيار عرض الشبكة السداسية التي تستند إليها خريطتنا.</font></font><br><br><h3 style=";text-align:right;direction:rtl"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> نسيج شبكي </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">على الرغم من عدم انتظام شبكة الخريطة ، فإن الشبكة الأساسية مسطحة تمامًا. </font><font style="vertical-align: inherit;">يمكننا إظهار ذلك من خلال عرض نمط الشبكة على الخريطة. </font><font style="vertical-align: inherit;">يمكن تحقيق ذلك باستخدام نسيج شبكي متكرر.</font></font><br><br><div style="text-align:center;;text-align:right;direction:rtl"><img src="https://habrastorage.org/getpro/habr/post_images/3a7/74c/76e/3a774c76e29b57018450a8e21f5bf1fb.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">تكرار نسيج شبكي. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">يحتوي النسيج الموضح أعلاه على جزء صغير من الشبكة السداسية التي تغطي خليتين 2 × 2. </font><font style="vertical-align: inherit;">هذه المنطقة مستطيلة وليست مربعة. </font><font style="vertical-align: inherit;">نظرًا لأن النسيج نفسه مربع ، يبدو النمط ممتدًا. </font><font style="vertical-align: inherit;">عند أخذ العينات ، نحتاج إلى تعويض ذلك.</font></font><br><br><h3 style=";text-align:right;direction:rtl"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> إسقاط الشبكة </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">لإسقاط نقش شبكي ، نحتاج إلى إضافة </font><font style="vertical-align: inherit;">خاصية نسيج إلى </font><font style="vertical-align: inherit;">Shader </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Terrain</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><pre style=";text-align:right;direction:rtl"> <code class="hljs nginx"> <span class="hljs-section"><span class="hljs-section">Properties</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">_Color</span></span> (<span class="hljs-string"><span class="hljs-string">"Color"</span></span>, Color) = (<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>) _MainTex (<span class="hljs-string"><span class="hljs-string">"Terrain Texture Array"</span></span>, 2DArray) = <span class="hljs-string"><span class="hljs-string">"white"</span></span> {} <span class="hljs-attribute"><span class="hljs-attribute">_GridTex</span></span> (<span class="hljs-string"><span class="hljs-string">"Grid Texture"</span></span>, 2D) = <span class="hljs-string"><span class="hljs-string">"white"</span></span> {} <span class="hljs-attribute"><span class="hljs-attribute">_Glossiness</span></span> (<span class="hljs-string"><span class="hljs-string">"Smoothness"</span></span>, Range(<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>)) = <span class="hljs-number"><span class="hljs-number">0</span></span>.<span class="hljs-number"><span class="hljs-number">5</span></span> _Metallic (<span class="hljs-string"><span class="hljs-string">"Metallic"</span></span>, Range(<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>)) = <span class="hljs-number"><span class="hljs-number">0</span></span>.<span class="hljs-number"><span class="hljs-number">0</span></span> }</code> </pre> <br><div style="text-align:center;;text-align:right;direction:rtl"><img src="https://habrastorage.org/getpro/habr/post_images/283/708/6de/2837086dedff939d3380396c9146ddfc.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">مواد الإغاثة بنسيج شبكي. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">اختبر النسيج باستخدام إحداثيات XZ للعالم ، ثم اضربه في البياض. </font><font style="vertical-align: inherit;">نظرًا لأن خطوط الشبكة على الملمس رمادية ، فإن هذا سيؤدي إلى تشابك النمط في النقوش.</font></font><br><br><pre style=";text-align:right;direction:rtl"> <code class="hljs pgsql"> sampler2D _GridTex; … <span class="hljs-type"><span class="hljs-type">void</span></span> surf (<span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">inout</span></span> SurfaceOutputStandard o) { fixed4 c = GetTerrainColor(<span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>) + GetTerrainColor(<span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>) + GetTerrainColor(<span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>); fixed4 grid = tex2D(_GridTex, <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.worldPos.xz); o.Albedo = c.rgb * grid * _Color; o.Metallic = _Metallic; o.Smoothness = _Glossiness; o.Alpha = ca; }</code> </pre> <br><div style="text-align:center;;text-align:right;direction:rtl"><img src="https://habrastorage.org/getpro/habr/post_images/972/a3e/432/972a3e4323541d1195904c9777a29e07.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ضرب البيدو بشبكة دقيقة. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">نحتاج إلى قياس النمط بحيث يتطابق مع الخلايا في الخريطة. </font><font style="vertical-align: inherit;">المسافة بين مراكز الخلايا المجاورة هي 15 ، ويجب مضاعفتها لتحريك خليتين. </font><font style="vertical-align: inherit;">أي أننا بحاجة إلى تقسيم إحداثيات الشبكة V على 30. يبلغ نصف القطر الداخلي للخلايا 5√3 ، ولتحريك خليتين إلى اليمين ، نحتاج إلى أربعة أضعاف ذلك. </font><font style="vertical-align: inherit;">لذلك ، من الضروري تقسيم إحداثيات شبكة U على 20√3.</font></font><br><br><pre style=";text-align:right;direction:rtl"> <code class="hljs markdown"> float2 gridUV = IN.worldPos.xz; gridUV.x <span class="hljs-emphasis"><span class="hljs-emphasis">*= 1 / (4 *</span></span> 8.66025404); gridUV.y <span class="hljs-emphasis"><span class="hljs-emphasis">*= 1 / (2 *</span></span> 15.0); fixed4 grid = tex2D(_GridTex, gridUV);</code> </pre> <br><div style="text-align:center;;text-align:right;direction:rtl"><img src="https://habrastorage.org/getpro/habr/post_images/454/1ba/191/4541ba19123145c27422e2b90b52aa6f.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">حجم الشبكة الصحيح. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">الآن تتوافق خطوط الشبكة مع خلايا الخريطة. </font><font style="vertical-align: inherit;">مثل مواد الإغاثة ، يتجاهلون الارتفاع ، لذلك سيتم تمديد الخطوط على طول المنحدرات.</font></font><br><br><div style="text-align:center;;text-align:right;direction:rtl"><img src="https://habrastorage.org/getpro/habr/post_images/98a/708/906/98a7089069b6d04bc708851045c9fe7a.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">إسقاط على الخلايا ذات الارتفاع. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">عادة ما يكون تشوه الشبكة ليس سيئًا للغاية ، خاصة عند النظر إلى خريطة من مسافة طويلة.</font></font><br><br><div style="text-align:center;;text-align:right;direction:rtl"><img src="https://habrastorage.org/getpro/habr/post_images/287/5ac/690/2875ac690eb796bf00a86b48d193aec8.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">شبكة في المسافة.</font></font></i> <br><br><h3 style=";text-align:right;direction:rtl"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> إدراج الشبكة </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">على الرغم من أن عرض الشبكة مناسب ، إلا أنه ليس مطلوبًا دائمًا. </font><font style="vertical-align: inherit;">على سبيل المثال ، يجب إيقاف تشغيله عند التقاط لقطة شاشة. </font><font style="vertical-align: inherit;">بالإضافة إلى ذلك ، لا يفضل الجميع رؤية الشبكة باستمرار. </font><font style="vertical-align: inherit;">لذلك دعونا نجعله اختياريًا. </font><font style="vertical-align: inherit;">سنضيف التوجيه متعدد الملفات إلى التظليل لإنشاء خيارات مع وبدون شبكة. </font><font style="vertical-align: inherit;">للقيام بذلك ، سوف نستخدم الكلمة الأساسية </font></font><code>GRID_ON</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">يتم وصف تجميع التظليل الشرطي في البرنامج التعليمي </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rendering 5 ، أضواء متعددة</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><pre style=";text-align:right;direction:rtl"> <code class="hljs css"> <span class="hljs-selector-id"><span class="hljs-selector-id">#pragma</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">surface</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">surf</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">Standard</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">fullforwardshadows</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">vertex</span></span><span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">:vert</span></span> <span class="hljs-selector-id"><span class="hljs-selector-id">#pragma</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">target</span></span> 3<span class="hljs-selector-class"><span class="hljs-selector-class">.5</span></span> <span class="hljs-selector-id"><span class="hljs-selector-id">#pragma</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">multi_compile</span></span> _ <span class="hljs-selector-tag"><span class="hljs-selector-tag">GRID_ON</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">عند الإعلان عن متغير ، نقوم </font></font><code>grid</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">أولاً بتعيينه قيمة 1. ونتيجة لذلك ، سيتم تعطيل الشبكة. </font><font style="vertical-align: inherit;">ثم سنقوم بتجربة نسيج الشبكة فقط للمتغير باستخدام كلمة رئيسية محددة </font></font><code>GRID_ON</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre style=";text-align:right;direction:rtl"> <code class="hljs mel"> fixed4 <span class="hljs-keyword"><span class="hljs-keyword">grid</span></span> = <span class="hljs-number"><span class="hljs-number">1</span></span>; #<span class="hljs-keyword"><span class="hljs-keyword">if</span></span> defined(GRID_ON) float2 gridUV = IN.worldPos.xz; gridUV.x *= <span class="hljs-number"><span class="hljs-number">1</span></span> / (<span class="hljs-number"><span class="hljs-number">4</span></span> * <span class="hljs-number"><span class="hljs-number">8.66025404</span></span>); gridUV.y *= <span class="hljs-number"><span class="hljs-number">1</span></span> / (<span class="hljs-number"><span class="hljs-number">2</span></span> * <span class="hljs-number"><span class="hljs-number">15.0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">grid</span></span> = tex2D(_GridTex, gridUV); #endif o.Albedo = c.rgb * <span class="hljs-keyword"><span class="hljs-keyword">grid</span></span> * _Color;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">نظرًا </font></font><code>GRID_ON</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">لعدم تضمين </font><font style="vertical-align: inherit;">الكلمة الرئيسية </font><font style="vertical-align: inherit;">في تظليل التضاريس ، ستختفي الشبكة. </font><font style="vertical-align: inherit;">لتمكينه مرة أخرى ، سنضيف مفتاحًا إلى واجهة مستخدم محرر الخرائط. </font><font style="vertical-align: inherit;">لتحقيق ذلك ، </font></font><code>HexMapEditor</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">يجب أن أحصل على رابط إلى مادة </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Terrain</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> وطريقة لتمكين الكلمة الرئيسية أو تعطيلها </font></font><code>GRID_ON</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre style=";text-align:right;direction:rtl"> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Material terrainMaterial; … <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ShowGrid</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> visible</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (visible) { terrainMaterial.EnableKeyword(<span class="hljs-string"><span class="hljs-string">"GRID_ON"</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { terrainMaterial.DisableKeyword(<span class="hljs-string"><span class="hljs-string">"GRID_ON"</span></span>); } }</code> </pre> <br><div style="text-align:center;;text-align:right;direction:rtl"><img src="https://habrastorage.org/getpro/habr/post_images/7d0/d53/873/7d0d53873a0aace69be804dcbf22d7ce.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">محرر مسدسات مسيرة بالإشارة إلى المادة. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">أضف مفتاح </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">الشبكة</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> إلى واجهة المستخدم </font><font style="vertical-align: inherit;">وربطه بالطريقة </font></font><code>ShowGrid</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><div style="text-align:center;;text-align:right;direction:rtl"><img src="https://habrastorage.org/getpro/habr/post_images/56b/38a/6b6/56b38a6b6792eb8b89fb3936a55e9194.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">تبديل الشبكة.</font></font></i> <br><br><h3 style=";text-align:right;direction:rtl"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> حفظ الدولة </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">الآن في وضع التشغيل ، يمكننا تبديل عرض الشبكة. </font><font style="vertical-align: inherit;">في الاختبار الأول ، يتم إيقاف تشغيل الشبكة مبدئيًا وتصبح مرئية عند تشغيل المفتاح. </font><font style="vertical-align: inherit;">عند إيقاف تشغيله ، ستختفي الشبكة مرة أخرى. </font><font style="vertical-align: inherit;">ومع ذلك ، إذا خرجنا من وضع التشغيل عندما تكون الشبكة مرئية ، فسيتم إعادة تشغيلها في المرة التالية التي تقوم فيها بتشغيل وضع التشغيل ، على الرغم من إيقاف تشغيل المفتاح. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">هذا لأننا نغير الكلمة الرئيسية لمواد </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">التضاريس</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> العامة </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">نقوم بتحرير الأصل المادي ، لذلك يتم حفظ التغيير في محرر الوحدة. </font><font style="vertical-align: inherit;">لن يتم حفظه في التجميع. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">لبدء اللعبة دائمًا بدون شبكة ، سنعطل الكلمة الرئيسية </font></font><code>GRID_ON</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">في Awake </font></font><code>HexMapEditor</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre style=";text-align:right;direction:rtl"> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Awake</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { terrainMaterial.DisableKeyword(<span class="hljs-string"><span class="hljs-string">"GRID_ON"</span></span>); }</code> </pre> <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">حزمة الوحدة</font></font></a> <br><br><h2 style=";text-align:right;direction:rtl"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> وضع التحرير </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">إذا أردنا التحكم في الحركة على الخريطة ، فعلينا التفاعل معها. </font><font style="vertical-align: inherit;">كحد أدنى ، نحتاج إلى تحديد الخلية كنقطة بداية للمسار. </font><font style="vertical-align: inherit;">ولكن عند النقر فوق خلية ، سيتم تحريرها. </font><font style="vertical-align: inherit;">يمكننا تعطيل جميع خيارات التعديل يدويًا ، ولكن هذا غير مريح. </font><font style="vertical-align: inherit;">بالإضافة إلى ذلك ، لا نريد إجراء حسابات الإزاحة أثناء تحرير الخريطة. </font><font style="vertical-align: inherit;">لذا دعنا نضيف مفتاحًا يحدد ما إذا كنا في وضع التحرير.</font></font><br><br><h3 style=";text-align:right;direction:rtl"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> تحرير التبديل </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">أضف إلى </font></font><code>HexMapEditor</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">الحقل المنطقي </font></font><code>editMode</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">، بالإضافة إلى الطريقة التي تحدده. </font><font style="vertical-align: inherit;">ثم أضف مفتاحًا آخر إلى واجهة المستخدم للتحكم فيه. </font><font style="vertical-align: inherit;">لنبدأ بوضع التنقل ، أي أنه سيتم تعطيل وضع التحرير بشكل افتراضي.</font></font><br><br><pre style=";text-align:right;direction:rtl"> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> editMode; … <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetEditMode</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> toggle</span></span></span><span class="hljs-function">)</span></span> { editMode = toggle; }</code> </pre> <br><div style="text-align:center;;text-align:right;direction:rtl"><img src="https://habrastorage.org/getpro/habr/post_images/1bf/19b/ace/1bf19baceed0ecfa766dbe0386ed38d3.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">مفتاح وضع التحرير. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">لتعطيل التعديل حقًا ، اجعل المكالمة </font></font><code>EditCells</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">تعتمد على </font></font><code>editMode</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre style=";text-align:right;direction:rtl"> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">HandleInput</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Ray inputRay = Camera.main.ScreenPointToRay(Input.mousePosition); RaycastHit hit; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Physics.Raycast(inputRay, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> hit)) { HexCell currentCell = hexGrid.GetCell(hit.point); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (previousCell &amp;&amp; previousCell != currentCell) { ValidateDrag(currentCell); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { isDrag = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (editMode) { EditCells(currentCell); } previousCell = currentCell; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { previousCell = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; } }</code> </pre> <br><h3 style=";text-align:right;direction:rtl"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> تسميات التصحيح </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">حتى الآن ليس لدينا وحدات للتحرك حول الخريطة. </font><font style="vertical-align: inherit;">بدلاً من ذلك ، نتصور مسافات الحركة. </font><font style="vertical-align: inherit;">للقيام بذلك ، يمكنك استخدام تسميات الخلايا الموجودة. </font><font style="vertical-align: inherit;">لذلك ، سنجعلها مرئية عند تعطيل وضع التحرير.</font></font><br><br><pre style=";text-align:right;direction:rtl"> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetEditMode</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> toggle</span></span></span><span class="hljs-function">)</span></span> { editMode = toggle; hexGrid.ShowUI(!toggle); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">نظرًا لأننا نبدأ بوضع التنقل ، يجب تمكين التصنيفات الافتراضية. </font></font><code>HexGridChunk.Awake</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">يعطلها </font><font style="vertical-align: inherit;">حاليًا </font><font style="vertical-align: inherit;">، ولكن لا يجب عليه فعل ذلك بعد الآن.</font></font><br><br><pre style=";text-align:right;direction:rtl"> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Awake</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { gridCanvas = GetComponentInChildren&lt;Canvas&gt;(); cells = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HexCell[HexMetrics.chunkSizeX * HexMetrics.chunkSizeZ]; <span class="hljs-comment"><span class="hljs-comment">// ShowUI(false); }</span></span></code> </pre> <br><div style="text-align:center;;text-align:right;direction:rtl"><img src="https://habrastorage.org/getpro/habr/post_images/730/666/90c/73066690c998f0715fb22356a0374fed.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">تنسيق التسميات. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">تصبح إحداثيات الخلية مرئية مباشرة بعد تشغيل وضع التشغيل. </font><font style="vertical-align: inherit;">لكننا لسنا بحاجة إلى إحداثيات ، نستخدم التسميات لعرض المسافات. </font><font style="vertical-align: inherit;">نظرًا لأن هذا يتطلب رقمًا واحدًا فقط لكل خلية ، يمكنك زيادة حجم الخط بحيث يمكن قراءته بشكل أفضل. </font><font style="vertical-align: inherit;">قم بتغيير الإعداد الأساسي لـ </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hex Cell Label</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> بحيث يستخدم الخط الغامق بالحجم 8.</font></font><br><br><div style="text-align:center;;text-align:right;direction:rtl"><img src="https://habrastorage.org/getpro/habr/post_images/8ea/008/aa0/8ea008aa075686891f8815148c70ba06.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">العلامات ذات حجم الخط الغامق 8.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> الآن بعد تشغيل وضع التشغيل ، سنرى علامات كبيرة. </font><font style="vertical-align: inherit;">فقط الإحداثيات الأولى للخلية مرئية ، ولا يتم وضع الباقي في الملصق.</font></font><br><br><div style="text-align:center;;text-align:right;direction:rtl"><img src="https://habrastorage.org/getpro/habr/post_images/745/baf/016/745baf0160c2f9cf8aaae974ff285d16.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">العلامات الكبيرة. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">نظرًا لأننا لم نعد بحاجة إلى الإحداثيات ، فسنحذف </font></font><code>HexGrid.CreateCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">القيمة </font><font style="vertical-align: inherit;">في </font><font style="vertical-align: inherit;">المهمة </font></font><code>label.text</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre style=";text-align:right;direction:rtl"> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateCell</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> i</span></span></span><span class="hljs-function">)</span></span> { … Text label = Instantiate&lt;Text&gt;(cellLabelPrefab); label.rectTransform.anchoredPosition = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(position.x, position.z); <span class="hljs-comment"><span class="hljs-comment">// label.text = cell.coordinates.ToStringOnSeparateLines(); cell.uiRect = label.rectTransform; … }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">يمكنك أيضًا إزالة تبديل </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">التصنيفات</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> والطريقة المرتبطة به </font><font style="vertical-align: inherit;">من واجهة المستخدم </font></font><code>HexMapEditor.ShowUI</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre style=";text-align:right;direction:rtl"> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// public void ShowUI (bool visible) { // hexGrid.ShowUI(visible); // }</span></span></code> </pre> <br><div style="text-align:center;;text-align:right;direction:rtl"><img src="https://habrastorage.org/getpro/habr/post_images/6e0/4d4/652/6e04d46522e65937a9324e0f3498d480.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">لم يعد مفتاح الأسلوب أكثر. </font></font></i> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">حزمة الوحدة</font></font></a> <br><br><h2 style=";text-align:right;direction:rtl"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> إيجاد المسافات </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">الآن بعد أن أصبح لدينا وضع التنقل المميز ، يمكننا البدء في عرض المسافات. </font><font style="vertical-align: inherit;">سنحدد خلية ثم نعرض المسافة من هذه الخلية إلى جميع الخلايا على الخريطة.</font></font><br><br><h3 style=";text-align:right;direction:rtl"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> عرض المسافة </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">لتتبع المسافة إلى الخلية ، أضف إلى </font></font><code>HexCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">الحقل الصحيح </font></font><code>distance</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">سيشير إلى المسافة بين هذه الخلية والخلية المحددة. </font><font style="vertical-align: inherit;">لذلك ، بالنسبة للخلية المحددة نفسها ، ستكون صفرًا ، والجار المباشر هو 1 ، وهكذا.</font></font><br><br><pre style=";text-align:right;direction:rtl"> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> distance;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">عندما يتم تعيين المسافة ، يجب علينا تحديث تسمية الخلية لعرض قيمتها. </font></font><code>HexCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">لديه إشارة إلى </font></font><code>RectTransform</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">كائن واجهة المستخدم. </font><font style="vertical-align: inherit;">سنحتاج إلى الاتصال به </font></font><code>GetComponent&lt;Text&gt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">للوصول إلى الزنزانة. </font><font style="vertical-align: inherit;">ضع في اعتبارك ما </font></font><code>Text</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">يوجد في مساحة الاسم </font></font><code>UnityEngine.UI</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">، لذا استخدمه في بداية البرنامج النصي.</font></font><br><br><pre style=";text-align:right;direction:rtl"> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">UpdateDistanceLabel</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Text label = uiRect.GetComponent&lt;Text&gt;(); label.text = distance.ToString(); }</code> </pre> <br><div class="spoiler" style=";text-align:right;direction:rtl"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ألا يجب أن نحتفظ برابط مباشر إلى مكون النص؟</font></font></b> <div class="spoiler_text" style=";text-align:right;direction:rtl"> ,   .     ,       ,  ,    .   ,      . </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> لنقم بتعيين الخاصية العامة لاستلام وتعيين المسافة إلى الخلية ، بالإضافة إلى تحديث التسمية الخاصة بها. </font></font><br><br><pre style=";text-align:right;direction:rtl"> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Distance { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> distance; } <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { distance = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; UpdateDistanceLabel(); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">أضف إلى </font></font><code>HexGrid</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">الطريقة العامة </font></font><code>FindDistancesTo</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">باستخدام معلمة الخلية. </font><font style="vertical-align: inherit;">في الوقت الحالي ، سنقوم ببساطة بتعيين مسافة الصفر لكل خلية.</font></font><br><br><pre style=";text-align:right;direction:rtl"> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FindDistancesTo</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cells.Length; i++) { cells[i].Distance = <span class="hljs-number"><span class="hljs-number">0</span></span>; } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">إذا لم يتم تمكين وضع التحرير ، فإننا </font></font><code>HexMapEditor.HandleInput</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">نسمي طريقة جديدة مع الخلية الحالية.</font></font><br><br><pre style=";text-align:right;direction:rtl"> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (editMode) { EditCells(currentCell); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { hexGrid.FindDistancesTo(currentCell); }</code> </pre> <br><h3 style=";text-align:right;direction:rtl"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> المسافات بين الإحداثيات </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">الآن في وضع التنقل ، بعد لمس أحدها ، تعرض جميع الخلايا صفرًا. </font><font style="vertical-align: inherit;">ولكن ، بالطبع ، يجب عليهم عرض المسافة الحقيقية للخلية. </font><font style="vertical-align: inherit;">لحساب المسافة بينهما ، يمكننا استخدام إحداثيات الخلية. </font><font style="vertical-align: inherit;">لذلك ، افترض أن </font></font><code>HexCoordinates</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">لديها طريقة </font></font><code>DistanceTo</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">واستخدمها </font></font><code>HexGrid.FindDistancesTo</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre style=";text-align:right;direction:rtl"> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FindDistancesTo</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cells.Length; i++) { cells[i].Distance = cell.coordinates.DistanceTo(cells[i].coordinates); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">أضف الآن إلى </font></font><code>HexCoordinates</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">الطريقة </font></font><code>DistanceTo</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">يجب عليه مقارنة إحداثياته ​​مع إحداثيات مجموعة أخرى. </font><font style="vertical-align: inherit;">لنبدأ فقط بقياس X ، وسنطرح إحداثيات X من بعضها البعض.</font></font><br><br><pre style=";text-align:right;direction:rtl"> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DistanceTo</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCoordinates other</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x - other.x; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ونتيجة لذلك ، نحصل على إزاحة على طول X بالنسبة للخلية المحددة. </font><font style="vertical-align: inherit;">لكن لا يمكن أن تكون المسافات سالبة ، لذلك تحتاج إلى إرجاع الفرق الإحداثي X modulo.</font></font><br><br><pre style=";text-align:right;direction:rtl"> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x &lt; other.x ? other.x - x : x - other.x;</code> </pre> <br><div style="text-align:center;;text-align:right;direction:rtl"><img src="https://habrastorage.org/getpro/habr/post_images/fdb/c62/16c/fdbc6216c12ae4a38ff7edaba203116e.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">المسافات على طول X.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> لذا نحصل على المسافات الصحيحة فقط إذا أخذنا في الاعتبار بُعدًا واحدًا فقط. </font><font style="vertical-align: inherit;">ولكن هناك ثلاثة أبعاد في شبكة السداسيات. </font><font style="vertical-align: inherit;">لذا دعونا نجمع المسافات لجميع الأبعاد الثلاثة ونرى ما يمنحنا إياه.</font></font><br><br><pre style=";text-align:right;direction:rtl"> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (x &lt; other.x ? other.x - x : x - other.x) + (Y &lt; other.Y ? other.Y - Y : Y - other.Y) + (z &lt; other.z ? other.z - z : z - other.z);</code> </pre> <br><div style="text-align:center;;text-align:right;direction:rtl"><img src="https://habrastorage.org/getpro/habr/post_images/ffd/170/ac0/ffd170ac0b133a9b589e3dea9d6fd2b3.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">مجموع مسافات XYZ. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">اتضح أننا نحصل على ضعف المسافة. </font><font style="vertical-align: inherit;">أي للحصول على المسافة الصحيحة ، يجب تقسيم هذا المبلغ إلى النصف.</font></font><br><br><pre style=";text-align:right;direction:rtl"> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ((x &lt; other.x ? other.x - x : x - other.x) + (Y &lt; other.Y ? other.Y - Y : Y - other.Y) + (z &lt; other.z ? other.z - z : z - other.z)) / <span class="hljs-number"><span class="hljs-number">2</span></span>;</code> </pre> <br><div style="text-align:center;;text-align:right;direction:rtl"><img src="https://habrastorage.org/getpro/habr/post_images/9bd/37d/353/9bd37d3535471f748d31be64ce897c17.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">مسافات حقيقية.</font></font></i> <br><br><div class="spoiler" style=";text-align:right;direction:rtl"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">لماذا يساوي المجموع ضعف المسافة؟</font></font></b> <div class="spoiler_text" style=";text-align:right;direction:rtl">  ,       .      ,  (1, −3, 2).       .      ,       .      .   ,            .         . <br><br><div style="text-align:center;;text-align:right;direction:rtl"><img src="https://habrastorage.org/getpro/habr/post_images/09e/533/197/09e533197dfc487db1c5b91f92fd6ba8.png"></div><br> <i> .</i> </div></div><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">حزمة الوحدة</font></font></a> <br><br><h2 style=";text-align:right;direction:rtl"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> العمل مع العقبات </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">تتوافق المسافات المحسوبة من قبلنا مع أقصر المسارات من الخلية المحددة إلى الخلية الأخرى. </font><font style="vertical-align: inherit;">لا يمكننا إيجاد طريقة أقصر. </font><font style="vertical-align: inherit;">ولكن من المؤكد أن تكون هذه المسارات صحيحة إذا لم يحظر المسار أي شيء. </font><font style="vertical-align: inherit;">يمكن للمنحدرات والمياه وغيرها من العوائق أن تجعلنا نتجول. </font><font style="vertical-align: inherit;">ربما لا يمكن الوصول إلى بعض الخلايا على الإطلاق. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">لإيجاد طريقة للتغلب على العقبات ، نحتاج إلى استخدام نهج مختلف بدلاً من مجرد حساب المسافة بين الإحداثيات. </font><font style="vertical-align: inherit;">لم يعد بإمكاننا فحص كل خلية على حدة. </font><font style="vertical-align: inherit;">سيتعين علينا البحث في الخريطة حتى نجد كل خلية يمكن الوصول إليها.</font></font><br><br><h3 style=";text-align:right;direction:rtl"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> تصوّر البحث </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">البحث عن الخرائط هو عملية تكرارية. </font><font style="vertical-align: inherit;">لفهم ما نقوم به ، سيكون من المفيد رؤية كل مرحلة من مراحل البحث. </font><font style="vertical-align: inherit;">يمكننا القيام بذلك عن طريق تحويل خوارزمية البحث إلى coroutine ، والتي نحتاج إلى مساحة بحث لها </font></font><code>System.Collections</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">معدل التحديث 60 تكرارًا في الثانية صغير بما يكفي لنرى ما يحدث ، ولم يستغرق البحث على خريطة صغيرة وقتًا طويلاً.</font></font><br><br><pre style=";text-align:right;direction:rtl"> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FindDistancesTo</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell</span></span></span><span class="hljs-function">)</span></span> { StartCoroutine(Search(cell)); } <span class="hljs-function"><span class="hljs-function">IEnumerator </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Search</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell</span></span></span><span class="hljs-function">)</span></span> { WaitForSeconds delay = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> WaitForSeconds(<span class="hljs-number"><span class="hljs-number">1</span></span> / <span class="hljs-number"><span class="hljs-number">60f</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cells.Length; i++) { <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> delay; cells[i].Distance = cell.coordinates.DistanceTo(cells[i].coordinates); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">نحتاج إلى التأكد من أن بحثًا واحدًا نشطًا فقط في أي وقت. </font><font style="vertical-align: inherit;">لذلك ، قبل البدء في بحث جديد ، نوقف جميع coroutines.</font></font><br><br><pre style=";text-align:right;direction:rtl"> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FindDistancesTo</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell</span></span></span><span class="hljs-function">)</span></span> { StopAllCoroutines(); StartCoroutine(Search(cell)); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> بالإضافة إلى ذلك ، نحتاج إلى إكمال البحث عند تحميل خريطة جديدة. </font></font><br><br><pre style=";text-align:right;direction:rtl"> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Load</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">BinaryReader reader, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> header</span></span></span><span class="hljs-function">)</span></span> { StopAllCoroutines(); … }</code> </pre> <br><h3 style=";text-align:right;direction:rtl"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> اتساع نطاق البحث الأول </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">حتى قبل أن نبدأ البحث ، نعلم أن المسافة إلى الخلية المحددة هي صفر. وبطبيعة الحال ، فإن المسافة إلى جميع جيرانها هي 1 ، إذا كان من الممكن الوصول إليهم. ثم يمكننا إلقاء نظرة على أحد هؤلاء الجيران. هذه الخلية على الأرجح لها جيرانها الذين يمكن الوصول إليهم ، والذين لم يتم حساب المسافة الخاصة بهم حتى الآن. إذا كان الأمر كذلك ، فيجب أن تكون المسافة إلى هؤلاء الجيران 2. يمكننا تكرار هذه العملية لجميع الجيران على مسافة 1. بعد ذلك ، نكررها لجميع الجيران على مسافة 2. وهكذا ، حتى نصل إلى جميع الخلايا.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">أي أننا أولاً نجد جميع الخلايا على مسافة 1 ، ثم نجد كل شيء على مسافة 2 ، ثم على مسافة 3 ، وهكذا ، حتى ننتهي. </font><font style="vertical-align: inherit;">يضمن هذا العثور على أصغر مسافة لكل خلية يمكن الوصول إليها. </font><font style="vertical-align: inherit;">هذه الخوارزمية تسمى البحث الأول. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">لكي تعمل ، نحتاج إلى معرفة ما إذا كنا قد حددنا بالفعل المسافة إلى الخلية. </font><font style="vertical-align: inherit;">غالبًا ما يتم وضع الخلايا في مجموعة تسمى مجموعة جاهزة أو مغلقة. </font><font style="vertical-align: inherit;">ولكن يمكننا تحديد المسافة إلى الخلية </font></font><code>int.MaxValue</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">للإشارة إلى أننا لم نزورها بعد. </font><font style="vertical-align: inherit;">نحن بحاجة إلى القيام بذلك لجميع الخلايا مباشرة قبل إجراء البحث.</font></font><br><br><pre style=";text-align:right;direction:rtl"> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-function">IEnumerator </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Search</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cells.Length; i++) { cells[i].Distance = <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>.MaxValue; } … }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">يمكنك أيضًا استخدام هذا لإخفاء جميع الخلايا غير المرغوبة عن طريق التغيير </font></font><code>HexCell.UpdateDistanceLabel</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">بعد ذلك ، سنبدأ كل بحث على خريطة فارغة.</font></font><br><br><pre style=";text-align:right;direction:rtl"> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">UpdateDistanceLabel</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Text label = uiRect.GetComponent&lt;Text&gt;(); label.text = distance == <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>.MaxValue ? <span class="hljs-string"><span class="hljs-string">""</span></span> : distance.ToString(); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">بعد ذلك ، نحتاج إلى تتبع الخلايا التي يجب زيارتها ، والترتيب الذي تمت زيارتها. </font><font style="vertical-align: inherit;">غالبًا ما تسمى هذه المجموعة بحدود أو مجموعة مفتوحة. </font><font style="vertical-align: inherit;">نحتاج فقط إلى معالجة الخلايا بنفس الترتيب الذي التقينا به. </font><font style="vertical-align: inherit;">للقيام بذلك ، يمكنك استخدام قائمة الانتظار </font></font><code>Queue</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">، التي تعد جزءًا من مساحة الاسم </font></font><code>System.Collections.Generic</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">ستكون الخلية المحددة هي الأولى التي يتم وضعها في قائمة الانتظار هذه وستكون على مسافة 0.</font></font><br><br><pre style=";text-align:right;direction:rtl"> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-function">IEnumerator </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Search</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cells.Length; i++) { cells[i].Distance = <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>.MaxValue; } WaitForSeconds delay = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> WaitForSeconds(<span class="hljs-number"><span class="hljs-number">1</span></span> / <span class="hljs-number"><span class="hljs-number">60f</span></span>); Queue&lt;HexCell&gt; frontier = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Queue&lt;HexCell&gt;(); cell.Distance = <span class="hljs-number"><span class="hljs-number">0</span></span>; frontier.Enqueue(cell); <span class="hljs-comment"><span class="hljs-comment">// for (int i = 0; i &lt; cells.Length; i++) { // yield return delay; // cells[i].Distance = // cell.coordinates.DistanceTo(cells[i].coordinates); // } }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">من هذه اللحظة ، تقوم الخوارزمية بتنفيذ الحلقة أثناء وجود شيء ما في قائمة الانتظار. </font><font style="vertical-align: inherit;">عند كل تكرار ، يتم استرداد الخلية الموجودة في المقدمة من قائمة الانتظار.</font></font><br><br><pre style=";text-align:right;direction:rtl"> <code class="cs hljs"> frontier.Enqueue(cell); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (frontier.Count &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> delay; HexCell current = frontier.Dequeue(); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">الآن لدينا الخلية الحالية ، والتي يمكن أن تكون على أي مسافة. </font><font style="vertical-align: inherit;">بعد ذلك ، نحتاج إلى إضافة جميع جيرانها إلى قائمة الانتظار خطوة واحدة أبعد من الخلية المحددة.</font></font><br><br><pre style=";text-align:right;direction:rtl"> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (frontier.Count &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> delay; HexCell current = frontier.Dequeue(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (HexDirection d = HexDirection.NE; d &lt;= HexDirection.NW; d++) { HexCell neighbor = current.GetNeighbor(d); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (neighbor != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { neighbor.Distance = current.Distance + <span class="hljs-number"><span class="hljs-number">1</span></span>; frontier.Enqueue(neighbor); } } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> لكن يجب أن نضيف فقط تلك الخلايا التي لم تعط بعد مسافة. </font></font><br><br><pre style=";text-align:right;direction:rtl"> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (neighbor != <span class="hljs-literal"><span class="hljs-literal">null</span></span> &amp;&amp; neighbor.Distance == <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>.MaxValue) { neighbor.Distance = current.Distance + <span class="hljs-number"><span class="hljs-number">1</span></span>; frontier.Enqueue(neighbor); }</code> </pre> <br><iframe width="560" height="315" src="https://www.youtube.com/embed/https://translate" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">بحث واسع.</font></font></i> <br><br><h3 style=";text-align:right;direction:rtl"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> تجنب الماء </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">بعد التأكد من أن البحث الأول باتساع المسافة يجدها على الخريطة الرتيبة ، يمكننا البدء في إضافة العقبات. </font><font style="vertical-align: inherit;">يمكن القيام بذلك عن طريق رفض إضافة خلايا إلى قائمة الانتظار إذا تم استيفاء شروط معينة. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">في الواقع ، نتخطى بالفعل بعض الخلايا: الخلايا غير الموجودة ، وتلك التي أشرنا إليها بالفعل. </font><font style="vertical-align: inherit;">دعونا نعيد كتابة الشفرة بحيث نتخطى الجيران بشكل صريح في هذه الحالة.</font></font><br><br><pre style=";text-align:right;direction:rtl"> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (HexDirection d = HexDirection.NE; d &lt;= HexDirection.NW; d++) { HexCell neighbor = current.GetNeighbor(d); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (neighbor == <span class="hljs-literal"><span class="hljs-literal">null</span></span> || neighbor.Distance != <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>.MaxValue) { <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } neighbor.Distance = current.Distance + <span class="hljs-number"><span class="hljs-number">1</span></span>; frontier.Enqueue(neighbor); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">دعونا نتخطى جميع الخلايا الموجودة تحت الماء. </font><font style="vertical-align: inherit;">هذا يعني أنه عند البحث عن أقصر مسافات ، نعتبر الحركة على الأرض فقط.</font></font><br><br><pre style=";text-align:right;direction:rtl"> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (neighbor == <span class="hljs-literal"><span class="hljs-literal">null</span></span> || neighbor.Distance != <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>.MaxValue) { <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (neighbor.IsUnderwater) { <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; }</code> </pre> <br><iframe width="560" height="315" src="https://www.youtube.com/embed/https://translate" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">المسافات دون التحرك عبر الماء. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">لا تزال الخوارزمية تجد أقصر مسافات ، ولكنها تتجنب الآن كل الماء. </font><font style="vertical-align: inherit;">لذلك ، لا تكتسب الخلايا تحت الماء أي مسافة ، مثل المناطق المعزولة من الأرض. </font><font style="vertical-align: inherit;">تتلقى الخلية تحت الماء المسافة فقط إذا تم تحديدها.</font></font><br><br><h3 style=";text-align:right;direction:rtl"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> تجنب المنحدرات </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">أيضًا ، لتحديد إمكانية زيارة أحد الجيران ، يمكننا استخدام نوع الضلع. </font><font style="vertical-align: inherit;">على سبيل المثال ، يمكنك جعل المنحدرات تسد المسار. </font><font style="vertical-align: inherit;">إذا سمحت بالحركة على المنحدرات ، فلا يزال من الممكن الوصول إلى الخلايا على الجانب الآخر من الجرف ، فقط على المسارات الأخرى. </font><font style="vertical-align: inherit;">لذلك ، يمكن أن تكون على مسافات مختلفة جدًا.</font></font><br><br><pre style=";text-align:right;direction:rtl"> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (neighbor.IsUnderwater) { <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (current.GetEdgeType(neighbor) == HexEdgeType.Cliff) { <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; }</code> </pre> <br><iframe width="560" height="315" src="https://www.youtube.com/embed/https://translate" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">المسافات دون عبور المنحدرات. </font></font></i> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">حزمة الوحدة</font></font></a> <br><br><h2 style=";text-align:right;direction:rtl"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> تكاليف السفر </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">يمكننا تجنب الخلايا والحواف ، لكن هذه الخيارات ثنائية. </font><font style="vertical-align: inherit;">يمكن للمرء أن يتصور أنه من الأسهل التنقل في بعض الاتجاهات أكثر من غيرها. </font><font style="vertical-align: inherit;">في هذه الحالة ، يتم قياس المسافة في العمل أو الوقت.</font></font><br><br><h3 style=";text-align:right;direction:rtl"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> الطرق السريعة </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">سيكون من المنطقي أن يكون السفر على الطرق أسهل وأسرع ، لذلك دعونا نجعل تقاطع الحواف مع الطرق أقل تكلفة. </font><font style="vertical-align: inherit;">نظرًا لأننا نستخدم قيمًا صحيحة لتحديد المسافة ، فسوف نترك تكلفة التحرك على طول الطرق تساوي 1 ، وستزداد تكلفة عبور الحواف الأخرى إلى 10. وهذا فرق كبير يتيح لنا معرفة ما إذا حصلنا على النتائج الصحيحة على الفور.</font></font><br><br><pre style=";text-align:right;direction:rtl"> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> distance = current.Distance; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (current.HasRoadThroughEdge(d)) { distance += <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { distance += <span class="hljs-number"><span class="hljs-number">10</span></span>; } neighbor.Distance = distance;</code> </pre> <br><div style="text-align:center;;text-align:right;direction:rtl"><img src="https://habrastorage.org/getpro/habr/post_images/899/225/6e3/8992256e34fef206c7282bc31a72a573.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">الطرق ذات المسافات الخاطئة.</font></font></i> <br><br><h3 style=";text-align:right;direction:rtl"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> فرز الحدود </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">لسوء الحظ ، اتضح أن البحث الأول لا يمكن أن يعمل مع تكاليف نقل متغيرة. </font><font style="vertical-align: inherit;">يفترض أن الخلايا تضاف إلى الحدود بترتيب زيادة المسافة ، وهذا بالنسبة لنا لم يعد مناسبًا. </font><font style="vertical-align: inherit;">نحن بحاجة إلى قائمة انتظار ذات أولوية ، أي قائمة انتظار تصنف نفسها. </font><font style="vertical-align: inherit;">لا توجد قوائم انتظار ذات أولوية قياسية ، لأنه لا يمكنك برمجتها بطريقة تناسب جميع المواقف. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">يمكننا إنشاء قائمة الانتظار ذات الأولوية الخاصة بنا ، ولكن دعنا نقوم بتحسينها لتناسب البرنامج التعليمي المستقبلي. </font><font style="vertical-align: inherit;">في الوقت الحالي ، نستبدل قائمة الانتظار بقائمة تحتوي على طريقة </font></font><code>Sort</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre style=";text-align:right;direction:rtl"> <code class="cs hljs"> List&lt;HexCell&gt; frontier = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;HexCell&gt;(); cell.Distance = <span class="hljs-number"><span class="hljs-number">0</span></span>; frontier.Add(cell); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (frontier.Count &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> delay; HexCell current = frontier[<span class="hljs-number"><span class="hljs-number">0</span></span>]; frontier.RemoveAt(<span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (HexDirection d = HexDirection.NE; d &lt;= HexDirection.NW; d++) { … neighbor.Distance = distance; frontier.Add(neighbor); } }</code> </pre> <br><div class="spoiler" style=";text-align:right;direction:rtl"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ألا يمكنني استخدام ListPool &lt;HexCell&gt;؟</font></font></b> <div class="spoiler_text" style=";text-align:right;direction:rtl"> , ,  .       ,  ,        . </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">لكي تكون الحدود صحيحة ، نحتاج إلى فرزها بعد إضافة خلية إليها. </font><font style="vertical-align: inherit;">في الواقع ، يمكننا تأجيل التصنيف حتى تتم إضافة جميع جيران الخلية ، ولكن ، أكرر ، حتى لا تهمنا التحسينات. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">نريد فرز الخلايا حسب المسافة. </font><font style="vertical-align: inherit;">للقيام بذلك ، نحتاج إلى استدعاء طريقة فرز القائمة مع ارتباط بالطريقة التي تجري هذه المقارنة.</font></font><br><br><pre style=";text-align:right;direction:rtl"> <code class="cs hljs"> frontier.Add(neighbor); frontier.Sort((x, y) =&gt; x.Distance.CompareTo(y.Distance));</code> </pre> <br><div class="spoiler" style=";text-align:right;direction:rtl"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">كيف تعمل طريقة الفرز هذه؟</font></font></b> <div class="spoiler_text" style=";text-align:right;direction:rtl">     .     ,       .        . <br><br><pre style=";text-align:right;direction:rtl"> <code class="cs hljs"> frontier.Sort(CompareDistances); … <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CompareDistances</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell x, HexCell y</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x.Distance.CompareTo(y.Distance); }</code> </pre> </div></div><br><div style="text-align:center;;text-align:right;direction:rtl"><img src="https://habrastorage.org/getpro/habr/post_images/2ca/f5d/f85/2caf5df85335f7997694522b7885d882.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">الحدود التي تم فرزها لا تزال غير صحيحة.</font></font></i> <br><br><h3 style=";text-align:right;direction:rtl"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> تحديث الحدود </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">بعد أن بدأنا في فرز الحدود ، بدأنا في الحصول على نتائج أفضل ، ولكن لا تزال هناك أخطاء. هذا لأنه عندما تتم إضافة خلية إلى الحدود ، فإننا لا نجد بالضرورة أقصر مسافة لهذه الخلية. هذا يعني أنه لم يعد بإمكاننا الآن تخطي الجيران الذين تم تخصيص مسافة لهم بالفعل. بدلاً من ذلك ، نحتاج إلى التحقق مما إذا وجدنا مسارًا أقصر. إذا كان الأمر كذلك ، فنحن بحاجة إلى تغيير المسافة إلى الجار ، بدلاً من إضافته إلى الحدود.</font></font><br><br><pre style=";text-align:right;direction:rtl"> <code class="cs hljs"> HexCell neighbor = current.GetNeighbor(d); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (neighbor == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (neighbor.IsUnderwater) { <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (current.GetEdgeType(neighbor) == HexEdgeType.Cliff) { <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> distance = current.Distance; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (current.HasRoadThroughEdge(d)) { distance += <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { distance += <span class="hljs-number"><span class="hljs-number">10</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (neighbor.Distance == <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>.MaxValue) { neighbor.Distance = distance; frontier.Add(neighbor); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (distance &lt; neighbor.Distance) { neighbor.Distance = distance; } frontier.Sort((x, y) =&gt; x.Distance.CompareTo(y.Distance));</code> </pre> <br><iframe width="560" height="315" src="https://www.youtube.com/embed/https://translate" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">المسافات الصحيحة. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">الآن بعد أن حصلنا على المسافات الصحيحة ، سنبدأ في التفكير في تكاليف النقل. </font><font style="vertical-align: inherit;">قد تلاحظ أن المسافات إلى بعض الخلايا كبيرة في البداية ، ولكن يتم تصحيحها عند إزالتها من الحدود. </font><font style="vertical-align: inherit;">يسمى هذا النهج خوارزمية Dijkstra ، ويطلق عليه اسم أول اختراع بواسطة Edsger Dijkstra.</font></font><br><br><h3 style=";text-align:right;direction:rtl"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> المنحدرات </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">لا نريد أن يقتصر الأمر على التكاليف المختلفة للطرق فقط. </font><font style="vertical-align: inherit;">على سبيل المثال ، يمكنك تقليل تكلفة عبور الحواف المسطحة بدون طرق إلى 5 ، وترك المنحدرات بدون طرق بقيمة 10.</font></font><br><br><pre style=";text-align:right;direction:rtl"> <code class="cs hljs"> HexEdgeType edgeType = current.GetEdgeType(neighbor); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (edgeType == HexEdgeType.Cliff) { <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> distance = current.Distance; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (current.HasRoadThroughEdge(d)) { distance += <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { distance += edgeType == HexEdgeType.Flat ? <span class="hljs-number"><span class="hljs-number">5</span></span> : <span class="hljs-number"><span class="hljs-number">10</span></span>; }</code> </pre> <br><div style="text-align:center;;text-align:right;direction:rtl"><img src="https://habrastorage.org/getpro/habr/post_images/8fd/8e1/1b5/8fd8e11b5a95d0e35ce03d1eb8bc32a0.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">للتغلب على المنحدرات ، تحتاج إلى مزيد من العمل ، والطرق سريعة دائمًا.</font></font></i> <br><br><h3 style=";text-align:right;direction:rtl"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> كائنات الإغاثة </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">يمكننا إضافة التكاليف في وجود كائنات الإغاثة. </font><font style="vertical-align: inherit;">على سبيل المثال ، في العديد من الألعاب يكون التنقل في الغابات أكثر صعوبة. </font><font style="vertical-align: inherit;">في هذه الحالة ، نضيف ببساطة جميع مستويات الكائنات إلى المسافة. </font><font style="vertical-align: inherit;">وهنا أيضا يسرع الطريق كل شيء.</font></font><br><br><pre style=";text-align:right;direction:rtl"> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (current.HasRoadThroughEdge(d)) { distance += <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { distance += edgeType == HexEdgeType.Flat ? <span class="hljs-number"><span class="hljs-number">5</span></span> : <span class="hljs-number"><span class="hljs-number">10</span></span>; distance += neighbor.UrbanLevel + neighbor.FarmLevel + neighbor.PlantLevel; }</code> </pre> <br><div style="text-align:center;;text-align:right;direction:rtl"><img src="https://habrastorage.org/getpro/habr/post_images/f6e/ef4/b2b/f6eef4b2bba378bd83daf9377f9a1603.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">الأشياء تتباطأ إذا لم يكن هناك طريق.</font></font></i> <br><br><h3 style=";text-align:right;direction:rtl"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> الجدران </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">أخيرًا ، لنأخذ في الاعتبار الجدران. </font><font style="vertical-align: inherit;">يجب أن تمنع الجدران الحركة إذا لم يمر الطريق عبرها.</font></font><br><br><pre style=";text-align:right;direction:rtl"> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (current.HasRoadThroughEdge(d)) { distance += <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (current.Walled != neighbor.Walled) { <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { distance += edgeType == HexEdgeType.Flat ? <span class="hljs-number"><span class="hljs-number">5</span></span> : <span class="hljs-number"><span class="hljs-number">10</span></span>; distance += neighbor.UrbanLevel + neighbor.FarmLevel + neighbor.PlantLevel; }</code> </pre> <br><div style="text-align:center;;text-align:right;direction:rtl"><img src="https://habrastorage.org/getpro/habr/post_images/1b3/9cd/7a9/1b39cd7a97483749c25474622ed8326b.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">الجدران لا تسمح لنا بالمرور ، تحتاج إلى البحث عن البوابة. </font></font></i> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">حزمة الوحدة</font></font></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/ar425919/">https://habr.com/ru/post/ar425919/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ar425905/index.html">كيفية كتابة كود المجمع مع تعليمات متداخلة (تقنية أخرى للتعتيم على رمز البايت)</a></li>
<li><a href="../ar425907/index.html">نحن نقوم بمشروع تعلُّم الآلة في Python. الجزء 2</a></li>
<li><a href="../ar425911/index.html">قم بنقل CRM cloud إلى الإصدار المحاصر</a></li>
<li><a href="../ar425915/index.html">كيف يمكن للاتصالات عبر الحدود أن تحل محل إشارات المرور وتقصير طريقة العمل</a></li>
<li><a href="../ar425917/index.html">مقاتل العدالة يمنع Waymo من تسجيل براءة اختراع لتكنولوجيا lidar الرئيسية</a></li>
<li><a href="../ar425921/index.html">اجتماع مجتمع .NET على CLRium # 4 + عبر الإنترنت</a></li>
<li><a href="../ar425923/index.html">25 سنة عذاب</a></li>
<li><a href="../ar425925/index.html">الطباعة ثلاثية الأبعاد في إنشاء التخطيطات على سبيل المثال في STUDIO 911</a></li>
<li><a href="../ar425927/index.html">محطة الطقس على Arduino من A إلى Z. الجزء 2</a></li>
<li><a href="../ar425929/index.html">تخلت جوجل عن الكفاح من أجل عقد البنتاجون المليار</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>