<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤹🏼 👭 🕵🏻 另一个模拟库 🌌 🧚 🌽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="下午好 我从事测试自动化。 像所有自动化工程师一样，我有一组通常选择编写测试的库和工具。 但是，在某些情况下，经常会出现一些熟悉的库无法解决此问题，并存在使自动测试不稳定或脆弱的风险。 在本文中，我想告诉您使用嘲笑ov的看似标准任务是如何促使我编写模块的。 我也想分享我的决定并听听反馈。 
 应用程...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>另一个模拟库</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/476904/"><p>下午好 我从事测试自动化。 像所有自动化工程师一样，我有一组通常选择编写测试的库和工具。 但是，在某些情况下，经常会出现一些熟悉的库无法解决此问题，并存在使自动测试不稳定或脆弱的风险。 在本文中，我想告诉您使用嘲笑ov的看似标准任务是如何促使我编写模块的。 我也想分享我的决定并听听反馈。 </p><a name="habracut"></a><br><h1> 应用程式 </h1><br><p> 审计是金融部门的必要部门之一。 数据需要定期检查（对帐）。 在这方面，我测试过的应用程序出现了。 为了不谈论抽象的东西，让我们想象一下我们的团队正在开发一个用于处理即时通讯程序中的应用程序的应用程序。 对于每个应用程序，必须在elasticsearch中创建一个适当的事件。 验证应用程序将是我们对未跳过应用程序的监视。 </p><br><p> 因此，假设我们有一个包含以下组件的系统： </p><br><ol><li> 配置服务器。 对于用户而言，这是一个单一的入口点，他不仅可以配置用于验证的应用程序，还可以配置系统的其他组件。 </li><li> 验证申请。 </li><li> 来自应用程序的数据处理存储在elasticsearch中的应用程序。 </li><li> 参考数据。 数据格式取决于与应用程序集成的Messenger。 </li></ol><br><h1> 挑战赛 </h1><br><p> 在这种情况下，测试自动化看起来非常简单： </p><br><ol><li> 环境准备： <br><ul><li> 使用最小的配置（使用msi和命令行）安装Elasticsearch。 </li><li> 已安装验证应用程序。 </li></ul></li><li> 测试执行： <br><ul><li> 验证应用程序已配置。 </li><li>  Elasticsearch充满了对应测试的测试数据（处理了多少个应用程序）。 </li><li> 该应用程序从Messenger接收“参考”数据（假定实际上有多少个应用程序）。 </li><li> 检查由应用程序发布的判决：成功验证的应用程序数量，丢失的应用程序数量等。 </li></ul></li><li> 清洁环境。 </li></ol><br><p> 问题是我们正在测试监视，但是要配置它，我们需要来自配置服务器的数据。 首先，为每次运行安装和配置服务器是一项耗时的操作（例如，它有自己的基础）。 其次，我想隔离应用程序，以简化发现缺陷时问题的定位。 最后，决定使用模拟。 </p><br><p> 这可能会引发一个问题：“如果我们仍然模拟服务器，也许我们不能花时间安装和填充Elasticsearch，而要替换模拟吗？”。 但是，您始终需要记住，模拟的使用提供了灵活性，但是增加了监视模拟行为的相关性的义务。 因此，我拒绝替换elasticsearch：安装和填充它非常简单。 </p><br><h1> 第一次模拟 </h1><br><p>服务器以/配置中的几种方式将配置发送到GET请求。 我们对两种方式感兴趣。 第一个是<code>/configuration/data_cluster</code>与集群配置 </p><br><pre> <code class="json hljs">{ <span class="hljs-attr"><span class="hljs-attr">"host"</span></span>: <span class="hljs-string"><span class="hljs-string">"127.0.0.1"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"port"</span></span>: <span class="hljs-number"><span class="hljs-number">443</span></span>, <span class="hljs-attr"><span class="hljs-attr">"credentials"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"username"</span></span>: <span class="hljs-string"><span class="hljs-string">"user"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"password"</span></span>: <span class="hljs-string"><span class="hljs-string">"pass"</span></span> } }</code> </pre> <br><p> 第二是<code>/configuration/reconciliation</code>与钻井应用程序的配置<code>/configuration/reconciliation</code> </p><br><pre> <code class="json hljs">{ <span class="hljs-attr"><span class="hljs-attr">"reconciliation_interval"</span></span>: <span class="hljs-number"><span class="hljs-number">3600</span></span>, <span class="hljs-attr"><span class="hljs-attr">"configuration_update_interval"</span></span>: <span class="hljs-number"><span class="hljs-number">60</span></span>, <span class="hljs-attr"><span class="hljs-attr">"source"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"address"</span></span>: <span class="hljs-string"><span class="hljs-string">"file:///c:/path"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"credentials"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"username"</span></span>: <span class="hljs-string"><span class="hljs-string">"user"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"password"</span></span>: <span class="hljs-string"><span class="hljs-string">"pass"</span></span> } } }</code> </pre> <br><p> 困难在于，您需要能够在测试期间或测试之间更改服务器响应，以测试应用程序如何响应配置更改，错误的密码等。 </p><br><p> 因此，静态模拟和用于单元测试中的模拟工具（模拟，来自pytest的Monkeypatch等）对我们不起作用。 我找到了一个我认为很适合我的出色的<code>pretenders</code>库。  <a href="https://pretenders.readthedocs.io/en/latest/" title="阅读假装者文档">伪装程序</a>提供使用规则确定HTTP服务器如何响应请求的HTTP服务器的功能。 规则存储在预设中，从而可以隔离不同测试套件的模拟。 预设可以清除并重新填写，使您可以根据需要更新答案。 在准备环境期间，只需将服务器本身提升一次即可： </p><br><pre> <code class="bash hljs">python -m pretenders.server.server --host 127.0.0.1 --port 8000</code> </pre> <br><p> 在测试中，我们需要增加客户端的使用。 在最简单的情况下，当答案在测试中被完全硬编码时，可能看起来像这样： </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> json <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> pytest <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pretenders.client.http <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> HTTPMock <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pretenders.common.constants <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> FOREVER @pytest.fixture <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">configuration_server_mock</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(request)</span></span></span><span class="hljs-function">:</span></span> mock = HTTPMock(host=<span class="hljs-string"><span class="hljs-string">"127.0.0.1"</span></span>, port=<span class="hljs-number"><span class="hljs-number">8000</span></span>, name=<span class="hljs-string"><span class="hljs-string">"server"</span></span>) request.addfinalizer(mock.reset) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> mock <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test_something</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(configuration_server_mock)</span></span></span><span class="hljs-function">:</span></span> configuration_server_mock.when(<span class="hljs-string"><span class="hljs-string">"GET /configuration/data_cluster"</span></span>).reply( headers={<span class="hljs-string"><span class="hljs-string">"Content-Type"</span></span>: <span class="hljs-string"><span class="hljs-string">"application/json"</span></span>}, body=json.dumps({ <span class="hljs-string"><span class="hljs-string">"host"</span></span>: <span class="hljs-string"><span class="hljs-string">"127.0.0.1"</span></span>, <span class="hljs-string"><span class="hljs-string">"port"</span></span>: <span class="hljs-number"><span class="hljs-number">443</span></span>, <span class="hljs-string"><span class="hljs-string">"credentials"</span></span>: { <span class="hljs-string"><span class="hljs-string">"username"</span></span>: <span class="hljs-string"><span class="hljs-string">"user"</span></span>, <span class="hljs-string"><span class="hljs-string">"password"</span></span>: <span class="hljs-string"><span class="hljs-string">"pass"</span></span>, }, }), status=<span class="hljs-number"><span class="hljs-number">200</span></span>, times=FOREVER, ) configuration_server_mock.when(<span class="hljs-string"><span class="hljs-string">"GET /configuration/reconciliation"</span></span>).reply( headers={<span class="hljs-string"><span class="hljs-string">"Content-Type"</span></span>: <span class="hljs-string"><span class="hljs-string">"application/json"</span></span>}, body=json.dumps({ <span class="hljs-string"><span class="hljs-string">"reconciliation_interval"</span></span>: <span class="hljs-number"><span class="hljs-number">3600</span></span>, <span class="hljs-string"><span class="hljs-string">"configuration_update_interval"</span></span>: <span class="hljs-number"><span class="hljs-number">60</span></span>, <span class="hljs-string"><span class="hljs-string">"source"</span></span>: { <span class="hljs-string"><span class="hljs-string">"address"</span></span>: <span class="hljs-string"><span class="hljs-string">"file:///c:/path"</span></span>, <span class="hljs-string"><span class="hljs-string">"credentials"</span></span>: { <span class="hljs-string"><span class="hljs-string">"username"</span></span>: <span class="hljs-string"><span class="hljs-string">"user"</span></span>, <span class="hljs-string"><span class="hljs-string">"password"</span></span>: <span class="hljs-string"><span class="hljs-string">"pass"</span></span>, }, }, }), status=<span class="hljs-number"><span class="hljs-number">200</span></span>, times=FOREVER, ) <span class="hljs-comment"><span class="hljs-comment"># test application</span></span></code> </pre> <br><p> 但这还不是全部。 凭借其灵活性， <code>pretenders</code>有两个必须记住的局限性，在我们的案例中必须加以解决： </p><br><ol><li> 不能一次删除一个规则。 为了更改答案，您必须删除整个预设并再次重新创建所有规则。 </li><li> 规则中使用的所有路径都是相对的。 预设具有格式为/嘲讽http / &lt;预设名称&gt;的唯一路径，并且该路径是规则中所有已创建路径的通用前缀。 被测应用程序仅接收主机名，并且不知道前缀。 </li></ol><br><p> 第一个限制是非常不愉快的，但是可以通过编写一个模块来封装该配置来解决。 例如 </p><br><pre> <code class="python hljs">configuration.data_cluster.port = <span class="hljs-number"><span class="hljs-number">443</span></span></code> </pre> <br><p> 或（以减少更新请求的频率） </p><br><pre> <code class="python hljs">data_cluster_config = get_default_data_cluster_config() data_cluster_config.port = <span class="hljs-number"><span class="hljs-number">443</span></span> configuration.update_data_cluster(data_cluster_config)</code> </pre> <br><p> 这种封装使我们几乎可以轻松地更新所有路径。 您还可以为每个单独的端点创建一个单独的预设，并创建一个通用（主要）预设，将其重定向（通过307或308）到单独的预设。 然后，您只能清除一个预设以更新规则。 </p><br><p> 为了摆脱前缀，您可以使用<a href="https://mitmproxy.org/" title="转到mitmproxy网站">mitmproxy</a>库。 这是一个功能强大的工具，除其他功能外，还可以重定向请求。 我们将删除前缀，如下所示： </p><br><pre> <code class="bash hljs">mitmdump --mode reverse:http://127.0.0.1:8000 --replacements :~http:^/:/mockhttp/server/ --listen-host 127.0.01 --listen-port 80</code> </pre> <br><p> 该命令的参数执行以下操作： </p><br><ol><li>  <code>--listen-host 127.0.0.1</code>和<code>--listen-port 80</code>明显。  Mitmproxy提升其服务器，并使用这些参数确定该服务器将侦听的接口和端口。 </li><li>  <code>--mode reverse:http://127.0.0.1:8000</code>意味着对mitproxy服务器的请求将重定向到<code>http://127.0.0.1:8000</code> 。  <a href="https://docs.mitmproxy.org/stable/concepts-modes/" title="各种模式的文档">在这里</a>阅读更多。 </li><li>  <code>--replacements :~http:^/:/mockhttp/server/</code>定义了用于更改请求的模板。 它由三部分组成：一个请求过滤器（HTTP请求为<code>/mockhttp/server</code> ），一个用于更改的模板（用<code>^/</code>替换路径的开头）和实际替换的<code>/mockhttp/server</code> （ <code>/mockhttp/server</code> ）。  <a href="https://docs.mitmproxy.org/stable/overview-features/" title="功能文档">在这里</a>阅读更多。 </li></ol><br><p> 在我们的示例中，我们向所有HTTP请求添加了<code>mockhttp/server</code> ，并将其重定向到<code>http://127.0.0.1:8000</code> ，即 给我们的服务器伪装者。 结果，我们已经实现了，现在可以通过对<code>http://127.0.0.1/configuration/data_cluster</code>的GET请求获得配置。 </p><br><p> 总的来说，我对<code>pretenders</code>和<code>mitmproxy</code>的设计感到满意。 由于表面上很复杂-毕竟是2台服务器而不是一台真正的服务器-准备工作包括安装2个软件包并在命令行上执行2个命令以启动它们。 并不是所有的事情都像管理模拟那样简单，但是所有的复杂性都只在一个地方（管理预设），并且可以非常简单，可靠地解决。 但是，新的情况出现在问题中，这使我开始思考新的解决方案。 </p><br><h1> 第二次模拟 </h1><br><p> 在那一刻之前，我几乎没有说过参考数据来自何处。 细心的读者可能会注意到，在上面的示例中，文件系统的路径用作数据源的地址。 它确实可以像这样工作，但仅适用于其中一个供应商。 另一个供应商提供了一个用于接收应用程序的API，正是这个问题引起了他的兴趣。 在测试过程中很难提高供应商的API，因此我计划按照与以前相同的方案将其替换为模拟。 但是要接收申请，需要一个表格 </p><br><pre> <code class="plaintext hljs">GET /application-history?page=2&amp;size=5&amp;start=1569148012&amp;end=1569148446</code> </pre> <br><p> 这里有2分。 首先，一些选择。 事实是，可以以任何顺序指定参数，这极大地使<code>pretenders</code>规则的正则表达式复杂化。 还必须记住，参数是可选的，但这不是诸如随机顺序之类的问题。 其次，最后一个参数（开始和结束）指定过滤订单的时间间隔。 这种情况下的问题在于，我们无法预先预测应用程序将使用哪个间隔（不是幅度，而是开始时间）来形成模拟响应。 简而言之，我们需要知道并使用参数值来形成“合理的”答案。 例如，在这种情况下，“合理性”很重要，因此我们可以测试应用程序是否遍历了分页的所有页面：如果我们以相同的方式回答所有请求，那么由于仅请求五分之一的页面，我们将无法发现缺陷。 。 </p><br><p> 我试图寻找替代解决方案，但最终我决定尝试编写自己的解决方案。 因此<a href="https://github.com/KillAChicken/loose-server" title="转到存储库和文档">服务器松动了</a> 。 这是一个<a href="https://palletsprojects.com/p/flask/" title="转到项目页面">Flask</a>应用程序，在启动后可以在其中配置路径和响应。 开箱即用，他知道如何使用有关请求类型（GET，POST等）和路径的规则。 这使您可以替换原始任务中的<code>pretenders</code>和<code>mitmproxy</code> 。 我还将展示如何将其用于为供应商API创建模拟。 </p><br><p> 应用程序需要2条主要路径： </p><br><ol><li> 基本端点。 这是将用于所有已配置规则的前缀。 </li><li> 配置端点。 这是您可以用来配置模拟服务器本身的那些请求的前缀。 </li></ol><br><pre> <code class="bash hljs">python -m looseserver.default.server.run --host 127.0.0.1 --port 80 --base-endpoint / --configuration-endpoint /_mock_configuration/</code> </pre> <br><p> 通常，最好不要配置基本端点和配置端点，以使一个端点是另一个端点的父节点。 否则，存在配置和测试路径冲突的风险。 配置端点优先，因为Flask规则是在配置之前添加的，而不是在动态路径中添加的。 在本例中，如果我们不打算在此模拟中包括供应商API，则可以使用<code>--base-endpoint /configuration/</code> 。 </p><br><p> 测试的最简单版本变化不大 </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> json <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> pytest <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> looseserver.default.client.http <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> HTTPClient <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> looseserver.default.client.rule <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> PathRule <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> looseserver.default.client.response <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> FixedResponse @pytest.fixture <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">configuration_server_mock</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(request)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MockFactory</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> self._client = HTTPClient(configuration_url=<span class="hljs-string"><span class="hljs-string">"http://127.0.0.1/_mock_configuration/"</span></span>) self._rule_ids = [] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">create_rule</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, path, json_response)</span></span></span><span class="hljs-function">:</span></span> rule = self._client.create_rule(PathRule(path=path)) self._rule_ids.append(rule.rule_id) response = FixedResponse( headers={<span class="hljs-string"><span class="hljs-string">"Content-Type"</span></span>: <span class="hljs-string"><span class="hljs-string">"application/json"</span></span>}, status=<span class="hljs-number"><span class="hljs-number">200</span></span>, body=json.dumps(json_response), ) self._client.set_response(rule_id=rule.rule_id, response=response) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">_delete_rules</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> rule_id <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> self._rule_ids: self._client.remove_rule(rule_id=rule_id) mock = MockFactory() request.addfinalizer(mock._delete_rules) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> mock <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test_something</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(configuration_server_mock)</span></span></span><span class="hljs-function">:</span></span> configuration_server_mock.create_rule( path=<span class="hljs-string"><span class="hljs-string">"configuration/data_cluster"</span></span>, json_response={ <span class="hljs-string"><span class="hljs-string">"host"</span></span>: <span class="hljs-string"><span class="hljs-string">"127.0.0.1"</span></span>, <span class="hljs-string"><span class="hljs-string">"port"</span></span>: <span class="hljs-number"><span class="hljs-number">443</span></span>, <span class="hljs-string"><span class="hljs-string">"credentials"</span></span>: { <span class="hljs-string"><span class="hljs-string">"username"</span></span>: <span class="hljs-string"><span class="hljs-string">"user"</span></span>, <span class="hljs-string"><span class="hljs-string">"password"</span></span>: <span class="hljs-string"><span class="hljs-string">"pass"</span></span>, }, } ) configuration_server_mock.create_rule( path=<span class="hljs-string"><span class="hljs-string">"configuration/reconciliation"</span></span>, json_response={ <span class="hljs-string"><span class="hljs-string">"reconciliation_interval"</span></span>: <span class="hljs-number"><span class="hljs-number">3600</span></span>, <span class="hljs-string"><span class="hljs-string">"configuration_update_interval"</span></span>: <span class="hljs-number"><span class="hljs-number">60</span></span>, <span class="hljs-string"><span class="hljs-string">"source"</span></span>: { <span class="hljs-string"><span class="hljs-string">"address"</span></span>: <span class="hljs-string"><span class="hljs-string">"file:///applications"</span></span>, <span class="hljs-string"><span class="hljs-string">"credentials"</span></span>: { <span class="hljs-string"><span class="hljs-string">"username"</span></span>: <span class="hljs-string"><span class="hljs-string">"user"</span></span>, <span class="hljs-string"><span class="hljs-string">"password"</span></span>: <span class="hljs-string"><span class="hljs-string">"pass"</span></span>, }, }, } )</code> </pre> <br><p> 固定装置变得越来越困难，但是现在可以一次删除一个规则，从而简化了使用它们的工作。 不再需要使用<code>mitmproxy</code> 。 </p><br><p> 让我们回到供应商API。 我们将为松散的服务器创建一种新型的规则，根据参数值，它将给出不同的答案。 接下来，我们将这个规则用于page参数。 </p><br><p> 需要为服务器和客户端创建新的规则和答案。 让我们从服务器开始： </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> looseserver.server.rule <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ServerRule <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ServerParameterRule</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(ServerRule)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, parameter_name, parameter_value=None, rule_type=</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"PARAMETER"</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function">:</span></span> super(ServerParameterRule, self).__init__(rule_type=rule_type) self._parameter_name = parameter_name self._parameter_value = parameter_value <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">is_match_found</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, request)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> self._parameter_value <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">None</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> self._parameter_name <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> request.args <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> request.args.get(self._parameter_name) == self._parameter_value</code> </pre> <br><p> 每个规则都必须定义一个<code>is_match_found</code>方法，该方法确定它是否应适用于给定的请求。 输入参数是请求对象。 创建新规则后，有必要“教导”服务器以使其从客户端接受。 为此，请使用<code>RuleFactory</code> ： </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> looseserver.default.server.rule <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> create_rule_factory <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> looseserver.default.server.application <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> configure_application <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">_create_application</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(base_endpoint, configuration_endpoint)</span></span></span><span class="hljs-function">:</span></span> server_rule_factory = create_rule_factory(base_endpoint) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">_parse_param_rule</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(rule_type, parameters)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ServerParameterRule( rule_type=rule_type, parameter_name=parameters[<span class="hljs-string"><span class="hljs-string">"parameter_name"</span></span>], parameter_value=parameters[<span class="hljs-string"><span class="hljs-string">"parameter_value"</span></span>], ) server_rule_factory.register_rule( rule_type=<span class="hljs-string"><span class="hljs-string">"PARAMETER"</span></span>, parser=_parse_param_rule, serializer=<span class="hljs-keyword"><span class="hljs-keyword">lambda</span></span> rule_type, rule: <span class="hljs-keyword"><span class="hljs-keyword">None</span></span>, ) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> configure_application( rule_factory=server_rule_factory, base_endpoint=base_endpoint, configuration_endpoint=configuration_endpoint, ) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> __name__ == <span class="hljs-string"><span class="hljs-string">"__main__"</span></span>: application = _create_application(base_endpoint=<span class="hljs-string"><span class="hljs-string">"/"</span></span>, configuration_endpoint=<span class="hljs-string"><span class="hljs-string">"/_mock_configuration"</span></span>) application.run(host=<span class="hljs-string"><span class="hljs-string">"127.0.0.1"</span></span>, port=<span class="hljs-number"><span class="hljs-number">80</span></span>)</code> </pre> <br><p> 在这里，我们默认情况下为规则创建一个工厂，以便它包含我们之前使用的规则，并注册一个新类型。 在这种情况下，客户端不需要规则信息，因此<code>serializer</code>实际上不执行任何操作。 此工厂进一步转移到应用程序。 它可以像常规的Flask应用程序一样运行。 </p><br><p> 与客户的情况相似：我们创建规则和工厂。 但是对于客户端，首先，没有必要定义<code>is_match_found</code>方法，其次，在这种情况下，需要序列化程序才能将规则发送到服务器。 </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> looseserver.client.rule <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ClientRule <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> looseserver.default.client.rule <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> create_rule_factory <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ClientParameterRule</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(ClientRule)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, parameter_name, parameter_value=None, rule_type=</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"PARAMETER"</span></span></span></span><span class="hljs-function"><span class="hljs-params">, rule_id=None)</span></span></span><span class="hljs-function">:</span></span> super(ClientParameterRule, self).__init__(rule_type=rule_type, rule_id=rule_id) self.parameter_name = parameter_name self.parameter_value = parameter_value <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">_create_client</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(configuration_url)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">_serialize_param_rule</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(rule)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { <span class="hljs-string"><span class="hljs-string">"parameter_name"</span></span>: rule.parameter_name, <span class="hljs-string"><span class="hljs-string">"parameter_value"</span></span>: rule.parameter_value, } client_rule_factory = create_rule_factory() client_rule_factory.register_rule( rule_type=<span class="hljs-string"><span class="hljs-string">"PARAMETER"</span></span>, parser=<span class="hljs-keyword"><span class="hljs-keyword">lambda</span></span> rule_type, parameters: ClientParameterRule(rule_type=rule_type, parameter_name=<span class="hljs-keyword"><span class="hljs-keyword">None</span></span>), serializer=_serialize_param_rule, ) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> HTTPClient(configuration_url=configuration_url, rule_factory=client_rule_factory)</code> </pre> <br><p> 仍然可以使用<code>_create_client</code>创建客户端，并且可以在测试中使用规则。 在下面的示例中，我添加了另一个默认规则的使用： <code>CompositeRule</code> 。 它使您可以将多个规则组合为一个，以便仅当每个规则调用<code>is_match_found</code>返回True时它们才起作用。 </p><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">@pytest.fixture def configuration_server_mock(request): class MockFactory: def __init__(self): self._client = _create_client("http://127.0.0.1/_mock_configuration/") self._rule_ids = [] def create_paged_rule(self, path, page, json_response): rule_prototype = CompositeRule( children=[ PathRule(path=path), ClientParameterRule(parameter_name="page", parameter_value=page), ] ) rule = self._client.create_rule(rule_prototype) self._rule_ids.append(rule.rule_id) response = FixedResponse( headers={"Content-Type": "application/json"}, status=200, body=json.dumps(json_response), ) self._client.set_response(rule_id=rule.rule_id, response=response) ... mock = MockFactory() request.addfinalizer(mock._delete_rules) return mock def test_something(configuration_server_mock): ... configuration_server_mock.create_paged_rule( path="application-history", page=None, json_response=["1", "2", "3"], ) configuration_server_mock.create_paged_rule( path="application-history", page="1", json_response=["1", "2", "3"], ) configuration_server_mock.create_paged_rule( path="application-history", page="2", json_response=["4", "5"], )</span></span></code> </pre> <br><h1> 结论 </h1><br><p>  <code>pretenders</code>和<code>mitmproxy</code>为创建<code>mitmproxy</code>提供了强大而灵活的工具。 优点： </p><br><ol><li> 设置简单。 </li><li> 能够使用预设隔离查询集。 </li><li> 一次删除整个隔离集。 </li></ol><br><p> 缺点包括： </p><br><ol><li> 需要为规则创建正则表达式。 </li><li> 无法单独更改规则。 </li><li> 所有创建的路径都存在前缀，或者使用<code>mitmproxy</code>进行重定向。 </li></ol><br><p> 文档链接： <br>  <a href="https://pretenders.readthedocs.io/en/latest/">假装者</a> <br>  <a href="https://docs.mitmproxy.org/stable/">三甲氧基</a> <br>  <a href="https://github.com/KillAChicken/loose-server/wiki">服务器松动</a> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN476904/">https://habr.com/ru/post/zh-CN476904/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN476880/index.html">安全婴儿床：CSRF</a></li>
<li><a href="../zh-CN476888/index.html">2020年UX设计的发展趋势</a></li>
<li><a href="../zh-CN476890/index.html">对于在Houdini工作的人。 关于Vex的本性和Python入门课程</a></li>
<li><a href="../zh-CN476900/index.html">arduino上的自主设备，指示温度升高（降低）</a></li>
<li><a href="../zh-CN476902/index.html">巴里摩尔，Voximplant的热门话题是什么？ 已实现的网络套接字，先生</a></li>
<li><a href="../zh-CN476906/index.html">SOLIDWORKS 2020新增功能</a></li>
<li><a href="../zh-CN476908/index.html">Hadoop死了吗？ 第二部分</a></li>
<li><a href="../zh-CN476910/index.html">上古：DOS游戏的声卡的艰难选择</a></li>
<li><a href="../zh-CN476912/index.html">程序员的公司代码权利</a></li>
<li><a href="../zh-CN476914/index.html">从Github存储库安装Powershell模块</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>