<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üôãüèø ü§ûüèΩ üë®üèæ‚Äç‚öñÔ∏è Membuat shader rumput di mesin Unity üëßüèº üè∏ ‚ûø</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Tutorial ini akan menunjukkan kepada Anda bagaimana menulis shader geometris untuk menghasilkan bilah rumput dari bagian atas jala yang masuk dan meng...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Membuat shader rumput di mesin Unity</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/458060/"><iframe width="560" height="315" src="https://www.youtube.com/embed/https://translate" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Tutorial ini akan menunjukkan kepada Anda bagaimana menulis shader geometris untuk menghasilkan bilah rumput dari bagian atas jala yang masuk dan menggunakan tessellation untuk mengontrol kepadatan rumput. <br><br>  Artikel ini menjelaskan proses selangkah demi selangkah dari penulisan shader rumput di Unity.  Shader menerima mesh yang masuk, dan dari setiap simpul mesh menghasilkan pisau rumput menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">shader geometris</a> .  Demi minat dan realisme, bilah rumput akan memiliki <strong>ukuran</strong> dan <strong>rotasi</strong> <strong>acak</strong> , dan mereka juga akan terpengaruh oleh <strong>angin</strong> .  Untuk mengontrol kepadatan rumput, kami menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tessellation</a> untuk memisahkan jala yang masuk.  Rumput akan dapat <strong>dilemparkan</strong> dan <strong>menerima</strong> bayangan. <br><br>  <strong>Proyek yang sudah selesai</strong> diposting di akhir artikel.  File shader yang dihasilkan berisi sejumlah besar komentar yang memudahkan pemahaman. <br><a name="habracut"></a><br><h3>  Persyaratan </h3><br>  Untuk menyelesaikan tutorial ini, Anda akan membutuhkan pengetahuan praktis tentang mesin Unity dan pemahaman awal tentang sintaks dan fungsionalitas shader. <br><br>  <a href="">Unduh konsep proyek (.zip)</a> . <br><br><h2>  Mulai bekerja </h2><br>  Unduh konsep proyek dan buka di editor Unity.  Buka adegan <code>Main</code> , dan kemudian buka shader <code>Grass</code> di editor kode Anda. <br><br>  File ini berisi shader yang menghasilkan warna putih, serta beberapa fungsi yang akan kita gunakan dalam tutorial ini.  Anda akan melihat bahwa fungsi-fungsi ini bersama dengan vertex shader termasuk dalam blok <code>CGINCLUDE</code> terletak di <em>luar</em> <code>SubShader</code> .  Kode yang ditempatkan di blok ini akan secara <strong>otomatis dimasukkan dalam semua lintasan</strong> di shader;  ini akan berguna nanti karena shader kami akan memiliki beberapa lintasan. <br><br>  Kami akan mulai dengan menulis <strong>shader geometris</strong> yang menghasilkan segitiga dari setiap titik pada permukaan mesh kami. <br><br><h2>  1. Geometris Shaders </h2><br>  Pembagi geometris adalah bagian opsional dari pipa render.  Mereka dieksekusi <strong>setelah</strong> shader vertex (atau shader tessellation jika tessellation digunakan) dan sebelum simpul diproses untuk shader fragmen. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ef7/c01/458/ef7c01458cadf7cd0cf46695d7114f96.jpg"></div><br>  <i>Direct3D Graphics Pipeline 11. Perhatikan bahwa dalam diagram ini fragmen shader disebut <em>pixel shader</em> .</i> <br><br>  Pembagi geometris menerima satu <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">primitif</a> pada input dan dapat menghasilkan nol, satu atau banyak primitif.  Kita akan mulai dengan menulis shader geometris yang menerima <strong>titik</strong> (atau <em>titik</em> ) pada input, dan yang memberi makan <strong>satu segitiga yang</strong> mewakili bilah rumput. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Add inside the CGINCLUDE block. struct geometryOutput { float4 pos : SV_POSITION; }; [maxvertexcount(3)] void geo(triangle float4 IN[3] : SV_POSITION, inout TriangleStream&lt;geometryOutput&gt; triStream) { } ‚Ä¶ // Add inside the SubShader Pass, just below the #pragma fragment frag line. #pragma geometry geo</span></span></code> </pre> <br>  Kode di atas menyatakan shader geometris yang disebut <code>geo</code> dengan dua parameter.  Yang pertama, <code>triangle float4 IN[3]</code> , melaporkan bahwa ia akan mengambil satu segitiga (terdiri dari tiga titik) sebagai input.  Yang kedua, seperti <code>TriangleStream</code> , mengatur shader untuk menampilkan aliran segitiga sehingga setiap titik menggunakan struktur <code>geometryOutput</code> Output untuk mengirimkan datanya. <br><br><div class="spoiler">  <b class="spoiler_title">Kami mengatakan di atas bahwa shader akan menerima satu simpul dan menghasilkan bilah rumput.</b>  <b class="spoiler_title">Lalu mengapa kita mendapatkan segitiga?</b> <div class="spoiler_text">  Mengambil <code></code> sebagai input lebih murah.  Ini bisa dilakukan sebagai berikut. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">geo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(point vertexOutput IN[</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">1</span></span></span></span><span class="hljs-function"><span class="hljs-params">], inout TriangleStream&lt;geometryOutput&gt; triStream)</span></span></span></span></code> </pre> <br>  Namun, karena mesh masuk kami (dalam hal ini <code>GrassPlane10x10</code> , terletak di folder <code>Mesh</code> ) memiliki <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">topologi segitiga</a> , ini akan menyebabkan ketidakcocokan antara topologi mesh yang masuk dan input primitif yang diperlukan.  Meskipun ini <strong>diizinkan</strong> dalam DirectX HLSL, itu tidak <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">diizinkan di OpenGL</a> , jadi kesalahan akan ditampilkan. </div></div><br>  Selain itu, kami menambahkan parameter terakhir dalam tanda kurung di atas deklarasi fungsi: <code>[maxvertexcount(3)]</code> .  Ia memberi tahu GPU bahwa kami akan menampilkan (tetapi tidak <strong>diharuskan</strong> melakukan) <em>tidak lebih dari</em> 3 simpul.  Kami juga membuat <code>SubShader</code> menggunakan shader geometris dengan mendeklarasikannya di dalam <code>Pass</code> . <br><br>  Shader geometris kami belum melakukan apa pun;  untuk menggambar segitiga, tambahkan kode berikut di dalam geometri shader. <br><br><pre> <code class="cpp hljs">geometryOutput o; o.pos = float4(<span class="hljs-number"><span class="hljs-number">0.5</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>); triStream.Append(o); o.pos = float4(<span class="hljs-number"><span class="hljs-number">-0.5</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>); triStream.Append(o); o.pos = float4(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>); triStream.Append(o);</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0db/534/ac1/0db534ac10c125955829fd53b9923cd7.gif"></div><br>  Ini memberikan hasil yang sangat aneh.  Saat Anda memindahkan kamera, menjadi jelas bahwa segitiga ditampilkan di <strong>ruang layar</strong> .  Ini logis: karena shader geometris dieksekusi segera sebelum memproses simpul, maka shader vertex menghilangkan tanggung jawab untuk simpul yang akan ditampilkan dalam <strong>ruang pemotongan</strong> .  Kami akan mengubah kode kami untuk mencerminkan hal ini. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Update the return call in the vertex shader. //return UnityObjectToClipPos(vertex); return vertex; ‚Ä¶ // Update each assignment of o.pos in the geometry shader. o.pos = UnityObjectToClipPos(float4(0.5, 0, 0, 1)); ‚Ä¶ o.pos = UnityObjectToClipPos(float4(-0.5, 0, 0, 1)); ‚Ä¶ o.pos = UnityObjectToClipPos(float4(0, 1, 0, 1));</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/221/912/b3e/221912b3e6bc0581126a0f415b6e79c5.png"></div><br>  Sekarang segitiga kita ditampilkan dengan benar di dunia.  Namun, tampaknya hanya satu yang dibuat.  Faktanya, satu segitiga <em>digambar</em> untuk setiap verteks dari mesh kita, tetapi posisi yang ditetapkan untuk verteks dari segitiga adalah <strong>konstan</strong> - mereka tidak berubah untuk setiap verteks yang masuk.  Oleh karena itu, semua segitiga terletak satu di atas yang lain. <br><br>  Kami akan memperbaiki ini dengan membuat <strong>offset</strong> posisi titik keluar relatif terhadap titik masuk. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Add to the top of the geometry shader. float3 pos = IN[0]; ‚Ä¶ // Update each assignment of o.pos. o.pos = UnityObjectToClipPos(pos + float3(0.5, 0, 0)); ‚Ä¶ o.pos = UnityObjectToClipPos(pos + float3(-0.5, 0, 0)); ‚Ä¶ o.pos = UnityObjectToClipPos(pos + float3(0, 1, 0));</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6b2/ac4/84c/6b2ac484c5a033b18e88400e10191779.png"></div><br><div class="spoiler">  <b class="spoiler_title">Mengapa beberapa simpul tidak membuat segitiga?</b> <div class="spoiler_text"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cab/447/d9c/cab447d9c4c82d8208a28e7cee2f7807.png"></div><br>  Meskipun kami telah menentukan bahwa primitif yang masuk akan berupa <strong>segitiga</strong> , sebilah rumput ditransmisikan hanya dari <strong>salah</strong> satu titik segitiga, membuang dua lainnya.  Tentu saja, kita dapat mentransfer sebilah rumput dari ketiga titik yang masuk, tetapi ini akan mengarah pada fakta bahwa segitiga tetangga secara berlebihan menciptakan bilah rumput di atas satu sama lain. <br><br>  Atau Anda dapat mengatasi masalah ini dengan mengambil jerat yang memiliki jenis <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">titik</a> Topologi sebagai jerat yang masuk dari shader geometris. </div></div><br>  Segitiga sekarang digambar dengan benar, dan pangkalannya terletak di puncak yang memancarkannya.  Sebelum melanjutkan, buat objek <code>GrassPlane</code> <strong>tidak aktif</strong> dalam adegan, dan buat objek <code>GrassBall</code> <strong>aktif</strong> .  Kami ingin rumput menghasilkan dengan benar pada berbagai jenis permukaan, jadi penting untuk mengujinya pada jerat berbagai bentuk. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/19b/f67/8fb/19bf678fbb6ce3c03956dbdf068004f0.png"></div><br>  Sejauh ini, semua segitiga dipancarkan dalam satu arah, dan tidak keluar dari permukaan bola.  Untuk mengatasi masalah ini, kita akan membuat bilah rumput di <strong>ruang bersinggungan</strong> . <br><br><h2>  2. Ruang singgung </h2><br>  Idealnya, kami ingin membuat bilah rumput dengan menetapkan lebar, tinggi, kelengkungan dan rotasi yang berbeda, tanpa memperhitungkan sudut permukaan dari mana bilah rumput dipancarkan.  Sederhananya, kita mendefinisikan sebilah rumput di ruang <strong>lokal ke titik memancarkannya</strong> , dan kemudian mengubahnya sehingga <strong>lokal ke jala</strong> .  Ruang ini disebut <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ruang singgung</a> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3fd/8f7/c39/3fd8f7c394bf4eb18cb988aceafe342b.png"></div><br>  <i>Dalam ruang singgung, sumbu <strong>X</strong> , <strong>Y,</strong> dan <strong>Z</strong> didefinisikan relatif terhadap normal dan posisi permukaan (dalam kasus kami, simpul).</i> <br><br>  Seperti ruang lainnya, kita dapat mendefinisikan ruang singgung titik dengan tiga vektor: <strong>kanan</strong> , <strong>maju</strong> dan <strong>atas</strong> .  Dengan menggunakan vektor-vektor ini, kita dapat membuat matriks untuk memutar bilah rumput dari garis singgung ke ruang lokal. <br><br>  Anda dapat mengakses vektor ke <strong>kanan</strong> dan <strong>atas</strong> dengan menambahkan data titik masukan baru. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Add to the CGINCLUDE block. struct vertexInput { float4 vertex : POSITION; float3 normal : NORMAL; float4 tangent : TANGENT; }; struct vertexOutput { float4 vertex : SV_POSITION; float3 normal : NORMAL; float4 tangent : TANGENT; }; ‚Ä¶ // Modify the vertex shader. vertexOutput vert(vertexInput v) { vertexOutput o; o.vertex = v.vertex; o.normal = v.normal; o.tangent = v.tangent; return o; } ‚Ä¶ // Modify the input for the geometry shader. Note that the SV_POSITION semantic is removed. void geo(triangle vertexOutput IN[3], inout TriangleStream&lt;geometryOutput&gt; triStream) ‚Ä¶ // Modify the existing line declaring pos. float3 pos = IN[0].vertex;</span></span></code> </pre> <br>  Vektor ketiga dapat dihitung dengan mengambil <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">produk vektor</a> antara dua lainnya.  Produk vektor mengembalikan vektor <strong>tegak lurus</strong> ke dua vektor yang masuk. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Place in the geometry shader, below the line declaring float3 pos. float3 vNormal = IN[0].normal; float4 vTangent = IN[0].tangent; float3 vBinormal = cross(vNormal, vTangent) * vTangent.w;</span></span></code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Mengapa hasil vektor dikalikan dengan koordinat garis singgung w?</b> <div class="spoiler_text">  Saat mengekspor mesh dari editor 3D, biasanya binormals (juga disebut <em>garis singgung ke dua titik</em> ) sudah disimpan dalam data mesh.  Alih-alih mengimpor binormals ini, Unity hanya mengambil arah setiap binormal dan menugaskan mereka ke koordinat <strong>w</strong> tangen.  Ini memungkinkan Anda untuk menghemat memori, sementara pada saat yang sama memberikan kemampuan untuk membuat ulang binormal yang benar.  Diskusi terperinci tentang topik ini dapat ditemukan di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> . </div></div><br>  Memiliki ketiga vektor, kita dapat membuat matriks untuk transformasi antara ruang singgung dan ruang lokal.  Kami akan melipatgandakan setiap simpul bilah rumput dengan matriks ini sebelum meneruskannya ke <code>UnityObjectToClipPos</code> , yang mengharapkan simpul di ruang lokal. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Add below the lines declaring the three vectors. float3x3 tangentToLocal = float3x3( vTangent.x, vBinormal.x, vNormal.x, vTangent.y, vBinormal.y, vNormal.y, vTangent.z, vBinormal.z, vNormal.z );</span></span></code> </pre> <br>  Sebelum menggunakan matriks, kami mentransfer kode output titik ke fungsi agar tidak menulis baris kode yang sama berulang kali.  Ini disebut <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">prinsip KERING</a> , atau <strong>jangan ulangi diri Anda sendiri</strong> . <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Add to the CGINCLUDE block. geometryOutput VertexOutput(float3 pos) { geometryOutput o; o.pos = UnityObjectToClipPos(pos); return o; } ‚Ä¶ // Remove the following from the geometry shader. //geometryOutput o; //o.pos = UnityObjectToClipPos(pos + float3(0.5, 0, 0)); //triStream.Append(o); //o.pos = UnityObjectToClipPos(pos + float3(-0.5, 0, 0)); //triStream.Append(o); //o.pos = UnityObjectToClipPos(pos + float3(0, 1, 0)); //triStream.Append(o); // ...and replace it with the code below. triStream.Append(VertexOutput(pos + float3(0.5, 0, 0))); triStream.Append(VertexOutput(pos + float3(-0.5, 0, 0))); triStream.Append(VertexOutput(pos + float3(0, 1, 0)));</span></span></code> </pre> <br>  Akhirnya, kita mengalikan simpul output dengan matriks <code>tangentToLocal</code> , menyelaraskan mereka dengan normal dari titik input mereka. <br><br><pre> <code class="cpp hljs">triStream.Append(VertexOutput(pos + mul(tangentToLocal, float3(<span class="hljs-number"><span class="hljs-number">0.5</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>)))); triStream.Append(VertexOutput(pos + mul(tangentToLocal, float3(<span class="hljs-number"><span class="hljs-number">-0.5</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>)))); triStream.Append(VertexOutput(pos + mul(tangentToLocal, float3(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>))));</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c95/3f8/286/c953f828675a9d4e202c0c9349d37f9d.png" alt="gambar"></div><br>  Ini lebih seperti yang kita butuhkan, tetapi tidak tepat.  Masalahnya di sini adalah bahwa pada awalnya kita menetapkan arah "atas" (atas) dari sumbu <strong>Y</strong> ;  Namun, dalam ruang singgung, arah naik biasanya terletak di sepanjang sumbu <strong>Z.</strong>  Sekarang kita akan melakukan perubahan ini. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Modify the position of the third vertex being emitted. triStream.Append(VertexOutput(pos + mul(tangentToLocal, float3(0, 0, 1))));</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0cf/f51/ddb/0cff51ddbea12280cb78a1db9ada1786.png"></div><br><h2>  3. Penampilan rumput </h2><br>  Untuk membuat segitiga lebih mirip bilah rumput, Anda perlu menambahkan warna dan variasi.  Kami mulai dengan menambahkan <strong>gradien</strong> turun dari atas bilah rumput. <br><br><h3>  Gradien warna 3.1 </h3><br>  Tujuan kami adalah memungkinkan seniman untuk mengatur dua warna - atas dan bawah, dan untuk menyisipkan di antara dua warna ini ia ujung ke pangkal pisau rumput.  Warna-warna ini sudah didefinisikan dalam file shader sebagai <code>_TopColor</code> dan <code>_BottomColor</code> .  Untuk pengambilan sampel yang tepat, Anda harus meneruskan <strong>koordinat UV</strong> ke shader fragmen. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Add to the geometryOutput struct. float2 uv : TEXCOORD0; ‚Ä¶ // Modify the VertexOutput function signature. geometryOutput VertexOutput(float3 pos, float2 uv) ‚Ä¶ // Add to VertexOutput, just below the line assigning o.pos. o.uv = uv; ‚Ä¶ // Modify the existing lines in the geometry shader. triStream.Append(VertexOutput(pos + mul(tangentToLocal, float3(0.5, 0, 0)), float2(0, 0))); triStream.Append(VertexOutput(pos + mul(tangentToLocal, float3(-0.5, 0, 0)), float2(1, 0))); triStream.Append(VertexOutput(pos + mul(tangentToLocal, float3(0, 0, 1)), float2(0.5, 1)));</span></span></code> </pre> <br>  Kami menciptakan koordinat UV untuk bilah rumput dalam bentuk segitiga, dua simpul dasar yang terletak di kiri bawah dan kanan, dan ujung atas terletak di tengah di atas. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/165/e39/932/165e399323aaa07e7c4cee728c0c9988.png"></div><br>  <i>Koordinat UV dari tiga simpul bilah rumput.</i>  <i>Meskipun kami mengecat bilah rumput dengan gradien sederhana, pengaturan tekstur yang serupa memungkinkan Anda untuk melapisi tekstur.</i> <br><br>  Sekarang kita dapat mencicipi warna atas dan bawah dalam shader fragmen dengan UV dan kemudian interpolasi dengan <code>lerp</code> .  Kita juga perlu memodifikasi parameter fragmen shader, menjadikan <code>geometryOutput</code> sebagai input, dan bukan hanya posisi <code>float4</code> . <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Modify the function signature of the fragment shader. float4 frag (geometryOutput i, fixed facing : VFACE) : SV_Target ‚Ä¶ // Replace the existing return call. return float4(1, 1, 1, 1); return lerp(_BottomColor, _TopColor, i.uv.y);</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/596/510/51f/59651051f474907a88740e83bc9d4532.png"></div><br><h3>  3.2 Arah sudu acak </h3><br>  Untuk menciptakan variabilitas dan memberikan tampilan yang lebih alami pada rumput, kami akan membuat setiap helai rumput terlihat secara acak.  Untuk melakukan ini, kita perlu membuat matriks rotasi yang memutar bilah rumput jumlah acak di sekitar sumbu <strong>atas</strong> . <br><br>  Ada dua fungsi dalam file shader yang akan membantu kami melakukan ini: <code>rand</code> , yang menghasilkan angka acak dari input tiga dimensi, dan <code>AngleAxis3x3</code> , yang menerima sudut (dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">radian</a> ) dan mengembalikan matriks yang memutar nilai ini di sekitar sumbu yang ditentukan.  Fungsi terakhir bekerja persis sama dengan fungsi C # <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Quaternion.AngleAxis</a> (hanya <code>AngleAxis3x3</code> mengembalikan matriks, bukan angka empat). <br><br>  Fungsi <code>rand</code> mengembalikan angka dalam kisaran 0 ... 1;  kita kalikan dengan <strong>2 Pi</strong> untuk mendapatkan rentang nilai sudut penuh. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Add below the line declaring the tangentToLocal matrix. float3x3 facingRotationMatrix = AngleAxis3x3(rand(pos) * UNITY_TWO_PI, float3(0, 0, 1));</span></span></code> </pre> <br>  Kami menggunakan posisi <code>pos</code> masuk sebagai seed untuk rotasi acak.  Karena ini, setiap helai rumput akan memiliki rotasi sendiri, konstan di setiap bingkai. <br><br>  Rotasi dapat diterapkan pada bilah rumput dengan mengalikannya dengan matriks <code>tangentToLocal</code> dibuat.  Perhatikan bahwa perkalian matriks <strong>tidak</strong> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">komutatif</a> ;  urutan operan itu <strong>penting</strong> . <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Add below the line declaring facingRotationMatrix. float3x3 transformationMatrix = mul(tangentToLocal, facingRotationMatrix); ‚Ä¶ // Replace the multiplication matrix operand with our new transformationMatrix. triStream.Append(VertexOutput(pos + mul(transformationMatrix, float3(0.5, 0, 0)), float2(0, 0))); triStream.Append(VertexOutput(pos + mul(transformationMatrix, float3(-0.5, 0, 0)), float2(1, 0))); triStream.Append(VertexOutput(pos + mul(transformationMatrix, float3(0, 0, 1)), float2(0.5, 1)));</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/09f/c2f/e80/09fc2fe8028b51f78989954e65812cd3.png"></div><br><h3>  3.3 Tekuk ke depan secara acak </h3><br>  Jika semua bilah rumput sejajar sempurna, mereka akan tampak sama.  Ini mungkin cocok untuk rumput yang terawat baik, misalnya, di halaman yang dipangkas, tetapi di alam rumput tidak tumbuh seperti itu.  Kami akan membuat matriks baru untuk memutar rumput di sepanjang sumbu <strong>X</strong> , serta properti untuk mengontrol rotasi ini. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Add as a new property. _BendRotationRandom("Bend Rotation Random", Range(0, 1)) = 0.2 ‚Ä¶ // Add to the CGINCLUDE block. float _BendRotationRandom; ‚Ä¶ // Add to the geometry shader, below the line declaring facingRotationMatrix. float3x3 bendRotationMatrix = AngleAxis3x3(rand(pos.zzx) * _BendRotationRandom * UNITY_PI * 0.5, float3(-1, 0, 0));</span></span></code> </pre> <br>  Sekali lagi kami menggunakan posisi bilah rumput sebagai benih acak, kali ini dengan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">menyapunya</a> untuk membuat benih yang unik.  Kami juga akan mengalikan <code>UNITY_PI</code> dengan <strong>0,5</strong> ;  ini akan memberi kita interval acak 0 ... 90 derajat. <br><br>  Kami sekali lagi menerapkan matriks ini melalui rotasi, mengalikan semuanya dalam urutan yang benar. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Modify the existing line. float3x3 transformationMatrix = mul(mul(tangentToLocal, facingRotationMatrix), bendRotationMatrix);</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/49c/122/534/49c122534d7298c0f9c646501a708daa.gif"></div><br><h3>  3.4 Lebar dan tinggi </h3><br>  Sedangkan ukuran bilah rumput terbatas pada lebar 1 unit dan tinggi 1 unit.  Kami akan menambahkan properti untuk mengontrol ukuran, serta properti untuk menambahkan variasi acak. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Add as new properties. _BladeWidth("Blade Width", Float) = 0.05 _BladeWidthRandom("Blade Width Random", Float) = 0.02 _BladeHeight("Blade Height", Float) = 0.5 _BladeHeightRandom("Blade Height Random", Float) = 0.3 ‚Ä¶ // Add to the CGINCLUDE block. float _BladeHeight; float _BladeHeightRandom; float _BladeWidth; float _BladeWidthRandom; ‚Ä¶ // Add to the geometry shader, above the triStream.Append calls. float height = (rand(pos.zyx) * 2 - 1) * _BladeHeightRandom + _BladeHeight; float width = (rand(pos.xzy) * 2 - 1) * _BladeWidthRandom + _BladeWidth; ‚Ä¶ // Modify the existing positions with our new height and width. triStream.Append(VertexOutput(pos + mul(transformationMatrix, float3(width, 0, 0)), float2(0, 0))); triStream.Append(VertexOutput(pos + mul(transformationMatrix, float3(-width, 0, 0)), float2(1, 0))); triStream.Append(VertexOutput(pos + mul(transformationMatrix, float3(0, 0, height)), float2(0.5, 1)));</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/35b/22e/f34/35b22ef34945a576100a152a0e25eec5.png"></div><br>  Segitiga sekarang jauh lebih mirip bilah rumput, tetapi juga terlalu sedikit.  Tidak ada cukup puncak di jala yang masuk untuk menciptakan kesan bidang yang terlalu padat. <br><br>  Salah satu solusinya adalah membuat mesh baru yang lebih padat, baik menggunakan C # atau dalam editor 3D.  Ini akan berhasil, tetapi tidak akan memungkinkan kita untuk mengontrol kepadatan rumput secara dinamis.  Sebagai gantinya, kami akan membagi mesh yang masuk menggunakan <strong>tessellation</strong> . <br><br><h2>  4. Tessellation </h2><br>  <strong>Tessellation</strong> adalah tahap opsional dari render pipeline, dilakukan setelah vertex shader dan sebelum geometric shader (jika ada).  Tugasnya adalah untuk membagi satu permukaan yang masuk ke banyak primitif.  Tessellation diimplementasikan dalam dua langkah yang dapat diprogram: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">hull</a> dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">domain</a> shaders. <br><br>  Untuk shader permukaan, Unity memiliki <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">implementasi tessellation bawaan</a> .  Namun, karena kita <strong>tidak menggunakan</strong> shader permukaan, kita harus mengimplementasikan shell dan domain shader kita sendiri.  Pada artikel ini, saya tidak akan membahas implementasi tessellation secara rinci, dan kami hanya menggunakan file <code>CustomTessellation.cginc</code> ada.  File ini diadaptasi dari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">artikel Coding Catlike</a> , yang merupakan sumber informasi yang sangat baik tentang implementasi tessellation di Unity. <br><br>  Jika kita memasukkan objek <code>TessellationExample</code> dalam adegan, kita akan melihat bahwa itu sudah memiliki materi yang mengimplementasikan tessellation.  Mengubah properti <strong>Tessellation Uniform</strong> menunjukkan efek subdivisi. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2d8/8a7/f01/2d88a7f01e3a7462ffd0c8f20953b5ca.gif"></div><br>  Kami menerapkan tessellation di shader rumput untuk mengontrol kepadatan pesawat, dan oleh karena itu untuk mengontrol jumlah bilah rumput yang dihasilkan.  Pertama, Anda perlu menambahkan file <code>CustomTessellation.cginc</code> .  Kami akan merujuknya dengan jalur <em>relatifnya</em> ke shader. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Add inside the CGINCLUDE block, below the other #include statements. #include "Shaders/CustomTessellation.cginc"</span></span></code> </pre> <br>  Jika Anda membuka <code>CustomTessellation.cginc</code> , Anda akan melihat bahwa <code>vertexOutput</code> dan <code>vertexOutput</code> , serta vertex shaders, sudah ditentukan di dalamnya.  Tidak perlu mendefinisikan ulang mereka di shader rumput kami;  mereka dapat dihapus. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/*struct vertexInput { float4 vertex : POSITION; float3 normal : NORMAL; float4 tangent : TANGENT; }; struct vertexOutput { float4 vertex : SV_POSITION; float3 normal : NORMAL; float4 tangent : TANGENT; }; vertexOutput vert(vertexInput v) { vertexOutput o; o.vertex = v.vertex; o.normal = v.normal; o.tangent = v.tangent; return o; }*/</span></span></code> </pre> <br>  Perhatikan bahwa <code>vert</code> vertex shader di <code>CustomTessellation.cginc</code> hanya meneruskan input langsung ke tahap tessellation;  fungsi <code>vertexOutput</code> , yang disebut di dalam domain shader, mengambil tugas untuk menciptakan struktur <code>vertexOutput</code> . <br><br>  Sekarang kita bisa menambahkan <strong>shell</strong> dan <strong>domain</strong> shader ke shader rumput.  Kami juga akan menambahkan properti <code>_TessellationUniform</code> baru untuk mengontrol ukuran unit - variabel yang sesuai dengan properti ini telah dideklarasikan di <code>CustomTessellation.cginc</code> . <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Add as a new property. _TessellationUniform("Tessellation Uniform", Range(1, 64)) = 1 ‚Ä¶ // Add below the other #pragma statements in the SubShader Pass. #pragma hull hull #pragma domain domain</span></span></code> </pre> <br>  Sekarang mengubah properti <strong>Tessellation Uniform</strong> memungkinkan kita untuk mengontrol kepadatan rumput.  Saya menemukan bahwa hasil yang baik diperoleh dengan nilai <strong>5</strong> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/280/d93/c14/280d93c1420a9744bd56f2d2496f96ab.gif"></div><br><h2>  5. Angin </h2><br>  Kami menerapkan angin dengan mengambil sampel <strong>tekstur distorsi</strong> .  Tekstur ini akan terlihat seperti <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">peta normal</a> , hanya di dalamnya hanya akan ada dua bukan tiga saluran.  Kami akan menggunakan dua saluran ini sebagai arah angin sepanjang <strong>X</strong> dan <strong>Y.</strong> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a58/aaa/687/a58aaa68742934ff1bddf1cbaf9564f5.png"></div><br>  Sebelum mencicipi tekstur angin, kita perlu membuat koordinat UV.  Alih-alih menggunakan koordinat tekstur yang ditetapkan untuk mesh, kami menerapkan posisi titik masuk.  Berkat ini, jika ada beberapa jerat rumput di dunia, ilusi akan dibuat bahwa mereka semua adalah bagian dari sistem angin yang sama.  Kami juga menggunakan <code>_Time</code> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">shader</a> untuk menggulir tekstur angin di sepanjang permukaan rumput. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Add as new properties. _WindDistortionMap("Wind Distortion Map", 2D) = "white" {} _WindFrequency("Wind Frequency", Vector) = (0.05, 0.05, 0, 0) ‚Ä¶ // Add to the CGINCLUDE block. sampler2D _WindDistortionMap; float4 _WindDistortionMap_ST; float2 _WindFrequency; ‚Ä¶ // Add to the geometry shader, just above the line declaring the transformationMatrix. float2 uv = pos.xz * _WindDistortionMap_ST.xy + _WindDistortionMap_ST.zw + _WindFrequency * _Time.y;</span></span></code> </pre> <br>  Kami menerapkan skala dan offset <code>_WindDistortionMap</code> ke posisi, dan kemudian menggesernya ke <code>_Time.y</code> , ditingkatkan ke <code>_WindFrequency</code> .  Sekarang kita akan menggunakan UVs ini untuk mencicipi tekstur dan membuat properti untuk mengontrol kekuatan angin. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Add as a new property. _WindStrength("Wind Strength", Float) = 1 ‚Ä¶ // Add to the CGINCLUDE block. float _WindStrength; ‚Ä¶ // Add below the line declaring float2 uv. float2 windSample = (tex2Dlod(_WindDistortionMap, float4(uv, 0, 0)).xy * 2 - 1) * _WindStrength;</span></span></code> </pre> <br>  Perhatikan bahwa kami skala nilai sampel dari tekstur dari interval 0 ... 1 ke interval -1 ... 1.  Selanjutnya, kita dapat membuat vektor dinormalisasi yang menunjukkan arah angin. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Add below the line declaring float2 windSample. float3 wind = normalize(float3(windSample.x, windSample.y, 0));</span></span></code> </pre> <br>  Sekarang kita dapat membuat matriks untuk memutar vektor ini dan melipatgandakannya dengan Matriks <code>transformationMatrix</code> kita. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Add below the line declaring float3 wind. float3x3 windRotation = AngleAxis3x3(UNITY_PI * windSample, wind); ‚Ä¶ // Modify the existing line. float3x3 transformationMatrix = mul(mul(mul(tangentToLocal, windRotation), facingRotationMatrix), bendRotationMatrix);</span></span></code> </pre> <br>  Akhirnya, kami mentransfer tekstur <code>Wind</code> (terletak di akar proyek) ke bidang <strong>Peta Distorsi Angin</strong> dari materi rumput di editor Unity.  Kami juga mengatur parameter <strong>Ubin</strong> tekstur ke <code>0.01, 0.01</code> . <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/https://translate" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Jika rumput tidak menjiwai di jendela <strong>Adegan</strong> , lalu klik tombol <strong>Toggle skybox, kabut, dan berbagai efek lainnya</strong> untuk mengaktifkan bahan animasi. <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Dari kejauhan, rumput terlihat benar, tetapi jika kita perhatikan dengan cermat bilah rumput, kita melihat bahwa seluruh bilah rumput berputar, itulah sebabnya alas tidak lagi menempel ke tanah. </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6e9/148/51e/6e914851e888c448c30080a7abefae33.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pangkal bilah rumput tidak lagi melekat pada tanah, tetapi berpotongan dengan itu (ditunjukkan dengan </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">warna merah</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ), dan menggantung di atas bidang tanah (ditunjukkan oleh </font><font style="vertical-align: inherit;">garis </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">hijau</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kami akan memperbaikinya dengan mendefinisikan matriks transformasi kedua, yang hanya berlaku untuk dua simpul basis. </font><font style="vertical-align: inherit;">Dalam matriks ini </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tidak akan</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> disertakan matriks </font></font><code>windRotation</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dan </font></font><code>bendRotationMatrix</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, berkat yang dasar melekat pada permukaan rumput.</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Add below the line declaring float3x3 transformationMatrix. float3x3 transformationMatrixFacing = mul(tangentToLocal, facingRotationMatrix); ‚Ä¶ // Modify the existing lines outputting the base vertex positions. triStream.Append(VertexOutput(pos + mul(transformationMatrixFacing, float3(width, 0, 0)), float2(0, 0))); triStream.Append(VertexOutput(pos + mul(transformationMatrixFacing, float3(-width, 0, 0)), float2(1, 0)));</span></span></code> </pre> <br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 6. Lengkungan bilah rumput </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sekarang setiap helai rumput ditentukan oleh satu segitiga. Pada jarak yang jauh, ini bukan masalah, tetapi di dekat bilah rumput mereka terlihat sangat kaku dan geometris, bukan organik dan bersemangat. Kami akan memperbaikinya dengan membuat bilah rumput dari beberapa segitiga dan menekuknya di sepanjang </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">kurva</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Setiap helai rumput akan dibagi menjadi beberapa </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">segmen</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Setiap segmen akan memiliki bentuk persegi panjang dan terdiri dari dua segitiga, dengan pengecualian segmen atas - itu akan menjadi satu segitiga yang menunjukkan ujung bilah rumput. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sejauh ini, kami hanya menggambar tiga simpul, membuat segitiga tunggal. Lalu, bagaimana, jika ada lebih banyak simpul, apakah geometri shader tahu mana yang akan bergabung dan membentuk segitiga? Jawabannya ada dalam struktur data</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">strip segitiga</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Tiga simpul pertama bergabung dan membentuk segitiga, dan setiap simpul baru membentuk segitiga dengan dua sebelumnya.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/871/8ec/676/8718ec676d7efd819718bd25d5b27b54.gif"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bilah rumput yang terbagi lagi, direpresentasikan sebagai strip segitiga dan menciptakan satu simpul pada satu waktu. Setelah tiga simpul pertama, setiap simpul baru membentuk segitiga baru dengan dua simpul sebelumnya.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ini tidak hanya lebih efisien dalam hal penggunaan memori, tetapi juga memungkinkan Anda untuk membuat urutan segitiga dengan mudah dan cepat dalam kode Anda. Jika kita ingin membuat beberapa garis segitiga, kita bisa memanggil </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;">RestartStrip</font></a><font style="vertical-align: inherit;"> untuk </font></font><code>TriangleStream</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fungsi tersebut </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Sebelum kita mulai menggambar lebih banyak simpul dari geometri shader, kita perlu meningkatkannya </font><font style="vertical-align: inherit;">. Kami akan menggunakan desain </font><font style="vertical-align: inherit;">untuk memungkinkan penulis shader mengontrol jumlah segmen dan menghitung jumlah simpul yang ditampilkan dari itu.</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"></font><br><br><font style="vertical-align: inherit;"></font><code>maxvertexcount</code><font style="vertical-align: inherit;"></font><code>#define</code><font style="vertical-align: inherit;"></font><br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Add to the CGINCLUDE block. #define BLADE_SEGMENTS 3 ‚Ä¶ // Modify the existing line defining the maxvertexcount. [maxvertexcount(BLADE_SEGMENTS * 2 + 1)]</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Awalnya, kami menetapkan jumlah segmen menjadi </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dan memperbarui </font></font><code>maxvertexcount</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">untuk menghitung jumlah simpul berdasarkan jumlah segmen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Untuk membuat bilah rumput yang tersegmentasi, kami menggunakan siklus </font></font><code>for</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Setiap iterasi dari loop akan menambahkan </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dua simpul</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">kiri</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dan </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">kanan</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Setelah menyelesaikan ujungnya, kami menambahkan simpul terakhir di ujung bilah rumput. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sebelum kita melakukan ini, akan berguna untuk memindahkan bagian posisi komputasi dari simpul bilah kode ke dalam fungsi, karena kita akan menggunakan kode ini beberapa kali di dalam dan di luar loop. Tambahkan </font></font><code>CGINCLUDE</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">berikut ini </font><font style="vertical-align: inherit;">ke blok </font><font style="vertical-align: inherit;">:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">geometryOutput </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GenerateGrassVertex</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(float3 vertexPosition, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> width, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> height, float2 uv, float3x3 transformMatrix)</span></span></span><span class="hljs-function"> </span></span>{ float3 tangentPoint = float3(width, <span class="hljs-number"><span class="hljs-number">0</span></span>, height); float3 localPosition = vertexPosition + mul(transformMatrix, tangentPoint); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> VertexOutput(localPosition, uv); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fungsi ini melakukan tugas yang sama karena ia melewati argumen yang sebelumnya kami lewati </font></font><code>VertexOutput</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">untuk menghasilkan simpul dari bilah rumput. </font><font style="vertical-align: inherit;">Memperoleh posisi, tinggi dan lebar, itu benar mengubah simpul menggunakan matriks yang ditransmisikan dan memberikannya koordinat UV. </font><font style="vertical-align: inherit;">Kami akan memperbarui kode yang ada agar fungsi berfungsi dengan benar.</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Update the existing code outputting the vertices. triStream.Append(GenerateGrassVertex(pos, width, 0, float2(0, 0), transformationMatrixFacing)); triStream.Append(GenerateGrassVertex(pos, -width, 0, float2(1, 0), transformationMatrixFacing)); triStream.Append(GenerateGrassVertex(pos, 0, height, float2(0.5, 1), transformationMatrix));</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fungsi mulai bekerja dengan benar, dan kami siap untuk memindahkan kode generasi vertex ke dalam loop </font></font><code>for</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Tambahkan yang </font></font><code>float width</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">berikut di </font><font style="vertical-align: inherit;">bawah baris </font><font style="vertical-align: inherit;">:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; BLADE_SEGMENTS; i++) { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> t = i / (<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>)BLADE_SEGMENTS; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kami mengumumkan siklus yang akan dijalankan sekali untuk setiap bilah segmen rumput. </font><font style="vertical-align: inherit;">Di dalam loop, tambahkan variabel </font></font><code>t</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Variabel ini akan menyimpan nilai dalam rentang 0 ... 1, yang menunjukkan seberapa jauh kita telah bergerak di sepanjang bilah rumput. </font><font style="vertical-align: inherit;">Kami menggunakan nilai ini untuk menghitung lebar dan tinggi segmen di setiap iterasi loop.</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Add below the line declaring float t. float segmentHeight = height * t; float segmentWidth = width * (1 - t);</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Saat bergerak ke atas rumput, tingginya meningkat dan lebarnya berkurang. </font><font style="vertical-align: inherit;">Sekarang kita dapat menambahkan panggilan ke loop </font></font><code>GenerateGrassVertex</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">untuk menambahkan simpul ke aliran segitiga. </font><font style="vertical-align: inherit;">Kami juga akan menambahkan satu panggilan di </font></font><code>GenerateGrassVertex</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">luar loop untuk membuat ujung bilah rumput.</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Add below the line declaring float segmentWidth. float3x3 transformMatrix = i == 0 ? transformationMatrixFacing : transformationMatrix; triStream.Append(GenerateGrassVertex(pos, segmentWidth, segmentHeight, float2(0, t), transformMatrix)); triStream.Append(GenerateGrassVertex(pos, -segmentWidth, segmentHeight, float2(1, t), transformMatrix)); ‚Ä¶ // Add just below the loop to insert the vertex at the tip of the blade. triStream.Append(GenerateGrassVertex(pos, 0, height, float2(0.5, 1), transformationMatrix)); ‚Ä¶ // Remove the existing calls to triStream.Append. //triStream.Append(GenerateGrassVertex(pos, width, 0, float2(0, 0), transformationMatrixFacing)); //triStream.Append(GenerateGrassVertex(pos, -width, 0, float2(1, 0), transformationMatrixFacing)); //triStream.Append(GenerateGrassVertex(pos, 0, height, float2(0.5, 1), transformationMatrix));</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lihatlah garis dengan deklarasi </font></font><code>float3x3 transformMatrix</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- di sini kita memilih salah satu dari dua matriks transformasi: kita ambil </font></font><code>transformationMatrixFacing</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">untuk simpul dari basis dan </font></font><code>transformationMatrix</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">untuk semua yang lain.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/02b/211/61c/02b21161cd4afc0cca35ae71ffe2570e.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bilah rumput sekarang dibagi menjadi banyak segmen, tetapi permukaan bilahnya masih datar - segitiga baru belum terlibat. </font><font style="vertical-align: inherit;">Kami akan menambahkan rumput kelengkungan, menggeser posisi vertex dari </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Y</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Pertama, kita perlu memodifikasi fungsi </font></font><code>GenerateGrassVertex</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sehingga mendapat offset di </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Y</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , yang akan kita panggil </font></font><code>forward</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Update the function signature of GenerateGrassVertex. geometryOutput GenerateGrassVertex(float3 vertexPosition, float width, float height, float forward, float2 uv, float3x3 transformMatrix) ‚Ä¶ // Modify the Y coordinate assignment of tangentPoint. float3 tangentPoint = float3(width, forward, height);</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Untuk menghitung perpindahan setiap simpul, kami mengganti </font></font><code>pow</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nilai </font><font style="vertical-align: inherit;">ke dalam fungsi </font></font><code>t</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Setelah </font></font><code>t</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">naik ke daya, pengaruhnya pada perpindahan ke depan akan menjadi </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nonlinear</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dan mengubah bilah rumput menjadi kurva.</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Add as new properties. _BladeForward("Blade Forward Amount", Float) = 0.38 _BladeCurve("Blade Curvature Amount", Range(1, 4)) = 2 ‚Ä¶ // Add to the CGINCLUDE block. float _BladeForward; float _BladeCurve; ‚Ä¶ // Add inside the geometry shader, below the line declaring float width. float forward = rand(pos.yyz) * _BladeForward; ‚Ä¶ // Add inside the loop, below the line declaring segmentWidth. float segmentForward = pow(t, _BladeCurve) * forward; ‚Ä¶ // Modify the GenerateGrassVertex calls inside the loop. triStream.Append(GenerateGrassVertex(pos, segmentWidth, segmentHeight, segmentForward, float2(0, t), transformMatrix)); triStream.Append(GenerateGrassVertex(pos, -segmentWidth, segmentHeight, segmentForward, float2(1, t), transformMatrix)); ‚Ä¶ // Modify the GenerateGrassVertex calls outside the loop. triStream.Append(GenerateGrassVertex(pos, 0, height, forward, float2(0.5, 1), transformationMatrix));</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ini adalah potongan kode yang cukup besar, tetapi semua pekerjaan dilakukan mirip dengan apa yang dilakukan untuk lebar dan tinggi bilah rumput. </font><font style="vertical-align: inherit;">Dengan nilai yang lebih rendah </font></font><code>_BladeForward</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dan </font></font><code>_BladeCurve</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">kami mendapatkan halaman yang tertata rapi, dan nilai yang lebih besar akan memberikan efek sebaliknya.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c1f/cbc/e43/c1fcbce43fa5e1c1be319dc1f5190f3d.png"></div><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 7. Pencahayaan dan bayangan </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sebagai langkah terakhir untuk menyelesaikan shader, kami akan menambahkan kemampuan untuk </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">melemparkan</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dan </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">menerima</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> bayangan. </font><font style="vertical-align: inherit;">Kami juga akan menambahkan pencahayaan sederhana dari sumber utama cahaya directional.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 7.1 Bayangan Casting </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Untuk memberikan bayangan di Unity, Anda perlu menambahkan pass kedua ke shader. Bagian ini akan digunakan oleh sumber cahaya yang menciptakan bayangan di tempat kejadian untuk membuat kedalaman rumput ke dalam </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">peta bayangan</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> mereka </font><font style="vertical-align: inherit;">. Ini berarti bahwa shader geometris harus diluncurkan di lorong bayangan, sehingga bilah rumput dapat melemparkan bayangan. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Karena shader geometris ditulis di dalam blok </font></font><code>CGINCLUDE</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, kita dapat menggunakannya dalam lintasan file apa pun. Buat pass kedua yang akan menggunakan shader yang sama dengan yang pertama, dengan pengecualian shader fragmen - kita akan mendefinisikan yang baru di mana kita akan menulis makro yang memproses output.</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Add below the existing Pass. Pass { Tags { "LightMode" = "ShadowCaster" } CGPROGRAM #pragma vertex vert #pragma geometry geo #pragma fragment frag #pragma hull hull #pragma domain domain #pragma target 4.6 #pragma multi_compile_shadowcaster float4 frag(geometryOutput i) : SV_Target { SHADOW_CASTER_FRAGMENT(i) } ENDCG }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Selain membuat shader fragmen baru, ada beberapa perbedaan penting dalam bagian ini. </font><font style="vertical-align: inherit;">Label </font></font><code>LightMode</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">penting </font></font><code>ShadowCaster</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, bukan </font></font><code>ForwardBase</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- ini memberitahu Unity bahwa bagian ini harus digunakan untuk membuat objek menjadi peta bayangan. </font><font style="vertical-align: inherit;">Ada juga arahan preprosesor di sini </font></font><code>multi_compile_shadowcaster</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Ini memastikan bahwa shader mengkompilasi semua opsi yang diperlukan untuk membuat bayangan. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jadikan objek game </font></font><code>Fence</code> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">aktif</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> di TKP; </font><font style="vertical-align: inherit;">jadi kami mendapatkan permukaan di mana bilah rumput bisa memberi bayangan.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c57/640/6cf/c576406cf284fe41e4b04d8af264d96e.png"></div><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 7.2 Mendapatkan Bayangan </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Setelah Unity merender peta bayangan dari sudut pandang bayangan yang menciptakan sumber cahaya, ia meluncurkan bagian yang "mengumpulkan" bayangan ke dalam tekstur </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ruang layar</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Untuk mencicipi tekstur ini, kita perlu menghitung posisi simpul di ruang layar dan mentransfernya ke shader fragmen.</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Add to the geometryOutput struct. unityShadowCoord4 _ShadowCoord : TEXCOORD1; ‚Ä¶ // Add to the VertexOutput function, just above the return call. o._ShadowCoord = ComputeScreenPos(o.pos);</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dalam fragmen shader dari bagian itu, </font></font><code>ForwardBase</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">kita bisa menggunakan makro untuk mendapatkan nilai yang </font></font><code>float</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">menunjukkan apakah permukaan dalam bayangan atau tidak. </font><font style="vertical-align: inherit;">Nilai ini berada dalam kisaran 0 ... 1, di mana 0 adalah naungan penuh, 1 adalah penerangan penuh.</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mengapa koordinat UV dari ruang layar disebut _ShadowCoord? </font><font style="vertical-align: inherit;">Ini tidak sesuai dengan konvensi penamaan sebelumnya.</font></font></b> <div class="spoiler_text">    Unity           (       ).          <code>SHADOW_ATTENUATION</code> .         <code>Autolight.cginc</code> ,  ,       . <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> SHADOW_ATTENUATION(a) unitySampleShadow(a._ShadowCoord)</span></span></code> </pre> <br>              -    ,            . </div></div><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Add to the ForwardBase pass's fragment shader, replacing the existing return call. return SHADOW_ATTENUATION(i); //return lerp(_BottomColor, _TopColor, i.uv.y);</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Akhirnya, kita perlu membuat shader dikonfigurasi dengan benar untuk menerima bayangan. </font><font style="vertical-align: inherit;">Untuk melakukan ini, kami akan menambahkan </font></font><code>ForwardBase</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">arahan preprocessor </font><font style="vertical-align: inherit;">ke pass </font><font style="vertical-align: inherit;">sehingga mengkompilasi semua opsi shader yang diperlukan.</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Add to the ForwardBase pass's preprocessor directives, below #pragma target 4.6. #pragma multi_compile_fwdbase</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/90a/491/468/90a491468a1ad129d35bea03b0b51898.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Setelah mendekatkan kamera, kita bisa melihat artefak di permukaan bilah rumput; </font><font style="vertical-align: inherit;">mereka disebabkan oleh fakta bahwa bilah rumput individu membayangi diri mereka sendiri. </font><font style="vertical-align: inherit;">Kita dapat memperbaikinya dengan menerapkan </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pergeseran linier</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> atau memindahkan posisi simpul di ruang pemotongan sedikit jauh dari layar. </font><font style="vertical-align: inherit;">Kami akan menggunakan makro Unity untuk ini dan memasukkannya ke dalam desain </font></font><code>#if</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sehingga operasi hanya dilakukan di jalur bayangan.</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Add at the end of the VertexOutput function, just above the return call. #if UNITY_PASS_SHADOWCASTER // Applying the bias prevents artifacts from appearing on the surface. o.pos = UnityApplyLinearShadowBias(o.pos); #endif</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/dca/ec0/d88/dcaec0d88eea1893b6a07eb45724a0b6.gif"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Setelah menerapkan pergantian bayangan linier, artefak bayangan dalam bentuk garis-garis menghilang dari permukaan segitiga.</font></font></i> <br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mengapa ada artefak di sepanjang tepi bilah rumput yang teduh?</font></font></b> <div class="spoiler_text"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/08a/12e/af1/08a12eaf1af17fc9b35de7d07a64afca.png"></div><br>      (multisample anti-aliasing <strong>MSAA</strong> ) Unity <em> </em>     ,        .        ,  . <br><br>    ‚Äî  ,    ,   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">  Unity</a> .      (     );     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">    Unity</a> . </div></div><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 7.3 Pencahayaan </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kami akan menerapkan pencahayaan menggunakan algoritma perhitungan pencahayaan tersebar sangat sederhana dan umum.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/404/3ae/452/4043ae452046c0b4b405aa88afe8d2b7.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">... di mana </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">N</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> adalah normal ke permukaan, </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> adalah arah yang dinormalisasi dari sumber utama pencahayaan terarah, dan </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> adalah pencahayaan yang dihitung. </font><font style="vertical-align: inherit;">Dalam tutorial ini kami </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tidak akan</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> menerapkan pencahayaan tidak langsung. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Saat ini, normals tidak ditugaskan untuk simpul dari bilah rumput. </font><font style="vertical-align: inherit;">Seperti halnya posisi vertex, pertama-tama kita menghitung normals dalam </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ruang singgung</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dan kemudian mengubahnya menjadi lokal. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ketika </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Angka Kelengkungan Pisau</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> adalah </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , semua bilah rumput di ruang singgung diarahkan dalam satu arah: tepat di seberang sumbu </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Y</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Sebagai langkah pertama dari solusi kami, kami menghitung yang normal, dengan asumsi tidak ada lengkungan.</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Add to the GenerateGrassVertex function, belowing the line declaring tangentPoint. float3 tangentNormal = float3(0, -1, 0); float3 localNormal = mul(transformMatrix, tangentNormal);</span></span></code> </pre> <br> <code>tangentNormal</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, didefinisikan secara langsung berlawanan dengan sumbu </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Y</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , ditransformasikan oleh matriks yang sama yang kami gunakan untuk mengkonversi titik singgung ke ruang lokal. </font><font style="vertical-align: inherit;">Sekarang kita bisa meneruskannya ke suatu fungsi </font></font><code>VertexOutput</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, dan kemudian ke suatu struktur </font></font><code>geometryOutput</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Modify the return call in GenerateGrassVertex. return VertexOutput(localPosition, uv, localNormal); ‚Ä¶ // Add to the geometryOutput struct. float3 normal : NORMAL; ‚Ä¶ // Modify the existing function signature. geometryOutput VertexOutput(float3 pos, float2 uv, float3 normal) ‚Ä¶ // Add to the VertexOutput function to pass the normal through to the fragment shader. o.normal = UnityObjectToWorldNormal(normal);</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Perhatikan bahwa sebelum kesimpulan, kita mengubah yang normal menjadi </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ruang dunia</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ; </font><font style="vertical-align: inherit;">Unity menyampaikan kepada shaders arah sumber utama cahaya terarah di ruang dunia, sehingga transformasi ini diperlukan. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sekarang kita dapat memvisualisasikan normals dalam fragmen shader </font></font><code>ForwardBase</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">untuk memeriksa hasil pekerjaan kita.</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Add to the ForwardBase fragment shader. float3 normal = facing &gt; 0 ? i.normal : -i.normal; return float4(normal * 0.5 + 0.5, 1); // Remove the existing return call. //return SHADOW_ATTENUATION(i);</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Karena </font></font><code>Cull</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nilai diberikan </font><font style="vertical-align: inherit;">pada shader kami </font></font><code>Off</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, kedua sisi bilah rumput diberikan. </font><font style="vertical-align: inherit;">Agar normal diarahkan pada arah yang benar, kami menggunakan parameter tambahan </font></font><code>VFACE</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">yang kami tambahkan ke shader fragmen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Argumen </font></font><code>fixed facing</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">akan mengembalikan angka </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">positif</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> jika kita menampilkan permukaan depan, dan angka </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">negatif</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> jika sebaliknya. </font><font style="vertical-align: inherit;">Kami menggunakan ini dalam kode di atas untuk membalik normal jika perlu.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e1b/8ca/965/e1b8ca965ed8e80b539a9773d1adeb0c.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ketika </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jumlah Kelengkungan Blade</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> lebih besar dari 1, posisi garis singgung </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Z</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dari </font><font style="vertical-align: inherit;">setiap simpul akan digeser dengan jumlah yang </font></font><code>forward</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">diteruskan ke fungsi </font></font><code>GenerateGrassVertex</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Kami akan menggunakan nilai ini untuk secara proporsional skala sumbu </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Z</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dari </font><font style="vertical-align: inherit;">normal.</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Modify the existing line in GenerateGrassVertex. float3 tangentNormal = normalize(float3(0, -1, forward));</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Terakhir, tambahkan kode ke shader fragmen untuk menggabungkan bayangan, pencahayaan terarah, dan pencahayaan sekitar. </font><font style="vertical-align: inherit;">Saya merekomendasikan mempelajari informasi yang lebih terperinci tentang penerapan pencahayaan khusus dalam shader di </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tutorial</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> saya </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;">tentang toon shader</font></a><font style="vertical-align: inherit;"> .</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Add to the ForwardBase fragment shader, below the line declaring float3 normal. float shadow = SHADOW_ATTENUATION(i); float NdotL = saturate(saturate(dot(normal, _WorldSpaceLightPos0)) + _TranslucentGain) * shadow; float3 ambient = ShadeSH9(float4(normal, 1)); float4 lightIntensity = NdotL * _LightColor0 + float4(ambient, 1); float4 col = lerp(_BottomColor, _TopColor * lightIntensity, i.uv.y); return col; // Remove the existing return call. //return float4(normal * 0.5 + 0.5, 1);</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c14/894/d14/c14894d14edc336b770f4b94bedd3708.png"></div><br><h2>  Kesimpulan </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dalam tutorial ini, rumput mencakup area kecil 10x10 unit. </font><font style="vertical-align: inherit;">Agar shader dapat menutup ruang terbuka besar dengan tetap mempertahankan kinerja tinggi, optimisasi harus diperkenalkan. </font><font style="vertical-align: inherit;">Anda dapat menerapkan tessellation berdasarkan jarak sehingga bilah rumput lebih sedikit dihasilkan dari kamera. </font><font style="vertical-align: inherit;">Selain itu, untuk jarak yang jauh, bukannya bilah rumput individu, kelompok bilah rumput dapat ditarik menggunakan quadrangle tunggal dengan tekstur yang ditumpangkan.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5a7/a05/e86/5a7a05e8690c152f9196bb3c94fada19.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tekstur rumput termasuk dalam paket </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aset Standar</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> mesin Unity. </font><font style="vertical-align: inherit;">Banyak bilah rumput digambar pada satu segi empat, yang mengurangi jumlah segitiga dalam adegan. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Meskipun secara alami kita tidak dapat menggunakan pembagi geometris dengan pembungkus permukaan, untuk meningkatkan atau memperluas fungsi pencahayaan dan naungan, jika Anda perlu menggunakan model pencahayaan Unity standar, Anda dapat mempelajari </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">repositori GitHub ini</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , yang menunjukkan solusi untuk masalah ini dengan menunda render dan pengisian G-buffer secara manual. </font></font><br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kode sumber Shader di repositori GitHub</font></font></a> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Penambahan: kerja sama </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tanpa interoperabilitas, efek grafis mungkin tampak statis atau tidak bernyawa bagi pemain. </font><font style="vertical-align: inherit;">Tutorial ini sudah sangat panjang, jadi saya tidak menambahkan bagian tentang interaksi objek dunia dengan rumput. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Implementasi herbal interaktif yang naif akan mengandung dua komponen: sesuatu di dunia game yang dapat </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mengirimkan data</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ke shader untuk memberi tahu bagian mana dari rumput yang sedang berinteraksi dengan, dan kode dalam shader untuk </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">menafsirkan</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> data ini. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Contoh bagaimana ini dapat diterapkan dengan air ditunjukkan di </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sini</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Dapat diadaptasi untuk bekerja dengan rumput; </font><font style="vertical-align: inherit;">alih-alih menggambar riak di tempat karakter berada, Anda dapat membalik bilah rumput ke bawah untuk mensimulasikan efek langkah.</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id458060/">https://habr.com/ru/post/id458060/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id458046/index.html">Lembar Curang Gradle</a></li>
<li><a href="../id458048/index.html">Delegasi sebagai alat manajer</a></li>
<li><a href="../id458050/index.html">Bagaimana Piter Mobius 2019 (dan sedikit tentang Mobius berikutnya)</a></li>
<li><a href="../id458052/index.html">AMA dengan Habr. 10. Terakhir * Masalah</a></li>
<li><a href="../id458056/index.html">Wawancara besar dengan Martin Kleppmann: ‚ÄúMencari masa depan sistem data terdistribusi‚Äù</a></li>
<li><a href="../id458062/index.html">Gambaran Umum Platform UserGate</a></li>
<li><a href="../id458064/index.html">PVS-Studio di Awan - Menjalankan Analisis pada Travis CI</a></li>
<li><a href="../id458068/index.html">PVS-Studio untuk Visual Studio</a></li>
<li><a href="../id458070/index.html">PVS-Studio untuk Visual Studio</a></li>
<li><a href="../id458072/index.html">PVS-Studio pergi ke awan - meluncurkan analisis tentang Travis CI</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>