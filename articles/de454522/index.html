<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤳🏻 🤽🏽 👳 Node.js: Verwalten des Speichers, der für Anwendungen verfügbar ist, die in Containern ausgeführt werden 🎣 📃 🧒🏽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Beim Ausführen von Node.js-Anwendungen in Docker-Containern funktionieren herkömmliche Speichereinstellungen nicht immer wie erwartet. Das Material, d...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Node.js: Verwalten des Speichers, der für Anwendungen verfügbar ist, die in Containern ausgeführt werden</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/454522/">  Beim Ausführen von Node.js-Anwendungen in Docker-Containern funktionieren herkömmliche Speichereinstellungen nicht immer wie erwartet.  Das Material, dessen Übersetzung wir heute veröffentlichen, ist darauf ausgerichtet, die Antwort auf die Frage zu finden, warum dies so ist.  Es enthält auch praktische Empfehlungen zum Verwalten des Speichers, der für Node.js-Anwendungen verfügbar ist, die in Containern ausgeführt werden. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/webt/9_/rp/-s/9_rp-s7libv7ncp6mubs2h_qjzu.png"></a> <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">Überprüfung der Empfehlungen</font> </h2><br>  Angenommen, eine Node.js-Anwendung wird in einem Container mit einem festgelegten Speicherlimit ausgeführt.  Wenn es sich um Docker handelt, kann die Option <code>--memory</code> verwendet werden, um dieses Limit <code>--memory</code> .  Ähnliches ist bei der Arbeit mit Container-Orchestrierungssystemen möglich.  In diesem Fall wird empfohlen, beim Starten der Anwendung Node.js die <code>--max-old-space-size</code> .  Auf diese Weise können Sie die Plattform darüber informieren, wie viel Speicher für sie verfügbar ist, und auch berücksichtigen, dass diese Menge unter dem auf Containerebene festgelegten Grenzwert liegen sollte. <br><br>  Wenn die Anwendung Node.js im Container ausgeführt wird, legen Sie die Kapazität des verfügbaren Speichers entsprechend dem Spitzenwert der von der Anwendung verwendeten aktiven Speichermenge fest.  Dies erfolgt, wenn die Container-Speichergrenzen konfiguriert werden können. <br><br>  Lassen Sie uns nun näher auf das Problem der Verwendung von Speicher in Containern eingehen. <br><br><h2>  <font color="#3AC1EF">Docker-Speicherlimit</font> </h2><br>  Standardmäßig haben Container keine Ressourcenbeschränkungen und können so viel Speicher verwenden, wie das Betriebssystem zulässt.  Der <code>docker run</code> Befehl <code>docker run</code> verfügt über Befehlszeilenoptionen, mit denen Sie Grenzwerte für die Speichernutzung oder die Prozessorressourcen festlegen können. <br><br>  Der Befehl zum Starten des Containers könnte folgendermaßen aussehen: <br><br><pre> <code class="javascript hljs">docker run --memory &lt;x&gt;&lt;y&gt; --interactive --tty &lt;imagename&gt; bash</code> </pre> <br>  Bitte beachten Sie Folgendes: <br><br><ul><li>  <code>x</code> ist die Grenze der dem Container zur Verfügung stehenden Speichermenge, ausgedrückt in Einheiten von <code>y</code> . </li><li>  <code>y</code> kann den Wert <code>b</code> (Bytes), <code>k</code> (Kilobyte), <code>m</code> (Megabyte), <code>g</code> (Gigabyte) annehmen. </li></ul><br>  Hier ist ein Beispiel für einen Container-Startbefehl: <br><br><pre> <code class="javascript hljs">docker run --memory <span class="hljs-number"><span class="hljs-number">1000000</span></span>b --interactive --tty &lt;imagename&gt; bash</code> </pre> <br>  Hier ist das Speicherlimit auf <code>1000000</code> Bytes festgelegt. <br><br>  Um das auf Containerebene festgelegte Speicherlimit zu überprüfen, können Sie im Container den folgenden Befehl ausführen: <br><br><pre> <code class="javascript hljs">cat /sys/fs/cgroup/memory/memory.limit_in_bytes</code> </pre> <br>  Lassen Sie uns über das Verhalten des Systems sprechen, wenn Sie das Speicherlimit für die Anwendung Node.js mit dem <code>--max-old-space-size</code> .  In diesem Fall entspricht dieses Speicherlimit dem auf Containerebene festgelegten Limit. <br><br>  Was im Schlüsselnamen als "alter Raum" bezeichnet wird, ist eines der Fragmente des von V8 kontrollierten Heaps (der Ort, an dem die "alten" JavaScript-Objekte platziert werden).  Diese Taste steuert die maximale Heap-Größe, wenn Sie nicht auf die Details eingehen, die wir unten berühren.  Details zu den Befehlszeilenschaltern von Node.j finden Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> . <br><br>  Wenn eine Anwendung versucht, mehr Speicher zu verwenden, als im Container verfügbar ist, wird ihr Betrieb im Allgemeinen beendet. <br><br>  Im folgenden Beispiel (die Anwendungsdatei heißt <code>test-fatal-error.js</code> ) werden <code>MyRecord</code> Objekte im Abstand von 10 Millisekunden in das <code>test-fatal-error.js</code> <code>MyRecord</code> .  Dies führt zu einem unkontrollierten Heap-Wachstum, das einen Speicherverlust simuliert. <br><br><pre> <code class="javascript hljs"><span class="hljs-meta"><span class="hljs-meta">'use strict'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> list = []; setInterval(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">=&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> record = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MyRecord(); list.push(record); },<span class="hljs-number"><span class="hljs-number">10</span></span>); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MyRecord</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> x=<span class="hljs-string"><span class="hljs-string">'hii'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.name = x.repeat(<span class="hljs-number"><span class="hljs-number">10000000</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.id = x.repeat(<span class="hljs-number"><span class="hljs-number">10000000</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.account = x.repeat(<span class="hljs-number"><span class="hljs-number">10000000</span></span>); } setInterval(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">=&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(process.memoryUsage()) },<span class="hljs-number"><span class="hljs-number">100</span></span>);</code> </pre> <br>  Bitte beachten Sie, dass alle Beispiele für Programme, die wir hier diskutieren werden, im Docker-Image enthalten sind, das vom Docker Hub heruntergeladen werden kann: <br><br><pre> <code class="javascript hljs">docker pull ravali1906/dockermemory</code> </pre> <br>  Sie können dieses Bild für unabhängige Experimente verwenden. <br><br>  Darüber hinaus können Sie die Anwendung in einen Docker-Container packen, das Image sammeln und mit dem Speicherlimit ausführen: <br><br><pre> <code class="javascript hljs">docker run --memory <span class="hljs-number"><span class="hljs-number">512</span></span>m --interactive --tty ravali1906/dockermemory bash</code> </pre> <br>  Hier ist <code>ravali1906/dockermemory</code> der Name des Bildes. <br><br>  Jetzt können Sie die Anwendung starten, indem Sie ein Speicherlimit angeben, das das Containerlimit überschreitet: <br><br><pre> <code class="javascript hljs">$ node --max_old_space_size=<span class="hljs-number"><span class="hljs-number">1024</span></span> test-fatal-error.js { <span class="hljs-attr"><span class="hljs-attr">rss</span></span>: <span class="hljs-number"><span class="hljs-number">550498304</span></span>, <span class="hljs-attr"><span class="hljs-attr">heapTotal</span></span>: <span class="hljs-number"><span class="hljs-number">1090719744</span></span>, <span class="hljs-attr"><span class="hljs-attr">heapUsed</span></span>: <span class="hljs-number"><span class="hljs-number">1030627104</span></span>, <span class="hljs-attr"><span class="hljs-attr">external</span></span>: <span class="hljs-number"><span class="hljs-number">8272</span></span> } Killed</code> </pre> <br>  Hier repräsentiert der <code>--max_old_space_size</code> das in Megabyte angegebene Speicherlimit.  Die Methode <code>process.memoryUsage()</code> gibt Auskunft über die Speichernutzung.  Die Werte werden in Bytes ausgedrückt. <br><br>  Die Anwendung wird zu einem bestimmten Zeitpunkt zwangsweise beendet.  Dies geschieht, wenn die von ihm verwendete Speichermenge eine bestimmte Grenze überschreitet.  Was ist diese Grenze?  Über welche Einschränkungen der Speichermenge können wir sprechen? <br><br><h2>  <font color="#3AC1EF">Das erwartete Verhalten einer Anwendung, die mit dem Schlüssel ausgeführt wird, ist - max-old-space-size</font> </h2><br>  Standardmäßig beträgt die maximale Heap-Größe in Node.js (bis Version 11.x) 700 MB auf 32-Bit-Plattformen und 1400 MB auf 64-Bit-Plattformen.  Informationen zum Einstellen dieser Werte finden Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> . <br><br>  Wenn Sie <code>--max-old-space-size</code> Schlüssel <code>--max-old-space-size</code> , <code>--max-old-space-size</code> Speicherlimit <code>--max-old-space-size</code> , das das Container-Speicherlimit überschreitet, können Sie davon ausgehen, dass die Anwendung durch den Kernel-Sicherheitsmechanismus des Linux OOM Killer-Kernels beendet wird. <br><br>  In Wirklichkeit kann dies nicht passieren. <br><br><h2>  <font color="#3AC1EF">Das tatsächliche Verhalten der Anwendung, die mit dem Schlüssel ausgeführt wird, ist max-old-space-size</font> </h2><br>  Die Anwendung weist unmittelbar nach dem Start nicht den gesamten Speicher zu, dessen Begrenzung mit <code>--max-old-space-size</code> .  Die Größe des JavaScript-Heaps hängt von den Anforderungen der Anwendung ab.  Sie können anhand des Werts des <code>heapUsed</code> aus dem von der Methode <code>heapUsed</code> <code>process.memoryUsage()</code> Objekt beurteilen, wie viel Speicher die Anwendung verwendet.  Tatsächlich handelt es sich um den im Heap für Objekte zugewiesenen Speicher. <br><br>  Infolgedessen schließen wir, dass die Anwendung zwangsweise beendet wird, wenn die Heap-Größe größer ist als der durch den Schlüssel <code>--memory</code> festgelegte Grenzwert, wenn der Container <code>--memory</code> . <br><br>  Aber in Wirklichkeit kann dies auch nicht passieren. <br><br>  Bei der Profilerstellung für ressourcenintensive Node.js-Anwendungen, die in Containern mit einem bestimmten Speicherlimit ausgeführt werden, können die folgenden Muster beobachtet werden: <br><br><ol><li>  OOM Killer wird viel später ausgelöst als in dem Moment, in dem die <code>heapUsed</code> <code>heapTotal</code> und <code>heapUsed</code> deutlich über den Speichergrenzen liegen. </li><li>  OOM Killer reagiert nicht auf das Überschreiten von Grenzwerten. </li></ol><br><h2>  <font color="#3AC1EF">Eine Erklärung des Verhaltens von Node.js-Anwendungen in Containern</font> </h2><br>  Ein Container überwacht einen wichtigen Indikator für die Anwendungen, die auf ihm ausgeführt werden.  Dies ist <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">RSS</a> (Resident Set Size).  Dieser Indikator repräsentiert einen bestimmten Teil des virtuellen Speichers der Anwendung. <br><br>  Darüber hinaus ist es ein Speicher, der der Anwendung zugewiesen wird. <br><br>  Das ist aber noch nicht alles.  RSS ist Teil des aktiven Speichers, der der Anwendung zugewiesen ist. <br><br>  Möglicherweise ist nicht der gesamte einer Anwendung zugewiesene Speicher aktiv.  Tatsache ist, dass „zugewiesener Speicher“ nicht unbedingt physisch zugewiesen wird, bis der Prozess beginnt, ihn wirklich zu verwenden.  Darüber hinaus kann das Betriebssystem als Antwort auf Anforderungen zur Speicherzuweisung von anderen Prozessen inaktive Teile des Anwendungsspeichers in die Auslagerungsdatei kopieren und den freigegebenen Speicherplatz an andere Prozesse übertragen.  Wenn die Anwendung diese Speicherelemente erneut benötigt, werden sie aus der Auslagerungsdatei entnommen und in den physischen Speicher zurückgeführt. <br><br>  Die RSS-Metrik gibt die Menge des aktiven und verfügbaren Speichers für die Anwendung in ihrem Adressraum an.  Er beeinflusst die Entscheidung über das erzwungene Herunterfahren der Anwendung. <br><br><h2>  <font color="#3AC1EF">Beweise</font> </h2><br><h3>  <font color="#3AC1EF">▍ Beispiel Nr. 1.</font>  <font color="#3AC1EF">Eine Anwendung, die Speicher für einen Puffer reserviert</font> </h3><br>  Das folgende Beispiel, <code>buffer_example.js</code> , zeigt ein Programm, das Speicher für einen Puffer reserviert: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> buf = Buffer.alloc(+process.argv[<span class="hljs-number"><span class="hljs-number">2</span></span>] * <span class="hljs-number"><span class="hljs-number">1024</span></span> * <span class="hljs-number"><span class="hljs-number">1024</span></span>) <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.round(buf.length / (<span class="hljs-number"><span class="hljs-number">1024</span></span> * <span class="hljs-number"><span class="hljs-number">1024</span></span>))) <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.round(process.memoryUsage().rss / (<span class="hljs-number"><span class="hljs-number">1024</span></span> * <span class="hljs-number"><span class="hljs-number">1024</span></span>)))</code> </pre> <br>  Führen Sie den Container zunächst mit dem folgenden Befehl aus, damit die vom Programm zugewiesene Speichermenge den beim Start des Containers festgelegten Grenzwert überschreitet: <br><br><pre> <code class="javascript hljs">docker run --memory <span class="hljs-number"><span class="hljs-number">1024</span></span>m --interactive --tty ravali1906/dockermemory bash</code> </pre> <br>  Führen Sie danach das Programm aus: <br><br><pre> <code class="javascript hljs">$ node buffer_example <span class="hljs-number"><span class="hljs-number">2000</span></span> <span class="hljs-number"><span class="hljs-number">2000</span></span> <span class="hljs-number"><span class="hljs-number">16</span></span></code> </pre> <br>  Wie Sie sehen, hat das System das Programm nicht abgeschlossen, obwohl der vom Programm zugewiesene Speicher das Containerlimit überschreitet.  Dies geschah aufgrund der Tatsache, dass das Programm nicht mit dem gesamten zugewiesenen Speicher arbeitet.  RSS ist sehr klein und überschreitet nicht das Container-Speicherlimit. <br><br><h3>  <font color="#3AC1EF">▍ Beispiel Nr. 2.</font>  <font color="#3AC1EF">Anwendung, die den Puffer mit Daten füllt</font> </h3><br>  Im folgenden Beispiel, <code>buffer_example_fill.js</code> , wird der Speicher nicht nur zugewiesen, sondern auch mit Daten gefüllt: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> buf = Buffer.alloc(+process.argv[<span class="hljs-number"><span class="hljs-number">2</span></span>] * <span class="hljs-number"><span class="hljs-number">1024</span></span> * <span class="hljs-number"><span class="hljs-number">1024</span></span>,<span class="hljs-string"><span class="hljs-string">'x'</span></span>) <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.round(buf.length / (<span class="hljs-number"><span class="hljs-number">1024</span></span> * <span class="hljs-number"><span class="hljs-number">1024</span></span>))) <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.round(process.memoryUsage().rss / (<span class="hljs-number"><span class="hljs-number">1024</span></span> * <span class="hljs-number"><span class="hljs-number">1024</span></span>)))</code> </pre> <br>  Führen Sie den Container aus: <br><br><pre> <code class="javascript hljs">docker run --memory <span class="hljs-number"><span class="hljs-number">1024</span></span>m --interactive --tty ravali1906/dockermemory bash</code> </pre> <br>  Führen Sie danach die Anwendung aus: <br><br><pre> <code class="javascript hljs">$ node buffer_example_fill.js <span class="hljs-number"><span class="hljs-number">2000</span></span> <span class="hljs-number"><span class="hljs-number">2000</span></span> <span class="hljs-number"><span class="hljs-number">984</span></span></code> </pre> <br>  Anscheinend endet die Anwendung auch jetzt noch nicht!  Warum?  Tatsache ist, dass einige der alten Seiten im Prozessspeicher in die Auslagerungsdatei verschoben werden, wenn die Menge des aktiven Speichers den beim Starten des Containers festgelegten Grenzwert erreicht und in der Auslagerungsdatei Platz ist.  Der freigegebene Speicher wird für denselben Prozess verfügbar gemacht.  Standardmäßig weist Docker der Auslagerungsdatei Speicherplatz zu, der dem mit dem Flag <code>--memory</code> festgelegten Speicherlimit <code>--memory</code> .  Vor diesem Hintergrund können wir sagen, dass der Prozess 2 GB Speicher hat - 1 GB im aktiven Speicher und 1 GB in der Auslagerungsdatei.  Das heißt, aufgrund der Tatsache, dass die Anwendung ihren eigenen Speicher verwenden kann, dessen Inhalt vorübergehend in die Auslagerungsdatei verschoben wird, liegt die Größe des RSS-Index innerhalb des Containerlimits.  Infolgedessen funktioniert die Anwendung weiterhin. <br><br><h3>  <font color="#3AC1EF">▍ Beispiel Nr. 3.</font>  <font color="#3AC1EF">Eine Anwendung, die einen Puffer mit Daten füllt, die in einem Container ausgeführt werden, der keine Auslagerungsdatei verwendet</font> </h3><br>  Hier ist der Code, mit dem wir hier experimentieren werden (dies ist dieselbe Datei <code>buffer_example_fill.js</code> ): <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> buf = Buffer.alloc(+process.argv[<span class="hljs-number"><span class="hljs-number">2</span></span>] * <span class="hljs-number"><span class="hljs-number">1024</span></span> * <span class="hljs-number"><span class="hljs-number">1024</span></span>,<span class="hljs-string"><span class="hljs-string">'x'</span></span>) <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.round(buf.length / (<span class="hljs-number"><span class="hljs-number">1024</span></span> * <span class="hljs-number"><span class="hljs-number">1024</span></span>))) <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.round(process.memoryUsage().rss / (<span class="hljs-number"><span class="hljs-number">1024</span></span> * <span class="hljs-number"><span class="hljs-number">1024</span></span>)))</code> </pre> <br>  Führen Sie diesmal den Container aus und richten Sie die Funktionen für die Arbeit mit der Auslagerungsdatei explizit ein: <br><br><pre> <code class="javascript hljs">docker run --memory <span class="hljs-number"><span class="hljs-number">1024</span></span>m --memory-swap=<span class="hljs-number"><span class="hljs-number">1024</span></span>m --memory-swappiness=<span class="hljs-number"><span class="hljs-number">0</span></span> --interactive --tty ravali1906/dockermemory bash</code> </pre> <br>  Starten Sie die Anwendung: <br><br><pre> <code class="javascript hljs">$ node buffer_example_fill.js <span class="hljs-number"><span class="hljs-number">2000</span></span> Killed</code> </pre> <br>  Siehe die Nachricht <code>Killed</code> ?  Wenn der Schlüsselwert <code>--memory-swap</code> gleich dem Schlüsselwert <code>--memory</code> , teilt dies dem Container mit, dass die <code>--memory</code> nicht verwendet werden soll.  Darüber hinaus kann der Kernel des Betriebssystems, in dem der Container selbst ausgeführt wird, standardmäßig eine bestimmte Anzahl anonymer Speicherseiten, die vom Container verwendet werden, in die Auslagerungsdatei kopieren.  <code>--memory-swappiness</code> auf <code>0</code> deaktivieren wir diese Funktion.  Infolgedessen stellt sich heraus, dass die Auslagerungsdatei nicht im Container verwendet wird.  Der Prozess endet, wenn die RSS-Metrik das Speicherlimit des Containers überschreitet. <br><br><h2>  <font color="#3AC1EF">Allgemeine Empfehlungen</font> </h2><br>  Wenn Node.js-Anwendungen mit dem <code>--max-old-space-size</code> gestartet werden, dessen Wert das beim <code>--max-old-space-size</code> des Containers festgelegte Speicherlimit überschreitet, scheint es, dass Node.js das Containerlimit nicht beachtet.  Wie aus den vorherigen Beispielen hervorgeht, ist der offensichtliche Grund für dieses Verhalten die Tatsache, dass die Anwendung einfach nicht das gesamte Heap-Volume verwendet, das mit dem <code>--max-old-space-size</code> . <br><br>  Denken Sie daran, dass sich die Anwendung nicht immer gleich verhält, wenn sie mehr Speicher verwendet, als im Container verfügbar ist.  Warum?  Tatsache ist, dass der aktive Speicher (RSS) des Prozesses von vielen externen Faktoren beeinflusst wird, die die Anwendung selbst nicht beeinflussen kann.  Sie hängen von der Belastung des Systems und den Eigenschaften der Umgebung ab.  Dies sind beispielsweise Funktionen der Anwendung selbst, der Grad der Parallelität im System, Funktionen des Betriebssystem-Schedulers, Funktionen des Garbage Collector usw.  Darüber hinaus können sich diese Faktoren von Start zu Start ändern. <br><br><h2>  <font color="#3AC1EF">Empfehlungen zum Festlegen der Größe des Node.js-Heaps für Fälle, in denen Sie diese Option steuern können, jedoch nicht mit Speicherbeschränkungen auf Containerebene</font> </h2><br><ul><li>  Führen Sie die minimale Node.js-Anwendung im Container aus und messen Sie die statische RSS-Größe (in meinem Fall sind dies für Node.js 10.x etwa 20 MB). </li><li>  Der Node.js-Heap enthält nicht nur den alten_Space, sondern auch andere (z. B. den neuen_Space, den Code_Space usw.).  Wenn Sie die Standardkonfiguration der Plattform berücksichtigen, sollten Sie sich daher darauf verlassen, dass das Programm etwa 20 MB mehr Speicher benötigt.  Wenn sich die Standardeinstellungen geändert haben, müssen diese Änderungen ebenfalls berücksichtigt werden. </li><li>  Jetzt müssen wir den erhaltenen Wert (angenommen, er beträgt 40 MB) von der im Container verfügbaren Speichermenge subtrahieren.  Was bleibt, ist ein Wert, der ohne Angst vor einer Programmausführung aufgrund von Speichermangel als Schlüsselwert angegeben werden kann - <code>--max-old-space-size</code> . </li></ul><br><h2>  <font color="#3AC1EF">Empfehlungen zum Festlegen von Containerspeichergrenzen für Fälle, in denen dieser Parameter gesteuert werden kann, die Anwendungsparameter von Node.j jedoch nicht</font> </h2><br><ul><li>  Führen Sie die Anwendung in Modi aus, mit denen Sie die Spitzenwerte des von ihr verbrauchten Speichers ermitteln können. </li><li>  Analysieren Sie den RSS-Score.  Insbesondere hier kann zusammen mit der Methode <code>process.memoryUsage()</code> der Linux-Befehl <code>top</code> nützlich sein. </li><li>  Vorausgesetzt, dass in dem Container, in dem die Anwendung ausgeführt werden soll, nichts anderes als die Ausführung ausgeführt wird, kann der erhaltene Wert als Container-Speicherlimit verwendet werden.  Um sicher zu gehen, wird empfohlen, diese um mindestens 10% zu erhöhen. </li></ul><br><h2>  <font color="#3AC1EF">Zusammenfassung</font> </h2><br>  In Node.js 12.x werden einige der hier diskutierten Probleme gelöst, indem die Größe des Heaps adaptiv angepasst wird, was entsprechend der Menge des verfügbaren RAM durchgeführt wird.  Dieser Mechanismus funktioniert auch, wenn Node.js-Anwendungen in Containern ausgeführt werden.  Die Einstellungen können jedoch von den Standardeinstellungen abweichen.  Dies ist beispielsweise der <code>--max_old_space_size</code> , wenn beim Starten der Anwendung der Schlüssel <code>--max_old_space_size</code> verwendet wurde.  Für solche Fälle bleibt alles oben Genannte relevant.  Dies legt nahe, dass jeder, der Node.js-Anwendungen in Containern ausführt, vorsichtig und verantwortungsbewusst mit den Speichereinstellungen umgehen sollte.  Darüber hinaus kann die Kenntnis der Standardbeschränkungen für die Speichernutzung, die eher konservativ ist, die Anwendungsleistung verbessern, indem diese Beschränkungen absichtlich geändert werden. <br><br>  <b>Liebe Leser!</b>  Haben Sie nicht genügend Speicherprobleme, wenn Sie Node.js-Anwendungen in Docker-Containern ausführen? <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/getpro/habr/post_images/a09/9e4/5a8/a099e45a81c9dafd3a3673edd5ea415b.jpg"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de454522/">https://habr.com/ru/post/de454522/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de454512/index.html">Frühstücksbericht mit Charles Weatherly, Autor des Kultbuchs Etudes for Programmers</a></li>
<li><a href="../de454514/index.html">Entwicklung eines einfachen Musiksynthesizers auf ATMEGA8</a></li>
<li><a href="../de454516/index.html">Wie man guten Text für 200 Rubel bekommt</a></li>
<li><a href="../de454518/index.html">Wasmer: Die schnellste Go-Bibliothek zum Ausführen von WebAssembly-Code</a></li>
<li><a href="../de454520/index.html">Richtlinien zum Schreiben von sauberem JavaScript-Code</a></li>
<li><a href="../de454524/index.html">Reparatur von Stirnbändern Samsung Level On Pro</a></li>
<li><a href="../de454530/index.html">DJI hat einen Oktokopter entwickelt, der Filme machen kann</a></li>
<li><a href="../de454532/index.html">Ich werde ein Wort über den technischen Ansatz sagen</a></li>
<li><a href="../de454534/index.html">Unwissenschaftlich über Monaden</a></li>
<li><a href="../de454536/index.html">Verstärker zum klassischen Herzfrequenzsensor</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>