<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§≥üèª ü§ΩüèΩ üë≥ Node.js: Verwalten des Speichers, der f√ºr Anwendungen verf√ºgbar ist, die in Containern ausgef√ºhrt werden üé£ üìÉ üßíüèΩ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Beim Ausf√ºhren von Node.js-Anwendungen in Docker-Containern funktionieren herk√∂mmliche Speichereinstellungen nicht immer wie erwartet. Das Material, d...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Node.js: Verwalten des Speichers, der f√ºr Anwendungen verf√ºgbar ist, die in Containern ausgef√ºhrt werden</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/454522/">  Beim Ausf√ºhren von Node.js-Anwendungen in Docker-Containern funktionieren herk√∂mmliche Speichereinstellungen nicht immer wie erwartet.  Das Material, dessen √úbersetzung wir heute ver√∂ffentlichen, ist darauf ausgerichtet, die Antwort auf die Frage zu finden, warum dies so ist.  Es enth√§lt auch praktische Empfehlungen zum Verwalten des Speichers, der f√ºr Node.js-Anwendungen verf√ºgbar ist, die in Containern ausgef√ºhrt werden. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/webt/9_/rp/-s/9_rp-s7libv7ncp6mubs2h_qjzu.png"></a> <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">√úberpr√ºfung der Empfehlungen</font> </h2><br>  Angenommen, eine Node.js-Anwendung wird in einem Container mit einem festgelegten Speicherlimit ausgef√ºhrt.  Wenn es sich um Docker handelt, kann die Option <code>--memory</code> verwendet werden, um dieses Limit <code>--memory</code> .  √Ñhnliches ist bei der Arbeit mit Container-Orchestrierungssystemen m√∂glich.  In diesem Fall wird empfohlen, beim Starten der Anwendung Node.js die <code>--max-old-space-size</code> .  Auf diese Weise k√∂nnen Sie die Plattform dar√ºber informieren, wie viel Speicher f√ºr sie verf√ºgbar ist, und auch ber√ºcksichtigen, dass diese Menge unter dem auf Containerebene festgelegten Grenzwert liegen sollte. <br><br>  Wenn die Anwendung Node.js im Container ausgef√ºhrt wird, legen Sie die Kapazit√§t des verf√ºgbaren Speichers entsprechend dem Spitzenwert der von der Anwendung verwendeten aktiven Speichermenge fest.  Dies erfolgt, wenn die Container-Speichergrenzen konfiguriert werden k√∂nnen. <br><br>  Lassen Sie uns nun n√§her auf das Problem der Verwendung von Speicher in Containern eingehen. <br><br><h2>  <font color="#3AC1EF">Docker-Speicherlimit</font> </h2><br>  Standardm√§√üig haben Container keine Ressourcenbeschr√§nkungen und k√∂nnen so viel Speicher verwenden, wie das Betriebssystem zul√§sst.  Der <code>docker run</code> Befehl <code>docker run</code> verf√ºgt √ºber Befehlszeilenoptionen, mit denen Sie Grenzwerte f√ºr die Speichernutzung oder die Prozessorressourcen festlegen k√∂nnen. <br><br>  Der Befehl zum Starten des Containers k√∂nnte folgenderma√üen aussehen: <br><br><pre> <code class="javascript hljs">docker run --memory &lt;x&gt;&lt;y&gt; --interactive --tty &lt;imagename&gt; bash</code> </pre> <br>  Bitte beachten Sie Folgendes: <br><br><ul><li>  <code>x</code> ist die Grenze der dem Container zur Verf√ºgung stehenden Speichermenge, ausgedr√ºckt in Einheiten von <code>y</code> . </li><li>  <code>y</code> kann den Wert <code>b</code> (Bytes), <code>k</code> (Kilobyte), <code>m</code> (Megabyte), <code>g</code> (Gigabyte) annehmen. </li></ul><br>  Hier ist ein Beispiel f√ºr einen Container-Startbefehl: <br><br><pre> <code class="javascript hljs">docker run --memory <span class="hljs-number"><span class="hljs-number">1000000</span></span>b --interactive --tty &lt;imagename&gt; bash</code> </pre> <br>  Hier ist das Speicherlimit auf <code>1000000</code> Bytes festgelegt. <br><br>  Um das auf Containerebene festgelegte Speicherlimit zu √ºberpr√ºfen, k√∂nnen Sie im Container den folgenden Befehl ausf√ºhren: <br><br><pre> <code class="javascript hljs">cat /sys/fs/cgroup/memory/memory.limit_in_bytes</code> </pre> <br>  Lassen Sie uns √ºber das Verhalten des Systems sprechen, wenn Sie das Speicherlimit f√ºr die Anwendung Node.js mit dem <code>--max-old-space-size</code> .  In diesem Fall entspricht dieses Speicherlimit dem auf Containerebene festgelegten Limit. <br><br>  Was im Schl√ºsselnamen als "alter Raum" bezeichnet wird, ist eines der Fragmente des von V8 kontrollierten Heaps (der Ort, an dem die "alten" JavaScript-Objekte platziert werden).  Diese Taste steuert die maximale Heap-Gr√∂√üe, wenn Sie nicht auf die Details eingehen, die wir unten ber√ºhren.  Details zu den Befehlszeilenschaltern von Node.j finden Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> . <br><br>  Wenn eine Anwendung versucht, mehr Speicher zu verwenden, als im Container verf√ºgbar ist, wird ihr Betrieb im Allgemeinen beendet. <br><br>  Im folgenden Beispiel (die Anwendungsdatei hei√üt <code>test-fatal-error.js</code> ) werden <code>MyRecord</code> Objekte im Abstand von 10 Millisekunden in das <code>test-fatal-error.js</code> <code>MyRecord</code> .  Dies f√ºhrt zu einem unkontrollierten Heap-Wachstum, das einen Speicherverlust simuliert. <br><br><pre> <code class="javascript hljs"><span class="hljs-meta"><span class="hljs-meta">'use strict'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> list = []; setInterval(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">=&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> record = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MyRecord(); list.push(record); },<span class="hljs-number"><span class="hljs-number">10</span></span>); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MyRecord</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> x=<span class="hljs-string"><span class="hljs-string">'hii'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.name = x.repeat(<span class="hljs-number"><span class="hljs-number">10000000</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.id = x.repeat(<span class="hljs-number"><span class="hljs-number">10000000</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.account = x.repeat(<span class="hljs-number"><span class="hljs-number">10000000</span></span>); } setInterval(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">=&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(process.memoryUsage()) },<span class="hljs-number"><span class="hljs-number">100</span></span>);</code> </pre> <br>  Bitte beachten Sie, dass alle Beispiele f√ºr Programme, die wir hier diskutieren werden, im Docker-Image enthalten sind, das vom Docker Hub heruntergeladen werden kann: <br><br><pre> <code class="javascript hljs">docker pull ravali1906/dockermemory</code> </pre> <br>  Sie k√∂nnen dieses Bild f√ºr unabh√§ngige Experimente verwenden. <br><br>  Dar√ºber hinaus k√∂nnen Sie die Anwendung in einen Docker-Container packen, das Image sammeln und mit dem Speicherlimit ausf√ºhren: <br><br><pre> <code class="javascript hljs">docker run --memory <span class="hljs-number"><span class="hljs-number">512</span></span>m --interactive --tty ravali1906/dockermemory bash</code> </pre> <br>  Hier ist <code>ravali1906/dockermemory</code> der Name des Bildes. <br><br>  Jetzt k√∂nnen Sie die Anwendung starten, indem Sie ein Speicherlimit angeben, das das Containerlimit √ºberschreitet: <br><br><pre> <code class="javascript hljs">$ node --max_old_space_size=<span class="hljs-number"><span class="hljs-number">1024</span></span> test-fatal-error.js { <span class="hljs-attr"><span class="hljs-attr">rss</span></span>: <span class="hljs-number"><span class="hljs-number">550498304</span></span>, <span class="hljs-attr"><span class="hljs-attr">heapTotal</span></span>: <span class="hljs-number"><span class="hljs-number">1090719744</span></span>, <span class="hljs-attr"><span class="hljs-attr">heapUsed</span></span>: <span class="hljs-number"><span class="hljs-number">1030627104</span></span>, <span class="hljs-attr"><span class="hljs-attr">external</span></span>: <span class="hljs-number"><span class="hljs-number">8272</span></span> } Killed</code> </pre> <br>  Hier repr√§sentiert der <code>--max_old_space_size</code> das in Megabyte angegebene Speicherlimit.  Die Methode <code>process.memoryUsage()</code> gibt Auskunft √ºber die Speichernutzung.  Die Werte werden in Bytes ausgedr√ºckt. <br><br>  Die Anwendung wird zu einem bestimmten Zeitpunkt zwangsweise beendet.  Dies geschieht, wenn die von ihm verwendete Speichermenge eine bestimmte Grenze √ºberschreitet.  Was ist diese Grenze?  √úber welche Einschr√§nkungen der Speichermenge k√∂nnen wir sprechen? <br><br><h2>  <font color="#3AC1EF">Das erwartete Verhalten einer Anwendung, die mit dem Schl√ºssel ausgef√ºhrt wird, ist - max-old-space-size</font> </h2><br>  Standardm√§√üig betr√§gt die maximale Heap-Gr√∂√üe in Node.js (bis Version 11.x) 700 MB auf 32-Bit-Plattformen und 1400 MB auf 64-Bit-Plattformen.  Informationen zum Einstellen dieser Werte finden Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> . <br><br>  Wenn Sie <code>--max-old-space-size</code> Schl√ºssel <code>--max-old-space-size</code> , <code>--max-old-space-size</code> Speicherlimit <code>--max-old-space-size</code> , das das Container-Speicherlimit √ºberschreitet, k√∂nnen Sie davon ausgehen, dass die Anwendung durch den Kernel-Sicherheitsmechanismus des Linux OOM Killer-Kernels beendet wird. <br><br>  In Wirklichkeit kann dies nicht passieren. <br><br><h2>  <font color="#3AC1EF">Das tats√§chliche Verhalten der Anwendung, die mit dem Schl√ºssel ausgef√ºhrt wird, ist max-old-space-size</font> </h2><br>  Die Anwendung weist unmittelbar nach dem Start nicht den gesamten Speicher zu, dessen Begrenzung mit <code>--max-old-space-size</code> .  Die Gr√∂√üe des JavaScript-Heaps h√§ngt von den Anforderungen der Anwendung ab.  Sie k√∂nnen anhand des Werts des <code>heapUsed</code> aus dem von der Methode <code>heapUsed</code> <code>process.memoryUsage()</code> Objekt beurteilen, wie viel Speicher die Anwendung verwendet.  Tats√§chlich handelt es sich um den im Heap f√ºr Objekte zugewiesenen Speicher. <br><br>  Infolgedessen schlie√üen wir, dass die Anwendung zwangsweise beendet wird, wenn die Heap-Gr√∂√üe gr√∂√üer ist als der durch den Schl√ºssel <code>--memory</code> festgelegte Grenzwert, wenn der Container <code>--memory</code> . <br><br>  Aber in Wirklichkeit kann dies auch nicht passieren. <br><br>  Bei der Profilerstellung f√ºr ressourcenintensive Node.js-Anwendungen, die in Containern mit einem bestimmten Speicherlimit ausgef√ºhrt werden, k√∂nnen die folgenden Muster beobachtet werden: <br><br><ol><li>  OOM Killer wird viel sp√§ter ausgel√∂st als in dem Moment, in dem die <code>heapUsed</code> <code>heapTotal</code> und <code>heapUsed</code> deutlich √ºber den Speichergrenzen liegen. </li><li>  OOM Killer reagiert nicht auf das √úberschreiten von Grenzwerten. </li></ol><br><h2>  <font color="#3AC1EF">Eine Erkl√§rung des Verhaltens von Node.js-Anwendungen in Containern</font> </h2><br>  Ein Container √ºberwacht einen wichtigen Indikator f√ºr die Anwendungen, die auf ihm ausgef√ºhrt werden.  Dies ist <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">RSS</a> (Resident Set Size).  Dieser Indikator repr√§sentiert einen bestimmten Teil des virtuellen Speichers der Anwendung. <br><br>  Dar√ºber hinaus ist es ein Speicher, der der Anwendung zugewiesen wird. <br><br>  Das ist aber noch nicht alles.  RSS ist Teil des aktiven Speichers, der der Anwendung zugewiesen ist. <br><br>  M√∂glicherweise ist nicht der gesamte einer Anwendung zugewiesene Speicher aktiv.  Tatsache ist, dass ‚Äûzugewiesener Speicher‚Äú nicht unbedingt physisch zugewiesen wird, bis der Prozess beginnt, ihn wirklich zu verwenden.  Dar√ºber hinaus kann das Betriebssystem als Antwort auf Anforderungen zur Speicherzuweisung von anderen Prozessen inaktive Teile des Anwendungsspeichers in die Auslagerungsdatei kopieren und den freigegebenen Speicherplatz an andere Prozesse √ºbertragen.  Wenn die Anwendung diese Speicherelemente erneut ben√∂tigt, werden sie aus der Auslagerungsdatei entnommen und in den physischen Speicher zur√ºckgef√ºhrt. <br><br>  Die RSS-Metrik gibt die Menge des aktiven und verf√ºgbaren Speichers f√ºr die Anwendung in ihrem Adressraum an.  Er beeinflusst die Entscheidung √ºber das erzwungene Herunterfahren der Anwendung. <br><br><h2>  <font color="#3AC1EF">Beweise</font> </h2><br><h3>  <font color="#3AC1EF">‚ñç Beispiel Nr. 1.</font>  <font color="#3AC1EF">Eine Anwendung, die Speicher f√ºr einen Puffer reserviert</font> </h3><br>  Das folgende Beispiel, <code>buffer_example.js</code> , zeigt ein Programm, das Speicher f√ºr einen Puffer reserviert: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> buf = Buffer.alloc(+process.argv[<span class="hljs-number"><span class="hljs-number">2</span></span>] * <span class="hljs-number"><span class="hljs-number">1024</span></span> * <span class="hljs-number"><span class="hljs-number">1024</span></span>) <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.round(buf.length / (<span class="hljs-number"><span class="hljs-number">1024</span></span> * <span class="hljs-number"><span class="hljs-number">1024</span></span>))) <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.round(process.memoryUsage().rss / (<span class="hljs-number"><span class="hljs-number">1024</span></span> * <span class="hljs-number"><span class="hljs-number">1024</span></span>)))</code> </pre> <br>  F√ºhren Sie den Container zun√§chst mit dem folgenden Befehl aus, damit die vom Programm zugewiesene Speichermenge den beim Start des Containers festgelegten Grenzwert √ºberschreitet: <br><br><pre> <code class="javascript hljs">docker run --memory <span class="hljs-number"><span class="hljs-number">1024</span></span>m --interactive --tty ravali1906/dockermemory bash</code> </pre> <br>  F√ºhren Sie danach das Programm aus: <br><br><pre> <code class="javascript hljs">$ node buffer_example <span class="hljs-number"><span class="hljs-number">2000</span></span> <span class="hljs-number"><span class="hljs-number">2000</span></span> <span class="hljs-number"><span class="hljs-number">16</span></span></code> </pre> <br>  Wie Sie sehen, hat das System das Programm nicht abgeschlossen, obwohl der vom Programm zugewiesene Speicher das Containerlimit √ºberschreitet.  Dies geschah aufgrund der Tatsache, dass das Programm nicht mit dem gesamten zugewiesenen Speicher arbeitet.  RSS ist sehr klein und √ºberschreitet nicht das Container-Speicherlimit. <br><br><h3>  <font color="#3AC1EF">‚ñç Beispiel Nr. 2.</font>  <font color="#3AC1EF">Anwendung, die den Puffer mit Daten f√ºllt</font> </h3><br>  Im folgenden Beispiel, <code>buffer_example_fill.js</code> , wird der Speicher nicht nur zugewiesen, sondern auch mit Daten gef√ºllt: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> buf = Buffer.alloc(+process.argv[<span class="hljs-number"><span class="hljs-number">2</span></span>] * <span class="hljs-number"><span class="hljs-number">1024</span></span> * <span class="hljs-number"><span class="hljs-number">1024</span></span>,<span class="hljs-string"><span class="hljs-string">'x'</span></span>) <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.round(buf.length / (<span class="hljs-number"><span class="hljs-number">1024</span></span> * <span class="hljs-number"><span class="hljs-number">1024</span></span>))) <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.round(process.memoryUsage().rss / (<span class="hljs-number"><span class="hljs-number">1024</span></span> * <span class="hljs-number"><span class="hljs-number">1024</span></span>)))</code> </pre> <br>  F√ºhren Sie den Container aus: <br><br><pre> <code class="javascript hljs">docker run --memory <span class="hljs-number"><span class="hljs-number">1024</span></span>m --interactive --tty ravali1906/dockermemory bash</code> </pre> <br>  F√ºhren Sie danach die Anwendung aus: <br><br><pre> <code class="javascript hljs">$ node buffer_example_fill.js <span class="hljs-number"><span class="hljs-number">2000</span></span> <span class="hljs-number"><span class="hljs-number">2000</span></span> <span class="hljs-number"><span class="hljs-number">984</span></span></code> </pre> <br>  Anscheinend endet die Anwendung auch jetzt noch nicht!  Warum?  Tatsache ist, dass einige der alten Seiten im Prozessspeicher in die Auslagerungsdatei verschoben werden, wenn die Menge des aktiven Speichers den beim Starten des Containers festgelegten Grenzwert erreicht und in der Auslagerungsdatei Platz ist.  Der freigegebene Speicher wird f√ºr denselben Prozess verf√ºgbar gemacht.  Standardm√§√üig weist Docker der Auslagerungsdatei Speicherplatz zu, der dem mit dem Flag <code>--memory</code> festgelegten Speicherlimit <code>--memory</code> .  Vor diesem Hintergrund k√∂nnen wir sagen, dass der Prozess 2 GB Speicher hat - 1 GB im aktiven Speicher und 1 GB in der Auslagerungsdatei.  Das hei√üt, aufgrund der Tatsache, dass die Anwendung ihren eigenen Speicher verwenden kann, dessen Inhalt vor√ºbergehend in die Auslagerungsdatei verschoben wird, liegt die Gr√∂√üe des RSS-Index innerhalb des Containerlimits.  Infolgedessen funktioniert die Anwendung weiterhin. <br><br><h3>  <font color="#3AC1EF">‚ñç Beispiel Nr. 3.</font>  <font color="#3AC1EF">Eine Anwendung, die einen Puffer mit Daten f√ºllt, die in einem Container ausgef√ºhrt werden, der keine Auslagerungsdatei verwendet</font> </h3><br>  Hier ist der Code, mit dem wir hier experimentieren werden (dies ist dieselbe Datei <code>buffer_example_fill.js</code> ): <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> buf = Buffer.alloc(+process.argv[<span class="hljs-number"><span class="hljs-number">2</span></span>] * <span class="hljs-number"><span class="hljs-number">1024</span></span> * <span class="hljs-number"><span class="hljs-number">1024</span></span>,<span class="hljs-string"><span class="hljs-string">'x'</span></span>) <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.round(buf.length / (<span class="hljs-number"><span class="hljs-number">1024</span></span> * <span class="hljs-number"><span class="hljs-number">1024</span></span>))) <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.round(process.memoryUsage().rss / (<span class="hljs-number"><span class="hljs-number">1024</span></span> * <span class="hljs-number"><span class="hljs-number">1024</span></span>)))</code> </pre> <br>  F√ºhren Sie diesmal den Container aus und richten Sie die Funktionen f√ºr die Arbeit mit der Auslagerungsdatei explizit ein: <br><br><pre> <code class="javascript hljs">docker run --memory <span class="hljs-number"><span class="hljs-number">1024</span></span>m --memory-swap=<span class="hljs-number"><span class="hljs-number">1024</span></span>m --memory-swappiness=<span class="hljs-number"><span class="hljs-number">0</span></span> --interactive --tty ravali1906/dockermemory bash</code> </pre> <br>  Starten Sie die Anwendung: <br><br><pre> <code class="javascript hljs">$ node buffer_example_fill.js <span class="hljs-number"><span class="hljs-number">2000</span></span> Killed</code> </pre> <br>  Siehe die Nachricht <code>Killed</code> ?  Wenn der Schl√ºsselwert <code>--memory-swap</code> gleich dem Schl√ºsselwert <code>--memory</code> , teilt dies dem Container mit, dass die <code>--memory</code> nicht verwendet werden soll.  Dar√ºber hinaus kann der Kernel des Betriebssystems, in dem der Container selbst ausgef√ºhrt wird, standardm√§√üig eine bestimmte Anzahl anonymer Speicherseiten, die vom Container verwendet werden, in die Auslagerungsdatei kopieren.  <code>--memory-swappiness</code> auf <code>0</code> deaktivieren wir diese Funktion.  Infolgedessen stellt sich heraus, dass die Auslagerungsdatei nicht im Container verwendet wird.  Der Prozess endet, wenn die RSS-Metrik das Speicherlimit des Containers √ºberschreitet. <br><br><h2>  <font color="#3AC1EF">Allgemeine Empfehlungen</font> </h2><br>  Wenn Node.js-Anwendungen mit dem <code>--max-old-space-size</code> gestartet werden, dessen Wert das beim <code>--max-old-space-size</code> des Containers festgelegte Speicherlimit √ºberschreitet, scheint es, dass Node.js das Containerlimit nicht beachtet.  Wie aus den vorherigen Beispielen hervorgeht, ist der offensichtliche Grund f√ºr dieses Verhalten die Tatsache, dass die Anwendung einfach nicht das gesamte Heap-Volume verwendet, das mit dem <code>--max-old-space-size</code> . <br><br>  Denken Sie daran, dass sich die Anwendung nicht immer gleich verh√§lt, wenn sie mehr Speicher verwendet, als im Container verf√ºgbar ist.  Warum?  Tatsache ist, dass der aktive Speicher (RSS) des Prozesses von vielen externen Faktoren beeinflusst wird, die die Anwendung selbst nicht beeinflussen kann.  Sie h√§ngen von der Belastung des Systems und den Eigenschaften der Umgebung ab.  Dies sind beispielsweise Funktionen der Anwendung selbst, der Grad der Parallelit√§t im System, Funktionen des Betriebssystem-Schedulers, Funktionen des Garbage Collector usw.  Dar√ºber hinaus k√∂nnen sich diese Faktoren von Start zu Start √§ndern. <br><br><h2>  <font color="#3AC1EF">Empfehlungen zum Festlegen der Gr√∂√üe des Node.js-Heaps f√ºr F√§lle, in denen Sie diese Option steuern k√∂nnen, jedoch nicht mit Speicherbeschr√§nkungen auf Containerebene</font> </h2><br><ul><li>  F√ºhren Sie die minimale Node.js-Anwendung im Container aus und messen Sie die statische RSS-Gr√∂√üe (in meinem Fall sind dies f√ºr Node.js 10.x etwa 20 MB). </li><li>  Der Node.js-Heap enth√§lt nicht nur den alten_Space, sondern auch andere (z. B. den neuen_Space, den Code_Space usw.).  Wenn Sie die Standardkonfiguration der Plattform ber√ºcksichtigen, sollten Sie sich daher darauf verlassen, dass das Programm etwa 20 MB mehr Speicher ben√∂tigt.  Wenn sich die Standardeinstellungen ge√§ndert haben, m√ºssen diese √Ñnderungen ebenfalls ber√ºcksichtigt werden. </li><li>  Jetzt m√ºssen wir den erhaltenen Wert (angenommen, er betr√§gt 40 MB) von der im Container verf√ºgbaren Speichermenge subtrahieren.  Was bleibt, ist ein Wert, der ohne Angst vor einer Programmausf√ºhrung aufgrund von Speichermangel als Schl√ºsselwert angegeben werden kann - <code>--max-old-space-size</code> . </li></ul><br><h2>  <font color="#3AC1EF">Empfehlungen zum Festlegen von Containerspeichergrenzen f√ºr F√§lle, in denen dieser Parameter gesteuert werden kann, die Anwendungsparameter von Node.j jedoch nicht</font> </h2><br><ul><li>  F√ºhren Sie die Anwendung in Modi aus, mit denen Sie die Spitzenwerte des von ihr verbrauchten Speichers ermitteln k√∂nnen. </li><li>  Analysieren Sie den RSS-Score.  Insbesondere hier kann zusammen mit der Methode <code>process.memoryUsage()</code> der Linux-Befehl <code>top</code> n√ºtzlich sein. </li><li>  Vorausgesetzt, dass in dem Container, in dem die Anwendung ausgef√ºhrt werden soll, nichts anderes als die Ausf√ºhrung ausgef√ºhrt wird, kann der erhaltene Wert als Container-Speicherlimit verwendet werden.  Um sicher zu gehen, wird empfohlen, diese um mindestens 10% zu erh√∂hen. </li></ul><br><h2>  <font color="#3AC1EF">Zusammenfassung</font> </h2><br>  In Node.js 12.x werden einige der hier diskutierten Probleme gel√∂st, indem die Gr√∂√üe des Heaps adaptiv angepasst wird, was entsprechend der Menge des verf√ºgbaren RAM durchgef√ºhrt wird.  Dieser Mechanismus funktioniert auch, wenn Node.js-Anwendungen in Containern ausgef√ºhrt werden.  Die Einstellungen k√∂nnen jedoch von den Standardeinstellungen abweichen.  Dies ist beispielsweise der <code>--max_old_space_size</code> , wenn beim Starten der Anwendung der Schl√ºssel <code>--max_old_space_size</code> verwendet wurde.  F√ºr solche F√§lle bleibt alles oben Genannte relevant.  Dies legt nahe, dass jeder, der Node.js-Anwendungen in Containern ausf√ºhrt, vorsichtig und verantwortungsbewusst mit den Speichereinstellungen umgehen sollte.  Dar√ºber hinaus kann die Kenntnis der Standardbeschr√§nkungen f√ºr die Speichernutzung, die eher konservativ ist, die Anwendungsleistung verbessern, indem diese Beschr√§nkungen absichtlich ge√§ndert werden. <br><br>  <b>Liebe Leser!</b>  Haben Sie nicht gen√ºgend Speicherprobleme, wenn Sie Node.js-Anwendungen in Docker-Containern ausf√ºhren? <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/getpro/habr/post_images/a09/9e4/5a8/a099e45a81c9dafd3a3673edd5ea415b.jpg"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de454522/">https://habr.com/ru/post/de454522/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de454512/index.html">Fr√ºhst√ºcksbericht mit Charles Weatherly, Autor des Kultbuchs Etudes for Programmers</a></li>
<li><a href="../de454514/index.html">Entwicklung eines einfachen Musiksynthesizers auf ATMEGA8</a></li>
<li><a href="../de454516/index.html">Wie man guten Text f√ºr 200 Rubel bekommt</a></li>
<li><a href="../de454518/index.html">Wasmer: Die schnellste Go-Bibliothek zum Ausf√ºhren von WebAssembly-Code</a></li>
<li><a href="../de454520/index.html">Richtlinien zum Schreiben von sauberem JavaScript-Code</a></li>
<li><a href="../de454524/index.html">Reparatur von Stirnb√§ndern Samsung Level On Pro</a></li>
<li><a href="../de454530/index.html">DJI hat einen Oktokopter entwickelt, der Filme machen kann</a></li>
<li><a href="../de454532/index.html">Ich werde ein Wort √ºber den technischen Ansatz sagen</a></li>
<li><a href="../de454534/index.html">Unwissenschaftlich √ºber Monaden</a></li>
<li><a href="../de454536/index.html">Verst√§rker zum klassischen Herzfrequenzsensor</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>