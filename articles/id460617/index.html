<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🕴🏽 👩‍🏭 📩 Seluruh kebenaran tentang RTOS. Artikel # 30. Inisialisasi Nucleus SE dan Prosedur Memulai 👯 🧗🏾 🛵</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Sistem operasi apa pun memiliki mekanisme startup tertentu. Prinsip operasi mekanisme ini untuk setiap sistem berbeda. Biasanya mereka mengatakan bahw...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Seluruh kebenaran tentang RTOS. Artikel # 30. Inisialisasi Nucleus SE dan Prosedur Memulai</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/460617/"><img src="https://habrastorage.org/webt/nr/me/cz/nrmeczn3tg-kdwyme6qgmd7ily4.jpeg"><br><br>  Sistem operasi apa pun memiliki mekanisme startup tertentu.  Prinsip operasi mekanisme ini untuk setiap sistem berbeda.  Biasanya mereka mengatakan bahwa sistem melakukan boot (Eng. Boot), ini adalah singkatan untuk "bootstrap", yang mengacu pada ungkapan "tarik diri melalui pagar dengan tali sepatu seseorang" (untuk melewati pagar, menarik diri dengan tali pada sepatu), yang secara kasar menggambarkan bagaimana sistem bergerak secara independen dari keadaan di mana memori penuh kekosongan ( <i>kira-kira penerjemah: jika benar-benar akurat, maka sampah</i> ) ke eksekusi program yang stabil.  Secara tradisional, sebagian kecil dari program dimuat ke dalam memori, dapat disimpan dalam ROM.  Di masa lalu, itu bisa dimasukkan menggunakan sakelar di bagian depan komputer.  Bootloader ini membaca program boot yang lebih kompleks yang telah memuat sistem operasi.  Saat ini, komputer desktop melakukan booting sebagai berikut: kode BIOS mencari perangkat (hard drive, CD-ROM, stik USB) untuk boot, dan kemudian sistem operasi melakukan booting. <br><br>  OS untuk sistem tertanam juga dapat diinisialisasi dengan cara yang sama.  Dan pada kenyataannya, sistem operasi tertanam yang dikembangkan berdasarkan sistem operasi desktop dimuat.  Tetapi dalam kebanyakan RTOS "klasik", metode yang lebih sederhana (dan karena itu lebih cepat) digunakan. <br><a name="habracut"></a><br>  Sistem operasi adalah bagian dari perangkat lunak.  Jika perangkat lunak ini sudah ada dalam memori (misalnya, dalam satu atau beberapa bentuk ROM), maka Anda hanya perlu memastikan bahwa urutan perintah CPU setelah reset berakhir dengan eksekusi kode inisialisasi OS.  Begitulah cara kerja kebanyakan RTOS, termasuk Nucleus SE ( <i>catatan penerjemah: ini juga berlaku untuk <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">RTOS MAX kami</a></i> ). <br><br>  Sebagian besar alat pengembangan perangkat lunak tertanam mencakup kode startup yang diperlukan untuk menangani reset CPU dan mentransfer kontrol ke fungsi Entry Point di fungsi <b>utama ()</b> .  Nucleus SE redistributable code tidak berurusan dengan proses ini, karena harus se portable mungkin.  Sebaliknya, ini berisi fungsi <b>utama ()</b> , yang mengendalikan CPU dan menginisialisasi dan memulai OS.  Fitur ini akan dibahas secara rinci di bawah ini. <br><br><div class="spoiler">  <b class="spoiler_title">Artikel sebelumnya dalam seri:</b> <div class="spoiler_text">  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Artikel # 29.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Gangguan pada Nucleus SE</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Artikel # 28.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Pengatur waktu perangkat lunak</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Artikel # 27.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Waktu sistem</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Artikel # 26.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Saluran: layanan tambahan dan struktur data</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Artikel # 25.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Saluran Data: Pengantar dan Layanan Dasar</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Artikel # 24.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Antrian: layanan tambahan dan struktur data</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Artikel # 23.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Antrian: pengantar dan layanan dasar</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Artikel # 22.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Kotak Surat: Layanan Tambahan dan Struktur Data</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Artikel # 21.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Kotak Surat: Pengantar dan Layanan Dasar</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Artikel # 20.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Semaphores: Layanan Tambahan dan Struktur Data</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Artikel # 19.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Semaphores: pengantar dan layanan dasar</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Artikel # 18.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Grup Bendera Acara: Layanan Pembantu dan Struktur Data</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Artikel # 17.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Grup Bendera Acara: Pengantar dan Layanan Dasar</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Artikel # 16.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Sinyal</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Artikel # 15.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Partisi Memori: Layanan dan Struktur Data</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Artikel # 14.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian memori: pengantar dan layanan dasar</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Artikel # 13.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Struktur data tugas dan panggilan API yang tidak didukung</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Artikel # 12.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Layanan untuk bekerja dengan tugas</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Artikel # 11.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Tugas: konfigurasi dan pengantar API</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Artikel # 10.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Penjadwal: fitur canggih dan pelestarian konteks</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Artikel # 9.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Penjadwal: implementasi</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Artikel # 8.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Nucleus SE: Desain dan Penyebaran Internal</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Artikel # 7.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Nucleus SE: Pendahuluan</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Artikel # 6.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Layanan RTOS lainnya</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Artikel # 5.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Interaksi tugas dan sinkronisasi</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Artikel # 4.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Tugas, pengalihan konteks, dan interupsi</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Artikel # 3.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Tugas dan Perencanaan</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Artikel # 2.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">RTOS: Struktur dan mode waktu-nyata</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><br></a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Artikel # 1.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">RTOS: pengantar.</a> <br></div></div><br><h3>  Inisialisasi memori </h3><br>  Deklarasi semua variabel statis dalam kode SE Nucleus dimulai dengan awalan <b>ROM</b> atau <b>RAM</b> untuk menunjukkan di mana mereka seharusnya berada.  Dua arahan <b>#define</b> ini didefinisikan dalam file <b>nuse_types.h</b> dan harus dikonfigurasikan dengan mempertimbangkan spesifikasi dari set alat pengembangan yang digunakan (kompiler dan tautan).  Biasanya, <b>ROM</b> harus bertipe <b>const</b> ( <i>catatan penerjemah: dari pengalaman saya, <b>const</b> tidak selalu cukup, <b>statis</b> lebih baik</i> ), dan <b>RAM</b> adalah nilai kosong. <br><br>  Semua variabel <b>ROM</b> diinisialisasi secara statis, yang logis.  Variabel <b>RAM</b> tidak diinisialisasi secara statis (karena ini hanya bekerja dengan kotak peralatan tertentu yang dikonfigurasi untuk secara otomatis menyalin dari ROM ke RAM);  kode inisialisasi eksplisit termasuk dalam aplikasi dan akan dijelaskan secara rinci di bawah ini. <br><br>  Nucleus SE tidak menyimpan data "konstan" dalam RAM, yang biasanya kekurangan pasokan dalam sistem kecil.  Alih-alih menggunakan struktur data yang kompleks untuk menggambarkan objek kernel, set tabel (array) digunakan, yang mudah ditempatkan dalam ROM atau RAM, tergantung pada kebutuhan. <br><br><h2>  Fungsi utama () </h2><br>  Berikut ini adalah kode lengkap untuk fungsi <b>utama ()</b> dari Nucleus SE: <br><br><pre><code class="plaintext hljs">void main(void) { NUSE_Init(); /* initialize kernel data */ /* user initialization code here */ NUSE_Scheduler(); /* start tasks */ }</code> </pre> <br>  Urutan operasi ini cukup sederhana: <br><br><ul><li>  Pertama, fungsi <b>NUSE_Init () dipanggil</b> .  Ini menginisialisasi semua struktur data Nucleus SE dan akan dijelaskan secara rinci di bawah ini. </li><li>  Kemudian pengguna dapat memasukkan kode inisialisasi aplikasi apa pun yang akan dieksekusi sebelum penjadwal tugas dimulai.  Untuk informasi lebih lanjut tentang apa yang dapat dicapai dengan kode ini, lihat nanti dalam artikel ini. </li><li>  Akhirnya, penjadwal Nucleus SE ( <b>NUSE_Scheduler ()</b> ) dimulai.  Ini juga akan dibahas secara rinci nanti dalam artikel ini. </li></ul><br><h2>  Fungsi NUSE_Init () </h2><br>  Fungsi ini menginisialisasi semua variabel kernel Nucleus SE dan struktur data. <br><br><div class="spoiler">  <b class="spoiler_title">Di bawah ini adalah kode fungsi lengkap:</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">void NUSE_Init(void) { U8 index; /* global data */ NUSE_Task_Active = 0; NUSE_Task_State = NUSE_STARTUP_CONTEXT; #if NUSE_SYSTEM_TIME_SUPPORT NUSE_Tick_Clock = 0; #endif #if NUSE_SCHEDULER_TYPE == NUSE_TIME_SLICE_SCHEDULER NUSE_Time_Slice_Ticks = NUSE_TIME_SLICE_TICKS; #endif /* tasks */ #if ((NUSE_SCHEDULER_TYPE != NUSE_RUN_TO_COMPLETION_SCHEDULER) || NUSE_SIGNAL_SUPPORT || NUSE_TASK_SLEEP || NUSE_SUSPEND_ENABLE || NUSE_SCHEDULE_COUNT_SUPPORT) for (index=0; index&lt;NUSE_TASK_NUMBER; index++) { NUSE_Init_Task(index); } #endif /* partition pools */ #if NUSE_PARTITION_POOL_NUMBER != 0 for (index=0; index&lt;NUSE_PARTITION_POOL_NUMBER; index++) { NUSE_Init_Partition_Pool(index); } #endif /* mailboxes */ #if NUSE_MAILBOX_NUMBER != 0 for (index=0; index&lt;NUSE_MAILBOX_NUMBER; index++) { NUSE_Init_Mailbox(index); } #endif /* queues */ #if NUSE_QUEUE_NUMBER != 0 for (index=0; index&lt;NUSE_QUEUE_NUMBER; index++) { NUSE_Init_Queue(index); } #endif /* pipes */ #if NUSE_PIPE_NUMBER != 0 for (index=0; index&lt;NUSE_PIPE_NUMBER; index++) { NUSE_Init_Pipe(index); } #endif /* semaphores */ #if NUSE_SEMAPHORE_NUMBER != 0 for (index=0; index&lt;NUSE_SEMAPHORE_NUMBER; index++) { NUSE_Init_Semaphore(index); } #endif /* event groups */ #if NUSE_EVENT_GROUP_NUMBER != 0 for (index=0; index&lt;NUSE_EVENT_GROUP_NUMBER; index++) { NUSE_Init_Event_Group(index); } #endif /* timers */ #if NUSE_TIMER_NUMBER != 0 for (index=0; index&lt;NUSE_TIMER_NUMBER; index++) { NUSE_Init_Timer(index); } #endif }</code> </pre><br></div></div><br>  Pertama, variabel global diinisialisasi: <br><ul><li>  <b>NUSE_Task_Active</b> - indeks tugas aktif, diinisialisasi ke nol;  nanti ini dapat mengubah penjadwal. </li><li>  <b>NUSE_Task_State</b> - diinisialisasi dengan nilai <b>NUSE_STARTUP_CONTEXT</b> , yang membatasi fungsionalitas API untuk kode inisialisasi aplikasi berikutnya. </li><li>  Jika dukungan waktu sistem diaktifkan, <b>NUSE_Tick_Clock diatur</b> ke nol. </li><li>  Jika penjadwal Time Slice diaktifkan, <b>NUSE_Time_Slice_Ticks</b> diberi nilai yang dikonfigurasi <b>NUSE_TIME_SLICE_TICKS</b> . </li></ul><br>  Kemudian fungsi dipanggil untuk menginisialisasi objek kernel: <br><br><ul><li>  <b>NUSE_Init_Task ()</b> dipanggil untuk menginisialisasi struktur data setiap tugas.  Panggilan ini dilewati hanya jika penjadwal Run to Completion digunakan, dan sinyal, penghentian sementara tugas, dan penghitung penjadwalan tidak dikonfigurasi (karena kombinasi fungsi ini akan mengakibatkan tidak adanya struktur tugas ini dalam RAM, oleh karena itu, inisialisasi tidak akan dilakukan). </li><li>  <b>NUSE_Init_Partition_Pool ()</b> dipanggil untuk menginisialisasi setiap objek kumpulan partisi.  Panggilan ini dilewati jika tidak ada kumpulan partisi yang dikonfigurasi. </li><li>  <b>NUSE_Init_Mailbox ()</b> dipanggil untuk menginisialisasi setiap objek kotak surat.  Panggilan ini dilewati jika tidak ada kotak surat yang dikonfigurasi. </li><li>  <b>NUSE_Init_Queue ()</b> dipanggil untuk menginisialisasi setiap objek antrian.  Panggilan ini dilewati jika tidak ada antrian yang dikonfigurasi. </li><li>  <b>NUSE_Init_Pipe ()</b> dipanggil untuk menginisialisasi setiap objek saluran.  Panggilan ini dilewati jika tidak ada saluran yang dikonfigurasi. </li><li>  <b>NUSE_Init_Semaphore ()</b> dipanggil untuk menginisialisasi setiap objek semaphore.  Panggilan ini dilewati jika tidak ada semafor yang dikonfigurasi. </li><li>  <b>NUSE_Init_Event_Group ()</b> dipanggil untuk menginisialisasi setiap objek grup acara.  Panggilan ini dilewati jika tidak ada grup acara yang dikonfigurasi. </li><li>  <b>NUSE_Init_Timer ()</b> dipanggil untuk menginisialisasi setiap objek <b>pengatur</b> waktu.  Panggilan-panggilan ini dilewati jika tidak ada timer yang dikonfigurasi. </li></ul><br><h3>  Inisialisasi tugas </h3><br><div class="spoiler">  <b class="spoiler_title">Berikut ini adalah kode lengkap untuk fungsi NUSE_Init_Task ():</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">void NUSE_Init_Task(NUSE_TASK task) { #if NUSE_SCHEDULER_TYPE != NUSE_RUN_TO_COMPLETION_SCHEDULER NUSE_Task_Context[task][15] = /* SR */ NUSE_STATUS_REGISTER; NUSE_Task_Context[task][16] = /* PC */ NUSE_Task_Start_Address[task]; NUSE_Task_Context[task][17] = /* SP */ (U32 *)NUSE_Task_Stack_Base[task] + NUSE_Task_Stack_Size[task]; #endif #if NUSE_SIGNAL_SUPPORT || NUSE_INCLUDE_EVERYTHING NUSE_Task_Signal_Flags[task] = 0; #endif #if NUSE_TASK_SLEEP || NUSE_INCLUDE_EVERYTHING NUSE_Task_Timeout_Counter[task] = 0; #endif #if NUSE_SUSPEND_ENABLE || NUSE_INCLUDE_EVERYTHING #if NUSE_INITIAL_TASK_STATE_SUPPORT || NUSE_INCLUDE_EVERYTHING NUSE_Task_Status[task] = NUSE_Task_Initial_State[task]; #else NUSE_Task_Status[task] = NUSE_READY; #endif #endif #if NUSE_SCHEDULE_COUNT_SUPPORT || NUSE_INCLUDE_EVERYTHING NUSE_Task_Schedule_Count[task] = 0; #endif }</code> </pre><br></div></div><br>  Jika penjadwal Run to Completion belum dikonfigurasi, blok konteks untuk <b>tugas NUSE_Task_Context [task] []</b> diinisialisasi.  Sebagian besar elemen bukan nilai yang ditetapkan, karena mereka mewakili register mesin yang umum, yang seharusnya memiliki nilai menengah ketika memulai tugas.  Dalam contoh (Freescale ColdFire) dari implementasi Nucleus SE (tetapi untuk prosesor lainnya mekanismenya akan serupa) tiga entri terakhir diatur secara eksplisit: <br><br><ul><li>  <b>NUSE_Task_Context [task] [15]</b> berisi register status ( <b>SR</b> , register status) dan memiliki nilai arahan <b>#define NUSE_STATUS_REGISTER</b> . </li><li>  <b>NUSE_Task_Context [task] [16]</b> berisi penghitung program ( <b>PC</b> , penghitung program) dan memiliki nilai alamat dari titik input dari kode tugas: <b>NUSE_Task_Start_Address [task]</b> . </li><li>  <b>NUSE_Task_Context [task] [17]</b> berisi penunjuk tumpukan ( <b>SP</b> , penunjuk tumpukan) dan diinisialisasi dengan nilai yang dihitung sebagai jumlah alamat dari tumpukan tugas ( <b>NUSE_Task_Stack_Base [tugas]</b> ) dan ukuran tumpukan tugas ( <b>NUSE_Task_Stack_Size [tugas]</b> ). </li></ul><br>  Jika dukungan sinyal diaktifkan, tanda sinyal tugas ( <b>NUSE_Task_Signal_Flags [tugas]</b> ) diatur ke nol. <br><br>  Jika penangguhan tugas diaktifkan (yaitu, panggilan layanan API <b>NUSE_Task_Sleep ()</b> ), penghitung waktu tunggu tugas ( <b>NUSE_Task_Timeout_Counter [tugas]</b> ) diatur ke nol. <br><br>  Jika status penundaan tugas diaktifkan, status tugas ( <b>NUSE_Task_Status [tugas]</b> ) diinisialisasi.  Nilai awal ini ditetapkan oleh pengguna (dalam <b>NUSE_Task_Initial_State [tugas]</b> ) jika dukungan untuk keadaan awal tugas diaktifkan.  Jika tidak, status akan ditetapkan ke <b>NUSE_READY</b> . <br><br>  Jika penghitung perencanaan diaktifkan, penghitung tugas ( <b>NUSE_Task_Schedule_Count [tugas]</b> ) disetel ke nol. <br><br><h3>  Menginisialisasi Pools Partisi </h3><br>  Berikut ini adalah kode lengkap untuk fungsi <b>NUSE_Init_Partition_Pool ()</b> : <br><br><pre> <code class="plaintext hljs">void NUSE_Init_Partition_Pool(NUSE_PARTITION_POOL pool) { NUSE_Partition_Pool_Partition_Used[pool] = 0; #if NUSE_BLOCKING_ENABLE NUSE_Partition_Pool_Blocking_Count[pool] = 0; #endif }</code> </pre><br>  Penghitung kumpulan partisi "bekas" ( <b>NUSE_Partition_Pool__Partition_Used [pool]</b> ) disetel ke nol. <br><br>  Jika kunci tugas diaktifkan, penghitung tugas yang diblokir dari kumpulan partisi ( <b>NUSE_Partition_Pool_Blocking_Count [pool]) disetel</b> ke nol. <br><br><h3>  Inisialisasi Kotak Surat </h3><br>  Di bawah ini adalah kode <b>NUSE_Init_Mailbox () lengkap</b> : <br><br><pre> <code class="plaintext hljs">void NUSE_Init_Mailbox(NUSE_MAILBOX mailbox) { NUSE_Mailbox_Data[mailbox] = 0; NUSE_Mailbox_Status[mailbox] = 0; #if NUSE_BLOCKING_ENABLE NUSE_Mailbox_Blocking_Count[mailbox] = 0; #endif }</code> </pre><br>  <b>Penyimpanan</b> data kotak surat ( <b>NUSE_Mailbox_Data [mailbox]</b> ) diatur ke nol, dan status ( <b>NUSE_Mailbox_Status [mailbox]</b> ) menjadi "tidak digunakan" (yaitu, nol). <br><br>  Jika penguncian tugas diaktifkan, penghitung tugas kotak surat yang diblokir ( <b>NUSE_Mailbox_Blocking_Count [kotak surat]</b> ) diatur ke nol. <br><br><h3>  Inisialisasi antrian </h3><br>  Berikut ini adalah kode lengkap untuk fungsi <b>NUSE_Init_Queue ()</b> : <br><br><pre> <code class="plaintext hljs">void NUSE_Init_Queue(NUSE_QUEUE queue) { NUSE_Queue_Head[queue] = 0; NUSE_Queue_Tail[queue] = 0; NUSE_Queue_Items[queue] = 0; #if NUSE_BLOCKING_ENABLE NUSE_Queue_Blocking_Count[queue] = 0; #endif }</code> </pre><br>  Pointer ke awal dan akhir antrian (pada kenyataannya, ini adalah indeks <b>NUSE_Queue_Head [queue</b> ] dan <b>NUSE_Queue_Tail [queue]</b> ) diberi nilai yang menunjukkan awal dari area data antrian (yaitu, mereka mengambil nilai nol).  Penghitung dalam antrian ( <b>NUSE_Queue_Items [antrian]</b> ) juga disetel ke nol. <br><br>  Jika penguncian tugas diaktifkan, penghitung tugas antrian yang diblokir ( <b>NUSE_Queue_Blocking_Count [antrian]</b> ) diatur ke nol. <br><br><h3>  Inisialisasi saluran </h3><br>  Berikut ini adalah kode lengkap untuk fungsi <b>NUSE_Init_Pipe ()</b> : <br><br><pre> <code class="plaintext hljs">void NUSE_Init_Pipe(NUSE_PIPE pipe) { NUSE_Pipe_Head[pipe] = 0; NUSE_Pipe_Tail[pipe] = 0; NUSE_Pipe_Items[pipe] = 0; #if NUSE_BLOCKING_ENABLE NUSE_Pipe_Blocking_Count[pipe] = 0; #endif }</code> </pre><br>  Pointer ke awal dan akhir saluran (pada kenyataannya, ini adalah indeks - <b>NUSE_Pipe_Head [pipe]</b> dan <b>NUSE_Pipe_Tail [pipe]</b> ) diberi nilai yang menunjukkan awal dari area data saluran (yaitu, mereka mengambil nilai nol).  <b>Penghitung</b> saluran ( <b>NUSE_Pipe_Items [pipe]</b> ) juga disetel ke nol. <br><br>  Jika penguncian tugas diaktifkan, penghitung tugas saluran yang diblokir ( <b>NUSE_Pipe_Blocking_Count [pipa]</b> ) disetel ke nol. <br><br><h3>  Inisialisasi semaphore </h3><br>  Berikut ini adalah kode lengkap untuk fungsi <b>NUSE_Init_Semaphore ()</b> : <br><br><pre> <code class="plaintext hljs">void NUSE_Init_Semaphore(NUSE_SEMAPHORE semaphore) { NUSE_Semaphore_Counter[semaphore] = NUSE_Semaphore_Initial_Value[semaphore]; #if NUSE_BLOCKING_ENABLE NUSE_Semaphore_Blocking_Count[semaphore] = 0; #endif }</code> </pre><br>  Penghitung semaphore ( <b>NUSE_Semaphore_Counter [semaphore]</b> ) diinisialisasi dengan nilai yang ditetapkan oleh pengguna ( <b>NUSE_Semaphore_Initial_Value [semaphore]</b> ). <br><br>  Jika penguncian tugas diaktifkan, penghitung tugas semafor yang dikunci ( <b>NUSE_Semaphore_Blocking_Count [semaphore]</b> ) disetel ke nol. <br><br><h3>  Menginisialisasi Grup Acara </h3><br>  Berikut ini adalah kode lengkap untuk fungsi <b>NUSE_Init_Event_Group ()</b> : <br><br><pre> <code class="plaintext hljs">void NUSE_Init_Event_Group(NUSE_EVENT_GROUP group) { NUSE_Event_Group_Data[group] = 0; #if NUSE_BLOCKING_ENABLE NUSE_Event_Group_Blocking_Count[group] = 0; #endif }</code> </pre><br>  Bendera grup acara diatur ulang, mis.  <b>NUSE_Event_Group_Data [grup]</b> diberi nilai nol. <br><br>  Jika penguncian tugas diaktifkan, penghitung tugas yang diblokir dari grup bendera acara ( <b>NUSE_Event_Group_Blocking_Count [grup]</b> ) disetel ke nol. <br><br><h3>  Timer Inisialisasi </h3><br>  Di bawah ini adalah kode lengkap <b>NUSE_Init_Timer ()</b> ; <br><br><pre> <code class="plaintext hljs">void NUSE_Init_Timer(NUSE_TIMER timer) { NUSE_Timer_Status[timer] = FALSE; NUSE_Timer_Value[timer] = NUSE_Timer_Initial_Time[timer]; NUSE_Timer_Expirations_Counter[timer] = 0; }</code> </pre><br>  Keadaan timer ( <b>NUSE_Timer_Status [timer]</b> ) diatur ke "tidak digunakan", mis.  <b>SALAH</b> <br><br>  Nilai hitung mundur ( <b>NUSE_Timer_Value [timer</b> ]) diinisialisasi oleh nilai yang ditetapkan oleh pengguna ( <b>NUSE_Timer_Initial_Time [timer]</b> ). <br><br>  Penghitung penyelesaian ( <b>NUSE_Timer_Expirations_Counter [timer]</b> ) disetel ke nol. <br><br><h2>  Menginisialisasi Kode Aplikasi </h2><br>  Setelah struktur data Inti N telah diinisialisasi, menjadi mungkin untuk mengeksekusi kode yang bertanggung jawab untuk menginisialisasi aplikasi sebelum memulai tugas.  Fitur ini mungkin berguna untuk tugas-tugas berikut: <br><br><ul><li>  Inisialisasi struktur data aplikasi.  Pengisian eksplisit struktur data lebih mudah dipahami dan didebug dibandingkan dengan inisialisasi otomatis variabel statis. </li><li>  Penugasan objek kernel.  Mengingat bahwa semua objek kernel dibuat secara statis pada tahap build dan diidentifikasi menggunakan nilai indeks, mungkin berguna untuk menetapkan "pemilik" atau menentukan penggunaan objek-objek ini.  Ini dapat dilakukan dengan menggunakan arahan #define, namun, jika ada beberapa contoh tugas, lebih baik untuk menetapkan indeks objek melalui array global (diindeks oleh ID tugas). </li><li>  Inisialisasi perangkat.  Ini dapat berguna untuk pemasangan awal perangkat. </li></ul><br>  Jelas, banyak dari tujuan ini dapat dicapai sebelum inisialisasi Nucleus SE, tetapi keuntungan di lokasi kode aplikasi di sini adalah bahwa sekarang Anda dapat menggunakan layanan kernel (panggilan API).  Misalnya, antrian atau kotak surat mungkin sudah diisi sebelumnya dengan data yang perlu diproses saat tugas dimulai. <br><br>  Panggilan API memiliki batasan: semua tindakan yang biasanya mengarah pada aktivasi penjadwal dilarang (misalnya, menjeda / memblokir tugas).  Variabel global <b>NUSE_Task_State telah</b> disetel ke <b>NUSE_STARTUP_CONTEXT</b> untuk <b>menunjukkan</b> batasan ini. <br><br><h2>  Luncurkan penjadwal </h2><br>  Setelah inisialisasi selesai, tetap hanya menjalankan penjadwal untuk mulai mengeksekusi kode aplikasi - tugas.  Konfigurasi penjadwal dan pekerjaan berbagai jenis penjadwal dijelaskan secara rinci di salah satu artikel sebelumnya ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="># 9</a> ), jadi hanya ringkasan singkat yang diperlukan di sini. <br>  Urutan langkah-langkah utama adalah sebagai berikut: <br><br><ul><li>  <b>Mengatur</b> variabel global <b>NUSE_Task_State ke</b> <b>NUSE_TASK_CONTEXT</b> . </li><li>  Pilih indeks tugas pertama yang akan dijalankan.  Jika dukungan untuk tugas awal diaktifkan, pencarian untuk tugas jadi pertama dilakukan, jika tidak, nilai nol digunakan. </li><li>  Penjadwal <b>disebut</b> - <b>NUSE_Scheduler ()</b> . </li></ul><br>  Apa yang sebenarnya terjadi pada langkah terakhir tergantung pada penjadwal yang dipilih.  Saat menggunakan penjadwal Run to Completion, siklus perencanaan dimulai dan tugas dipanggil secara berurutan.  Saat menggunakan penjadwal lain, konteks tugas pertama dimuat dan kontrol ditransfer ke tugas. <br><br>  Artikel berikut akan membahas diagnostik dan pemeriksaan kesalahan. <br><br>  <b>Tentang Pengarang:</b> Colin Walls telah bekerja di industri elektronik selama lebih dari tiga puluh tahun, mencurahkan sebagian besar waktunya untuk firmware.  Dia sekarang adalah seorang insinyur firmware di Mentor Embedded (sebuah divisi dari Mentor Graphics).  Colin Walls sering berbicara di konferensi dan seminar, penulis berbagai artikel teknis dan dua buku tentang firmware.  Tinggal di Inggris.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Blog</a> profesional <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Colin</a> , email: colin_walls@mentor.com. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id460617/">https://habr.com/ru/post/id460617/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id460603/index.html">V2G. Mobil listrik akan membantu menyeimbangkan produksi dan konsumsi listrik</a></li>
<li><a href="../id460605/index.html">Studio Foto Otomatis, Bagian 1</a></li>
<li><a href="../id460607/index.html">Toko aplikasi Keamanan Ofensif dengan alat peretas dari Android</a></li>
<li><a href="../id460611/index.html">Failover: perfeksionisme menghancurkan kita dan ... kemalasan</a></li>
<li><a href="../id460615/index.html">Setelah Industrial Ninja: bagaimana PLC diretas pada Positive Hack Days 9</a></li>
<li><a href="../id460621/index.html">Tic Tac Toe Bagian 4: Berinteraksi dengan Flask Backend Menggunakan HTTP</a></li>
<li><a href="../id460623/index.html">Tentang penyiksaan Julian Assange</a></li>
<li><a href="../id460625/index.html">Karena saya tidak mengambil tempat pertama dalam kompetisi untuk pengembang JavaScript dari Telegram</a></li>
<li><a href="../id460627/index.html">vGPU - penggunaan tidak dapat diabaikan</a></li>
<li><a href="../id460629/index.html">Probabilitas bahwa 2 penambang memiliki dunia yang sama</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>