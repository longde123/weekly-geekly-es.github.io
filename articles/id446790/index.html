<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚Ñ¢Ô∏è ü§õ üè® Bagaimana saya menemukan telur paskah di keamanan Android dan tidak mendapatkan pekerjaan di Google üèÇüèº üò¨ üñäÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Google menyukai telur paskah. Itu sangat mencintai mereka, sehingga Anda dapat menemukannya di hampir setiap produk mereka. Tradisi telur paskah Andro...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Bagaimana saya menemukan telur paskah di keamanan Android dan tidak mendapatkan pekerjaan di Google</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/446790/"><img src="https://habrastorage.org/webt/cx/0o/3t/cx0o3tqoavfz_opnsomw9-65h_i.jpeg" align="left">  Google menyukai telur paskah.  Itu sangat mencintai mereka, sehingga Anda dapat menemukannya di hampir setiap produk mereka.  Tradisi telur paskah Android dimulai pada versi OS yang paling awal (saya pikir semua orang di sana tahu apa yang terjadi ketika Anda masuk ke pengaturan umum dan mengetuk nomor versi beberapa kali). <br><br>  Tetapi kadang-kadang Anda dapat menemukan telur paskah di tempat-tempat yang paling tidak mungkin.  Bahkan ada legenda urban bahwa suatu hari, seorang programmer Googled ‚Äúmutex lock‚Äù, tetapi bukannya hasil pencarian mendarat di foo.bar, selesaikan semua tugas dan dapatkan pekerjaan di Google. <br><br><div class="spoiler">  <b class="spoiler_title">Rekonstruksi</b> <div class="spoiler_text"><img src="https://habrastorage.org/getpro/habr/post_images/157/242/ffc/157242ffcbf299f7a67641f9df1e551e.jpg" alt="gambar"><br></div></div><br>  Hal yang sama (kecuali tanpa akhir yang bahagia) terjadi pada saya.  Pesan tersembunyi di mana pasti tidak ada, membalikkan kode Java dan perpustakaan aslinya, VM rahasia, wawancara Google - semua itu ada di bawah. <br><a name="habracut"></a><br><h3>  Droidguard </h3><br>  Suatu malam yang membosankan saya mengatur ulang pabrik ponsel saya dan mengaturnya kembali.  Hal pertama yang pertama, instalasi Android baru meminta saya untuk masuk ke akun Google.  Dan saya bertanya-tanya: bagaimana proses masuk ke Android bekerja?  Dan malam tiba-tiba menjadi kurang membosankan. <br><br>  Saya menggunakan Burp Suite PortSwigger untuk mencegat dan menganalisis lalu lintas jaringan.  Versi Komunitas gratis sudah cukup untuk tujuan kita.  Untuk melihat permintaan https, pertama-tama kita perlu menginstal sertifikat PortSwigger ke perangkat.  Sebagai perangkat pengujian, saya memilih Samsung Galaxy S yang berusia 8 tahun dengan Android 4.4.  Apa pun yang lebih baru dari itu dan Anda mungkin memiliki masalah dengan penyematan sertifikat dan lainnya. <br><br>  Dalam semua kejujuran, tidak ada yang khusus dengan permintaan Google API.  Perangkat mengirim informasi tentang dirinya sendiri dan mendapat token sebagai tanggapan ... Satu-satunya langkah yang penasaran adalah permintaan POST ke layanan anti-penyalahgunaan. <br><br><img src="https://habrastorage.org/webt/nv/4c/7n/nv4c7njt_zecyvp0vquekhnoxbm.png"><br><br>  Setelah permintaan dibuat, di antara banyak parameter yang sangat normal muncul yang menarik, bernama <b>droidguard_result</b> .  Ini adalah string Base64 yang sangat panjang: <br><br><img src="https://habrastorage.org/webt/kp/h3/i-/kph3i-1n7tw9dv-ckitddw4rxdm.png"><br><br>  DroidGuard adalah mekanisme Google untuk mendeteksi bot dan emulator di antara perangkat nyata.  SafetyNet, misalnya, juga menggunakan data DroidGuard.  Google juga memiliki hal serupa untuk browser - Botguard. <br><br>  Tapi apa data itu?  Ayo cari tahu. <br><br><h3>  Buffer protokol </h3><br>  Apa yang menghasilkan tautan itu ( <i><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">www.googleapis.com/androidantiabuse/v1/x/create?alt=PROTO&amp;key=AIzaSyBofcZsgLSS7BOnBjZPEkk4rYwzOIz-lTI</a></i> ) dan apa yang ada di dalam Android yang membuat permintaan ini?  Setelah penyelidikan singkat, ternyata tautan itu, dalam bentuk persis ini, terletak di dalam salah satu kelas Google Play Services yang dikaburkan: <br><br><pre><code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bdd</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Context var1, bdh var2)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>(var1, <span class="hljs-string"><span class="hljs-string">"https://www.googleapis.com/androidantiabuse/v1/x/create?alt=PROTO&amp;key=AIzaSyBofcZsgLSS7BOnBjZPEkk4rYwzOIz-lTI"</span></span>, var2); }</code> </pre> <br>  Seperti yang telah kita lihat di Burp, permintaan POST pada tautan ini memiliki <b>Content-Type</b> - <b>application / x-protobuf</b> (Google Protocol Buffer, protokol Google untuk serialisasi biner).  Tapi bukan json - sulit untuk mengungkap apa yang sebenarnya dikirim. <br><br>  Protokol buffer berfungsi seperti ini: <br><br><ul><li>  Pertama kami menggambarkan struktur pesan dalam format khusus dan menyimpannya ke dalam file .proto; </li><li>  Kemudian kita mengkompilasi file .proto, dan kompiler protoc menghasilkan kode sumber dalam bahasa yang dipilih (dalam kasus Android itu Java); </li><li>  Akhirnya, kami menggunakan kelas yang dihasilkan dalam proyek kami. </li></ul><br>  Kami memiliki dua cara untuk memecahkan kode pesan protobuf.  Yang pertama adalah menggunakan penganalisa protobuf dan mencoba untuk membuat ulang deskripsi asli file .proto.  Yang kedua adalah mencabut kelas yang dihasilkan oleh protoc dari Google Play Services, yang saya putuskan untuk lakukan. <br><br>  Kami mengambil file .apk Layanan Google Play dari versi yang sama yang diinstal pada perangkat (atau, jika perangkat di-root, ambil saja file langsung dari sana).  Menggunakan dex2jar kita mengkonversi file .dex kembali ke .jar dan buka di dekompiler pilihan.  Saya pribadi suka Fernflower JetBrains.  Ini berfungsi sebagai plugin untuk IntelliJ IDEA (atau Android Studio), jadi kami cukup meluncurkan Android Studio dan membuka file dengan tautan yang kami coba analisis.  Jika proguard tidak berusaha terlalu keras, kode Java yang didekompilasi untuk membuat pesan protobuf bisa saja disalin ke proyek Anda. <br><br>  Melihat kode yang didekompilasi, kita melihat bahwa Build. * Konstanta sedang dikirim di dalam pesan protobuf.  (Oke, itu tidak terlalu sulit ditebak). <br><br><pre> <code class="java hljs">... var3.a(<span class="hljs-string"><span class="hljs-string">"4.0.33 (910055-30)"</span></span>); a(var3, <span class="hljs-string"><span class="hljs-string">"BOARD"</span></span>, Build.BOARD); a(var3, <span class="hljs-string"><span class="hljs-string">"BOOTLOADER"</span></span>, Build.BOOTLOADER); a(var3, <span class="hljs-string"><span class="hljs-string">"BRAND"</span></span>, Build.BRAND); a(var3, <span class="hljs-string"><span class="hljs-string">"CPU_ABI"</span></span>, Build.CPU_ABI); a(var3, <span class="hljs-string"><span class="hljs-string">"CPU_ABI2"</span></span>, Build.CPU_ABI2); a(var3, <span class="hljs-string"><span class="hljs-string">"DEVICE"</span></span>, Build.DEVICE); ...</code> </pre><br>  Namun sayangnya, dalam balasan server semua bidang protobuf berubah menjadi sup alfabet setelah kebingungan.  Tetapi kita dapat menemukan apa yang ada di sana menggunakan penangan kesalahan.  Berikut cara memeriksa data yang berasal dari server: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!var7.d()) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> bdf(<span class="hljs-string"><span class="hljs-string">"byteCode"</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!var7.f()) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> bdf(<span class="hljs-string"><span class="hljs-string">"vmUrl"</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!var7.h()) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> bdf(<span class="hljs-string"><span class="hljs-string">"vmChecksum"</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!var7.j()) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> bdf(<span class="hljs-string"><span class="hljs-string">"expiryTimeSecs"</span></span>); }</code> </pre><br>  Rupanya, begitulah cara bidang dipanggil sebelum kebingungan: <b>byteCode</b> , <b>vmUrl</b> , <b>vmChecksum</b> dan <b>expiryTimeSecs</b> .  Skema penamaan ini sudah memberi kita beberapa ide. <br><br>  Kami menggabungkan semua kelas yang didekompilasi dari Google Play Services ke dalam proyek uji coba, menamainya kembali, menghasilkan tes Build. * Perintah dan peluncuran (meniru perangkat apa pun yang kita inginkan).  Jika seseorang ingin melakukannya sendiri, inilah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tautan ke GitHub saya</a> . <br><br>  Jika permintaannya benar, server mengembalikan ini: <br><blockquote>  00: 06: 26.761 [main] INFO daresponse.AntiabuseResponse - byteKode kode: 34446 <br>  00: 06: 26.761 [main] INFO daresponse.AntiabuseResponse - vmChecksum: C15E93CCFD9EF178293A2334A1C9F9B08F115993 <br>  00: 06: 26.761 [main] INFO daresponse.AntiabuseResponse - vmUrl: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">www.gstatic.com/droidguard/C15E93CCFD9EF178293A2334A1C9F9B08F115993</a> <br>  00: 06: 26.761 [main] INFO daresponse.AntiabuseResponse - expiryTimeSecs: 10 </blockquote><br>  Langkah 1 selesai.  Sekarang mari kita lihat apa yang tersembunyi di balik tautan <b>vmUrl</b> . <br><br><h3>  APK rahasia </h3><br>  Tautan membawa kita langsung ke file .apk, dinamai hash SHA-1-nya sendiri.  Ini agak kecil - hanya 150KB.  Dan itu cukup dibenarkan: jika diunduh oleh setiap satu dari 2 miliar perangkat Android, itu adalah 270TB lalu lintas pada layanan Google. <br><br><img src="https://habrastorage.org/webt/-s/di/nj/-sdinjinilpprsvgslvs3e6gsdk.png"><br><br>  Kelas <code>DroidGuardService</code> , sebagai bagian dari Google Play Services, mengunduh file ke perangkat, membongkar, mengekstrak .dex dan menggunakan <code>com.google.ccc.abuse.droidguard.DroidGuard</code> melalui refleksi.  Jika ada kesalahan, maka <code>DroidGuardService</code> beralih dari DroidGuard kembali ke Droidguasso.  Tapi itu cerita lain sepenuhnya. <br><br>  Pada dasarnya, kelas <code>DroidGuard</code> adalah pembungkus JNI sederhana di sekitar perpustakaan .so asli.  ABI perpustakaan asli cocok dengan apa yang kami kirim di bidang <code>CPU_ABI</code> dalam permintaan protobuf: kita dapat meminta armeabi, x86 atau bahkan MIPS. <br><br>  Layanan <code>DroidGuardService</code> sendiri tidak mengandung logika menarik untuk bekerja dengan kelas <code>DroidGuard</code> .  Ini hanya membuat instance baru <code>DroidGuard</code> , mengirimkannya <b>byteCode</b> dari pesan protobuf, memanggil metode publik, yang mengembalikan array byte.  Array ini kemudian dikirim ke server di dalam parameter <b>droidguard_result</b> . <br><br>  Untuk mendapatkan gambaran kasar tentang apa yang terjadi di dalam <code>DroidGuard</code> kita dapat mengulangi logika <code>DroidGuardService</code> (tetapi tanpa mengunduh .apk, karena kita sudah memiliki pustaka asli).  Kita dapat mengambil file .dex dari APK rahasia, mengubahnya menjadi .jar dan kemudian digunakan dalam proyek kami.  Satu-satunya masalah adalah bagaimana kelas <code>DroidGuard</code> memuat pustaka asli.  Blok inisialisasi statis memanggil metode <code>loadDroidGuardLibrary()</code> : <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { loadDroidGuardLibrary(); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (Exception ex) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> RuntimeException(ex); } }</code> </pre><br>  Kemudian metode <code>loadDroidGuardLibrary()</code> membaca library.txt (terletak di root file .apk) dan memuat perpustakaan dengan nama itu melalui <code>System.load(String filename)</code> .  Sangat tidak nyaman bagi kami, karena kami harus membangun .apk dengan cara yang sangat spesifik untuk meletakkan library.txt dan file .so ke dalam root.  Akan jauh lebih nyaman untuk menyimpan file .so di folder lib dan memuatnya melalui <code>System.loadLibrary(String libname)</code> . <br><br>  Itu tidak sulit untuk dilakukan.  Kami akan menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">smali / baksmali</a> - assembler / disassembler untuk file .dex.  Setelah menggunakannya, class.dex berubah menjadi banyak file .smali.  Kelas <code>com.google.ccc.abuse.droidguard.DroidGuard</code> harus dimodifikasi, sehingga blok inisialisasi statis memanggil metode <code>System.loadLibrary("droidguard")</code> alih-alih <code>loadDroidGuardLibrary()</code> .  Sintaksis Smali cukup sederhana, blok inisialisasi baru terlihat seperti ini: <br><br><pre> <code class="plaintext hljs">.method static constructor &lt;clinit&gt;()V .locals 1 const-string v0, "droidguard" invoke-static {v0}, Ljava/lang/System;-&gt;loadLibrary(Ljava/lang/String;)V return-void .end method</code> </pre><br>  Kemudian kami menggunakan backsmali untuk membangun semuanya kembali ke .dex, dan kemudian kami mengubahnya menjadi .jar.  Pada akhirnya kita mendapatkan file .jar yang bisa kita gunakan dalam proyek kita - ini <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dia</a> . <br><br>  Seluruh bagian yang berhubungan dengan DroidGuard adalah beberapa string.  Bagian terpenting adalah mengunduh array byte yang kami dapatkan di langkah sebelumnya setelah menangani layanan anti-penyalahgunaan dan menyerahkannya ke konstruktor <code>DroidGuard</code> : <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">runDroidguard</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> byteCode: ByteArray? = loadBytecode(<span class="hljs-string"><span class="hljs-string">"bytecode.base64"</span></span>); byteCode?.let { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> droidguard = DroidGuard(applicationContext, <span class="hljs-string"><span class="hljs-string">"addAccount"</span></span>, it) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> params = mapOf(<span class="hljs-string"><span class="hljs-string">"dg_email"</span></span> to <span class="hljs-string"><span class="hljs-string">"test@gmail.com"</span></span>, <span class="hljs-string"><span class="hljs-string">"dg_gmsCoreVersion"</span></span> to <span class="hljs-string"><span class="hljs-string">"910055-30"</span></span>, <span class="hljs-string"><span class="hljs-string">"dg_package"</span></span> to <span class="hljs-string"><span class="hljs-string">"com.google.android.gms"</span></span>, <span class="hljs-string"><span class="hljs-string">"dg_androidId"</span></span> to UUID.randomUUID().toString()) droidguard.<span class="hljs-keyword"><span class="hljs-keyword">init</span></span>() <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> result = droidguard.ss(params) droidguard.close() } }</code> </pre><br>  Sekarang kita dapat menggunakan profiler Android Studio dan melihat apa yang terjadi selama pekerjaan DroidGuard: <br><br><img src="https://habrastorage.org/webt/c-/9w/pz/c-9wpzbrrpibjyflhyrunq3azu0.png"><br><br>  Metode asli initNative () mengumpulkan data tentang perangkat dan memanggil metode Java <code>hasSystemFeature(), getMemoryInfo(), getPackageInfo()</code> ... itu sesuatu, tapi saya masih tidak melihat logika yang solid.  Nah, yang tersisa hanyalah membongkar file .so. <br><br><h3>  libdroidguard.so </h3><br>  Untungnya, menganalisis perpustakaan asli tidak lebih sulit daripada melakukannya dengan file .dex dan .jar.  Kami membutuhkan aplikasi yang mirip dengan Hex-Rays IDA dan beberapa pengetahuan tentang kode assembler x86 atau ARM.  Saya memilih ARM, karena saya memiliki perangkat yang telah di-root untuk debug.  Jika Anda tidak memilikinya, Anda bisa mengambil pustaka x86 dan debug menggunakan emulator. <br><br>  Sebuah aplikasi yang mirip dengan Hex-Rays IDA mendekompilasi biner menjadi sesuatu yang menyerupai kode C.  Jika kita membuka <code>Java_com_google_ccc_abuse_droidguard_DroidGuard_ssNative</code> metode, kita akan melihat sesuatu seperti ini: <br><br><pre> <code class="cpp hljs">__int64 __<span class="hljs-function"><span class="hljs-function">fastcall </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Java_com_google_ccc_abuse_droidguard_DroidGuard_initNative</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> a1, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> a2, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> a3, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> a4, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> a5, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> a6, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> a7, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> a8, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> a9)</span></span></span><span class="hljs-function"> ... v14 </span></span>= (*(_DWORD *)v9 + <span class="hljs-number"><span class="hljs-number">684</span></span>))(v9, a5); v15 = (*(_DWORD *)v9 + <span class="hljs-number"><span class="hljs-number">736</span></span>))(v9, a5, <span class="hljs-number"><span class="hljs-number">0</span></span>); ...</code> </pre><br>  Tidak terlihat terlalu menjanjikan.  Pertama kita perlu membuat beberapa langkah awal untuk mengubahnya menjadi sesuatu yang lebih berguna.  Dekompiler tidak tahu apa-apa tentang JNI, jadi kami menginstal Android NDK dan mengimpor file jni.h.  Seperti yang kita ketahui, dua parameter pertama dari metode JNI adalah <code>JNIEnv*</code> dan <code>jobject (this)</code> .  Kita bisa mengetahui tipe-tipe parameter lain dari kode Java DroidGuard.  Setelah menetapkan jenis yang benar, offset yang tidak berarti berubah menjadi panggilan metode JNI: <br><br><pre> <code class="cpp hljs">__int64 __<span class="hljs-function"><span class="hljs-function">fastcall </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Java_com_google_ccc_abuse_droidguard_DroidGuard_initNative</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(_JNIEnv *env, jobject thiz, jobject context, jstring flow, jbyteArray byteCode, jobject runtimeApi, jobject extras, jint loggingFd, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> runningInAppSide)</span></span></span><span class="hljs-function"> </span></span>{ ... programLength = _env-&gt;functions-&gt;GetArrayLength)(_env, byteCode); programBytes = (jbyte *)_env-&gt;functions-&gt;GetByteArrayElements)(_env, byteCode, <span class="hljs-number"><span class="hljs-number">0</span></span>); ...</code> </pre><br>  Jika kami memiliki cukup kesabaran untuk melacak array byte yang diterima dari server anti-penyalahgunaan, kami akan ... kecewa.  Sayangnya, tidak ada jawaban sederhana untuk "apa yang terjadi di sini?".  Ini murni, kode byte yang disuling, dan pustaka asli adalah mesin virtual.  Beberapa enkripsi AES ditaburkan di atas dan kemudian VM membaca kode byte, byte demi byte, dan menjalankan perintah.  Setiap byte adalah perintah yang diikuti oleh operan.  Tidak banyak perintah, hanya sekitar 70: baca int, baca byte, baca string, panggil metode Java, gandakan dua angka, if-goto dll. <br><br><h3>  Bangun neo </h3><br>  Saya memutuskan untuk melangkah lebih jauh dan mencari tahu struktur kode byte untuk VM ini.  Ada masalah lain dengan panggilan: kadang-kadang (sekali setiap beberapa minggu) ada versi baru dari perpustakaan asli di mana pasangan byte-perintah diacak.  Itu tidak menghentikan saya dan saya memutuskan untuk membuat ulang VM menggunakan Java. <br><br>  Apa yang dilakukan kode byte adalah melakukan semua pekerjaan rutin mengumpulkan informasi tentang perangkat.  Sebagai contoh, ini memuat string dengan nama metode, mendapatkan alamatnya melalui dlsym dan dijalankan.  Dalam versi Java saya dari VM, saya hanya menciptakan 5 metode atau lebih dan belajar menafsirkan 25 perintah pertama dari kode byte layanan anti-penyalahgunaan.  Pada perintah ke-26, VM membaca string terenkripsi lain dari kode byte.  Tiba-tiba ternyata itu bukan nama metode lain.  Jauh dari itu. <br><blockquote>  Perintah Mesin Virtual # 26 <br>  Metode doa vm-&gt; vm_method_table [2 * 0x77] <br>  Metode vmMethod_readString <br>  indeks adalah 0x9d <br>  panjang string adalah 0x0066 <br>  (kunci baru dihasilkan) <br>  byte string yang dikodekan adalah EB 4E E6 DC 34 13 35 4A DD 55 B3 91 33 05 61 04 C0 54 FD 95 2F 18 72 04 C1 55 E1 92 28 11 66 04 DD 4F B3 94 33 04 35 0A C1 4E B2 DB 12 17 79 4F 92 55 FC DB 33 05 35 45 C6 01 F7 89 29 1F 71 43 C7 40 E1 9F 6B 1E 70 48 DE 4E B8 CD 75 44 23 14 85 14 A7 C2 7F 40 26 42 84 17 A2 BB 21 19 7A 43 DE 44 BD 98 29 1B <br>  byte string yang didekodekan adalah 59 6F 75 27 72 65 20 6E 6F 74 20 6A 75 73 74 20 72 75 6E 6E 69 6E 67 20 73 74 72 69 6E 67 73 20 6F 6E 20 6F 75 72 20 2E 73 6F 21 20 54 61 6C 6B 20 74 6F 20 75 73 20 61 74 20 64 72 6F 69 64 67 75 61 72 64 2D 68 65 6C 6C 6F 2B 36 33 32 36 30 37 35 34 39 39 36 33 66 36 36 31 40 67 6F 6F 67 6C 65 2E 63 6F 6D <br>  nilai string yang didekodekan adalah ( <b>Anda tidak hanya menjalankan string pada .so! Bicaralah kepada kami di droidguard@google.com</b> ) </blockquote>  Itu aneh.  Mesin virtual belum pernah berbicara dengan saya sebelumnya.  Saya pikir jika Anda mulai melihat pesan rahasia diarahkan kepada Anda, Anda akan menjadi gila.  Untuk memastikan saya masih waras, saya menjalankan beberapa ratus jawaban berbeda dari layanan anti-penyalahgunaan melalui VM saya.  Secara harfiah setiap 25-30 perintah ada pesan yang disembunyikan dalam kode byte.  Mereka sering diulang, tetapi di bawah ini adalah beberapa yang unik.  Namun, saya mengedit alamat email: setiap pesan memiliki alamat yang berbeda, seperti "droidguard+tag@google.com", dengan tag yang unik untuk masing-masingnya. <br><blockquote>  droidguard@google.com: Jangan menjadi orang asing! <br>  Kamu masuk!  Hubungi kami di droidguard@google.com <br>  Salam dari droidguard@google.com traveler pemberani!  Katakan hai! <br>  Apakah mudah menemukan ini?  droidguard@google.com ingin tahu <br>  Orang-orang di droidguard@google.com akan sangat menghargai mendengar dari Anda! <br>  Apa semua omong kosong ini?  Tanyakan droidguard@google.com ... mereka akan tahu! <br>  Hai!  Senang melihatmu di sini.  Sudahkah Anda berbicara dengan droidguard@google.com? <br>  Anda tidak hanya menjalankan string pada .so!  Hubungi kami di droidguard@google.com <br></blockquote>  Apakah saya yang terpilih?  Saya pikir sudah waktunya untuk berhenti mengacaukan DroidGuard dan berbicara dengan Google, karena mereka bertanya kepada saya. <br><br><h3>  Panggilan Anda sangat penting bagi kami </h3><br>  Saya mengatakan temuan saya di email yang saya temukan.  Untuk membuat hasil sedikit lebih mengesankan, saya mengotomatiskan proses analisis sedikit.  Masalahnya, string dan byte array disimpan dalam kode byte yang dienkripsi.  VM menerjemahkannya menggunakan konstanta yang diuraikan oleh kompiler.  Dengan menggunakan aplikasi yang mirip dengan Hex-Rays IDA, Anda dapat mengekstraknya dengan mudah.  Tetapi dengan setiap perubahan konstanta versi baru dan itu cukup nyaman untuk selalu mengekstraknya secara manual. <br><br>  Tetapi Java-parsing perpustakaan asli ternyata sangat sederhana.  Menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">jelf</a> (pustaka untuk parsing file ELF) kami menemukan offset <code>Java_com_google_ccc_abuse_droidguard_DroidGuard_initNative</code> metode dalam biner, dan kemudian menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Capstone</a> (kerangka kerja pembongkaran dengan binding untuk berbagai bahasa, termasuk Java) kami mendapatkan kode assembler dan mencarinya untuk memuat konstanta ke dalam berbagai bahasa, termasuk Jawa) pendaftar. <br><br>  Pada akhirnya saya mendapatkan aplikasi yang meniru seluruh proses DroidGuard: membuat permintaan ke layanan anti-penyalahgunaan, mengunduh .apk, membuka paketnya, mem-parsing perpustakaan asli, mengekstrak konstanta yang diperlukan, mengambil pemetaan perintah VM dan memilih mengartikan kode byte.  Saya mengkompilasi semuanya dan mengirimkannya ke Google.  Sementara saya berada di sana, saya mulai bersiap untuk pindah dan mencari Glassdoor untuk gaji rata-rata di Google.  Saya memutuskan untuk tidak menyetujui kurang dari enam angka. <br><br>  Jawabannya tidak butuh waktu lama.  Sebuah email dari anggota tim DroidGuard hanya membaca: "Mengapa kamu melakukan ini?" <br><br><img src="https://habrastorage.org/webt/go/ql/kf/goqlkffwq02w6daa9-e22xxgdiq.jpeg"><br><br>  "Karena aku bisa" - jawabku.  Seorang karyawan Google menjelaskan kepada saya bahwa DroidGuard seharusnya melindungi Android dari peretas (Anda tidak bilang!) Dan akan lebih bijak jika menyimpan kode sumber DroidGuard VM saya sendiri.  Percakapan kami berakhir di sana. <br><br><h3>  Wawancara </h3><br>  Sebulan kemudian saya menerima email lain.  Tim DroidGuard di Zurich membutuhkan karyawan baru.  Apakah saya tertarik bergabung?  Tentu saja! <br><br>  Tidak ada jalan pintas untuk masuk ke Google.  Yang bisa dilakukan oleh kontak saya hanyalah meneruskan CV saya ke departemen SDM.  Setelah itu saya harus melalui omong kosong birokrasi yang biasa dan serangkaian wawancara. <br><br>  Ada banyak cerita di luar sana tentang wawancara Google.  Algoritma, tugas Olimpiade, dan pemrograman Google Documents bukanlah tugas saya, jadi saya memulai persiapan.  Saya membaca kursus "Algoritma" Coursera puluhan kali, menyelesaikan ratusan tugas di Hackerrank dan belajar untuk berkeliling grafik di kedua dimensi dengan mata tertutup. <br><br>  Dua bulan berlalu.  Untuk mengatakan saya merasa siap akan menjadi pernyataan yang meremehkan.  Google Documents menjadi IDE favorit saya.  Saya merasa seperti saya tahu segalanya yang perlu diketahui tentang algoritma.  Tentu saja, saya tahu kelemahan saya dan menyadari bahwa saya mungkin tidak akan melewati serangkaian 5 wawancara di Zurich, tetapi pergi ke Disneyland programmer secara gratis adalah hadiah dalam dan dari dirinya sendiri.  Langkah pertama adalah wawancara telepon untuk menyingkirkan kandidat terlemah dan tidak membuang waktu pengembang Zurich pada pertemuan tatap muka.  Hari itu ditetapkan, telepon berdering ... <br><br><img src="https://habrastorage.org/webt/5c/nk/uh/5cnkuh5btyvoaz0pyz-zma3flzs.png"><br><br>  ... dan saya langsung gagal tes pertama saya.  Saya beruntung - mereka mengajukan pertanyaan yang pernah saya lihat di internet sebelumnya dan sudah diselesaikan.  Itu tentang serialisasi array string.  Saya menawarkan kode string di Base64 dan menyimpannya melalui pembagi.  Pewawancara meminta saya untuk mengembangkan algoritma Base64.  Setelah itu wawancara berubah menjadi semacam monolog, di mana diwawancarai menjelaskan kepada saya bagaimana Base64 bekerja dan saya mencoba mengingat operasi bit di Jawa. <br><br><div class="spoiler">  <b class="spoiler_title">Jika ada orang di Google yang membaca ini</b> <div class="spoiler_text">  Kawan, kau genius berdarah jika sampai di sana!  Serius.  Saya tidak bisa membayangkan bagaimana seseorang bisa membersihkan semua hambatan yang mereka hadapi di depan Anda. <br></div></div><br>  3 hari setelah panggilan saya mendapat email yang mengatakan mereka tidak ingin mewawancarai saya lebih lanjut.  Dan itulah bagaimana komunikasi saya dengan Google berakhir. <br><br>  Mengapa ada pesan di DroidGuard yang meminta untuk mengobrol, saya masih tidak tahu.  Mungkin hanya untuk statistik.  Orang yang saya tulis pada awalnya memberi tahu saya bahwa orang-orang benar-benar menulis di sana, tetapi frekuensinya bervariasi: kadang-kadang mereka mendapat 3 balasan dalam seminggu, kadang-kadang 1 setahun. <br><br>  Saya percaya ada cara yang lebih mudah untuk mendapatkan wawancara di Google.  Lagipula, Anda bisa menanyakan salah satu dari 100.000 karyawan (meskipun tidak semua dari mereka adalah pengembang, diakui).  Namun itu adalah pengalaman yang menyenangkan. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id446790/">https://habr.com/ru/post/id446790/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id446776/index.html">Bukti Kerja Efektif</a></li>
<li><a href="../id446780/index.html">Cara membuat tema gelap dan tidak membahayakan. Pengalaman Tim Yandex.Mail</a></li>
<li><a href="../id446782/index.html">Yo-ho-ho dan sebotol rum</a></li>
<li><a href="../id446786/index.html">Mengapa saya menolak Disqus dan Anda harus pergi juga</a></li>
<li><a href="../id446788/index.html">Kiat & trik Kubernetes: tentang pengembangan lokal dan Telepresence</a></li>
<li><a href="../id446794/index.html">Kami bekerja dengan Wordstat dengan benar. Panduan lengkap</a></li>
<li><a href="../id446796/index.html">Sirkuit tidak standar: indikator tujuh segmen pada ATtiny13</a></li>
<li><a href="../id446798/index.html">Kepergian seorang insinyur elektronik dari Apple menyebabkan kegemparan di antara para spekulan saham. Bagaimana menjadi seperti dia?</a></li>
<li><a href="../id446802/index.html">Refill Dot Cartridges - Sangat Menarik</a></li>
<li><a href="../id446806/index.html">Latar Belakang: "Runet Autonomous" - apa itu dan siapa yang membutuhkannya</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>