<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🕵🏽 👍🏽 🔮 Unity：使用WFC算法获得的无休止的程序生成的城市（波动函数崩溃） 🧒🏼 🎻 ⚙️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="哈Ha！ 

 作为俄罗斯市场上Unity的 立法者 ，我们为您提供有关WFC（波动函数崩溃）算法实际使用的有趣研究报告，该算法建立在量子力学众所周知的原理的图像和相似之处上，非常便于在游戏中生成关卡的过程。 早在Habré上，有关该算法的详细故事已经发布。 今天的文章的作者玛丽安·克莱恩伯格（Ma...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Unity：使用WFC算法获得的无休止的程序生成的城市（波动函数崩溃）</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/piter/blog/455004/"> 哈Ha！ <br><br> 作为俄罗斯市场上<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Unity的</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">立法者</a> ，我们为您提供有关WFC（波动函数崩溃）算法实际使用的有趣研究报告，该算法建立在量子力学众所周知的原理的图像和相似之处上，非常便于在游戏中生成关卡的过程。 早在Habré上，有关该算法的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">详细故事</a>已经发布。 今天的文章的作者玛丽安·克莱恩伯格（Marian Kleineberg）在三维图形和无休止的城市生成的背景下考虑了该算法。 祝您阅读愉快！ <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/4b/e7/af/4be7afzttmmd9g8y2snj_pnxpns.jpeg"></div><a name="habracut"></a><br> 我们将讨论一种游戏，在该游戏中，您会穿越无尽的城市，而这个城市是随着移动而生成的。 使用WFC算法（波动函数折叠）从一组街区构建城市。 <br><br> 可播放的程序集可从<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">itch.io</a>网站上下载。 您也可以<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">在github上</a>获取<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">源代码</a> 。 最后，我提出一个<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">视频，</a>在其中我漫步于由此产生的城市。 <br><br><h3> 演算法 </h3><br> 我将“单元”一词称为3D体素网格元素，它可以包含一个块或为空。 我将称呼“模块”一词为一个可以占据这样一个单元的块。 <br><br> 该算法决定在游戏世界的每个单元中选择哪个模块。 单元阵列被认为是不可观察形式的波函数。 因此，每个单元对应于可能出现在其中的许多模块。 就量子力学而言，可以说“该单元是所有模块的叠加”。 世界的存在是以完全不可观察的形式开始的，每个单元中都可以存在任何模块。 此外，所有细胞都崩溃了。 这意味着对于每个单元，从所有可能的单元中随机选择一个模块。 <br><br> 下一步是约束传播。 对于每个模块，选择允许与其相邻的模块子集。 每次模块崩溃时，都会更新其他模块的子集，但仍允许与其相邻。 就计算能力而言，限制的传播阶段是该算法最耗资源的部分。 <br><br> 该算法的重要方面是确定要崩溃的单元格。 该算法总是使具有<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">最小熵</a>的单元崩溃。 这是一个允许进行最少选择的单元（即，随机性最小的单元）。 如果所有模块的崩溃概率都相同，则具有最小数量可能模块的单元将具有最低的熵。 通常，对于各种可用模块，被选择的概率是不同的。 与具有两个模块的模块相比，具有两个可能模块的模块具有相同的概率提供了更大的选择范围（更大的熵），对于其中一个模块，落入选择范围的概率非常高，而对于另一个模块而言，概率很小。 <br><br><img src="https://habrastorage.org/webt/dp/kw/z-/dpkwz-w1fr5-xxrw_flqyt_mtou.gif"><br><br>  （由<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">ExUtumno</a>在Github上发布的Gif） <br><br> 在此处可以找到有关波动函数塌陷算法的更多详细信息，以及许多漂亮的示例。 最初，提出了该算法用于基于单个样本生成2D纹理。 在这种情况下，根据示例中模块和邻接规则的出现来确定它们的概率指示符。 本文手动提供此信息。 <br><br> 这是一个演示该算法的<a href="">视频</a> 。 <br><br><h3> 关于模块，原型和模块 </h3><br> 世界由其中约100个街区组成的集合产生。 我使用Blender创建了它们。 刚开始时，我只有几个街区，当我认为必要时，我会一点一点地添加它们。 <br><br><img src="https://habrastorage.org/webt/yj/26/sn/yj26snwykmonhpvoy9mvv_bnsq8.png"><br><br> 该算法需要知道哪些模块可以彼此相邻放置。 对于每个模块，都有6个可能的邻居列表，每个方向一个。 但是，我希望避免手动创建此类列表。 另外，我想为每个模块自动生成旋转选项。 <br><br> 使用所谓的原型模块可以解决这两个任务。 本质上，这是<code>MonoBehaviour</code> ，在Unity编辑器中使用起来很方便。 基于此类原型，将自动创建模块以及有效的相邻元素列表和旋转选项。 <br><br> 建模邻接信息会引起一个复杂的问题，因此该自动过程可以正常工作。 这是我得到的： <br><br><img src="https://habrastorage.org/webt/ym/cj/ke/ymcjkeehpahvovwxbpl7kma28bs.png"><br><br> 每个块有6个触点，每个面一个。 联系人有一个电话号码。 另外，水平触点可以颠倒，不颠倒或对称。 垂直触点的旋转指数在0到3的范围内，或者标记为<i>旋转不变的</i> 。 <br><br> 基于此，我可以自动检查允许哪些模块组合在一起。 相邻的模块必须具有相同的引脚号。 它们的对称性也必须重合（相同的垂直旋转指数，一对反向和非反向水平触点），或者模块必须对称/不变。 <br><br><img src="https://habrastorage.org/webt/zk/-3/lo/zk-3looqprzz5upxpuavvmkccbu.png"><br><br> 有一些排除规则可以禁止默认情况下允许的邻居选项。 一些带有匹配联系人的街区在附近看起来很难看。 这是在不应用异常规则的情况下生成的映射的示例： <br><br><img src="https://habrastorage.org/webt/md/od/0f/mdod0f_xkotiz9sc7tigjres6ia.jpeg"><br><br><h3> 通往无限的方式 </h3><br> 原始的波函数塌陷算法生成有限尺寸的图。 我想建立一个随着您的前进而不断扩展的世界。 <br><br> 最初，我尝试生成有限大小的片段，并使用相邻片段的接触作为限制。 如果生成了一个片段，并且还生成了一个与其相邻的片段，则仅允许此类模块适合于现有模块。 通过这种方法，会出现以下问题：每当一个单元崩溃时，限制的传播都会减少机会，即使距离多个单元也是如此。 下图显示了折叠单个单元格的效果： <br><br><img src="https://habrastorage.org/webt/ex/yj/rv/exyjrvgb7tciaf1skkzgndnvpd0.png"><br><br> 如果在算法的每个步骤中仅生成一个片段，则限制不适用于相邻片段。 在这种情况下，在片段内选择了这样的模块，如果考虑其他片段，这将是不可接受的。 结果，当算法尝试生成下一个片段时，它找不到单个解决方案。 <br><br> 现在，我不再使用片段，而是将地图存储在字典中，该字典显示单元在单元上的位置。 仅在必要时才填充单元格。 考虑到这一点，应调整算法的某些元素。 选择应该折叠的单元格时，如果单元格的数量是无限的，则不可能考虑所有单元格。 相反，一旦玩家到达地图，我们一次只会生成一小部分地图。 在这一地区之外，限制继续蔓延。 <br><br> 在某些情况下，这种方法不起作用。 从上图考虑隧道直段的一组模块-隧道没有入口。 如果算法选择了这样的隧道模块，那么根据定义，该隧道将是无限的。 在分配限制的阶段，程序将尝试分配无限数量的像元。 我开发了一组特殊的模块来解决此问题。 <br><br><h3> 边界条件 </h3><br> 有两个重要的边界条件。 地图顶层的所有面孔都必须具有“空中”接触。 地图底部的所有面孔都必须具有“固定”接触。 如果不满足这些条件，则在地图上地面上将有孔，并且某些建筑物将没有屋顶。 <br><br> 在有限大小的地图上，此问题将很容易解决。 对于处于最高和最低级别的所有单元，有必要删除所有接触不良的模块。 然后开始分发限制并删除不再适合我们的其余模块。 <br><br> 在无限大小的地图上，这是行不通的，因为无论在最高级别还是最低级别，我们都有无限数量的像元。 最幼稚的解决方案是在所有不适当的单元格出现时立即删除它们。 但是，在上级卸下模块时，限制条件适用于与其相邻的那些单元。 有雪崩效应，再次导致细胞的无限选择。 <br><br> 我通过创建1×n×1地图（其中n是高度）解决了这个问题。 这张地图使用世界包装来散布限制。 该机制的作用与游戏《吃豆人》中的游戏一样：超出地图的右边缘，角色由于左边缘而返回到地图。 现在，我可以对地图应用任何限制了。 每次您在无限地图上创建新的单元格时，都会使用一组对应于地图上特定位置的模块来初始化此单元格。 <br><br><h3> 错误条件和返回搜索 </h3><br> 有时，WFC算法达到一种状态，其中该单元不对应于任何可能的模块。 在我们要处理的世界有限的应用程序中，您可以简单地重置结果并重新开始。 在无限的世界中，这是行不通的，因为已经向玩家展示了世界的一部分。 首先，我确定了一个解决方案，在该解决方案中，发生错误的位置用白色块填充。 <br><br> 我目前正在使用退货搜索。 单元崩溃的顺序和有关限制分布的一些信息以历史记录的形式存储。 如果WFC算法失败，则部分历史记录将被取消。 通常，这是可行的，但是有时错误识别得太晚了，返回搜索涉及很多步骤。 在极少数情况下，会重新生成播放器所在的单元。 <br><br> 我认为，由于此限制，具有无限世界的WFC算法的应用不适用于商业游戏。 <br><br><h3> 背景知识 </h3><br> 在观看了<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">奥斯卡·斯泰尔伯格（Oscar Stelberg）关于</a>他如何使用该算法在游戏Bad North中生成关卡<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">的演讲</a>后，我开始着手这项任务。 通常，我的算法是在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">procjam</a>的一周内<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">实现的</a> 。 <br><br> 我有一些进一步完善此算法的想法，但不确定是否有一天会添加游戏性。 而且，如果我聚在一起-当然，这将不是您已经想象的那样史诗般的策略。 但是，如果您想检查自己喜欢的游戏机制如何使用此算法，请自己尝试！ 最后，源代码是公开可用的，并由MIT许可。 </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN455004/">https://habr.com/ru/post/zh-CN455004/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN454990/index.html">“建议您养猫”-初创公司如何在Product Hunt上射击</a></li>
<li><a href="../zh-CN454994/index.html">无线充电的优点是什么，为什么它的前途是未来？ 2019年的个人经历</a></li>
<li><a href="../zh-CN454998/index.html">朱莉娅和并行计算</a></li>
<li><a href="../zh-CN455000/index.html">小心翼翼地与妻子搬到荷兰。 第3部分：工作，同事和其他生活</a></li>
<li><a href="../zh-CN455002/index.html">欢迎来到9月的顶级3D博览会</a></li>
<li><a href="../zh-CN455006/index.html">具有290个16位字的程序的三命令远程控制</a></li>
<li><a href="../zh-CN455008/index.html">语义网和链接数据。 更正和补充</a></li>
<li><a href="../zh-CN455012/index.html">蜂窝拦截常见问题解答：什么是IMSI拦截器/ SCAT，我可以预防它们吗？</a></li>
<li><a href="../zh-CN455016/index.html">我们创建一个拥有理想评分的人迹罕至的网站Lighthouse</a></li>
<li><a href="../zh-CN455018/index.html">大爱小企业的职位</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>