<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👐🏽 🚩 👩🏻‍⚖️ Optimasi atau cara tidak menembak diri sendiri di kaki 🧘 👎🏽 🖋️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hari baik untuk semua Hari ini saya ingin berbicara dengan Anda tentang pengoptimalan. Apa itu, mengapa itu diperlukan, dan yang paling penting, bagai...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Optimasi atau cara tidak menembak diri sendiri di kaki</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/469127/"><p>  Hari baik untuk semua  Hari ini saya ingin berbicara dengan Anda tentang pengoptimalan.  Apa itu, mengapa itu diperlukan, dan yang paling penting, bagaimana memastikan bahwa itu tidak menyakitkan saat itu. </p><br><a name="habracut"></a><p>  Pertama-tama, kita akan mengerti apa itu optimasi secara umum, dan apa itu optimasi di JS.  Jadi, optimasi adalah peningkatan sesuatu sesuai dengan karakteristik kuantitatif.  JS mengidentifikasi empat karakteristik kuantitatif untuk dirinya sendiri: </p><br><p>  <b>Jumlah kode</b> - secara umum diterima bahwa semakin sedikit baris kode yang ditulis, semakin produktif dan lebih baik.  Pendapat saya berbeda secara mendasar, karena dengan menulis satu baris kode Anda dapat membuat kebocoran memori atau siklus abadi sehingga browser mati. </p><br><p>  <b>Kecepatan (kinerja)</b> adalah kompleksitas komputasi yang disebut, yaitu, jumlah tindakan yang perlu dilakukan parser untuk menjalankan instruksi. </p><br><p>  <b>Kecepatan build</b> - bukan rahasia lagi bahwa sekarang hampir tidak ada proyek yang dapat dilakukan tanpa pembangun seperti Webpack atau Gulp, oleh karena itu karakteristik ini menampilkan kebenaran pengaturan pembangun proyek.  Percayalah, ketika server sedikit lebih pintar dari penggiling kopi, itu menjadi penting. </p><br><p>  <b>Penggunaan kembali kode</b> - karakteristik ini menunjukkan seberapa baik arsitektur untuk menggunakan kembali fungsi, komponen, modul dibangun. <br>  Pertimbangkan masing-masing kategori secara lebih rinci, kami akan menganalisis karakteristik apa yang dicakupnya dan bergantung pada apa. </p><br><p>  <b>Volume Kode:</b> <br><br></p><ul><li>  Dubbing.  Berapa banyak kode dari jenis yang sama ditulis di tempat yang berbeda; </li><li>  Komentar  Komentar dalam kode itu baik, tetapi saya telah menemukan proyek di mana ada lebih banyak komentar daripada kode; </li><li>  Kurangnya unifikasi.  Contoh yang baik dari masalah seperti itu adalah fungsi yang serupa, yang memiliki nuansa tergantung pada beberapa properti. </li><li>  Kehadiran kode mati.  Cukup sering dalam proyek ada fungsi debugging atau fungsi yang tidak digunakan sama sekali. </li></ul><br><p>  <b>Kinerja:</b> </p><br><ul><li>  Menggunakan mekanisme caching browser; </li><li>  Optimasi kode berdasarkan pada lingkungan di mana ia akan dieksekusi; </li><li>  Adanya kebocoran memori; </li><li>  Menggunakan pekerja web; </li><li>  Menggunakan referensi ke elemen pohon DOM; </li><li>  Penggunaan variabel global; </li><li>  Kehadiran panggilan rekursif; </li><li>  Penyederhanaan perhitungan matematis. </li></ul><br><p>  <b>Membangun kecepatan:</b> </p><br><ul><li>  Jumlah ketergantungan eksternal; </li><li>  Konversi kode.  Ini mengacu pada jumlah potongan dan ukurannya, konversi css, perekatan file, pengoptimalan grafik, dan banyak lagi. </li></ul><br><p>  <b>Penggunaan Kembali Kode:</b> </p><br><ul><li>  Jumlah komponen; </li><li>  Pengulangan komponen </li><li>  Fleksibilitas dan penyesuaian. </li></ul><br><p>  Seperti yang dikatakan dalam artikel sebelumnya, untuk mengubah sesuatu, Anda perlu menentukan titik awal dan mencari tahu seberapa buruk semuanya.  Di mana harus memulai proses yang sangat produktif?  Mulailah dengan hal yang paling sederhana: percepat perakitan dan memotong waktu kelebihan dari proyek.  Anda bertanya mengapa layak memulai dengan ini?  Karena kenyataan bahwa mereka saling bergantung.  Mengurangi jumlah kode akan meningkatkan kecepatan membangun, dan, akibatnya, meningkatkan produktivitas Anda. </p><br><p>  Optimalisasi waktu pembuatan tidak dapat dihindari memperkenalkan kita pada konsep “Dingin” - ini adalah proses ketika proyek dimulai dari awal dan sampai pada titik di mana semua ketergantungan dipengaruhi dan kode sepenuhnya dikompilasi ulang.  Jangan bingung dengan Rebild - ini adalah membangun kembali kode klien tanpa menarik dependensi eksternal dan perada lainnya. </p><br><p>  Untuk meningkatkan kecepatan build akan membantu: </p><br><ul><li>  Menggunakan perakit modern.  Teknologi tidak tinggal diam, dan jika Anda memiliki webpack pertama, maka ketika Anda pindah ke keempat Anda akan melihat peningkatan yang menyenangkan sudah tidak melakukan apa-apa; </li><li>  Menyingkirkan semua kecanduan yang mati.  Dari waktu ke waktu, pengembang, berusaha menemukan kebenaran di dasar kaleng asam sulfat, lupa untuk membersihkan setelah eksperimen mereka sendiri. Kolega saya pernah bertanya: "Apakah dependensi yang ditulis dalam package.json, tetapi tidak diimpor di mana pun dalam kode, masuk ke dalam paket bundel? "  Ya, mereka tidak akan dimasukkan dalam majelis itu sendiri, tetapi paket itu akan dikempiskan.  Pertanyaannya adalah, mengapa? </li><li>  Bagilah rakitan menjadi beberapa profil tergantung pada kebutuhan Anda.  Minimal dua: prod dan dev.  Contoh kasus: kekaburan kode.  Pada prod, ini wajib, karena lebih sedikit berat = pemuatan lebih cepat, tetapi pada kebingungan dev hanya mengganggu dan menghabiskan waktu build pada manipulasi yang tidak perlu; </li><li>  Paralelisasi langkah perakitan individu; </li><li>  Menggunakan klien npm yang dapat melakukan cache. </li></ul><br><p>  Mempercepat pembangunan kembali dan bangunan "dingin" akan membutuhkan memotong komentar yang tidak perlu dan potongan kode.  Namun, apa yang harus dilakukan jika Anda memiliki proyek besar dan tidak mungkin untuk memeriksanya sendiri?  Dalam kasus seperti itu, penganalisa kode datang untuk menyelamatkan. </p><br><p>  Secara pribadi, saya secara berkala menggunakan <b>SonarQube</b> , bukan yang terbaik, tetapi fleksibel.  Dapat diajarkan fitur-fitur proyek, jika ada.  Dari waktu ke waktu ia melakukan hal-hal yang setidaknya berdiri, setidaknya jatuh, tetapi, seperti instrumen apa pun, ia harus dapat menggunakannya dan tidak lupa untuk bersikap skeptis tentang pernyataannya.  Terlepas dari semua kelemahannya, ia berupaya keras untuk mencari kode mati, komentar, keberadaan copy-paste dan hal-hal kecil, seperti kurangnya perbandingan yang ketat. </p><br><p>  Perbedaan utama antara SonarQube dan ESlint / TSLint / Prettier dan lainnya seperti mereka adalah bahwa ia memeriksa kualitas kode, mengisolasi dubbing, kompleksitas perhitungan, dan juga memberikan rekomendasi pada perubahan yang diperlukan.  Analog cukup memeriksa kode untuk kesalahan, sintaksis dan format. </p><br><p>  Dalam praktiknya, saya menemukan <b>codacy</b> , layanan yang bagus dengan berlangganan gratis dan berbayar.  Ini akan berguna jika Anda perlu memeriksa sesuatu di samping, tanpa harus menggunakan 'pemanen' ini di rumah.  Ini memiliki antarmuka yang intuitif, indikasi rinci tentang apa yang salah dengan kode dan banyak lagi. </p><br><p>  Pada artikel ini saya tidak akan menyentuh pada topik pengaturan membangun, potongan dan sisanya, karena semuanya tergantung pada kebutuhan proyek dan pembangun yang diinstal.  Mungkin saya akan membicarakan ini di artikel lain. </p><br><p>  Manipulasi yang dilakukan membantu mempercepat perakitan - untung, tapi bagaimana selanjutnya?  Karena analis dapat menemukan dubbing kode, akan berguna untuk menempatkannya dalam modul atau komponen terpisah, sehingga meningkatkan penggunaan kembali kode. </p><br><p>  Hanya ada satu bagian yang tidak kami sentuh - kecepatan kode itu sendiri.  Mekanisme untuk membawa produktivitasnya disebut oleh semua kata yang dibenci refactoring.  Mari kita lihat lebih dekat apa yang layak dilakukan saat refactoring dan apa yang tidak. </p><br><p>  Aturan hidup: jika berfungsi, jangan menyentuhnya, seharusnya tidak membimbing Anda dalam proses ini.  Aturan pertama di IT: lakukan backup, maka Anda akan mengucapkan terima kasih pada diri sendiri.  Di depan, sebelum melakukan perubahan, lakukan tes agar tidak kehilangan fungsionalitas di masa mendatang.  Lalu tanyakan pada diri Anda - bagaimana menentukan waktu muat dan kebocoran memori? </p><br><p>  Ini akan membantu DevTool.  Itu tidak hanya akan menunjukkan kebocoran memori, memberi tahu Anda waktu buka halaman, drawdown pada animasi, dan jika Anda beruntung, itu akan melakukan audit untuk Anda, tetapi ini tidak akurat.  DevTools juga memiliki fitur yang bagus, seperti membatasi kecepatan unduh, yang memungkinkan Anda untuk memprediksi kecepatan pemuatan halaman dengan Internet yang buruk. </p><br><p>  Kami dapat mengidentifikasi masalah, sekarang mari kita selesaikan! </p><br><p>  Untuk memulai, kami akan mengurangi waktu pemuatan menggunakan mekanisme caching browser.  Browser dapat melakukan cache semua dan selanjutnya menyediakan data dari cache kepada pengguna.  Penyimpanan lokal dan penyimpanan sesi tidak ada yang mengambil dari Anda.  Mereka memungkinkan Anda untuk menyimpan beberapa data yang membantu mempercepat SPA selama unduhan berikutnya dan mengurangi permintaan server yang tidak perlu. </p><br><p>  Diperlukan untuk mengoptimalkan kode berdasarkan lingkungan di mana ia akan dieksekusi, tetapi seperti yang ditunjukkan oleh praktik, ia memakan banyak waktu dan upaya, sementara tidak membawa peningkatan yang nyata.  Saya mengusulkan untuk mempertimbangkan ini hanya sebagai rekomendasi. <br>  Secara alami disarankan untuk menghilangkan semua kebocoran memori.  Saya tidak akan fokus pada ini, saya pikir semua orang tahu bagaimana menghilangkannya, dan jika tidak, maka google saja. </p><br><p>  Asisten kami yang lain adalah pekerja web.  Pekerja web adalah utas yang dimiliki browser yang dapat digunakan untuk mengeksekusi kode JS tanpa memblokir loop acara.  Pekerja web dapat melakukan tugas yang berat dan panjang secara komputasi tanpa memblokir aliran antarmuka pengguna.  Bahkan, ketika digunakan, perhitungan dilakukan secara paralel.  Di depan kami adalah multithreading yang nyata.  Ada tiga jenis pekerja web: </p><br><ol><li>  Pekerja yang Berdedikasi - Contoh pekerja web khusus dibuat oleh proses utama.  Hanya proses itu sendiri yang dapat bertukar data dengan mereka. </li><li>  Pekerja Bersama (Pekerja Bersama) - Akses ke pekerja bersama dapat diperoleh dengan proses apa pun yang memiliki sumber yang sama dengan pekerja (misalnya, tab browser yang berbeda, iframe, dan pekerja bersama lainnya). </li><li>  Pekerja Layanan adalah pekerja yang didorong oleh peristiwa yang terdaftar menggunakan sumber dan jalur mereka.  Mereka dapat mengontrol halaman web yang terhubung dengan mereka dengan mencegat dan memodifikasi perintah navigasi dan permintaan sumber daya, dan menyimpan data yang bisa dikontrol dengan sangat tepat.  Semua ini memberi kami alat yang sangat baik untuk mengontrol perilaku aplikasi dalam situasi tertentu (misalnya, ketika jaringan tidak tersedia). </li></ol><br><p>  Cara bekerja dengan mereka dapat dengan mudah ditemukan di Internet. </p><br><p>  Kami semacam mencari tahu pendekatan dan proubles pihak ketiga, sekarang saya mengusulkan untuk berbicara tentang kode itu sendiri. </p><br><p>  Pertama-tama, cobalah untuk menyingkirkan panggilan langsung ke pohon DOM, karena ini adalah operasi yang memakan waktu.  Mari kita bayangkan bahwa Anda terus-menerus memanipulasi semacam objek dalam kode Anda.  Alih-alih bekerja dengan objek ini dengan referensi, Anda terus-menerus menarik pohon DOM untuk mencari elemen ini dan bekerja dengannya, dan kami menerapkan pola caching dalam kode. </p><br><p>  Langkah kedua adalah menyingkirkan variabel global.  ES6 memberi kami penemuan luar biasa dari umat manusia yang disebut variabel blok (dalam istilah sederhana, deklarasi variabel dari <b>var</b> ke <b>let</b> dan <b>const</b> ). </p><br><p>  Dan akhirnya, yang paling enak.  Di sini, sayangnya, tidak semua orang memiliki pengalaman yang cukup untuk memahami nuansa tersebut.  Saya menentang penggunaan fungsi rekursif.  Ya, mereka mengurangi jumlah kode tertulis, tetapi itu tidak dapat dilakukan tanpa tangkapan: seringkali fungsi rekursif seperti itu tidak memiliki kondisi keluar, mereka hanya dilupakan.  Seperti dalam pepatah "Anda dapat mematahkan jari dengan palu, tetapi ini bukan masalah palu, tetapi pemilik jari" atau lelucon tentang kucing: fungsi rekursif tidak buruk, Anda harus dapat memasaknya. </p><br><p>  Terlepas dari semua kekuatan aplikasi front-end modern, Anda tidak boleh melupakan dasar-dasarnya.  Contoh yang jelas tentang pemborosan dan irasionalitas adalah penambahan elemen baru ke awal array.  Siapa tahu, dia mengerti, dan dia yang tidak - sekarang saya akan memberi tahu.  Semua orang tahu bahwa elemen array memiliki indeksnya sendiri, dan ketika kita akan menambahkan elemen array baru ke permulaannya, urutan tindakannya adalah sebagai berikut: </p><br><ol><li>  Definisi panjang array </li><li>  Penomoran masing-masing elemen. </li><li>  Pergeseran setiap elemen array </li><li>  Masukkan item baru ke dalam array </li><li>  Mengindeks ulang elemen array. </li></ol><br><p>  <b>Ringkasan:</b> </p><br><p>  Saatnya untuk mengakhiri, dan bagi mereka yang merasa nyaman dengan format memo, simpan daftar langkah-langkah berkat yang dapat Anda pahami pada tahap optimasi apa Anda sekarang dan apa yang harus dilakukan selanjutnya: </p><br><ol><li>  Kami menentukan berapa banyak semuanya baik / buruk, hapus metrik. </li><li>  Kami memotong semua yang tidak perlu: dependensi yang tidak digunakan, kode mati, komentar yang tidak perlu. </li><li>  Kami menyesuaikan dan mempercepat waktu perakitan, mengonfigurasi profil yang berbeda untuk kontur. </li><li>  Kami menganalisis kode dan memutuskan bagian mana yang akan kami optimalkan dan tulis ulang. </li><li>  Kami sedang menulis tes untuk mencegah hilangnya fungsionalitas. </li><li>  Kami mulai refactoring, menyingkirkan variabel global, kebocoran memori, kode dubbing dan sampah lainnya, dan jangan lupa tentang caching. </li><li>  Kami menyederhanakan kerumitan perhitungan dan mengambil segala yang mungkin untuk pekerja web. </li></ol><br><p>  Semuanya tidak serumit kelihatannya pada pandangan pertama.  Urutan Anda mungkin akan berbeda dari urutan saya, jika hanya karena Anda memiliki kepala sendiri di pundak Anda.  Anda akan menambahkan item baru atau, sebaliknya, mengurangi jumlahnya, tetapi dasar dari daftar akan serupa.  Saya secara khusus menggambarkan pembagian sehingga kegiatan ini dapat berjalan paralel dengan pekerjaan utama.  Seringkali pelanggan tidak siap untuk membayar pengerjaan ulang, setuju? </p><br><p>  <b>Dan akhirnya.</b> </p><br><p>  Saya percaya pada Anda, dan bahwa Anda akan berhasil.  Apakah Anda pikir saya naif?  Saya kira Anda akan terkejut, tetapi karena Anda menemukan artikel ini, bacalah sampai akhir, itu berarti (saya punya kabar baik untuk Anda), Anda memiliki otak, dan Anda berusaha mengembangkannya.  Saya berharap Anda sukses dalam usaha yang sulit seperti mengoptimalkan bagian depan! </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id469127/">https://habr.com/ru/post/id469127/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id469111/index.html">Ganti Obyek dengan var: apa yang bisa salah?</a></li>
<li><a href="../id469115/index.html">Panduan Discovery.js: Mulai Cepat</a></li>
<li><a href="../id469117/index.html">Pemrograman di bawah BC 0010 pada tahun 2019</a></li>
<li><a href="../id469119/index.html">Alamat IPv4 di RIPE sudah berakhir. Benar-benar selesai ...</a></li>
<li><a href="../id469125/index.html">Tema gelap Thunderbird sebagai alasan untuk menjalankan penganalisis kode</a></li>
<li><a href="../id469129/index.html">Karena tema yang gelap, Thunderbird harus menjalankan penganalisa kode</a></li>
<li><a href="../id469131/index.html">Jin</a></li>
<li><a href="../id469133/index.html">Gadget apa yang diperkenalkan Amazon di Peranti Kerasnya 2019</a></li>
<li><a href="../id469135/index.html">Kesalahpahaman umum tentang OOP</a></li>
<li><a href="../id469137/index.html">Otak adalah batas terakhir privasi</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>