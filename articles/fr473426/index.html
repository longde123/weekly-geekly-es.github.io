<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>↔️ 🤞 🐼 Automatisation des tests End-2-End d'un système d'information intégré. Partie 1. Organisationnelle 👸🏼 🏞️ 👦🏿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Avec cet article, nous ouvrons une série de publications sur la façon dont nous avons automatisé le processus de test manuel d'un grand système d'info...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Automatisation des tests End-2-End d'un système d'information intégré. Partie 1. Organisationnelle</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/lanit/blog/473426/">  Avec cet article, nous ouvrons une série de publications sur la façon dont nous avons automatisé le processus de test manuel d'un grand système d'information dans l'un des principaux projets de LANIT et sur les résultats. <br><br>  <i>La première partie - organisationnelle et managériale - devrait être utile principalement à ceux qui sont chargés de tester l'automatisation et de créer de tels systèmes dans leur ensemble.</i>  <i>Les chefs de projet, chefs de groupe et propriétaires de services de tests fonctionnels et automatiques, <b>tous soucieux de la question «comment construire un test de bout en bout rentable de leur système informatique», trouveront ici un plan et une méthodologie spécifiques.</b></i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8f3/664/45f/8f366445ff952429d3a43ff7911ef34d.jpg"></div>  <i><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Source</a></i> <br><a name="habracut"></a><br><h1>  Partie 1 - Organisationnelle et managériale.  Pourquoi avons-nous eu besoin d'automatisation.  Organisation du processus de développement et de gestion.  Organisation d'utilisation </h1><br>  Au départ, il y avait au départ un système d'information vaste et complexe (nous l'appellerons le «Système») avec de nombreux scénarios d'affaires complexes, longs et interconnectés.  Tous les scripts ont été testés en tant qu'E2E via des interfaces Web exclusivement en mode manuel (il y avait plus d'un millier et demi de ces scénarios de la priorité la plus critique uniquement).  De plus, tous ces scénarios devaient être exécutés au moins une fois lors de la régression de chaque nouvelle version ou correctif avant la prochaine mise à jour du déploiement du produit. <br><br>  À un certain moment, quand il est devenu complètement insupportable de cliquer sur la souris en mode manuel, ils ont décidé d'automatiser tout cela.  C'est ce qu'ils ont fait à travers le développement d'un service séparé basé sur java + sélénium + séléniure + sélénoïde, qui est également appelé <b>"cadre de test"</b> ou simplement <b>"Autotests"</b> . <br><br>  Historiquement, le code du framework de test a été développé par deux équipes.  Tout d'abord, la première équipe a créé un prototype avec quelques dizaines de scénarios.  Ensuite, la deuxième équipe pendant un an a mis à l'échelle le prototype à la fois en largeur (nombre de tests) et en profondeur (des modèles de codage et de mise en œuvre typiques ont été introduits). <br><br>  Je suis l'équipe et le chef d'équipe de la deuxième équipe, qui a adopté le cadre prototype pour la mise à l'échelle (en mai 2018). <br><br>  Au moment d'écrire ces lignes, la tâche définie il y a un an était terminée et l'équipe de projet a bénéficié d'un <u><b>service d'</b></u> automatisation stable.  Ce n'est pas en vain que j'ai insisté sur le <u><b>service</b></u> , car initialement la tâche n'était pas définie comme le développement d'une application, mais comme la fourniture d'un service-service pour tester l'automatisation à un groupe de «tests fonctionnels».  Et cette fonctionnalité a par la suite grandement influencé l'organisation du développement et l'architecture du cadre de test. <br><br><blockquote><h2>  Résumé </h2><br>  Environ 1 500 scénarios de test ont été automatisés: dans chaque test, de 200 à 2 000 opérations utilisateur. <br><br>  La capacité totale du service est jusqu'à 60 navigateurs fonctionnant simultanément, et ce n'est pas la limite (le nombre peut être multiplié par 5 en raison de machines virtuelles). <br>  La durée totale d'une régression complète ne dépasse pas 3 heures et le test PreQA est inférieur à une heure. <br><br>  Une large gamme de fonctionnalités a été implémentée: <br><br><ul><li>  utilisation locale (exécution en temps réel) et à distance (via des plans Bamboo); </li><li>  limiter la composition des tests en cours par filtre; </li><li>  un rapport détaillé avec les résultats de chaque étape du scénario de test (via le framework Allure); </li><li>  télécharger et télécharger des fichiers depuis / vers le navigateur, puis vérifier les résultats de leur traitement en termes de format et de contenu des fichiers; </li><li>  comptabilité et contrôle de la nature asynchrone de l'interface angulaire.  Y compris le contrôle des requêtes bloquées (requête en attente) entre les services Angular et REST; </li><li>  contrôle des journaux du navigateur; </li><li>  enregistrement de test vidéo; </li><li>  suppression de l'instantané de la page au moment de la "chute" du test; </li><li>  transmission d'événements en ELK; </li><li>  beaucoup plus sur les petites choses ... </li></ul><br></blockquote><br><h1>  Pourquoi tout cela était-il nécessaire? </h1><br>  Au début, le but du système était assez simple et clair. <br><br>  Imaginez que vous disposez d'un grand système de registre pour gérer une vaste gamme de documents et leur cycle de vie, qui fournissent quelques centaines de processus métier.  De plus, il y a des millions de personnes, des fournisseurs - des dizaines de milliers, des services - des milliers, des documents complexes, y compris le cadre et le modèle, et les processus métier sont fournis de centaines de façons différentes ... <br><br>  Tout cela se transforme en mille cinq cents scénarios de test, et ce n'est que la priorité la plus élevée et seulement positive. <br><br>  Dans le processus d'automatisation, diverses nuances ont été révélées qui nécessitaient l'utilisation de diverses solutions. <br><br>  Par exemple, un script peut contenir jusqu'à des centaines d'opérations distinctes, y compris des opérations intéressantes telles que: «Téléchargez un fichier EXCEL avec des données et vérifiez que le système traite chaque enregistrement du fichier» (pour résoudre ce problème, il a fallu plusieurs étapes pour préparer les données, puis vérifier le résultat du chargement dans Système).  Et maintenant, nous ajoutons la restriction de la réutilisation des données de test: les données de test pour la réussite de la plupart des scénarios de test doivent être «fraîches» et non utilisées auparavant dans des scénarios similaires (pendant les tests, l'état des données dans le système change, par conséquent, elles ne peuvent pas être réutilisées pour les mêmes contrôles). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/242/0a7/ccc/2420a7ccc161bb7ee6537a73cd6bd33a.jpg"></div>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Source</a> <br><br>  À un moment donné, les tests manuels du système dans le cadre de la régression ont cessé de sembler rentables et assez rapides, et ils ont décidé de l'automatiser via l'interface utilisateur Web. <br><br>  En d'autres termes, le groupe de tests fonctionnels ouvre la «page», sélectionne le «groupe de tests», appuie sur le bouton «exécuter» (nous avons utilisé Bamboo).  Ensuite, les autotests (ci-après dénommés autotests. Désignez le produit créé pour les tests en général) émulent automatiquement les actions des utilisateurs du système via le navigateur («appuyez» sur les boutons nécessaires, entrez des valeurs dans les champs, etc.), une fois terminé, affichez un rapport détaillé sur tous étapes et actions terminées et résultats de la vérification (correspondance de la réaction attendue du système avec son comportement réel). <br><br>  Total, le but des autotests est l'automatisation des tests E2E manuels.  Il s'agit d'un système «externe» qui ne participe pas au processus de développement du système sous test et n'est en aucun cas lié aux tests unitaires ou d'intégration utilisés par les développeurs. <br><br><h2>  Buts </h2><br>  Il était nécessaire de réduire considérablement les coûts de main-d'œuvre pour effectuer des tests End-2-End et d'augmenter la vitesse des régressions complètes et réduites en termes de volume. <br><br><div class="spoiler">  <b class="spoiler_title">Objectifs supplémentaires</b> <div class="spoiler_text"><ul><li>  assurer une vitesse de développement élevée des autotests avec un haut niveau d'autonomie (la nécessité de remplir préalablement les données de test des stands du système / de configurer les autotests pour chaque stand devrait être minimisée); </li><li>  optimiser les dépenses (de temps et financières) pour les communications entre les équipes d'automatisation, de tests fonctionnels et de développement de systèmes; </li><li>  minimiser le risque de divergences entre les autotests effectivement mis en œuvre et les attentes initiales de l'équipe de tests fonctionnels (l'équipe de tests fonctionnels doit faire confiance sans condition aux résultats des autotests). </li></ul></div></div><br><h2>  Les tâches </h2><br>  La tâche principale du développement a été formulée très simplement - automatiser au cours des 6 prochains mois 1000 scénarios de test de la plus haute priorité. <br><br>  Le nombre prévu d'actions de test de base variait de 100 à 300, ce qui nous a donné environ 200 mille méthodes de test avec 10 à 20 lignes de code, sans tenir compte des classes générales et auxiliaires d'aides, des fournisseurs de données et des modèles de données. <br><br>  Ainsi, il s'est avéré que, compte tenu des contraintes de temps (130 jours ouvrables), il était nécessaire de faire au moins 10 tests par jour et en même temps de s'assurer de la pertinence des autotests mis en œuvre en tenant compte des changements intervenus dans le Système (le Système se développe activement). <br><br>  Selon des estimations d'experts, le travail requis pour développer un autotest était de 4 à 8 heures.  Nous avons donc au moins une équipe de 5 personnes (en réalité, au plus fort du développement des autotests, l'équipe comptait plus de 10 ingénieurs en automatisation). <br><br>  Les tâches à résoudre étaient également compréhensibles. <br><br><ul><li>  <b>Configurer les processus et la commande:</b> </li><li>  définir le processus d'interaction avec le client (groupe de test fonctionnel), fixer le format de description du cas de test comme entrée pour l'équipe d'automatisation; </li><li>  organiser le processus de développement et de maintenance; </li><li>  former une équipe. <br></li><li>  <b>Développez des autotests avec les fonctionnalités suivantes:</b> </li><li>  cliquer automatiquement sur les boutons du navigateur avec une vérification préalable de la présence d'éléments et des informations nécessaires sur la page; </li><li>  fournir du travail avec des éléments complexes tels que Yandex.Map; </li><li>  assurer le chargement des fichiers générés automatiquement dans le système, assurer le téléchargement des fichiers du système avec vérification de leur format et de leur contenu. </li><li>  Fournissez un enregistrement à partir des captures d'écran du navigateur, des vidéos et des journaux internes. </li><li>  Pour offrir la possibilité de s'intégrer à des systèmes externes comme un serveur de messagerie, le système de suivi des tâches (JIRA) permet de vérifier les processus d'intégration entre le système testé et les systèmes externes. </li><li>  Fournissez un rapport documenté sur toutes les mesures prises, y compris un affichage des valeurs saisies et vérifiées, ainsi que tous les investissements nécessaires. </li><li>  Effectuez des tests dans le volume requis en mode parallèle. </li><li>  Déployez des autotests dans l'infrastructure existante. </li><li>  Affinez les scripts de test déjà automatisés du concept de cible consonantique (vitesse de raffinement - environ 50 tests par sprint hebdomadaire). </li></ul><br>  Comme je l'ai mentionné dans l'introduction, au début, nous avions un prototype MVP fonctionnel mis en œuvre par une autre équipe, qui devait être augmenté de 20 tests à 1000, ajoutant de nouvelles fonctionnalités en cours de route, et garantissant une évolutivité et une flexibilité acceptables pour apporter des modifications. <br><br>  La présence d'un prototype fonctionnel en plus à l'entrée nous a donné une pile technologique, qui comprenait: Java SE8, JUnit4, Selenium + Selenide + Selenoid, Bamboo en tant que «coureur» de tests et «constructeur» de rapports Allure.  Comme le prototype fonctionnait bien et offrait les fonctionnalités de base nécessaires, nous avons décidé de ne pas modifier la pile technologique, mais de nous concentrer sur le développement de l'évolutivité de la solution, l'augmentation de la stabilité et le développement des fonctionnalités requises manquantes. <br><br>  Fondamentalement, tout semblait réalisable et optimiste.  De plus, nous avons complètement fait face aux tâches à un moment donné. <br><br>  Ce qui suit décrit les aspects technologiques et de processus individuels du développement des tests automatiques. <br><br><h1>  Description des autotests.  Histoires d'utilisateurs et fonctionnalités </h1><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/345/e52/429/345e524291244a67e411a344257eafa8.png"></div>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Source</a> <br><br>  Les autotests implémentent l'ensemble d'histoires utilisateur suivant dans le contexte de leur utilisation par le groupe de test: <br><br><ul><li>  automatisation manuelle des tests; </li><li>  régression complète automatique; </li><li>  contrôle qualité des assemblages de la chaîne CI \ CD. </li></ul><br>  Les détails de mise en œuvre et les décisions architecturales seront discutés dans la <b>Partie 2 - Technique.</b>  <b>Architecture et pile technique.</b>  <b>Détails de mise en œuvre et surprises techniques</b> . <br><br><h2>  Tests automatiques et manuels (User stories) </h2><br>  En tant que testeur, je souhaite effectuer le test E2E cible, qui sera réalisé sans ma participation directe (en mode automatique) et me fournira un rapport détaillé dans le cadre des étapes franchies, y compris les données saisies et les résultats obtenus, ainsi que: <br><br><ul><li>  Il devrait être possible de sélectionner différents peuplements cibles avant de commencer le test; </li><li>  devrait être capable de gérer la composition des tests en cours de tous les implémentés; </li><li>  à la fin du test, vous devez obtenir une vidéo du test à partir de l'écran du navigateur; </li><li>  lorsque le test se bloque, vous devez obtenir une capture d'écran de la fenêtre du navigateur actif. </li></ul><br><h2>  Régression complète automatique </h2><br>  En tant que groupe de test, je souhaite effectuer tous les tests tous les soirs sur un banc de test particulier en mode automatique, y compris toutes les fonctionnalités du "Test manuel automatique". <br><br><h2>  Contrôle qualité des assemblages dans la chaîne CI \ CD </h2><br>  En tant que groupe de test, je souhaite effectuer des tests automatiques des mises à jour déployées du système sur un stand pré-QA dédié avant de mettre à jour les stands de l'étape de test fonctionnel cible, qui ont ensuite été utilisés pour les tests fonctionnels. <br><br><h1>  Fonctionnalités de base implémentées </h1><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/347/92c/432/34792c43244275202d123378b2b6b72e.jpg"></div>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Source</a> <br><br>  Voici un bref ensemble des principales fonctions implémentées des tests automatiques, qui se sont avérées essentielles ou simplement utiles.  Les détails de la mise en œuvre de certaines fonctions intéressantes seront dans la deuxième partie de l'article. <br><br><h2>  Utilisation locale et à distance </h2><br>  La fonction offrait deux options pour exécuter les autotests - local et distant. <br><br>  En mode local, le testeur a exécuté l'autotest requis sur son lieu de travail et a pu observer en même temps ce qui se passait dans le navigateur.  Le lancement s'est fait à travers le "triangle vert" dans IntelliJ IIDEA -).  La fonction était très utile au début du projet pour le débogage et les démonstrations, mais maintenant elle n'est utilisée que par les développeurs d'autotests. <br><br>  En mode distant, le testeur démarre l'autotest en utilisant l'interface du plan Bamboo avec les paramètres de la composition des tests en cours, un stand et quelques autres paramètres. <br><br>  <i>La fonction a été implémentée à l'aide de la variable d'environnement MODE = REMOTE | LOCAL, selon le navigateur Web local ou distant qui a été initialisé dans le cloud <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Selenoid</a> .</i> <br><br><h2>  Limiter la composition des tests en cours par filtre </h2><br>  La fonction permet de limiter la composition des tests en cours en mode d'utilisation à distance pour la commodité des utilisateurs et de réduire le temps de test.  Une filtration en deux étapes est utilisée.  La première étape bloque l'exécution des tests basés sur la variable FILTER_BLOCK et sert principalement à exclure de grands groupes de tests de l'exécution.  La deuxième étape «ignore» uniquement les tests qui correspondent à la variable FILTER. <br><br>  La valeur des filtres est spécifiée comme un ensemble d'expressions régulières REGEXP1, ..., REGEXPN, appliquées par le principe de "OU". <br><br>  Lors du démarrage en mode manuel, il a été demandé au testeur de définir une variable d'environnement spéciale en tant que liste d'expressions régulières applicables à l'annotation spéciale @ Filter (valeur de chaîne), qui annotait toutes les méthodes de test dans les classes de test.  Pour chaque test, cette annotation est unique et est construite sur la base d'un ensemble de balises séparées par un trait de soulignement.  Nous utilisons le modèle minimum suivant SUBSYSTEM_FUNCTION_TEST-ID_ {DEFAULT}, où la balise DEFAULT est pour les tests inclus dans la régression nocturne automatique. <br><br>  <i>La fonction est implémentée via une extension personnalisée de la classe org.junit.runners.BlockJUnit4ClassRunner (les détails seront donnés dans la partie 2-1 de la suite de cet article)</i> <br><br><h2>  Documenter le rapport avec les résultats pour toutes les étapes </h2><br>  Les résultats du test sont affichés pour toutes les actions de test (étapes) avec toutes les informations requises <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">disponibles</a> dans Allure Framework.  Les énumérer n'a pas de sens.  Il y a suffisamment d'informations sur le site officiel et sur Internet dans son ensemble.  Il n'y a eu aucune surprise en utilisant le framework Allure, et en général je le recommande pour son utilisation. <br><br>  Les principales fonctions utilisées sont: <br><br><ul><li>  affichage de chaque étape de test (le nom de l'étape correspond à son nom dans la spécification de test - script de test); </li><li>  afficher les paramètres d'étape sous une forme lisible par l'homme (grâce à la mise en œuvre requise de la méthode toString de toutes les valeurs transmises); </li><li>  Joindre des captures d'écran, des vidéos et divers fichiers supplémentaires au rapport; </li><li>  classification des tests par types et sous-systèmes, ainsi que la liaison de l'autotest avec la spécification de test dans le système de gestion de lien de test Test Link grâce à l'utilisation d'annotations spécialisées. </li></ul><br><h2>  Téléchargez et téléchargez des fichiers depuis / vers le navigateur avec leur vérification et analyse ultérieures </h2><br>  Travailler avec des fichiers est un aspect extrêmement important des scripts de test.  Il était nécessaire de fournir à la fois le téléchargement de divers fichiers et le téléchargement. <br><br>  <b>Le téléchargement de fichiers</b> impliquait tout d'abord le chargement de fichiers EXCEL générés dynamiquement dans le système conformément au contexte d'exécution du script de test.  Le téléchargement a été implémenté à l'aide de méthodes standard fournies par les outils de sélénium. <br><br>  <b>Le téléchargement de fichiers</b> impliquait le téléchargement de fichiers en appuyant sur le «bouton» du navigateur vers un répertoire local avec le «transfert» ultérieur de ce fichier vers le serveur sur lequel les AutoTests ont été exécutés (le serveur sur lequel l'agent Bamboo distant a été installé).  De plus, ce fichier a été analysé et analysé en termes de format et de contenu.  Les principaux types de fichiers étaient les fichiers EXCEL et PDF. <br><br>  L'implémentation de cette fonction s'est avérée être une tâche non triviale, principalement en raison du manque de capacités de gestion de fichiers standard: pour le moment, la fonction n'est implémentée que pour le navigateur Chrome via la page de service «chrome: // Downloads /». <br><br>  Je vais vous parler en détail des détails d'implémentation dans la deuxième partie. <br><br><h2>  Comptabilité et contrôle de la nature asynchrone de l'interface angulaire.  Contrôle des demandes en attente entre les services Angular et REST </h2><br>  Étant donné que l'objet de nos tests était basé sur Angular, nous avons dû apprendre à "lutter" avec la nature asynchrone du frontend et des timeouts. <br><br>  En général, en plus de org.openqa.selenium.support.ui.FluentWait, nous utilisons une méthode d'attente spécialement conçue qui vérifie via Javascript les interactions «incomplètes» avec les services REST frontaux, et sur la base de ce délai d'attente dynamique, les tests obtiennent des informations sur le suivi puis attendez encore un peu. <br><br>  Du point de vue de la fonctionnalité, nous avons pu réduire considérablement le temps nécessaire pour terminer les tests en raison du rejet des attentes statiques où il n'y a aucun moyen de déterminer différemment la fin de l'opération.  De plus, cela nous a permis de définir des services REST «suspendus» avec des problèmes de performances.  Par exemple, ils ont intercepté un service REST pour lequel le nombre d'enregistrements affichés sur la page a été défini sur 10 000 éléments. <br><br>  Des informations sur le service REST «gelé» avec tous les paramètres de son appel, pour lesquels le test «tombe» pour des raisons d'infrastructure, sont ajoutées aux résultats du test interrompu et sont également diffusées en tant qu'événement dans ELK.  Cela vous permet de transférer immédiatement les problèmes identifiés aux équipes de développement appropriées du système. <br><br><h2>  Contrôle du journal du navigateur </h2><br>  La fonction de contrôle du journal du navigateur a été ajoutée pour contrôler les erreurs sur les pages de niveau SÉVÈRE afin de recevoir des informations supplémentaires pour les tests abandonnés, par exemple, pour surveiller les erreurs comme "... Échec du chargement de la ressource: le serveur a répondu avec un état de 500 (erreur interne du serveur)". <br><br>  La composition des erreurs de traitement de page dans le navigateur est appliquée à chaque résultat de test et est également déchargée en tant qu'événements dans l'ELK. <br><br><h2>  Enregistrement vidéo du test et suppression de l'instantané de la page au point de "chute" du test </h2><br>  Les fonctions sont implémentées pour faciliter le diagnostic et l'analyse des tests abandonnés. <br><br>  L'enregistrement vidéo est activé séparément pour le mode d'exécution de test à distance sélectionné.  La vidéo est jointe en tant que pièce jointe aux résultats dans le rapport Allure. <br>  Une capture d'écran est prise automatiquement lorsque le test se bloque et les résultats sont également appliqués au rapport Allure. <br><br><h2>  Passer des événements à ELK </h2><br>  La fonction d'envoi d'événements à ELK est implémentée pour permettre une analyse statistique du comportement général des AutoTests et de la stabilité de l'objet de test.  À l'heure actuelle, des événements ont été envoyés pour terminer les tests avec les résultats et la durée, ainsi que des erreurs de navigateur de niveau SÉVÈRE et des services REST fixes de «gel». <br><br><h1>  Organisation de développement </h1><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2ee/a24/368/2eea243683bc7a87f0453db38b6c7947.jpg"></div>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Source</a> <br><br><h2>  Équipe de développement </h2><br>  Nous avions donc besoin d'au moins 5 développeurs.  Ajoutez une autre personne pour compenser les absences non planifiées.  Nous en avons 6. Plus un chef d'équipe, qui est responsable de la fonctionnalité transversale et de la révision du code. <br><br>  Ainsi, nous avons dû prendre 6 développeurs Java (en réalité, au plus fort du développement des autotests, l'équipe a dépassé 10 ingénieurs en automatisation). <br><br>  Compte tenu de l'état général du marché et d'une pile technologique assez simple, l'équipe était principalement composée de stagiaires, la plupart d'entre eux soit juste diplômés des universités, soit en dernière année.  En fait, nous recherchions des personnes ayant une connaissance de base de Java.  La préférence a été donnée aux spécialistes des tests manuels qui souhaiteraient devenir programmeurs et aux candidats motivés ayant une expérience (insignifiante) en développement qui, à l'avenir, souhaitaient devenir programmeurs. <br><br>             ,           (    <b> 2 – .    .     </b> ). <br><br>    ,           ,             .        CodeRush .    . <br><br><h2>   </h2><br>       . ,    , «»        . <br><br>           () .    code review   merge request ( GitLab).   code review   «»    (  )       . <br><br>     –           .           /   ,         . <br><br> ode review   , ,      ()   -   ,    . ode review  . <br><br>     code review         ,        . <br><br><img src="https://habrastorage.org/getpro/habr/post_images/08f/c89/1c7/08fc891c7ccd91d6e6c2235c06149a69.jpg" align="left" width="300">  :     ,      ,      ,     ,         .        ,     ,    ,    / . <br><br>      « »,      -   -.         -. <br><br>                   ,               .    sprint retrospective event. <br><br><h2>     </h2><br>         - ( )    ,      stakeholder  . <br><br>        –    .   ,            ,          .   ,      -    .       . <br><br>        - ( ,      . .),          .     () ,       « » / « » ( ,      ,            ). <br><br>  -             -   ( :    -  – ,   - ,   — ,    ).  ,       -       /  :    « -      (  )». <br><br>      -  ,     - (-)      - («» ).     «» -          -  «     X» ( ,       -). <br><br><h2>   </h2><br>     ,    .      master,    -. -   -         code review. <br><br>     ,        –     ,        . <br><br> : <br><br> <b>(+)</b>        ; <br> <b>(+)</b>              ; <br> <b>(+)</b>  «»      ; <br> <b>(-)</b>      (); <br> <b>(-)</b>       hotfix . <br><br>       . <br><br> <b></b> <br><br><ul><li>      MASTER. </li><li>  . </li><li>      FEATURE . </li><li>           ,   «   »  rebase. </li><li> <b>     Gitlab   merge request    .  merge request- :</b> </li><li>  —       «Jira»; </li><li>  —       Bamboo. </li></ul><br> <b>GateKeeper ( )</b> <br><br><ul><li>         Bamboo. </li><li>          . </li><li>  (merge) FEATURE  DEVELOP,            . </li><li>    . </li></ul><br><hr><br> <i><b>          <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" class="user_link">kotalesssk</a> . <br><br>    1,      , .         2.</b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La deuxième partie - la partie technique - est principalement axée sur les chefs de file des groupes d'automatisation, les tests d'interface utilisateur de bout en bout et l'automatisation des tests. </font><font style="vertical-align: inherit;">Ils y trouveront des recettes spécifiques pour l'organisation architecturale du code et du déploiement, qui soutiennent le développement en masse parallèle de grands groupes de tests face à la variabilité constante des spécifications de test. </font><font style="vertical-align: inherit;">De plus, vous pouvez trouver dans la deuxième partie la liste complète des fonctions nécessaires aux tests d'interface utilisateur avec quelques détails d'implémentation. </font><font style="vertical-align: inherit;">Et une liste de surprises que vous pourriez également rencontrer.</font></font></i> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr473426/">https://habr.com/ru/post/fr473426/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr473412/index.html">Création d'un plugin pour Clang Static Analyzer pour rechercher les débordements d'entiers</a></li>
<li><a href="../fr473416/index.html">Programme de la conférence ZeroNights 2019</a></li>
<li><a href="../fr473418/index.html">OSCP - Sécurité offensive</a></li>
<li><a href="../fr473420/index.html">Nous ouvrons la saison des PHP-Meetups à Nizhny Novgorod le 2 novembre</a></li>
<li><a href="../fr473424/index.html">ARM annonce les solutions graphiques Mali-G57 Valhall et Mali-D37, les neuroprocesseurs Ethos-N57 et N37</a></li>
<li><a href="../fr473428/index.html">RCS remplace SMS. Le progrès tant attendu, ou un pas en avant de deux en arrière?</a></li>
<li><a href="../fr473430/index.html">FAQ sur le travail de l'assistant chauffeur</a></li>
<li><a href="../fr473432/index.html">Trois meilleurs rapports de Saint TeamLead Conf</a></li>
<li><a href="../fr473434/index.html">Une approche systématique dans les tons turquoises à bord du June</a></li>
<li><a href="../fr473436/index.html">Transformation Le management comme compétence</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>