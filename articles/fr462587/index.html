<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🍦 🧜🏿 👩🏽‍🌾 IDE AirTest et reconnaissance d'image - Automatisation des tests de jeux mobiles basés sur la reconnaissance d'image 🚺 🚵🏻 🈚️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dans l' article précédent, nous avons rencontré AirTest IDE , mais juste au cas où, répétons: AirTest IDE a été développé par NetEase et est conçu pou...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>IDE AirTest et reconnaissance d'image - Automatisation des tests de jeux mobiles basés sur la reconnaissance d'image</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/462587/"><p> Dans l' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">article précédent,</a> nous avons rencontré <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">AirTest IDE</a> , mais juste au cas où, répétons: AirTest IDE a été développé par NetEase et est conçu pour les applications "difficiles à automatiser", telles que les jeux.  En fait, ils sont le principal objectif des développeurs, bien que cela ne cesse pas d'utiliser AirTest pour d'autres applications. </p><br><p>  Ce travail est le deuxième d'une série consacrée à l'IDE AirTest.  Vous <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">pouvez trouver le</a> premier article de synthèse sur AirTest IDE <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> , et le troisième et dernier, qui est consacré au cadre d'automatisation Poco UI, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">par ce lien</a> . </p><br><p>  Aujourd'hui, je vais vous parler de l'un des 2 principaux cadres - AirTest.  <strong>AirTest</strong> est un cadre multiplateforme pour automatiser l'interface utilisateur, basé sur les principes de la reconnaissance d'image ( <strong>Image Recognition</strong> ), qui, selon les développeurs, convient aux jeux et aux applications.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Le projet AirTest</a> sur GitHub contient 4 projets: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Airtest</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Poco</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">iOS-Tangent</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">multi-device-runner</a> . </p><br><p>  Et maintenant passons à la partie amusante! </p><br><p><img src="https://habrastorage.org/webt/hm/wq/hx/hmwqhxdmwp-ygtplkw6vn66juug.jpeg" alt="image"></p><a name="habracut"></a><br><h2 id="kak-rabotaet-airtest">  Fonctionnement d'AirTest </h2><br><p>  AirTest traite les captures d'écran résultantes en fonction du processus de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">seuillage</a> .  L'essentiel est de comparer l'intensité des pixels de l'image avec un certain nombre ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">valeur seuil</a> ) et, si la valeur du pixel est supérieure, de lui attribuer une couleur (le blanc est le plus souvent utilisé).  Sinon, une couleur différente est attribuée - le noir.  Par conséquent, la sortie est une image en noir et blanc.  Une limitation naturelle en découle - AirTest ne prend pas en compte la couleur lors de la reconnaissance.  Par exemple, si vous utilisez un objet avec la même silhouette, mais différent, par exemple, la coloration et que vous devez vérifier la présence d'un élément avec une palette de couleurs spécifique, cela sera extrêmement difficile et peut ne pas fonctionner du tout. </p><br><p>  Par exemple, dans le cadre du test IDE AirTest, il a été décidé de travailler avec le jeu <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Marvel Puzzle Quest</a> .  Lors du chargement, les personnages de cet univers de bande dessinée clignotent à l'écran dans un certain ordre.  De temps en temps, leurs costumes changent et c'est la première fois que je suis alerté.  Dans l'exemple ci-dessous, je m'attendais, dans le cadre du test, à Spider-Man dans le classique, et reçu dans un costume furtif.  En fait, le test a réussi, mais cela s'est produit à cause de ce qui précède - l'utilisation d'une image en noir et blanc pendant la reconnaissance.  Un exemple de ce qui était attendu et de ce qui s'est finalement produit: </p><br><p><img src="https://habrastorage.org/webt/wv/te/xh/wvtexhrzu8jsuqpb3qkhm86owgo.png" alt="image"></p><br><h3 id="uluchshenie-veroyatnosti-uspeshnogo-zaversheniya-testov">  Amélioration des chances de réussite des tests </h3><br><p>  Comme vous l'avez déjà compris, la reconnaissance d'image est loin d'être une panacée, bien qu'elle fonctionne bien ici.  Pour écrire des tests de qualité, vous ne pouvez pas éviter d'écrire du code et, par conséquent, de connaître les bases de Python.  Par exemple, avant de rechercher un élément spécifique, il serait bon de s'assurer qu'il est bien à l'écran.  Il y a des moments où AirTest «manque» et peut prendre le mauvais article pour celui dont vous avez besoin.  De temps en temps, il y a des problèmes avec la reconnaissance du texte que vous voulez trouver en utilisant la reconnaissance d'image.  AirTest peut confondre les résultats et supposer que le texte dont vous avez besoin est à l'écran, mais, en fait, le texte est complètement différent.  Le processus d'analyse des résultats est conçu pour simplifier le système de rapport qui est déjà intégré dans l'IDE AirTest.  Vous pouvez créer et ouvrir un rapport une fois le test / script terminé à l'aide du raccourci clavier Ctrl / Cmd + L. </p><br><p>  Selon les recommandations générales, je voudrais également souligner les points suivants. </p><br><ul><li>  Prenez des captures d'écran des éléments dont vous avez besoin.  Je veux dire, si vous avez besoin d'un bouton qui, par exemple, est sur une texture complexe à l'arrière, essayez de faire un écran uniquement avec le bouton afin de ne pas perdre de temps à traiter l'arrière, ce qui, en fait, n'est pas nécessaire.  Dans ce cas, la recherche ne dépendra pas de ce qui est affiché sur le fond et vous obtiendrez un résultat plus précis en moins de temps. </li><li>  Essayez d'éviter la reconnaissance d'images qui ne contiennent que du texte, comme  la reconnaissance réussie ("taux de réussite") dans ce cas sera considérablement réduite. </li><li>  Bien que la création de captures d'écran pendant l'enregistrement automatique de code (enregistrement automatique de script) soit une fonction assez pratique, mais à certains endroits, les captures d'écran ne sont pas très informatives.  Il est préférable de les créer manuellement afin de stocker des informations de recherche plus utiles dans vos photos. </li></ul><br><p>  Et si vous voulez demander "Est-il possible de modifier les paramètres du processus de recherche d'images?", Alors je vais vous répondre - oui, c'est possible. </p><br><h3 id="nastroyki-poiska-izobrazheniy-image-recognition">  Paramètres de reconnaissance d'image </h3><br><p>  L'utilisateur est autorisé et encouragé à travailler avec les paramètres de reconnaissance d'image pour obtenir les résultats souhaités, pour optimiser le temps et la probabilité de reconnaissance réussie des éléments (taux de réussite) à l'écran.  Ces paramètres sont stockés dans la fenêtre de l'éditeur d'image et pour l'ouvrir, vous devez double-cliquer sur l'image souhaitée dans l'éditeur de script.  Les paramètres de reconnaissance de chaque image doivent être modifiés séparément ou des variables globales doivent être utilisées si, par exemple, vous souhaitez augmenter les exigences de précision pour l'opération de seuil pour votre projet. </p><br><div class="spoiler">  <b class="spoiler_title">Fenêtre de l'éditeur d'images</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/ex/on/wt/exonwtjyt59f9vk5mgwjtozz698.png" alt="image"></p></div></div><br><p>  L'Editeur d'images contient une zone de travail, ainsi que des boutons "Instantané + Reconnaissance" et "Afficher l'aide".  Le premier est chargé de comparer votre image actuelle avec la version de l'instantané.  L'image instantanée est capturée à partir de la fenêtre actuelle sur votre appareil.  Le deuxième bouton ouvre le manuel fonctionnel de l'éditeur d'images.  Dans la partie droite de la fenêtre, l'image de recherche actuelle est affichée, ainsi que des paramètres tels que le nom de fichier, le seuil, target_pos et rgb. </p><br><ul><li>  <strong>Le</strong> champ du nom de <strong>fichier</strong> est responsable du nom de l'image actuellement enregistrée (toutes les images sont enregistrées dans le dossier du projet). </li><li>  <strong>seuil</strong> enregistre la valeur du pourcentage de coïncidence (de 0 à 1) des images après reconnaissance.  Plus la valeur est élevée, plus l'exigence de précision de correspondance d'image est élevée.  Comme mentionné ci-dessus, AirTest convertit les images en noir et blanc (en fonction de la mise en œuvre du seuil) et, par conséquent, la couleur n'est pas prise en compte lors de la reconnaissance. </li><li>  <strong>La</strong> case à cocher <strong>RVB</strong> est conçue pour «activer et ajouter» de la couleur lors de la reconnaissance d'image et ainsi commencer à en tenir compte.  Cependant, gardez à l'esprit que l'inclusion de cette fonctionnalité ne garantit toujours pas 100% du résultat.  Par exemple, si vous avez 2 boutons identiques qui ne diffèrent que par la couleur d'arrière-plan, la probabilité d'une reconnaissance incorrecte (par exemple, dans assert_exists / assert_not_exists) sera assez élevée. </li><li>  <strong>target_pos</strong> est responsable du point de l'image sur lequel AirTest clique après la reconnaissance.  Par défaut, la valeur est 5, mais vous pouvez la changer de 1 à 9, où 1 est le coin supérieur gauche de votre image de travail et 9 est le coin inférieur droit.  L'emplacement des neuf points est clairement indiqué dans la capture d'écran ci-dessous.  Vous pouvez également lire à ce sujet dans la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">documentation officielle.</a> <br>  Dans cet exemple, le bouton central est sélectionné pour la reconnaissance.  Le contour montre les bordures de la sélection. </li></ul><br><p><img src="https://habrastorage.org/webt/hy/9d/pg/hy9dpgjrq_b3mk87vn4uq839v8y.png" alt="image"></p><br><h2 id="napisanie-avtomatizirovannyh-testov-pri-pomoschi-airtest">  Écriture de tests automatisés avec AirTest </h2><br><p>  Toutes les commandes de travail du framework AirTest se trouvent dans la fenêtre AirTestAssistant dans le coin supérieur gauche de l'IDE Airtest.  S'il n'y est pas, vous pouvez définir la <em>disposition de fenêtre</em> par défaut à l'aide de <em>Fenêtre -&gt; Disposition par défaut</em> . </p><br><div class="spoiler">  <b class="spoiler_title">Emplacement de la fenêtre de l'assistant AirTest</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/lr/yr/om/lryromif73kpuavg-iqgegnqa5y.png" alt="image"></p></div></div><br><p>  Dans la version actuelle du programme, vous pouvez utiliser les commandes suivantes disponibles dans la fenêtre de l'Assistant AirTest: </p><br><ol><li>  <strong>tactile</strong> - cette commande simule un geste tactile sur un appareil mobile.  Touch a les paramètres suivants - touch (v, times = 1, duration = 0.01, right_click = False). <br><ul><li>  v - image ou coordonnée (x, y) </li><li>  fois - le nombre de clics.  La valeur par défaut est 1 </li><li>  durée - la durée de la mise en attente après avoir touché l'écran.  Avec ce paramètre, vous pouvez simuler un "appui long" (long_touch).  La valeur par défaut est 0,01 seconde. </li><li>  clic droit - cliquez sur le "bouton droit de la souris".  Ne peut être utilisé que dans les programmes Windows. </li></ul></li><li>  <strong>wait</strong> - en attente de l'élément d'interface utilisateur.  La commande a les paramètres suivants - attendre (v, timeout = TIMEOUT, intervalle = 5, intervalfunc = None). <br><ul><li>  v - l'image que le programme attend </li><li>  timeout - timeout.  La valeur par défaut est 20. </li><li>  intervalfunc - fonction utilisateur (personnalisée).  Si l'image n'est pas trouvée, cette fonction sera exécutée. </li><li>  interval - intervalle entre la comparaison d'images <br>  La fonction retourne ce qui suit: si une image est trouvée, alors les coordonnées centrales de l'image donnée sont retournées, sinon TargetNotFoundError est levée </li></ul></li><li>  <strong>swipe</strong> - cette commande simule un geste de glissement sur un appareil mobile ("glissement de l'écran").  Swipe a les paramètres suivants: swipe (v1, v2 = None, vector = None, duration = 0.01). <br><ul><li>  v1 - la valeur à partir de laquelle svayp commence.  Il peut s'agir d'une image ou d'une coordonnée donnée (x, y) </li><li>  v2: glissez la valeur de fin (la commande est exécutée de v1 à v2).  Ce paramètre a une priorité plus élevée que le paramètre "vecteur" </li><li>  vecteur [x, y] - est créé pendant le fonctionnement d'AirTest ou vous pouvez le définir vous-même.  Indique le chemin à parcourir.  Pour balayer vers la droite, X doit être positif, à son tour, Y doit être positif pour balayer vers le bas. </li><li>  étapes - n'a pas utilisé ce paramètre et n'a pas trouvé comment il est appliqué dans la pratique.  L'info-bulle donne ce qui suit: "le nœud dans le chemin de balayage, 5 par défaut".  Je suppose que le vecteur de direction de balayage sera divisé en «sections» et au lieu de permuter instantanément du point A au point B, le balayage sera simulé avec de petites pauses dans les nœuds spécifiés dans ce paramètre, comme s'il simulait un mouvement par phases.  Par exemple, si la valeur est 5, le vecteur sera divisé en 5 segments. </li><li>  duration - la durée du balayage.  La valeur par défaut est 0,5 seconde. </li></ul></li><li>  <strong>existe</strong> - une vérification existe pour l'élément que vous attendez sur l'écran du moniteur de l'appareil.  existe a les paramètres suivants: existe (v) <br><ul><li>  v - image <br>  La fonction retourne ce qui suit: si une image est trouvée, alors les coordonnées du centre de l'image sont retournées, sinon False. </li></ul></li><li>  <strong>text</strong> - commande de saisie de <strong>texte</strong> .  text a les paramètres suivants: text (text, enter = True, search = False) <br><ul><li>  texte - chaîne de texte à saisir </li><li>  enter - ce paramètre est responsable de l'opportunité d'utiliser "Enter" après avoir saisi du texte.  La valeur par défaut est True. </li><li>  recherche - n'a pas utilisé ce paramètre et n'a pas trouvé comment il est appliqué dans la pratique.  L'info-bulle donne les informations suivantes: "forcer" Rechercher "ou non après la saisie".  La valeur par défaut est False. </li></ul></li><li>  <strong>keyevent</strong> - émulation de la pression de boutons physiques sur l'appareil, tels que HOME, BACK, MENU, POWER, etc.  Paramètres de cette commande: keyevent (keyname) <br><ul><li>  keyname - nom du bouton (POWER, HOME, etc.) </li></ul></li><li>  <strong>instantané</strong> - créer une capture d'écran de l'écran dans l'état actuel.  Options par défaut: instantané (nom de fichier = Aucun, msg = "test-point") <br><ul><li>  nom de fichier - enregistrez la capture d'écran actuelle dans un fichier séparé.  Vous pouvez ignorer cette option. </li><li>  msg - description de ce point de test.  Ce texte sera affiché dans le rapport HTML, qui peut être créé après le test. <br>  Cette fonction renvoie les éléments suivants: nom de fichier (nom de fichier). </li></ul></li><li>  <strong>sommeil</strong> - le test de course "s'endort" pendant un certain temps.  Valeurs par défaut: sleep (secs = 1.0) <br><ul><li>  secs - timeout.  La valeur par défaut est 1 seconde. </li></ul></li><li>  <strong>assert_exists</strong> - vérifie si un élément existe.  Paramètres de cette commande: assert_exists (v, msg = "test-point") <br><ul><li>  v - image avec l'élément dont la présence est vérifiée </li><li>  msg - description de ce point de test.  Ce texte sera affiché dans le rapport HTML, qui peut être créé après le test. <br>  Cette fonction retourne ce qui suit: si une image est trouvée, alors les coordonnées du point central de cette image sont retournées, sinon une AssertionError est levée </li></ul></li><li>  <strong>assert_not_exists</strong> - vérifie que l'élément n'est pas présent sur l'écran de l'appareil.  Paramètres pour cette commande: assert_not_exists (v, msg = "test-point") <br><ul><li>  v - image avec l'élément dont la présence est vérifiée </li><li>  msg - description de ce point de test.  Ce texte sera affiché dans le rapport HTML, qui peut être créé après le test. </li></ul></li><li>  <strong>assert_equal</strong> - vérifie que l'attribut est égal à la valeur spécifiée.  Paramètres pour cette commande: assert_equal (premier, deuxième, msg = "test-point") <br><ul><li>  premier - le premier élément à comparer </li><li>  second - le deuxième élément à comparer </li><li>  msg - description de ce point de test.  Ce texte sera affiché dans le rapport HTML, qui peut être créé après le test. </li></ul></li><li>  <strong>assert_not_equal</strong> - vérifie que l'attribut n'est pas égal à la valeur spécifiée.  Paramètres pour cette commande: assert_not_equal (first, second, msg = "test-point") <br><ul><li>  premier - le premier élément à comparer </li><li>  second - le deuxième élément à comparer </li><li>  msg - description de ce point de test.  Ce texte sera affiché dans le rapport HTML, qui peut être créé après le test. </li></ul></li></ol><br><p>  Ces commandes sont divisées en 3 groupes principaux: opérations, <strong>fonctions auxiliaires</strong> et <strong>assertions</strong> .  Vous pouvez sélectionner le groupe dont vous avez besoin en utilisant le filtre approprié (un menu déroulant juste en dessous du nom de la fenêtre). </p><br><div class="spoiler">  <b class="spoiler_title">Filtre de groupe d'équipe</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/mt/vg/gd/mtvggd5lefzxlku-9ajljrv0evk.png" alt="image"></p></div></div><br><p>  Les équipes qui ont besoin d'une image activent les fonctions d'enregistrement de capture d'écran immédiatement après avoir cliqué sur le bouton correspondant.  Par exemple, pour sélectionner l'élément à cliquer sur l'écran, sélectionnez la commande tactile dans AirTest Assistant et dans la fenêtre Écran de l'appareil, sur l'appareil actif, encerclez l'élément sur lequel vous souhaitez cliquer.  Après cela, la commande correspondante apparaîtra dans la fenêtre principale (Script Editor), dans notre cas, touchez, avec l'image comme paramètre.  En conséquence, le processus d'automatisation est le suivant (le gif a été enregistré à partir d'une version obsolète d'AirTest IDE): </p><br><p><img src="https://habrastorage.org/webt/hn/je/uc/hnjeucmd5d-b8b8ubej4c5ldmoa.gif" alt="image"></p><br><p>  Si, pour une raison quelconque, vous ne souhaitez pas créer manuellement des captures d'écran et / ou écrire du code en général, vous pouvez utiliser la fonction d'enregistrement automatique.  Vous pouvez l'activer en cliquant sur le bouton "caméra" en face du menu déroulant avec des groupes de commandes dans la fenêtre de l'Assistant Airtest.  L'enregistrement automatique est une chose assez précise et pratique, mais, bien sûr, ce n'est pas une panacée et ne remplacera pas la composition manuelle de code. </p><br><p><img src="https://habrastorage.org/webt/i_/nj/j7/i_njj7gha1mdbooh88eokhyojei.gif" alt="image"></p><br><p>  Il convient de mentionner 3 touches de raccourci supplémentaires - F5 (démarrer le script), F10 (arrêter le script en cours), Ctrl + L / Cmd + L (créer un rapport basé sur le test terminé). <br>  Vous pouvez exécuter des tests prêts à l'emploi sans interface utilisateur à l'aide du terminal (ligne de commande).  Vous trouverez plus d'informations à ce sujet en général et sur l'exécution de tests en particulier <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> . </p><br><p>  Un exemple d'un extrait d'un test écrit en utilisant le framework AirTest peut être trouvé sous le spoiler! </p><br><div class="spoiler">  <b class="spoiler_title">Exemple d'autotest écrit à l'aide d'AirTest (reconnaissance d'image)</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/_3/4-/hf/_34-hffgtdgomhgjdtjpjddnrc4.png" alt="image"></p></div></div><br><p>  L'interface utilisateur de votre application / jeu ne se compose pas entièrement d'icônes, de boutons, de dos, etc. uniques.  De plus, des éléments périodiquement visuellement identiques peuvent être trouvés sur un seul écran, par exemple des boutons, des curseurs, etc.  Le plus souvent, dans de tels cas, AirTest ne pourra pas reconnaître l'élément dont vous avez besoin et soit le test échouera avec erreur, soit le mauvais élément d'interface sera sélectionné pour d'autres manipulations. </p><br><div class="spoiler">  <b class="spoiler_title">Un exemple de fenêtre avec plusieurs éléments identiques</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/t8/fz/v6/t8fzv6yv_wicafos4use8i6zaqu.jpeg" alt="image"></p></div></div><br><p>  Surtout pour de tels cas, un autre cadre a été développé qui est déjà intégré à l'IDE AirTest.  Il est Poco et a été brièvement décrit dans un article avec un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">aperçu de l'IDE Airtest</a> .  Je vais vous en dire plus sur ce framework dans le prochain article. </p><br><p>  Dites-nous si vous avez déjà utilisé l'IDE AirTest et ce que vous pensez de cet outil.  Je serai heureux de discuter dans les commentaires! </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr462587/">https://habr.com/ru/post/fr462587/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr462575/index.html">Security Week 32: trou dans iMessage, confidentialité de l'entrée vocale</a></li>
<li><a href="../fr462577/index.html">Mon expérience de développement Nim</a></li>
<li><a href="../fr462581/index.html">Comment nous avons organisé le premier leasing électronique et à quoi cela a conduit</a></li>
<li><a href="../fr462583/index.html">Rencontrez le pointeur déterministe du ramasse-miettes</a></li>
<li><a href="../fr462585/index.html">Création rapide de CRUD avec nest, @ nestjsx / crud et TestMace</a></li>
<li><a href="../fr462589/index.html">Créez un pipeline pour le traitement en continu des données. 2e partie</a></li>
<li><a href="../fr462593/index.html">De l'autre côté du stand</a></li>
<li><a href="../fr462595/index.html">Audit et test des lettres: ce à quoi vous devez faire attention lors de la mise en page</a></li>
<li><a href="../fr462597/index.html">Dactylographier et réagir</a></li>
<li><a href="../fr462601/index.html">Sauvegarde des serveurs Windows dans AWS</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>