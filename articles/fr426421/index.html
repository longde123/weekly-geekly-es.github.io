<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üêö üë∂üèª üí§ EHCI humainement en russe üë©üèø‚Äçü§ù‚Äçüë©üèº üê• üë®üèº‚Äçüåæ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Pr√©sentation 
 Je souhaite la bienvenue √† tous. Aujourd'hui, je veux partager mon exp√©rience et toujours, √† mon avis, expliquer clairement √† ce sujet,...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>EHCI humainement en russe</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/426421/"><img src="https://habrastorage.org/webt/kk/0o/he/kk0ohepnkx9kfrbmht7mtec5pr4.jpeg" alt="image"><br><br><h3>  <b>Pr√©sentation</b> </h3><br>  Je souhaite la bienvenue √† tous.  Aujourd'hui, je veux partager mon exp√©rience et toujours, √† mon avis, expliquer clairement √† ce sujet, √† premi√®re vue, une norme simple pour le contr√¥leur h√¥te USB 2.0. <br><br>  Au d√©part, vous pouvez imaginer qu'un port USB 2.0 n'est qu'√† 4 broches, dont deux transmettent simplement des donn√©es (comme, par exemple, un port COM), mais en fait, tout n'est pas le cas, et m√™me le contraire.  Le contr√¥leur USB, en principe, ne nous permet pas de transf√©rer des donn√©es comme via un port COM standard.  EHCI est une norme assez complexe qui permet un transfert de donn√©es fiable et rapide du logiciel vers l'appareil lui-m√™me, et dans la direction oppos√©e. <br><br>  Cet article peut vous √™tre utile si, par exemple, vous n'avez pas les comp√©tences suffisantes en √©criture pour les pilotes et en lecture de documentation pour un mat√©riel.  Un exemple simple: vous voulez √©crire votre syst√®me d'exploitation pour un mini-PC, afin que certaines distributions Windows ou Linux ne t√©l√©chargent pas de fer, et vous utilisez toute sa puissance exclusivement √† vos propres fins. <br><a name="habracut"></a><br><h3>  <b>Qu'est-ce que EHCI?</b> </h3><br>  Eh bien, commen√ßons.  EHCI - Enhanced Host Controller Interface, est con√ßu pour transf√©rer des donn√©es et des demandes de contr√¥le vers des p√©riph√©riques USB, et dans l'autre sens, et dans 99% des cas, c'est un lien entre n'importe quel logiciel et un p√©riph√©rique physique.  EHCI fonctionne comme un p√©riph√©rique PCI et utilise en cons√©quence MMIO (Memory-Mapped-IO) pour contr√¥ler le contr√¥leur (oui, je sais que certains p√©riph√©riques PCI utilisent des ports, mais ici j'ai tout g√©n√©ralis√©).  La documentation d'Intel ne d√©crit que le principe de fonctionnement, et il n'y a aucune indication sur tous les algorithmes √©crits au moins en pseudo-code.  EHCI dispose de 2 types de registres MMIO: Capability et Operational.  Les premiers servent √† obtenir les caract√©ristiques du contr√¥leur, tandis que les seconds servent √† le contr√¥ler.  En fait, je vais attacher l'essence m√™me de la connexion entre le logiciel et le contr√¥leur EHCI: <br><br><img src="https://habrastorage.org/webt/rh/px/zr/rhpxzre1s167jv51xhcz_shffsu.jpeg" alt="image"><br><br>  Chaque contr√¥leur EHCI poss√®de plusieurs ports, chacun pouvant √™tre connect√© √† n'importe quel p√©riph√©rique USB.  Veuillez √©galement noter que EHCI est une version am√©lior√©e de UHCI, qui a √©galement √©t√© d√©velopp√©e par Intel quelques ann√©es plus t√¥t.  Pour des raisons de compatibilit√© descendante, tout contr√¥leur UHCI / OHCI qui a une version inf√©rieure √† EHCI sera un compagnon d'EHCI.  Par exemple, vous avez un clavier USB (et la plupart des claviers de l'ann√©e jusqu'√† pr√©sent ont √©t√© comme √ßa) qui fonctionne sur USB 1.1 (notez que la vitesse maximale d'USB 1.1 est de 12 m√©gabits par seconde, et FullSpeed ‚Äã‚ÄãUSB 2.0 a une bande passante jusqu'√† 480 Mbps), et si vous avez un ordinateur avec un port USB 2.0, lorsque vous connectez le clavier √† l'ordinateur, le contr√¥leur h√¥te EHCI fonctionnera de quelque mani√®re que ce soit avec USB 1.1.  Ce mod√®le est illustr√© dans le diagramme suivant: <br><br><img src="https://habrastorage.org/webt/61/mg/lf/61mglfeajk5ivpcqmwjkazxniwy.jpeg" alt="image"><br><br>  De plus, pour l'avenir, je tiens √† vous avertir imm√©diatement que votre pilote peut ne pas fonctionner correctement en raison d'une situation aussi absurde: vous avez initialis√© UHCI, puis EHCI, tout en ajoutant deux p√©riph√©riques identiques, d√©finissez le bit de contr√¥le du propri√©taire du port sur le registre de port, puis UHCI a cess√© de fonctionner, car EHCI fait automatiquement glisser le port sur lui-m√™me, et le port sur UHCI ne r√©pond plus, cette situation doit √™tre surveill√©e. <br><br>  Examinons √©galement un diagramme montrant l'architecture EHCI elle-m√™me: <br><br><img src="https://habrastorage.org/webt/vq/t-/nt/vqt-ntbqnrcrz4k8he1uzngwyyo.jpeg" alt="image"><br><br>  √Ä droite est √©crit sur la file d'attente - √† leur sujet un peu plus tard. <br><br><h2>  Registres du contr√¥leur EHCI </h2><br>  Pour commencer, je tiens √† pr√©ciser une fois de plus que gr√¢ce √† ces registres, vous contr√¥lerez votre appareil, ils sont donc tr√®s importants - et sans eux, la programmation EHCI est impossible. <br><br>  Vous devez d'abord obtenir l'adresse MMIO qui est donn√©e √† ce contr√¥leur, √† offset + 0x10 sera l'adresse de nos registres tant attendus.  Il y a une chose: tout d'abord, les registres de capacit√© vont, et seulement apr√®s eux - Op√©rationnels, donc, au d√©calage 0 (√† partir de l'adresse pr√©c√©dente, que nous avons re√ßue au d√©calage 0x10 par rapport au d√©but du MMIO de notre EHCI), il y a un octet - la longueur des registres de capacit√©. <br><br><h3>  <b>Registres de capacit√©</b> </h3><br>  Au d√©calage 2, le registre <b>HCIVERSION</b> est <b>localis√©</b> - le num√©ro de r√©vision de ce HC, qui prend 2 octets et contient la version BCD de la r√©vision (ce BCD peut √™tre trouv√© sur Wikipedia). <br>  Au d√©calage +4, le registre <b>HCSPARAMS</b> est <b>localis√©</b> , sa taille est de 2 mots, il contient les param√®tres structurels de l'appareil et ses bits affichent ce qui suit: <br><br><ul><li>  Bit 16 - Indicateurs de port - LED disponibles pour les p√©riph√©riques USB connect√©s. </li><li>  Bits 15:12 - le num√©ro du contr√¥leur compagnon affect√© √† ce contr√¥leur </li><li>  Bits 11: 8 - le nombre de ports sur le contr√¥leur compagnon </li><li>  Bit 7 - R√®gles de routage des ports - montre comment ces ports sont mapp√©s aux ports compagnons </li><li>  Bit 4 - Contr√¥le de l'alimentation du port - indique s'il est n√©cessaire de mettre sous tension chaque port, 0 - l'alimentation est fournie automatiquement </li><li>  Bits 3: 0 - le nombre de ports pour ce contr√¥leur. </li><li>  Au d√©calage +8 se trouve le registre HCCPARAMS - il affiche les param√®tres de compatibilit√©, ses bits signifient ce qui suit: </li><li>  Bit 2 - disponibilit√© de la file d'attente asynchrone, </li><li>  Bit 1 - Disponibilit√© de la file d'attente p√©riodique (s√©quentielle) </li><li>  Compatibilit√© bits 0 - 64 bits </li></ul><br><h3>  <b>Registres d'op√©ration</b> </h3><br>  Au d√©calage 0, le registre <b>USBCMD</b> est le registre de commande du contr√¥leur, ses bits signifient ce qui suit: <br><br><ul><li>  Bits 23:16 - Interrupt Threshold Control - montre combien de micro-trames seront utilis√©es pour une trame r√©guli√®re.  Le plus grand, le plus rapide, mais s'il est sup√©rieur √† 8, les micro-images seront trait√©es √† la m√™me vitesse que pour le 8. </li><li>  Bit 6 - interruption apr√®s chaque transaction dans la file d'attente asynchrone, </li><li>  Bit 5 - est la file d'attente asynchrone utilis√©e </li><li>  Bit 4 - utilisation de la file d'attente s√©quentielle, </li><li>  Bits 3: 2 - la taille de FrameList'a (plus √† ce sujet plus tard).  0 signifie 1024 √©l√©ments, 1 - 512, 2 - 256, 3 - r√©serv√©s </li><li>  Bit 1 - d√©fini pour r√©initialiser le contr√¥leur h√¥te. </li><li>  Bit 0 - Marche / Arr√™t </li></ul>  . <br>  Ensuite, au d√©calage +4, il y a le registre <b>USBSTS</b> - l'√©tat du contr√¥leur h√¥te, <br><br><ul><li>  Le bit 15 indique si une file d'attente asynchrone est utilis√©e. </li><li>  Le bit 14 indique si une file d'attente s√©quentielle est utilis√©e, </li><li>  Bit 13 - indique qu'une file d'attente asynchrone vide a √©t√© d√©tect√©e, </li><li>  Le bit 12 est d√©fini sur 1, si une erreur s'est produite lors du traitement de la transaction, le contr√¥leur h√¥te arr√™tera toutes les files d'attente. </li><li>  Le bit 4 est d√©fini sur 1, si une erreur grave se produit, le contr√¥leur h√¥te arr√™te toutes les files d'attente. </li><li>  Bit 3 FrameList (Register) Rollover - d√©fini sur 1 lorsque le contr√¥leur h√¥te a trait√© l'int√©gralit√© de la FrameList. </li><li>  Bit 1 - Interruption d'erreur USB - Dois-je g√©n√©rer une interruption d'erreur? </li><li>  Bit 0 - Interruption USB - d√©fini apr√®s un traitement de transaction r√©ussi, si IOC a √©t√© install√© dans TD </li></ul><br>  Pas fatigu√©?  Vous pouvez vous verser une mouette solide et amener le foie, nous sommes au tout d√©but! <br><br>  Au d√©calage +8, il y a un registre <b>USBINTR</b> - le registre d'activation d'interruption <br>  Afin de ne pas √©crire pendant longtemps, et encore plus, pour ne pas lire pendant longtemps, les valeurs des bits de ce registre peuvent √™tre trouv√©es dans la sp√©cification, un lien vers celui-ci sera laiss√© ci-dessous.  Ici, j'√©cris juste 0, car  Je n'ai absolument aucune envie d'√©crire des gestionnaires, des interruptions de carte, etc., donc je pense que cela est presque compl√®tement inutile. <br><br>  √Ä l'offset +12 (0x0C), se trouve le registre <b>FRINDEX</b> , dans lequel se trouve simplement le num√©ro de trame actuel, et je tiens √† noter que les 4 derniers bits affichent le num√©ro de micro-trame, dans les 28 bits sup√©rieurs le num√©ro de trame (√©galement la valeur n'est pas n√©cessairement inf√©rieure √† la taille de frameList Mais si vous avez besoin d'un index, il vaut mieux le prendre avec un masque de 0x3FF (ou 0x1FF, etc.). <br><br>  Le registre <b>CTRLDSSEGMENT</b> est √† offset + 0x10; il montre au contr√¥leur h√¥te les 32 bits les plus significatifs de l'adresse de la feuille de trame. <br><br>  Le registre <b>PERIODICLISTBASE</b> a un d√©calage de + 0x14, vous pouvez y mettre les 32 bits inf√©rieurs de la feuille de trame, notez que l'adresse doit √™tre align√©e sur la taille de la page m√©moire (4096). <br><br>  Le registre <b>ASYNCLISTADDR</b> a un d√©calage de + 0x18, vous pouvez y mettre l'adresse de la file d'attente asynchrone, notez qu'elle doit √™tre align√©e √† la limite de 32 octets, alors qu'elle doit √™tre dans les quatre premiers gigaoctets de m√©moire physique. <br><br>  Le registre <b>CONFIGFLAG</b> indique si le p√©riph√©rique est configur√©.  Vous devez d√©finir le bit 0 apr√®s avoir termin√© la configuration de l'appareil, il a un d√©calage de + 0x40. <br><br>  Passons aux registres de ports.  Chaque port a son propre registre d'√©tat de commande, chaque registre de port est d√©cal√© <b>+ 0x44 + (PortNumber - 1) * 4</b> , ses bits signifient ce qui suit: <br><br><ul><li>  Bit 12 - alimentation du port, 1 - l'alimentation est fournie, 0 - non. </li><li>  Le bit 8 - Port Rest - est d√©fini pour r√©initialiser l'appareil. </li><li>  Bit 3 - Port Enable / Disable Change - d√©fini lors du changement de l'√©tat de "l'inclusion" du port. </li><li>  Bit 2 - port activ√© / d√©sactiv√©. </li><li>  Bit 1 - Modifier l'√©tat de la connexion, est d√©fini sur 1, par exemple, si vous avez connect√© ou d√©connect√© un p√©riph√©rique USB. </li><li>  Bit 0 - √©tat de la connexion, 1 - connect√©, 0 - non. </li></ul><br>  Passons maintenant au jus lui-m√™me. <br><br><h2>  Structures de transfert de donn√©es et de requ√™tes </h2><br>  L'organisation d'une structure de traitement des demandes comprend des files d'attente et des descripteurs de transfert (TD). <br><br>  Pour le moment, nous ne consid√©rerons que 3 structures. <br><br><h3>  Liste s√©quentielle </h3><br>  La liste s√©quentielle (P√©riodique, P√©r√©odique) est organis√©e comme suit: <br><br><img src="https://habrastorage.org/webt/hv/2h/23/hv2h23mnmv5uks1ffugte6ycpcu.jpeg" alt="image"><br><br>  Comme vous pouvez le voir dans le diagramme, le traitement commence par l'obtention de la trame souhait√©e √† partir du cadre de feuille, chacun de ses √©l√©ments occupe 4 octets et a la structure suivante: <br><br><img src="https://habrastorage.org/webt/o_/m7/ic/o_m7icnqm0ifgvnfpfycwahilwy.jpeg" alt="image"><br><br>  Comme vous pouvez le voir sur l'image, le transfert d'adresse / descripteur de file d'attente est align√© √† la limite de 32 octets, le bit 0 signifie que le contr√¥leur h√¥te ne traitera pas cet √©l√©ment, les bits 3: 1 indiquent le type de ce que le contr√¥leur h√¥te traitera: 0 - TD isosynchrone (iTD), 1 - tour, 2 et 3 dans cet article, je ne consid√©rerai pas. <br><br><h3>  File d'attente asynchrone </h3><br>  Le contr√¥leur h√¥te traite cette file d'attente uniquement lorsque la trame s√©quentielle est vide ou que le contr√¥leur h√¥te a trait√© l'int√©gralit√© de la liste s√©rie. <br><br>  Une file d'attente asynchrone est un pointeur vers une file d'attente qui contient d'autres files d'attente qui doivent √™tre trait√©es.  Sch√©ma: <br><br><img src="https://habrastorage.org/webt/rz/sv/4s/rzsv4sqoyqegzwqoij9vl7qpt14.jpeg" alt="image"><br><br><h3>  qTD (descripteur de transfert d'√©l√©ment de file d'attente) </h3><br>  Ce TD a la structure suivante: <br><br><img src="https://habrastorage.org/webt/hf/gq/g5/hfgqg5fvujkx2bv8piy6i3gijyu.jpeg" alt="image"><br><br>  <b>Pointeur qTD suivant</b> - un pointeur vers la continuation de la file d'attente pour le traitement (pour l'ex√©cution horizontale), bit 0 Le pointeur qTD suivant indique qu'il n'y a plus de file d'attente. <br>  <b>Jeton qTD</b> - jeton TD, affiche les param√®tres de transfert de donn√©es: <br><br><ul><li>  Bit 31 - Basculement des donn√©es (plus √† ce sujet plus tard) </li><li>  Bits 30:16 - la quantit√© de donn√©es √† transf√©rer, apr√®s l'ach√®vement de la transaction, leur valeur diminue de la quantit√© de donn√©es transf√©r√©es. </li><li>  Bit 15 - IOC - Interruption √† la fin - provoque une interruption une fois le traitement des descripteurs termin√©. </li><li>  Les bits 14:12 indiquent le num√©ro du tampon actuel vers / √† partir duquel les donn√©es sont √©chang√©es, plus √† ce sujet plus tard. </li><li>  Bits 11:10 - le nombre d'erreurs autoris√©es.  Ce tableau indique quand le nombre d'erreurs diminue: <br><br><img src="https://habrastorage.org/webt/ko/hz/ia/kohzia9y2vxtrd1tepp-h5qokgm.jpeg" alt="image"><br><br>  Note de bas de page 1 - la d√©tection de Babble ou Stall arr√™te automatiquement l'ex√©cution de la t√™te de file d'attente.  R√©f√©rence 3 - Les erreurs de tampon de donn√©es sont des probl√®mes avec l'h√¥te.  Ils ne tiennent pas compte des tentatives de p√©riph√©rique. </li><li>  9: 8 - Code PID - type de jeton: 0 - jeton √† l'entr√©e (de l'h√¥te √† l'appareil), 1 - jeton √† la sortie (de l'appareil √† l'h√¥te), 2 - jeton ¬´SETUP¬ª </li><li>  Les bits 7: 0 indiquent l'√©tat TD: <br>  Le bit 7 indique que le TD est dans un √©tat actif (c'est-√†-dire que le contr√¥leur h√¥te traite ce TD) <br>  Bit 6 - Halted - indique qu'une erreur s'est produite et que l'ex√©cution de TD s'est arr√™t√©e. <br>  Bit 4 - Babble Detected - la quantit√© de donn√©es que nous avons envoy√©es √† l'appareil, ou par tour, est inf√©rieure √† ce que nous transmettons, c'est-√†-dire, par exemple, l'appareil nous a envoy√© 100 octets de donn√©es, et nous lisons seulement 50 octets, puis 50 autres Le bit Halted sera √©galement d√©fini si ce bit est d√©fini sur 1. <br>  Bit 3 - Erreur de transaction - Une erreur s'est produite lors de la transaction. </li></ul><br>  <b>qTD Buffer Page Pointer List</b> - l'un des 5 tampons.  Il contient un lien vers l'endroit o√π en m√©moire la transaction doit √™tre effectu√©e (envoyer des donn√©es √† l'appareil / recevoir des donn√©es de l'appareil), toutes les adresses dans les tampons, sauf la premi√®re, doivent √™tre align√©es sur la taille de la page (4096 octets). <br><br><h3>  Responsable de ligne </h3><br>  La t√™te de file d'attente a la structure suivante: <br><br><img src="https://habrastorage.org/webt/9m/ob/l7/9mobl76mr1drsddxbgndgbgoneo.jpeg" alt="image"><br><br>  <b>Pointeur de lien horizontal de t√™te de file d'attente</b> - pointeur vers la file d'attente suivante, les bits 2: 1 ont les valeurs suivantes selon le type de file d'attente: <br><br><img src="https://habrastorage.org/webt/bu/gw/sa/bugwsap9snr11blm5ifggvhei60.jpeg" alt="image"><br><br>  <b>Capacit√©s / caract√©ristiques des terminaux</b> - caract√©ristiques des files d'attente: <br><br><ul><li>  Les bits 26:16 contiennent la taille de paquet maximale pour la transmission </li><li>  Bit 14: Data Toggle Control - indique o√π le contr√¥leur h√¥te doit prendre la valeur initiale de Data Toggle, 0 - ignore le bit DT dans qTD, enregistre le bit DT pour la t√™te de file d'attente. </li><li>  Bit 13:12 - caract√©ristiques de la vitesse de transmission: <img src="https://habrastorage.org/webt/gk/tb/sd/gktbsdm7kys5kcgk6e3uewkgf1q.jpeg" alt="image"></li><li>  Bits 11: 8 - le num√©ro du noeud final auquel la demande est adress√©e </li><li>  Bits 6: 0 - adresse de l'appareil </li></ul><br>  <b>Capacit√©s de point de terminaison: Queue Head DWord 2</b> - suite du mot double pr√©c√©dent: <br><br><ul><li>  Bits 29:23 - Num√©ro de concentrateur </li><li>  Bits 22:16 - Adresse du hub </li></ul><br>  <b>Pointeur de lien qTD actuel</b> - pointeur vers le qTD actuel. <br><br>  Nous passons au plus int√©ressant. <br><br><h2>  Pilote EHCI </h2><br>  Commen√ßons par les requ√™tes que l'EHCI peut r√©pondre.  Il existe 2 types de demandes: Contr√¥le - √† la commande, et Bulk - aux points de terminaison, pour l'√©change de donn√©es, par exemple, la grande majorit√© des lecteurs flash USB (USB MassStorage) utilisent le type de transfert de donn√©es Bulk / Bulk / Bulk.  La souris et le clavier utilisent √©galement des demandes group√©es pour le transfert de donn√©es. <br><br>  Initialisez EHCI et configurez les files d'attente asynchrones et s√©quentielles: <br><br><pre><code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Base I/O Address PciBar bar; PciGetBar(&amp;bar, id, 0); EhciController *hc = VMAlloc(sizeof(EhciController)); hc-&gt;capRegs = (EhciCapRegs *)(uintptr_t)bar.u.address; hc-&gt;opRegs = (EhciOpRegs *)(uintptr_t)(bar.u.address + hc-&gt;capRegs-&gt;capLength); // Read the Command register //    uint cmd = ROR(usbCmdO); // Write it back, setting bit 2 (the Reset bit) //   ,   2(Reset) // and making sure the two schedule Enable bits are clear. //  ,  2   WOR(usbCmdO, 2 | cmd &amp; ~(CMD_ASE | CMD_PSE)); // A small delay here would be good. You don't want to read //     ,     // the register before it has a chance to actually set the bit //   ,         ROR(usbCmdO); // Now wait for the controller to clear the reset bit. //      Reset while (ROR(usbCmdO) &amp; 2); // Again, a small delay here would be good to allow the // reset to actually become complete. //   ROR(usbCmdO); // wait for the halted bit to become set //    Halted    while (!(ROR(usbStsO) &amp; STS_HCHALTED)); //     ,        // ,           128  hc-&gt;frameList = (u32 *)VMAlloc(1024 * sizeof(u32) + 8192 * 4); hc-&gt;frameList = (((uint)hc-&gt;frameList) / 16384) * 16384 + 16384; hc-&gt;qhPool = (EhciQH *)VMAlloc(sizeof(EhciQH) * MAX_QH + 8192 * 4); hc-&gt;tdPool = (EhciTD *)VMAlloc(sizeof(EhciTD) * MAX_TD + 8192 * 4); hc-&gt;qhPool = (((uint)hc-&gt;qhPool) / 16384) * 16384 + 16384; hc-&gt;tdPool = (((uint)hc-&gt;tdPool) / 16384) * 16384 + 16384; // Asynchronous queue setup //    EhciQH *qh = EhciAllocQH(hc); //     ,      // ,    qh-&gt;qhlp = (u32)(uintptr_t)qh | PTR_QH; //  ,  ,     qh-&gt;ch = QH_CH_H; qh-&gt;caps = 0; qh-&gt;curLink = 0; qh-&gt;nextLink = PTR_TERMINATE; qh-&gt;altLink = 0; qh-&gt;token = 0; //    for (uint i = 0; i &lt; 5; ++i) { qh-&gt;buffer[i] = 0; qh-&gt;extBuffer[i] = 0; } hc-&gt;asyncQH = qh; // Periodic list queue setup //    qh = EhciAllocQH(hc); //     qh-&gt;qhlp = PTR_TERMINATE; qh-&gt;ch = 0; qh-&gt;caps = 0; qh-&gt;curLink = 0; qh-&gt;nextLink = PTR_TERMINATE; qh-&gt;altLink = 0; qh-&gt;token = 0; //   for (uint i = 0; i &lt; 5; ++i) { qh-&gt;buffer[i] = 0; qh-&gt;extBuffer[i] = 0; } qh-&gt;transfer = 0; qh-&gt;qhLink.prev = &amp;qh-&gt;qhLink; qh-&gt;qhLink.next = &amp;qh-&gt;qhLink; hc-&gt;periodicQH = qh; //        for (uint i = 0; i &lt; 1024; ++i) hc-&gt;frameList[i] = PTR_QH | (u32)(uintptr_t)qh; kprintf("FrameList filled. Turning off Legacy BIOS support..."); // Check extended capabilities //  BIOS Legacy support uint eecp = (RCR(hccParamsO) &amp; HCCPARAMS_EECP_MASK) &gt;&gt; HCCPARAMS_EECP_SHIFT; if (eecp &gt;= 0x40) { // Disable BIOS legacy support uint legsup = PciRead32(id, eecp + USBLEGSUP); kprintf("."); if (legsup &amp; USBLEGSUP_HC_BIOS) { PciWrite32(id, eecp + USBLEGSUP, legsup | USBLEGSUP_HC_OS); kprintf("."); for (;;) { legsup = PciRead32(id, eecp + USBLEGSUP); kprintf("."); if (~legsup &amp; USBLEGSUP_HC_BIOS &amp;&amp; legsup &amp; USBLEGSUP_HC_OS) { break; } } } } kprintf("Done\n"); // Disable interrupts //   //hc-&gt;opRegs-&gt;usbIntr = 0; MWIR(ehcibase, usbIntrO, 0); // Setup frame list //     //hc-&gt;opRegs-&gt;frameIndex = 0; WOR(frameIndexO, 0); //hc-&gt;opRegs-&gt;periodicListBase = (u32)(uintptr_t)hc-&gt;frameList; WOR(periodicListBaseO, (u32)(uintptr_t)hc-&gt;frameList); //       //hc-&gt;opRegs-&gt;asyncListAddr = (u32)(uintptr_t)hc-&gt;asyncQH; WOR(asyncListAddrO, (u32)(uintptr_t)hc-&gt;asyncQH); //    0 //hc-&gt;opRegs-&gt;ctrlDsSegment = 0; WOR(ctrlDsSegmentO, 0); // Clear status //   //hc-&gt;opRegs-&gt;usbSts = ~0; WOR(usbStsO, ~0); // Enable controller //  , 8 -,  //     //hc-&gt;opRegs-&gt;usbCmd = (8 &lt;&lt; CMD_ITC_SHIFT) | CMD_PSE | CMD_ASE | CMD_RS; WOR(usbCmdO, (8 &lt;&lt; CMD_ITC_SHIFT) | CMD_PSE | CMD_ASE | CMD_RS); while (ROR(usbStsO)&amp;STS_HCHALTED); // Configure all devices to be managed by the EHCI // ,   //hc-&gt;opRegs-&gt;configFlag = 1; WOR(configFlagO, 1);\ // Probe devices //   EhciProbe(hc);</span></span></code> </pre> <br>  En fait, le code pour r√©initialiser le port √† son √©tat d'origine: <br><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">volatile</span></span> u32 *reg = &amp;hc-&gt;opRegs-&gt;ports[port]; <span class="hljs-comment"><span class="hljs-comment">//    ,  100 *reg|=(1&lt;&lt;12)|(1&lt;&lt;20); Wait(100); //  ,  50  EhciPortSet(reg, PORT_RESET | (1&lt;&lt;12) | (1&lt;&lt;20) | (1&lt;&lt;6)); Wait(50); EhciPortClr(reg, PORT_RESET); // Wait 100ms for port to enable (TODO - what is appropriate length of time?) //  100    ,   , //  100    uint status = 0; for (uint i = 0; i &lt; 10; ++i) { // Delay Wait(10); // Get current status //    status = *reg; // Check if device is attached to port //      if (~status &amp; PORT_CONNECTION) break; // Acknowledge change in status //    -    if (status &amp; (PORT_ENABLE_CHANGE | PORT_CONNECTION_CHANGE)) { EhciPortClr(reg, PORT_ENABLE_CHANGE | PORT_CONNECTION_CHANGE); continue; } // Check if device is enabled //    ,    if (status &amp; PORT_ENABLE) break; } return status;</span></span></code> </pre><br>  Demande de contr√¥le √† l'appareil: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EhciDevControl</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(UsbDevice *dev, UsbTransfer *t)</span></span></span><span class="hljs-function"> </span></span>{ EhciController *hc = (EhciController *)dev-&gt;hc; UsbDevReq *req = t-&gt;req; <span class="hljs-comment"><span class="hljs-comment">// Determine transfer properties //    uint speed = dev-&gt;speed; uint addr = dev-&gt;addr; uint maxSize = dev-&gt;maxPacketSize; uint type = req-&gt;type; uint len = req-&gt;len; // Create queue of transfer descriptors //   TDs EhciTD *td = EhciAllocTD(hc); if (!td) return; EhciTD *head = td; EhciTD *prev = 0; // Setup packet //   uint toggle = 0; uint packetType = USB_PACKET_SETUP; uint packetSize = sizeof(UsbDevReq); EhciInitTD(td, prev, toggle, packetType, packetSize, req); prev = td; // Data in/out packets packetType = type &amp; RT_DEV_TO_HOST ? USB_PACKET_IN : USB_PACKET_OUT; u8 *it = (u8 *)t-&gt;data; u8 *end = it + len; //EhciPrintTD(td); while (it &lt; end) { td = EhciAllocTD(hc); if (!td) return; toggle ^= 1; packetSize = end - it; if (packetSize &gt; maxSize) packetSize = maxSize; EhciInitTD(td, prev, toggle, packetType, packetSize, it); it += packetSize; prev = td; } // Status packet //   td = EhciAllocTD(hc); if (!td) return; toggle = 1; packetType = type &amp; RT_DEV_TO_HOST ? USB_PACKET_OUT : USB_PACKET_IN; EhciInitTD(td, prev, toggle, packetType, 0, 0); // Initialize queue head //   : EhciQH *qh = EhciAllocQH(hc); EhciInitQH(qh, t, head, dev-&gt;parent, false, speed, addr, 0, maxSize); // Wait until queue has been processed //       EhciInsertAsyncQH(hc-&gt;asyncQH, qh); EhciWaitForQH(hc, qh); }</span></span></code> </pre><br>  Code de traitement des files d'attente: <br><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (qh-&gt;token &amp; TD_TOK_HALTED) { t-&gt;success = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; t-&gt;complete = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (qh-&gt;nextLink &amp; PTR_TERMINATE) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (~qh-&gt;token &amp; TD_TOK_ACTIVE) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (qh-&gt;token &amp; TD_TOK_DATABUFFER) kprintf(<span class="hljs-string"><span class="hljs-string">" Data Buffer Error\n"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (qh-&gt;token &amp; TD_TOK_BABBLE) kprintf(<span class="hljs-string"><span class="hljs-string">" Babble Detected\n"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (qh-&gt;token &amp; TD_TOK_XACT) kprintf(<span class="hljs-string"><span class="hljs-string">" Transaction Error\n"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (qh-&gt;token &amp; TD_TOK_MMF) kprintf(<span class="hljs-string"><span class="hljs-string">" Missed Micro-Frame\n"</span></span>); t-&gt;success = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; t-&gt;complete = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (t-&gt;complete) ....</code> </pre><br>  Et maintenant la demande de point final (demande en masse) <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EhciDevIntr</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(UsbDevice *dev, UsbTransfer *t)</span></span></span><span class="hljs-function"> </span></span>{ EhciController *hc = (EhciController *)dev-&gt;hc; <span class="hljs-comment"><span class="hljs-comment">// Determine transfer properties //    uint speed = dev-&gt;speed; uint addr = dev-&gt;addr; uint maxSize = t-&gt;endp-&gt;desc-&gt;maxPacketSize; uint endp = t-&gt;endp-&gt;desc-&gt;addr &amp; 0xf; EhciTD *td = EhciAllocTD(hc); if (!td) { t-&gt;success = false; t-&gt;complete = true; return; } EhciTD *head = td; EhciTD *prev = 0; // Data in/out packets uint toggle = t-&gt;endp-&gt;toggle; uint packetType = t-&gt;endp-&gt;desc-&gt;addr &amp; 0x80 ? USB_PACKET_IN : USB_PACKET_OUT; uint packetSize = t-&gt;len; EhciInitTD(td, prev, toggle, packetType, packetSize, t-&gt;data); // Initialize queue head //    EhciQH *qh = EhciAllocQH(hc); EhciInitQH(qh, t, head, dev-&gt;parent, true, speed, addr, endp, maxSize); //printQh(qh); // Schedule queue //    EhciInsertPeriodicQH(hc-&gt;periodicQH, qh); }</span></span></code> </pre><br>  Je pense que le sujet est assez int√©ressant, sur Internet en russe il n'y a presque pas de documentation, de descriptions et d'articles sur ce sujet, et s'il y en a, c'est tr√®s flou.  Si le sujet du travail avec le d√©veloppement mat√©riel et OS est int√©ressant, alors il y a beaucoup √† dire. <br><br>  Docks: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">sp√©cification</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr426421/">https://habr.com/ru/post/fr426421/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr426411/index.html">D√©veloppement de classes de descripteurs C ++ / CLI</a></li>
<li><a href="../fr426413/index.html">Principes SOLIDES que chaque d√©veloppeur doit conna√Ætre</a></li>
<li><a href="../fr426415/index.html">Fintech-digest: contr√¥le de la digitalisation par la Banque Centrale, salaire de crypto-monnaie, carte Mir sous forme de bracelets et porte-cl√©s</a></li>
<li><a href="../fr426417/index.html">Pavel 2.0: consultant reptiloid sur JS, node.js avec sockets et t√©l√©phonie</a></li>
<li><a href="../fr426419/index.html">Surcharge interdite ou m√©thodes de pontage en Java</a></li>
<li><a href="../fr426423/index.html">mmWave sur smartphones: comment Qualcomm a rendu possible l'impossible</a></li>
<li><a href="../fr426425/index.html">Toute la v√©rit√© sur RTOS. Article # 14. Sections de m√©moire: introduction et services de base</a></li>
<li><a href="../fr426427/index.html">Des trucs utiles pour "bourrer": une petite s√©lection √† petits prix</a></li>
<li><a href="../fr426429/index.html">Installation de FreeSWITCH 1.8 sur Debian 9 (Raspbian Stretch, l'image de base du syst√®me Smart Home de MajorDoMo sur Rasbperri Pi)</a></li>
<li><a href="../fr426431/index.html">D√©montage du moteur de roman visuel Qlie</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>