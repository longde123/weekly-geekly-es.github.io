<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👇🏻 🤹🏾 🚦 Wasmer: perpustakaan Go tercepat untuk mengeksekusi kode WebAssembly 🤚🏽 👉 🏓</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="WebAssembly (wasm) adalah format instruksi biner portabel. Kode wasm kode yang sama dapat dieksekusi di lingkungan apa pun. Untuk mendukung pernyataan...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Wasmer: perpustakaan Go tercepat untuk mengeksekusi kode WebAssembly</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/454518/">  WebAssembly (wasm) adalah format instruksi biner portabel.  Kode wasm kode yang sama dapat dieksekusi di lingkungan apa pun.  Untuk mendukung pernyataan ini, setiap bahasa, platform, dan sistem harus dapat mengeksekusi kode tersebut, membuatnya secepat dan seaman mungkin. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><img src="https://habrastorage.org/webt/6b/ba/7g/6bba7gvszh2fqjm_zupvfk90fea.png"></a> <a name="habracut"></a><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Wasmer</a> adalah runtime wasm yang ditulis dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Rust</a> .  Jelas, wasmer dapat digunakan dalam aplikasi Rust apa pun.  Penulis materi, terjemahan yang kami terbitkan hari ini, mengatakan bahwa ia dan peserta lain dalam proyek Wasmer berhasil mengimplementasikan runtime kode-was ini dalam bahasa lain: <br><br><ul><li>  Dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">C dan C ++,</a> ini diimplementasikan melalui binding. </li><li>  Dalam PHP, ini merupakan perpanjangan dari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">php-ext-wasm</a> . </li><li>  Dalam Python, ini adalah paket mesin <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">cuci</a> yang diterbitkan di PyPi yang sedang dikerjakan di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">repositori python-ext-wasm</a> . </li><li>  Di Ruby, ini adalah permata <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">wasmer</a> yang dapat ditemukan di RubyGems.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Kodenya ada di repositori ruby-ext-wasm</a> . </li></ul><br>  Di sini kita akan berbicara tentang proyek baru - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">go-ext-wasm</a> , yang merupakan perpustakaan untuk Go, yang dirancang untuk mengeksekusi kode biner-biner.  Ternyata, proyek pengembangan-jauh jauh lebih cepat daripada solusi serupa lainnya.  Tapi jangan maju dulu.  Mari kita mulai dengan sebuah cerita tentang bagaimana bekerja dengannya. <br><br><h2>  <font color="#3AC1EF">Memanggil fungsi wasme dari Go</font> </h2><br>  Untuk memulai, instal wasmer di lingkungan Go (dengan dukungan cgo). <br><br><pre><code class="go hljs">export CGO_ENABLED=<span class="hljs-number"><span class="hljs-number">1</span></span>; export CC=gcc; <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> install github.com/wasmerio/<span class="hljs-keyword"><span class="hljs-keyword">go</span></span>-ext-wasm/wasmer</code> </pre> <br>  Proyek <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">go-ext-wasm</a> adalah perpustakaan Go biasa.  Saat bekerja dengan perpustakaan ini, konstruk <code>import "github.com/wasmerio/go-ext-wasm/wasmer"</code> . <br><br>  Sekarang mari kita berlatih.  Kami akan menulis program sederhana yang dikompilasi dalam wasm.  Kami akan menggunakan ini, misalnya, Karat: <br><br><pre> <code class="rust hljs"><span class="hljs-meta"><span class="hljs-meta">#[no_mangle]</span></span> <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sum</span></span></span></span>(x: <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>, y: <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span> {   x + y }</code> </pre> <br>  Kami memanggil file dengan program <code>simple.rs</code> , sebagai hasil dari kompilasi program ini kami mendapatkan file <a href="">simple.wasm</a> . <br><br>  Program berikut, yang ditulis dalam Go, menjalankan fungsi <code>sum</code> dari file wasm, dengan memberikan angka 5 dan 37 sebagai argumen: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> main <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> (   <span class="hljs-string"><span class="hljs-string">"fmt"</span></span>   wasm <span class="hljs-string"><span class="hljs-string">"github.com/wasmerio/go-ext-wasm/wasmer"</span></span> ) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> {   <span class="hljs-comment"><span class="hljs-comment">//   WebAssembly.   bytes, _ := wasm.ReadBytes("simple.wasm")   //    WebAssembly.   instance, _ := wasm.NewInstance(bytes)   defer instance.Close()   //    `sum`   WebAssembly.   sum := instance.Exports["sum"]   //        Go.   //   ,      ,  .   result, _ := sum(5, 37)   fmt.Println(result) // 42! }</span></span></code> </pre> <br>  Di sini, sebuah program yang ditulis dalam Go memanggil fungsi dari file wasm yang diperoleh dengan mengkompilasi kode yang ditulis dalam Rust. <br><br>  Jadi, percobaan itu berhasil, kami berhasil mengeksekusi kode WebAssembly di Go.  Perlu dicatat bahwa konversi tipe data bersifat otomatis.  Nilai-nilai Go yang dilewatkan ke kode wasm dilemparkan ke tipe WebAssembly.  Apa yang dikembalikan fungsi wasm ke tipe Go.  Akibatnya, bekerja dengan fungsi dari file wasm di Go terlihat sama dengan bekerja dengan fungsi Go biasa. <br><br><h2>  <font color="#3AC1EF">Fungsi Panggilan Pergi dari Kode WebAssembly</font> </h2><br>  Seperti yang kita lihat pada contoh sebelumnya, modul WebAssembly dapat mengekspor fungsi yang dapat dipanggil dari luar.  Ini adalah mekanisme yang memungkinkan kode wasme dijalankan di berbagai lingkungan. <br><br>  Pada saat yang sama, modul WebAssembly sendiri dapat bekerja dengan fungsi yang diimpor.  Pertimbangkan program berikut yang ditulis dalam Rust. <br><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> {   <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sum</span></span></span></span>(x: <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>, y: <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>; } <span class="hljs-meta"><span class="hljs-meta">#[no_mangle]</span></span> <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">add1</span></span></span></span>(x: <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>, y: <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span> {   <span class="hljs-keyword"><span class="hljs-keyword">unsafe</span></span> { sum(x, y) } + <span class="hljs-number"><span class="hljs-number">1</span></span> }</code> </pre> <br>  Beri nama file dengan <code>import.rs</code> .  Mengompilasinya ke dalam WebAssembly akan menghasilkan kode yang dapat ditemukan di <a href="">sini</a> . <br><br>  Fungsi <code>add1</code> diekspor <code>add1</code> fungsi <code>sum</code> .  Tidak ada implementasi dari fungsi ini, hanya tanda tangannya yang ditentukan dalam file.  Inilah yang disebut fungsi eksternal.  Untuk WebAssembly, ini adalah fungsi yang diimpor.  Implementasinya harus diimpor. <br><br>  Kami mengimplementasikan fungsi <code>sum</code> menggunakan Go.  Untuk ini, kita perlu menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">cgo</a> .  Ini kode yang dihasilkan.  Beberapa komentar, yang merupakan deskripsi dari fragmen kode utama, diberi nomor.  Di bawah ini kita akan membicarakannya secara lebih rinci. <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> main <span class="hljs-comment"><span class="hljs-comment">// // 1.    `sum` (   cgo). // // #include &lt;stdlib.h&gt; // // extern int32_t sum(void *context, int32_t x, int32_t y); import "C" import (   "fmt"   wasm "github.com/wasmerio/go-ext-wasm/wasmer"   "unsafe" ) // 2.    `sum`    ( cgo). //export sum func sum(context unsafe.Pointer, x int32, y int32) int32 {   return x + y } func main() {   //   WebAssembly.   bytes, _ := wasm.ReadBytes("import.wasm")   // 3.     WebAssembly.   imports, _ := wasm.NewImports().Append("sum", sum, C.sum)   // 4.     WebAssembly  .   instance, _ := wasm.NewInstanceWithImports(bytes, imports)   //    WebAssembly.   defer instance.Close()   //    `add1`   WebAssembly.   add1 := instance.Exports["add1"]   //   .   result, _ := add1(1, 2)   fmt.Println(result)   // add1(1, 2)   // = sum(1 + 2) + 1   // = 1 + 2 + 1   // = 4   // QED }</span></span></code> </pre> <br>  Mari kita uraikan kode ini: <br><br><ol><li>  Tanda tangan dari fungsi <code>sum</code> didefinisikan dalam C (lihat komentar pada perintah <code>import "C"</code> ). </li><li>  Implementasi fungsi <code>sum</code> didefinisikan dalam Go (perhatikan baris <code>//export</code> - mekanisme ini dapat digunakan untuk membuat koneksi kode yang ditulis dalam Go dengan kode yang ditulis dalam C). </li><li>  <code>NewImports</code> adalah API yang digunakan untuk membuat impor WebAssembly.  Dalam kode ini, <code>"sum"</code> adalah nama fungsi yang diimpor oleh WebAssembly, <code>sum</code> adalah penunjuk ke fungsi Go, dan <code>C.sum</code> adalah penunjuk ke fungsi cgo. </li><li>  Dan akhirnya, <code>NewInstanceWithImports</code> adalah konstruktor yang dirancang untuk menginisialisasi modul WebAssembly dengan impor. </li></ol><br><h2>  <font color="#3AC1EF">Membaca data dari memori</font> </h2><br>  Contoh WebAssembly memiliki memori linier.  Mari kita bicara tentang cara membaca data darinya.  Mari kita mulai, seperti biasa, dengan kode Rust, yang akan kita sebut <code>memory.rs</code> . <br><br><pre> <code class="rust hljs"><span class="hljs-meta"><span class="hljs-meta">#[no_mangle]</span></span> <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">return_hello</span></span></span></span>() -&gt; *<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">u8</span></span> {   <span class="hljs-string"><span class="hljs-string">b"Hello, World!\0"</span></span>.as_ptr() }</code> </pre> <br>  Hasil kompilasi kode ini ada di file <code>memory.wasm</code> , yang digunakan di bawah ini. <br><br>  Fungsi <code>return_hello</code> mengembalikan pointer ke string.  Baris berakhir, seperti dalam C, dengan karakter nol. <br><br>  Sekarang pergi ke sisi Go: <br><br><pre> <code class="go hljs">bytes, _ := wasm.ReadBytes(<span class="hljs-string"><span class="hljs-string">"memory.wasm"</span></span>) instance, _ := wasm.NewInstance(bytes) <span class="hljs-keyword"><span class="hljs-keyword">defer</span></span> instance.Close() <span class="hljs-comment"><span class="hljs-comment">//    `return_hello`. //      . result, _ := instance.Exports["return_hello"]() //      . pointer := result.ToI32() //    . memory := instance.Memory.Data() fmt.Println(string(memory[pointer : pointer+13])) // Hello, World!</span></span></code> </pre> <br>  Fungsi <code>return_hello</code> mengembalikan pointer sebagai nilai <code>i32</code> .  Kami mendapatkan nilai ini dengan menghubungi <code>ToI32</code> .  Kemudian kita mendapatkan data dari memori menggunakan <code>instance.Memory.Data()</code> . <br><br>  Fungsi ini mengembalikan potongan memori instance WebAssembly.  Anda dapat menggunakannya seperti slice Go. <br><br>  Untungnya, kita tahu panjang baris yang ingin kita baca, oleh karena itu, untuk membaca informasi yang diperlukan, cukup menggunakan <code>memory[pointer : pointer+13]</code> .  Kemudian data yang dibaca dikonversi menjadi string. <br><br>  <a href="">Berikut adalah</a> contoh yang menunjukkan mekanisme memori yang lebih maju saat menggunakan kode WebAssembly Go. <br><br><h2>  <font color="#3AC1EF">Tingkatan yang dicapai</font> </h2><br>  Proyek go-ext-wasm, seperti yang baru saja kita lihat, memiliki API yang nyaman.  Sekarang saatnya berbicara tentang kinerjanya. <br><br>  Tidak seperti PHP atau Ruby, dunia Go sudah memiliki solusi untuk bekerja dengan kode wasm.  Secara khusus, kita berbicara tentang proyek-proyek berikut: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Life</a> from Perlin Network - Juru bahasa WebAssembly. </li><li>  Go Interpreter's <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Wagon</a> adalah interpreter dan toolkit WebAssembly. </li></ul><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Materi</a> pada proyek php-ext-wasm menggunakan algoritma <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">n-body</a> untuk mempelajari kinerja.  Ada banyak algoritma lain yang cocok untuk memeriksa kinerja lingkungan eksekusi kode.  Sebagai contoh, ini adalah algoritma <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Fibonacci</a> (versi rekursif) dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">algoritma Pollard ρ yang</a> digunakan dalam Life.  Ini adalah algoritma kompresi Snappy.  Yang terakhir ini bekerja dengan sukses dengan go-ext-wasm, tetapi tidak dengan Life atau Wagon.  Akibatnya, ia dikeluarkan dari set tes.  Kode uji dapat ditemukan di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> . <br><br>  Selama pengujian, versi terbaru dari proyek penelitian digunakan.  Yaitu, ini adalah Life 20190521143330-57f3819c2df0 dan Wagon 0.4.0. <br><br>  Angka-angka yang ditunjukkan pada grafik mencerminkan nilai rata-rata yang diperoleh setelah 10 awal tes.  Studi ini menggunakan 2016 MacBook Pro 15 "dengan prosesor Intel Core i7 2,9 GHz dan memori 16 GB. <br><br>  Hasil tes dikelompokkan sepanjang sumbu X sesuai dengan jenis tes.  Sumbu Y menunjukkan waktu, dalam milidetik, yang diperlukan untuk menyelesaikan tes.  Semakin kecil indikatornya, semakin baik. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/810/8c2/321/8108c23213493ab6ade095909770b58e.png"><br>  <i><font color="#999999">Perbandingan kinerja Wasmer, Wagon dan Life menggunakan implementasi dari berbagai algoritma</font></i> <br><br>  Platform Life and Wagon, secara rata-rata, memberikan hasil yang hampir sama.  Wasmer, rata-rata, adalah 72 kali lebih cepat. <br><br>  Penting untuk dicatat bahwa Wasmer mendukung tiga backend: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Singlepass</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Cranelift</a> dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">LLVM</a> .  Backend default di Go library adalah Cranelift (di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> Anda dapat mengetahui lebih lanjut tentang itu).  Menggunakan LLVM akan memberikan kinerja yang mendekati aslinya, tetapi diputuskan untuk memulai dengan Cranelift, karena backend ini memberikan rasio terbaik antara waktu kompilasi dan waktu eksekusi program. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Di sini</a> Anda dapat membaca tentang berbagai backend, pro dan kontra mereka, dan dalam situasi apa lebih baik menggunakannya. <br><br><h2>  <font color="#3AC1EF">Ringkasan</font> </h2><br>  Proyek open source <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">go-ext-wasm</a> adalah Go library baru yang dirancang untuk mengeksekusi kode biner wasme.  Ini termasuk <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">runtime Wasmer</a> .  Versi pertamanya termasuk API, kebutuhan yang paling sering muncul. <br>  Tes kinerja menunjukkan bahwa Wasmer, rata-rata, 72 kali lebih cepat daripada Life and Wagon. <br><br>  <b>Pembaca yang budiman!</b>  Apakah Anda berencana menggunakan kemampuan untuk menjalankan kode wasme di Go menggunakan go-ext-wasm? <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id454518/">https://habr.com/ru/post/id454518/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id454506/index.html">Entropic - Registri Paket Baru Terdistribusi untuk Node.js</a></li>
<li><a href="../id454508/index.html">Porting Aplikasi Desktop ke .NET Core</a></li>
<li><a href="../id454512/index.html">Sarapan laporan dengan Charles Weatherly, penulis buku kultus Etudes for Programmer</a></li>
<li><a href="../id454514/index.html">Pengembangan synthesizer musik sederhana di ATMEGA8</a></li>
<li><a href="../id454516/index.html">Cara mendapatkan teks yang bagus untuk 200 rubel</a></li>
<li><a href="../id454520/index.html">Pedoman untuk menulis kode JavaScript bersih</a></li>
<li><a href="../id454522/index.html">Node.js: mengelola memori yang tersedia untuk aplikasi yang berjalan dalam wadah</a></li>
<li><a href="../id454524/index.html">Perbaikan Ikat Kepala Samsung Level On Pro</a></li>
<li><a href="../id454530/index.html">DJI menciptakan octocopter yang dapat membuat film</a></li>
<li><a href="../id454532/index.html">Saya akan mengatakan sepatah kata pun tentang pendekatan rekayasa</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>