<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🔕 🤷🏻 ⚱️ 依赖类型-编程语言的未来 🆔 🌌 👨🏼‍🏭</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="大家好！ 

 尽管今天讨论的主题有些古怪和抽象-我们希望它可以使您的周末多样化。 在文章的末尾，我们放置了作者的三个链接，使您熟悉Idris，F *和JavaScript的依赖类型。 

 有时似乎编程语言自60年代以来并没有太大变化。 当他们告诉我这件事时，我经常想起我们现在拥有多少个出色的工具...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>依赖类型-编程语言的未来</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/piter/blog/432416/"> 大家好！ <br><br> 尽管今天讨论的主题有些古怪和抽象-我们希望它可以使您的周末多样化。 在文章的末尾，我们放置了作者的三个链接，使您熟悉Idris，F *和JavaScript的依赖类型。 <br><a name="habracut"></a><br> 有时似乎编程语言自60年代以来并没有太大变化。 当他们告诉我这件事时，我经常想起我们现在拥有多少个出色的工具和功能，以及它们如何简化我们的生活。 临时：这些是集成的调试器，单元测试，静态分析器，凉爽的IDE以及类型化数组等等。 语言的发展是一个漫长而渐进的过程，没有这样的“银弹”可以一劳永逸地改变语言的发展。 <br><br> 今天，我想告诉您这个正在进行的过程的最后阶段之一。 我们正在谈论的技术仍在积极探索中，但是一切都表明它将很快在主流语言中扎根。 我们的故事从计算机科学中最基本的概念之一开始： <b>类型</b> 。 <br><br><h2> 类型世界 </h2><br> 打字是与我们的思想密不可分的事情之一，以至于我们甚至根本没有考虑过类型的概念？ 为什么1是一个<code>int</code> ，但如果仅将此值放在引号中，则它变成<code>string</code> ？ 本质上，什么是“类型”？ 在编程中通常会遇到这种情况，答案取决于问题的措辞。 <br><br> 类型多样。 在某些类型系统中，类型和值之间有非常清晰的界限。 因此，3、2和1是<code>integer</code>数值，但<code>integer</code>不是值。 这种结构在语言中是“嵌入的”，与含义有根本的不同。 但是，实际上，这种区别是没有必要的，只能限制我们。 <br><br> 如果您释放这些类型并将它们转换为另一种值类别，那么就会出现许多惊人的可能性。 值可以存储，转换并传递给函数。 因此，有可能制作一个将类型作为参数的函数，从而创建通用的函数：可以在不重载的情况下处理许多类型的函数。 您可以具有给定类型的值的数组，而不必像在C中那样进行奇怪的指针算术和类型转换。您还可以在程序运行时收集新类型，并提供自动JSON反序列化等功能。 但是，即使您将类型视为值，也仍然无法做到所有类型都可以对值进行处理。 因此，使用用户实例进行操作，例如，您可以比较其名称，检查其年龄或标识符等。 <br><br><pre> <code class="plaintext hljs">if user.name == "Marin" &amp;&amp; user.age &lt; 65 { print("You can't retire yet!") }</code> </pre> <br> 但是，当您尝试对<code>User</code>类型执行相同<code>User</code> ，只能比较类型名称和可能的属性名称。 由于这是一种类型，而不是实例，因此无法检查其属性的值。 <br><br><pre> <code class="plaintext hljs">if typeof(user) == User { print("Well, it's a user. That's all I know") }</code> </pre> <br> 如果我们具有仅接收非空用户列表的功能，那将有多酷？ 还是仅当电子邮件地址以正确格式记录时才接受电子邮件地址的功能？ 为此，您需要使用“非空数组”或“电子邮件地址”类型。 在这种情况下，它是一个与值相关的类型，即 关于<b>依赖类型</b> 。 在主流语言中，这是不可能的。 <br><br> 为了可以使用类型，编译器必须检查它们。 如果您声明该变量包含整数，那么如果其中没有<code>string</code>会更好，否则编译器会发誓。 原则上讲，这很好，因为它不允许我们求爱。 检查类型非常简单：如果一个函数返回一个<code>integer</code> ，而我们尝试在其中返回<code>"Marin"</code> ，则这是一个错误。 <br><br> 但是，对于依赖类型，情况会变得更加复杂。 问题是编译器究竟何时检查类型。 如果程序尚未运行，他如何确保数组中恰好有三个值？ 如果尚未分配整数，如何确保它大于3？ 这就是<i>魔术</i> ……或者换句话说， <i>数学</i> 。 如果可以从数学上证明数字集始终大于3，则编译器可以对此进行验证。 <br><br><h2> 工作室里的数学！ </h2><br>  <b>数学归纳法</b>用于制定证据。 归纳法使我们能够无条件确认陈述的真实性。 例如，我们想证明以下数学公式适用于任何正数： <br><br><pre> <code class="plaintext hljs">1 + 2 + 3 + ... + x = x * (x + 1) / 2</code> </pre> <br>  x的数目是无限的，因此我们需要很长时间才能手动检查所有数字。 幸运的是，这不是必需的。 我们只需要证明两件事： <br><br><ol><li> 在第一天就观察到该陈述。  （通常是0或1） </li><li> 如果此陈述对数字<code>n</code>为真，则对下一个数字<code>n + 1</code>为真。 </li></ol><br> 由于对于第一个数字和所有随后的数字都遵循该声明，因此我们知道对于所有可能的数字都是正确的。 <br><br> 要证明这一点并不困难： <br><br><pre> <code class="plaintext hljs">1 = 1 * (1 + 1) / 2 1 = 1</code> </pre> <br> 现在我们还必须证明该语句适用于所有其他数字。 为此，假设它适用于某个数字n，然后确保它也适用于n + 1。 <br><br> 假设以下表达式为真： <br><br><pre> <code class="plaintext hljs">1 + 2 + 3 + ... + n = n * (n + 1) / 2</code> </pre> <br> 检查出<code>n + 1</code> ： <br><br><pre> <code class="plaintext hljs">(1 + 2 + 3 + ... + n) + (n + 1) = (n + 1) * ((n + 1) + 1) / 2</code> </pre> <br> 因此，我们可以用以上等式替换<code>"(1 + 2 + 3 + ... + n)"</code> ： <br><br><pre> <code class="plaintext hljs">(n * (n + 1) / 2) + (n + 1) = (n + 1) * ((n + 2) / 2)</code> </pre> <br> 并简化为 <br><br><pre> <code class="plaintext hljs">(n + 1) * (n/2 + 1) = (n + 1) * (n/2 + 1)</code> </pre> <br> 由于表达式的两个部分相等，因此我们确保此语句为真。 这是无需手动计算每种情况即可验证语句真实性的方法之一，并且基于此原理，依赖类型起作用。 您编写数学语句以确保类型命题正确。 <br><br> 这种方法的优点在于，任何数学证明都可以以计算机程序的形式发布-这就是我们所需要的！ <br><br><h2> 返回编程 </h2><br> 因此，我们发现可以先证明某些事情，然后再进行特定值的证明。 为此，需要使用一种编程语言来表达将要写入类型系统本身的代码中的这些语句，也就是说，需要改进类型系统。 <br><br> 考虑一个例子。 在这里，我们有一个append函数，它接受两个数组并将其组合。 通常，此类函数的签名如下所示： <br><br><pre> <code class="plaintext hljs">append: (arr1: Array, arr2: Array) -&gt; Array</code> </pre> <br> 但是，仅通过查看签名，我们就无法确定正确的实现。 函数返回一个数组的事实并不意味着它做了什么。 检查结果的一种方法是确保结果数组的长度等于参数数组的长度之和。 <br><br><pre> <code class="plaintext hljs">newArray = append([1], [2, 3]) assert(length(newArray) == 3)</code> </pre> <br> 但是，如果可以创建一个在编译时检查的约束，为什么还要在运行时检查它： <br><br><pre> <code class="plaintext hljs">append: (arr1: Array, arr2: Array) -&gt; newArray: Array where length(newArray) == length(arr1) + length(arr2)</code> </pre> <br> 我们声明<code>append</code>是一个函数，它接受两个<code>Array</code>参数并返回一个新的<code>Array</code>参数，我们称之为<code>newArray</code> 。 仅在这一次，我们增加了一个警告，新数组的长度应等于该函数所有参数的长度之和。 我们在运行时上面获得的语句在编译时转换为类型。 <br><br> 上面的代码引用类型的世界，而不是值，即<code>==</code>符号表示返回的类型<code>length</code>的比较，而不是其值。 为了使这种机制起作用，返回的类型长度必须给我们一些有关实际数字的信息。 <br><br> 为了确保这种机制的运行，您需要确保每个数字都是单独的类型。 一种类型只能包含一个值：1.同样的值适用于2、3和所有其他数字。 当然，这样的工作很累人，但是我们需要进行编程才能完成这样的工作。 您可以编写一个可以为我们完成此任务的编译器。 <br><br> 完成此操作后，您可以为包含1，2，3和不同数量元素的数组创建单独的类型。  <code>ArrayOfOne</code> ， <code>ArrayOfTwo</code>等。 <br><br> 因此，您可以定义长度函数，该函数将采用上述数组类型之一，并有一个相关的返回类型， <code>One</code> <code>ArrayOfOne</code>为<code>One</code> ， <code>ArrayOfOne</code>为<code>Two</code> ， <code>ArrayOfTwo</code> 。 每个数字。 <br><br> 现在，对于数组的任何特定长度，我们都有一个单独的类型，我们可以验证（在编译时）两个数组的长度相等。 为此，比较它们的类型。 并且由于类型与其他任何类型都具有相同的值，因此您可以为其分配操作。 您可以通过指定<code>ArrayOfOne</code>和<code>ArrayOfTwo</code>的总和等于<code>ArrayOfThree</code>来确定两个特定类型的<code>ArrayOfThree</code> 。 <br><br> 这就是编译器需要确保所编写代码正确的所有信息。 <br><br> 假设我们要创建一个<code>ArrayOfThree</code>类型的变量： <br><br><pre> <code class="plaintext hljs">result: ArrayOfThree = append([1], [2, 3])</code> </pre> <br> 编译器可以确定[1]只有一个值，因此您可以分配类型<code>ArrayOfOne</code> 。 它还可以将<code>ArrayOfTwo</code>分配给[2，3]。 <br><br> 编译器知道结果的类型必须等于第一个和第二个参数的类型之和。 他还知道ArrayOfOne + ArrayOfTwo等于ArrayOfThree，也就是说，他知道标识右侧的整个表达式的类型为ArrayOfThree。 它与左侧的表达式匹配，并且编译器很满意。 <br><br> 如果我们写以下内容： <br><br><pre> <code class="plaintext hljs">result: ArrayOfTwo = append([1], [2, 3])</code> </pre> <br> 那么编译器将完全不满意，因为它将知道类型不正确。 <br><br><h2> 依赖打字非常酷 </h2><br> 在这种情况下，根本无法允许大量错误。 使用依赖类型，可以避免单位错误，对不存在的数组索引的访问，空指针异常，无限循环和代码损坏。 <br><br> 使用依赖类型，您几乎可以表达任何内容。 阶乘函数将只接受自然数， <code>login</code>函数将不接受空行， <code>removeLast</code>函数将仅接受非空数组。 此外，在启动程序之前，请检查所有这一切。 <br><br> 运行时检查的问题是，如果程序已经在运行，则它们将失败。 如果程序仅由您运行，而不由用户运行，这是正常的。 依赖类型允许您对类型级别进行此类检查，因此在程序执行期间出现此类故障是不可能的。 <br><br> 我认为依赖类型化是主流编程语言的未来，我迫不及待地要等待它！ <br><br>  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">伊德里斯</a> <br><br>  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">F *</a> <br><br>  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">将依赖类型添加到JavaScript</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN432416/">https://habr.com/ru/post/zh-CN432416/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN432404/index.html">Linux的备份不写字母</a></li>
<li><a href="../zh-CN432408/index.html">金融科技摘要：准备将小型银行与Visa和Mastercard（养老金计算器）断开连接</a></li>
<li><a href="../zh-CN432410/index.html">具有Entity Framework Core的DDD样式的实体</a></li>
<li><a href="../zh-CN432412/index.html">高负载++：如何帮助ERP系统每秒处理500,000个请求</a></li>
<li><a href="../zh-CN432414/index.html">快速调试的老秘诀：动画源代码</a></li>
<li><a href="../zh-CN432418/index.html">解析Java中的Lambda表达式</a></li>
<li><a href="../zh-CN432420/index.html">Git Merge和Git Rebase简介：为什么以及何时使用它们</a></li>
<li><a href="../zh-CN432422/index.html">iOS上的离线模式及其在Realm上的实现功能</a></li>
<li><a href="../zh-CN432424/index.html">HyperFlex认证的SAP HANA基础架构</a></li>
<li><a href="../zh-CN432426/index.html">调试无法播放的错误</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>