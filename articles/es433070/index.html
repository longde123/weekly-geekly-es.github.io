<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üå† üïï ‚ö∞Ô∏è C√≥mo distinguir champ√∫ de champi√±ones y brochetas de champ√°n ... Elasticsearch: busque productos en las bases de datos de la tienda üôãüèΩ üèñÔ∏è üßü</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Desaf√≠o 


 Una de las grandes tareas de la aplicaci√≥n para almacenar y analizar compras es buscar productos id√©nticos o muy cercanos en la base de da...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>C√≥mo distinguir champ√∫ de champi√±ones y brochetas de champ√°n ... Elasticsearch: busque productos en las bases de datos de la tienda</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/433070/"><h1 id="zadacha">  Desaf√≠o </h1><br><p> Una de las grandes tareas de la aplicaci√≥n para almacenar y analizar compras es buscar productos id√©nticos o muy cercanos en la base de datos, que contiene nombres de productos variados e incomprensibles obtenidos de los recibos.  Hay dos tipos de solicitud de entrada: </p><br><ol><li>  Un nombre espec√≠fico con abreviaturas, que solo pueden entender los cajeros de un supermercado local o los √°vidos compradores. </li><li>  Una consulta en lenguaje natural ingresada por el usuario en la cadena de b√∫squeda. </li></ol><br><p>  Las solicitudes del primer tipo, por regla general, provienen de los productos en el cheque en s√≠, cuando el usuario necesita encontrar productos m√°s baratos.  Nuestra tarea es seleccionar el producto an√°logo m√°s similar del cheque en otras tiendas cercanas.  Es importante elegir la marca de producto m√°s adecuada y, si es posible, el volumen. </p><br><p><img src="https://habrastorage.org/webt/yp/_d/ny/yp_dnyvhrlrrrr6v0pa_6sz_ibk.jpeg"></p><a name="habracut"></a><br><p>  El segundo tipo de solicitud es una simple solicitud del usuario para buscar un producto espec√≠fico en la tienda m√°s cercana.  La solicitud puede ser una descripci√≥n muy general y no √∫nica del producto.  Puede haber ligeras desviaciones de la solicitud.  Por ejemplo, si un usuario busca leche 3.2% y en nuestra base de datos solo 2.5% leche, entonces todav√≠a queremos mostrar al menos este resultado. </p><br><p><img src="https://habrastorage.org/webt/ar/0-/03/ar0-03doeo4rgkrbni26iz9rek4.jpeg"></p><br><h1 id="osobennosti-dataseta--problemy-dlya-resheniya">  Conjunto de datos de caracter√≠sticas: problemas a resolver </h1><br><p>  La informaci√≥n en el recibo del producto est√° lejos de ser ideal.  Tiene muchas abreviaturas no siempre claras, errores gramaticales, errores tipogr√°ficos, varias traducciones, letras latinas en el medio del alfabeto cir√≠lico y juegos de caracteres que tienen sentido solo para la organizaci√≥n interna de una tienda en particular. <br>  Por ejemplo, un pur√© de manzana y pl√°tano con queso cottage se puede escribir f√°cilmente en el cheque de la siguiente manera: </p><br><p><img src="https://habrastorage.org/webt/kv/gg/23/kvgg23lcyv2h5gulck5k_9x1a-s.jpeg"></p><cut></cut><br><h1 id="o-tehnologii">  Acerca de la tecnolog√≠a </h1><br><p>  Elasticsearch es una tecnolog√≠a bastante popular y asequible para implementar b√∫squedas.  Este es un motor de b√∫squeda JSON REST API que usa Lucene y est√° escrito en Java.  Las principales ventajas de Elastic son velocidad, escalabilidad y tolerancia a fallas.  Se utilizan motores similares para b√∫squedas complejas en la base de datos de documentos.  Por ejemplo, una b√∫squeda que tiene en cuenta la morfolog√≠a del idioma o una b√∫squeda por geocoordenadas. </p><br><h1 id="napravleniya-dlya-eksperimentov-i-uluchsheniy">  Instrucciones para la experimentaci√≥n y la mejora. </h1><br><p>  Para comprender c√≥mo puede mejorar su b√∫squeda, debe analizar el sistema de b√∫squeda en sus componentes personalizados.  Para nuestro caso, la estructura del sistema se ve as√≠. </p><br><ol><li>  La cadena de entrada para la b√∫squeda pasa a trav√©s del analizador, que de cierta manera divide la cadena en tokens: unidades de b√∫squeda que buscan entre los datos que tambi√©n se almacenan como tokens. </li><li>  Luego hay una b√∫squeda directa de estos tokens para cada documento en la base de datos existente.  Despu√©s de encontrar un token en un documento determinado (que tambi√©n se presenta en la base de datos como un conjunto de tokens), su relevancia se calcula de acuerdo con el modelo de similitud seleccionado (lo llamaremos el modelo de relevancia).  Este puede ser un simple <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">TF / IDF</a> (T√©rmino Frecuencia - Frecuencia de documento inversa), o puede ser otros modelos m√°s complejos o espec√≠ficos. </li><li>  En la siguiente etapa, el n√∫mero de puntos anotados por cada ficha individual se agrega de cierta manera.  Los par√°metros de agregaci√≥n se establecen mediante la sem√°ntica de consulta.  Un ejemplo de tales agregaciones pueden ser pesos adicionales para ciertos tokens (valor agregado), condiciones para la presencia obligatoria de un token, etc.  El resultado de esta etapa es Score: la evaluaci√≥n final de la relevancia de un documento particular de la base de datos en relaci√≥n con la solicitud inicial. </li></ol><br><p><img src="https://habrastorage.org/webt/_u/yg/zp/_uygzp1ohyyhtksrfuwbfvmi3r0.jpeg"></p><br><p>  Se pueden distinguir tres componentes configurables por separado del dispositivo de b√∫squeda, en cada uno de los cuales puede resaltar sus propias formas y m√©todos de mejora. </p><br><ol><li>  Analizadores </li><li>  Modelo de similitud </li><li>  Mejoras en el tiempo de consulta </li></ol><br><p>  A continuaci√≥n, consideraremos cada componente individualmente y analizaremos configuraciones de par√°metros espec√≠ficos que ayudaron a mejorar la b√∫squeda en el caso de los nombres de productos. </p><br><h3 id="query-time-uluchsheniya">  Mejoras en el tiempo de consulta </h3><br><p>  Para comprender qu√© podemos mejorar en la solicitud, damos un ejemplo de la solicitud inicial. </p><br><pre><code class="sql hljs">{ "query": { "multi_match": { "query": "  105", "type": "most_fields", "fields": ["name"], "minimum_should_match": "70%" } }, ‚Äúsize‚Äù: 100, ‚Äúmin_score‚Äù: 15 }</code> </pre> <br><p>  Utilizamos el tipo de consulta most_fields, ya que prevemos la necesidad de una combinaci√≥n de varios analizadores para el campo "nombre del producto".  Este tipo de consulta le permite combinar resultados de b√∫squeda para diferentes atributos del objeto que contiene el mismo texto, analizados de diferentes maneras.  Una alternativa a este enfoque es utilizar las consultas best_fields o cross_fields, pero no son adecuadas para nuestro caso, ya que la b√∫squeda se calcula entre los diversos atributos del objeto (por ejemplo, nombre y descripci√≥n).  Nos enfrentamos a la tarea de tener en cuenta varios aspectos de un atributo: el nombre del producto. </p><br><p>  Lo que se puede configurar: </p><br><ul><li>  Combinaci√≥n ponderada de diferentes analizadores. <br>  Inicialmente, todos los elementos de b√∫squeda tienen el mismo peso y, por lo tanto, la misma importancia.  Esto se puede cambiar agregando el par√°metro 'boost', que toma valores num√©ricos.  Si el par√°metro es mayor que 1, el elemento de b√∫squeda tendr√° un mayor impacto en los resultados, respectivamente, menor que 1 - menos. </li><li>  Separaci√≥n de analizadores en 'deber√≠a' y 'debe'. <br>  Es decir, ciertos analizadores deben coincidir, y algunos son opcionales, es decir, insuficientes.  En nuestro caso, el analizador de n√∫meros puede ser un ejemplo de los beneficios de tal separaci√≥n.  Si solo el n√∫mero coincide en el nombre del producto en la solicitud y el nombre del producto en la base de datos, entonces esta no es una condici√≥n suficiente para su equivalencia.  No queremos ver tales productos como resultado.  Al mismo tiempo, si la solicitud es "crema 10%", entonces queremos que toda crema con 10% de grasa tenga una gran ventaja sobre la crema con 20% de grasa. </li><li>  El par√°metro minimum_should_match.  ¬øCu√°ntos tokens deben coincidir necesariamente en la solicitud y el documento de la base de datos?  Este par√°metro funciona junto con el tipo de nuestra solicitud (most_fields) y verifica el n√∫mero m√≠nimo de tokens coincidentes para cada uno de los campos (en nuestro caso, para cada analizador). </li><li>  Par√°metro min_score.  Umbral de documentos de cribado con puntos insuficientes.  El problema es que no se conoce la velocidad m√°xima.  El puntaje resultante depende de una solicitud espec√≠fica y de una base de datos espec√≠fica de documentos.  A veces puede ser 150, y a veces 2, pero ambos valores significar√°n que el objeto de la base de datos es relevante para la solicitud.  No podemos comparar las puntuaciones de los resultados de diferentes consultas. <br><ul><li>  Constante <br>  Despu√©s de un monitoreo suficiente de los valores finales de la velocidad para diferentes consultas, puede identificar un borde aproximado, despu√©s del cual para la mayor√≠a de las consultas los resultados se vuelven inapropiados.  Esta es la decisi√≥n m√°s f√°cil, pero tambi√©n la m√°s est√∫pida, que conduce a una b√∫squeda de baja calidad. </li><li>  Intente analizar los puntajes obtenidos para una solicitud espec√≠fica despu√©s de realizar una b√∫squeda con m√≠nimo o cero puntaje m√≠nimo. <br>  La idea es que despu√©s de un cierto momento, puede observar un salto brusco en la direcci√≥n de la disminuci√≥n de la velocidad.  Solo queda determinar este salto para detenerse a tiempo.  Tal enfoque funcionar√≠a bien en consultas similares: <br><img src="https://habrastorage.org/webt/9z/qo/-u/9zqo-uovb_75ytduyti4byhmeyo.png"><br>  El salto se puede encontrar por m√©todos estad√≠sticos.  Pero, desafortunadamente, no en todas las solicitudes, este salto est√° presente y es f√°cilmente identificable. </li><li>  Calcule la velocidad ideal y establezca min_score como una cierta fracci√≥n del ideal, que se puede hacer de dos maneras: <br><ul><li>  A partir de la descripci√≥n detallada de los c√°lculos proporcionados por el propio Elastic al establecer la explicaci√≥n: par√°metro verdadero.  Esta es una tarea dif√≠cil, que requiere una comprensi√≥n profunda de la arquitectura de consulta y los algoritmos computacionales utilizados por Elastic. </li><li>  Por un peque√±o truco.  Recibimos una solicitud, agregamos un nuevo producto a nuestra base de datos con el mismo nombre, hacemos una b√∫squeda y obtenemos la m√°xima velocidad.  Como habr√° una coincidencia del 100% en el nombre, el valor resultante ser√° ideal.  Es este enfoque el que usamos en nuestro sistema, ya que las preocupaciones sobre el alto costo de esta operaci√≥n con respecto al tiempo no han sido confirmadas. </li></ul></li></ul></li><li>  Cambie el algoritmo de puntuaci√≥n, que es responsable del valor de relevancia final.  Esto puede estar tomando en cuenta la distancia a la tienda (dar m√°s puntos a los productos que est√°n m√°s cerca), los precios de los productos (dar m√°s puntos a los productos con el precio m√°s probable), etc. </li></ul><br><h3 id="analizatory">  Analizadores </h3><br><p>  El analizador analiza la cadena de entrada en tres etapas y genera tokens en las unidades de b√∫squeda de salida: </p><br><p><img src="https://habrastorage.org/webt/cd/vc/u8/cdvcu8tw-9wsrgelal2ii0waeio.jpeg"></p><br><p>  Primero, los cambios ocurren en el nivel de caracteres de la cadena.  Esto puede ser reemplazar, eliminar o agregar caracteres a una cadena.  Luego entra en juego un tokenizer, que est√° dise√±ado para dividir la cadena en tokens.  El tokenizer est√°ndar divide la cadena en tokens de acuerdo con los signos de puntuaci√≥n.  En el √∫ltimo paso, los tokens recibidos se filtran y procesan. </p><br><p>  Considere qu√© variaciones de los pasos se han vuelto √∫tiles en nuestro caso. </p><br><h5 id="char-filters">  Filtros de carb√≥n </h5><br><ul><li>  Seg√∫n los detalles del idioma ruso, ser√≠a √∫til procesar caracteres como th y e y reemplazarlos con y y e, respectivamente. </li><li>  Realizar transliteraci√≥n: la transferencia de caracteres de una escritura por caracteres de otra escritura.  En nuestro caso, este es el procesamiento de nombres escritos en lat√≠n o mezclados con ambos alfabetos.  La transliteraci√≥n se puede implementar usando el complemento ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">ICU Analysis Plugin</a> ) como filtro de token (es decir, no procesa la cadena original, sino los tokens finales).  Decidimos escribir nuestra transliteraci√≥n, ya que no est√°bamos muy contentos con el algoritmo en el complemento.  La idea es reemplazar primero las ocurrencias del conjunto de cuatro caracteres (por ejemplo, ‚ÄúSHCH =&gt; u‚Äù), luego las ocurrencias de tres caracteres, etc. El orden en el que se usan los filtros de s√≠mbolos es importante porque el resultado depender√° del orden. </li><li>  Reemplazar Latin c, rodeado de cir√≠lico, con ruso p.  La necesidad de esto se identific√≥ despu√©s de analizar los nombres en la base de datos: muchos nombres en cir√≠lico inclu√≠an el lat√≠n c, que significa cir√≠lico c.  Cuando como si el nombre estuviera completamente en lat√≠n, el lat√≠n C significa cir√≠lico k o c.  Por lo tanto, antes de la transliteraci√≥n, es necesario reemplazar el car√°cter c. </li><li>  Eliminar n√∫meros demasiado grandes de los nombres.  A veces, en los nombres de los productos hay un n√∫mero de identificaci√≥n interno (por ejemplo, 3387522 K.Ts. Maslo podsoln.raf. 0.9l), que no tiene ning√∫n significado en el caso general. </li><li>  Reemplazar comas con puntos.  ¬øPor qu√© se necesita esto?  Para que los n√∫meros, por ejemplo, el contenido de grasa de la leche 3.2 y 3.2, sean equivalentes </li></ul><br><h5 id="tokenizer">  Tokenizer </h5><br><ul><li>  Tokenizador est√°ndar: separa las l√≠neas seg√∫n el espacio y los signos de puntuaci√≥n (p. Ej., "Twix extra 2" -&gt; "twix", "extra", "2") </li><li>  Tokenizer EdgeNGram: divide cada palabra en tokens de una longitud determinada (generalmente un rango de n√∫meros), comenzando con el primer car√°cter (por ejemplo, para N = [3, 6]: "twix extra 2" -&gt; "twee", "tweak", "Twix", "ex", "ext", "ext", "extra") </li><li>  Tokenizer para n√∫meros: selecciona solo n√∫meros de una cadena buscando una expresi√≥n regular (por ejemplo, "twix extra 2 4.5" -&gt; "2", "4.5") </li></ul><br><h5 id="token-filter">  Filtro de fichas </h5><br><ul><li>  Filtro en min√∫scula </li><li>  Filtro de tartamudeo: realiza un algoritmo de tartamudeo para cada token.  La derivaci√≥n es determinar la forma inicial de una palabra (por ejemplo, "arroz" -&gt; "arroz") </li><li>  An√°lisis fon√©tico.  Es necesario para minimizar la influencia de los errores tipogr√°ficos y las diferentes formas de escribir la misma palabra en los resultados de b√∫squeda.  La tabla muestra los diversos algoritmos disponibles para el an√°lisis fon√©tico y el resultado de su trabajo en casos problem√°ticos.  En el primer caso (Champ√∫ / champ√°n / champi√±√≥n / champi√±√≥n) el √©xito est√° determinado por la generaci√≥n de diferentes codificaciones, en el resto, lo mismo. </li></ul><br><p><img src="https://habrastorage.org/webt/gi/oi/x6/gioix68jytjyfxexdt3pvjpatze.png"></p><br><h3 id="similarity-model">  Modelo de similitud </h3><br><p>  El modelo de relevancia es necesario para determinar en qu√© medida la coincidencia de un token afecta la relevancia del objeto de la base de datos con respecto a la solicitud.  Suponga que si el token en la solicitud y el producto de la base de datos coinciden, esto ciertamente no es malo, pero dice poco sobre la conformidad del producto con la solicitud.  Por lo tanto, la coincidencia de diferentes tokens conlleva diferentes valores.  Para tener esto en cuenta, se necesita un modelo de relevancia.  Elastic ofrece muchos modelos diferentes.  Si realmente los comprende, puede elegir un modelo muy espec√≠fico y adecuado para un caso particular.  La elecci√≥n puede basarse en la cantidad de palabras que se usan con frecuencia (como el mismo token), una evaluaci√≥n de la importancia de los tokens largos (¬øm√°s largo significa mejor? ¬øPeor? ¬øNo importa?), ¬øQu√© resultados queremos ver al final, etc.  Ejemplos de modelos que se proponen en Elastic pueden ser TF-IDF (el modelo m√°s simple y m√°s comprensible), <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Okapi BM25</a> (TF-IDF mejorado, el modelo predeterminado), Divergencia de aleatoriedad, Divergencia de independencia, etc.  Cada modelo tambi√©n tiene opciones personalizables.  Despu√©s de varios experimentos con el modelo, el modelo predeterminado Okapi BM25 mostr√≥ el mejor resultado, pero con par√°metros diferentes a los predefinidos. </p><br><h1 id="ispolzovanie-kategoriy">  Usando categor√≠as </h1><br><p>  En el curso de trabajar con la b√∫squeda, se hizo disponible informaci√≥n adicional muy importante sobre el producto, su categor√≠a.  Puede leer m√°s sobre c√≥mo implementamos la categorizaci√≥n en el art√≠culo. <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Seg√∫n tengo entendido, como muchos dulces, o la clasificaci√≥n de los productos mediante el cheque en la aplicaci√≥n</a> .  Hasta entonces, basamos nuestra b√∫squeda solo en una comparaci√≥n de nombres de productos, ahora es posible comparar la categor√≠a de solicitud y los productos en la base de datos. <br>  Las opciones posibles para usar esta informaci√≥n son una coincidencia obligatoria en el campo de categor√≠a (formateado como un filtro de resultados), una ventaja adicional en forma de puntos para productos con la misma categor√≠a (como en el caso de los n√∫meros) y la clasificaci√≥n de los resultados por categor√≠a (primero coincidencia, luego todos los dem√°s).  Para nuestro caso, la √∫ltima opci√≥n funcion√≥ mejor.  Esto se debe a que nuestro algoritmo de categorizaci√≥n es demasiado bueno para usar el segundo m√©todo y no lo suficientemente bueno como para usar el primero.  Tenemos suficiente confianza en el algoritmo y queremos que la coincidencia de categor√≠as sea una gran ventaja.  En el caso de agregar puntos adicionales a la velocidad (segundo m√©todo), los productos con la misma categor√≠a subir√°n a la lista, pero a√∫n perder√°n frente a algunos productos que coinciden m√°s por su nombre.  Sin embargo, el primer m√©todo tampoco nos conviene, ya que los errores en la categorizaci√≥n a√∫n son posibles.  A veces, la solicitud puede contener informaci√≥n insuficiente para determinar correctamente la categor√≠a, o hay muy pocos productos en esta categor√≠a en el radio inmediato del usuario.  En este caso, todav√≠a queremos mostrar resultados con una categor√≠a diferente, pero a√∫n relevante por nombre de producto. <br>  El segundo m√©todo tambi√©n es bueno porque no "estropea" la velocidad de los productos como resultado de la b√∫squeda, y le permite continuar usando la velocidad m√≠nima calculada sin obst√°culos. <br>  La implementaci√≥n espec√≠fica del tipo se puede ver en la consulta final. </p><br><h1 id="finalnaya-model">  Modelo final </h1><br><p>  La selecci√≥n del modelo de b√∫squeda final incluy√≥ la generaci√≥n de varios motores de b√∫squeda, su evaluaci√≥n y comparaci√≥n.  Muy a menudo, la comparaci√≥n se bas√≥ en uno de los par√°metros.  Supongamos que en un caso espec√≠fico necesitamos calcular el mejor tama√±o para el tokenizer edgeNgram (es decir, elegir el rango m√°s efectivo de N).  Para hacer esto, generamos los mismos motores de b√∫squeda con solo una diferencia en el tama√±o de este rango.  Despu√©s de eso, fue posible determinar el mejor valor para este par√°metro. <br>  Los modelos se evaluaron utilizando la m√©trica nDCG (ganancia acumulada descontada normalizada), una m√©trica para evaluar la calidad de la clasificaci√≥n.  Se enviaron consultas predefinidas a cada modelo de b√∫squeda, despu√©s de lo cual se calcul√≥ la m√©trica nDCG en funci√≥n de los resultados de b√∫squeda recibidos. <br>  Analizadores que ingresaron al modelo final: </p><br><p><img src="https://habrastorage.org/webt/nb/-m/ti/nb-mtitufklquryy-5o3m2trrl4.jpeg"></p><br><p><img src="https://habrastorage.org/webt/5n/y3/6g/5ny36gkpfblbdtr5xvu8b4fx_r4.jpeg"></p><br><p><img src="https://habrastorage.org/webt/2r/er/zv/2rerzvbqvsdgezshkhpfeds2mc0.jpeg"></p><br><p><img src="https://habrastorage.org/webt/5h/tv/69/5htv691pabkoks90jq08h6nmdxo.jpeg"></p><br><p>  El modelo predeterminado (Okapi - BM25) con el par√°metro b = 0.5 fue elegido como el modelo de relevancia.  El valor predeterminado es 0,75.  Este par√°metro muestra hasta qu√© punto la longitud del nombre del producto normaliza la variable tf (frecuencia de t√©rmino).  Un n√∫mero menor en nuestro caso funciona mejor, ya que un nombre largo a menudo no afecta la importancia de una sola palabra.  Es decir, la palabra "chocolate" en el nombre "chocolate con avellanas trituradas en un paquete de 25 piezas" no pierde su valor por el hecho de que el nombre es lo suficientemente largo. </p><br><p>  La consulta final se ve as√≠: </p><br><p><img src="https://habrastorage.org/webt/ol/9y/5n/ol9y5nfbppfwyxhqaskziiypuru.jpeg"></p><br><p>  Experimentalmente, se revel√≥ la mejor combinaci√≥n de analizadores y pesos. </p><br><p>  Como resultado de la clasificaci√≥n, los productos con la misma categor√≠a van al principio de los resultados y luego a todos los dem√°s.  La ordenaci√≥n por el n√∫mero de puntos (velocidad) se almacena dentro de cada subconjunto. </p><br><p>  Para simplificar, el umbral de velocidad se establece en 15 en esta solicitud, aunque en nuestro sistema utilizamos el par√°metro calculado que se describi√≥ anteriormente. </p><br><h1 id="v-buduschem">  En el futuro </h1><br><p>  Se piensa mejorar la b√∫squeda resolviendo uno de los problemas m√°s vergonzosos de nuestro algoritmo, que es la existencia de un mill√≥n y una forma diferente de acortar una palabra de 5 letras.  Se puede resolver mediante el procesamiento inicial de nombres para revelar abreviaturas.  Una forma de resolver esto es intentar comparar el nombre abreviado de nuestra base de datos con uno de los nombres de la base de datos con los nombres completos "correctos".  Esta decisi√≥n encuentra sus obst√°culos definitivos, pero parece un cambio prometedor. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es433070/">https://habr.com/ru/post/es433070/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es433058/index.html">Quinteto como entidad b√°sica para describir un √°rea tem√°tica</a></li>
<li><a href="../es433060/index.html">Por qu√© no creo microbenchmarks</a></li>
<li><a href="../es433062/index.html">AXIS P1367 versus IDIS DC-B3303X: Comparar c√°maras CCTV</a></li>
<li><a href="../es433064/index.html">Gesti√≥n de incidentes: "no puede darse por vencido" o el arte de colocar comas</a></li>
<li><a href="../es433066/index.html">HighLoad Cup # 2. Campeonato para desarrolladores de back-end de nuevo en servicio</a></li>
<li><a href="../es433072/index.html">C√≥mo hackear la protecci√≥n de copia de la consola Sega Dreamcast</a></li>
<li><a href="../es433074/index.html">Cambiar a Kotlin en un proyecto de Android: consejos y trucos</a></li>
<li><a href="../es433076/index.html">C√≥mo creamos nuestra biblioteca de la Galer√≠a de Android para ver contenido multimedia</a></li>
<li><a href="../es433078/index.html">Escribimos robots comerciales utilizando el marco gr√°fico StockSharp. Parte 2</a></li>
<li><a href="../es433082/index.html">Bombear las cuentas de otras personas se ha convertido en un delito penal en Corea del Sur</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>