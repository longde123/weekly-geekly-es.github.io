<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>〽️ 🤽🏻 👩🏽‍🤝‍👨🏾 TDD-Anwendungen beim Spring Boot: Arbeiten mit einer Datenbank 🔌 ⛹🏻 😍</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Der zweite Artikel aus der Reihe "Testgesteuerte Entwicklung von Anwendungen auf Spring Boot" und dieses Mal werde ich über das Testen des Datenbankzu...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>TDD-Anwendungen beim Spring Boot: Arbeiten mit einer Datenbank</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/433958/"><p>  Der zweite Artikel aus der Reihe "Testgesteuerte Entwicklung von Anwendungen auf Spring Boot" und dieses Mal werde ich über das Testen des Datenbankzugriffs sprechen, ein wichtiger Aspekt des Integrationstests.  Ich werde Ihnen erklären, wie Sie die Schnittstelle eines zukünftigen Dienstes für den Datenzugriff durch Tests bestimmen, integrierte Speicherdatenbanken zum Testen verwenden, mit Transaktionen arbeiten und Testdaten in die Datenbank hochladen. </p><a name="habracut"></a><br><p>  Ich werde nicht viel über TDD und das Testen im Allgemeinen sprechen. Ich lade alle ein, den ersten Artikel zu lesen - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Wie man eine Pyramide im Kofferraum baut oder wie man Anwendungen im Spring Boot / Geek-Magazin testgetrieben entwickelt</a> </p><br><p>  Ich werde wie beim letzten Mal mit einem kleinen theoretischen Teil beginnen und zum End-to-End-Test übergehen. </p><br><h1 id="piramida-testirovaniya">  Pyramide testen </h1><br><p>  Zunächst eine kleine, aber notwendige Beschreibung einer so wichtigen Entität beim Testen wie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">der Testpyramide</a> oder <em>der Testpyramide</em> . </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/f6c/930/f2d/f6c930f2d4ae8a6068696ace34e9566e.png" alt="Bild"></p><br><p>  (entnommen aus <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">der praktischen Testpyramide</a> ) </p><br><p>  Die Testpyramide ist der Ansatz, wenn Tests auf mehreren Ebenen organisiert werden. </p><br><ul><li>  <strong>UI</strong> -Tests (oder End-to-End- <strong>E2E-</strong> Tests) gibt es nur wenige und sie sind langsam, aber sie testen die reale Anwendung - keine Verspottungen und Testgegenstücke.  Unternehmen denken oft auf dieser Ebene und alle BDD-Frameworks leben hier (siehe Gurke in einem vorherigen Artikel). </li><li>  Es folgen <strong>Integrationstests</strong> (Service, Komponente - jede hat ihre eigene Terminologie), die sich bereits auf eine bestimmte Komponente (Service) des Systems konzentrieren und diese durch Moki / Doubles von anderen Komponenten isolieren, aber dennoch die Integration mit realen externen Systemen überprüfen. Diese Tests sind miteinander verbunden an die Datenbank, REST-Anfragen senden, arbeite ich mit einer Nachrichtenwarteschlange.  In der Tat sind dies Tests, die die Integration der Geschäftslogik in die Außenwelt verifizieren. </li><li>  Ganz unten befinden sich schnelle <strong>Komponententests</strong> , bei denen die minimalen Codeblöcke (Klassen, Methoden) vollständig isoliert getestet werden. </li></ul><br><p>  Spring hilft beim Schreiben von Tests für jedes Level - <em>auch für Unit-Tests</em> , obwohl dies seltsam klingen mag, da in der Welt der Unit-Tests überhaupt kein Wissen über das Framework vorhanden sein sollte.  Nachdem ich den E2E-Test geschrieben habe, werde ich nur zeigen, wie Spring es auch solchen rein „integrationsbezogenen“ Dingen wie Controllern ermöglicht, isoliert zu testen. </p><br><p>  Aber ich werde ganz oben in der Pyramide beginnen - dem langsamen UI-Test, der eine vollwertige Anwendung startet und testet. </p><br><h1 id="end-to-end-test">  End-to-End-Test </h1><br><p>  Also eine neue Funktion: </p><br><pre><code class="plaintext hljs">Feature: A list of available cakes Background: catalogue is updated Given the following items are promoted | Title | Price | | Red Velvet | 3.95 | | Victoria Sponge | 5.50 | Scenario: a user visiting the web-site sees the list of items Given a new user, Alice When she visits Cake Factory web-site Then she sees that "Red Velvet" is available with price £3.95 And she sees that "Victoria Sponge" is available with price £5.50</code> </pre> <br><blockquote>  Und hier ist ein sofort interessanter Aspekt - was tun mit dem vorherigen Test über die Begrüßung auf der Hauptseite?  Es scheint nicht mehr relevant zu sein, nach dem Start der Site auf der Hauptseite gibt es bereits ein Verzeichnis, keine Begrüßung.  Es gibt keine einzige Antwort, würde ich sagen - es hängt von der Situation ab.  Aber der wichtigste Rat - lassen Sie sich nicht auf die Tests ein!  Löschen Sie, wenn sie an Relevanz verlieren, und schreiben Sie sie neu, um das Lesen zu erleichtern.  Insbesondere E2E-Tests - dies sollte in der Tat eine <strong>lebendige und aktuelle Spezifikation sein</strong> .  In meinem Fall habe ich nur die alten Tests gelöscht und durch neue ersetzt, wobei ich einige der vorherigen Schritte verwendet und nicht vorhandene hinzugefügt habe. </blockquote><p>  Jetzt bin ich an einem wichtigen Punkt angelangt - der Wahl der Technologie zum Speichern von Daten.  In Übereinstimmung mit dem <em>Lean-</em> Ansatz möchte ich die Auswahl bis zum allerletzten Moment verschieben - wenn ich sicher weiß, ob das relationale Modell oder nicht, was die Anforderungen an Konsistenz und Transaktionsfähigkeit sind.  Im Allgemeinen gibt es Lösungen dafür - zum Beispiel die Erstellung von <strong>Testzwillingen</strong> und verschiedenen <strong>In-Memory-</strong> Speichern, aber bisher möchte ich den Artikel nicht komplizieren und sofort die Technologie auswählen - relationale Datenbanken.  Um jedoch zumindest die Möglichkeit zu bewahren, eine Datenbank auszuwählen, werde ich eine Abstraktion hinzufügen - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Spring Data JPA</a> .  JPA selbst ist eine ziemlich abstrakte Spezifikation für den Zugriff auf relationale Datenbanken, und Spring Data macht die Verwendung noch einfacher. </p><br><blockquote>  Spring Data JPA verwendet standardmäßig Hibernate als Anbieter, unterstützt jedoch auch andere Technologien wie EclipseLink und MyBatis.  Für Leute, die mit der Java Persistence API nicht sehr vertraut sind - JPA ist wie eine Schnittstelle, und Hibernate ist eine Klasse, die sie implementiert. </blockquote><p>  Um die JPA-Unterstützung hinzuzufügen, habe ich einige Abhängigkeiten hinzugefügt: </p><br><pre> <code class="plaintext hljs">implementation('org.springframework.boot:spring-boot-starter-data-jpa') runtime('com.h2database:h2')</code> </pre> <br><p>  Als Datenbank werde ich <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">H2 verwenden</a> - eine in Java geschriebene eingebettete Datenbank mit der Fähigkeit, im In-Memory-Modus zu arbeiten. </p><br><p>  Mit Spring Data JPA definiere ich sofort eine Schnittstelle für den Zugriff auf Daten: </p><br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CakeRepository</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CrudRepository</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CakeEntity</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">String</span></span></span><span class="hljs-class">&gt; </span></span>{ }</code> </pre> <br><p>  Und die Essenz: </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Entity</span></span> <span class="hljs-meta"><span class="hljs-meta">@Builder</span></span> <span class="hljs-meta"><span class="hljs-meta">@AllArgsConstructor</span></span> <span class="hljs-meta"><span class="hljs-meta">@Table</span></span>(name = <span class="hljs-string"><span class="hljs-string">"cakes"</span></span>) <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CakeEntity</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CakeEntity</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ } <span class="hljs-meta"><span class="hljs-meta">@Id</span></span> <span class="hljs-meta"><span class="hljs-meta">@GeneratedValue</span></span>(strategy = GenerationType.IDENTITY) Long id; <span class="hljs-meta"><span class="hljs-meta">@NotBlank</span></span> String title; <span class="hljs-meta"><span class="hljs-meta">@Positive</span></span> BigDecimal price; <span class="hljs-meta"><span class="hljs-meta">@NotBlank</span></span> <span class="hljs-meta"><span class="hljs-meta">@NaturalId</span></span> String sku; <span class="hljs-keyword"><span class="hljs-keyword">boolean</span></span> promoted; <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">equals</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Object o)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span> == o) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (o == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> || getClass() != o.getClass()) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; CakeEntity cakeEntity = (CakeEntity) o; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Objects.equals(title, cakeEntity.title); } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">hashCode</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Objects.hash(title); } }</code> </pre> <br><p>  Die Beschreibung der Entität enthält einige weniger offensichtliche Dinge. </p><br><ul><li>  <code>@NaturalId</code> für das <code>@NaturalId</code> Feld.  Dieses Feld wird als „natürlicher Bezeichner“ zum Überprüfen der Gleichheit von Entitäten verwendet. Die Verwendung aller Felder oder <code>@Id</code> Felder in <code>equals</code> / <code>hashCode</code> Methoden ist eher ein Anti-Pattern.  Hier ist beispielsweise gut geschrieben, wie die Gleichheit von Entitäten korrekt überprüft <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">werden kann</a> . </li><li>  Um den Boilerplate-Code ein wenig zu reduzieren, verwende ich <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Project Lombok</a> - Annotation Processor für Java.  Sie können verschiedene nützliche Dinge hinzufügen, z. B. <code>@Builder</code> um automatisch einen Builder für die Klasse zu generieren, und <code>@AllArgsConstructor</code> , um einen Konstruktor für alle Felder zu erstellen. </li></ul><br><p>  Eine Schnittstellenimplementierung wird automatisch von Spring Data bereitgestellt. </p><br><h1 id="vniz-po-piramide">  Die Pyramide hinunter </h1><br><p>  Jetzt ist die Zeit gekommen, um zur nächsten Ebene der Pyramide zu gelangen.  Als Faustregel würde ich empfehlen, <strong>immer mit dem e2e-Test zu beginnen</strong> , da Sie so das "Endziel" und die Grenzen der neuen Funktion bestimmen können, aber es gibt keine weiteren strengen Regeln.  Es ist nicht erforderlich, zuerst einen Integrationstest zu schreiben, bevor Sie zur Einheitenebene wechseln.  Es ist nur meistens so, dass es bequemer und einfacher ist - und es ist ganz natürlich, unterzugehen. </p><br><p>  Aber gerade jetzt möchte ich diese Regel sofort brechen und einen Komponententest schreiben, der dabei hilft, die Schnittstelle und den Vertrag einer neuen Komponente zu bestimmen, die noch nicht existiert.  Der Controller sollte ein Modell zurückgeben, das von einer bestimmten Komponente X ausgefüllt wird, und ich habe diesen Test geschrieben: </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@ExtendWith</span></span>(MockitoExtension.class) <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IndexControllerTest</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Mock</span></span> CakeFinder cakeFinder; <span class="hljs-meta"><span class="hljs-meta">@InjectMocks</span></span> IndexController indexController; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Set&lt;Cake&gt; cakes = Set.of(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Cake(<span class="hljs-string"><span class="hljs-string">"Test 1"</span></span>, <span class="hljs-string"><span class="hljs-string">"£10"</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Cake(<span class="hljs-string"><span class="hljs-string">"Test 2"</span></span>, <span class="hljs-string"><span class="hljs-string">"£10"</span></span>)); <span class="hljs-meta"><span class="hljs-meta">@BeforeEach</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setUp</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ when(cakeFinder.findPromotedCakes()).thenReturn(cakes); } <span class="hljs-meta"><span class="hljs-meta">@Test</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">shouldReturnAListOfFoundPromotedCakes</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ ModelAndView index = indexController.index(); assertThat(index.getModel()).extracting(<span class="hljs-string"><span class="hljs-string">"cakes"</span></span>).contains(cakes); } }</code> </pre> <br><p>  Dies ist ein reiner Unit-Test - keine Kontexte, keine Datenbanken hier, nur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Mockito</a> für Mok.  Und dieser Test ist nur eine gute Demonstration, wie Spring Unit-Tests hilft - der <em>Controller in Spring MVC ist nur eine Klasse, deren Methoden Parameter gewöhnlicher Typen akzeptieren und POJO-Objekte zurückgeben - Modelle anzeigen</em> .  Es gibt keine HTTP-Anforderungen, keine Antworten, Header, JSON, XML - all dies wird automatisch in Form von Konvertern und Serialisierern auf den Stapel angewendet.  Ja, es gibt einen kleinen "Hinweis" auf Spring in Form von <code>ModelAndView</code> , aber dies ist ein reguläres POJO, und Sie können es sogar entfernen, wenn Sie möchten, es wird speziell für UI-Controller benötigt. </p><br><blockquote>  Ich werde nicht viel über Mockito sprechen, Sie können alles in der offiziellen Dokumentation lesen.  Insbesondere gibt es in diesem Test nur interessante Punkte - ich verwende <code>MockitoExtension.class</code> als Testläufer und es werden automatisch Mokas für von <code>@Mock</code> kommentierte Felder <code>@Mock</code> und diese Mokas dann als Abhängigkeiten in den Konstruktor für das Objekt in das mit <code>@InjectMocks</code> gekennzeichnete Feld <code>@InjectMocks</code> .  Sie können dies alles manuell mit der <code>Mockito.mock()</code> -Methode tun und dann eine Klasse erstellen. </blockquote><p>  Mit diesem Test können Sie die Methode der neuen Komponente ermitteln - <code>findPromotedCakes</code> , eine Liste der Kuchen, die auf der Hauptseite <code>findPromotedCakes</code> sollen.  Er bestimmt nicht, was es ist oder wie es mit der Datenbank funktionieren soll.  Es liegt in der alleinigen Verantwortung des Controllers, das übertragene Material zu übernehmen und die Modelle ("Kuchen") in einem bestimmten Bereich zurückzugeben.  Trotzdem hat <code>CakeFinder</code> bereits die erste Methode in meiner Oberfläche, was bedeutet, dass Sie einen Integrationstest dafür schreiben können. </p><br><blockquote>  Ich habe absichtlich alle Klassen innerhalb des <code>cakes</code> <strong>privat gemacht,</strong> damit niemand außerhalb des Pakets sie verwenden kann.  Der einzige Weg, um Daten aus der Datenbank abzurufen, ist die CakeFinder-Schnittstelle, die meine „Komponente X“ für den Zugriff auf die Datenbank ist.  Es wird zu einem natürlichen „Stecker“, den ich leicht einrasten kann, wenn ich etwas isoliert testen und die Basis nicht berühren muss.  Die einzige Implementierung ist JpaCakeFinder.  Wenn sich beispielsweise der Datenbanktyp oder die Datenquelle in Zukunft ändern, müssen Sie eine Implementierung der <code>CakeFinder</code> Schnittstelle <code>CakeFinder</code> , ohne den Code zu ändern, der sie verwendet. </blockquote><br><h1 id="integracionnyy-test-dlya-jpa-ispolzuya-datajpatest">  Integrationstest für JPA mit @DataJpaTest </h1><br><p>  Integrationstests sind Frühlingsbrot und Butter.  Tatsächlich wurde für Integrationstests alles so gut gemacht, dass Entwickler manchmal nicht auf die Einheitenebene wechseln oder die UI-Ebene vernachlässigen möchten.  Das ist weder schlecht noch gut - ich wiederhole, dass das Hauptziel der Tests das Vertrauen ist.  Eine Reihe schneller und effektiver Integrationstests kann ausreichen, um dieses Vertrauen zu schaffen.  Es besteht jedoch die Gefahr, dass diese Tests im Laufe der Zeit entweder langsamer oder langsamer werden oder einfach mit dem isolierten Testen von Komponenten anstelle der Integration beginnen. </p><br><p>  Integrationstests können die Anwendung <code>@SpringBootTest</code> ( <code>@SpringBootTest</code> ) oder ihre separate Komponente (JPA, Web) <code>@SpringBootTest</code> .  In meinem Fall möchte ich einen gezielten Test für JPA schreiben, sodass ich keine Controller oder andere Komponenten konfigurieren muss.  Die Annotation <code>@DataJpaTest</code> ist im Spring Boot Test dafür verantwortlich.  Dies ist eine <em>Meta-</em> Annotation, d.h.  Es kombiniert verschiedene Anmerkungen, die verschiedene Aspekte des Tests konfigurieren. </p><br><ul><li>  @AutoConfigureDataJpa </li><li>  @AutoConfigureTestDatabase </li><li>  @AutoConfigureCache </li><li>  @AutoConfigureTestEntityManager </li><li>  @Transactional </li></ul><br><p>  Zuerst erzähle ich Ihnen jedes einzeln und dann zeige ich Ihnen den fertigen Test. </p><br><p>  <strong>@AutoConfigureDataJpa</strong> <br>  Es lädt eine ganze Reihe von Konfigurationen und richtet Repositorys (automatische Generierung von Implementierungen für <code>CrudRepositories</code> ) sowie Migrationstools für die FlyWay- und Liquibase-Datenbanken ein und stellt mithilfe von DataSource, Transaktionsmanager und schließlich Hibernate eine Verbindung zur Datenbank her.  Tatsächlich handelt es sich hierbei nur um eine Reihe von Konfigurationen, die für den Zugriff auf Daten relevant sind. Weder <code>DispatcherServlet</code> von Web MVC noch andere Komponenten sind hier enthalten. </p><br><p>  <strong>@AutoConfigureTestDatabase</strong> <br>  Dies ist einer der interessantesten Aspekte des JPA-Tests.  Diese Konfiguration <em>durchsucht den Klassenpfad nach einer der unterstützten eingebetteten Datenbanken und konfiguriert den Kontext neu, sodass die DataSource auf eine zufällig erstellte speicherinterne Datenbank verweist</em> .  Da ich die Abhängigkeit zur H2-Basis hinzugefügt habe, muss ich nichts weiter tun. Nur diese Annotation automatisch für jeden Testlauf zu haben, ergibt eine leere Basis, und dies ist einfach unglaublich praktisch. </p><br><p>  Es sei daran erinnert, dass diese Basis ohne Schema vollständig leer sein wird.  Um die Schaltung zu erzeugen, gibt es mehrere Möglichkeiten. </p><br><ol><li>  Verwenden Sie die <strong>Auto-DDL-</strong> Funktion aus dem Ruhezustand.  Der Spring Boot Test setzt diesen Wert automatisch auf <code>create-drop</code> sodass Hibernate aus der Entitätsbeschreibung ein Schema generiert und es am Ende der Sitzung löscht.  Dies ist eine unglaublich leistungsstarke Funktion von Hibernate, die für Tests sehr nützlich ist. </li><li>  Verwenden Sie Migrationen, die von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Flyway</a> oder <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Liquibase erstellt wurden</a> . </li></ol><br><p>  Weitere Informationen zu den verschiedenen Ansätzen zur Initialisierung der Datenbank finden Sie in der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Dokumentation</a> . </p><br><p>  <strong>@AutoConfigureCache</strong> <br>  Es konfiguriert nur den Cache für die Verwendung von NoOpCacheManager - d. H.  Cache nichts.  Dies ist nützlich, um Überraschungen bei Tests zu vermeiden. </p><br><p>  <strong>@AutoConfigureTestEntityManager</strong> <br>  Fügt dem <code>TestEntityManager</code> ein spezielles <code>TestEntityManager</code> Objekt hinzu, das an sich schon ein interessantes Tier ist.  <code>EntityManager</code> ist die Hauptklasse von JPA, die für das Hinzufügen von Entitäten zur Sitzung, das Löschen und ähnliche Dinge verantwortlich ist.  Nur wenn beispielsweise der Ruhezustand in Betrieb genommen wird - das Hinzufügen einer Entität zu einer Sitzung bedeutet nicht, dass eine Anforderung an die Datenbank ausgeführt wird, und das Laden aus einer Sitzung bedeutet nicht, dass eine ausgewählte Anforderung ausgeführt wird.  Aufgrund der internen Mechanismen von Hibernate werden reale Vorgänge mit der Datenbank zum richtigen Zeitpunkt ausgeführt, den das Framework selbst bestimmt.  Bei Tests kann es jedoch erforderlich sein, etwas zwangsweise an die Datenbank zu senden, da der Zweck der Tests darin besteht, die Integration zu testen.  Und <code>TestEntityManager</code> ist nur ein <code>TestEntityManager</code> mit dem einige Vorgänge mit der Datenbank zwangsweise ausgeführt werden können. Beispielsweise <code>persistAndFlush()</code> Hibernate, alle Anforderungen auszuführen. </p><br><p>  <strong>@Transactional</strong> <br>  Diese Annotation macht alle Tests in der Klasse transaktional, wobei die Transaktion nach Abschluss des Tests automatisch zurückgesetzt wird.  Dies ist nur ein Mechanismus zum „Bereinigen“ der Datenbank vor jedem Test, da Sie sonst Daten aus jeder Tabelle manuell löschen müssten. </p><br><blockquote>  Ob ein Test eine Transaktion verwalten sollte, ist keine so einfache und offensichtliche Frage, wie es scheinen mag.  Trotz der Bequemlichkeit des "sauberen" Status der Datenbank kann das Vorhandensein von <code>@Transactional</code> in Tests eine unangenehme Überraschung sein, wenn der "Battle" -Code die Transaktion nicht selbst startet, sondern eine vorhandene erfordert.  Dies kann dazu führen, dass der Integrationstest bestanden wird. Wenn jedoch der reale Code vom Controller und nicht vom Test ausgeführt wird, hat der Dienst keine aktive Transaktion und die Methode löst eine Ausnahme aus.  Obwohl dies gefährlich aussieht, sind Transaktionstests bei Tests der Benutzeroberfläche auf hoher Ebene nicht so schlecht.  Nach meiner Erfahrung habe ich nur einmal gesehen, dass ein bestehender Integrationstest den Produktionscode zum Absturz brachte, was eindeutig das Vorhandensein einer vorhandenen Transaktion erforderte.  Wenn Sie jedoch weiterhin überprüfen müssen, ob die Services und Komponenten selbst Transaktionen korrekt verwalten, können Sie die Annotation <code>@Transactional</code> für den Test im gewünschten Modus „blockieren“ (z. B. die Transaktion nicht starten). </blockquote><br><h1 id="integracionnyy-test-so-springboottest">  Integrationstest mit @SpringBootTest </h1><br><p>  Ich möchte auch darauf hinweisen, dass <code>@DataJpaTest</code> kein einzigartiges Beispiel für einen <code>@DataJpaTest</code> ist. Es gibt <code>@WebMvcTest</code> , <code>@DataMongoTest</code> und viele andere.  Eine der wichtigsten <code>@SpringBootTest</code> bleibt jedoch <code>@SpringBootTest</code> , mit dem die Anwendung <em>"wie sie ist"</em> für die Tests <code>@SpringBootTest</code> wird - mit allen konfigurierten Komponenten und Integrationen.  Es stellt sich eine logische Frage: Wenn Sie die gesamte Anwendung ausführen können, warum werden beispielsweise fokale DataJpa-Tests durchgeführt?  Ich würde sagen, dass es hier wieder keine strengen Regeln gibt. </p><br><p>  Wenn <em>es möglich ist</em> , jedes Mal Anwendungen auszuführen, Abstürze in Tests zu isolieren, das Setup des Tests nicht zu überlasten und nicht erneut zu komplizieren, können und sollten Sie natürlich @SpringBootTest verwenden. </p><br><p>  Im wirklichen Leben können Anwendungen jedoch viele verschiedene Einstellungen erfordern, eine Verbindung zu verschiedenen Systemen herstellen, und ich möchte nicht, dass meine Datenbankzugriffstests fallen, weil  Die Verbindung zur Nachrichtenwarteschlange ist nicht konfiguriert.  Daher ist es wichtig, den gesunden Menschenverstand zu verwenden. Wenn der Test mit der Annotation @SpringBootTest funktioniert, müssen Sie die Hälfte des Systems sperren. Ist dies dann in @SpringBootTest überhaupt sinnvoll? </p><br><h1 id="podgotovka-dannyh-dlya-testa">  Vorbereitung der Daten für den Test </h1><br><p>  Einer der wichtigsten Punkte beim Testen ist die Datenaufbereitung.  Jeder Test sollte isoliert durchgeführt werden und die Umgebung vor dem Start vorbereiten, um das System in den ursprünglich gewünschten Zustand zu bringen.  Die einfachste Möglichkeit, dies zu tun, besteht darin, die Anmerkungen <code>@BeforeEach</code> / <code>@BeforeAll</code> und dort mithilfe des Repositorys, <code>EntityManager</code> oder <code>TestEntityManager</code> Einträge zur Datenbank <code>TestEntityManager</code> .  Es gibt jedoch noch eine andere Option, mit der Sie ein vorbereitetes Skript ausführen oder die gewünschte SQL-Abfrage ausführen können. Dies ist die <code>@Sql</code> SQL-Annotation.  Vor dem Ausführen des Tests führt der Spring Boot-Test automatisch das angegebene Skript aus, sodass der Block <code>@Transactional</code> mehr <code>@Transactional</code> werden <code>@BeforeAll</code> , und <code>@Transactional</code> kümmert sich um die Datenbereinigung. </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@DataJpaTest</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">JpaCakeFinderTest</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> String PROMOTED_CAKE = <span class="hljs-string"><span class="hljs-string">"Red Velvet"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> String NON_PROMOTED_CAKE = <span class="hljs-string"><span class="hljs-string">"Victoria Sponge"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> CakeFinder finder; <span class="hljs-meta"><span class="hljs-meta">@Autowired</span></span> CakeRepository cakeRepository; <span class="hljs-meta"><span class="hljs-meta">@Autowired</span></span> TestEntityManager testEntityManager; <span class="hljs-meta"><span class="hljs-meta">@BeforeEach</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setUp</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.testEntityManager.persistAndFlush(CakeEntity.builder().title(PROMOTED_CAKE) .sku(<span class="hljs-string"><span class="hljs-string">"SKU1"</span></span>).price(BigDecimal.TEN).promoted(<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>).build()); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.testEntityManager.persistAndFlush(CakeEntity.builder().sku(<span class="hljs-string"><span class="hljs-string">"SKU2"</span></span>) .title(NON_PROMOTED_CAKE).price(BigDecimal.ONE).promoted(<span class="hljs-keyword"><span class="hljs-keyword">false</span></span>).build()); finder = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> JpaCakeFinder(cakeRepository); } ... }</code> </pre> <br><h1 id="red-green-refactor-cikl">  Rot-Grün-Refaktor-Zyklus </h1><br><p>  Trotz dieser Textmenge sieht der Test für den Entwickler immer noch wie eine einfache Klasse mit der Annotation @DataJpaTest aus, aber ich hoffe, dass ich zeigen konnte, wie viele nützliche Dinge unter der Haube passieren, an die der Entwickler nicht denken kann.  Jetzt können wir zum TDD-Zyklus übergehen und dieses Mal werde ich einige TDD-Iterationen mit Beispielen für Refactoring und minimalem Code zeigen.  Um es klarer zu machen, empfehle ich dringend, dass Sie sich den Verlauf in Git ansehen, in dem jedes Commit ein separater und wichtiger Schritt mit einer Beschreibung dessen ist, was und wie es funktioniert. </p><br><h2 id="podgotovka-dannyh">  Datenaufbereitung </h2><br><p>  Ich verwende den Ansatz mit <code>@BeforeAll</code> / <code>@BeforeEach</code> und erstelle manuell alle Datensätze in der Datenbank.  Das Beispiel mit der Annotation <code>@Sql</code> wird in eine separate Klasse <code>JpaCakeFinderTestWithScriptSetup</code> . Es dupliziert Tests, die natürlich nicht sein sollten und nur zum Zweck der Demonstration des Ansatzes existieren. </p><br><p>  Der Anfangszustand des Systems - es gibt zwei Einträge im System, ein Kuchen nimmt an der Aktion teil und muss in das von der Methode zurückgegebene Ergebnis einbezogen werden, der zweite - Nr. </p><br><h2 id="pervyy-test-integracionnyy-test">  Erster Test Integrationstest </h2><br><p>  Der erste Test ist der einfachste - <code>findPromotedCakes</code> sollte eine Beschreibung und einen Preis des an der Aktion teilnehmenden Kuchens enthalten. </p><br><h3 id="red">  Rot </h3><br><pre> <code class="java hljs"> <span class="hljs-meta"><span class="hljs-meta">@Test</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">shouldReturnPromotedCakes</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ Iterable&lt;Cake&gt; promotedCakes = finder.findPromotedCakes(); assertThat(promotedCakes).extracting(Cake::getTitle).contains(PROMOTED_CAKE); assertThat(promotedCakes).extracting(Cake::getPrice).contains(<span class="hljs-string"><span class="hljs-string">"£10.00"</span></span>); }</code> </pre> <br><p>  Der Test stürzt natürlich ab - die Standardimplementierung gibt einen leeren Satz zurück. </p><br><h3 id="green">  Grün </h3><br><p>  Natürlich möchten wir die Filterung sofort schreiben, eine Anfrage an die Datenbank mit <code>where</code> und so weiter.  Aber nach der TDD-Praxis muss ich den <em>Mindestcode</em> schreiben <em>, damit der Test bestanden wird</em> .  Und dieser minimale Code soll alle Datensätze in der Datenbank zurückgeben.  Ja, so einfach und kitschig. </p><br><pre> <code class="java hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Set&lt;Cake&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">findPromotedCakes</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ Spliterator&lt;CakeEntity&gt; cakes = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.cakeRepository.findAll() .spliterator(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> StreamSupport.stream(cakes, <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>).map( cakeEntity -&gt; <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Cake(cakeEntity.title, formatPrice(cakeEntity.price))) .collect(Collectors.toSet()); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">formatPrice</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(BigDecimal price)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"£"</span></span> + price.setScale(<span class="hljs-number"><span class="hljs-number">2</span></span>, RoundingMode.DOWN).toPlainString(); }</code> </pre> <br><blockquote>  Wahrscheinlich würden einige argumentieren, dass Sie hier den Test auch ohne Basis grün machen können - codieren Sie einfach das vom Test erwartete Ergebnis fest.  Ich höre gelegentlich ein solches Argument, aber ich denke, jeder versteht, dass TDD kein Dogma oder eine Religion ist. Es macht keinen Sinn, dies auf den Punkt der Absurdität zu bringen.  Wenn Sie dies jedoch wirklich möchten, können Sie beispielsweise Daten in der Installation nach dem Zufallsprinzip sortieren, damit sie nicht fest codiert werden. </blockquote><br><h3 id="refactor">  Refactor </h3><br><p>  Ich sehe hier nicht viel Refactoring, daher kann diese Phase für diesen speziellen Test übersprungen werden.  Aber ich würde immer noch nicht empfehlen, diese Phase zu ignorieren. Es ist besser, jedes Mal im „grünen“ Zustand des Systems anzuhalten und nachzudenken. Ist es möglich, etwas umzugestalten, um es besser und einfacher zu machen? </p><br><h2 id="vtoroy-test">  Zweiter Test </h2><br><p>  Der zweite Test bestätigt jedoch bereits, dass kein beworbener Kuchen in das von <code>findPromotedCakes</code> Ergebnis <code>findPromotedCakes</code> . </p><br><pre> <code class="java hljs"> <span class="hljs-meta"><span class="hljs-meta">@Test</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">shouldNotReturnNonPromotedCakes</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ Iterable&lt;Cake&gt; promotedCakes = finder.findPromotedCakes(); assertThat(promotedCakes).extracting(Cake::getTitle) .doesNotContain(NON_PROMOTED_CAKE); }</code> </pre> <br><h3 id="red-1">  Rot </h3><br><p>  Der Test stürzt erwartungsgemäß ab - die Datenbank enthält zwei Datensätze, und der Code gibt einfach alle zurück. </p><br><h3 id="green-1">  Grün </h3><br><p>  Und wieder können Sie denken - und was ist der Mindestcode, den Sie schreiben können, um den Test zu bestehen?  Da es bereits einen Stream und dessen Assembly gibt, können Sie dort einfach einen <code>filter</code> hinzufügen. </p><br><pre> <code class="java hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Set&lt;Cake&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">findPromotedCakes</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ Spliterator&lt;CakeEntity&gt; cakes = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.cakeRepository.findAll() .spliterator(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> StreamSupport.stream(cakes, <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>) .filter(cakeEntity -&gt; cakeEntity.promoted) .map(cakeEntity -&gt; <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Cake(cakeEntity.title, formatPrice(cakeEntity.price))) .collect(Collectors.toSet()); }</code> </pre> <br><p>  Wir starten Tests neu - Integrationstests sind jetzt grün.  Ein wichtiger Moment ist gekommen - aufgrund der Kombination aus dem Komponententest des Controllers und dem Integrationstest für die Arbeit mit der Datenbank ist meine Funktion bereit - und der UI-Test ist jetzt erfolgreich! </p><br><h3 id="refactor-1">  Refactor </h3><br><p>  Und da alle Tests grün sind, ist es Zeit für eine Umgestaltung.  Ich denke, es muss nicht klargestellt werden, dass das Filtern im Speicher keine gute Idee ist. Es ist besser, dies in der Datenbank zu tun.  Zu diesem <code>CakesRepository</code> ich im <code>CakesRepository</code> eine neue Methode <code>CakesRepository</code> - <code>findByPromotedIsTrue</code> : </p><br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CakeRepository</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CrudRepository</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CakeEntity</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">String</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-function"><span class="hljs-function">Iterable&lt;CakeEntity&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">findByPromotedIsTrue</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; }</code> </pre> <br><p>  Für diese Methode hat Spring Data automatisch eine Methode generiert, die eine Abfrage der Formularauswahl <code>select from cakes where promoted = true</code> ausführt <code>select from cakes where promoted = true</code> .  Weitere Informationen zur Generierung von Abfragen finden Sie in der Spring Data- <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Dokumentation</a> . </p><br><pre> <code class="java hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Set&lt;Cake&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">findPromotedCakes</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ Spliterator&lt;CakeEntity&gt; cakes = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.cakeRepository.findByPromotedIsTrue() .spliterator(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> StreamSupport.stream(cakes, <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>).map( cakeEntity -&gt; <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Cake(cakeEntity.title, formatPrice(cakeEntity.price))) .collect(Collectors.toSet()); }</code> </pre> <br><p>  Dies ist ein gutes Beispiel für die Flexibilität, die Integrationstests und der Black-Box-Ansatz bieten.  Wenn das Repository gesperrt war, war das Hinzufügen einer neuen Methode ohne Änderung der Tests nicht unmöglich. </p><br><h1 id="podklyuchenie-k-production-baze">  Verbindung zur Produktionsbasis </h1><br><p>  Um ein wenig „Realismus“ hinzuzufügen und zu zeigen, wie Sie die Konfiguration für Tests und die Hauptanwendung trennen können, füge ich eine Datenzugriffskonfiguration für die Anwendung „Produktion“ hinzu. </p><br><p>  Alles wird traditionell durch den Abschnitt in <code>application.yml</code> hinzugefügt: </p><br><pre> <code class="plaintext hljs">datasource: url: jdbc:h2:./data/cake-factory</code> </pre><br><p>  Dadurch werden die Daten im Dateisystem automatisch im Ordner <code>./data</code> .  Ich <code>@DataJpaTest</code> fest, dass dieser Ordner in Tests nicht erstellt wird. <code>@DataJpaTest</code> ersetzt aufgrund des Vorhandenseins der Annotation <code>@DataJpaTest</code> automatisch die Verbindung zur <code>@DataJpaTest</code> durch eine zufällige Datenbank im Speicher. </p><br><blockquote>  Zwei nützliche Dinge, die nützlich sein können, sind die <code>schema.sql</code> <code>data.sql</code> und <code>schema.sql</code> .   , Spring Boot             .          ,   , ,    . </blockquote><br><h1 id="zaklyuchenie">  Fazit </h1><br><p> ,               ,    ,       TDD . </p><br><p>      Spring Security —                Spring,       . </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de433958/">https://habr.com/ru/post/de433958/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de433946/index.html">Spickzettel für künstliche Intelligenz - werfen Sie den Überschuss weg, lehren Sie die Hauptsache. Trainingssequenz-Verarbeitungstechnik</a></li>
<li><a href="../de433948/index.html">So machen Sie die Zahlung bequemer: die Erfahrung eines IaaS-Anbieters</a></li>
<li><a href="../de433952/index.html">10 Gründe, sich für eine Lösung für SAP HANA von HPE zu entscheiden. Teil 2</a></li>
<li><a href="../de433954/index.html">Acht Audiotechnologien und Audio-Gadgets, die 2019 in die TECnology Hall of Fame aufgenommen werden</a></li>
<li><a href="../de433956/index.html">Modder haben KI verwendet, um die Textur in Spielen zu verbessern</a></li>
<li><a href="../de433964/index.html">ECMAScript-Module in Node.js: Ein neuer Plan</a></li>
<li><a href="../de433966/index.html">Weihnachtskarte vom Mars. Die ESA zeigte eine große Ansammlung von Eis auf der Oberfläche des roten Planeten</a></li>
<li><a href="../de433968/index.html">Das degenerierteste Kommunikationsspiel</a></li>
<li><a href="../de433972/index.html">HolyJS 2018 Moskau mit den Augen des Teilnehmers</a></li>
<li><a href="../de433974/index.html">Chatbot bekommt Gehör oder Amateurleiden</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>