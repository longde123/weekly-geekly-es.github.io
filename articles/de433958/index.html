<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>„ÄΩÔ∏è ü§Ωüèª üë©üèΩ‚Äçü§ù‚Äçüë®üèæ TDD-Anwendungen beim Spring Boot: Arbeiten mit einer Datenbank üîå ‚õπüèª üòç</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Der zweite Artikel aus der Reihe "Testgesteuerte Entwicklung von Anwendungen auf Spring Boot" und dieses Mal werde ich √ºber das Testen des Datenbankzu...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>TDD-Anwendungen beim Spring Boot: Arbeiten mit einer Datenbank</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/433958/"><p>  Der zweite Artikel aus der Reihe "Testgesteuerte Entwicklung von Anwendungen auf Spring Boot" und dieses Mal werde ich √ºber das Testen des Datenbankzugriffs sprechen, ein wichtiger Aspekt des Integrationstests.  Ich werde Ihnen erkl√§ren, wie Sie die Schnittstelle eines zuk√ºnftigen Dienstes f√ºr den Datenzugriff durch Tests bestimmen, integrierte Speicherdatenbanken zum Testen verwenden, mit Transaktionen arbeiten und Testdaten in die Datenbank hochladen. </p><a name="habracut"></a><br><p>  Ich werde nicht viel √ºber TDD und das Testen im Allgemeinen sprechen. Ich lade alle ein, den ersten Artikel zu lesen - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Wie man eine Pyramide im Kofferraum baut oder wie man Anwendungen im Spring Boot / Geek-Magazin testgetrieben entwickelt</a> </p><br><p>  Ich werde wie beim letzten Mal mit einem kleinen theoretischen Teil beginnen und zum End-to-End-Test √ºbergehen. </p><br><h1 id="piramida-testirovaniya">  Pyramide testen </h1><br><p>  Zun√§chst eine kleine, aber notwendige Beschreibung einer so wichtigen Entit√§t beim Testen wie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">der Testpyramide</a> oder <em>der Testpyramide</em> . </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/f6c/930/f2d/f6c930f2d4ae8a6068696ace34e9566e.png" alt="Bild"></p><br><p>  (entnommen aus <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">der praktischen Testpyramide</a> ) </p><br><p>  Die Testpyramide ist der Ansatz, wenn Tests auf mehreren Ebenen organisiert werden. </p><br><ul><li>  <strong>UI</strong> -Tests (oder End-to-End- <strong>E2E-</strong> Tests) gibt es nur wenige und sie sind langsam, aber sie testen die reale Anwendung - keine Verspottungen und Testgegenst√ºcke.  Unternehmen denken oft auf dieser Ebene und alle BDD-Frameworks leben hier (siehe Gurke in einem vorherigen Artikel). </li><li>  Es folgen <strong>Integrationstests</strong> (Service, Komponente - jede hat ihre eigene Terminologie), die sich bereits auf eine bestimmte Komponente (Service) des Systems konzentrieren und diese durch Moki / Doubles von anderen Komponenten isolieren, aber dennoch die Integration mit realen externen Systemen √ºberpr√ºfen. Diese Tests sind miteinander verbunden an die Datenbank, REST-Anfragen senden, arbeite ich mit einer Nachrichtenwarteschlange.  In der Tat sind dies Tests, die die Integration der Gesch√§ftslogik in die Au√üenwelt verifizieren. </li><li>  Ganz unten befinden sich schnelle <strong>Komponententests</strong> , bei denen die minimalen Codebl√∂cke (Klassen, Methoden) vollst√§ndig isoliert getestet werden. </li></ul><br><p>  Spring hilft beim Schreiben von Tests f√ºr jedes Level - <em>auch f√ºr Unit-Tests</em> , obwohl dies seltsam klingen mag, da in der Welt der Unit-Tests √ºberhaupt kein Wissen √ºber das Framework vorhanden sein sollte.  Nachdem ich den E2E-Test geschrieben habe, werde ich nur zeigen, wie Spring es auch solchen rein ‚Äûintegrationsbezogenen‚Äú Dingen wie Controllern erm√∂glicht, isoliert zu testen. </p><br><p>  Aber ich werde ganz oben in der Pyramide beginnen - dem langsamen UI-Test, der eine vollwertige Anwendung startet und testet. </p><br><h1 id="end-to-end-test">  End-to-End-Test </h1><br><p>  Also eine neue Funktion: </p><br><pre><code class="plaintext hljs">Feature: A list of available cakes Background: catalogue is updated Given the following items are promoted | Title | Price | | Red Velvet | 3.95 | | Victoria Sponge | 5.50 | Scenario: a user visiting the web-site sees the list of items Given a new user, Alice When she visits Cake Factory web-site Then she sees that "Red Velvet" is available with price ¬£3.95 And she sees that "Victoria Sponge" is available with price ¬£5.50</code> </pre> <br><blockquote>  Und hier ist ein sofort interessanter Aspekt - was tun mit dem vorherigen Test √ºber die Begr√º√üung auf der Hauptseite?  Es scheint nicht mehr relevant zu sein, nach dem Start der Site auf der Hauptseite gibt es bereits ein Verzeichnis, keine Begr√º√üung.  Es gibt keine einzige Antwort, w√ºrde ich sagen - es h√§ngt von der Situation ab.  Aber der wichtigste Rat - lassen Sie sich nicht auf die Tests ein!  L√∂schen Sie, wenn sie an Relevanz verlieren, und schreiben Sie sie neu, um das Lesen zu erleichtern.  Insbesondere E2E-Tests - dies sollte in der Tat eine <strong>lebendige und aktuelle Spezifikation sein</strong> .  In meinem Fall habe ich nur die alten Tests gel√∂scht und durch neue ersetzt, wobei ich einige der vorherigen Schritte verwendet und nicht vorhandene hinzugef√ºgt habe. </blockquote><p>  Jetzt bin ich an einem wichtigen Punkt angelangt - der Wahl der Technologie zum Speichern von Daten.  In √úbereinstimmung mit dem <em>Lean-</em> Ansatz m√∂chte ich die Auswahl bis zum allerletzten Moment verschieben - wenn ich sicher wei√ü, ob das relationale Modell oder nicht, was die Anforderungen an Konsistenz und Transaktionsf√§higkeit sind.  Im Allgemeinen gibt es L√∂sungen daf√ºr - zum Beispiel die Erstellung von <strong>Testzwillingen</strong> und verschiedenen <strong>In-Memory-</strong> Speichern, aber bisher m√∂chte ich den Artikel nicht komplizieren und sofort die Technologie ausw√§hlen - relationale Datenbanken.  Um jedoch zumindest die M√∂glichkeit zu bewahren, eine Datenbank auszuw√§hlen, werde ich eine Abstraktion hinzuf√ºgen - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Spring Data JPA</a> .  JPA selbst ist eine ziemlich abstrakte Spezifikation f√ºr den Zugriff auf relationale Datenbanken, und Spring Data macht die Verwendung noch einfacher. </p><br><blockquote>  Spring Data JPA verwendet standardm√§√üig Hibernate als Anbieter, unterst√ºtzt jedoch auch andere Technologien wie EclipseLink und MyBatis.  F√ºr Leute, die mit der Java Persistence API nicht sehr vertraut sind - JPA ist wie eine Schnittstelle, und Hibernate ist eine Klasse, die sie implementiert. </blockquote><p>  Um die JPA-Unterst√ºtzung hinzuzuf√ºgen, habe ich einige Abh√§ngigkeiten hinzugef√ºgt: </p><br><pre> <code class="plaintext hljs">implementation('org.springframework.boot:spring-boot-starter-data-jpa') runtime('com.h2database:h2')</code> </pre> <br><p>  Als Datenbank werde ich <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">H2 verwenden</a> - eine in Java geschriebene eingebettete Datenbank mit der F√§higkeit, im In-Memory-Modus zu arbeiten. </p><br><p>  Mit Spring Data JPA definiere ich sofort eine Schnittstelle f√ºr den Zugriff auf Daten: </p><br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CakeRepository</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CrudRepository</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CakeEntity</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">String</span></span></span><span class="hljs-class">&gt; </span></span>{ }</code> </pre> <br><p>  Und die Essenz: </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Entity</span></span> <span class="hljs-meta"><span class="hljs-meta">@Builder</span></span> <span class="hljs-meta"><span class="hljs-meta">@AllArgsConstructor</span></span> <span class="hljs-meta"><span class="hljs-meta">@Table</span></span>(name = <span class="hljs-string"><span class="hljs-string">"cakes"</span></span>) <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CakeEntity</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CakeEntity</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ } <span class="hljs-meta"><span class="hljs-meta">@Id</span></span> <span class="hljs-meta"><span class="hljs-meta">@GeneratedValue</span></span>(strategy = GenerationType.IDENTITY) Long id; <span class="hljs-meta"><span class="hljs-meta">@NotBlank</span></span> String title; <span class="hljs-meta"><span class="hljs-meta">@Positive</span></span> BigDecimal price; <span class="hljs-meta"><span class="hljs-meta">@NotBlank</span></span> <span class="hljs-meta"><span class="hljs-meta">@NaturalId</span></span> String sku; <span class="hljs-keyword"><span class="hljs-keyword">boolean</span></span> promoted; <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">equals</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Object o)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span> == o) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (o == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> || getClass() != o.getClass()) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; CakeEntity cakeEntity = (CakeEntity) o; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Objects.equals(title, cakeEntity.title); } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">hashCode</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Objects.hash(title); } }</code> </pre> <br><p>  Die Beschreibung der Entit√§t enth√§lt einige weniger offensichtliche Dinge. </p><br><ul><li>  <code>@NaturalId</code> f√ºr das <code>@NaturalId</code> Feld.  Dieses Feld wird als ‚Äûnat√ºrlicher Bezeichner‚Äú zum √úberpr√ºfen der Gleichheit von Entit√§ten verwendet. Die Verwendung aller Felder oder <code>@Id</code> Felder in <code>equals</code> / <code>hashCode</code> Methoden ist eher ein Anti-Pattern.  Hier ist beispielsweise gut geschrieben, wie die Gleichheit von Entit√§ten korrekt √ºberpr√ºft <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">werden kann</a> . </li><li>  Um den Boilerplate-Code ein wenig zu reduzieren, verwende ich <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Project Lombok</a> - Annotation Processor f√ºr Java.  Sie k√∂nnen verschiedene n√ºtzliche Dinge hinzuf√ºgen, z. B. <code>@Builder</code> um automatisch einen Builder f√ºr die Klasse zu generieren, und <code>@AllArgsConstructor</code> , um einen Konstruktor f√ºr alle Felder zu erstellen. </li></ul><br><p>  Eine Schnittstellenimplementierung wird automatisch von Spring Data bereitgestellt. </p><br><h1 id="vniz-po-piramide">  Die Pyramide hinunter </h1><br><p>  Jetzt ist die Zeit gekommen, um zur n√§chsten Ebene der Pyramide zu gelangen.  Als Faustregel w√ºrde ich empfehlen, <strong>immer mit dem e2e-Test zu beginnen</strong> , da Sie so das "Endziel" und die Grenzen der neuen Funktion bestimmen k√∂nnen, aber es gibt keine weiteren strengen Regeln.  Es ist nicht erforderlich, zuerst einen Integrationstest zu schreiben, bevor Sie zur Einheitenebene wechseln.  Es ist nur meistens so, dass es bequemer und einfacher ist - und es ist ganz nat√ºrlich, unterzugehen. </p><br><p>  Aber gerade jetzt m√∂chte ich diese Regel sofort brechen und einen Komponententest schreiben, der dabei hilft, die Schnittstelle und den Vertrag einer neuen Komponente zu bestimmen, die noch nicht existiert.  Der Controller sollte ein Modell zur√ºckgeben, das von einer bestimmten Komponente X ausgef√ºllt wird, und ich habe diesen Test geschrieben: </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@ExtendWith</span></span>(MockitoExtension.class) <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IndexControllerTest</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Mock</span></span> CakeFinder cakeFinder; <span class="hljs-meta"><span class="hljs-meta">@InjectMocks</span></span> IndexController indexController; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Set&lt;Cake&gt; cakes = Set.of(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Cake(<span class="hljs-string"><span class="hljs-string">"Test 1"</span></span>, <span class="hljs-string"><span class="hljs-string">"¬£10"</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Cake(<span class="hljs-string"><span class="hljs-string">"Test 2"</span></span>, <span class="hljs-string"><span class="hljs-string">"¬£10"</span></span>)); <span class="hljs-meta"><span class="hljs-meta">@BeforeEach</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setUp</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ when(cakeFinder.findPromotedCakes()).thenReturn(cakes); } <span class="hljs-meta"><span class="hljs-meta">@Test</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">shouldReturnAListOfFoundPromotedCakes</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ ModelAndView index = indexController.index(); assertThat(index.getModel()).extracting(<span class="hljs-string"><span class="hljs-string">"cakes"</span></span>).contains(cakes); } }</code> </pre> <br><p>  Dies ist ein reiner Unit-Test - keine Kontexte, keine Datenbanken hier, nur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Mockito</a> f√ºr Mok.  Und dieser Test ist nur eine gute Demonstration, wie Spring Unit-Tests hilft - der <em>Controller in Spring MVC ist nur eine Klasse, deren Methoden Parameter gew√∂hnlicher Typen akzeptieren und POJO-Objekte zur√ºckgeben - Modelle anzeigen</em> .  Es gibt keine HTTP-Anforderungen, keine Antworten, Header, JSON, XML - all dies wird automatisch in Form von Konvertern und Serialisierern auf den Stapel angewendet.  Ja, es gibt einen kleinen "Hinweis" auf Spring in Form von <code>ModelAndView</code> , aber dies ist ein regul√§res POJO, und Sie k√∂nnen es sogar entfernen, wenn Sie m√∂chten, es wird speziell f√ºr UI-Controller ben√∂tigt. </p><br><blockquote>  Ich werde nicht viel √ºber Mockito sprechen, Sie k√∂nnen alles in der offiziellen Dokumentation lesen.  Insbesondere gibt es in diesem Test nur interessante Punkte - ich verwende <code>MockitoExtension.class</code> als Testl√§ufer und es werden automatisch Mokas f√ºr von <code>@Mock</code> kommentierte Felder <code>@Mock</code> und diese Mokas dann als Abh√§ngigkeiten in den Konstruktor f√ºr das Objekt in das mit <code>@InjectMocks</code> gekennzeichnete Feld <code>@InjectMocks</code> .  Sie k√∂nnen dies alles manuell mit der <code>Mockito.mock()</code> -Methode tun und dann eine Klasse erstellen. </blockquote><p>  Mit diesem Test k√∂nnen Sie die Methode der neuen Komponente ermitteln - <code>findPromotedCakes</code> , eine Liste der Kuchen, die auf der Hauptseite <code>findPromotedCakes</code> sollen.  Er bestimmt nicht, was es ist oder wie es mit der Datenbank funktionieren soll.  Es liegt in der alleinigen Verantwortung des Controllers, das √ºbertragene Material zu √ºbernehmen und die Modelle ("Kuchen") in einem bestimmten Bereich zur√ºckzugeben.  Trotzdem hat <code>CakeFinder</code> bereits die erste Methode in meiner Oberfl√§che, was bedeutet, dass Sie einen Integrationstest daf√ºr schreiben k√∂nnen. </p><br><blockquote>  Ich habe absichtlich alle Klassen innerhalb des <code>cakes</code> <strong>privat gemacht,</strong> damit niemand au√üerhalb des Pakets sie verwenden kann.  Der einzige Weg, um Daten aus der Datenbank abzurufen, ist die CakeFinder-Schnittstelle, die meine ‚ÄûKomponente X‚Äú f√ºr den Zugriff auf die Datenbank ist.  Es wird zu einem nat√ºrlichen ‚ÄûStecker‚Äú, den ich leicht einrasten kann, wenn ich etwas isoliert testen und die Basis nicht ber√ºhren muss.  Die einzige Implementierung ist JpaCakeFinder.  Wenn sich beispielsweise der Datenbanktyp oder die Datenquelle in Zukunft √§ndern, m√ºssen Sie eine Implementierung der <code>CakeFinder</code> Schnittstelle <code>CakeFinder</code> , ohne den Code zu √§ndern, der sie verwendet. </blockquote><br><h1 id="integracionnyy-test-dlya-jpa-ispolzuya-datajpatest">  Integrationstest f√ºr JPA mit @DataJpaTest </h1><br><p>  Integrationstests sind Fr√ºhlingsbrot und Butter.  Tats√§chlich wurde f√ºr Integrationstests alles so gut gemacht, dass Entwickler manchmal nicht auf die Einheitenebene wechseln oder die UI-Ebene vernachl√§ssigen m√∂chten.  Das ist weder schlecht noch gut - ich wiederhole, dass das Hauptziel der Tests das Vertrauen ist.  Eine Reihe schneller und effektiver Integrationstests kann ausreichen, um dieses Vertrauen zu schaffen.  Es besteht jedoch die Gefahr, dass diese Tests im Laufe der Zeit entweder langsamer oder langsamer werden oder einfach mit dem isolierten Testen von Komponenten anstelle der Integration beginnen. </p><br><p>  Integrationstests k√∂nnen die Anwendung <code>@SpringBootTest</code> ( <code>@SpringBootTest</code> ) oder ihre separate Komponente (JPA, Web) <code>@SpringBootTest</code> .  In meinem Fall m√∂chte ich einen gezielten Test f√ºr JPA schreiben, sodass ich keine Controller oder andere Komponenten konfigurieren muss.  Die Annotation <code>@DataJpaTest</code> ist im Spring Boot Test daf√ºr verantwortlich.  Dies ist eine <em>Meta-</em> Annotation, d.h.  Es kombiniert verschiedene Anmerkungen, die verschiedene Aspekte des Tests konfigurieren. </p><br><ul><li>  @AutoConfigureDataJpa </li><li>  @AutoConfigureTestDatabase </li><li>  @AutoConfigureCache </li><li>  @AutoConfigureTestEntityManager </li><li>  @Transactional </li></ul><br><p>  Zuerst erz√§hle ich Ihnen jedes einzeln und dann zeige ich Ihnen den fertigen Test. </p><br><p>  <strong>@AutoConfigureDataJpa</strong> <br>  Es l√§dt eine ganze Reihe von Konfigurationen und richtet Repositorys (automatische Generierung von Implementierungen f√ºr <code>CrudRepositories</code> ) sowie Migrationstools f√ºr die FlyWay- und Liquibase-Datenbanken ein und stellt mithilfe von DataSource, Transaktionsmanager und schlie√ülich Hibernate eine Verbindung zur Datenbank her.  Tats√§chlich handelt es sich hierbei nur um eine Reihe von Konfigurationen, die f√ºr den Zugriff auf Daten relevant sind. Weder <code>DispatcherServlet</code> von Web MVC noch andere Komponenten sind hier enthalten. </p><br><p>  <strong>@AutoConfigureTestDatabase</strong> <br>  Dies ist einer der interessantesten Aspekte des JPA-Tests.  Diese Konfiguration <em>durchsucht den Klassenpfad nach einer der unterst√ºtzten eingebetteten Datenbanken und konfiguriert den Kontext neu, sodass die DataSource auf eine zuf√§llig erstellte speicherinterne Datenbank verweist</em> .  Da ich die Abh√§ngigkeit zur H2-Basis hinzugef√ºgt habe, muss ich nichts weiter tun. Nur diese Annotation automatisch f√ºr jeden Testlauf zu haben, ergibt eine leere Basis, und dies ist einfach unglaublich praktisch. </p><br><p>  Es sei daran erinnert, dass diese Basis ohne Schema vollst√§ndig leer sein wird.  Um die Schaltung zu erzeugen, gibt es mehrere M√∂glichkeiten. </p><br><ol><li>  Verwenden Sie die <strong>Auto-DDL-</strong> Funktion aus dem Ruhezustand.  Der Spring Boot Test setzt diesen Wert automatisch auf <code>create-drop</code> sodass Hibernate aus der Entit√§tsbeschreibung ein Schema generiert und es am Ende der Sitzung l√∂scht.  Dies ist eine unglaublich leistungsstarke Funktion von Hibernate, die f√ºr Tests sehr n√ºtzlich ist. </li><li>  Verwenden Sie Migrationen, die von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Flyway</a> oder <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Liquibase erstellt wurden</a> . </li></ol><br><p>  Weitere Informationen zu den verschiedenen Ans√§tzen zur Initialisierung der Datenbank finden Sie in der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Dokumentation</a> . </p><br><p>  <strong>@AutoConfigureCache</strong> <br>  Es konfiguriert nur den Cache f√ºr die Verwendung von NoOpCacheManager - d. H.  Cache nichts.  Dies ist n√ºtzlich, um √úberraschungen bei Tests zu vermeiden. </p><br><p>  <strong>@AutoConfigureTestEntityManager</strong> <br>  F√ºgt dem <code>TestEntityManager</code> ein spezielles <code>TestEntityManager</code> Objekt hinzu, das an sich schon ein interessantes Tier ist.  <code>EntityManager</code> ist die Hauptklasse von JPA, die f√ºr das Hinzuf√ºgen von Entit√§ten zur Sitzung, das L√∂schen und √§hnliche Dinge verantwortlich ist.  Nur wenn beispielsweise der Ruhezustand in Betrieb genommen wird - das Hinzuf√ºgen einer Entit√§t zu einer Sitzung bedeutet nicht, dass eine Anforderung an die Datenbank ausgef√ºhrt wird, und das Laden aus einer Sitzung bedeutet nicht, dass eine ausgew√§hlte Anforderung ausgef√ºhrt wird.  Aufgrund der internen Mechanismen von Hibernate werden reale Vorg√§nge mit der Datenbank zum richtigen Zeitpunkt ausgef√ºhrt, den das Framework selbst bestimmt.  Bei Tests kann es jedoch erforderlich sein, etwas zwangsweise an die Datenbank zu senden, da der Zweck der Tests darin besteht, die Integration zu testen.  Und <code>TestEntityManager</code> ist nur ein <code>TestEntityManager</code> mit dem einige Vorg√§nge mit der Datenbank zwangsweise ausgef√ºhrt werden k√∂nnen. Beispielsweise <code>persistAndFlush()</code> Hibernate, alle Anforderungen auszuf√ºhren. </p><br><p>  <strong>@Transactional</strong> <br>  Diese Annotation macht alle Tests in der Klasse transaktional, wobei die Transaktion nach Abschluss des Tests automatisch zur√ºckgesetzt wird.  Dies ist nur ein Mechanismus zum ‚ÄûBereinigen‚Äú der Datenbank vor jedem Test, da Sie sonst Daten aus jeder Tabelle manuell l√∂schen m√ºssten. </p><br><blockquote>  Ob ein Test eine Transaktion verwalten sollte, ist keine so einfache und offensichtliche Frage, wie es scheinen mag.  Trotz der Bequemlichkeit des "sauberen" Status der Datenbank kann das Vorhandensein von <code>@Transactional</code> in Tests eine unangenehme √úberraschung sein, wenn der "Battle" -Code die Transaktion nicht selbst startet, sondern eine vorhandene erfordert.  Dies kann dazu f√ºhren, dass der Integrationstest bestanden wird. Wenn jedoch der reale Code vom Controller und nicht vom Test ausgef√ºhrt wird, hat der Dienst keine aktive Transaktion und die Methode l√∂st eine Ausnahme aus.  Obwohl dies gef√§hrlich aussieht, sind Transaktionstests bei Tests der Benutzeroberfl√§che auf hoher Ebene nicht so schlecht.  Nach meiner Erfahrung habe ich nur einmal gesehen, dass ein bestehender Integrationstest den Produktionscode zum Absturz brachte, was eindeutig das Vorhandensein einer vorhandenen Transaktion erforderte.  Wenn Sie jedoch weiterhin √ºberpr√ºfen m√ºssen, ob die Services und Komponenten selbst Transaktionen korrekt verwalten, k√∂nnen Sie die Annotation <code>@Transactional</code> f√ºr den Test im gew√ºnschten Modus ‚Äûblockieren‚Äú (z. B. die Transaktion nicht starten). </blockquote><br><h1 id="integracionnyy-test-so-springboottest">  Integrationstest mit @SpringBootTest </h1><br><p>  Ich m√∂chte auch darauf hinweisen, dass <code>@DataJpaTest</code> kein einzigartiges Beispiel f√ºr einen <code>@DataJpaTest</code> ist. Es gibt <code>@WebMvcTest</code> , <code>@DataMongoTest</code> und viele andere.  Eine der wichtigsten <code>@SpringBootTest</code> bleibt jedoch <code>@SpringBootTest</code> , mit dem die Anwendung <em>"wie sie ist"</em> f√ºr die Tests <code>@SpringBootTest</code> wird - mit allen konfigurierten Komponenten und Integrationen.  Es stellt sich eine logische Frage: Wenn Sie die gesamte Anwendung ausf√ºhren k√∂nnen, warum werden beispielsweise fokale DataJpa-Tests durchgef√ºhrt?  Ich w√ºrde sagen, dass es hier wieder keine strengen Regeln gibt. </p><br><p>  Wenn <em>es m√∂glich ist</em> , jedes Mal Anwendungen auszuf√ºhren, Abst√ºrze in Tests zu isolieren, das Setup des Tests nicht zu √ºberlasten und nicht erneut zu komplizieren, k√∂nnen und sollten Sie nat√ºrlich @SpringBootTest verwenden. </p><br><p>  Im wirklichen Leben k√∂nnen Anwendungen jedoch viele verschiedene Einstellungen erfordern, eine Verbindung zu verschiedenen Systemen herstellen, und ich m√∂chte nicht, dass meine Datenbankzugriffstests fallen, weil  Die Verbindung zur Nachrichtenwarteschlange ist nicht konfiguriert.  Daher ist es wichtig, den gesunden Menschenverstand zu verwenden. Wenn der Test mit der Annotation @SpringBootTest funktioniert, m√ºssen Sie die H√§lfte des Systems sperren. Ist dies dann in @SpringBootTest √ºberhaupt sinnvoll? </p><br><h1 id="podgotovka-dannyh-dlya-testa">  Vorbereitung der Daten f√ºr den Test </h1><br><p>  Einer der wichtigsten Punkte beim Testen ist die Datenaufbereitung.  Jeder Test sollte isoliert durchgef√ºhrt werden und die Umgebung vor dem Start vorbereiten, um das System in den urspr√ºnglich gew√ºnschten Zustand zu bringen.  Die einfachste M√∂glichkeit, dies zu tun, besteht darin, die Anmerkungen <code>@BeforeEach</code> / <code>@BeforeAll</code> und dort mithilfe des Repositorys, <code>EntityManager</code> oder <code>TestEntityManager</code> Eintr√§ge zur Datenbank <code>TestEntityManager</code> .  Es gibt jedoch noch eine andere Option, mit der Sie ein vorbereitetes Skript ausf√ºhren oder die gew√ºnschte SQL-Abfrage ausf√ºhren k√∂nnen. Dies ist die <code>@Sql</code> SQL-Annotation.  Vor dem Ausf√ºhren des Tests f√ºhrt der Spring Boot-Test automatisch das angegebene Skript aus, sodass der Block <code>@Transactional</code> mehr <code>@Transactional</code> werden <code>@BeforeAll</code> , und <code>@Transactional</code> k√ºmmert sich um die Datenbereinigung. </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@DataJpaTest</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">JpaCakeFinderTest</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> String PROMOTED_CAKE = <span class="hljs-string"><span class="hljs-string">"Red Velvet"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> String NON_PROMOTED_CAKE = <span class="hljs-string"><span class="hljs-string">"Victoria Sponge"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> CakeFinder finder; <span class="hljs-meta"><span class="hljs-meta">@Autowired</span></span> CakeRepository cakeRepository; <span class="hljs-meta"><span class="hljs-meta">@Autowired</span></span> TestEntityManager testEntityManager; <span class="hljs-meta"><span class="hljs-meta">@BeforeEach</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setUp</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.testEntityManager.persistAndFlush(CakeEntity.builder().title(PROMOTED_CAKE) .sku(<span class="hljs-string"><span class="hljs-string">"SKU1"</span></span>).price(BigDecimal.TEN).promoted(<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>).build()); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.testEntityManager.persistAndFlush(CakeEntity.builder().sku(<span class="hljs-string"><span class="hljs-string">"SKU2"</span></span>) .title(NON_PROMOTED_CAKE).price(BigDecimal.ONE).promoted(<span class="hljs-keyword"><span class="hljs-keyword">false</span></span>).build()); finder = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> JpaCakeFinder(cakeRepository); } ... }</code> </pre> <br><h1 id="red-green-refactor-cikl">  Rot-Gr√ºn-Refaktor-Zyklus </h1><br><p>  Trotz dieser Textmenge sieht der Test f√ºr den Entwickler immer noch wie eine einfache Klasse mit der Annotation @DataJpaTest aus, aber ich hoffe, dass ich zeigen konnte, wie viele n√ºtzliche Dinge unter der Haube passieren, an die der Entwickler nicht denken kann.  Jetzt k√∂nnen wir zum TDD-Zyklus √ºbergehen und dieses Mal werde ich einige TDD-Iterationen mit Beispielen f√ºr Refactoring und minimalem Code zeigen.  Um es klarer zu machen, empfehle ich dringend, dass Sie sich den Verlauf in Git ansehen, in dem jedes Commit ein separater und wichtiger Schritt mit einer Beschreibung dessen ist, was und wie es funktioniert. </p><br><h2 id="podgotovka-dannyh">  Datenaufbereitung </h2><br><p>  Ich verwende den Ansatz mit <code>@BeforeAll</code> / <code>@BeforeEach</code> und erstelle manuell alle Datens√§tze in der Datenbank.  Das Beispiel mit der Annotation <code>@Sql</code> wird in eine separate Klasse <code>JpaCakeFinderTestWithScriptSetup</code> . Es dupliziert Tests, die nat√ºrlich nicht sein sollten und nur zum Zweck der Demonstration des Ansatzes existieren. </p><br><p>  Der Anfangszustand des Systems - es gibt zwei Eintr√§ge im System, ein Kuchen nimmt an der Aktion teil und muss in das von der Methode zur√ºckgegebene Ergebnis einbezogen werden, der zweite - Nr. </p><br><h2 id="pervyy-test-integracionnyy-test">  Erster Test Integrationstest </h2><br><p>  Der erste Test ist der einfachste - <code>findPromotedCakes</code> sollte eine Beschreibung und einen Preis des an der Aktion teilnehmenden Kuchens enthalten. </p><br><h3 id="red">  Rot </h3><br><pre> <code class="java hljs"> <span class="hljs-meta"><span class="hljs-meta">@Test</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">shouldReturnPromotedCakes</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ Iterable&lt;Cake&gt; promotedCakes = finder.findPromotedCakes(); assertThat(promotedCakes).extracting(Cake::getTitle).contains(PROMOTED_CAKE); assertThat(promotedCakes).extracting(Cake::getPrice).contains(<span class="hljs-string"><span class="hljs-string">"¬£10.00"</span></span>); }</code> </pre> <br><p>  Der Test st√ºrzt nat√ºrlich ab - die Standardimplementierung gibt einen leeren Satz zur√ºck. </p><br><h3 id="green">  Gr√ºn </h3><br><p>  Nat√ºrlich m√∂chten wir die Filterung sofort schreiben, eine Anfrage an die Datenbank mit <code>where</code> und so weiter.  Aber nach der TDD-Praxis muss ich den <em>Mindestcode</em> schreiben <em>, damit der Test bestanden wird</em> .  Und dieser minimale Code soll alle Datens√§tze in der Datenbank zur√ºckgeben.  Ja, so einfach und kitschig. </p><br><pre> <code class="java hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Set&lt;Cake&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">findPromotedCakes</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ Spliterator&lt;CakeEntity&gt; cakes = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.cakeRepository.findAll() .spliterator(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> StreamSupport.stream(cakes, <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>).map( cakeEntity -&gt; <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Cake(cakeEntity.title, formatPrice(cakeEntity.price))) .collect(Collectors.toSet()); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">formatPrice</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(BigDecimal price)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"¬£"</span></span> + price.setScale(<span class="hljs-number"><span class="hljs-number">2</span></span>, RoundingMode.DOWN).toPlainString(); }</code> </pre> <br><blockquote>  Wahrscheinlich w√ºrden einige argumentieren, dass Sie hier den Test auch ohne Basis gr√ºn machen k√∂nnen - codieren Sie einfach das vom Test erwartete Ergebnis fest.  Ich h√∂re gelegentlich ein solches Argument, aber ich denke, jeder versteht, dass TDD kein Dogma oder eine Religion ist. Es macht keinen Sinn, dies auf den Punkt der Absurdit√§t zu bringen.  Wenn Sie dies jedoch wirklich m√∂chten, k√∂nnen Sie beispielsweise Daten in der Installation nach dem Zufallsprinzip sortieren, damit sie nicht fest codiert werden. </blockquote><br><h3 id="refactor">  Refactor </h3><br><p>  Ich sehe hier nicht viel Refactoring, daher kann diese Phase f√ºr diesen speziellen Test √ºbersprungen werden.  Aber ich w√ºrde immer noch nicht empfehlen, diese Phase zu ignorieren. Es ist besser, jedes Mal im ‚Äûgr√ºnen‚Äú Zustand des Systems anzuhalten und nachzudenken. Ist es m√∂glich, etwas umzugestalten, um es besser und einfacher zu machen? </p><br><h2 id="vtoroy-test">  Zweiter Test </h2><br><p>  Der zweite Test best√§tigt jedoch bereits, dass kein beworbener Kuchen in das von <code>findPromotedCakes</code> Ergebnis <code>findPromotedCakes</code> . </p><br><pre> <code class="java hljs"> <span class="hljs-meta"><span class="hljs-meta">@Test</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">shouldNotReturnNonPromotedCakes</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ Iterable&lt;Cake&gt; promotedCakes = finder.findPromotedCakes(); assertThat(promotedCakes).extracting(Cake::getTitle) .doesNotContain(NON_PROMOTED_CAKE); }</code> </pre> <br><h3 id="red-1">  Rot </h3><br><p>  Der Test st√ºrzt erwartungsgem√§√ü ab - die Datenbank enth√§lt zwei Datens√§tze, und der Code gibt einfach alle zur√ºck. </p><br><h3 id="green-1">  Gr√ºn </h3><br><p>  Und wieder k√∂nnen Sie denken - und was ist der Mindestcode, den Sie schreiben k√∂nnen, um den Test zu bestehen?  Da es bereits einen Stream und dessen Assembly gibt, k√∂nnen Sie dort einfach einen <code>filter</code> hinzuf√ºgen. </p><br><pre> <code class="java hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Set&lt;Cake&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">findPromotedCakes</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ Spliterator&lt;CakeEntity&gt; cakes = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.cakeRepository.findAll() .spliterator(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> StreamSupport.stream(cakes, <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>) .filter(cakeEntity -&gt; cakeEntity.promoted) .map(cakeEntity -&gt; <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Cake(cakeEntity.title, formatPrice(cakeEntity.price))) .collect(Collectors.toSet()); }</code> </pre> <br><p>  Wir starten Tests neu - Integrationstests sind jetzt gr√ºn.  Ein wichtiger Moment ist gekommen - aufgrund der Kombination aus dem Komponententest des Controllers und dem Integrationstest f√ºr die Arbeit mit der Datenbank ist meine Funktion bereit - und der UI-Test ist jetzt erfolgreich! </p><br><h3 id="refactor-1">  Refactor </h3><br><p>  Und da alle Tests gr√ºn sind, ist es Zeit f√ºr eine Umgestaltung.  Ich denke, es muss nicht klargestellt werden, dass das Filtern im Speicher keine gute Idee ist. Es ist besser, dies in der Datenbank zu tun.  Zu diesem <code>CakesRepository</code> ich im <code>CakesRepository</code> eine neue Methode <code>CakesRepository</code> - <code>findByPromotedIsTrue</code> : </p><br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CakeRepository</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CrudRepository</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CakeEntity</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">String</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-function"><span class="hljs-function">Iterable&lt;CakeEntity&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">findByPromotedIsTrue</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; }</code> </pre> <br><p>  F√ºr diese Methode hat Spring Data automatisch eine Methode generiert, die eine Abfrage der Formularauswahl <code>select from cakes where promoted = true</code> ausf√ºhrt <code>select from cakes where promoted = true</code> .  Weitere Informationen zur Generierung von Abfragen finden Sie in der Spring Data- <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Dokumentation</a> . </p><br><pre> <code class="java hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Set&lt;Cake&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">findPromotedCakes</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ Spliterator&lt;CakeEntity&gt; cakes = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.cakeRepository.findByPromotedIsTrue() .spliterator(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> StreamSupport.stream(cakes, <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>).map( cakeEntity -&gt; <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Cake(cakeEntity.title, formatPrice(cakeEntity.price))) .collect(Collectors.toSet()); }</code> </pre> <br><p>  Dies ist ein gutes Beispiel f√ºr die Flexibilit√§t, die Integrationstests und der Black-Box-Ansatz bieten.  Wenn das Repository gesperrt war, war das Hinzuf√ºgen einer neuen Methode ohne √Ñnderung der Tests nicht unm√∂glich. </p><br><h1 id="podklyuchenie-k-production-baze">  Verbindung zur Produktionsbasis </h1><br><p>  Um ein wenig ‚ÄûRealismus‚Äú hinzuzuf√ºgen und zu zeigen, wie Sie die Konfiguration f√ºr Tests und die Hauptanwendung trennen k√∂nnen, f√ºge ich eine Datenzugriffskonfiguration f√ºr die Anwendung ‚ÄûProduktion‚Äú hinzu. </p><br><p>  Alles wird traditionell durch den Abschnitt in <code>application.yml</code> hinzugef√ºgt: </p><br><pre> <code class="plaintext hljs">datasource: url: jdbc:h2:./data/cake-factory</code> </pre><br><p>  Dadurch werden die Daten im Dateisystem automatisch im Ordner <code>./data</code> .  Ich <code>@DataJpaTest</code> fest, dass dieser Ordner in Tests nicht erstellt wird. <code>@DataJpaTest</code> ersetzt aufgrund des Vorhandenseins der Annotation <code>@DataJpaTest</code> automatisch die Verbindung zur <code>@DataJpaTest</code> durch eine zuf√§llige Datenbank im Speicher. </p><br><blockquote>  Zwei n√ºtzliche Dinge, die n√ºtzlich sein k√∂nnen, sind die <code>schema.sql</code> <code>data.sql</code> und <code>schema.sql</code> .   , Spring Boot             .          ,   , ,    . </blockquote><br><h1 id="zaklyuchenie">  Fazit </h1><br><p> ,               ,    ,       TDD . </p><br><p>      Spring Security ‚Äî                Spring,       . </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de433958/">https://habr.com/ru/post/de433958/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de433946/index.html">Spickzettel f√ºr k√ºnstliche Intelligenz - werfen Sie den √úberschuss weg, lehren Sie die Hauptsache. Trainingssequenz-Verarbeitungstechnik</a></li>
<li><a href="../de433948/index.html">So machen Sie die Zahlung bequemer: die Erfahrung eines IaaS-Anbieters</a></li>
<li><a href="../de433952/index.html">10 Gr√ºnde, sich f√ºr eine L√∂sung f√ºr SAP HANA von HPE zu entscheiden. Teil 2</a></li>
<li><a href="../de433954/index.html">Acht Audiotechnologien und Audio-Gadgets, die 2019 in die TECnology Hall of Fame aufgenommen werden</a></li>
<li><a href="../de433956/index.html">Modder haben KI verwendet, um die Textur in Spielen zu verbessern</a></li>
<li><a href="../de433964/index.html">ECMAScript-Module in Node.js: Ein neuer Plan</a></li>
<li><a href="../de433966/index.html">Weihnachtskarte vom Mars. Die ESA zeigte eine gro√üe Ansammlung von Eis auf der Oberfl√§che des roten Planeten</a></li>
<li><a href="../de433968/index.html">Das degenerierteste Kommunikationsspiel</a></li>
<li><a href="../de433972/index.html">HolyJS 2018 Moskau mit den Augen des Teilnehmers</a></li>
<li><a href="../de433974/index.html">Chatbot bekommt Geh√∂r oder Amateurleiden</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>