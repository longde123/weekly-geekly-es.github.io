<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üßòüèº ‚ôãÔ∏è üëßüèª Animasi Android berdasarkan Kotlin dan RxJava üöí üî† ‚û°Ô∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Halo, Habr! Tahun lalu, Ivan ≈†koriƒá dari PSPDFKit berbicara di MBLT DEV dengan laporan tentang membuat animasi di Android berdasarkan Kotlin dan perpu...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Animasi Android berdasarkan Kotlin dan RxJava</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/e-Legion/blog/418383/"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><img src="https://habrastorage.org/webt/2g/5z/pi/2g5zpitzszs5lxzgdighjoo14u4.png"></a> <br><br>  Halo, Habr!  Tahun lalu, Ivan ≈†koriƒá dari PSPDFKit berbicara di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">MBLT DEV</a> dengan laporan tentang membuat animasi di Android berdasarkan Kotlin dan perpustakaan RxJava. <br><br>  Saya sekarang menggunakan teknik dari laporan dalam mengerjakan proyek saya, mereka banyak membantu.  Di bawah cutscene adalah transkrip laporan dan video, sekarang Anda dapat memanfaatkan trik ini. <a name="habracut"></a><br><br><h2>  Animasi </h2><br>  Di Android, ada 4 kelas yang berlaku seolah-olah secara default: <br><br><ol><li>  <b>ValueAnimator</b> - Kelas ini menyediakan mekanisme sinkronisasi sederhana untuk menjalankan animasi yang menghitung nilai animasi dan mengaturnya untuk Tampilan. </li><li>  <b>ObjectAnimator</b> adalah subkelas dari ValueAnimator yang memungkinkan Anda untuk mendukung animasi untuk properti objek. </li><li>  <b>AnimatorSet</b> digunakan untuk membuat urutan animasi.  Misalnya, Anda memiliki urutan animasi: <br><br><ol><li>  Lihat dedaunan di sebelah kiri layar. </li><li>  Setelah menyelesaikan animasi pertama, kami ingin melakukan animasi tampilan untuk tampilan lain, dll. </li></ol></li><li>  <b>ViewPropertyAnimator</b> - Secara otomatis meluncurkan dan mengoptimalkan animasi untuk properti View yang dipilih.  Kami terutama akan menggunakannya.  Oleh karena itu, kami akan menggunakan API ini dan kemudian meletakkannya di RxJava sebagai bagian dari pemrograman reaktif. </li></ol><br><cut></cut><br><h3>  ValueAnimator </h3><br>  Mari kita <b>menganalisis</b> kerangka <b>ValueAnimator</b> .  Ini digunakan untuk mengubah nilai.  Anda menentukan rentang nilai melalui <b>ValueAnimator.ofFloat</b> untuk tipe float primitif dari 0 hingga 100. Tentukan nilai <b>Durasi</b> dan mulai animasi. <br>  Pertimbangkan sebuah contoh: <br><br><pre><code class="hljs kotlin"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> animator = ValueAnimator.ofFloat(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">100f</span></span>) animator.duration = <span class="hljs-number"><span class="hljs-number">1000</span></span> animator.start() animator.addUpdateListener(<span class="hljs-keyword"><span class="hljs-keyword">object</span></span> : ValueAnimator.AnimatorUpdateListener { <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onAnimationUpdate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(animation: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">ValueAnimator</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> animatedValue = animation.animatedValue <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Float</span></span> textView.translationX = animatedValue } })</code> </pre> <br>  Di sini kita menambahkan <b>UpdateListener</b> dan dengan setiap pembaruan kita akan memindahkan Tampilan kita secara horizontal dan mengubah posisinya dari 0 menjadi 100, meskipun ini bukan cara yang sangat baik untuk melakukan operasi ini. <br><br><h3>  ObjectAnimator </h3><br>  Contoh implementasi animasi lainnya adalah ObjectAnimator: <br><br><pre> <code class="hljs pgsql">val objectAnimator = ObjectAnimator.ofFloat(textView, "translationX", <span class="hljs-number"><span class="hljs-number">100</span></span>f) objectAnimator.duration = <span class="hljs-number"><span class="hljs-number">1000</span></span> objectAnimator.<span class="hljs-keyword"><span class="hljs-keyword">start</span></span>()</code> </pre> <br>  Kami memberinya perintah untuk mengubah parameter Tampilan spesifik ke nilai yang ditentukan ke Tampilan yang diinginkan dan mengatur waktu menggunakan metode <b>setDuration</b> .  Intinya adalah bahwa kelas Anda harus memiliki metode <b>setTranslationX</b> , maka sistem akan menemukan metode ini melalui refleksi, dan kemudian View akan dianimasikan.  Masalahnya adalah refleksi digunakan di sini. <br><br><h3>  Animatorset </h3><br>  Sekarang pertimbangkan kelas <b>AnimatorSet</b> : <br><br><pre> <code class="hljs pgsql">val bouncer = AnimatorSet() bouncer.play(bounceAnim).<span class="hljs-keyword"><span class="hljs-keyword">before</span></span>(squashAnim1) bouncer.play(squashAnim1).<span class="hljs-keyword"><span class="hljs-keyword">before</span></span>(squashAnim2) val fadeAnim = ObjectAnimator.ofFloat(newBall, "alpha", <span class="hljs-number"><span class="hljs-number">1</span></span>f, <span class="hljs-number"><span class="hljs-number">0</span></span>f) fadeAnim.duration = <span class="hljs-number"><span class="hljs-number">250</span></span> val animatorSet = AnimatorSet() animatorSet.play(bouncer).<span class="hljs-keyword"><span class="hljs-keyword">before</span></span>(fadeAnim) animatorSet.<span class="hljs-keyword"><span class="hljs-keyword">start</span></span>()</code> </pre> <br>  Bahkan, sangat tidak nyaman untuk digunakan, terutama untuk sejumlah besar objek.  Jika Anda ingin membuat animasi yang lebih kompleks - misalnya, atur penundaan antara tampilan animasi, dan semakin banyak animasi yang ingin Anda lakukan, semakin sulit untuk mengendalikannya. <br><br><h3>  ViewPropertyAnimator </h3><br>  Kelas terakhir adalah <b>ViewPropertyAnimator</b> .  Ini adalah salah satu kelas terbaik untuk menjiwai View.  Ini adalah API yang bagus untuk memperkenalkan rangkaian animasi yang Anda jalankan: <br><br><pre> <code class="hljs kotlin">ViewCompat.animate(textView) .translationX(<span class="hljs-number"><span class="hljs-number">50f</span></span>) .translationY(<span class="hljs-number"><span class="hljs-number">100f</span></span>) .setDuration(<span class="hljs-number"><span class="hljs-number">1000</span></span>) .setInterpolator(AccelerateDecelerateInterpolator()) .setStartDelay(<span class="hljs-number"><span class="hljs-number">50</span></span>) .setListener(<span class="hljs-keyword"><span class="hljs-keyword">object</span></span> : Animator.AnimatorListener { <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onAnimationRepeat</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(animation: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Animator</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> {} <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onAnimationEnd</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(animation: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Animator</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> {} <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onAnimationCancel</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(animation: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Animator</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> {} <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onAnimationStart</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(animation: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Animator</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> {} })</code> </pre><br>  Kita memulai metode <b>ViewCompat.animate</b> , yang mengembalikan <b>ViewPropertyAnimator</b> , dan untuk <b>translationX</b> animasi <b>kita</b> menetapkan nilainya menjadi 50, untuk parameter <b>translatonY</b> ke 100. Kemudian kita menentukan durasi animasi, serta interpolator.  Interpolator menentukan urutan di mana animasi muncul.  Contoh ini menggunakan interpolator yang mempercepat awal animasi dan menambahkan perlambatan di bagian akhir.  Kami juga menambahkan penundaan untuk memulai animasi.  Selain itu, kami memiliki <b>AnimatorListener</b> .  Dengannya, Anda dapat berlangganan ke acara tertentu yang terjadi selama animasi.  Antarmuka ini memiliki 4 metode: <b>onAnimationStart</b> , <b>onAnimationCancel</b> , <b>onAnimationEnd</b> , <b>onAnimationRepeat</b> . <br><br>  Sebagai aturan, kami hanya tertarik untuk menyelesaikan animasi.  Di API Level 16 <br>  ditambahkan denganEndAction: <br><br><pre> <code class="hljs pgsql">.withEndAction({ //API <span class="hljs-number"><span class="hljs-number">16</span></span>+ //<span class="hljs-keyword"><span class="hljs-keyword">do</span></span> something here <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> animation ends })</code> </pre> <br>  Di dalamnya, Anda dapat menentukan antarmuka <b>Runnable</b> , dan setelah selesai menunjukkan animasi tertentu, suatu tindakan dilakukan. <br><br>  Sekarang beberapa komentar tentang proses pembuatan animasi secara umum: <br><br><ol><li>  Metode <b>start ()</b> adalah opsional: segera setelah Anda memanggil metode <b>animate ()</b> , serangkaian animasi diperkenalkan.  Ketika <b>ViewPropertyAnimator</b> dikonfigurasi, sistem akan memulai animasi segera setelah siap untuk melakukannya. </li><li>  Hanya satu kelas <b>ViewPropertyAnimator yang</b> hanya dapat menghidupkan tampilan tertentu.  Karena itu, jika Anda ingin melakukan beberapa animasi, misalnya, Anda ingin sesuatu bergerak, dan pada saat yang sama bertambah besar ukurannya, maka Anda perlu menentukan ini dalam satu animator. </li></ol><br><h3>  Mengapa kami memilih RxJava? </h3><br>  Mari kita mulai dengan contoh sederhana.  Misalkan kita membuat metode fadeIn: <br><br><pre> <code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fadeIn</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(view: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">View</span></span></span></span><span class="hljs-function"><span class="hljs-params">, duration: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Long</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: Completable { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> animationSubject = CompletableSubject.create() <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> animationSubject.doOnSubscribe { ViewCompat.animate(view) .setDuration(duration) .alpha(<span class="hljs-number"><span class="hljs-number">1f</span></span>) .withEndAction { animationSubject.onComplete() } } }</code> </pre> <br>  Ini adalah solusi yang cukup primitif, dan untuk menerapkannya pada proyek Anda, Anda perlu mempertimbangkan beberapa nuansa. <br><br>  Kami akan membuat <b>Subjek Completable</b> , yang akan kami gunakan untuk menunggu animasi selesai, dan kemudian menggunakan metode <b>onComplete</b> untuk mengirim pesan ke pelanggan.  Untuk menjalankan animasi secara berurutan, Anda harus segera memulai animasi, tetapi segera setelah seseorang berlangganan.  Dengan cara ini, beberapa animasi gaya reaktif dapat dijalankan secara berurutan. <br><br>  Pertimbangkan animasi itu sendiri.  Di dalamnya, kami mentransfer Lihat, di mana animasi akan dilakukan, dan juga menunjukkan durasi animasi.  Dan karena animasi ini adalah penampilan, kita harus menunjukkan transparansi 1. <br><br>  Mari kita coba menggunakan metode kita dan membuat animasi sederhana.  Misalkan kita memiliki 4 tombol di layar, dan kami ingin menambahkan animasi untuk penampilan dengan durasi 1 detik: <br><br><pre> <code class="hljs go">val durationMs = <span class="hljs-number"><span class="hljs-number">1000</span></span>L button1.alpha = <span class="hljs-number"><span class="hljs-number">0f</span></span> button2.alpha = <span class="hljs-number"><span class="hljs-number">0f</span></span> button3.alpha = <span class="hljs-number"><span class="hljs-number">0f</span></span> button4.alpha = <span class="hljs-number"><span class="hljs-number">0f</span></span> fadeIn(button1, durationMs) .andThen(fadeIn(button2, durationMs)) .andThen(fadeIn(button3, durationMs)) .andThen(fadeIn(button4, durationMs)) .subscribe()</code> </pre><br>  Hasilnya adalah kode ringkas tersebut.  Dengan menggunakan operator dan kemudian, <b>Anda</b> dapat menjalankan animasi secara berurutan.  Saat kami berlangganan, itu akan mengirimkan acara <b>doOnSubscribe</b> ke <b>Completable</b> , yang merupakan yang pertama dalam antrian eksekusi.  Setelah selesai, ia akan berlangganan ke rantai kedua, ketiga, dan seterusnya.  Oleh karena itu, jika kesalahan terjadi pada tahap tertentu, maka seluruh urutan melempar kesalahan.  Anda juga harus menentukan alpha 0 sebelum dimulainya animasi sehingga tombol tidak terlihat.  Dan beginilah tampilannya: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/sq/-m/02/sq-m02uv2i1uu85udver9fwzqww.gif"></div><br>  Menggunakan <b>Kotlin</b> , kita dapat menggunakan ekstensi: <br><br><pre> <code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> View.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fadeIn</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(duration: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Long</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: Completable { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> animationSubject = CompletableSubject.create() <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> animationSubject.doOnSubscribe { ViewCompat.animate(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>) .setDuration(duration) .alpha(<span class="hljs-number"><span class="hljs-number">1f</span></span>) .withEndAction { animationSubject.onComplete() } } }</code> </pre> <br>  Untuk kelas tampilan, fungsi ekstensi telah ditambahkan.  Lebih lanjut, tidak perlu meneruskan argumen View ke metode fadeIn.  Sekarang Anda dapat mengganti semua panggilan ke Lihat dengan kata kunci ini di dalam metode.  Inilah yang mampu dilakukan <b>Kotlin.</b> <br><br>  Mari kita lihat bagaimana pemanggilan fungsi ini dalam rantai animasi kami telah berubah: <br><br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">button1</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.fadeIn</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">durationMs</span></span>) <span class="hljs-selector-class"><span class="hljs-selector-class">.andThen</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">button2</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.fadeIn</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">durationMs</span></span>)) <span class="hljs-selector-class"><span class="hljs-selector-class">.andThen</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">button3</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.fadeIn</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">durationMs</span></span>)) <span class="hljs-selector-class"><span class="hljs-selector-class">.andThen</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">button4</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.fadeIn</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">durationMs</span></span>)) <span class="hljs-selector-class"><span class="hljs-selector-class">.subscribe</span></span>()</code> </pre><br>  Sekarang kodenya terlihat lebih bisa dimengerti.  Ini dengan jelas menyatakan bahwa kami ingin menerapkan animasi dengan durasi tertentu ke tampilan yang diinginkan.  Menggunakan operator <b>andThen</b> , <b>kami</b> membuat rangkaian animasi berurutan ke tombol kedua, ketiga, dan seterusnya. <br><br>  Kami selalu menunjukkan durasi animasi, nilai ini sama untuk semua tampilan - 1000 milidetik.  <b>Kotlin</b> datang untuk menyelamatkan lagi.  Kita dapat membuat nilai waktu default. <br><br><pre> <code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> View.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fadeIn</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(duration: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> = </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">1000</span></span></span></span><span class="hljs-function"><span class="hljs-params">L)</span></span></span></span>:</code> </pre> <br>  Jika Anda tidak menentukan parameter <b>durasi</b> , maka waktu akan secara otomatis ditetapkan ke 1 detik.  Tetapi jika kita ingin tombol di nomor 2 untuk meningkatkan waktu ini menjadi 2 detik, kita cukup menentukan nilai ini dalam metode: <br><br><pre> <code class="hljs erlang">button1.fadeIn() .<span class="hljs-keyword"><span class="hljs-keyword">and</span></span>Then(button2.fadeIn(duration = <span class="hljs-number"><span class="hljs-number">2000</span></span>L)) .<span class="hljs-keyword"><span class="hljs-keyword">and</span></span>Then(button3.fadeIn()) .<span class="hljs-keyword"><span class="hljs-keyword">and</span></span>Then(button4.fadeIn()) .subscribe()</code> </pre><br><h3>  Menjalankan dua animasi </h3><br>  Kami dapat menjalankan serangkaian animasi menggunakan operator <b>andThen</b> .  Bagaimana jika saya perlu menjalankan 2 animasi sekaligus?  Untuk melakukan ini, ada <b>penggabungan dengan</b> operator di <b>RxJava</b> yang memungkinkan Anda untuk menggabungkan elemen yang dapat diselesaikan sedemikian rupa sehingga mereka akan diluncurkan secara bersamaan.  Pernyataan ini memulai semua elemen dan berakhir setelah elemen terakhir ditampilkan.  Jika kita mengubah <b>danKemudian</b> <b>bergabung dengan</b> , kita mendapatkan animasi di mana semua tombol muncul pada saat yang sama, tetapi tombol 2 akan muncul sedikit lebih lama daripada yang lain: <br><br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">button1</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.fadeIn</span></span>() <span class="hljs-selector-class"><span class="hljs-selector-class">.mergeWith</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">button2</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.fadeIn</span></span>(2000)) <span class="hljs-selector-class"><span class="hljs-selector-class">.mergeWith</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">button3</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.fadeIn</span></span>()) <span class="hljs-selector-class"><span class="hljs-selector-class">.mergeWith</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">button4</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.fadeIn</span></span>()) <span class="hljs-selector-class"><span class="hljs-selector-class">.subscribe</span></span>()</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/webt/jd/fw/xb/jdfwxbgedu3gnufrsrfqezc46ga.gif"></div><br>  Sekarang kita dapat mengelompokkan animasi.  Mari kita coba menyulitkan tugas: misalnya, kita ingin tombol 1 dan tombol 2 muncul pada saat yang sama, dan kemudian tombol 3 dan tombol 4: <br><br><pre> <code class="hljs css">(<span class="hljs-selector-tag"><span class="hljs-selector-tag">button1</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.fadeIn</span></span>()<span class="hljs-selector-class"><span class="hljs-selector-class">.mergeWith</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">button2</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.fadeIn</span></span>())) <span class="hljs-selector-class"><span class="hljs-selector-class">.andThen</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">button3</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.fadeIn</span></span>()<span class="hljs-selector-class"><span class="hljs-selector-class">.mergeWith</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">button4</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.fadeIn</span></span>())) <span class="hljs-selector-class"><span class="hljs-selector-class">.subscribe</span></span>()</code> </pre> <br>  Kami menggabungkan tombol pertama dan kedua dengan operator <b>penggabunganDengan</b> , mengulangi tindakan untuk yang ketiga dan keempat, dan memulai grup ini secara berurutan dengan operator <b>andLalu</b> .  Sekarang kita akan meningkatkan kode dengan menambahkan metode <b>fadeInTogether</b> : <br><br><pre> <code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fadeInTogether</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(first: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">View</span></span></span></span><span class="hljs-function"><span class="hljs-params">, second: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">View</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: Completable { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> first.fadeIn() .mergeWith(second.fadeIn()) }</code> </pre> <br>  Ini akan memungkinkan Anda untuk menjalankan animasi fadeIn untuk dua View secara bersamaan.  Bagaimana rantai animasi berubah: <br><br><pre> <code class="hljs erlang"><span class="hljs-function"><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fadeInTogether</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(button1, button2)</span></span></span><span class="hljs-function"> .</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">andThen</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(fadeInTogether(button3, button4))</span></span></span><span class="hljs-function"> .</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">subscribe</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span></code> </pre> <br>  Hasilnya adalah animasi berikut: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/hk/xw/pe/hkxwpemdtbmksyv_r7mq2qx3bcw.gif"></div><br>  Pertimbangkan contoh yang lebih kompleks.  Misalkan kita perlu menunjukkan animasi dengan penundaan yang diberikan.  Pernyataan <b>interval</b> akan membantu: <br><br><pre> <code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">animate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> timeObservable = Observable.interval(<span class="hljs-number"><span class="hljs-number">100</span></span>, TimeUnit.MILLISECONDS) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> btnObservable = Observable.just(button1, button2, button3, button4) }</code> </pre> <br>  Ini akan menghasilkan nilai setiap 100 milidetik.  Setiap tombol akan muncul setelah 100 milidetik.  Selanjutnya, kami menunjukkan Observable lain yang akan memancarkan tombol.  Dalam hal ini, kami memiliki 4 tombol.  Kami menggunakan operator <b>zip</b> . <br><br><img src="https://habrastorage.org/webt/g5/qq/yi/g5qqyih178patmj5cjpfyoevkkw.png" alt="gambar"><br><br>  Di hadapan kami adalah aliran acara: <br><br><pre> <code class="hljs mel">Observable.zip(timeObservable, btnObservable, BiFunction&lt;Long, View, Disposable&gt; { _, <span class="hljs-keyword"><span class="hljs-keyword">button</span></span> -&gt; <span class="hljs-keyword"><span class="hljs-keyword">button</span></span>.fadeIn().subscribe() })</code> </pre> <br>  Yang pertama berhubungan dengan <b>timeObservable</b> .  <b>Diamati</b> ini akan menghasilkan angka secara berkala.  Misalkan 100 milidetik. <br><br>  Yang Dapat <b>Diamati</b> kedua akan menghasilkan tampilan.  Operator <b>zip</b> menunggu hingga objek pertama muncul di utas pertama, dan menghubungkannya ke objek pertama dari utas kedua.  Terlepas dari kenyataan bahwa semua 4 objek di utas kedua ini akan segera muncul, ia akan menunggu sampai benda-benda mulai muncul di utas pertama.  Dengan demikian, objek pertama dari aliran pertama akan terhubung ke objek pertama dari yang kedua dalam bentuk pandangan kami, dan 100 milidetik kemudian, ketika objek baru muncul, operator akan menggabungkannya dengan objek kedua.  Karena itu, tampilan akan muncul dengan penundaan tertentu. <br><br>  Mari kita <b>berurusan</b> dengan <b>BiFinction</b> di <b>RxJava</b> .  Fungsi ini menerima dua objek sebagai input, melakukan beberapa operasi padanya, dan mengembalikan objek ketiga.  Kami ingin mengambil waktu dan melihat objek dan mendapatkan <b>Disposable</b> karena kami memanggil animasi <b>fadeIn</b> dan berlangganan untuk <b>berlangganan</b> .  Nilai waktu tidak penting bagi kami.  Hasilnya, kami mendapatkan animasi ini: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/8q/wa/1z/8qwa1z75xolp2jb-hsznqzncykw.gif"></div><br><h3>  Vanogogh </h3><br>  Saya akan memberi tahu Anda tentang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">proyek</a> yang mulai dikembangkan Ivan untuk MBLT DEV 2017. <br><br>  Perpustakaan yang dikembangkan oleh Ivan menyajikan berbagai kerang untuk animasi.  Kami sudah mempertimbangkan ini di atas.  Ini juga berisi animasi yang sudah jadi yang bisa Anda gunakan.  Anda mendapatkan seperangkat alat umum untuk membuat animasi Anda sendiri.  Perpustakaan ini akan memberi Anda komponen yang lebih kuat untuk pemrograman reaktif. <br><br>  Pertimbangkan perpustakaan menggunakan contoh: <br><br><pre> <code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fadeIn</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(view:</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">View</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> : AnimationCompletable { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> AnimationBuilder.forView(view) .alpha(<span class="hljs-number"><span class="hljs-number">1f</span></span>) .duration(<span class="hljs-number"><span class="hljs-number">2000L</span></span>) .build().toCompletable() }</code> </pre> <br>  Misalkan Anda ingin membuat animasi yang muncul, tetapi kali ini <b>AnimationCompletable</b> muncul alih-alih objek <b>Completable</b> .  Kelas ini mewarisi dari <b>Completable</b> , jadi sekarang lebih banyak fungsi yang muncul.  Salah satu fitur penting dari kode sebelumnya adalah bahwa tidak mungkin untuk membatalkan animasi.  Sekarang Anda dapat membuat objek <b>AnimationCompletable</b> yang membuat animasi berhenti segera setelah kami berhenti berlangganan darinya. <br><br>  Buat animasi yang muncul menggunakan <b>AnimationBuilder</b> - salah satu kelas perpustakaan.  Tentukan tampilan animasi yang akan diterapkan.  Pada dasarnya, kelas ini menyalin perilaku <b>ViewPropertyAnimator</b> , tetapi dengan perbedaan bahwa output adalah aliran. <br><br>  Selanjutnya, atur alpha 1f dan durasinya adalah 2 detik.  Lalu kami mengumpulkan animasi.  Segera setelah kami <b>memunculkan</b> statemen <b>build</b> , animasi muncul.  Kami menetapkan animasi properti dari objek yang tidak dapat diubah, sehingga akan menyimpan karakteristik ini untuk peluncurannya.  Tetapi animasi itu sendiri tidak akan mulai. <br><br>  Panggil <b>toCompletable</b> , yang akan membuat <b>AnimationCompletable</b> .  Ini akan membungkus parameter animasi ini dalam semacam shell untuk pemrograman reaktif, dan segera setelah Anda berlangganan, itu akan memulai animasi.  Jika Anda mematikannya sebelum proses selesai, animasi akan berakhir.  Anda juga sekarang dapat menambahkan fungsi panggilan balik.  Anda dapat menulis operator <b>doOnAnimationReady</b> , <b>doOnAnimationStart</b> , <b>doOnAnimationEnd,</b> dan sejenisnya: <br><br><pre> <code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fadeIn</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(view:</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">View</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> : AnimationCompletable { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> AnimationBuilder.forView(view) .alpha(<span class="hljs-number"><span class="hljs-number">1f</span></span>) .duration(<span class="hljs-number"><span class="hljs-number">2000L</span></span>) .buildCompletable() .doOnAnimationReady { view.alpha = <span class="hljs-number"><span class="hljs-number">0f</span></span> } }</code> </pre> <br>  Dalam contoh ini, kami menunjukkan betapa nyamannya menggunakan <b>AnimationBuilder</b> , dan mengubah status Tampilan kami sebelum memulai animasi. <br><br><h3>  Laporkan video </h3><br>  Kami melihat salah satu opsi untuk membuat, menyusun, dan mengubah animasi menggunakan Kotlin dan RxJava.  Berikut ini tautan ke <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">proyek</a> yang menjelaskan animasi dan contoh dasar untuk mereka, serta kerangka utama untuk bekerja dengan animasi. <br><br>  Selain dekripsi, saya membagikan video laporan: <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/Yv80bdUnJgw" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><h3>  Pembicara MBLT DEV 2018 </h3><br>  Sebelum <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">MBLT DEV 2018</a> , sedikit lebih dari dua bulan tersisa.  Kami akan memiliki pertunjukan berikut: <br><br><ul><li>  Laura Morinigo, Pakar Pengembang Google </li><li>  Kaushik Gopal, penulis Podcast Terfragmentasi </li><li>  Artyom Rudoi, Badoo </li><li>  Dina Sidorova, Google, dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">lainnya</a> . </li></ul><br>  Besok harga tiket akan berubah.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Daftarkan</a> hari ini. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id418383/">https://habr.com/ru/post/id418383/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id418371/index.html">Microtask untuk programmer dan metode pembayaran cryptocurrency alternatif</a></li>
<li><a href="../id418375/index.html">Tinjauan umum Uniz Slash + 3D Photo-Printer</a></li>
<li><a href="../id418377/index.html">Kotlin: dua sendok tar dalam satu tong madu</a></li>
<li><a href="../id418379/index.html">Prostesis bioelektrik anak-anak. Bagian 2</a></li>
<li><a href="../id418381/index.html">Apa yang Baru di DevTools di Versi Chrome 68</a></li>
<li><a href="../id418385/index.html">Bagaimana Saya Merakit Komputer untuk Game Lama</a></li>
<li><a href="../id418387/index.html">Fisikawan berdialog tentang jiwa</a></li>
<li><a href="../id418389/index.html">RabbitMQ vs Kafka: Menggunakan Kafka di Aplikasi yang Berorientasi Acara</a></li>
<li><a href="../id418391/index.html">OSPF (Bagian Satu)</a></li>
<li><a href="../id418393/index.html">[Jumat] Bagaimana kami menggergaji Web 3D</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>