<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🏭 👩🏿‍💻 🔴 功能思维。 第6部分 👸🏿 ℹ️ 🚡</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="我们将继续介绍有关F＃中的函数式编程的系列文章。 今天，我们讨论功能的关联性和组成，以及比较组成和管道。 看猫下！ 





- 第一部分 
- 第二部分 
- 第三部分 
- 第四部分 
- 第五部分 
 关联性和功能组成 
 功能关联 


 假设有一行函数编写在一起。 它们将以什么顺序组合？...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>功能思维。 第6部分</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/microsoft/blog/413195/"><p> 我们将继续介绍有关F＃中的函数式编程的系列文章。 今天，我们讨论功能的关联性和组成，以及比较组成和管道。 看猫下！ </p><br><p><img src="https://habrastorage.org/webt/7j/cd/7x/7jcd7xzdvnhpyxuebjvbzb1uiqs.jpeg"></p><br><ul><li>  <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第一部分</a></strong> </li><li>  <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第二部分</a></strong> </li><li>  <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第三部分</a></strong> </li><li>  <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第四部分</a></strong> </li><li>  <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第五部分</a></strong> <a name="habracut"></a></li></ul><br><h1> 关联性和功能组成 </h1><br><h4> 功能关联 </h4><br><p> 假设有一行函数编写在一起。 它们将以什么顺序组合？ </p><br><p> 例如，此功能是什么意思？ </p><br><pre><code class="plaintext hljs">let F xyz = xyz</code> </pre> <br><p> 这是否意味着将函数<code>y</code>应用于参数<code>z</code> ，然后将结果传递给<code>x</code> ？ 即：： </p><br><pre> <code class="plaintext hljs">let F xyz = x (yz)</code> </pre> <br><p> 还是将函数<code>x</code>应用于自变量<code>y</code> ，之后将使用自变量<code>z</code>评估作为结果获得的函数？ 即：： </p><br><pre> <code class="plaintext hljs">let F xyz = (xy) z</code> </pre> <br><ol><li> 第二个选项是正确的。 </li><li> 函数的使用具有<em>关联性</em> 。 </li><li>  <code>xyz</code>含义与<code>(xy) z</code>相同。 </li><li>  <code>wxyz</code>等于<code>((wx) y) z</code> 。 </li><li> 这看起来不妙。 </li><li> 我们已经看到了部分应用程序是如何工作的。 </li><li> 如果我们将<code>x</code>作为具有两个参数的函数进行讨论，则<code>(xy) z</code>是部分应用第一个参数的结果，然后将参数<code>z</code>传递给中间函数。 </li></ol><br><p> 如果需要正确的关联性，则可以使用括号或竖线。 以下三个条目是等效的： </p><br><pre> <code class="plaintext hljs">let F xyz = x (yz) let F xyz = yz |&gt; x //    let F xyz = x &lt;| yz //   </code> </pre> <br><p> 作为练习，尝试在不进行实际计算的情况下显示这些功能的签名。 </p><br><h4> 功能组成 </h4><br><p> 我们多次提到函数的组成，但是这个术语的真正含义是什么？ 乍一看似乎令人恐惧，但实际上，一切都很简单。 </p><br><p> 假设我们有一个函数“ f”，它将类型“ T1”映射到类型“ T2”。 我们还有一个函数“ g”将类型“ T2”转换为类型“ T3”。 然后，我们可以连接“ f”的输出和“ g”的输入，创建一个新函数，将类型“ T1”转换为类型“ T3”。 </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/45c/9ff/278/45c9ff278d8f76d6cd63d668dd0ce3fc.png"></p><br><p> 例如： </p><br><pre> <code class="plaintext hljs">let f (x:int) = float x * 3.0 // f  -  int-&gt;float let g (x:float) = x &gt; 4.0 // g  -  float-&gt;bool</code> </pre> <br><p> 我们可以创建一个新函数“ h”，该函数将“ f”的输出用作“ g”的输入。 </p><br><pre> <code class="plaintext hljs">let h (x:int) = let y = f(x) g(y) //    g</code> </pre> <br><p> 更加紧凑： </p><br><pre> <code class="plaintext hljs">let h (x:int) = g ( f(x) ) // h    int-&gt;bool // h 1 h 2</code> </pre> <br><p>  <em>到目前为止，如此简单。</em> 这很有趣，我们可以定义一个新的函数“ compose”，该函数将函数“ f”和“ g”合并在一起，甚至不知道它们的签名。 </p><br><pre> <code class="plaintext hljs">let compose fgx = g ( f(x) )</code> </pre> <br><p> 执行之后，您可以看到编译器正确地确定“ <code>f</code> ”是泛型类型<code>'a</code>到泛型类型<code>'b</code>的函数，并且' <code>g</code> '限于类型<code>'b</code>输入： </p><br><pre> <code class="plaintext hljs">val compose : ('a -&gt; 'b) -&gt; ('b -&gt; 'c) -&gt; 'a -&gt; 'c</code> </pre> <br><p>  （请注意，仅由于每个函数只有一个输入参数和一个输出，才有可能对操作进行广义组合。在非函数语言中，这种方法是不可能的。） </p><br><p> 如我们所见，该定义用于“ <code>&gt;&gt;</code> ”运算符。 </p><br><pre> <code class="plaintext hljs">let (&gt;&gt;) fgx = g ( f(x) )</code> </pre> <br><p> 由于有了这个定义，可以使用合成在现有功能的基础上构建新功能。 </p><br><pre> <code class="plaintext hljs">let add1 x = x + 1 let times2 x = x * 2 let add1Times2 x = (&gt;&gt;) add1 times2 x // add1Times2 3</code> </pre> <br><p> 显式记录非常麻烦。 但是您可以使它的使用更容易理解。 </p><br><p> 首先，您可以删除参数<code>x</code> ，该组合将返回部分应用程序。 </p><br><pre> <code class="plaintext hljs">let add1Times2 = (&gt;&gt;) add1 times2</code> </pre> <br><p> 其次，因为  <code>&gt;&gt;</code>是二进制运算符，您可以将其放在中间。 </p><br><pre> <code class="plaintext hljs">let add1Times2 = add1 &gt;&gt; times2</code> </pre> <br><p> 使用组合可使代码更清晰。 </p><br><pre> <code class="plaintext hljs">let add1 x = x + 1 let times2 x = x * 2 //   let add1Times2 x = times2(add1 x) //   let add1Times2 = add1 &gt;&gt; times2</code> </pre> <br><h4> 在实践中使用合成运算符 </h4><br><p> 合成运算符（像所有infix运算符一样）比常规函数具有较低的优先级。 这意味着在合成中使用的函数可以不带括号而带有参数。 </p><br><p> 例如，如果“ add”和“ times”函数具有参数，则可以在编写过程中传递它们。 </p><br><pre> <code class="plaintext hljs">let add nx = x + n let times nx = x * n let add1Times2 = add 1 &gt;&gt; times 2 let add5Times3 = add 5 &gt;&gt; times 3 // add5Times3 1</code> </pre> <br><p> 只要功能的相应输入和输出匹配，功能就可以使用任何值。 例如，考虑以下代码两次执行一个函数： </p><br><pre> <code class="plaintext hljs">let twice f = f &gt;&gt; f // ('a -&gt; 'a) -&gt; ('a -&gt; 'a)</code> </pre> <br><p> 请注意，编译器已推断“ <code>f</code> ”接受并返回相同类型的值。 </p><br><p> 现在考虑“ <code>+</code> ”功能。 如前所述，输入是<code>int</code> ，但输出实际上是<code>(int-&gt;int)</code> 。 因此，“ <code>+</code> ”可用于“ <code>twice</code> ”。 因此，您可以编写： </p><br><pre> <code class="plaintext hljs">let add1 = (+) 1 //  (int -&gt; int) let add1Twice = twice add1 //    (int -&gt; int) // add1Twice 9</code> </pre> <br><p> 另一方面，您不能写： </p><br><pre> <code class="plaintext hljs">let addThenMultiply = (+) &gt;&gt; (*)</code> </pre> <br><p> 因为输入“ *”必须是<code>int</code> ，而不是<code>int-&gt;int</code>函数（这是加法的输出）。 </p><br><p> 但是，如果您更正第一个函数，使其仅返回<code>int</code> ，那么一切都会起作用： </p><br><pre> <code class="plaintext hljs">let add1ThenMultiply = (+) 1 &gt;&gt; (*) // (+) 1   (int -&gt; int)   'int' // add1ThenMultiply 2 7</code> </pre> <br><p> 如有必要，还可以通过“ <code>&lt;&lt;</code> ”以相反的顺序执行合成： </p><br><pre> <code class="plaintext hljs">let times2Add1 = add 1 &lt;&lt; times 2 times2Add1 3</code> </pre> <br><p> 反向组合主要用于使代码更像英语（“类似于英语”）。 例如： </p><br><pre> <code class="plaintext hljs">let myList = [] myList |&gt; List.isEmpty |&gt; not //   myList |&gt; (not &lt;&lt; List.isEmpty) //   </code> </pre> <br><h4> 组成与 传送带 </h4><br><p> 成分和传送带之间的细微差别可能会让您感到困惑，因为 它们看起来很相似。 </p><br><p> 首先，查看管道的定义： </p><br><pre> <code class="plaintext hljs">let (|&gt;) xf = fx</code> </pre> <br><p> 所有这些使您可以将函数的参数放在其前面，而不是之后。 仅此而已。 如果函数具有多个参数，则输入应为最后一个参数（在当前参数集中，而不是根本不输入）。 前面看到的一个示例： </p><br><pre> <code class="plaintext hljs">let doSomething xyz = x+y+z doSomething 1 2 3 //      3 |&gt; doSomething 1 2 //     </code> </pre> <br><p> 组成不同，不能替代管道。 在下面的示例中，即使数字3也不是一个函数，所以“输出”不能传递给<code>doSomething</code> ： </p><br><pre> <code class="plaintext hljs">3 &gt;&gt; doSomething 1 2 //  // f &gt;&gt; g      g(f(x))     : doSomething 1 2 ( 3(x) ) //   3   ! // error FS0001: This expression was expected to have type 'a-&gt;'b // but here has type int</code> </pre> <br><p> 编译器抱怨值“ 3”必须是一种函数<code>'a-&gt;'b</code> 。 </p><br><p> 将此与组合的定义进行比较，该定义包含3个参数，其中前两个应为函数。 </p><br><pre> <code class="plaintext hljs">let (&gt;&gt;) fgx = g ( f(x) ) let add nx = x + n let times nx = x * n let add1Times2 = add 1 &gt;&gt; times 2</code> </pre> <br><p> 尝试使用管道而不是合成将导致编译错误。 在下面的示例中，“ <code>add 1</code> ”是（部分）函数<code>int-&gt;int</code> ，它不能用作“ <code>times 2</code> ”的第二个参数。 </p><br><pre> <code class="plaintext hljs">let add1Times2 = add 1 |&gt; times 2 //  // x |&gt; f      f(x)     : let add1Times2 = times 2 (add 1) // add1   'int' // error FS0001: Type mismatch. 'int -&gt; int' does not match 'int'</code> </pre> <br><p> 编译器抱怨“ <code>times 2</code> ”必须接受参数<code>int-&gt;int</code> ，即 是一个函数<code>(int-&gt;int)-&gt;'a</code> 。 </p><br><h1> 其他资源 </h1><br><p>  F＃的教程很多，包括那些具有C＃或Java经验的人的材料。 当您深入了解F＃时，以下链接可能会很有用： </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">F＃指南</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">F＃娱乐与利润</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">F＃维基</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">在Y分钟内学习X：F＃</a> </li></ul><br><p> 还介绍了其他几种<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">开始学习F＃的方法</a> 。 </p><br><p> 最后，F＃社区非常适合初学者。 在Slack上，由F＃Software Foundation支持的聊天非常活跃，您<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">可以自由加入</a>初学者室。 我们强烈建议您这样做！ </p><br><p> 不要忘记访问<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">俄语社区F＃的网站</a> ！ 如果您对学习语言有任何疑问，我们将很乐意在聊天室中讨论这些问题： </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">F＃软件基金会Slack聊天</a>室中的<code>#ru_general</code> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">室</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">在电报中聊天</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">聊天聊天</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">F＃软件基金会Slack聊天</a>室中的#en_general <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">室</a> </li></ul><br><h2> 关于翻译作者 </h2><br><p> 由<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><em>@kleidemos</em></a>翻译 <br><img src="https://habrastorage.org/getpro/habr/post_images/f95/c6d/92c/f95c6d92c5b1126b093792a43955aa43.png" width="56" height="56">  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">在F＃开发人员</a>的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">俄语社区</a>的努力下进行了翻译和编辑更改。 我们也感谢<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><em>@schvepsss</em></a>和<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><em>@shwars</em></a>为本文准备发表。 </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN413195/">https://habr.com/ru/post/zh-CN413195/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN413181/index.html">当外部函数调用比本地C调用快时</a></li>
<li><a href="../zh-CN413183/index.html">Optane DC永久性内存-DIMM格式的Optane</a></li>
<li><a href="../zh-CN413185/index.html">犯规行为或抽奖的组织者如何欺骗我们</a></li>
<li><a href="../zh-CN413187/index.html">Node.js的创建者Ryan Dahl访谈</a></li>
<li><a href="../zh-CN413193/index.html">买铁对云：如何计算</a></li>
<li><a href="../zh-CN413199/index.html">未来学家的失败。 电影中没有实现的想法</a></li>
<li><a href="../zh-CN413203/index.html">ICO和安全性：积极Hack天的竞争情报竞赛分析</a></li>
<li><a href="../zh-CN413205/index.html">必需的HTTP标头</a></li>
<li><a href="../zh-CN413207/index.html">PGCon 2018：照片，幻灯片，印象</a></li>
<li><a href="../zh-CN413211/index.html">解析Avito iOS应用程序：任何问题</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>