<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë° üéûÔ∏è üê¨ Fitur pemfilteran jendela pada FPGA üôå ü¶á üå®Ô∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Halo semuanya! Artikel ini akan fokus pada satu bagian penting dari pemrosesan sinyal digital - penyaringan sinyal jendela, khususnya pada FPGA. Artik...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Fitur pemfilteran jendela pada FPGA</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/427361/"> Halo semuanya!  Artikel ini akan fokus pada satu bagian penting dari pemrosesan sinyal digital - penyaringan sinyal jendela, khususnya pada FPGA.  Artikel ini akan menunjukkan cara mendesain jendela klasik dengan panjang standar dan jendela "panjang" dari sampel 64K hingga 16M +.  Bahasa pengembangan utama adalah VHDL, basis elemen adalah kristal Xilinx FPGA terbaru dari keluarga terbaru: ini adalah Ultrascale, Ultrascale +, 7-series.  Artikel ini akan mendemonstrasikan implementasi CORDIC - kernel dasar untuk mengonfigurasi fungsi jendela dalam durasi berapa pun, serta fungsi jendela dasar.  Artikel ini menjelaskan metode desain menggunakan bahasa tingkat tinggi C / C ++ di Vivado HLS.  Seperti biasa, di akhir artikel Anda akan menemukan tautan ke kode sumber proyek. <br><br>  KDPV: skema khas transmisi sinyal melalui node DSP untuk tugas analisis spektrum. <br><br><img src="https://habrastorage.org/webt/hq/5j/_l/hq5j_lnsfr_k8oaex-cesewdeyi.png"><br><a name="habracut"></a><br><h3>  Pendahuluan </h3><br>  Dari kursus "Digital Signal Processing" banyak orang tahu bahwa untuk bentuk gelombang sinusoidal yang tak terbatas dalam waktu, spektrumnya adalah fungsi delta pada frekuensi sinyal.  Dalam praktiknya, spektrum sinyal harmonik terbatas waktu nyata setara dengan fungsi <b>~ sin (x) / x</b> , dan lebar lobus utama tergantung pada durasi interval analisis sinyal <b>T.</b>  Batas waktu tidak lebih dari mengalikan sinyal dengan amplop persegi panjang.  Diketahui dari kursus DSP bahwa penggandaan sinyal dalam domain waktu adalah konvolusi dari spektrum mereka dalam domain frekuensi (dan sebaliknya), oleh karena itu, spektrum amplop persegi panjang terbatas dari sinyal harmonik setara dengan ~ sinc (x).  Ini juga disebabkan oleh fakta bahwa kita tidak dapat mengintegrasikan sinyal selama interval waktu yang tidak terbatas, dan transformasi Fourier dalam bentuk diskrit, diekspresikan melalui jumlah terbatas, dibatasi oleh jumlah sampel.  Sebagai aturan, panjang FFT di perangkat pemrosesan digital FPGA modern membutuhkan nilai <b>NFFT</b> dari 8 hingga beberapa juta poin.  Dengan kata lain, spektrum sinyal input dihitung pada interval <b>T</b> , yang dalam banyak kasus sama dengan <b>NFFT</b> .  Dengan membatasi sinyal ke interval <b>T</b> , kami memaksakan "jendela" persegi panjang dengan durasi sampel <b>T.</b>  Oleh karena itu, spektrum yang dihasilkan adalah spektrum dari sinyal harmonik berlipat ganda dan amplop persegi panjang.  Dalam tugas-tugas DSP, jendela berbagai bentuk telah ditemukan untuk waktu yang lama, yang, ketika ditumpangkan pada sinyal dalam domain waktu, dapat meningkatkan karakteristik spektralnya.  Sejumlah besar berbagai jendela terutama disebabkan oleh salah satu fitur utama dari setiap hamparan jendela.  Fitur ini dinyatakan dalam hubungan antara tingkat lobus samping dan lebar lobus sentral.  Pola yang terkenal: semakin kuat penekanan lobus samping, semakin luas lobus utama, dan sebaliknya. <br><br>  Salah satu aplikasi fungsi jendela: deteksi sinyal lemah dengan latar belakang sinyal yang lebih kuat dengan menekan level lobus samping.  Fungsi jendela utama dalam tugas DSP adalah segitiga, sinusoidal, Lanczos, Hann, Hamming, Blackman, Harris, jendela Blackman-Harris, jendela flat-top, Natall, Gauss, jendela Kaiser, dan banyak lainnya.  Sebagian besar dari mereka diekspresikan melalui seri terbatas dengan menjumlahkan sinyal harmonik dengan bobot tertentu.  Windows bentuk kompleks dihitung dengan mengambil eksponen (jendela Gaussian) atau fungsi Bessel yang dimodifikasi (jendela Kaiser), dan tidak akan dipertimbangkan dalam artikel ini.  Anda dapat membaca lebih lanjut tentang fungsi jendela dalam literatur, yang secara tradisional akan saya berikan di akhir artikel. <br><br>  Gambar berikut ini menunjukkan fungsi jendela yang khas dan karakteristik spektralnya yang dibangun menggunakan alat Matlab CAD. <br><br><img src="https://habrastorage.org/webt/nf/dw/pm/nfdwpmdfjlxbkjx4thfjo3d3wrq.png"><br><br><h3>  Implementasi </h3><br>  Di awal artikel, saya memasukkan KDPV, yang secara umum menunjukkan diagram struktural dari penggandaan data input dengan fungsi jendela.  Jelas, cara termudah untuk menerapkan penyimpanan fungsi jendela di FPGA adalah menulisnya ke memori (blok <i>RAMB</i> atau didistribusikan <i>Terdistribusi</i> - tidak masalah banyak), dan kemudian mengambil data secara siklikal ketika sampel input sinyal tiba.  Sebagai aturan, dalam FPGA modern, jumlah memori internal memungkinkan penyimpanan fungsi jendela dengan ukuran yang relatif kecil, yang kemudian dikalikan dengan sinyal input yang masuk.  Secara kecil maksud saya fungsi jendela hingga 64 ribu sampel. <br><br>  Tetapi bagaimana jika fungsi jendela terlalu panjang?  Misalnya, bacaan 1M.  Sangat mudah untuk menghitung bahwa untuk fungsi jendela seperti itu yang disajikan dalam kisi bit 32-bit, NRAMB = 1024 * 1024 * 32/32768 = 1024 blok sel-sel memori dari RAMB36K tipe FPGA Xilinx kristal diperlukan.  Dan untuk sampel 16 juta?  16 ribu sel memori!  Tidak satu pun FPGA modern yang memiliki begitu banyak memori.  Bagi banyak FPGA, ini terlalu banyak, dan dalam kasus lain itu adalah penggunaan sumber daya FPGA yang sia-sia (dan, tentu saja, uang pelanggan). <br><br>  Dalam hal ini, Anda perlu menemukan metode untuk menghasilkan sampel fungsi jendela langsung ke FPGA on the fly, tanpa menulis koefisien dari perangkat jarak jauh ke memori blok.  Untungnya, hal-hal dasar telah lama ditemukan untuk kita.  Menggunakan algoritma seperti <b>CORDIC</b> (metode <i>digit-per-digit</i> ), dimungkinkan untuk merancang banyak fungsi jendela yang rumusnya dinyatakan dalam sinyal harmonik (Blackman-Harris, Hann, Hamming, Nattal, dll.) <br><br><h3>  CORDIC </h3><br>  CORDIC adalah metode berulang yang sederhana dan nyaman untuk menghitung rotasi sistem koordinat, yang memungkinkan Anda menghitung fungsi kompleks dengan melakukan penambahan primitif dan operasi shift.  Dengan menggunakan algoritma CORDIC, seseorang dapat menghitung nilai sinyal harmonik sin (x), cos (x), menemukan fase - atan (x) dan atan2 (x, y), fungsi trigonometri hiperbolik, memutar vektor, mengekstrak akar angka, dll. <br><br>  Pada awalnya saya ingin mengambil kernel CORDIC yang sudah jadi dan mengurangi jumlah pekerjaan, tetapi saya tidak menyukai kernel Xilinx.  Setelah mempelajari repositori di github, saya menyadari bahwa semua kernel yang disajikan tidak cocok untuk sejumlah alasan (kurang terdokumentasi dan tidak dapat dibaca, tidak universal, dibuat untuk tugas atau basis elemen tertentu, <s>ditulis dalam Verilog</s> , dll.).  Kemudian saya meminta kawan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" class="user_link">lazifo</a> untuk melakukan pekerjaan ini untuk saya.  Tentu saja, ia mengatasinya, karena implementasi CORDIC adalah salah satu tugas paling sederhana di bidang DSP.  Tetapi karena saya tidak sabar, bersamaan dengan pekerjaannya, saya menulis <s>sepeda</s> saya <s>dengan</s> inti parametrized saya <s>sendiri</s> .  Fitur utama adalah kedalaman bit yang dapat dikonfigurasi dari sinyal output <b>DATA_WIDTH</b> dan fase input normal <b>PHASE_WIDTH</b> dari -1 hingga 1, dan ketepatan perhitungan <b>PRECISION</b> .  Inti CORDIC dijalankan sesuai dengan sirkuit paralel pipa - pada setiap siklus jam, inti siap melakukan perhitungan dan menerima sampel input.  Kernel menghabiskan N siklus untuk menghitung sampel keluaran, yang jumlahnya tergantung pada kapasitas sampel keluaran (semakin banyak kapasitas, semakin banyak iterasi untuk menghitung nilai output).  Semua perhitungan terjadi secara paralel.  Dengan demikian, CORDIC adalah inti dasar untuk membuat fungsi jendela. <br><br><h3>  Fungsi jendela </h3><br>  Dalam kerangka artikel ini, saya menyadari hanya fungsi-fungsi jendela yang diekspresikan melalui sinyal harmonik (Hann, Hamming, Blackman-Harris dari berbagai pesanan, dll.).  Apa yang dibutuhkan untuk ini?  Secara umum, rumus untuk membangun jendela terlihat seperti serangkaian panjang yang terbatas. <br><br><img src="https://habrastorage.org/webt/it/ih/tg/itihtgetk0lxnpoavnivrrot0ou.png"><br><br>  Seperangkat koefisien tertentu <b>a <sub>k</sub></b> dan anggota seri menentukan nama jendela.  Yang paling populer dan sering digunakan adalah jendela Blackman-Harris: dari urutan berbeda (dari 3 hingga 11).  Berikut ini adalah tabel koefisien untuk Blackman-Harris windows: <br><br><img src="https://habrastorage.org/webt/fy/ss/_4/fyss_4cniul5oacholwxdvxfhli.jpeg"><br><br>  Pada prinsipnya, rangkaian jendela Blackman-Harris dapat diterapkan di banyak masalah analisis spektral, dan tidak perlu mencoba menggunakan jendela kompleks seperti Gauss atau Kaiser.  Jendela nattal atau flat-top hanyalah tipe jendela dengan bobot berbeda, tetapi prinsip dasarnya sama dengan Blackman-Harris.  Diketahui bahwa semakin banyak anggota seri, semakin kuat penekanan tingkat lobus samping (bergantung pada pilihan yang masuk akal dari kedalaman bit dari fungsi jendela).  Berdasarkan tugas tersebut, pengembang tinggal memilih jenis windows yang digunakan. <br><br><h3>  Implementasi FPGA - pendekatan tradisional </h3><br>  Semua kernel fungsi jendela dirancang menggunakan pendekatan klasik untuk menggambarkan sirkuit digital dalam FPGA dan ditulis dalam bahasa VHDL.  Di bawah ini adalah daftar komponen yang dibuat: <br><br><ul><li>  <i>bh_win_7term</i> - Blackman-Harris 7 order, jendela dengan penindasan maksimum perancah samping. </li><li>  <i>bh_win_5term</i> - Blackman-Harris 5 order, termasuk jendela dengan atasan datar. </li><li>  <i>bh_win_4term</i> - Blackman-Harris 4 pesanan, termasuk jendela Nattal dan Blackman-Nattal. </li><li>  <i>bh_win_3term</i> - Blackman-Harris 3 pesanan, </li><li>  <i>hamming_win</i> - <i>Jendela</i> Hamming dan Hann. </li></ul><br>  Kode sumber untuk komponen jendela Blackman-Harris adalah 3 kali lipat: <br><br><pre><code class="vhdl hljs"><span class="hljs-keyword"><span class="hljs-keyword">entity</span></span> bh_win_3term <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">generic</span></span> ( TD : <span class="hljs-built_in"><span class="hljs-built_in">time</span></span>:=<span class="hljs-number"><span class="hljs-number">0.5</span></span>ns; <span class="hljs-comment"><span class="hljs-comment">--! Time delay PHI_WIDTH : integer:=10; --! Signal period = 2^PHI_WIDTH DAT_WIDTH : integer:=16; --! Output data width XSERIES : string:="ULTRA" --! for 6/7 series: "7SERIES"; for ULTRASCALE: "ULTRA"; ); port ( RESET : in std_logic; --! Global reset CLK : in std_logic; --! System clock AA0 : in std_logic_vector(DAT_WIDTH-1 downto 0); -- A0 AA1 : in std_logic_vector(DAT_WIDTH-1 downto 0); -- A1 AA2 : in std_logic_vector(DAT_WIDTH-1 downto 0); -- A2 ENABLE : in std_logic; --! Clock enable DT_WIN : out std_logic_vector(DAT_WIDTH-1 downto 0); --! Output DT_VLD : out std_logic --! Output data valid ); end bh_win_3term;</span></span></code> </pre> <br>  Dalam beberapa kasus, saya menggunakan perpustakaan <i>UNISIM</i> untuk menanamkan <b>simpul DSP48E1 dan DSP48E2</b> dalam proyek, yang pada akhirnya memungkinkan <b>saya</b> untuk meningkatkan kecepatan perhitungan karena pipelining di dalam blok-blok ini, tetapi seperti yang diperlihatkan, lebih cepat dan lebih mudah untuk memberikan kendali bebas dan menulis sesuatu seperti <b>P = A * B + C</b> dan tentukan arahan berikut dalam kode: <br><br><pre> <code class="vhdl hljs"><span class="hljs-keyword"><span class="hljs-keyword">attribute</span></span> USE_DSP <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> &lt;signal_name&gt;: <span class="hljs-keyword"><span class="hljs-keyword">signal</span></span> <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-string"><span class="hljs-string">"YES"</span></span>;</code> </pre> <br>  Ini berfungsi dengan baik dan secara kaku mengatur jenis elemen di mana fungsi matematika diimplementasikan untuk synthesizer. <br><br><h3>  Vivado hl </h3><br>  Selain itu, saya menerapkan semua inti menggunakan alat <b>HLS Vivado</b> .  Saya akan mencantumkan <b>keuntungan</b> utama <b>dari</b> Vivado HLS: kecepatan tinggi desain ( <i>waktu-ke-pasar</i> ) dalam bahasa tingkat tinggi C atau C ++, pemodelan cepat node yang dikembangkan karena kurangnya konsep frekuensi clock, konfigurasi solusi yang fleksibel (dalam hal sumber daya dan kinerja) dengan memperkenalkan pragma dan arahan dalam proyek, serta ambang masuk yang rendah untuk pengembang dalam bahasa tingkat tinggi.  Kerugian utama adalah biaya suboptimal sumber daya FPGA dibandingkan dengan pendekatan klasik.  Juga, tidak mungkin untuk mencapai kecepatan yang disediakan oleh metode RTL klasik lama (VHDL, Verilog, SV).  Ya, <b>kelemahan</b> terbesar adalah menari dengan rebana, tetapi ini adalah karakteristik semua CAD dari Xilinx.  (Catatan: dalam debugger Vivado HLS dan dalam model C ++ yang sebenarnya, seringkali diperoleh hasil yang berbeda, karena Vivado HLS bekerja dengan bengkok menggunakan keuntungan dari <i>presisi yang sewenang</i> - <i>wenang</i> ). <br><br>  Gambar berikut menunjukkan log kernel CORDIC yang disintesis di Vivado HLS.  Ini cukup informatif dan menampilkan banyak informasi berguna: jumlah sumber daya yang digunakan, antarmuka pengguna kernel, loop dan propertinya, keterlambatan dalam komputasi, interval untuk menghitung nilai output (penting ketika merancang rangkaian serial dan paralel): <br><br><img src="https://habrastorage.org/webt/oe/e3/zh/oee3zhonsadxnqugfhd8geg7hca.png"><br><br>  Anda juga dapat melihat cara menghitung data dalam berbagai komponen (fungsi).  Dapat dilihat bahwa pada fase nol, data fase dibaca, dan pada langkah 7 dan 8, hasil dari simpul CORDIC ditampilkan. <br><img src="https://habrastorage.org/webt/kw/nf/j7/kwnfj7uftmtnnv6iaxoecjvji1g.png"><br><br>  Hasil dari Vivado HLS: kernel RTL yang disintesis dibuat dari kode C.  Log menunjukkan bahwa dalam analisis waktu, kernel berhasil melewati semua batasan: <br><br><img src="https://habrastorage.org/webt/83/tb/hw/83tbhwy9j5jqkgn2tdz697dz-na.png"><br><br>  Kelebihan lain dari Vivado HLS adalah untuk memverifikasi hasilnya, dia sendiri membuat testbench dari kode RTL yang disintesis berdasarkan model yang digunakan untuk memeriksa kode C.  Ini mungkin tes primitif, tapi saya percaya ini sangat keren dan cukup nyaman untuk membandingkan operasi algoritma di C dan HDL.  Di bawah ini adalah tangkapan layar dari Vivado yang menunjukkan simulasi model fungsi kernel dari fungsi jendela yang diperoleh oleh Vivado HLS: <br><br><img src="https://habrastorage.org/webt/6q/zw/3m/6qzw3mcmm6xixm-wh9kpumqpzx8.png"><br><br>  Jadi, untuk semua fungsi jendela, hasil yang sama diperoleh, terlepas dari metode desain - dalam VHDL atau dalam C ++.  Namun, dalam kasus pertama, frekuensi operasi yang lebih besar dan jumlah sumber daya yang lebih kecil tercapai, dan dalam kasus kedua, kecepatan desain maksimum tercapai.  Kedua pendekatan memiliki hak untuk hidup. <br><br>  Saya secara khusus menghitung berapa banyak waktu yang akan saya habiskan untuk pengembangan menggunakan metode yang berbeda.  Saya menerapkan proyek C ++ di Vivado HLS ~ 12 kali lebih cepat daripada di VHDL. <br><br><h3>  Perbandingan pendekatan </h3><br>  Bandingkan kode sumber untuk HDL dan C ++ untuk inti CORDIC.  Algoritma, seperti yang dikatakan sebelumnya, didasarkan pada operasi penjumlahan, pengurangan, dan pergeseran.  Pada VHDL, terlihat seperti ini: ada tiga vektor data - satu bertanggung jawab untuk rotasi sudut, dan dua lainnya menentukan panjang vektor sepanjang sumbu X dan Y, yang setara dengan sin dan cos (lihat gambar dari wiki): <br><br><img src="https://habrastorage.org/webt/ab/3w/hv/ab3whvtkvcgl-ycqnkz3mjzr0lk.png"><br><br>  Dengan secara iteratif menghitung nilai Z, nilai-nilai X dan Y dihitung secara paralel. Proses siklus mencari nilai-nilai output pada HDL: <br><br><pre> <code class="vhdl hljs"><span class="hljs-keyword"><span class="hljs-keyword">constant</span></span> ROM_LUT : rom_array := ( x<span class="hljs-string"><span class="hljs-string">"400000000000"</span></span>, x<span class="hljs-string"><span class="hljs-string">"25C80A3B3BE6"</span></span>, x<span class="hljs-string"><span class="hljs-string">"13F670B6BDC7"</span></span>, x<span class="hljs-string"><span class="hljs-string">"0A2223A83BBB"</span></span>, x<span class="hljs-string"><span class="hljs-string">"05161A861CB1"</span></span>, x<span class="hljs-string"><span class="hljs-string">"028BAFC2B209"</span></span>, x<span class="hljs-string"><span class="hljs-string">"0145EC3CB850"</span></span>, x<span class="hljs-string"><span class="hljs-string">"00A2F8AA23A9"</span></span>, x<span class="hljs-string"><span class="hljs-string">"00517CA68DA2"</span></span>, x<span class="hljs-string"><span class="hljs-string">"0028BE5D7661"</span></span>, x<span class="hljs-string"><span class="hljs-string">"00145F300123"</span></span>, x<span class="hljs-string"><span class="hljs-string">"000A2F982950"</span></span>, x<span class="hljs-string"><span class="hljs-string">"000517CC19C0"</span></span>, x<span class="hljs-string"><span class="hljs-string">"00028BE60D83"</span></span>, x<span class="hljs-string"><span class="hljs-string">"000145F306D6"</span></span>, x<span class="hljs-string"><span class="hljs-string">"0000A2F9836D"</span></span>, x<span class="hljs-string"><span class="hljs-string">"0000517CC1B7"</span></span>, x<span class="hljs-string"><span class="hljs-string">"000028BE60DC"</span></span>, x<span class="hljs-string"><span class="hljs-string">"0000145F306E"</span></span>, x<span class="hljs-string"><span class="hljs-string">"00000A2F9837"</span></span>, x<span class="hljs-string"><span class="hljs-string">"00000517CC1B"</span></span>, x<span class="hljs-string"><span class="hljs-string">"0000028BE60E"</span></span>, x<span class="hljs-string"><span class="hljs-string">"00000145F307"</span></span>, x<span class="hljs-string"><span class="hljs-string">"000000A2F983"</span></span>, x<span class="hljs-string"><span class="hljs-string">"000000517CC2"</span></span>, x<span class="hljs-string"><span class="hljs-string">"00000028BE61"</span></span>, x<span class="hljs-string"><span class="hljs-string">"000000145F30"</span></span>, x<span class="hljs-string"><span class="hljs-string">"0000000A2F98"</span></span>, x<span class="hljs-string"><span class="hljs-string">"0000000517CC"</span></span>, x<span class="hljs-string"><span class="hljs-string">"000000028BE6"</span></span>, x<span class="hljs-string"><span class="hljs-string">"0000000145F3"</span></span>, x<span class="hljs-string"><span class="hljs-string">"00000000A2FA"</span></span>, x<span class="hljs-string"><span class="hljs-string">"00000000517D"</span></span>, x<span class="hljs-string"><span class="hljs-string">"0000000028BE"</span></span>, x<span class="hljs-string"><span class="hljs-string">"00000000145F"</span></span>, x<span class="hljs-string"><span class="hljs-string">"000000000A30"</span></span>, x<span class="hljs-string"><span class="hljs-string">"000000000518"</span></span>, x<span class="hljs-string"><span class="hljs-string">"00000000028C"</span></span>, x<span class="hljs-string"><span class="hljs-string">"000000000146"</span></span>, x<span class="hljs-string"><span class="hljs-string">"0000000000A3"</span></span>, x<span class="hljs-string"><span class="hljs-string">"000000000051"</span></span>, x<span class="hljs-string"><span class="hljs-string">"000000000029"</span></span>, x<span class="hljs-string"><span class="hljs-string">"000000000014"</span></span>, x<span class="hljs-string"><span class="hljs-string">"00000000000A"</span></span>, x<span class="hljs-string"><span class="hljs-string">"000000000005"</span></span>, x<span class="hljs-string"><span class="hljs-string">"000000000003"</span></span>, x<span class="hljs-string"><span class="hljs-string">"000000000001"</span></span>, x<span class="hljs-string"><span class="hljs-string">"000000000000"</span></span> ); pr_crd: <span class="hljs-keyword"><span class="hljs-keyword">process</span></span>(clk, reset) <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (reset = <span class="hljs-string"><span class="hljs-string">'1'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-comment"><span class="hljs-comment">---- Reset sine / cosine / angle vector ---- sigX &lt;= (others =&gt; (others =&gt; '0')); sigY &lt;= (others =&gt; (others =&gt; '0')); sigZ &lt;= (others =&gt; (others =&gt; '0')); elsif rising_edge(clk) then sigX(0) &lt;= init_x; sigY(0) &lt;= init_y; sigZ(0) &lt;= init_z; ---- calculate sine &amp; cosine ---- lpXY: for ii in 0 to DATA_WIDTH-2 loop if (sigZ(ii)(sigZ(ii)'left) = '1') then sigX(ii+1) &lt;= sigX(ii) + sigY(ii)(DATA_WIDTH+PRECISION-1 downto ii); sigY(ii+1) &lt;= sigY(ii) - sigX(ii)(DATA_WIDTH+PRECISION-1 downto ii); else sigX(ii+1) &lt;= sigX(ii) - sigY(ii)(DATA_WIDTH+PRECISION-1 downto ii); sigY(ii+1) &lt;= sigY(ii) + sigX(ii)(DATA_WIDTH+PRECISION-1 downto ii); end if; end loop; ---- calculate phase ---- lpZ: for ii in 0 to DATA_WIDTH-2 loop if (sigZ(ii)(sigZ(ii)'left) = '1') then sigZ(ii+1) &lt;= sigZ(ii) + ROM_TABLE(ii); else sigZ(ii+1) &lt;= sigZ(ii) - ROM_TABLE(ii); end if; end loop; end if; end process;</span></span></code> </pre><br>  Di C ++, di Vivado HLS, kode terlihat hampir sama, tetapi catatan beberapa kali lebih pendek: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Unrolled loop // int k; stg: for (k = 0; k &lt; NWIDTH; k++) { #pragma HLS UNROLL if (z[k] &lt; 0) { x[k+1] = x[k] + (y[k] &gt;&gt; k); y[k+1] = y[k] - (x[k] &gt;&gt; k); z[k+1] = z[k] + lut_angle[k]; } else { x[k+1] = x[k] - (y[k] &gt;&gt; k); y[k+1] = y[k] + (x[k] &gt;&gt; k); z[k+1] = z[k] - lut_angle[k]; } }</span></span></code> </pre><br><br>  Rupanya, siklus yang sama dengan shift dan penambahan digunakan.  Namun, secara default, semua loop di Vivado HLS "diciutkan" dan dieksekusi secara berurutan, sebagaimana dimaksudkan untuk bahasa C ++.  Pengenalan <b>pragma HLS UNROLL</b> atau <b>HLS PIPELINE</b> mengubah serial ke komputasi paralel.  Ini mengarah pada peningkatan sumber daya FPGA, namun, ini memungkinkan Anda untuk menghitung dan mengirimkan nilai baru ke inti pada setiap siklus clock. <br><br>  Hasil sintesis proyek dalam VHDL dan C ++ disajikan pada gambar di bawah ini.  Seperti yang Anda lihat, secara logis, perbedaannya adalah dua kali lebih mendukung pendekatan tradisional.  Untuk sumber daya FPGA lainnya, perbedaannya tidak signifikan.  Saya tidak masuk jauh ke dalam mengoptimalkan proyek di C ++, tetapi jelas dengan menetapkan berbagai arahan atau sebagian mengubah kode, jumlah sumber daya yang digunakan dapat dikurangi.  Dalam kedua kasus, timing dikonvergensi untuk frekuensi inti yang diberikan ~ 350 MHz. <br><img src="https://habrastorage.org/webt/lp/id/ic/lpidicvwz-edguptklqfahlo0ya.png"><br><br><h3>  Fitur Implementasi </h3><br>  Karena perhitungan dilakukan dalam format titik tetap, fungsi jendela memiliki sejumlah fitur yang harus diperhitungkan ketika merancang sistem DSP pada FPGA.  Sebagai contoh, semakin besar kedalaman bit dari data fungsi jendela, semakin baik akurasi overlay jendela.  Di sisi lain, dengan kedalaman bit yang tidak cukup dari fungsi jendela, distorsi akan dimasukkan ke dalam bentuk gelombang yang dihasilkan, yang akan mempengaruhi kualitas karakteristik spektral.  Misalnya, fungsi jendela harus memiliki setidaknya 20 bit ketika dikalikan dengan sinyal dengan durasi 2 ^ 20 = 1M sampel. <br><br><h3>  Kesimpulan </h3><br>  Artikel ini menunjukkan satu cara untuk merancang fungsi jendela tanpa menggunakan memori eksternal atau memori blok FPGA.  Metode menggunakan sumber daya logis eksklusif FPGA (dan dalam beberapa kasus blok DSP) diberikan.  Dengan menggunakan algoritma CORDIC, dimungkinkan untuk mendapatkan fungsi-fungsi jendela dari setiap kedalaman bit (dengan alasan), dengan panjang dan urutan berapa pun, dan oleh karena itu memiliki seperangkat karakteristik spektral dari jendela tersebut. <br><br>  Sebagai bagian dari salah satu studi, saya berhasil mendapatkan kernel fungsi Blackman-Harris yang berfungsi secara stabil dari 5 dan 7 orde besarnya pada sampel 1M pada frekuensi ~ 375 MHz, dan juga membuat generator koefisien putar untuk FFT berdasarkan CORDIC pada frekuensi ~ 400 MHz.  FPGA Crystal Digunakan: Kintex Ultrascale + (xcku11p-ffva1156-2-e). <br><br>  Tautan ke <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">proyek <b>github di</b> sini</a> .  Proyek ini berisi model matematika di Matlab, kode sumber untuk fungsi jendela dan CORDIC di VHDL, serta model fungsi jendela yang terdaftar di C ++ untuk Vivado HLS. <br><br><h3>  Artikel yang Berguna </h3><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Fungsi Jendela DSPLib</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Beberapa Fungsi Jendela DSPlib</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Wiki Penyaringan Jendela yang Diperluas</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Artikel wiki tentang CORDIC</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Vivado HLS Userguide</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Artikel tentang analisis spektral tentang Habr</a> </li></ul><br>  Saya juga menyarankan buku yang sangat populer tentang DSP - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Ayficher E., pemrosesan sinyal Jervis B. Digital.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Pendekatan praktis</a> <br><br>  Terima kasih atas perhatian anda! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id427361/">https://habr.com/ru/post/id427361/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id427351/index.html">Security Week 40: Kerentanan dalam CMS Drupal dan Lainnya</a></li>
<li><a href="../id427353/index.html">Drone menunjukkan: bagaimana kita mengoordinasikan sekelompok penari menari</a></li>
<li><a href="../id427355/index.html">Kompilasi CJM, keterampilan art director utama dan pemahaman pengguna</a></li>
<li><a href="../id427357/index.html">Menulis shader di Unity. GrabPass, PerRendererData</a></li>
<li><a href="../id427359/index.html">Bagaimana ECS, Sistem Pekerjaan C #, dan Arsitektur Ubah SRP</a></li>
<li><a href="../id427363/index.html">Implementasi LoRaWAN di perusahaan pertanian. Segala sesuatu tentang konstruksi, peluncuran, dan solusi</a></li>
<li><a href="../id427365/index.html">Laporan dari RedSlerm tentang pemantauan (Monit, Zabbix)</a></li>
<li><a href="../id427367/index.html">Konferensi BLACK HAT USA. Bagaimana seorang hacker Hollywood menggunakan kamera pengintai. Bagian 1</a></li>
<li><a href="../id427369/index.html">Konferensi BLACK HAT USA. Bagaimana seorang hacker Hollywood menggunakan kamera pengintai. Bagian 2</a></li>
<li><a href="../id427371/index.html">Kursus video "Dasar-dasar bekerja dengan notasi BPMN." Gratis</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>