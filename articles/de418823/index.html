<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üëêüèΩ üåü üë®üèΩ‚Äçüíª Python ist langsam. Warum? ü§òüèæ ü§∫ üë©üèø‚Äçüéì</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In letzter Zeit kann man die wachsende Popularit√§t der Programmiersprache Python beobachten. Es wird in DevOps, in der Datenanalyse, in der Webentwick...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Python ist langsam. Warum?</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/418823/">  In letzter Zeit kann man die wachsende Popularit√§t der Programmiersprache Python beobachten.  Es wird in DevOps, in der Datenanalyse, in der Webentwicklung, im Sicherheitsbereich und in anderen Bereichen verwendet.  Aber hier ist die Geschwindigkeit ... Von dieser Sprache gibt es hier nichts zu r√ºhmen.  Der Autor des Materials, dessen √úbersetzung wir heute ver√∂ffentlichen, hat beschlossen, die Gr√ºnde f√ºr die Langsamkeit von Python herauszufinden und Mittel zu finden, um es zu beschleunigen. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/webt/tv/zp/uz/tvzpuzzfhsgdyegpe8ri3pbl3mw.jpeg"></a> <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">Allgemeine Bestimmungen</font> </h2><br>  In welcher Beziehung steht Java in Bezug auf die Leistung zu C oder C ++?  Wie vergleiche ich C # und Python?  Die Antworten auf diese Fragen h√§ngen stark von der Art der vom Forscher analysierten Anwendungen ab.  Es gibt keinen perfekten Benchmark, aber das Studium der Leistung von Programmen, die in verschiedenen Sprachen geschrieben wurden. Das Computersprachen-Benchmark-Spiel kann ein guter <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Ausgangspunkt sein</a> . <br><br>  Ich beziehe mich seit mehr als zehn Jahren auf das Computersprachen-Benchmark-Spiel.  Python ist im Vergleich zu anderen Sprachen wie Java, C #, Go, JavaScript, C ++ eine <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">der langsamsten</a> .  Dies umfasst Sprachen, die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">JIT-</a> Kompilierung (C #, Java) und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">AOT-</a> Kompilierung (C #, C ++) verwenden, sowie interpretierte Sprachen wie JavaScript. <br><br>  An dieser Stelle m√∂chte ich darauf hinweisen, dass ich mit ‚ÄûPython‚Äú die Referenzimplementierung des Python-Interpreters CPython meine.  In diesem Material werden wir auf die anderen Implementierungen eingehen.  Eigentlich m√∂chte ich hier die Antwort auf die Frage finden, warum Python 2-10 mal mehr Zeit ben√∂tigt als andere Sprachen, um vergleichbare Probleme zu l√∂sen, und ob es schneller geht. <br><br>  Hier sind einige grundlegende Theorien, die versuchen zu erkl√§ren, warum Python langsam ist: <br><br><ul><li>  Der Grund daf√ºr ist die GIL (Global Interpreter Lock, Global Interpreter Lock). </li><li>  Der Grund ist, dass Python eher eine interpretierte als eine kompilierte Sprache ist. </li><li>  Der Grund ist die dynamische Eingabe. </li></ul><br>  Wir werden diese Ideen analysieren und versuchen, die Antwort auf die Frage zu finden, was den gr√∂√üten Einfluss auf die Leistung von Python-Anwendungen hat. <br><br><h2>  <font color="#3AC1EF">Gil</font> </h2><br>  Moderne Computer verf√ºgen √ºber Mehrkernprozessoren, und manchmal werden Multiprozessorsysteme gefunden.  Um all diese Rechenleistung zu nutzen, verwendet das Betriebssystem Strukturen auf niedriger Ebene, die als Threads bezeichnet werden, w√§hrend Prozesse (z. B. der Chrome-Browserprozess) viele Threads starten und entsprechend verwenden k√∂nnen.  Wenn ein Prozess beispielsweise besonders dringend Prozessorressourcen ben√∂tigt, kann seine Ausf√ºhrung auf mehrere Kerne aufgeteilt werden, sodass die meisten Anwendungen die Aufgaben, denen sie gegen√ºberstehen, schneller l√∂sen k√∂nnen. <br><br>  Zum Beispiel hat mein Chrome-Browser zum Zeitpunkt des Schreibens 44 offene Threads.  Es ist zu beachten, dass die Struktur und API des Systems f√ºr die Arbeit mit Streams in Posix-basierten Betriebssystemen (Mac OS, Linux) und in der Windows-Betriebssystemfamilie unterschiedlich ist.  Das Betriebssystem plant auch Threads. <br><br>  Wenn Sie noch nie mit Multithread-Programmierung vertraut waren, m√ºssen Sie sich jetzt mit den sogenannten Locks (Locks) vertraut machen.  Sperren haben die Bedeutung, dass Sie ein solches Systemverhalten sicherstellen k√∂nnen, wenn in einer Umgebung mit mehreren Threads, z. B. wenn eine bestimmte Variable im Speicher ge√§ndert wird, mehrere Threads nicht auf denselben Speicherbereich zugreifen k√∂nnen (zum Lesen oder √Ñndern). <br><br>  Wenn der CPython-Interpreter die Variablen erstellt, weist er Speicher zu und z√§hlt dann die Anzahl der vorhandenen Verweise auf diese Variablen.  Dieses Konzept wird als Referenzz√§hlung bezeichnet.  Wenn die Anzahl der Verbindungen gleich Null ist, wird der entsprechende Speicherplatz freigegeben.  Aus diesem Grund f√ºhrt beispielsweise die Erstellung von "tempor√§ren" Variablen, beispielsweise im Rahmen von Schleifen, nicht zu einer √ºberm√§√üigen Erh√∂hung des von der Anwendung verbrauchten Arbeitsspeichers. <br><br>  Der interessanteste Teil beginnt, wenn mehrere Threads dieselben Variablen verwenden. Das Hauptproblem hierbei ist, wie genau CPython die Referenzz√§hlung durchf√ºhrt.  Hier wird die Aktion der "globalen Interpretersperre" angezeigt, die die Ausf√ºhrung von Threads sorgf√§ltig steuert. <br><br>  Ein Interpreter kann jeweils nur eine Operation ausf√ºhren, unabh√§ngig davon, wie viele Threads sich im Programm befinden. <br><br><h3>  <font color="#3AC1EF">‚ñçWie wirkt sich GIL auf die Leistung von Python-Anwendungen aus?</font> </h3><br>  Wenn eine Single-Threaded-Anwendung im selben Python-Interpreter-Prozess ausgef√ºhrt wird, wirkt sich die GIL in keiner Weise auf die Leistung aus.  Wenn Sie beispielsweise GIL loswerden, werden wir keinen Leistungsunterschied feststellen. <br><br>  Wenn im Rahmen eines Python-Interpreter-Prozesses eine parallele Datenverarbeitung mithilfe von Multithreading-Mechanismen implementiert werden muss und die verwendeten Streams das E / A-Subsystem intensiv nutzen (z. B. wenn sie mit einem Netzwerk oder einer Festplatte arbeiten), k√∂nnen die Folgen von beobachtet werden wie GIL Threads verwaltet.  So sieht es aus, wenn zwei Threads verwendet werden und Prozesse intensiv geladen werden. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f9e/379/f47/f9e379f4724ba48881f53b489ca5ed1d.png"></div><br>  <i><font color="#999999">GIL-Visualisierung ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">von hier aus</a> )</font></i> <br><br>  Wenn Sie eine Webanwendung haben (zum Beispiel basierend auf dem Django-Framework) und WSGI verwenden, wird jede Anforderung f√ºr die Webanwendung von einem separaten Python-Interpreter-Prozess bearbeitet, dh wir haben nur eine Anforderungssperre.  Da der Python-Interpreter langsam startet, gibt es in einigen WSGI-Implementierungen einen sogenannten "Daemon-Modus", bei dem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">die Interpreter-Prozesse</a> in einem funktionierenden Zustand gehalten werden, wodurch das System Anforderungen schneller <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">bearbeiten</a> kann. <br><br><h3>  <font color="#3AC1EF">‚ñçWie verhalten sich andere Python-Interpreter?</font> </h3><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">PyPy</a> hat eine GIL, es ist normalerweise mehr als dreimal schneller als CPython. <br><br>  In Jython gibt es keine GIL, da Python-Threads in Jython als Java-Threads dargestellt werden.  Solche Threads verwenden die Speicherverwaltungsfunktionen der JVM. <br><br><h3>  <font color="#3AC1EF">‚ñçWie ist die Flusskontrolle in JavaScript organisiert?</font> </h3><br>  Wenn wir √ºber JavaScript sprechen, sollte zun√§chst beachtet werden, dass alle JS-Engines den <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Mark-and-Sweep-</a> Garbage-Collection-Algorithmus verwenden.  Wie bereits erw√§hnt, ist der Hauptgrund f√ºr die Verwendung von GIL der in CPython verwendete Speicherverwaltungsalgorithmus. <br><br>  JavaScript hat keine GIL, JS ist jedoch eine Single-Threaded-Sprache und ben√∂tigt daher keinen solchen Mechanismus.  Anstelle der parallelen Codeausf√ºhrung verwendet JavaScript asynchrone Programmiertechniken, die auf einer Ereignisschleife, Versprechungen und R√ºckrufen basieren.  Python hat etwas √Ñhnliches vom <code>asyncio</code> Modul <code>asyncio</code> . <br><br><h2>  <font color="#3AC1EF">Python - interpretierte Sprache</font> </h2><br>  Ich habe oft geh√∂rt, dass die schlechte Leistung von Python auf die Tatsache zur√ºckzuf√ºhren ist, dass es sich um eine interpretierte Sprache handelt.  Solche Aussagen basieren auf einer groben Vereinfachung der tats√§chlichen Funktionsweise von CPython.  Wenn Sie im Terminal einen Befehl wie <code>python myscript.py</code> , beginnt CPython mit einer langen Abfolge von Aktionen, die aus Lesen, lexikalischer Analyse, Parsen, Kompilieren, Interpretieren und Ausf√ºhren von <code>python myscript.py</code> besteht.  Wenn Sie an den Details interessiert sind, schauen Sie sich <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">dieses</a> Material an. <br><br>  Wenn wir diesen Prozess betrachten, ist es f√ºr uns besonders wichtig, dass hier in der Kompilierungsphase eine <code>.pyc</code> Datei erstellt wird und eine Folge von Bytecodes in die Datei im <code>__pycache__/</code> , die sowohl in Python 3 als auch in Python verwendet wird 2. <br><br>  Dies gilt nicht nur f√ºr von uns geschriebene Skripte, sondern auch f√ºr importierten Code, einschlie√ülich Module von Drittanbietern. <br><br>  Infolgedessen f√ºhrt Python die meiste Zeit (es sei denn, Sie schreiben Code, der nur einmal ausgef√ºhrt wird) den fertigen Bytecode aus.  Vergleicht man dies mit den Vorg√§ngen in Java und C #, so stellt sich heraus, dass der Java-Code in die ‚ÄûIntermediate Language‚Äú kompiliert wird und die virtuelle Java-Maschine den Bytecode liest und ihre JIT-Kompilierung in Maschinencode durchf√ºhrt.  Die "Zwischensprache" .NET CIL (die mit der .NET Common-Language-Runtime, CLR identisch ist) verwendet die JIT-Kompilierung, um zum Maschinencode zu navigieren. <br><br>  Infolgedessen wird sowohl in Java als auch in C # eine ‚ÄûZwischensprache‚Äú verwendet, und √§hnliche Mechanismen sind vorhanden.  Warum zeigt Python dann viel schlechtere Benchmarks als Java und C #, wenn alle diese Sprachen virtuelle Maschinen und eine Art Bytecode verwenden?  Zun√§chst aufgrund der Tatsache, dass die JIT-Kompilierung in .NET und Java verwendet wird. <br><br>  Die JIT-Kompilierung (Just In Time-Kompilierung, On-the-Fly- oder Just-in-Time-Kompilierung) erfordert eine Zwischensprache, um die Aufteilung des Codes in Fragmente (Frames) zu erm√∂glichen.  AOT-Kompilierungssysteme (Ahead Of Time-Kompilierung, Kompilierung vor der Ausf√ºhrung) sind so konzipiert, dass die volle Funktionalit√§t des Codes sichergestellt ist, bevor die Interaktion dieses Codes mit dem System beginnt. <br><br>  Die Verwendung von JIT beschleunigt die Ausf√ºhrung des Codes nicht, da einige Fragmente des Bytecodes wie in Python ausgef√ºhrt werden.  Mit JIT k√∂nnen Sie jedoch w√§hrend der Ausf√ºhrung Codeoptimierungen durchf√ºhren.  Ein guter JIT-Optimierer kann die am meisten geladenen Teile der Anwendung identifizieren (dieser Teil der Anwendung wird als ‚ÄûHot Spot‚Äú bezeichnet) und die entsprechenden Codefragmente optimieren, indem er sie durch optimierte und produktivere Optionen als die zuvor verwendeten ersetzt. <br><br>  Dies bedeutet, dass eine solche Optimierung die Ausf√ºhrung solcher Aktionen erheblich beschleunigen kann, wenn eine bestimmte Anwendung bestimmte Aktionen immer wieder ausf√ºhrt.  Beachten Sie auch, dass Java und C # stark typisierte Sprachen sind, damit der Optimierer mehr Annahmen √ºber Code treffen kann, die zur Verbesserung der Programmleistung beitragen k√∂nnen. <br><br>  In PyPy gibt es einen JIT-Compiler, und wie bereits erw√§hnt, ist diese Python-Interpreter-Implementierung viel schneller als CPython.  Informationen zum Vergleichen verschiedener Python-Interpreter finden Sie in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">diesem</a> Artikel. <br><br><h3>  <font color="#3AC1EF">‚ñç Warum verwendet CPython keinen JIT-Compiler?</font> </h3><br>  JIT-Compiler haben auch Nachteile.  Eine davon ist die Startzeit.  CPython startet bereits relativ langsam und PyPy ist 2-3 mal langsamer als CPython.  Die lange Laufzeit der JVM ist ebenfalls bekannt.  CLR .NET umgeht dieses Problem, indem es w√§hrend des Systemstarts gestartet wird. Es ist jedoch zu beachten, dass sowohl die CLR als auch das Betriebssystem, auf dem die CLR ausgef√ºhrt wird, von derselben Firma entwickelt wurden. <br><br>  Wenn Sie einen Python-Prozess haben, der schon lange ausgef√ºhrt wird, w√§hrend in einem solchen Prozess Code optimiert werden kann, da er h√§ufig verwendete Abschnitte enth√§lt, sollten Sie sich ernsthaft einen Interpreter mit einem JIT-Compiler ansehen. <br><br>  CPython ist jedoch eine Implementierung des Allzweck-Python-Interpreters.  Wenn Sie also mit Python eine Befehlszeilenanwendung entwickeln, wird die Arbeit erheblich verlangsamt, wenn der JIT-Compiler bei jedem Start dieser Anwendung lange warten muss. <br><br>  CPython versucht, so viele Python-Anwendungsf√§lle wie m√∂glich zu unterst√ºtzen.  Beispielsweise besteht die M√∂glichkeit, den JIT-Compiler mit Python zu verbinden. Das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Projekt</a> , das diese Idee umsetzt, entwickelt sich jedoch nicht sehr aktiv. <br><br>  Daher k√∂nnen wir sagen, dass Sie den PyPy-Interpreter verwenden, wenn Sie Python zum Schreiben eines Programms verwenden, dessen Leistung sich bei Verwendung des JIT-Compilers verbessern kann. <br><br><h2>  <font color="#3AC1EF">Python ist eine dynamisch typisierte Sprache</font> </h2><br>  In statisch typisierten Sprachen m√ºssen Sie beim Deklarieren von Variablen deren Typen angeben.  Unter diesen Sprachen k√∂nnen C, C ++, Java, C #, Go notiert werden. <br><br>  In dynamisch typisierten Sprachen hat das Konzept eines Datentyps dieselbe Bedeutung, aber der Typ einer Variablen ist dynamisch. <br><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">a</span></span> = <span class="hljs-number"><span class="hljs-number">1</span></span> a = <span class="hljs-string"><span class="hljs-string">"foo"</span></span></code> </pre> <br>  In diesem einfachsten Beispiel erstellt Python zuerst die erste Variable <code>a</code> , dann die zweite mit demselben Namen vom Typ <code>str</code> und gibt den Speicher frei, der der ersten Variablen <code>a</code> zugewiesen wurde. <br><br>  Es mag den Anschein haben, dass das Schreiben in Sprachen mit dynamischer Typisierung bequemer und einfacher ist als in Sprachen mit statischer Typisierung. Solche Sprachen wurden jedoch nicht aus einer Laune heraus erstellt.  Bei ihrer Entwicklung wurden die Merkmale von Computersystemen ber√ºcksichtigt.  Alles, was am Ende im Programmtext geschrieben steht, h√§ngt von den Anweisungen des Prozessors ab.  Dies bedeutet, dass die vom Programm verwendeten Daten, beispielsweise in Form von Objekten oder anderen Datentypen, auch in Strukturen auf niedriger Ebene konvertiert werden. <br><br>  Python f√ºhrt solche Transformationen automatisch durch, der Programmierer sieht diese Prozesse nicht und muss sich nicht um solche Transformationen k√ºmmern. <br><br>  Wenn Sie den Typ einer Variablen nicht angeben m√ºssen, wenn Sie sie deklarieren, ist dies keine Funktion der Sprache, die Python langsam macht.  Die Spracharchitektur erm√∂glicht es, fast alles dynamisch zu machen.  Zur Laufzeit k√∂nnen Sie beispielsweise Objektmethoden ersetzen.  Auch hier k√∂nnen Sie w√§hrend der Ausf√ºhrung des Programms die "Monkey Patch" -Technik verwenden, die auf Systemaufrufe auf niedriger Ebene angewendet wird.  In Python ist fast alles m√∂glich. <br><br>  Es ist die Python-Architektur, die die Optimierung extrem schwierig macht. <br><br>  Um diese Idee zu veranschaulichen, werde ich ein Tool zum Verfolgen von Systemaufrufen unter MacOS namens DTrace verwenden. <br><br>  In der fertigen CPython-Distribution gibt es keine DTrace-Unterst√ºtzungsmechanismen, daher muss CPython mit den entsprechenden Einstellungen neu kompiliert werden.  Hier wird Version 3.6.6 verwendet.  Wir verwenden also die folgende Abfolge von Aktionen: <br><br><pre> <code class="hljs ruby">wget <span class="hljs-symbol"><span class="hljs-symbol">https:</span></span>/<span class="hljs-regexp"><span class="hljs-regexp">/github.com/python</span></span><span class="hljs-regexp"><span class="hljs-regexp">/cpython/archive</span></span><span class="hljs-regexp"><span class="hljs-regexp">/v3.6.6.zip unzip v3.6.6.zip cd v3.6.6 ./configure</span></span> --with-dtrace make</code> </pre> <br>  Mit <code>python.exe</code> k√∂nnen Sie jetzt DTRace verwenden, um den Code zu verfolgen.  Lesen Sie hier, wie Sie DTrace mit Python verwenden.  Und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> finden Sie Skripte zum Messen verschiedener Leistungsindikatoren von Python-Programmen mit DTrace.  Darunter befinden sich Parameter zum Aufrufen von Funktionen, zur Laufzeit von Programmen, zur Zeit der Prozessorauslastung, zu Informationen √ºber Systemaufrufe usw.  So verwenden Sie den Befehl <code>dtrace</code> : <br><br><pre> <code class="hljs powershell">sudo dtrace <span class="hljs-literal"><span class="hljs-literal">-s</span></span> toolkit/&lt;tracer&gt;.d <span class="hljs-literal"><span class="hljs-literal">-c</span></span> <span class="hljs-string"><span class="hljs-string">'../cpython/python.exe script.py'</span></span></code> </pre> <br>  Und so zeigt die Trace-Funktion <code>py_callflow</code> Funktionsaufrufe in der Anwendung an. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/13e/bd4/926/13ebd492636a94b23400305293aec346.gif"></div><br>  <i><font color="#999999">Ablaufverfolgung mit DTrace</font></i> <br><br>  Beantworten wir nun die Frage, ob sich die dynamische Eingabe auf die Python-Leistung auswirkt.  Hier einige Gedanken dazu: <br><br><ul><li>  Typpr√ºfung und Konvertierung sind schwere Vorg√§nge.  Jedes Mal, wenn auf eine Variable zugegriffen, diese gelesen oder geschrieben wird, wird eine Typpr√ºfung durchgef√ºhrt. </li><li>  Eine Sprache mit einer solchen Flexibilit√§t ist schwer zu optimieren.  Der Grund daf√ºr, dass andere Sprachen so viel schneller als Python sind, besteht darin, dass sie Kompromisse eingehen, indem sie zwischen Flexibilit√§t und Leistung w√§hlen. </li><li>  Das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Cython-</a> Projekt kombiniert Python und statische Typisierung, was beispielsweise, wie in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">diesem Artikel gezeigt</a> , zu einer 84-fachen Leistungsverbesserung gegen√ºber regul√§rem Python f√ºhrt.  Schauen Sie sich dieses Projekt an, wenn Sie Geschwindigkeit ben√∂tigen. </li></ul><br><h2>  <font color="#3AC1EF">Zusammenfassung</font> </h2><br>  Der Grund f√ºr die schlechte Leistung von Python ist seine Dynamik und Vielseitigkeit.  Es kann als Werkzeug zur L√∂sung einer Vielzahl von Aufgaben verwendet werden.  Um die gleichen Ziele zu erreichen, k√∂nnen Sie versuchen, nach produktiveren und besser optimierten Tools zu suchen.  Vielleicht k√∂nnen sie finden, vielleicht auch nicht. <br><br>  In Python geschriebene Anwendungen k√∂nnen mithilfe der Funktionen der asynchronen Codeausf√ºhrung, der Profilerstellungstools und der Auswahl des richtigen Interpreters optimiert werden.  Um die Geschwindigkeit von Anwendungen zu optimieren, deren Startzeit unwichtig ist und deren Leistung von der Verwendung des JIT-Compilers profitieren kann, sollten Sie PyPy verwenden.  Wenn Sie maximale Leistung ben√∂tigen und auf die Einschr√§nkungen der statischen Typisierung vorbereitet sind, schauen Sie sich Cython an. <br><br>  <b>Liebe Leser!</b>  Wie l√∂sen Sie schlechte Python-Leistungsprobleme? <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de418823/">https://habr.com/ru/post/de418823/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de418813/index.html">√úberraschung: Hubbles Konstante ist tats√§chlich launisch</a></li>
<li><a href="../de418815/index.html">Typische Fehler, die ein Entwickler w√§hrend des Trainings macht - und wie man sie vermeidet</a></li>
<li><a href="../de418817/index.html">Progressive Offenlegung in Mobile UX: wie es funktioniert</a></li>
<li><a href="../de418819/index.html">Ultrakalte Substanz an Bord der ISS</a></li>
<li><a href="../de418821/index.html">Neue Angular 6.1-Funktionen</a></li>
<li><a href="../de418825/index.html">Methoden und Werkzeuge zur Entwicklung von Webseitenstilen</a></li>
<li><a href="../de418827/index.html">Tonaufnahmen von 19.000 Stunden Vortr√§gen, die w√§hrend der Apollo 11-Mondexpedition ver√∂ffentlicht wurden</a></li>
<li><a href="../de418829/index.html">Als einzige Zeile alten Codes f√ºr sechs Monate haben die MMORPG-Entwickler verr√ºckt gemacht</a></li>
<li><a href="../de418833/index.html">Nodejs und IoT: aufeinander abgestimmt</a></li>
<li><a href="../de418835/index.html">Wie haben wir das erste russische Smartphone gemacht?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>