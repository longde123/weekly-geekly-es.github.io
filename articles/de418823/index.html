<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👐🏽 🌟 👨🏽‍💻 Python ist langsam. Warum? 🤘🏾 🤺 👩🏿‍🎓</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In letzter Zeit kann man die wachsende Popularität der Programmiersprache Python beobachten. Es wird in DevOps, in der Datenanalyse, in der Webentwick...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Python ist langsam. Warum?</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/418823/">  In letzter Zeit kann man die wachsende Popularität der Programmiersprache Python beobachten.  Es wird in DevOps, in der Datenanalyse, in der Webentwicklung, im Sicherheitsbereich und in anderen Bereichen verwendet.  Aber hier ist die Geschwindigkeit ... Von dieser Sprache gibt es hier nichts zu rühmen.  Der Autor des Materials, dessen Übersetzung wir heute veröffentlichen, hat beschlossen, die Gründe für die Langsamkeit von Python herauszufinden und Mittel zu finden, um es zu beschleunigen. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/webt/tv/zp/uz/tvzpuzzfhsgdyegpe8ri3pbl3mw.jpeg"></a> <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">Allgemeine Bestimmungen</font> </h2><br>  In welcher Beziehung steht Java in Bezug auf die Leistung zu C oder C ++?  Wie vergleiche ich C # und Python?  Die Antworten auf diese Fragen hängen stark von der Art der vom Forscher analysierten Anwendungen ab.  Es gibt keinen perfekten Benchmark, aber das Studium der Leistung von Programmen, die in verschiedenen Sprachen geschrieben wurden. Das Computersprachen-Benchmark-Spiel kann ein guter <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Ausgangspunkt sein</a> . <br><br>  Ich beziehe mich seit mehr als zehn Jahren auf das Computersprachen-Benchmark-Spiel.  Python ist im Vergleich zu anderen Sprachen wie Java, C #, Go, JavaScript, C ++ eine <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">der langsamsten</a> .  Dies umfasst Sprachen, die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">JIT-</a> Kompilierung (C #, Java) und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">AOT-</a> Kompilierung (C #, C ++) verwenden, sowie interpretierte Sprachen wie JavaScript. <br><br>  An dieser Stelle möchte ich darauf hinweisen, dass ich mit „Python“ die Referenzimplementierung des Python-Interpreters CPython meine.  In diesem Material werden wir auf die anderen Implementierungen eingehen.  Eigentlich möchte ich hier die Antwort auf die Frage finden, warum Python 2-10 mal mehr Zeit benötigt als andere Sprachen, um vergleichbare Probleme zu lösen, und ob es schneller geht. <br><br>  Hier sind einige grundlegende Theorien, die versuchen zu erklären, warum Python langsam ist: <br><br><ul><li>  Der Grund dafür ist die GIL (Global Interpreter Lock, Global Interpreter Lock). </li><li>  Der Grund ist, dass Python eher eine interpretierte als eine kompilierte Sprache ist. </li><li>  Der Grund ist die dynamische Eingabe. </li></ul><br>  Wir werden diese Ideen analysieren und versuchen, die Antwort auf die Frage zu finden, was den größten Einfluss auf die Leistung von Python-Anwendungen hat. <br><br><h2>  <font color="#3AC1EF">Gil</font> </h2><br>  Moderne Computer verfügen über Mehrkernprozessoren, und manchmal werden Multiprozessorsysteme gefunden.  Um all diese Rechenleistung zu nutzen, verwendet das Betriebssystem Strukturen auf niedriger Ebene, die als Threads bezeichnet werden, während Prozesse (z. B. der Chrome-Browserprozess) viele Threads starten und entsprechend verwenden können.  Wenn ein Prozess beispielsweise besonders dringend Prozessorressourcen benötigt, kann seine Ausführung auf mehrere Kerne aufgeteilt werden, sodass die meisten Anwendungen die Aufgaben, denen sie gegenüberstehen, schneller lösen können. <br><br>  Zum Beispiel hat mein Chrome-Browser zum Zeitpunkt des Schreibens 44 offene Threads.  Es ist zu beachten, dass die Struktur und API des Systems für die Arbeit mit Streams in Posix-basierten Betriebssystemen (Mac OS, Linux) und in der Windows-Betriebssystemfamilie unterschiedlich ist.  Das Betriebssystem plant auch Threads. <br><br>  Wenn Sie noch nie mit Multithread-Programmierung vertraut waren, müssen Sie sich jetzt mit den sogenannten Locks (Locks) vertraut machen.  Sperren haben die Bedeutung, dass Sie ein solches Systemverhalten sicherstellen können, wenn in einer Umgebung mit mehreren Threads, z. B. wenn eine bestimmte Variable im Speicher geändert wird, mehrere Threads nicht auf denselben Speicherbereich zugreifen können (zum Lesen oder Ändern). <br><br>  Wenn der CPython-Interpreter die Variablen erstellt, weist er Speicher zu und zählt dann die Anzahl der vorhandenen Verweise auf diese Variablen.  Dieses Konzept wird als Referenzzählung bezeichnet.  Wenn die Anzahl der Verbindungen gleich Null ist, wird der entsprechende Speicherplatz freigegeben.  Aus diesem Grund führt beispielsweise die Erstellung von "temporären" Variablen, beispielsweise im Rahmen von Schleifen, nicht zu einer übermäßigen Erhöhung des von der Anwendung verbrauchten Arbeitsspeichers. <br><br>  Der interessanteste Teil beginnt, wenn mehrere Threads dieselben Variablen verwenden. Das Hauptproblem hierbei ist, wie genau CPython die Referenzzählung durchführt.  Hier wird die Aktion der "globalen Interpretersperre" angezeigt, die die Ausführung von Threads sorgfältig steuert. <br><br>  Ein Interpreter kann jeweils nur eine Operation ausführen, unabhängig davon, wie viele Threads sich im Programm befinden. <br><br><h3>  <font color="#3AC1EF">▍Wie wirkt sich GIL auf die Leistung von Python-Anwendungen aus?</font> </h3><br>  Wenn eine Single-Threaded-Anwendung im selben Python-Interpreter-Prozess ausgeführt wird, wirkt sich die GIL in keiner Weise auf die Leistung aus.  Wenn Sie beispielsweise GIL loswerden, werden wir keinen Leistungsunterschied feststellen. <br><br>  Wenn im Rahmen eines Python-Interpreter-Prozesses eine parallele Datenverarbeitung mithilfe von Multithreading-Mechanismen implementiert werden muss und die verwendeten Streams das E / A-Subsystem intensiv nutzen (z. B. wenn sie mit einem Netzwerk oder einer Festplatte arbeiten), können die Folgen von beobachtet werden wie GIL Threads verwaltet.  So sieht es aus, wenn zwei Threads verwendet werden und Prozesse intensiv geladen werden. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f9e/379/f47/f9e379f4724ba48881f53b489ca5ed1d.png"></div><br>  <i><font color="#999999">GIL-Visualisierung ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">von hier aus</a> )</font></i> <br><br>  Wenn Sie eine Webanwendung haben (zum Beispiel basierend auf dem Django-Framework) und WSGI verwenden, wird jede Anforderung für die Webanwendung von einem separaten Python-Interpreter-Prozess bearbeitet, dh wir haben nur eine Anforderungssperre.  Da der Python-Interpreter langsam startet, gibt es in einigen WSGI-Implementierungen einen sogenannten "Daemon-Modus", bei dem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">die Interpreter-Prozesse</a> in einem funktionierenden Zustand gehalten werden, wodurch das System Anforderungen schneller <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">bearbeiten</a> kann. <br><br><h3>  <font color="#3AC1EF">▍Wie verhalten sich andere Python-Interpreter?</font> </h3><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">PyPy</a> hat eine GIL, es ist normalerweise mehr als dreimal schneller als CPython. <br><br>  In Jython gibt es keine GIL, da Python-Threads in Jython als Java-Threads dargestellt werden.  Solche Threads verwenden die Speicherverwaltungsfunktionen der JVM. <br><br><h3>  <font color="#3AC1EF">▍Wie ist die Flusskontrolle in JavaScript organisiert?</font> </h3><br>  Wenn wir über JavaScript sprechen, sollte zunächst beachtet werden, dass alle JS-Engines den <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Mark-and-Sweep-</a> Garbage-Collection-Algorithmus verwenden.  Wie bereits erwähnt, ist der Hauptgrund für die Verwendung von GIL der in CPython verwendete Speicherverwaltungsalgorithmus. <br><br>  JavaScript hat keine GIL, JS ist jedoch eine Single-Threaded-Sprache und benötigt daher keinen solchen Mechanismus.  Anstelle der parallelen Codeausführung verwendet JavaScript asynchrone Programmiertechniken, die auf einer Ereignisschleife, Versprechungen und Rückrufen basieren.  Python hat etwas Ähnliches vom <code>asyncio</code> Modul <code>asyncio</code> . <br><br><h2>  <font color="#3AC1EF">Python - interpretierte Sprache</font> </h2><br>  Ich habe oft gehört, dass die schlechte Leistung von Python auf die Tatsache zurückzuführen ist, dass es sich um eine interpretierte Sprache handelt.  Solche Aussagen basieren auf einer groben Vereinfachung der tatsächlichen Funktionsweise von CPython.  Wenn Sie im Terminal einen Befehl wie <code>python myscript.py</code> , beginnt CPython mit einer langen Abfolge von Aktionen, die aus Lesen, lexikalischer Analyse, Parsen, Kompilieren, Interpretieren und Ausführen von <code>python myscript.py</code> besteht.  Wenn Sie an den Details interessiert sind, schauen Sie sich <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">dieses</a> Material an. <br><br>  Wenn wir diesen Prozess betrachten, ist es für uns besonders wichtig, dass hier in der Kompilierungsphase eine <code>.pyc</code> Datei erstellt wird und eine Folge von Bytecodes in die Datei im <code>__pycache__/</code> , die sowohl in Python 3 als auch in Python verwendet wird 2. <br><br>  Dies gilt nicht nur für von uns geschriebene Skripte, sondern auch für importierten Code, einschließlich Module von Drittanbietern. <br><br>  Infolgedessen führt Python die meiste Zeit (es sei denn, Sie schreiben Code, der nur einmal ausgeführt wird) den fertigen Bytecode aus.  Vergleicht man dies mit den Vorgängen in Java und C #, so stellt sich heraus, dass der Java-Code in die „Intermediate Language“ kompiliert wird und die virtuelle Java-Maschine den Bytecode liest und ihre JIT-Kompilierung in Maschinencode durchführt.  Die "Zwischensprache" .NET CIL (die mit der .NET Common-Language-Runtime, CLR identisch ist) verwendet die JIT-Kompilierung, um zum Maschinencode zu navigieren. <br><br>  Infolgedessen wird sowohl in Java als auch in C # eine „Zwischensprache“ verwendet, und ähnliche Mechanismen sind vorhanden.  Warum zeigt Python dann viel schlechtere Benchmarks als Java und C #, wenn alle diese Sprachen virtuelle Maschinen und eine Art Bytecode verwenden?  Zunächst aufgrund der Tatsache, dass die JIT-Kompilierung in .NET und Java verwendet wird. <br><br>  Die JIT-Kompilierung (Just In Time-Kompilierung, On-the-Fly- oder Just-in-Time-Kompilierung) erfordert eine Zwischensprache, um die Aufteilung des Codes in Fragmente (Frames) zu ermöglichen.  AOT-Kompilierungssysteme (Ahead Of Time-Kompilierung, Kompilierung vor der Ausführung) sind so konzipiert, dass die volle Funktionalität des Codes sichergestellt ist, bevor die Interaktion dieses Codes mit dem System beginnt. <br><br>  Die Verwendung von JIT beschleunigt die Ausführung des Codes nicht, da einige Fragmente des Bytecodes wie in Python ausgeführt werden.  Mit JIT können Sie jedoch während der Ausführung Codeoptimierungen durchführen.  Ein guter JIT-Optimierer kann die am meisten geladenen Teile der Anwendung identifizieren (dieser Teil der Anwendung wird als „Hot Spot“ bezeichnet) und die entsprechenden Codefragmente optimieren, indem er sie durch optimierte und produktivere Optionen als die zuvor verwendeten ersetzt. <br><br>  Dies bedeutet, dass eine solche Optimierung die Ausführung solcher Aktionen erheblich beschleunigen kann, wenn eine bestimmte Anwendung bestimmte Aktionen immer wieder ausführt.  Beachten Sie auch, dass Java und C # stark typisierte Sprachen sind, damit der Optimierer mehr Annahmen über Code treffen kann, die zur Verbesserung der Programmleistung beitragen können. <br><br>  In PyPy gibt es einen JIT-Compiler, und wie bereits erwähnt, ist diese Python-Interpreter-Implementierung viel schneller als CPython.  Informationen zum Vergleichen verschiedener Python-Interpreter finden Sie in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">diesem</a> Artikel. <br><br><h3>  <font color="#3AC1EF">▍ Warum verwendet CPython keinen JIT-Compiler?</font> </h3><br>  JIT-Compiler haben auch Nachteile.  Eine davon ist die Startzeit.  CPython startet bereits relativ langsam und PyPy ist 2-3 mal langsamer als CPython.  Die lange Laufzeit der JVM ist ebenfalls bekannt.  CLR .NET umgeht dieses Problem, indem es während des Systemstarts gestartet wird. Es ist jedoch zu beachten, dass sowohl die CLR als auch das Betriebssystem, auf dem die CLR ausgeführt wird, von derselben Firma entwickelt wurden. <br><br>  Wenn Sie einen Python-Prozess haben, der schon lange ausgeführt wird, während in einem solchen Prozess Code optimiert werden kann, da er häufig verwendete Abschnitte enthält, sollten Sie sich ernsthaft einen Interpreter mit einem JIT-Compiler ansehen. <br><br>  CPython ist jedoch eine Implementierung des Allzweck-Python-Interpreters.  Wenn Sie also mit Python eine Befehlszeilenanwendung entwickeln, wird die Arbeit erheblich verlangsamt, wenn der JIT-Compiler bei jedem Start dieser Anwendung lange warten muss. <br><br>  CPython versucht, so viele Python-Anwendungsfälle wie möglich zu unterstützen.  Beispielsweise besteht die Möglichkeit, den JIT-Compiler mit Python zu verbinden. Das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Projekt</a> , das diese Idee umsetzt, entwickelt sich jedoch nicht sehr aktiv. <br><br>  Daher können wir sagen, dass Sie den PyPy-Interpreter verwenden, wenn Sie Python zum Schreiben eines Programms verwenden, dessen Leistung sich bei Verwendung des JIT-Compilers verbessern kann. <br><br><h2>  <font color="#3AC1EF">Python ist eine dynamisch typisierte Sprache</font> </h2><br>  In statisch typisierten Sprachen müssen Sie beim Deklarieren von Variablen deren Typen angeben.  Unter diesen Sprachen können C, C ++, Java, C #, Go notiert werden. <br><br>  In dynamisch typisierten Sprachen hat das Konzept eines Datentyps dieselbe Bedeutung, aber der Typ einer Variablen ist dynamisch. <br><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">a</span></span> = <span class="hljs-number"><span class="hljs-number">1</span></span> a = <span class="hljs-string"><span class="hljs-string">"foo"</span></span></code> </pre> <br>  In diesem einfachsten Beispiel erstellt Python zuerst die erste Variable <code>a</code> , dann die zweite mit demselben Namen vom Typ <code>str</code> und gibt den Speicher frei, der der ersten Variablen <code>a</code> zugewiesen wurde. <br><br>  Es mag den Anschein haben, dass das Schreiben in Sprachen mit dynamischer Typisierung bequemer und einfacher ist als in Sprachen mit statischer Typisierung. Solche Sprachen wurden jedoch nicht aus einer Laune heraus erstellt.  Bei ihrer Entwicklung wurden die Merkmale von Computersystemen berücksichtigt.  Alles, was am Ende im Programmtext geschrieben steht, hängt von den Anweisungen des Prozessors ab.  Dies bedeutet, dass die vom Programm verwendeten Daten, beispielsweise in Form von Objekten oder anderen Datentypen, auch in Strukturen auf niedriger Ebene konvertiert werden. <br><br>  Python führt solche Transformationen automatisch durch, der Programmierer sieht diese Prozesse nicht und muss sich nicht um solche Transformationen kümmern. <br><br>  Wenn Sie den Typ einer Variablen nicht angeben müssen, wenn Sie sie deklarieren, ist dies keine Funktion der Sprache, die Python langsam macht.  Die Spracharchitektur ermöglicht es, fast alles dynamisch zu machen.  Zur Laufzeit können Sie beispielsweise Objektmethoden ersetzen.  Auch hier können Sie während der Ausführung des Programms die "Monkey Patch" -Technik verwenden, die auf Systemaufrufe auf niedriger Ebene angewendet wird.  In Python ist fast alles möglich. <br><br>  Es ist die Python-Architektur, die die Optimierung extrem schwierig macht. <br><br>  Um diese Idee zu veranschaulichen, werde ich ein Tool zum Verfolgen von Systemaufrufen unter MacOS namens DTrace verwenden. <br><br>  In der fertigen CPython-Distribution gibt es keine DTrace-Unterstützungsmechanismen, daher muss CPython mit den entsprechenden Einstellungen neu kompiliert werden.  Hier wird Version 3.6.6 verwendet.  Wir verwenden also die folgende Abfolge von Aktionen: <br><br><pre> <code class="hljs ruby">wget <span class="hljs-symbol"><span class="hljs-symbol">https:</span></span>/<span class="hljs-regexp"><span class="hljs-regexp">/github.com/python</span></span><span class="hljs-regexp"><span class="hljs-regexp">/cpython/archive</span></span><span class="hljs-regexp"><span class="hljs-regexp">/v3.6.6.zip unzip v3.6.6.zip cd v3.6.6 ./configure</span></span> --with-dtrace make</code> </pre> <br>  Mit <code>python.exe</code> können Sie jetzt DTRace verwenden, um den Code zu verfolgen.  Lesen Sie hier, wie Sie DTrace mit Python verwenden.  Und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> finden Sie Skripte zum Messen verschiedener Leistungsindikatoren von Python-Programmen mit DTrace.  Darunter befinden sich Parameter zum Aufrufen von Funktionen, zur Laufzeit von Programmen, zur Zeit der Prozessorauslastung, zu Informationen über Systemaufrufe usw.  So verwenden Sie den Befehl <code>dtrace</code> : <br><br><pre> <code class="hljs powershell">sudo dtrace <span class="hljs-literal"><span class="hljs-literal">-s</span></span> toolkit/&lt;tracer&gt;.d <span class="hljs-literal"><span class="hljs-literal">-c</span></span> <span class="hljs-string"><span class="hljs-string">'../cpython/python.exe script.py'</span></span></code> </pre> <br>  Und so zeigt die Trace-Funktion <code>py_callflow</code> Funktionsaufrufe in der Anwendung an. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/13e/bd4/926/13ebd492636a94b23400305293aec346.gif"></div><br>  <i><font color="#999999">Ablaufverfolgung mit DTrace</font></i> <br><br>  Beantworten wir nun die Frage, ob sich die dynamische Eingabe auf die Python-Leistung auswirkt.  Hier einige Gedanken dazu: <br><br><ul><li>  Typprüfung und Konvertierung sind schwere Vorgänge.  Jedes Mal, wenn auf eine Variable zugegriffen, diese gelesen oder geschrieben wird, wird eine Typprüfung durchgeführt. </li><li>  Eine Sprache mit einer solchen Flexibilität ist schwer zu optimieren.  Der Grund dafür, dass andere Sprachen so viel schneller als Python sind, besteht darin, dass sie Kompromisse eingehen, indem sie zwischen Flexibilität und Leistung wählen. </li><li>  Das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Cython-</a> Projekt kombiniert Python und statische Typisierung, was beispielsweise, wie in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">diesem Artikel gezeigt</a> , zu einer 84-fachen Leistungsverbesserung gegenüber regulärem Python führt.  Schauen Sie sich dieses Projekt an, wenn Sie Geschwindigkeit benötigen. </li></ul><br><h2>  <font color="#3AC1EF">Zusammenfassung</font> </h2><br>  Der Grund für die schlechte Leistung von Python ist seine Dynamik und Vielseitigkeit.  Es kann als Werkzeug zur Lösung einer Vielzahl von Aufgaben verwendet werden.  Um die gleichen Ziele zu erreichen, können Sie versuchen, nach produktiveren und besser optimierten Tools zu suchen.  Vielleicht können sie finden, vielleicht auch nicht. <br><br>  In Python geschriebene Anwendungen können mithilfe der Funktionen der asynchronen Codeausführung, der Profilerstellungstools und der Auswahl des richtigen Interpreters optimiert werden.  Um die Geschwindigkeit von Anwendungen zu optimieren, deren Startzeit unwichtig ist und deren Leistung von der Verwendung des JIT-Compilers profitieren kann, sollten Sie PyPy verwenden.  Wenn Sie maximale Leistung benötigen und auf die Einschränkungen der statischen Typisierung vorbereitet sind, schauen Sie sich Cython an. <br><br>  <b>Liebe Leser!</b>  Wie lösen Sie schlechte Python-Leistungsprobleme? <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de418823/">https://habr.com/ru/post/de418823/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de418813/index.html">Überraschung: Hubbles Konstante ist tatsächlich launisch</a></li>
<li><a href="../de418815/index.html">Typische Fehler, die ein Entwickler während des Trainings macht - und wie man sie vermeidet</a></li>
<li><a href="../de418817/index.html">Progressive Offenlegung in Mobile UX: wie es funktioniert</a></li>
<li><a href="../de418819/index.html">Ultrakalte Substanz an Bord der ISS</a></li>
<li><a href="../de418821/index.html">Neue Angular 6.1-Funktionen</a></li>
<li><a href="../de418825/index.html">Methoden und Werkzeuge zur Entwicklung von Webseitenstilen</a></li>
<li><a href="../de418827/index.html">Tonaufnahmen von 19.000 Stunden Vorträgen, die während der Apollo 11-Mondexpedition veröffentlicht wurden</a></li>
<li><a href="../de418829/index.html">Als einzige Zeile alten Codes für sechs Monate haben die MMORPG-Entwickler verrückt gemacht</a></li>
<li><a href="../de418833/index.html">Nodejs und IoT: aufeinander abgestimmt</a></li>
<li><a href="../de418835/index.html">Wie haben wir das erste russische Smartphone gemacht?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>