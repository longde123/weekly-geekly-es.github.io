<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤸🏿 ⛲️ 🧚🏾 File deskriptor Linux dengan contoh 🚋 🐹 🛑</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Suatu kali, dalam sebuah wawancara, mereka bertanya kepada saya apa yang akan Anda lakukan jika Anda menemukan layanan yang tidak berfungsi karena dis...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>File deskriptor Linux dengan contoh</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/471038/"> Suatu kali, dalam sebuah wawancara, mereka bertanya kepada saya apa yang akan Anda lakukan jika Anda menemukan layanan yang tidak berfungsi karena disk sudah kehabisan ruang? <br><br>  Tentu saja, saya menjawab bahwa saya akan melihat apa yang ditempati tempat ini dan, jika mungkin, saya akan membersihkan tempat itu. <br>  Kemudian pewawancara bertanya, bagaimana jika tidak ada ruang kosong di bagian itu, tetapi Anda juga tidak melihat file yang akan menempati seluruh tempat? <br><br>  Untuk ini, saya mengatakan bahwa Anda selalu dapat melihat deskriptor file terbuka, misalnya dengan perintah lsof dan memahami aplikasi mana yang mengambil semua ruang yang tersedia, dan kemudian Anda dapat melanjutkan sesuai dengan keadaan, tergantung pada apakah data diperlukan. <br><br>  Pewawancara menyela saya di kata terakhir, menambahkan pertanyaan saya: "Misalkan kita tidak membutuhkan data, itu hanya log debug, tetapi aplikasi tidak bekerja karena tidak dapat merekam debug"? <br><br>  "Oke," jawab saya, "kita bisa mematikan debug di konfigurasi aplikasi dan memulai kembali." <br>  Pewawancara keberatan: "Tidak, kami tidak dapat memulai ulang aplikasi, data penting masih tersimpan dalam memori kami, dan klien penting terhubung ke layanan itu sendiri, yang kami tidak dapat memaksa untuk menyambung kembali". <br><br>  "Ya," kataku, "jika kita tidak bisa memulai ulang aplikasi dan datanya tidak penting bagi kita, maka kita bisa menghapus file terbuka ini melalui deskriptor file, bahkan jika kita tidak melihatnya dalam perintah ls pada sistem file." <br><br>  Pewawancara merasa senang, tetapi saya tidak. <br><br>  Lalu saya berpikir, mengapa orang yang menguji pengetahuan saya tidak menggali lebih dalam?  Tetapi bagaimana jika datanya masih penting?  Bagaimana jika kita tidak dapat memulai ulang proses, dan pada saat yang sama proses ini menulis ke sistem file di bagian di mana tidak ada ruang kosong?  Bagaimana jika kita tidak bisa kehilangan tidak hanya data yang sudah direkam, tetapi juga data yang ditulis atau coba direkam oleh proses ini? <br><a name="habracut"></a><br><h3>  Tuzik </h3><br>  Di awal karir saya, saya mencoba membuat aplikasi kecil yang di dalamnya diperlukan untuk menyimpan informasi tentang pengguna.  Dan kemudian saya berpikir, bagaimana saya bisa memetakan pengguna ke datanya.  Sebagai contoh, saya memiliki Ivan Ivanov Ivanich, dan dia memiliki beberapa data, tetapi bagaimana cara berteman dengan mereka?  Saya dapat langsung menunjukkan bahwa anjing bernama "Tuzik" milik Ivan ini.  Tetapi bagaimana jika dia mengubah namanya dan bukannya Ivan menjadi, misalnya, Olya?  Kemudian ternyata bahwa Olya Ivanovna Ivanova kita tidak akan lagi memiliki anjing, dan Tuzik kita akan tetap milik Ivan yang tidak ada.  Basis data ini dibantu oleh basis data yang memberi setiap pengguna pengidentifikasi unik (ID), dan Tuzik saya dilampirkan pada ID ini, yang, pada kenyataannya, hanyalah nomor urut.  Jadi, pemilik tuzik dengan ID nomor 2, dan pada suatu waktu Ivan berada di bawah ID ini, dan kemudian Olya menjadi ID yang sama.  Masalah kemanusiaan dan peternakan telah dipecahkan secara praktis. <br><br><h3>  Deskriptor file </h3><br>  Masalah file dan program yang bekerja dengan file ini hampir sama dengan masalah anjing dan manusia kita.  Misalkan saya membuka file dengan nama ivan.txt dan mulai menulis kata tuzik ke dalamnya, tetapi berhasil menulis hanya huruf pertama "t" ke file, dan file ini diganti namanya oleh seseorang, misalnya, olya.txt.  Tetapi file tersebut tetap sama, dan saya masih ingin menulis kartu as saya di dalamnya.  Setiap kali saya membuka file dengan panggilan sistem terbuka dalam bahasa pemrograman apa pun, saya mendapatkan ID unik yang mengarahkan saya ke file, ID ini adalah deskriptor file.  Dan tidak masalah apa yang dilakukan orang selanjutnya dengan file ini, mereka dapat menghapusnya, mereka dapat mengganti nama, mereka dapat mengubah pemilik atau menghapus izin baca dan tulis, saya masih akan memiliki akses ke sana, karena pada saat file dibuka, Saya memiliki hak untuk membaca dan / atau menulisnya, dan saya berhasil mulai bekerja dengannya, yang berarti saya harus terus melakukan ini. <br><br>  Di Linux, perpustakaan libc terbuka untuk setiap aplikasi yang sedang berjalan (proses) 3 file deskriptor, dengan angka 0,1,2.  Anda dapat menemukan informasi lebih lanjut di tautan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">man stdio</a> dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">man stdout</a> <br><br><ul><li>  Deskriptor file 0 disebut STDIN dan dikaitkan dengan input data dari aplikasi </li><li>  Deskriptor file 1 disebut STDOUT dan digunakan oleh aplikasi untuk menampilkan data, misalnya, perintah cetak </li><li>  File descriptor 2 disebut STDERR dan digunakan oleh aplikasi untuk menghasilkan data pelaporan kesalahan. </li></ul><br>  Jika dalam program Anda Anda membuka file untuk membaca atau menulis, maka kemungkinan besar Anda akan mendapatkan ID gratis pertama dan ini akan menjadi nomor 3. <br><br>  Daftar file deskriptor dapat dilihat dari proses apa pun jika Anda mengetahui PID-nya. <br><br>  Misalnya, buka konsol dengan bash dan lihat PID proses kami <br><br><pre><code class="bash hljs">[user@localhost ]$ <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> $$ 15771</code> </pre> <br>  Di konsol kedua, jalankan <br><br><pre> <code class="bash hljs">[user@localhost ]$ ls -lah /proc/15771/fd/ total 0 dr-x------ 2 user user 0 Oct 7 15:42 . dr-xr-xr-x 9 user user 0 Oct 7 15:42 .. lrwx------ 1 user user 64 Oct 7 15:42 0 -&gt; /dev/pts/21 lrwx------ 1 user user 64 Oct 7 15:42 1 -&gt; /dev/pts/21 lrwx------ 1 user user 64 Oct 7 15:42 2 -&gt; /dev/pts/21 lrwx------ 1 user user 64 Oct 7 15:42 255 -&gt; /dev/pts/21</code> </pre><br>  Anda dapat dengan aman mengabaikan file deskriptor nomor 255 dalam kerangka artikel ini, dibuka untuk kebutuhan Anda dengan bash sendiri, dan bukan oleh pustaka yang ditautkan. <br><br>  Sekarang semua 3 file deskriptor dikaitkan dengan perangkat pseudo-terminal <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">/ dev / pts</a> , tetapi kita masih dapat memanipulasi mereka, misalnya, berjalan di konsol kedua <br><br><pre> <code class="bash hljs">[user@localhost ]$ <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">"hello world"</span></span> &gt; /proc/15771/fd/0</code> </pre><br>  Dan di konsol pertama kita akan lihat <br><br><pre> <code class="bash hljs">[user@localhost ]$ hello world</code> </pre><br><h3>  Redirect dan Pipe </h3><br>  Anda dapat dengan mudah mengganti 3 file deskriptor ini dalam proses apa pun, termasuk dalam bash, misalnya, melalui pipa yang menghubungkan dua proses, lihat <br><br><pre> <code class="bash hljs">[user@localhost ]$ cat /dev/zero | sleep 10000</code> </pre><br>  Anda dapat menjalankan perintah ini sendiri dengan <i>strace -f</i> dan melihat apa yang terjadi di dalamnya, tetapi saya akan memberi tahu Anda secara singkat. <br><br>  Proses induk kami bash dengan PID 15771 mem-parsing perintah kami dan mengerti persis berapa banyak perintah yang ingin kami jalankan, dalam kasus kami ada dua: kucing dan tidur.  Bash tahu bahwa ia perlu membuat dua proses anak, dan menggabungkannya dengan satu pipa.  Total bash akan membutuhkan 2 proses anak dan satu pipa. <br><br>  Sebelum membuat proses anak, bash meluncurkan pemanggilan sistem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pipa</a> dan menerima deskriptor file baru untuk buffer pipa sementara, tetapi buffer ini belum mengikat kedua proses anak kami. <br><br>  Untuk proses induk, sepertinya pipa sudah ada, dan belum ada proses anak: <br><br><pre> <code class="bash hljs">PID <span class="hljs-built_in"><span class="hljs-built_in">command</span></span> 15771 bash lrwx------ 1 user user 64 Oct 7 15:42 0 -&gt; /dev/pts/21 lrwx------ 1 user user 64 Oct 7 15:42 1 -&gt; /dev/pts/21 lrwx------ 1 user user 64 Oct 7 15:42 2 -&gt; /dev/pts/21 lrwx------ 1 user user 64 Oct 7 15:42 3 -&gt; pipe:[253543032] lrwx------ 1 user user 64 Oct 7 15:42 4 -&gt; pipe:[253543032] lrwx------ 1 user user 64 Oct 7 15:42 255 -&gt; /dev/pts/21</code> </pre><br>  Kemudian, menggunakan system call, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">clone</a> bash menciptakan dua proses anak, dan tiga proses kami akan terlihat seperti ini: <br><br><pre> <code class="bash hljs">PID <span class="hljs-built_in"><span class="hljs-built_in">command</span></span> 15771 bash lrwx------ 1 user user 64 Oct 7 15:42 0 -&gt; /dev/pts/21 lrwx------ 1 user user 64 Oct 7 15:42 1 -&gt; /dev/pts/21 lrwx------ 1 user user 64 Oct 7 15:42 2 -&gt; /dev/pts/21 lrwx------ 1 user user 64 Oct 7 15:42 3 -&gt; pipe:[253543032] lrwx------ 1 user user 64 Oct 7 15:42 4 -&gt; pipe:[253543032] lrwx------ 1 user user 64 Oct 7 15:42 255 -&gt; /dev/pts/21 PID <span class="hljs-built_in"><span class="hljs-built_in">command</span></span> 9004 bash lrwx------ 1 user user 64 Oct 7 15:57 0 -&gt; /dev/pts/21 lrwx------ 1 user user 64 Oct 7 15:57 1 -&gt; /dev/pts/21 lrwx------ 1 user user 64 Oct 7 15:57 2 -&gt; /dev/pts/21 lrwx------ 1 user user 64 Oct 7 15:57 3 -&gt; pipe:[253543032] lrwx------ 1 user user 64 Oct 7 15:57 4 -&gt; pipe:[253543032] lrwx------ 1 user user 64 Oct 7 15:57 255 -&gt; /dev/pts/21 PID <span class="hljs-built_in"><span class="hljs-built_in">command</span></span> 9005 bash lrwx------ 1 user user 64 Oct 7 15:57 0 -&gt; /dev/pts/21 lrwx------ 1 user user 64 Oct 7 15:57 1 -&gt; /dev/pts/21 lrwx------ 1 user user 64 Oct 7 15:57 2 -&gt; /dev/pts/21 lrwx------ 1 user user 64 Oct 7 15:57 3 -&gt; pipe:[253543032] lrwx------ 1 user user 64 Oct 7 15:57 4 -&gt; pipe:[253543032] lrwx------ 1 user user 64 Oct 7 15:57 255 -&gt; /dev/pts/21</code> </pre><br>  Jangan lupa bahwa klon mengkloning proses bersama dengan semua deskriptor file, sehingga mereka akan sama dalam proses induk dan yang anak.  Tugas proses induk dengan PID 15771 adalah untuk memantau proses anak, sehingga hanya menunggu respons dari proses anak. <br><br>  Karena itu, ia tidak perlu pipa, dan ia menutup file deskriptor dengan angka 3 dan 4. <br><br>  Dalam proses bash child pertama dengan PID 9004, panggilan sistem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dup2</a> , mengubah deskriptor file STDOUT kami dengan nomor 1 menjadi deskriptor file yang menunjuk ke pipa, dalam kasus kami ini adalah nomor 3. Dengan demikian, segala yang diproses oleh anak pertama dengan PID 9004 akan menulis ke STDOUT secara otomatis akan jatuh ke dalam buffer pipa. <br><br>  Dalam proses anak kedua dengan PID 9005, bash mengubah deskriptor file STDIN dengan angka 0 menggunakan dup2. Sekarang semua yang dibaca bash kedua dengan PID 9005 akan dibaca dari pipa. <br><br>  Setelah itu, deskriptor dengan angka 3 dan 4 juga ditutup dalam proses anak, karena mereka tidak lagi digunakan. <br><br>  Saya sengaja mengabaikan file deskriptor 255, ini menggunakan bash untuk kebutuhan internal dan juga akan ditutup dalam proses anak. <br><br>  Selanjutnya, dalam proses anak pertama dengan PID 9004, bash memulai file yang dapat dieksekusi yang kami tentukan pada baris perintah dengan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">exec</a> panggilan sistem, dalam kasus kami adalah / usr / bin / cat. <br><br>  Dalam proses anak kedua dengan PID 9005, bash memulai file eksekusi kedua yang kami tentukan, dalam kasus kami adalah / usr / bin / sleep. <br><br>  Panggilan sistem exec tidak menutup deskriptor file jika tidak dibuka dengan tanda O_CLOEXEC selama panggilan terbuka.  Dalam kasus kami, setelah menjalankan file yang dapat dieksekusi, semua deskriptor file saat ini akan disimpan. <br><br>  Periksa di konsol: <br><br><pre> <code class="bash hljs">[user@localhost ]$ pgrep -P 15771 9004 9005 [user@localhost ]$ ls -lah /proc/15771/fd/ total 0 dr-x------ 2 user user 0 Oct 7 15:42 . dr-xr-xr-x 9 user user 0 Oct 7 15:42 .. lrwx------ 1 user user 64 Oct 7 15:42 0 -&gt; /dev/pts/21 lrwx------ 1 user user 64 Oct 7 15:42 1 -&gt; /dev/pts/21 lrwx------ 1 user user 64 Oct 7 15:42 2 -&gt; /dev/pts/21 lrwx------ 1 user user 64 Oct 7 15:42 255 -&gt; /dev/pts/21 [user@localhost ]$ ls -lah /proc/9004/fd total 0 dr-x------ 2 user user 0 Oct 7 15:57 . dr-xr-xr-x 9 user user 0 Oct 7 15:57 .. lrwx------ 1 user user 64 Oct 7 15:57 0 -&gt; /dev/pts/21 l-wx------ 1 user user 64 Oct 7 15:57 1 -&gt; pipe:[253543032] lrwx------ 1 user user 64 Oct 7 15:57 2 -&gt; /dev/pts/21 lr-x------ 1 user user 64 Oct 7 15:57 3 -&gt; /dev/zero [user@localhost ]$ ls -lah /proc/9005/fd total 0 dr-x------ 2 user user 0 Oct 7 15:57 . dr-xr-xr-x 9 user user 0 Oct 7 15:57 .. lr-x------ 1 user user 64 Oct 7 15:57 0 -&gt; pipe:[253543032] lrwx------ 1 user user 64 Oct 7 15:57 1 -&gt; /dev/pts/21 lrwx------ 1 user user 64 Oct 7 15:57 2 -&gt; /dev/pts/21 [user@localhost ]$ ps -up 9004 USER PID %CPU %MEM VSZ RSS TTY STAT START TIME COMMAND user 9004 0.0 0.0 107972 620 pts/21 S+ 15:57 0:00 cat /dev/zero [user@localhost ]$ ps -up 9005 USER PID %CPU %MEM VSZ RSS TTY STAT START TIME COMMAND user 9005 0.0 0.0 107952 360 pts/21 S+ 15:57 0:00 sleep 10000</code> </pre><br>  Seperti yang Anda lihat, jumlah unik pipa kami adalah sama di kedua proses.  Jadi kami memiliki koneksi antara dua proses yang berbeda dengan satu orangtua. <br><br>  Bagi mereka yang tidak terbiasa dengan panggilan sistem yang menggunakan bash, saya sangat merekomendasikan menjalankan perintah melalui strace dan melihat apa yang terjadi di dalam, misalnya, seperti ini: <br><br><pre> <code class="bash hljs">strace -s 1024 -f bash -c <span class="hljs-string"><span class="hljs-string">"ls | grep hello"</span></span></code> </pre><br>  Mari kita kembali ke masalah kita dengan kehabisan ruang disk dan mencoba untuk menyimpan data tanpa memulai kembali prosesnya.  Mari kita menulis sebuah program kecil yang akan menulis ke disk sekitar 1 megabyte per detik.  Selain itu, jika karena alasan tertentu kami tidak dapat menulis data ke disk, kami hanya akan mengabaikannya dan mencoba untuk menulis data lagi setelah satu detik.  Dalam contoh saya menggunakan Python, Anda bisa menggunakan bahasa pemrograman lain. <br><br><pre> <code class="python hljs">[user@localhost ]$ cat openforwrite.py <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> datetime <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> time mystr=<span class="hljs-string"><span class="hljs-string">"a"</span></span>*<span class="hljs-number"><span class="hljs-number">1024</span></span>*<span class="hljs-number"><span class="hljs-number">1024</span></span>+<span class="hljs-string"><span class="hljs-string">"\n"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> open(<span class="hljs-string"><span class="hljs-string">"123.txt"</span></span>, <span class="hljs-string"><span class="hljs-string">"w"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> f: <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">try</span></span>: f.write(str(datetime.datetime.now())) f.write(mystr) f.flush() time.sleep(<span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">except</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">pass</span></span></code> </pre><br>  Jalankan program dan lihat deskriptor file <br><br><pre> <code class="bash hljs">[user@localhost ]$ python openforwrite.py &amp; [1] 3762 [user@localhost ]$ ps axuf | grep [o]penforwrite user 3762 0.0 0.0 128600 5744 pts/22 S+ 16:28 0:00 | \_ python openforwrite.py [user@localhost ]$ ls -la /proc/3762/fd total 0 dr-x------ 2 user user 0 Oct 7 16:29 . dr-xr-xr-x 9 user user 0 Oct 7 16:29 .. lrwx------ 1 user user 64 Oct 7 16:29 0 -&gt; /dev/pts/22 lrwx------ 1 user user 64 Oct 7 16:29 1 -&gt; /dev/pts/22 lrwx------ 1 user user 64 Oct 7 16:29 2 -&gt; /dev/pts/22 l-wx------ 1 user user 64 Oct 7 16:29 3 -&gt; /home/user/123.txt</code> </pre><br>  Seperti yang Anda lihat, kami memiliki 3 file deskriptor standar dan satu lagi yang kami buka.  Periksa ukuran file: <br><br><pre> <code class="bash hljs">[user@localhost ]$ ls -lah 123.txt -rw-rw-r-- 1 user user 117M Oct 7 16:30 123.txt</code> </pre><br>  data sedang ditulis, coba ubah izin file: <br><br><pre> <code class="bash hljs">[user@localhost ]$ sudo chown root: 123.txt [user@localhost ]$ ls -lah 123.txt -rw-rw-r-- 1 root root 168M Oct 7 16:31 123.txt [user@localhost ]$ ls -lah 123.txt -rw-rw-r-- 1 root root 172M Oct 7 16:31 123.txt</code> </pre><br>  Kami melihat bahwa data masih ditulis, meskipun pengguna kami tidak memiliki hak untuk menulis ke file.  Mari kita coba hapus: <br><br><pre> <code class="bash hljs">[user@localhost ]$ sudo rm 123.txt [user@localhost ]$ ls 123.txt ls: cannot access 123.txt: No such file or directory</code> </pre><br>  Di mana data ditulis?  Dan apakah semuanya itu ditulis?  Kami memeriksa: <br><br><pre> <code class="bash hljs">[user@localhost ]$ ls -la /proc/3762/fd total 0 dr-x------ 2 user user 0 Oct 7 16:29 . dr-xr-xr-x 9 user user 0 Oct 7 16:29 .. lrwx------ 1 user user 64 Oct 7 16:29 0 -&gt; /dev/pts/22 lrwx------ 1 user user 64 Oct 7 16:29 1 -&gt; /dev/pts/22 lrwx------ 1 user user 64 Oct 7 16:29 2 -&gt; /dev/pts/22 l-wx------ 1 user user 64 Oct 7 16:29 3 -&gt; /home/user/123.txt (deleted)</code> </pre><br>  Ya, file deskriptor kami masih ada, dan kami dapat bekerja dengan file deskriptor ini seperti halnya file lama kami, kami dapat membaca, membersihkan, dan menyalinnya. <br><br>  Kami melihat ukuran file: <br><br><pre> <code class="bash hljs">[user@localhost ]$ lsof | grep 123.txt python 31083 user 3w REG 8,5 19923457 2621522 /home/user/123.txt</code> </pre><br>  Ukuran file 19923457. Mencoba menghapus file: <br><br><pre> <code class="bash hljs">[user@localhost ]$ truncate -s 0 /proc/31083/fd/3 [user@localhost ]$ lsof | grep 123.txt python 31083 user 3w REG 8,5 136318390 2621522 /home/user/123.txt</code> </pre><br>  Seperti yang Anda lihat, ukuran file hanya meningkat dan trankate kami tidak berfungsi.  Lihat dokumentasi untuk panggilan sistem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">terbuka</a> .  Jika kita menggunakan flag O_APPEND saat membuka file, maka setiap kali sistem operasi memeriksa ukuran file dan menulis data hingga akhir file, ia melakukan ini secara atomis.  Ini memungkinkan beberapa utas atau proses untuk menulis ke file yang sama.  Namun dalam kode kami, kami tidak menggunakan bendera ini.  Kita dapat melihat ukuran file yang berbeda di lsof setelah trankate hanya jika kita membuka file untuk rekaman tambahan, yang berarti bahwa alih-alih dalam kode kita <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">with</span></span> open(<span class="hljs-string"><span class="hljs-string">"123.txt"</span></span>, <span class="hljs-string"><span class="hljs-string">"w"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> f:</code> </pre><br>  kita harus meletakkan <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">with</span></span> open(<span class="hljs-string"><span class="hljs-string">"123.txt"</span></span>, <span class="hljs-string"><span class="hljs-string">"a"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> f:</code> </pre><br>  Memeriksa dengan tanda "w" <br><br><pre> <code class="bash hljs">[user@localhost ]$ strace -e trace=open python openforwrite.py 2&gt;&amp;1| grep 123.txt open(<span class="hljs-string"><span class="hljs-string">"123.txt"</span></span>, O_WRONLY|O_CREAT|O_TRUNC, 0666) = 3</code> </pre><br>  dan dengan bendera "a" <br><br><pre> <code class="bash hljs">[user@localhost ]$ strace -e trace=open python openforwrite.py 2&gt;&amp;1| grep 123.txt open(<span class="hljs-string"><span class="hljs-string">"123.txt"</span></span>, O_WRONLY|O_CREAT|O_APPEND, 0666) = 3</code> </pre><br><h3>  Memprogram proses yang sudah berjalan </h3><br>  Seringkali, programmer menggunakan debugger (misalnya GDB) atau berbagai level logging dalam aplikasi saat membuat dan menguji program.  Linux menyediakan kemampuan untuk benar-benar menulis dan mengubah program yang sudah berjalan, misalnya mengubah nilai variabel, mengatur breakpoint, dll., Dll. <br><br>  Kembali ke pertanyaan awal dengan ruang disk yang tidak cukup untuk menulis file, kami akan mencoba meniru masalahnya. <br><br>  Buat file untuk partisi kami, yang akan kami pasang sebagai disk terpisah: <br><br><pre> <code class="bash hljs">[user@localhost ~]$ dd <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>=/dev/zero of=~/tempfile_for_article.dd bs=1M count=10 10+0 records <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> 10+0 records out 10485760 bytes (10 MB) copied, 0.00525929 s, 2.0 GB/s [user@localhost ~]$</code> </pre><br>  Buat sistem file: <br><br><pre> <code class="bash hljs">[user@localhost ~]$ mkfs.ext4 ~/tempfile_for_article.dd mke2fs 1.42.9 (28-Dec-2013) /home/user/tempfile_for_article.dd is not a block special device. Proceed anyway? (y,n) y ... Writing superblocks and filesystem accounting information: <span class="hljs-keyword"><span class="hljs-keyword">done</span></span> [user@localhost ~]$</code> </pre><br>  Pasang sistem file: <br><br><pre> <code class="bash hljs">[user@localhost ~]$ sudo mount ~/tempfile_for_article.dd /mnt/ [sudo] password <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> user: [user@localhost ~]$ df -h | grep mnt /dev/loop0 8.7M 172K 7.9M 3% /mnt</code> </pre><br>  Buat direktori dengan pemilik kami: <br><br><pre> <code class="bash hljs">[user@localhost ~]$ sudo mkdir /mnt/logs [user@localhost ~]$ sudo chown user: /mnt/logs</code> </pre><br>  Kami membuka file hanya untuk menulis di program kami: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">with</span></span> open(<span class="hljs-string"><span class="hljs-string">"/mnt/logs/123.txt"</span></span>, <span class="hljs-string"><span class="hljs-string">"w"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> f:</code> </pre><br>  Kami meluncurkan <br><br><pre> <code class="bash hljs">[user@localhost ]$ python openforwrite.py</code> </pre><br>  Menunggu beberapa detik <br><br><pre> <code class="bash hljs">[user@localhost ~]$ df -h | grep mnt /dev/loop0 8.7M 8.0M 0 100% /mnt</code> </pre><br>  Jadi, kami mendapatkan masalah yang dijelaskan di awal artikel ini.  Ruang bebas 0, ditempati 100%. <br><br>  Kami ingat bahwa sesuai dengan kondisi tugas, kami mencoba untuk merekam data yang sangat penting yang tidak dapat hilang.  Dan pada saat yang sama kita perlu memperbaiki layanan tanpa memulai kembali prosesnya. <br><br>  Misalkan kita masih memiliki ruang disk, tetapi di partisi yang berbeda, misalnya di / home. <br><br>  Mari kita coba "memprogram ulang dengan cepat" kode kita. <br><br>  Kami melihat PID dari proses kami, yang memakan semua ruang disk: <br><br><pre> <code class="bash hljs">[user@localhost ~]$ ps axuf | grep [o]penfor user 10078 27.2 0.0 128600 5744 pts/22 R+ 11:06 0:02 | \_ python openforwrite.py</code> </pre><br>  Kami terhubung ke proses melalui gdb <br><br><pre> <code class="bash hljs">[user@localhost ~]$ gdb -p 10078 ... (gdb)</code> </pre><br>  Kami melihat deskriptor file terbuka: <br><br><pre> <code class="bash hljs">(gdb) shell ls -lah /proc/10078/fd/ total 0 dr-x------ 2 user user 0 Oct 8 11:06 . dr-xr-xr-x 9 user user 0 Oct 8 11:06 .. lrwx------ 1 user user 64 Oct 8 11:09 0 -&gt; /dev/pts/22 lrwx------ 1 user user 64 Oct 8 11:09 1 -&gt; /dev/pts/22 lrwx------ 1 user user 64 Oct 8 11:06 2 -&gt; /dev/pts/22 l-wx------ 1 user user 64 Oct 8 11:09 3 -&gt; /mnt/logs/123.txt</code> </pre><br>  Kami melihat informasi tentang file descriptor dengan nomor 3, yang menarik minat kami <br><br><pre> <code class="bash hljs">(gdb) shell cat /proc/10078/fdinfo/3 pos: 8189952 flags: 0100001 mnt_id: 482</code> </pre><br>  Mengingat apa jenis panggilan sistem yang dibuat oleh Python (lihat di atas, di mana kami menjalankan strace dan menemukan panggilan terbuka), saat memproses kode kami untuk membuka file, kami melakukan hal yang sama atas nama kami sendiri, tetapi kami memerlukan bit O_WRONLY | O_CREAT | O_TRUNC ganti dengan nilai numerik.  Untuk melakukan ini, buka sumber kernel, misalnya, di <a href="">sini</a> dan lihat flag apa yang bertanggung jawab atas apa <br><br>  #define O_WRONLY 00000001 <br>  #define O_CREAT 00000100 <br>  #define O_TRUNC 00001000 <br><br>  Kami menggabungkan semua nilai menjadi satu, kami mendapatkan 00001101 <br><br>  Jalankan panggilan kami dari gdb <br><br><pre> <code class="bash hljs">(gdb) call open(<span class="hljs-string"><span class="hljs-string">"/home/user/123.txt"</span></span>, 00001101,0666) <span class="hljs-variable"><span class="hljs-variable">$1</span></span> = 4</code> </pre><br>  Jadi kami mendapat file deskriptor baru dengan nomor 4 dan file terbuka baru di bagian lain, periksa: <br><br><pre> <code class="bash hljs">(gdb) shell ls -lah /proc/10078/fd/ total 0 dr-x------ 2 user user 0 Oct 8 11:06 . dr-xr-xr-x 9 user user 0 Oct 8 11:06 .. lrwx------ 1 user user 64 Oct 8 11:09 0 -&gt; /dev/pts/22 lrwx------ 1 user user 64 Oct 8 11:09 1 -&gt; /dev/pts/22 lrwx------ 1 user user 64 Oct 8 11:06 2 -&gt; /dev/pts/22 l-wx------ 1 user user 64 Oct 8 11:09 3 -&gt; /mnt/logs/123.txt l-wx------ 1 user user 64 Oct 8 11:15 4 -&gt; /home/user/123.txt</code> </pre><br>  Kita ingat contoh pipa - bagaimana bash mengubah deskriptor file, dan telah mempelajari panggilan sistem dup2. <br><br>  Kami mencoba mengganti satu deskriptor file dengan yang lainnya <br><br><pre> <code class="bash hljs">(gdb) call dup2(4,3) <span class="hljs-variable"><span class="hljs-variable">$2</span></span> = 3</code> </pre><br>  Kami memeriksa: <br><br><pre> <code class="bash hljs">(gdb) shell ls -lah /proc/10078/fd/ total 0 dr-x------ 2 user user 0 Oct 8 11:06 . dr-xr-xr-x 9 user user 0 Oct 8 11:06 .. lrwx------ 1 user user 64 Oct 8 11:09 0 -&gt; /dev/pts/22 lrwx------ 1 user user 64 Oct 8 11:09 1 -&gt; /dev/pts/22 lrwx------ 1 user user 64 Oct 8 11:06 2 -&gt; /dev/pts/22 l-wx------ 1 user user 64 Oct 8 11:09 3 -&gt; /home/user/123.txt l-wx------ 1 user user 64 Oct 8 11:15 4 -&gt; /home/user/123.txt</code> </pre><br>  Kami menutup file descriptor 4, karena kami tidak memerlukannya: <br><br><pre> <code class="bash hljs">(gdb) call close (4) <span class="hljs-variable"><span class="hljs-variable">$1</span></span> = 0</code> </pre><br>  Dan keluar gdb <br><br><pre> <code class="bash hljs">(gdb) quit A debugging session is active. Inferior 1 [process 10078] will be detached. Quit anyway? (y or n) y Detaching from program: /usr/bin/python2.7, process 10078</code> </pre><br>  Periksa file baru: <br><br><pre> <code class="bash hljs">[user@localhost ~]$ ls -lah /home/user/123.txt -rw-rw-r-- 1 user user 5.1M Oct 8 11:18 /home/user/123.txt [user@localhost ~]$ ls -lah /home/user/123.txt -rw-rw-r-- 1 user user 7.1M Oct 8 11:18 /home/user/123.txt</code> </pre><br>  Seperti yang Anda lihat, data ditulis ke file baru, kami memeriksa yang lama: <br><br><pre> <code class="bash hljs">[user@localhost ~]$ ls -lah /mnt/logs/123.txt -rw-rw-r-- 1 user user 7.9M Oct 8 11:08 /mnt/logs/123.txt</code> </pre><br>  Data tidak hilang, aplikasi berfungsi, log ditulis ke tempat baru. <br><br><h3>  Mari kita sedikit menyulitkan tugas </h3><br>  Bayangkan bahwa data itu penting bagi kami, tetapi kami tidak memiliki ruang disk di salah satu bagian dan kami tidak dapat menghubungkan disk. <br><br>  Apa yang dapat kita lakukan adalah mengarahkan ulang data kita di suatu tempat, misalnya ke pipa, dan data dari pipa, pada gilirannya, mengarahkan kembali ke jaringan melalui beberapa program, misalnya netcat. <br>  Kita dapat membuat pipa bernama dengan perintah mkfifo.  Ini akan membuat file pseudo pada sistem file, bahkan jika tidak ada ruang kosong di dalamnya. <br><br>  Kami me-restart aplikasi, dan memeriksa: <br><br><pre> <code class="bash hljs">[user@localhost ]$ python openforwrite.py [user@localhost ~]$ ps axuf | grep [o]pen user 5946 72.9 0.0 128600 5744 pts/22 R+ 11:27 0:20 | \_ python openforwrite.py [user@localhost ~]$ ls -lah /proc/5946/fd total 0 dr-x------ 2 user user 0 Oct 8 11:27 . dr-xr-xr-x 9 user user 0 Oct 8 11:27 .. lrwx------ 1 user user 64 Oct 8 11:28 0 -&gt; /dev/pts/22 lrwx------ 1 user user 64 Oct 8 11:28 1 -&gt; /dev/pts/22 lrwx------ 1 user user 64 Oct 8 11:27 2 -&gt; /dev/pts/22 l-wx------ 1 user user 64 Oct 8 11:28 3 -&gt; /mnt/logs/123.txt [user@localhost ~]$ df -h | grep mnt /dev/loop0 8.7M 8.0M 0 100% /mnt</code> </pre><br>  Tidak ada ruang disk, tetapi kami berhasil membuat pipa bernama di sana: <br><br><pre> <code class="bash hljs">[user@localhost ~]$ mkfifo /mnt/logs/megapipe [user@localhost ~]$ ls -lah /mnt/logs/megapipe prw-rw-r-- 1 user user 0 Oct 8 11:28 /mnt/logs/megapipe</code> </pre><br>  Sekarang kita perlu membungkus semua data yang masuk ke pipa ini ke server lain melalui jaringan, untuk ini semua netcat yang sama akan dilakukan. <br><br>  Di server remote-server.example.com, jalankan <br><br><pre> <code class="bash hljs">[user@localhost ~]$ nc -l 7777 &gt; 123.txt</code> </pre><br>  Di server bermasalah kami, jalankan di terminal terpisah <br><br><pre> <code class="bash hljs">[user@localhost ~]$ nc remote-server.example.com 7777 &lt; /mnt/logs/megapipe</code> </pre><br>  Sekarang semua data yang masuk ke pipa akan secara otomatis pergi ke stdin di netcat, yang akan mengirimkannya ke jaringan pada port 7777. <br><br>  Yang harus kita lakukan adalah mulai menulis data kita ke dalam pipa bernama ini. <br><br>  Kami sudah memiliki aplikasi yang berjalan: <br><br><pre> <code class="bash hljs">[user@localhost ~]$ ps axuf | grep [o]pen user 5946 99.8 0.0 128600 5744 pts/22 R+ 11:27 169:27 | \_ python openforwrite.py [user@localhost ~]$ ls -lah /proc/5946/fd total 0 dr-x------ 2 user user 0 Oct 8 11:27 . dr-xr-xr-x 9 user user 0 Oct 8 11:27 .. lrwx------ 1 user user 64 Oct 8 11:28 0 -&gt; /dev/pts/22 lrwx------ 1 user user 64 Oct 8 11:28 1 -&gt; /dev/pts/22 lrwx------ 1 user user 64 Oct 8 11:27 2 -&gt; /dev/pts/22 l-wx------ 1 user user 64 Oct 8 11:28 3 -&gt; /mnt/logs/123.txt</code> </pre><br>  Dari semua flag, kita hanya perlu O_WRONLY karena file sudah ada dan kita tidak perlu menghapusnya <br><br><pre> <code class="bash hljs">[user@localhost ~]$ gdb -p 5946 ... (gdb) call open(<span class="hljs-string"><span class="hljs-string">"/mnt/logs/megapipe"</span></span>, 00000001,0666) <span class="hljs-variable"><span class="hljs-variable">$1</span></span> = 4 (gdb) shell ls -lah /proc/5946/fd total 0 dr-x------ 2 user user 0 Oct 8 11:27 . dr-xr-xr-x 9 user user 0 Oct 8 11:27 .. lrwx------ 1 user user 64 Oct 8 11:28 0 -&gt; /dev/pts/22 lrwx------ 1 user user 64 Oct 8 11:28 1 -&gt; /dev/pts/22 lrwx------ 1 user user 64 Oct 8 11:27 2 -&gt; /dev/pts/22 l-wx------ 1 user user 64 Oct 8 11:28 3 -&gt; /mnt/logs/123.txt l-wx------ 1 user user 64 Oct 8 14:20 4 -&gt; /mnt/logs/megapipe (gdb) call dup2(4,3) <span class="hljs-variable"><span class="hljs-variable">$2</span></span> = 3 (gdb) shell ls -lah /proc/5946/fd total 0 dr-x------ 2 user user 0 Oct 8 11:27 . dr-xr-xr-x 9 user user 0 Oct 8 11:27 .. lrwx------ 1 user user 64 Oct 8 11:28 0 -&gt; /dev/pts/22 lrwx------ 1 user user 64 Oct 8 11:28 1 -&gt; /dev/pts/22 lrwx------ 1 user user 64 Oct 8 11:27 2 -&gt; /dev/pts/22 l-wx------ 1 user user 64 Oct 8 11:28 3 -&gt; /mnt/logs/megapipe l-wx------ 1 user user 64 Oct 8 14:20 4 -&gt; /mnt/logs/megapipe (gdb) call close(4) <span class="hljs-variable"><span class="hljs-variable">$3</span></span> = 0 (gdb) shell ls -lah /proc/5946/fd total 0 dr-x------ 2 user user 0 Oct 8 11:27 . dr-xr-xr-x 9 user user 0 Oct 8 11:27 .. lrwx------ 1 user user 64 Oct 8 11:28 0 -&gt; /dev/pts/22 lrwx------ 1 user user 64 Oct 8 11:28 1 -&gt; /dev/pts/22 lrwx------ 1 user user 64 Oct 8 11:27 2 -&gt; /dev/pts/22 l-wx------ 1 user user 64 Oct 8 11:28 3 -&gt; /mnt/logs/megapipe (gdb) quit A debugging session is active. Inferior 1 [process 5946] will be detached. Quit anyway? (y or n) y Detaching from program: /usr/bin/python2.7, process 5946</code> </pre><br>  Memeriksa server jarak jauh remote-server.example.com <br><br><pre> <code class="bash hljs">[user@localhost ~]$ ls -lah 123.txt -rw-rw-r-- 1 user user 38M Oct 8 14:21 123.txt</code> </pre><br>  Data masuk, kami memeriksa server masalah <br><br><pre> <code class="bash hljs">[user@localhost ~]$ ls -lah /mnt/logs/ total 7.9M drwxr-xr-x 2 user user 1.0K Oct 8 11:28 . drwxr-xr-x 4 root root 1.0K Oct 8 10:55 .. -rw-rw-r-- 1 user user 7.9M Oct 8 14:17 123.txt prw-rw-r-- 1 user user 0 Oct 8 14:22 megapipe</code> </pre><br>  Data disimpan, masalah teratasi. <br><br>  Saya mengambil kesempatan ini untuk menyampaikan salam saya kepada kolega saya di Degiro. <br>  Dengarkan podcast Radio T. <br><br>  Baik untuk semua <br><br>  Sebagai pekerjaan rumah, saya mengusulkan untuk memikirkan apa yang akan ada dalam file deskriptor proses kucing dan tidur jika Anda menjalankan perintah ini: <br><br><pre> <code class="bash hljs">[user@localhost ~]$ cat /dev/zero 2&gt;/dev/null| sleep 10000</code> </pre></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id471038/">https://habr.com/ru/post/id471038/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id471026/index.html">TypeScript Kekuasaan tidak pernah</a></li>
<li><a href="../id471028/index.html">Troli truk ROS. Bagian 6. Odometri dengan enkoder roda, peta ruang, lidar</a></li>
<li><a href="../id471032/index.html">Foto yang tak terlihat</a></li>
<li><a href="../id471034/index.html">Wawancara dengan Pornhub Web Developer</a></li>
<li><a href="../id471036/index.html">Hidup dan belajar. Bagian 5. Pendidikan mandiri: kumpulkan diri Anda</a></li>
<li><a href="../id471040/index.html">[bookmark] React manual versi PDF dan ePUB</a></li>
<li><a href="../id471042/index.html">Pemecahan masalah dengan pwnable.kr 25 - otp. Batas ukuran file Linux</a></li>
<li><a href="../id471044/index.html">Sass MediaScreen - Menentukan Perangkat CSS</a></li>
<li><a href="../id471046/index.html">Avalonia yang bergaya</a></li>
<li><a href="../id471048/index.html">React + Mobx: apa gunanya?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>