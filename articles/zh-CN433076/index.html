<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🍀 🎞️ 🧑🏽‍🤝‍🧑🏻 我们如何制作Android Gallery库以查看媒体内容 📭 🚣🏿 🏗️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="哈Ha！ 不久前，为了寻求冒险，新项目和技术，我  成为机器人  定居在Redmadrobot。 我得到了一把椅子，一台显示器和一台Macbook，还有一个用于热身的小内部项目。 有必要完成并发布一个自写的库，以查看我们在项目中使用的媒体内容。 在本文中，我将告诉您如何在一周内了解触摸事件，如何成为...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>我们如何制作Android Gallery库以查看媒体内容</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/redmadrobot/blog/433076/"><p><img src="https://habrastorage.org/webt/fl/a3/rh/fla3rh2hkzl_guxybjkro7f8hua.png"><br><br> 哈Ha！ 不久前，为了寻求冒险，新项目和技术，我 <del> 成为机器人 </del> 定居在Redmadrobot。 我得到了一把椅子，一台显示器和一台Macbook，还有一个用于热身的小内部项目。 有必要完成并发布一个自写的库，以查看我们在项目中使用的媒体内容。 在本文中，我将告诉您如何在一周内了解触摸事件，如何成为开源，在Android SDK中发现错误并发布库。 </p><a name="habracut"></a><br><h2 id="nachalo"> 开始 </h2><br><p> 我们的商店应用程序的重要功能之一是能够查看附近和各个侧面的商品和服务的视频和照片。 我们不想重新发明轮子，而是去寻找一个适合我们的成品图书馆。 </p><br><p> 我们计划找到一种解决方案，以便用户可以： </p><br><ul><li> 查看照片； </li><li> 使用捏缩放和双击缩放照片； </li><li> 观看影片 </li><li> 翻转媒体内容； </li><li> 垂直滑动即可关闭照片卡（滑动即可关闭）。 </li></ul><br><p> 这是我们发现的内容： </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">FrescoImageViewer-</a>支持查看和滚动照片和基本手势，但不支持查看视频，仅用于<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Fresco</a>库。 </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">PhotoView-</a>支持查看照片，除了滚动，滑动以关闭之外，大多数主要控制手势均不支持查看视频。 </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">PhotoDraweeView-</a>功能类似于PhotoView，但适用于Fresco。 </li></ul><br><p> 由于没有一个库完全满足要求，因此我们不得不编写自己的库。 </p><br><h2 id="realizuem-biblioteku"> 我们意识到图书馆 </h2><br><p> 为了获得必要的功能，我们最终确定了其他库中的现有解决方案。 他们决定给发生的事情起一个小小的名字<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Android Gallery</a> 。 </p><br><h3 id="realizuem-funkcionalnost"> 我们实现功能 </h3><br><p>  <strong>查看和缩放照片</strong> <br> 为了查看照片，我们采用了PhotoView库，该库支持开箱即用的缩放。 </p><br><p>  <strong>观看影片</strong> <br> 为了观看视频，他们使用了<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">ExoPlayer</a> ，它已在<a href="">MediaPagerAdapter中</a>重用。 用户首次打开视频时，将创建ExoPlayer。 切换到另一个元素时，该元素已排队，因此在下次启动视频时，将使用已经创建的ExoPlayer实例。 这使元素之间的过渡更平滑。 </p><br><p> <strong>滚动媒体内容</strong> <br> 在这里，我们使用了来自FrescoImageViewer的MultiTouchViewPager，它不会拦截多点触摸事件，因此我们可以向其添加手势以缩放图像。 </p><br><p>  <strong>滑动即可关闭</strong> <br>  PhotoView不支持滑动以消除和反跳（在按比例放大或缩小图像时恢复原始图像尺寸）。 <br> 这就是我们设法处理它的方式。 </p><br><h3 id="izuchaem-touch-events-dlya-realizacii-swipe-to-dismiss"> 学习触摸事件以实现轻击以消除 </h3><br><p>在继续支持滑动以关闭之前，您需要了解触摸事件的工作原理。 当用户触摸屏幕时，将在当前Activity中调用<code>dispatchTouchEvent(motionEvent: MotionEvent)</code>方法，其中<code>MotionEvent.ACTION_DOWN</code>进入。 此方法决定事件的命运。 您可以将<code>motionEvent</code>传递给<code>onTouchEvent(motionEvent: MotionEvent)</code>进行触摸处理，也可以在View层次结构中将其从上到下进行进一步处理。 对<code>ACTION_UP</code>之前的事件和/或后续事件感兴趣的View返回true。 </p><br><p> 之后，当前手势的所有事件都将落入此View，直到该手势以<code>ACTION_UP</code>事件结束或父ViewGroup取得控制权（然后<code>ACTION_CANCELED</code>事件将进入View）。 如果事件<code>onTouchEvent(motionEvent: MotionEvent)</code>整个View层次结构，并且没有人感兴趣，它将返回<code>onTouchEvent(motionEvent: MotionEvent)</code>的Activity。 <br><br><img src="https://habrastorage.org/webt/yz/np/jd/yznpjdfaodnwmd3tzy_wldagyak.png"><br><br> 在我们的Android Gallery库中，第一个<code>ACTION_DOWN</code>事件到达PhotoView中的<code>dispatchTouchEvent()</code> ，其中<code>motionEvent</code>传递给<code>onTouch()</code>实现，该实现返回true。 此外，所有事件都经过相同的链，直到下列其中一项： </p><br><ul><li>  <code>ACTION_UP</code> ; </li><li>  ViewPager将尝试拦截该事件以进行滚动； </li><li>  <a href="">VerticalDragLayout</a>将尝试拦截该事件以使滑动消失。 </li></ul><br><p>  <code>onInterceptTouchEvent(motionEvent: MotionEvent)</code>方法中的仅ViewGroup可以拦截事件。 即使View对任何MotionEvent感兴趣，事件本身也将通过整个先前ViewGroup链的<code>dispatchTouchEvent(motionEvent: MotionEvent)</code> 。 因此，父母总是“看着”他们的孩子。 任何父ViewGroup都可以拦截事件并在<code>onInterceptTouchEvent(motionEvent: MotionEvent)</code>返回true，然后所有子<code>MotionEvent.ACTION_CANCEL</code>都将在<code>onTouchEvent(motionEvent: MotionEvent)</code>接收<code>onTouchEvent(motionEvent: MotionEvent)</code> 。 </p><br><p> 示例：用户将手指放在RecyclerView中的某个元素上，然后在同一元素中处理事件。 但是，只要他开始上下移动手指，RecyclerView就会拦截事件，并且滚动将开始，并且View将接收到<code>ACTION_CANCEL</code>事件。 <br><br><img src="https://habrastorage.org/webt/yp/x9/kf/ypx9kf8alvwtag0jfihj-jrzjmo.png"><br><br> 在Android Gallery中，VerticalDragLayout可以拦截事件以使其滑动以关闭或关闭ViewPager以进行滚动。 但是，View可以通过调用<code>requestDisallowInterceptTouchEvent(true)</code>方法来阻止父级<code>requestDisallowInterceptTouchEvent(true)</code>事件。 如果View需要执行其操作不希望被父级拦截的操作，则这可能是必要的。 </p><br><p> 例如，当播放器中的用户跳过曲目到特定时间时。 如果父级ViewPager截获了水平滚动，则将过渡到下一个轨道。 </p><br><p> 为了处理轻扫以消除问题，我们编写了VerticalDragLayout，但是它没有从PhotoView接收触摸事件。 为了理解为什么会发生这种情况，我不得不弄清楚如何在PhotoView中处理触摸事件。 </p><br><p> 加工订单： </p><br><ol><li> 当VerticalDragLayout中的MotionEvent.ACTION_DOWN触发时， <code>interceptTouchEvent()</code>返回false，因为 该ViewGroup仅对垂直ACTION_MOVE感兴趣。  ACTION_MOVE方向在<code>dispatchTouchEvent()</code>定义，然后将事件传递到ViewGroup中的<code>super.dispatchTouchEvent()</code>方法，在该事件中将事件传递到VerticalDragLayout中的<code>interceptTouchEvent()</code>实现。 <br><br><img src="https://habrastorage.org/webt/le/zg/xb/lezgxbf8n-_tnhdpqc96drpjqvm.png"><br><br></li><li> 当<code>ACTION_DOWN</code>事件到达PhotoView中的<code>onTouch()</code>方法时，该视图将<code>onTouch()</code>拦截事件管理的功能。 所有后续手势事件都不会落入<code>interceptTouchEvent()</code>方法中。 仅当手势完成或在图像的左右边界上<code>ACTION_MOVE</code>水平<code>ACTION_MOVE</code> ，才可以将控制权拦截给父级。 <br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (mAllowParentInterceptOnEdge &amp;&amp; !mScaleDragDetector.isScaling() &amp;&amp; !mBlockParentIntercept) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (mScrollEdge == EDGE_BOTH || (mScrollEdge == EDGE_LEFT &amp;&amp; dx &gt;= <span class="hljs-number"><span class="hljs-number">1f</span></span>) || (mScrollEdge == EDGE_RIGHT &amp;&amp; dx &lt;= -<span class="hljs-number"><span class="hljs-number">1f</span></span>)) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (parent != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { parent.requestDisallowInterceptTouchEvent(<span class="hljs-keyword"><span class="hljs-keyword">false</span></span>); } } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (parent != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { parent.requestDisallowInterceptTouchEvent(<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>); } }</code> </pre> <br><p><img src="https://habrastorage.org/webt/kk/s3/pj/kks3pjkovqsyiyiaif64bc_qh3e.png"><br><br> 由于PhotoView仅允许父级在水平<code>ACTION_MOVE</code>情况下截获控件，并且要<code>ACTION_MOVE</code>是垂直<code>ACTION_MOVE</code> ，因此VerticalDragLayout无法拦截事件控制以实现手势。 要解决此问题，您需要添加在垂直<code>ACTION_MOVE</code>情况下拦截控制的<code>ACTION_MOVE</code> 。 <br></p><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (mAllowParentInterceptOnEdge &amp;&amp; !mScaleDragDetector.isScaling() &amp;&amp; !mBlockParentIntercept) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (mHorizontalScrollEdge == HORIZONTAL_EDGE_BOTH || (mHorizontalScrollEdge == HORIZONTAL_EDGE_LEFT &amp;&amp; dx &gt;= <span class="hljs-number"><span class="hljs-number">1f</span></span>) || (mHorizontalScrollEdge == HORIZONTAL_EDGE_RIGHT &amp;&amp; dx &lt;= -<span class="hljs-number"><span class="hljs-number">1f</span></span>) || mVerticalScrollEdge == VERTICAL_EDGE_BOTH || (mVerticalScrollEdge == VERTICAL_EDGE_TOP &amp;&amp; dy &gt;= <span class="hljs-number"><span class="hljs-number">1f</span></span>) || (mVerticalScrollEdge == VERTICAL_EDGE_BOTTOM &amp;&amp; dy &lt;= -<span class="hljs-number"><span class="hljs-number">1f</span></span>)) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (parent != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { parent.requestDisallowInterceptTouchEvent(<span class="hljs-keyword"><span class="hljs-keyword">false</span></span>); } } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (parent != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { parent.requestDisallowInterceptTouchEvent(<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>); } }</code> </pre> <br><p> 现在，在第一个垂直<code>ACTION_MOVE</code>的情况下，PhotoView将提供拦截父级的机会： <br><br><img src="https://habrastorage.org/webt/j7/ea/_z/j7ea_zwmamtooghpppzcyxl-bne.png"><br><br> 以下<code>ACTION_MOVE</code>将在VerticalDragLyout中被拦截，并且<code>ACTION_CANCEL</code>事件将进入子视图： <br><br><img src="https://habrastorage.org/webt/jb/ag/tz/jbagtzmul81dakmf0nujxzumw6u.png"><br><br> 所有其他<code>ACTION_MOVE</code>将沿着标准链飞行到VerticalDragLayout。 重要的是，在ViewGroup从子View接管事件的控制之后，子View无法重新获得控制。 <br><br><img src="https://habrastorage.org/webt/ud/ql/yv/udqlyv7d4-aigffi5hdwypwfy5u.png"><br><br> 因此，我们实现了滑动以取消对PhotoView库的支持。 在我们的库中，我们使用了在单独的模块中取出的经过修改的PhotoView源，并在原始PhotoView存储库中创建了<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">合并请求</a> 。 <br><br></p><h3 id="realizuem-debauns-v-photoview"> 我们在PhotoView中实现绑定 </h3><br><p> 回想一下，当图像缩放超出其限制时，防抖动是一种可接受比例的动画恢复。 <br><br><img src="https://habrastorage.org/webt/op/rv/wb/oprvwbemhg9ikmrm1zfv45w6fvo.gif"><br><br>  PhotoView中没有这种可能性。 但是，既然我们开始研究别人的开源，为什么要停在那里？ 在PhotoView中，您可以设置缩放限制。 最初，这是最小值-x1，最大值-x3。 图像不能超出这些限制。 </p><br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onScale</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> scaleFactor, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> focusX, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> focusY)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((getScale() &lt; mMaxScale || scaleFactor &lt; <span class="hljs-number"><span class="hljs-number">1f</span></span>) &amp;&amp; (getScale() &gt; mMinScale || scaleFactor &gt; <span class="hljs-number"><span class="hljs-number">1f</span></span>)) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (mScaleChangeListener != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { mScaleChangeListener.onScaleChange(scaleFactor, focusX, focusY); } mSuppMatrix.postScale(scaleFactor, scaleFactor, focusX, focusY); <span class="hljs-comment"><span class="hljs-comment">//      checkAndDisplayMatrix(); } }</span></span></code> </pre> <br><p> 首先，我们决定删除“达到最小比例时禁止缩放”的条件：我们简单地抛出条件<code>getScale() &gt; mMinScale || scaleFactor &gt; 1f</code>  <code>getScale() &gt; mMinScale || scaleFactor &gt; 1f</code> 。 然后突然... <br><br><img src="https://habrastorage.org/webt/z_/ra/xg/z_raxgeezaf7o0h0zprufgrtggq.jpeg"><br><br> 德邦赚了！ 显然，发生这种情况的原因是该库的创建者决定对其进行两次安全播放，这既导致了反跳，又限制了缩放。 在onTouch事件的实现中，即在MotionEvent.ACTION_UP的情况下，如果用户缩放的比例大于/小于最大值/最小值， <a href="">则会</a>启动<a href="">AnimatedZoomRunnable</a> ，这会将图像恢复为其原始大小。 </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onTouch</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(View v, MotionEvent ev)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">boolean</span></span> handled = <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (ev.getAction()) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> MotionEvent.ACTION_UP: <span class="hljs-comment"><span class="hljs-comment">// If the user has zoomed less than min scale, zoom back // to min scale if (getScale() &lt; mMinScale) { RectF rect = getDisplayRect(); if (rect != null) { v.post(new AnimatedZoomRunnable(getScale(), mMinScale, rect.centerX(), rect.centerY())); handled = true; } } else if (getScale() &gt; mMaxScale) { RectF rect = getDisplayRect(); if (rect != null) { v.post(new AnimatedZoomRunnable(getScale(), mMaxScale, rect.centerX(), rect.centerY())); handled = true; } } break; } }</span></span></code> </pre> <br><p> 除了轻扫以关闭之外，我们还在库的源代码中完成了PhotoView的确定，并创建了一个<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">拉请求</a> ，其中对原始PhotoView附加了“反跳”。 </p><br><h3 id="ispravlyaem-vnezapnyy-bag-v-photoview"> 修复PhotoView中的突然错误 </h3><br><p>  PhotoView有一个非常讨厌的错误。 当用户想要通过双击放大图像时， <del> 他患有癫痫病 </del> 图像开始缩放，可以垂直翻转180度。 即使在来自Google Play的流行应用程序中，例如在Cyan中，也可以找到此错误。 <br><br><img src="https://habrastorage.org/webt/m7/y1/hm/m7y1hmgkwqachpwst660vkrilwa.gif"><br><br> 经过长时间的搜索，我们仍然定位了该错误：有时将负scaleFactor馈入输入矩阵以进行图像缩放以进行缩放，从而导致图像翻转。 </p><br><p>  <a href="">CustomGestureDetector</a> </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onScale</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ScaleGestureDetector detector)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//  -   scaleFactor &lt; 0 //      float scaleFactor = detector.getScaleFactor(); if (Float.isNaN(scaleFactor) || Float.isInfinite(scaleFactor)) return false; //    scaleFactor   callback //      mListener.onScale(scaleFactor, detector.getFocusX(), detector.getFocusY()); return true; }</span></span></code> </pre> <br><p> 要从Android ScaleGestureDetector进行缩放， <a href="">我们</a>得到scaleFactor，其计算如下： </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">float</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getScaleFactor</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (inAnchoredScaleMode()) { <span class="hljs-comment"><span class="hljs-comment">// Drag is moving up; the further away from the gesture // start, the smaller the span should be, the closer, // the larger the span, and therefore the larger the scale final boolean scaleUp = (mEventBeforeOrAboveStartingGestureEvent &amp;&amp; (mCurrSpan &lt; mPrevSpan)) || (!mEventBeforeOrAboveStartingGestureEvent &amp;&amp; (mCurrSpan &gt; mPrevSpan)); final float spanDiff = (Math.abs(1 - (mCurrSpan / mPrevSpan)) * SCALE_FACTOR); return mPrevSpan &lt;= 0 ? 1 : scaleUp ? (1 + spanDiff) : (1 - spanDiff); } return mPrevSpan &gt; 0 ? mCurrSpan / mPrevSpan : 1; }</span></span></code> </pre> <br><p> 如果使用调试日志覆盖此方法，则可以跟踪在哪个特定变量值上获得负scaleFactor： </p><br><pre> <code class="plaintext hljs">mEventBeforeOrAboveStartingGestureEvent is true; SCALE_FACTOR is 0.5; mCurrSpan: 1075.4398; mPrevSpan 38.867798; scaleUp: false; spanDiff: 13.334586; eval result is -12.334586</code> </pre> <br><p> 怀疑他们试图通过将spanDiff乘以SCALE_FACTOR == 0.5来解决此问题。 但是，如果mCurrSpan和mPrevSpan之差超过三倍，则此解决方案将无济于事。 已经为该错误启动了<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">票证</a> ，但尚未修复。 <br><del> 拐杖 </del> 解决此问题的最简单方法是直接跳过负scaleFactor值。 在实践中，用户不会注意到图像有时放大得比平时稍差。 </p><br><h1 id="vmesto-zaklyucheniya"> 而不是结论 </h1><br><h3 id="sudba-pull-rekvestov"> 拉取请求的命运 </h3><br><p> 我们进行了本地修复，并在PhotoView中创建了最后一个“ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">拉取请求”</a> 。 尽管有些PR已经挂了一年，但我们的PR已添加到master分支中，甚至发布了新版本的PhotoView。 之后，我们决定从Android Gallery中删除本地模块，并提取正式的PhotoView来源。 为此，我必须添加对AndroidX的支持，该支持已在版本<a href="">2.1.3中</a>添加到PhotoView中。 </p><br><h3 id="gde-nayti-biblioteku"> 在哪里可以找到图书馆 </h3><br><p> 在此处查找Android Gallery库的源代码-https: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">//github.com/redmadrobot-spb/android-gallery</a>以及使用说明。 为了支持仍使用支持库的项目，我们创建了<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">android-gallery-deprecated</a>的单独版本。 但是要小心，因为在一年中，支持库将变成南瓜！ </p><br><h3 id="chto-dalshe"> 接下来是什么 </h3><br><p> 现在图书馆完全适合我们，但是在开发过程中出现了新的想法。 以下是其中一些： </p><br><ul><li> 能够以任何布局使用库，而不仅仅是单独的FragmentDialog； </li><li> 自定义用户界面的能力； </li><li> 替换Gilde和ExoPlayer的能力； </li><li> 使用某些东西代替ViewPager的能力。 </li></ul><br><h3 id="ssylki"> 参考文献 </h3><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">从稍微不同的角度来看，Android触摸系统</a> -一篇关于该主题的非常好的文章，其中包含指向其他精彩文章和视频的链接，其中详细介绍了Android触摸系统的工作原理。 </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">精通Android中的手势</a> -有关俄语中Android触摸系统的文章。 </li></ul><br><h3 id="upd">  UPD </h3><br><p> 在撰写文章时，出现了<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">FrescoImageViewer</a>开发人员的类似<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">库</a> 。 他们增加了对<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">过渡动画的</a>支持，但到目前为止，我们仅提供视频支持。  :) </p></li></ol></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN433076/">https://habr.com/ru/post/zh-CN433076/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN433064/index.html">事件管理：“您不能放弃”或放置逗号的技巧</a></li>
<li><a href="../zh-CN433066/index.html">高负荷杯＃2。 后端开发人员重新投入使用的冠军</a></li>
<li><a href="../zh-CN433070/index.html">如何从香菇中区分洗发水，从香槟中区分烤串... Elasticsearch-在商店数据库中搜索产品</a></li>
<li><a href="../zh-CN433072/index.html">如何破解Sega Dreamcast控制台复制保护</a></li>
<li><a href="../zh-CN433074/index.html">在Android项目中切换到Kotlin：提示和技巧</a></li>
<li><a href="../zh-CN433078/index.html">我们使用StockSharp图形框架编写交易机器人。 第二部分</a></li>
<li><a href="../zh-CN433082/index.html">抽走他人的帐户已成为韩国的刑事犯罪</a></li>
<li><a href="../zh-CN433084/index.html">公开课“以经典泰坦尼克号数据集为例的特征工程”</a></li>
<li><a href="../zh-CN433086/index.html">Tinkoff以及一切，一切，一切：银行的物联网，分析和监控</a></li>
<li><a href="../zh-CN433088/index.html">埃隆·马斯克（Elon Musk）：您如何看待宝马和保时捷开发的充电技术，可在3分钟内增加100公里的行驶距离</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>