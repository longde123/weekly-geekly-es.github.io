<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ‘¨ğŸ¿â€ğŸ¨ ğŸ‘¬ â¬‡ï¸ Go Bitmap Indexes: Pencarian Liar ğŸ‘¨ğŸ¾â€ğŸ¤ ğŸ£ ğŸ‘•</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Pendahuluan 
 Saya membuat laporan ini dalam bahasa Inggris di konferensi GopherCon Russia 2019 di Moskow dan di Rusia pada pertemuan di Nizhny Novgor...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Go Bitmap Indexes: Pencarian Liar</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/badoo/blog/451938/"><img src="https://habrastorage.org/webt/hg/g_/eq/hgg_eq6037im5xzqx0ibzmdyoku.jpeg"><br><br><h2>  Pendahuluan </h2><br>  Saya membuat laporan ini dalam bahasa Inggris di konferensi GopherCon Russia 2019 di Moskow dan di Rusia pada pertemuan di Nizhny Novgorod.  Ini tentang indeks bitmap - kurang umum dari B-tree, tetapi tidak kalah menarik.  Saya berbagi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">rekaman</a> pidato di konferensi dalam bahasa Inggris dan transkrip teks dalam bahasa Rusia. <br><br>  Kami akan memeriksa bagaimana indeks bitmap bekerja, ketika lebih baik, ketika lebih buruk daripada indeks lain, dan dalam hal ini jauh lebih cepat daripada mereka;  Kita akan melihat DBMS populer mana yang sudah memiliki indeks bitmap.  coba tulis sendiri di Go.  Dan untuk hidangan penutup, kami akan menggunakan perpustakaan siap pakai untuk membuat basis data khusus super cepat kami sendiri. <br><br>  Saya sangat berharap bahwa pekerjaan saya akan bermanfaat dan menarik bagi Anda.  Ayo pergi! <br><a name="habracut"></a><br><h2>  Pendahuluan </h2><br><iframe width="560" height="315" src="https://www.youtube.com/embed/WvlUH6MjUuI" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">http://bit.ly/bitmapindexes</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://github.com/mkevac/gopherconrussia2019</a> <br><br>  Halo semuanya!  Sekarang jam enam sore, kami semua sangat lelah.  Saat yang tepat untuk berbicara tentang teori membosankan dari indeks basis data, bukan?  Jangan khawatir, saya akan memiliki beberapa baris kode sumber di sana-sini.  :-) <br><br>  Jika tanpa lelucon, maka laporan itu penuh dengan informasi, dan kami tidak punya banyak waktu.  Jadi mari kita mulai. <br><img src="https://habrastorage.org/webt/ui/p9/0n/uip90nv7gann0i9cq_xqctdilh0.png"><br>  Hari ini saya akan membicarakan hal-hal berikut: <br><br><ul><li>  apa itu indeks; <br></li><li>  apa itu indeks bitmap; <br></li><li>  di mana itu digunakan dan di mana itu TIDAK digunakan dan mengapa; <br></li><li>  implementasi sederhana di Go dan sedikit perjuangan dengan kompiler; <br></li><li>  sedikit kurang sederhana, tetapi jauh lebih produktif implementasi di Go-assembler; <br></li><li>  "Masalah" indeks bitmap; <br></li><li>  implementasi yang ada. <br></li></ul><br><br><h2>  Jadi apa itu indeks? </h2><br><img src="https://habrastorage.org/webt/ig/uh/ii/iguhiixwichncqrv6gdszecwgzg.png"><br><br>  Indeks adalah struktur data terpisah yang kami pegang dan perbarui di samping data utama.  Ini digunakan untuk mempercepat pencarian.  Tanpa indeks, pencarian akan memerlukan data penuh (proses yang disebut pemindaian penuh), dan proses ini memiliki kompleksitas algoritme linear.  Tetapi database biasanya mengandung sejumlah besar data dan kompleksitas linier terlalu lambat.  Idealnya, kita akan mendapatkan logaritma atau konstanta. <br><br>  Ini adalah topik yang sangat kompleks, penuh dengan kehalusan dan kompromi, tetapi setelah melihat dekade pengembangan dan penelitian berbagai database, saya siap untuk berdebat bahwa hanya ada beberapa pendekatan yang banyak digunakan untuk membuat indeks basis data. <br><br><img src="https://habrastorage.org/webt/aa/yv/wn/aayvwnmn7tbaucc39k3x7ejolsa.png"><br><br>  Pendekatan pertama adalah mengurangi area pencarian secara hierarkis, membagi area pencarian menjadi bagian-bagian yang lebih kecil. <br><br>  Biasanya kami melakukan ini menggunakan semua jenis pohon.  Contohnya adalah kotak besar dengan bahan di lemari Anda, di mana ada kotak kecil dengan bahan dibagi dengan berbagai topik.  Jika Anda membutuhkan bahan, maka Anda mungkin akan mencarinya dalam kotak dengan kata-kata "Bahan", dan bukan dalam kotak yang bertuliskan "Kue", kan? <br><br><img src="https://habrastorage.org/webt/zk/oq/_3/zkoq_3s8yr3izbnqvgd9nxmtvyi.png"><br><br>  Pendekatan kedua adalah dengan segera memilih elemen atau kelompok elemen yang diinginkan.  Kami melakukan ini di peta hash atau dalam indeks terbalik.  Menggunakan peta hash sangat mirip dengan contoh sebelumnya, hanya sebagai ganti kotak dengan kotak di lemari Anda ada banyak kotak kecil dengan barang-barang akhir. <br><br><img src="https://habrastorage.org/webt/kv/zh/0q/kvzh0qp0teoe7h1_ixbeum9jdne.png"><br><br>  Pendekatan ketiga adalah menyingkirkan kebutuhan akan pencarian.  Kami melakukan ini menggunakan filter Bloom atau filter kukuk.  Yang pertama memberikan jawaban secara instan, menghilangkan kebutuhan untuk mencari. <br><br><img src="https://habrastorage.org/webt/ic/b2/4f/icb24fzrjaf4ntui8cymh3orj3c.png"><br><br>  Pendekatan terakhir adalah memanfaatkan sepenuhnya semua kapasitas yang diberikan besi modern kepada kita.  Inilah yang kami lakukan dalam indeks bitmap.  Ya, ketika menggunakannya, kadang-kadang kita perlu memeriksa keseluruhan indeks, tetapi kita melakukannya dengan sangat efisien. <br><br>  Seperti yang saya katakan, topik indeks basis data sangat luas dan penuh dengan kompromi.  Ini berarti bahwa kadang-kadang kita dapat menggunakan beberapa pendekatan secara bersamaan: jika kita perlu mempercepat pencarian lebih lanjut atau jika perlu untuk mencakup semua jenis pencarian yang mungkin. <br><br>  Hari ini saya akan berbicara tentang pendekatan yang paling tidak diketahui dari ini - tentang indeks bitmap. <br><br><h2>  Siapa yang harus saya bicarakan ini? </h2><br><img src="https://habrastorage.org/webt/dh/i9/-r/dhi9-rzto3wlple4rympbmrdhx4.png"><br><br>  Saya bekerja sebagai pemimpin tim di Badoo (mungkin Anda lebih tahu produk kami yang lain, Bumble).  Kami sudah memiliki lebih dari 400 juta pengguna di seluruh dunia dan banyak fitur yang terlibat dalam memilih pasangan terbaik untuk mereka.  Kami melakukan ini menggunakan layanan kustom yang menggunakan indeks bitmap juga. <br><br><h2>  Jadi apa itu indeks bitmap? </h2><br><img src="https://habrastorage.org/webt/iz/ty/tu/iztytuxzo4kzx7vyc7vwrwwslze.png"><br>  Indeks Bitmap, seperti namanya, menggunakan bitmap atau bitet untuk mengimplementasikan indeks pencarian.  Dari pandangan mata burung, indeks ini terdiri dari satu atau lebih bitmap yang mewakili entitas (seperti orang) dan properti atau parameternya (usia, warna mata, dll.), Dan dari algoritme yang menggunakan operasi bit (DAN, ATAU, BUKAN) untuk menanggapi permintaan pencarian. <br><img src="https://habrastorage.org/webt/24/20/ey/2420eyiyck6eqjz7t6xf9zs-gvq.jpeg"><br>  Kami diberitahu bahwa indeks bitmap paling cocok dan sangat produktif untuk kasus-kasus di mana ada pencarian yang menggabungkan pertanyaan di banyak kolom yang memiliki sedikit kardinalitas (bayangkan "warna mata" atau "status perkawinan" terhadap sesuatu seperti "jarak dari pusat kota" )  Tetapi nanti saya akan menunjukkan bahwa mereka bekerja dengan sempurna dalam kasus kolom dengan kardinalitas tinggi. <br><br>  Pertimbangkan contoh paling sederhana dari indeks bitmap. <br><img src="https://habrastorage.org/webt/yc/rf/1d/ycrf1dwjkvooel8tctktagyxi0a.jpeg"><br>  Bayangkan kita memiliki daftar restoran Moskow dengan properti biner seperti ini: <br><br><ul><li>  dekat metro (dekat metro); <br></li><li>  ada parkir pribadi (memiliki parkir pribadi); <br></li><li>  ada beranda (memiliki teras); <br></li><li>  Anda dapat memesan meja (menerima reservasi); <br></li><li>  cocok untuk vegetarian (ramah vegan); <br></li><li>  mahal (mahal). <br></li></ul><br><img src="https://habrastorage.org/webt/sg/oq/db/sgoqdbv90ujmnpkajxcc-8eg0eg.jpeg"><br>  Mari kita beri setiap restoran nomor seri mulai dari 0 dan mengalokasikan memori untuk 6 bitmap (satu untuk setiap karakteristik).  Kemudian kami mengisi bitmap ini, tergantung pada apakah restoran memiliki properti ini atau tidak.  Jika restoran 4 memiliki beranda, maka bit No. 4 dalam bitmap "ada beranda" akan ditetapkan ke 1 (jika tidak ada beranda, maka ke 0). <br><img src="https://habrastorage.org/webt/jl/ap/ge/jlapgeh1fk9cvapi-9gyxtlgnty.jpeg"><br>  Sekarang kami memiliki indeks bitmap sesederhana mungkin, dan kami dapat menggunakannya untuk menjawab pertanyaan seperti: <br><br><ul><li>  â€œTunjukkan pada saya restoran yang cocok untuk vegetarianâ€; <br></li><li>  "Tunjukkan padaku restoran murah dengan beranda di mana kamu dapat memesan meja." <br></li></ul><br><br><img src="https://habrastorage.org/webt/2p/wq/t7/2pwqt76nijteahvflvizdufiumy.jpeg"><br><img src="https://habrastorage.org/webt/_d/fg/wq/_dfgwq--uyewk4k_fryjd533tug.jpeg"><br>  Bagaimana?  Ayo lihat.  Permintaan pertama sangat sederhana.  Yang perlu kita lakukan hanyalah mengambil bitmap "cocok untuk vegetarian" dan mengubahnya menjadi daftar restoran yang bitnya dipajang. <br><img src="https://habrastorage.org/webt/oe/0-/hd/oe0-hd5hqr6b6unvqtdoadn3jtu.jpeg"><br><img src="https://habrastorage.org/webt/en/3r/co/en3rcomfemoy-arkj9qx3fqmveu.jpeg"><br>  Kueri kedua sedikit lebih rumit.  Kita perlu menggunakan operasi bit TIDAK pada bitmap "mahal" untuk mendapatkan daftar restoran murah, kemudian mengaturnya dengan bitmap "Anda dapat memesan meja" dan mengatur hasilnya dengan bitmap "ada beranda".  Bitmap yang dihasilkan akan berisi daftar perusahaan yang memenuhi semua kriteria kami.  Dalam contoh ini, ini hanya restoran Yunost. <br><img src="https://habrastorage.org/webt/wm/jr/f5/wmjrf5nhch2k9zriz_sfuxzqfec.jpeg"><br><img src="https://habrastorage.org/webt/si/sf/c2/sisfc2h6lro8nu4yctf96absj_u.jpeg"><br>  Ada banyak teori, tetapi jangan khawatir, kami akan segera melihat kode. <br><br><h2>  Di mana indeks bitmap digunakan? </h2><br><img src="https://habrastorage.org/webt/zu/sd/up/zusdupegzydvhacdl-wzmwytrbq.jpeg"><br>  Jika Anda "google" indeks bitmap, 90% dari jawaban entah bagaimana akan terkait dengan Oracle DB.  Tetapi sisa DBMS juga mungkin mendukung hal yang keren, kan?  Tidak juga. <br><br>  Mari kita lihat daftar tersangka utama. <br><img src="https://habrastorage.org/webt/-k/xy/zn/-kxyznvnwct15_2jzp3rulwotic.jpeg"><br>  MySQL belum mendukung indeks bitmap, tetapi ada Proposal dengan proposal untuk menambahkan opsi ini ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://dev.mysql.com/worklog/task/?id=1524</a> ). <br><br>  PostgreSQL tidak mendukung indeks bitmap, tetapi menggunakan bitmap sederhana dan operasi bit untuk menggabungkan hasil pencarian di beberapa indeks lainnya. <br><br>  Tarantool memiliki indeks bitset, mendukung pencarian sederhana pada mereka. <br><br>  Redis memiliki bidang bit sederhana <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">(https://redis.io/commands/bitfield</a> ) tanpa kemampuan untuk mencari melalui mereka. <br><br>  MongoDB belum mendukung indeks bitmap, tetapi ada juga Proposal dengan proposal untuk menambahkan opsi ini <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://jira.mongodb.org/browse/SERVER-1723</a> <br><br>  Elasticsearch menggunakan bitmap di dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">(https://www.elastic.co/blog/frame-of-reference-and-roaring-bitmaps</a> ). <br><br><br><img src="https://habrastorage.org/webt/kv/rd/zo/kvrdzoime8mqrf1vtl_iqwgjaea.jpeg"><br><br><ul><li>  Tetapi tetangga baru muncul di rumah kami: Pilosa.  Ini adalah basis data non-relasional baru yang ditulis dalam Go.  Ini hanya berisi indeks bitmap dan mendasarkan semuanya pada mereka.  Kami akan membicarakannya nanti. <br></li></ul><br><br><h2>  Go implementasi </h2><br>  Tetapi mengapa indeks bitmap sangat jarang digunakan?  Sebelum menjawab pertanyaan ini, saya ingin menunjukkan kepada Anda penerapan indeks bitmap yang sangat sederhana di Go. <br><img src="https://habrastorage.org/webt/db/ua/jt/dbuajtkgolu346p22gzcufwsll4.jpeg"><br>  Bitmap pada dasarnya hanya potongan data.  Di Go, mari gunakan irisan byte untuk ini. <br><br>  Kami memiliki satu bitmap per karakteristik restoran, dan setiap bit dalam bitmap menunjukkan apakah restoran tertentu memiliki properti ini atau tidak. <br><img src="https://habrastorage.org/webt/j2/az/1i/j2az1inrzzj0rcdg9dajst7afhc.jpeg"><br>  Kita akan membutuhkan dua fungsi bantu.  Satu akan digunakan untuk mengisi bitmap kami dengan data acak.  Acak, tetapi dengan probabilitas tertentu bahwa restoran memiliki setiap properti.  Sebagai contoh, saya percaya bahwa ada sangat sedikit restoran di Moskow di mana Anda tidak dapat memesan meja, dan bagi saya tampaknya sekitar 20% dari perusahaan cocok untuk vegetarian. <br><br>  Fungsi kedua akan mengkonversi bitmap ke daftar restoran. <br><img src="https://habrastorage.org/webt/aj/d7/vg/ajd7vgvjt7_2ssgiw7hh2jue9vu.jpeg"><br><img src="https://habrastorage.org/webt/gl/nv/wv/glnvwvokatnkyd08nxslinseoyc.jpeg"><br>  Untuk menjawab permintaan "Tunjukkan restoran murah yang memiliki beranda dan tempat Anda dapat memesan meja", kami membutuhkan dua operasi bit: BUKAN dan DAN. <br><br>  Kita dapat menyederhanakan kode kita sedikit dengan menggunakan operasi yang lebih kompleks DAN TIDAK. <br><br>  Kami memiliki fungsi untuk masing-masing operasi ini.  Keduanya melalui irisan, mengambil elemen yang sesuai dari masing-masing, menggabungkannya dengan operasi bit dan menempatkan hasilnya dalam irisan yang dihasilkan. <br><img src="https://habrastorage.org/webt/_f/-m/wa/_f-mwakzpgavqkr_a6m3lzzo_gy.jpeg"><br>  Dan sekarang kita dapat menggunakan bitmap dan fungsi kita untuk menanggapi permintaan pencarian. <br><img src="https://habrastorage.org/webt/rp/tn/uq/rptnuqmitwu5f-ag2w4tquglhca.jpeg"><br>  Performanya tidak terlalu tinggi, walaupun faktanya fungsi-fungsinya sangat sederhana dan kami cukup menghemat fakta bahwa kami tidak mengembalikan irisan baru yang dihasilkan setiap kali fungsi dipanggil. <br><br>  Setelah diprofilkan sedikit dengan pprof, saya perhatikan bahwa kompiler Go melewatkan satu optimasi yang sangat sederhana, tetapi sangat penting: fungsi inlining. <br><img src="https://habrastorage.org/webt/4s/6j/vs/4s6jvsys1nnmrpxnzpyfed8myq8.jpeg"><br>  Faktanya adalah bahwa kompilator Go sangat takut pada loop yang melewati irisan, dan pasti menolak fungsi inline yang berisi loop. <br><img src="https://habrastorage.org/webt/ok/e_/th/oke_thx54xevzrxjqc6fmqx8w5y.jpeg"><br>  Tapi saya tidak takut, dan saya bisa membodohi kompiler dengan menggunakan goto bukannya loop, seperti di masa lalu yang baik. <br><br><img src="https://habrastorage.org/webt/bx/xo/ea/bxxoeatd8s3mby2jyemkac3jyfg.jpeg"><br><img src="https://habrastorage.org/webt/5k/fm/2l/5kfm2let9qh2ynkerqdkkd1thao.jpeg"><br><br>  Dan, seperti yang Anda lihat, sekarang kompiler dengan senang hati menguraikan fungsi kami!  Akibatnya, kami berhasil menghemat sekitar 2 mikrodetik.  Tidak buruk! <br><br><img src="https://habrastorage.org/webt/or/tx/lw/ortxlwhbagw4oafvij-sngkxbsm.jpeg"><br><br>  Kemacetan kedua mudah dilihat jika Anda dengan cermat melihat output assembler.  Kompilator telah menambahkan pengecekan slice bound tepat di dalam loop terpanas kami.  Faktanya adalah bahwa Go adalah bahasa yang aman, kompiler takut bahwa tiga argumen saya (tiga irisan) memiliki ukuran yang berbeda.  Setelah semua, maka akan ada kemungkinan teoritis tentang penampilan buffer overflow. <br><br>  Mari meyakinkan kompiler dengan menunjukkan kepadanya bahwa semua irisan memiliki ukuran yang sama.  Kita dapat melakukan ini dengan menambahkan cek sederhana di awal fungsi kita. <br><img src="https://habrastorage.org/webt/rq/v7/en/rqv7enj1mgqnsrgwnlkwscks0ri.jpeg"><br>  Melihat ini, kompiler dengan senang hati melewatkan tes, dan kami akhirnya menghemat 500 nanodetik lagi. <br><br><h2>  Batch besar </h2><br>  Oke, kami berhasil memeras beberapa kinerja dari implementasi sederhana kami, tetapi hasil ini, pada kenyataannya, jauh lebih buruk daripada yang mungkin dengan perangkat keras saat ini. <br><br>  Yang kami lakukan hanyalah operasi bit dasar, dan prosesor kami melakukannya dengan sangat efisien.  Namun, sayangnya, kami â€œmemberi makanâ€ prosesor kami dengan pekerjaan yang sangat kecil.  Fungsi kami melakukan operasi byte demi byte.  Kita dapat dengan mudah menyetel kode kita sehingga berfungsi dengan potongan 8-byte menggunakan irisan UInt64. <br><br><img src="https://habrastorage.org/webt/-w/vl/rd/-wvlrdx24mrcvy_vovvjeouaxjs.jpeg"><br><br>  Seperti yang Anda lihat, perubahan kecil ini telah mempercepat program kami sebanyak delapan kali karena peningkatan batch sebanyak delapan kali.  Keuntungannya bisa dikatakan linear. <br><br><img src="https://habrastorage.org/webt/tf/ej/nk/tfejnkdoftg8gs7vfpgrmbxfejq.jpeg"><br><h2>  Implementasi Assembler </h2><br><img src="https://habrastorage.org/webt/ii/3d/du/ii3ddup__yc_-dhzsuivs6fcpeu.jpeg"><br>  Tapi ini bukan akhirnya.  Prosesor kami dapat bekerja dengan potongan 16, 32 dan bahkan 64 byte.  Operasi "lebar" seperti itu disebut instruksi tunggal banyak data (SIMD; satu instruksi, banyak data), dan proses transformasi kode sehingga menggunakan operasi tersebut disebut vektorisasi. <br><br>  Sayangnya, kompiler Go jauh dari siswa yang sangat baik dalam vektorisasi.  Saat ini, satu-satunya cara untuk membuat vektor kode di Go adalah dengan mengambil dan menempatkan operasi ini secara manual menggunakan assembler Go. <br><br><img src="https://habrastorage.org/webt/qv/dr/ap/qvdrapgfhvfhrei2ies1w2vtcds.jpeg"><br><br>  Assembler Go adalah binatang buas yang aneh.  Anda mungkin tahu assembler adalah sesuatu yang sangat terkait dengan arsitektur komputer yang Anda tulis, tetapi ini tidak terjadi dengan Go.  Assembler Go lebih mirip IRL (bahasa representasi perantara) atau bahasa perantara: praktis tidak tergantung platform.  Rob Pike membuat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">presentasi yang</a> sangat baik tentang masalah ini beberapa tahun yang lalu di GopherCon di Denver. <br><br>  Selain itu, Go menggunakan format Plan 9 yang tidak biasa, yang berbeda dari format AT&amp;T dan Intel yang diakui secara umum. <br><img src="https://habrastorage.org/webt/kp/8r/px/kp8rpxg_xmp3faph2ysefnjavxk.jpeg"><br>  Aman untuk mengatakan bahwa menulis Go assembler secara manual bukanlah kegiatan yang paling menyenangkan. <br><br>  Tapi, untungnya, sudah ada dua alat tingkat tinggi yang membantu kita menulis Go assembler: PeachPy dan avo.  Kedua utilitas menghasilkan assembler Go dari kode level yang lebih tinggi yang ditulis dengan Python dan Go, masing-masing. <br><img src="https://habrastorage.org/webt/mf/qz/zb/mfqzzbyuqtrdk06iiiw4ufe5eou.jpeg"><br>  Utilitas ini menyederhanakan hal-hal seperti alokasi register, siklus penulisan, dan umumnya menyederhanakan proses memasuki dunia pemrograman assembler di Go. <br><br>  Kami akan menggunakan avo, sehingga program kami akan menjadi program Go yang hampir normal. <br><img src="https://habrastorage.org/webt/qd/ij/l2/qdijl2s77ub_c1om5budqbudjx4.jpeg"><br>  Inilah contoh paling sederhana dari program avo.  Kami memiliki fungsi utama () yang mendefinisikan fungsi Tambah () di dalam dirinya, artinya menambahkan dua angka.  Ada fungsi tambahan untuk mendapatkan parameter dengan nama dan mendapatkan salah satu register prosesor yang gratis dan cocok.  Setiap operasi prosesor memiliki fungsi terkait pada avo, seperti terlihat pada ADDQ.  Akhirnya, kita melihat fungsi pembantu untuk menyimpan nilai yang dihasilkan. <br><img src="https://habrastorage.org/webt/8q/ze/6_/8qze6_requgfy9fimtn5tiirtn8.jpeg"><br>  Dengan memanggil go menghasilkan, kami akan menjalankan program pada avo dan pada akhirnya dua file akan dihasilkan: <br><br><ul><li>  add.s dengan kode assembler Go yang dihasilkan; <br></li><li>  stub.go dengan header fungsi untuk menghubungkan dua dunia: Pergi dan assembler. <br></li></ul><br><img src="https://habrastorage.org/webt/mz/bk/pi/mzbkpixqbe5kygtl9vphoeak39w.jpeg"><br>  Sekarang kita telah melihat apa dan bagaimana avo lakukan, mari kita lihat fungsi kita.  Saya menerapkan versi fungsi skalar dan vektor (SIMD). <br><br>  Pertama, lihat versi skalar. <br><img src="https://habrastorage.org/webt/9v/1a/gj/9v1agjswpb-wnfoyqbb1x0rb6vo.jpeg"><br>  Seperti dalam contoh sebelumnya, kami meminta Anda untuk memberikan kepada kami register tujuan umum yang bebas dan benar, kami tidak perlu menghitung offset dan ukuran untuk argumen.  Semua ini berlaku untuk kita. <br><img src="https://habrastorage.org/webt/rt/yj/ju/rtyjjuzuc4ycx2au4tqohzaxsby.jpeg"><br>  Sebelumnya kami menggunakan label dan goto (atau lompatan) untuk meningkatkan kinerja dan untuk mengelabui kompiler Go, tetapi sekarang kami melakukannya dari awal.  Faktanya adalah bahwa loop adalah konsep level yang lebih tinggi.  Di assembler, kami hanya memiliki label dan lompatan. <br><img src="https://habrastorage.org/webt/c4/gk/ww/c4gkwwdt0to9yorwoya2jurfrj8.jpeg"><br>  Kode yang tersisa harus sudah familier dan mudah dimengerti.  Kami meniru loop dengan label dan lompatan, mengambil sebagian kecil data dari dua irisan kami, menggabungkannya dengan operasi bit (DAN TIDAK dalam kasus ini), dan kemudian memasukkan hasilnya dalam irisan yang dihasilkan.  Itu saja. <br><img src="https://habrastorage.org/webt/vw/gj/fg/vwgjfg2tkeaxec2n7qkvgneqpve.jpeg"><br>  Inilah yang terlihat seperti kode assembler akhir.  Kami tidak perlu menghitung offset dan ukuran (disorot dengan warna hijau) atau melacak register yang digunakan (disorot dengan warna merah). <br><img src="https://habrastorage.org/webt/of/sc/4v/ofsc4vbjkv2imcihypew4_japuo.jpeg"><br>  Jika kita membandingkan kinerja implementasi assembler dengan kinerja implementasi terbaik di Go, kita akan melihat bahwa itu sama.  Dan itu diharapkan.  Lagi pula, kami tidak melakukan sesuatu yang istimewa - kami hanya mereproduksi apa yang akan dilakukan oleh kompiler Go. <br><br>  Sayangnya, kami tidak dapat memaksa kompiler untuk menampilkan fungsi kami yang ditulis dalam assembler.  Kompiler Go tidak memiliki fitur ini hari ini, walaupun permintaan untuk menambahkannya sudah ada cukup lama. <br><br>  Itu sebabnya tidak mungkin untuk mendapatkan manfaat dari fungsi kecil di assembler.  Kita perlu menulis fungsi besar, atau menggunakan paket matematika / bit baru, atau memotong sisi assembler. <br><br>  Sekarang mari kita lihat versi vektor dari fungsi kita. <br><img src="https://habrastorage.org/webt/ac/qe/bs/acqebsweofbwzmvcwt-vro9yx4m.jpeg"><br>  Untuk contoh ini, saya memutuskan untuk menggunakan AVX2, jadi kami akan menggunakan operasi yang bekerja dengan potongan 32-byte.  Struktur kode sangat mirip dengan opsi skalar: memuat parameter, berikan kami daftar umum gratis, dll. <br><img src="https://habrastorage.org/webt/ef/5g/wa/ef5gwafb0stn7wunw8ryjcjyt_k.jpeg"><br>  Salah satu inovasi adalah bahwa operasi vektor yang lebih luas menggunakan register lebar khusus.  Dalam kasus potongan 32-byte, ini adalah register dengan awalan Y. Itulah sebabnya Anda melihat fungsi YMM () dalam kode.  Jika saya menggunakan AVX-512 dengan potongan 64-bit, awalannya adalah Z. <br><br>  Inovasi kedua adalah saya memutuskan untuk menggunakan optimasi yang disebut loop unrolling, yaitu, melakukan delapan operasi loop secara manual sebelum melompat ke awal loop.  Pengoptimalan ini mengurangi jumlah brunch (cabang) dalam kode, dan dibatasi oleh jumlah register gratis yang tersedia. <br><img src="https://habrastorage.org/webt/vj/1c/nd/vj1cndpc9uqyrzgfqrld4vfda5o.jpeg"><br>  Nah, bagaimana dengan kinerja?  Dia cantik!  Kami mendapat akselerasi sekitar tujuh kali dibandingkan dengan solusi terbaik di Go.  Mengesankan, ya? <br><img src="https://habrastorage.org/webt/d_/9b/ag/d_9bag_w0set74ryc4j5oqm5slm.jpeg"><br>  Tetapi bahkan implementasi ini berpotensi dipercepat dengan menggunakan AVX-512, prefetching atau JIT (just-in-time compiler) untuk perencana kueri.  Tetapi ini tentu saja merupakan topik untuk laporan terpisah. <br><br><h2>  Masalah Indeks Bitmap </h2><br>  Sekarang kita telah melihat implementasi sederhana dari indeks bitmap Go dan bahasa assembly yang jauh lebih efisien, mari kita bicara tentang mengapa indeks bitmap sangat jarang digunakan. <br><img src="https://habrastorage.org/webt/qs/yf/as/qsyfasqoxbr_heaolyqpd9ms7hk.jpeg"><br>  Dalam makalah ilmiah lama, tiga masalah indeks bitmap disebutkan, tetapi makalah ilmiah baru dan saya berpendapat bahwa mereka tidak lagi relevan.  Kami tidak akan mempelajari secara mendalam masing-masing masalah ini, tetapi kami akan mempertimbangkannya secara dangkal. <br><br><h2>  Masalah kardinalitas yang hebat </h2><br>  Jadi, kita diberitahu bahwa indeks bitmap hanya cocok untuk bidang dengan kardinalitas rendah, yaitu yang memiliki sedikit nilai (misalnya, jenis kelamin atau warna mata), dan alasannya adalah bahwa representasi biasa bidang tersebut (satu bit per nilai) dalam kasus kardinalitas besar, itu akan memakan terlalu banyak ruang dan, lebih lagi, indeks bitmap ini akan lemah (jarang) diisi. <br><img src="https://habrastorage.org/webt/zf/na/lt/zfnaltbokwrnweeiwtighgvq5cm.jpeg"><br><img src="https://habrastorage.org/webt/sa/p4/mw/sap4mwjq8sslx6_zgdanmn8fcwu.jpeg"><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Terkadang kita dapat menggunakan representasi lain, misalnya yang standar, yang kita gunakan untuk mewakili angka. </font><font style="vertical-align: inherit;">Tetapi munculnya algoritma kompresi yang mengubah segalanya. </font><font style="vertical-align: inherit;">Selama beberapa dekade terakhir, para ilmuwan dan peneliti telah menghasilkan sejumlah besar algoritma kompresi untuk bitmap. </font><font style="vertical-align: inherit;">Keuntungan utama mereka adalah Anda tidak perlu memperluas bitmap untuk operasi bit - kami dapat melakukan operasi bit secara langsung pada bitmap terkompresi. </font></font><br><img src="https://habrastorage.org/webt/mv/56/bt/mv56btwi703wsb0nya7ofor5lew.jpeg"><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Baru-baru ini, pendekatan hybrid sudah mulai muncul, seperti bitmap menderu. </font><font style="vertical-align: inherit;">Mereka secara bersamaan menggunakan tiga representasi berbeda untuk bitmap - sebenarnya bitmap, array dan yang disebut bit run - dan menyeimbangkan di antara mereka untuk memaksimalkan kinerja dan meminimalkan konsumsi memori.</font></font><br><br>    roaring     .          ,        Go. <br><img src="https://habrastorage.org/webt/af/xy/wy/afxywyhipsvsfla4tuot6ir0tei.jpeg"><br>   ,        ,   (binning). ,     ,   .  â€”     ,  , ,       .       185,2   185,3 . <br><br> ,          1 . <br><br>      ,        50    250 ,   ,  ,            200 . <br><br> ,         . <br><br><h2>     </h2><br>   bitmap-   ,       . <br><br>          ,          .   ,             .  ,     ,    â€” lock contention,      . <br><img src="https://habrastorage.org/webt/xg/ju/xl/xgjuxll8jn3btfxhniispsepbmw.jpeg"><br>             . <br><br>  â€”    .    bitmap- ,       .               lock contention. <br><br>     â€”    .       ,       ,   â€”    .    -   (,   100   500 )      . ,       ,          . <br><br>      :       . <br><br><h2>    </h2><br><br>   bitmap-   , ,   ,        ,   Â« Â». <br><br>  ,  ,    AND, OR  . .      - Â«       200  300   Â». <br><img src="https://habrastorage.org/webt/fq/qy/en/fqqyeneeggnmx0iccptaz8eygmm.jpeg"><br>                   OR. <br><img src="https://habrastorage.org/webt/jr/du/ey/jrdueypemf_a69m1wikbjpialze.jpeg"><br>        . ,    50 .       50 . <br><br>       ,      .      range-encoded bitmaps. <br><img src="https://habrastorage.org/webt/vq/hx/a5/vqhxa5jyy4w9_e5lurbjhntabie.jpeg"><br>           -  (, 200),      ,  . 200  .     300: 300  .  Dan sebagainya. <br><br>   ,        ,      .     ,      300 ,      ,      199 .  Selesai <br><img src="https://habrastorage.org/webt/wh/bc/hs/whbchsdcr0qrupa6jhu9fcpufke.jpeg"><br>  ,       bitmap-.   ,   ,      . , S2  Google.            ,   .           Â« Â» (   ). <br><br><h2>  Solusi siap pakai </h2><br>               .   -    - ,   ,    . <br><br>      ,   ,   bitmap-  .   ,   SIMD, . <br><br>  ,    ,   . <br><img src="https://habrastorage.org/webt/em/cg/km/emcgkmutgbpdj_arrdnfoub6lt0.jpeg"><br><h2> Roaring  </h2><br> -,    roaring bitmaps-,     .        ,     ,    bitmap-. <br><img src="https://habrastorage.org/webt/k3/mv/yh/k3mvyhvcdb8sh7g-aejhgqeob6c.jpeg"><br>  ,       Go-   SIMD,  , Go-  ,    C, . <br><br><h2> Pilosa </h2><br>  ,    , â€”  Pilosa,  ,  ,  bitmap-  .    ,       . <br><img src="https://habrastorage.org/webt/uw/gs/56/uwgs563qvexzg27dd5x15zbzlto.jpeg"><br> Pilosa  roaring         ,      ,     : , range-encoded bitmaps,    . . <br><br>       Pilosa       . <br><img src="https://habrastorage.org/webt/8d/jm/kn/8djmknf2jltazwrepy_ia4j7k_4.jpeg"><br>     ,    .      Pilosa,     ,         , ,   . <br><br>     NOT   Â«expensiveÂ»,    ( AND-)   Â«terraceÂ»    Â«reservationsÂ».  ,   . <br><img src="https://habrastorage.org/webt/bg/bu/oi/bgbuoi1v8n8vus4einuldy4u8zu.jpeg"><br>   ,        MySQL  PostgreSQL       â€” bitmap-. <br><img src="https://habrastorage.org/webt/ez/h4/g1/ezh4g1de2gpbozwi8-yubjvhpp4.jpeg"><br><h2>  Kesimpulan </h2><br><img src="https://habrastorage.org/webt/tp/0f/3v/tp0f3vktlhcltdxbu7fatn7qqhq.jpeg"><br>  Jika Anda belum tertidur, terima kasih.  Saya harus menyinggung banyak topik secara sepintas karena keterbatasan waktu, tetapi saya berharap laporan ini bermanfaat dan, mungkin, bahkan memotivasi. <br><br>  Adalah baik untuk mengetahui tentang indeks bitmap, bahkan jika Anda tidak membutuhkannya sekarang.  Biarkan mereka menjadi alat lain di laci Anda. <br><br>  Kami telah membahas berbagai trik kinerja untuk Go dan hal-hal yang tidak dilakukan dengan baik oleh kompiler Go.  Tetapi ini sangat berguna untuk diketahui oleh setiap programmer Go. <br><br>  Hanya itu yang ingin saya sampaikan.  Terima kasih </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id451938/">https://habr.com/ru/post/id451938/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id451928/index.html">Cara mengatur analitik web pada halaman AMP</a></li>
<li><a href="../id451930/index.html">Otomatisasi pencahayaan tangga</a></li>
<li><a href="../id451932/index.html">PHDays 9: Selamat datang di Bagian Pengembangan Aman</a></li>
<li><a href="../id451934/index.html">Alexander Lamden: "Setiap potongan besi memiliki karakter"</a></li>
<li><a href="../id451936/index.html">Mencari Kerentanan dalam Browser UC</a></li>
<li><a href="../id451942/index.html">Bagaimana mengoceh di Afrika menyelamatkan ribuan nyawa</a></li>
<li><a href="../id451944/index.html">2019: Tahun DEX (Pertukaran Terdesentralisasi)</a></li>
<li><a href="../id451948/index.html">Kisah tiga katrid</a></li>
<li><a href="../id451950/index.html">Pembangkit listrik virtual. Apakah mungkin untuk mengelola sumber energi "hijau"?</a></li>
<li><a href="../id451954/index.html">Lebih Banyak Telegram Rahasia</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>