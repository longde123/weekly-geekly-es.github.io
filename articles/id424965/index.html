<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ· ğŸ‘› ğŸ§‘ğŸ¾â€ğŸ¤â€ğŸ§‘ğŸ½ Bereaksi Pengembangan Aplikasi Menggunakan ReasonReact ğŸ‘ˆğŸ¼ ğŸ‘©â€ğŸ‘¦â€ğŸ‘¦ ğŸ‘ğŸ½</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Apakah Anda menggunakan Bereaksi untuk membuat antarmuka pengguna? Penulis materi, terjemahan yang kami terbitkan, mengatakan bahwa ia juga bekerja de...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Bereaksi Pengembangan Aplikasi Menggunakan ReasonReact</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/424965/">  Apakah Anda menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bereaksi</a> untuk membuat antarmuka pengguna?  Penulis materi, terjemahan yang kami terbitkan, mengatakan bahwa ia juga bekerja dengan React.  Di sini dia ingin berbicara tentang mengapa <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ReasonML</a> layak ditulis untuk aplikasi Bereaksi. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><img src="https://habrastorage.org/getpro/habr/post_images/e6a/7fb/319/e6a7fb319e17959ec7820b51e2d6538f.jpg"></a> <br><br>  React adalah alat pengembangan antarmuka yang sangat bagus.  Bisakah Anda membuatnya lebih baik?  Untuk meningkatkan pekerjaan Anda dengan React, Anda harus terlebih dahulu memahami masalah utamanya.  Secara khusus, masalah yang asal-usulnya terletak pada fakta bahwa Bereaksi adalah perpustakaan JavaScript. <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">Bereaksi dan JavaScript</font> </h2><br>  Jika Anda melihat dengan cermat pada Bereaksi, Anda akan melihat bahwa beberapa prinsip yang mendasari perpustakaan ini asing bagi JavaScript.  Secara khusus, kita berbicara tentang kekekalan, tentang prinsip-prinsip pemrograman fungsional dan tentang sistem tipe. <br><br>  Kekebalan adalah salah satu prinsip dasar Bereaksi.  Mutasi pada sifat-sifat komponen atau keadaan aplikasi sangat tidak diinginkan, karena ini dapat menyebabkan konsekuensi yang tidak terduga.  JavaScript tidak memiliki mekanisme standar untuk memberikan kekebalan.  Struktur data dibuat tidak berubah baik dengan mematuhi konvensi tertentu atau dengan menggunakan perpustakaan seperti <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">immutable-js</a> . <br><br>  Pustaka React didasarkan pada prinsip-prinsip pemrograman fungsional, karena aplikasi Bereaksi adalah komposisi fungsi.  Meskipun JavaScript memiliki beberapa fitur pemrograman fungsional, seperti fungsi kelas satu, ini bukan bahasa pemrograman fungsional.  Jika Anda perlu menulis kode deklaratif yang baik dalam JavaScript, Anda harus menggunakan perpustakaan pihak ketiga seperti <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Lodash / fp</a> atau <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Ramda</a> . <br><br>  Apa yang salah dengan sistem jenisnya?  React memiliki konsep <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">PropTypes</a> .  Ini digunakan untuk mensimulasikan tipe dalam JavaScript, karena bahasa ini sendiri tidak diketik secara statis.  Untuk memanfaatkan mengetik statis di JS, sekali lagi, Anda harus menggunakan alat pihak ketiga seperti <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Flow</a> dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">TypeScript</a> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f27/b1b/136/f27b1b136262168696ea82470b66cd3d.jpg"></div><br>  <i><font color="#999999">Bandingkan Bereaksi dan JavaScript</font></i> <br><br>  Seperti yang Anda lihat, JavaScript tidak kompatibel dengan prinsip dasar Bereaksi. <br><br>  Apakah ada bahasa pemrograman yang lebih baik daripada JavaScript yang konsisten dengan Bereaksi? <br>  Anda dapat memberikan jawaban positif untuk pertanyaan ini.  Bahasa ini adalah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ReasonML</a> . <br><br>  Nalar menerapkan kekekalan.  Karena didasarkan pada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">OCaml</a> , bahasa pemrograman fungsional, fitur yang sesuai juga dibangun ke dalam Alasan.  Bahasa ini juga memiliki sistem tipenya sendiri yang cocok untuk Bereaksi. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a83/a37/41e/a83a3741e3cdfac7139203f491e4f06d.jpg"></div><br>  <i><font color="#999999">Bandingkan Bereaksi, JavaScript, dan Alasan</font></i> <br><br>  Ternyata Alasan itu kompatibel dengan prinsip dasar Bereaksi. <br><br><h2>  <font color="#3AC1EF">Alasan</font> </h2><br>  Nalar bukan bahasa baru.  Ini adalah alternatif, sintaks seperti JavaScript dan toolkit untuk OCaml, bahasa pemrograman fungsional yang telah ada selama lebih dari 20 tahun.  Reason dibuat oleh pengembang dari Facebook yang sudah menggunakan OCaml dalam proyek mereka ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Flow</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Infer</a> ). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c95/e30/c30/c95e30c30a5de6bb24b079dbfdb667a4.jpg"></div><br>  <i><font color="#999999">OCaml</font></i> <br><br>  Sintaks seperti C dari Reason membuat OCaml tersedia untuk programmer yang terbiasa dengan bahasa umum seperti JavaScript atau Java.  Reason memberi pengembang dokumentasi yang lebih baik daripada OCaml, dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">komunitas</a> penggemar yang terus berkembang berkembang di sekitarnya.  Selain itu, apa yang ditulis dalam Alasan mudah untuk diintegrasikan dengan proyek JS yang ada. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a05/501/393/a05501393404c126b3a9164d346b6cc7.jpg"></div><br>  <i><font color="#999999">Alasan</font></i> <br><br>  Inti dari Alasan adalah OCaml.  Alasan memiliki semantik yang sama dengan OCaml, hanya sintaks yang berbeda.  Ini berarti bahwa Alasan memungkinkan untuk menulis kode OCaml menggunakan sintaksis mirip-JavaScript.  Akibatnya, programmer memiliki fitur OCaml yang luar biasa seperti sistem tipe ketat dan mekanisme pencocokan pola. <br><br>  Lihatlah potongan kode Alasan untuk membiasakan diri dengan sintaksnya. <br><br><pre><code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> fizzbuzz = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">i</span></span></span><span class="hljs-function">) =&gt;</span></span>  <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (i mod <span class="hljs-number"><span class="hljs-number">3</span></span>, i mod <span class="hljs-number"><span class="hljs-number">5</span></span>) {  | <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0</span></span></span></span></span><span class="hljs-function">) =&gt;</span></span> <span class="hljs-string"><span class="hljs-string">"FizzBuzz"</span></span>  | <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0</span></span></span></span><span class="hljs-function"><span class="hljs-params">, _</span></span></span><span class="hljs-function">) =&gt;</span></span> <span class="hljs-string"><span class="hljs-string">"Fizz"</span></span>  | <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">_, </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0</span></span></span></span></span><span class="hljs-function">) =&gt;</span></span> <span class="hljs-string"><span class="hljs-string">"Buzz"</span></span>  | <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">_</span></span></span><span class="hljs-function"> =&gt;</span></span> string_of_int(i)  }; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> to <span class="hljs-number"><span class="hljs-number">100</span></span>) {  Js.log(fizzbuzz(i)) };</code> </pre> <br>  Meskipun pola ini menggunakan mekanisme pencocokan pola, itu tetap sangat mirip dengan JavaScript. <br><br>  Satu-satunya bahasa yang berfungsi di browser adalah JavaScript, oleh karena itu, untuk menulis untuk browser dalam bahasa apa pun, kita perlu mengompilasinya dalam JavaScript. <br><br><h2>  <font color="#3AC1EF">BuckleScript</font> </h2><br>  Salah satu fitur Reason yang paling menarik dapat disebut kompiler BuckleScript, yang mengambil kode yang ditulis dalam Reason dan mengubahnya menjadi kode JS yang mudah dibaca dan produktif, di samping itu, juga membersihkannya dari konstruksi yang tidak digunakan. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f6c/075/e17/f6c075e172668e85e291b39f468a57c1.png"></div><br>  <i><font color="#999999">BuckleScript</font></i> <br><br>  Keterbacaan hasil BuckleScript akan berguna jika Anda bekerja di tim yang tidak semua orang kenal Alasan.  Orang-orang ini, setidaknya, akan dapat membaca kode JS yang dihasilkan. <br><br>  Kode alasan terkadang sangat mirip dengan kode JS sehingga kompiler tidak perlu mengubahnya sama sekali.  Dengan keadaan ini, Anda dapat menikmati manfaat dari pengetikan dan penulisan kode statis Reason yang sepertinya ditulis dalam JavaScript. <br><br>  Berikut adalah contoh kode yang berfungsi baik di Alasan dan JavaScript: <br><br><pre> <code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">add</span></span> = (a, b) =&gt; a + b; <span class="hljs-keyword"><span class="hljs-keyword">add</span></span>(<span class="hljs-number"><span class="hljs-number">6</span></span>, <span class="hljs-number"><span class="hljs-number">9</span></span>);</code> </pre> <br>  BuckleScript hadir dengan empat pustaka.  Ini adalah perpustakaan standar yang disebut <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Sabuk</a> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pustaka standar OCaml</a> tidak cukup di sini), dan binding untuk JavaScript, Node.js, dan DOM API. <br><br>  Karena BuckleScript didasarkan pada kompiler OCaml, kompilasi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sangat cepat</a> - jauh lebih cepat daripada Babel dan beberapa kali lebih cepat daripada TypeScript. <br><br>  Menggunakan BuckleScript, kami mengkompilasi fragmen kode Alasan di atas yang berisi fungsi <code>fizzbuzz()</code> di JavaScript. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/21c/a05/8a2/21ca058a2b658c47d975d922e39d1390.jpg"></div><br>  <i><font color="#999999">Kompilasi Kode Alasan dalam JavaScript Menggunakan BuckleScript</font></i> <br><br>  Seperti yang Anda lihat, kode JS ternyata cukup mudah dibaca.  Sepertinya ditulis oleh seorang pria. <br><br>  Program yang ditulis dalam Alasan dikompilasi tidak hanya dalam JavaScript, tetapi juga dalam kode asli dan dalam kode byte.  Sebagai hasilnya, misalnya, Anda dapat menulis aplikasi pada Reason dan menjalankannya di browser, di MacOS, di smartphone yang menjalankan Android dan iOS.  Ada permainan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Gravitron yang</a> ditulis oleh Jared Forsyth on Reason.  Itu dapat dijalankan pada semua platform di atas. <br><br><h2>  <font color="#3AC1EF">Organisasi interaksi dengan JavaScript</font> </h2><br>  BuckleScript memungkinkan untuk mengatur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">interaksi</a> Alasan dan JavaScript.  Ini berarti tidak hanya kemungkinan menggunakan kode JS yang berfungsi dalam basis kode Alasan, tetapi juga kemungkinan interaksi kode yang ditulis dalam Alasan dengan kode JavaScript ini.  Akibatnya, kode yang ditulis dalam Alasan mudah untuk diintegrasikan ke dalam proyek JS yang ada.  Selain itu, dalam kode alasan Anda dapat menggunakan paket JavaScript dari NPM.  Misalnya, Anda bisa membuat proyek yang membagikan Flow, TypeScript, dan Reason. <br><br>  Namun, semuanya tidak begitu sederhana.  Untuk menggunakan kode JavaScript atau pustaka di Reason, Anda harus terlebih dahulu porting menggunakan binding Reason.  Dengan kata lain, untuk menggunakan sistem tipe Reason yang ketat, kita membutuhkan tipe untuk kode JavaScript biasa. <br><br>  Jika Anda perlu menggunakan pustaka JavaScript apa pun dalam kode Alasan, Anda harus terlebih dahulu beralih ke Indeks Paket Alasan ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Redex</a> ) dan mencari tahu apakah perpustakaan ini telah diangkut ke Alasan.  Proyek Redex adalah katalog perpustakaan dan alat-alat yang ditulis dalam perpustakaan Alasan dan JavaScript dengan ikatan Alasan.  Jika Anda berhasil menemukan pustaka yang diperlukan dalam direktori ini, Anda dapat menginstalnya sebagai dependensi dan menggunakannya dalam aplikasi Alasan. <br><br>  Jika Anda tidak dapat menemukan perpustakaan yang diinginkan, Anda harus menulis sendiri binder.  Jika Anda baru memulai dengan Alasan, perlu diingat bahwa menulis binder bukanlah tugas pemula.  Ini adalah salah satu tugas paling sulit yang harus diselesaikan seseorang untuk mereka yang memprogram Alasan.  Sebenarnya, ini adalah topik untuk artikel terpisah. <br><br>  Jika Anda hanya perlu beberapa fungsi terbatas dari beberapa perpustakaan JavaScript, Anda tidak perlu menulis binding untuk seluruh perpustakaan tersebut.  Ini hanya dapat dilakukan untuk fungsi atau komponen yang diperlukan. <br><br><h2>  <font color="#3AC1EF">ReasonReact</font> </h2><br>  Pada awal artikel, kami berbicara tentang bagaimana itu didedikasikan untuk mengembangkan aplikasi Bereaksi menggunakan Alasan.  Anda dapat melakukan ini berkat pustaka <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ReasonReact</a> . <br><br>  Mungkin sekarang Anda berpikir: "Saya masih tidak mengerti mengapa perlu menulis Bereaksi aplikasi dalam Alasan."  Namun, kami telah membahas alasan utama untuk menggunakan bundel Bereaksi dan Alasan, yaitu bahwa Bereaksi lebih kompatibel dengan Alasan daripada dengan JavaScript.  Kenapa begitu?  Masalahnya adalah bahwa React dibuat berdasarkan Alasan, atau lebih tepatnya, berdasarkan OCaml. <br><br><h2>  <font color="#3AC1EF">Jalan Menuju ReasonReact</font> </h2><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/38c/139/424/38c139424305904a5d72c3c8596420ec.jpg"></div><br>  Prototipe React pertama dikembangkan oleh Facebook dan ditulis dalam Bahasa Meta <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Standar</a> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">StandardML</a> ), dalam bahasa yang merupakan kerabat OCaml.  Kemudian Bereaksi dipindahkan ke OCaml, di samping itu, Bereaksi diangkut ke JavaScript.  Ini dilakukan karena fakta bahwa seluruh web menggunakan JavaScript dan mungkin tidak masuk akal untuk membuat pernyataan seperti: "Sekarang kita akan menulis UI di OCaml".  Terjemahan Bereaksi menjadi JavaScript terbayar dan menyebabkan distribusi luas perpustakaan ini. <br><br>  Akibatnya, semua orang terbiasa menganggap React sebagai perpustakaan JS.  Bereaksi, serta perpustakaan dan bahasa lain seperti <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Elm</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Redux</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Recompose</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Ramda</a> , dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">PureScript</a> , telah membantu mempopulerkan gaya fungsional pemrograman dalam JavaScript.  Dan berkat penyebaran <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Flow</a> dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">TypeScript</a> di JavaScript, pengetikan statis juga menjadi populer.  Akibatnya, paradigma pemrograman fungsional menggunakan tipe statis telah menjadi dominan di dunia pengembangan frontend. <br><br>  Pada tahun 2006, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bloomberg</a> membuat dan mentransfer ke kategori proyek sumber terbuka, kompiler BuckleScript, yang mengubah OCaml menjadi JavaScript.  Ini memungkinkan mereka untuk menulis kode front-end yang lebih baik dan lebih aman menggunakan sistem tipe OCaml yang ketat.  Mereka mengambil kompiler OCaml yang dioptimalkan dan sangat cepat dan membuatnya menghasilkan kode JavaScript. <br><br>  Popularitas pemrograman fungsional dan rilis BuckleScript menciptakan iklim ideal yang memungkinkan Facebook untuk kembali ke ide asli React - perpustakaan yang awalnya ditulis dalam StandardML. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4e2/9f4/1ab/4e29f41aba5732c3a1c23482f1859d7c.png"></div><br>  <i><font color="#999999">ReasonReact</font></i> <br><br>  Mereka mencampur semantik OCaml dengan sintaksis JavaScript dan menciptakan Alasan.  Selain itu, mereka menciptakan pembungkus Alasan untuk React, disajikan dalam bentuk perpustakaan ReasonReact, yang memiliki fungsi tambahan, seperti merangkum prinsip Redux dalam komponen stateful.  Setelah melakukan ini, mereka membawa React kembali ke <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">asalnya</a> . <br><br><h2>  <font color="#3AC1EF">Tentang Bereaksi Fitur di Alasan</font> </h2><br>  Ketika perpustakaan React diterjemahkan ke dalam JavaScript, kemampuan bahasa disesuaikan dengan kebutuhan Bereaksi dengan membuat berbagai perpustakaan dan alat.  Pendekatan ini, khususnya, berarti kebutuhan akan sejumlah besar ketergantungan untuk proyek.  Kami tidak akan mengatakan bahwa perpustakaan seperti itu terus berkembang, dan perubahan terjadi secara teratur di dalamnya, membuat versi baru mereka tidak sesuai dengan yang lama.  Akibatnya, pengembang harus sangat serius dan berhati-hati dalam memelihara perpustakaan tempat proyeknya bergantung. <br><br>  Ini menambahkan lapisan kompleksitas tambahan untuk pengembangan JavaScript.  Sebagai contoh, aplikasi Bereaksi khas biasanya berisi setidaknya dependensi yang dapat dilihat pada gambar berikut. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0ed/64a/ac4/0ed64aac438522cd6a241e340a14194b.jpg"></div><br>  <i><font color="#999999">Ketergantungan Aplikasi Bereaksi Khas</font></i> <br><br>  Inilah tugas-tugas yang diselesaikan dependensi ini: <br><br><ul><li>  Pengetikan statis - Flow / TypeScript. </li><li>  Kekebalan - ImmutableJS. </li><li>  Routing - ReactRouter. </li><li>  Pemformatan Kode - Lebih cantik. </li><li>  Linting - ESLint. </li><li>  Fungsi bantu - Ramda / Lodash. </li></ul><br>  Sekarang kita akan menggunakan, alih-alih Bereaksi untuk JavaScript, perpustakaan ReasonReact.  Apakah kita perlu, dengan pendekatan ini, semua ketergantungan ini? <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e92/76b/d37/e9276bd37be87945122ed64af7d37118.gif"></div><br>  <i><font color="#999999">Beralih ke ReasonReact</font></i> <br><br>  Setelah menganalisis daftar tugas yang sama yang sebelumnya diselesaikan dengan menggunakan alat tambahan, kami menemukan bahwa semuanya dapat diselesaikan menggunakan alat ReasonReact bawaan.  Anda dapat membaca <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">lebih lanjut</a> tentang mereka di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> . <br><br>  Dalam aplikasi yang disiapkan oleh ReasonReact, semua ini dan banyak dependensi lainnya tidak diperlukan.  Faktanya adalah bahwa banyak fitur paling penting yang menyederhanakan pengembangan sudah termasuk dalam bahasa.  Akibatnya, pekerjaan dengan dependensi disederhanakan, dan, ketika aplikasi tumbuh dan berkembang, pekerjaan ini tidak menjadi rumit. <br><br>  Semua ini dimungkinkan berkat penggunaan bahasa OCaml, yang berusia lebih dari 20 tahun.  Ini adalah bahasa yang matang, prinsip-prinsip dasar dan mekanisme yang telah teruji waktu dan stabil. <br><br><h2>  <font color="#3AC1EF">Apa selanjutnya</font> </h2><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/499/326/c67/499326c67ab497eee1c0794b58a80641.jpg"></div><br>  Jika Anda berasal dari dunia JavaScript, mudah untuk memulai dengan Alasan karena sintaksis bahasa ini mirip dengan JavaScript.  Jika Anda menulis aplikasi React sebelumnya, beralih ke Reason akan lebih mudah bagi Anda, karena Anda dapat menggunakan semua pengetahuan Anda di bidang React saat bekerja dengan ReasonReact.  Di jantung ReasonReact terletak model pemikiran yang sama seperti pada inti React, proses bekerja sama dengan mereka juga sangat mirip.  Ini berarti bahwa ketika Anda beralih ke Alasan Anda tidak harus memulai dari awal.  Anda akan berurusan dengan Alasan dalam proses. <br><br>  Cara terbaik untuk mulai menggunakan Alasan dalam proyek Anda adalah secara bertahap memperkenalkan fragmen yang ditulis dalam Alasan ke dalamnya.  Seperti yang telah disebutkan, kode alasan dapat digunakan dalam proyek JS, serta kode JS dalam proyek alasan.  Pendekatan ini juga berlaku ketika menggunakan ReasonReact.  Anda dapat mengambil komponen ReasonReact dan menggunakannya dalam aplikasi React tradisional yang ditulis dalam JavaScript. <br><br>  Ini persis pendekatan tambahan yang dipilih oleh pengembang Facebook, yang banyak menggunakan Reason ketika mengembangkan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">messenger Facebook</a> . <br><br>  Jika Anda ingin menulis aplikasi Bereaksi menggunakan Reason dan mempelajari dasar-dasar bahasa ini dalam praktiknya, lihat materi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ini</a> , di mana pengembangan game "Tic Tac Toe" adalah langkah-demi-langkah. <br><br><h2>  <font color="#3AC1EF">Ringkasan</font> </h2><br>  Pencipta Alasan memiliki dua opsi.  Yang pertama adalah mengambil JavaScript dan entah bagaimana memperbaikinya.  Jika mereka memilih jalan ini, mereka harus berurusan dengan kelemahan historis JS. <br><br>  Namun, mereka memilih jalur kedua yang terkait dengan OCaml.  Mereka mengambil OCaml, bahasa yang matang dengan kinerja luar biasa, dan memodifikasinya agar terlihat seperti JavaScript. <br><br>  Bereaksi juga didasarkan pada prinsip-prinsip OCaml.  Itu sebabnya menulis aplikasi Bereaksi jauh lebih mudah dan lebih menyenangkan menggunakan Alasan.  Bekerja dengan React in Reason menawarkan pendekatan yang lebih stabil dan aman untuk membuat komponen React, karena sistem tipe yang ketat menjamin pengembang dan dia tidak harus menghadapi sebagian besar masalah JavaScript historis. <br><br>  <b>Pembaca yang budiman!</b>  Sudahkah Anda mencoba ReasonReact? <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id424965/">https://habr.com/ru/post/id424965/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id424951/index.html">Hore! Itu bukan paranoia</a></li>
<li><a href="../id424955/index.html">Intisari bahan-bahan segar dari dunia front-end untuk minggu terakhir No. 332 (24 - 30 September 2018)</a></li>
<li><a href="../id424957/index.html">Menghasilkan Gambar dari Teks Menggunakan AttnGAN</a></li>
<li><a href="../id424961/index.html">MTA-STS untuk Postfix</a></li>
<li><a href="../id424963/index.html">Pendanaan Zuckerberg: Alat Bangun untuk Sains Bersama</a></li>
<li><a href="../id424967/index.html">Pintasan JavaScript untuk pemula</a></li>
<li><a href="../id424969/index.html">Panduan Node.js, Bagian 9: Bekerja dengan Sistem File</a></li>
<li><a href="../id424971/index.html">Habrokast "Sunset Manually" # 1. Mencoba mengatur lingkungan untuk mengembangkan mainan untuk Windows</a></li>
<li><a href="../id424973/index.html">Deteksi Wajah pada Video: Raspberry Pi dan Neural Compute Stick</a></li>
<li><a href="../id424975/index.html">Kedalaman SIEM: korelasi out-of-box. Bagian 2. Skema data sebagai refleksi dari model "dunia"</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>