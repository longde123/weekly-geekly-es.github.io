<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>⛹️ ♈️ 👨🏻‍🌾 Konverter JSON Anda sendiri atau lebih banyak tentang ExpressionTrees 🤮 👩‍🎓 Ⓜ️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Serialisasi dan deserialisasi adalah operasi tipikal yang oleh pengembang modern dianggap sepele. Kami berkomunikasi dengan basis data, menghasilkan p...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Konverter JSON Anda sendiri atau lebih banyak tentang ExpressionTrees</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/464525/"><img src="https://habrastorage.org/webt/ud/qn/kd/udqnkdpyauh-0k7h5d-g_hgzrys.png"><br><br>  Serialisasi dan deserialisasi adalah operasi tipikal yang oleh pengembang modern dianggap sepele.  Kami berkomunikasi dengan basis data, menghasilkan permintaan HTTP, menerima data melalui REST API, dan sering kali bahkan tidak memikirkan cara kerjanya.  Hari ini saya menyarankan untuk menulis serializer dan deserializer saya untuk JSON untuk mencari tahu apa yang ada di balik tudung. <br><a name="habracut"></a><br><h2>  Penafian </h2><br>  Seperti <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">terakhir kali</a> , saya akan perhatikan: kita akan menulis serializer primitif, bisa dikatakan, sepeda.  Jika Anda memerlukan solusi turnkey, gunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Json.NET</a> .  Orang-orang ini merilis produk hebat yang sangat dapat dikustomisasi, dapat melakukan banyak hal dan <i>sudah menyelesaikan masalah</i> yang muncul ketika bekerja dengan JSON.  Menggunakan solusi Anda sendiri benar-benar keren, tetapi hanya jika Anda membutuhkan kinerja maksimum, penyesuaian khusus, atau Anda suka sepeda seperti yang saya suka. <br><br><h2>  Bidang subjek </h2><br>  Layanan untuk mengkonversi dari JSON ke representasi objek terdiri dari setidaknya dua subsistem.  Deserializer adalah subsistem yang mengubah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">JSON</a> (teks) yang valid menjadi representasi objek di dalam program kami.  Deserialisasi melibatkan tokenization, yaitu, mengurai JSON menjadi elemen logis.  Serializer adalah subsistem yang melakukan tugas terbalik: mengubah representasi objek data menjadi JSON. <br><br>  Konsumen paling sering melihat antarmuka berikut.  Saya sengaja menyederhanakannya untuk menyoroti metode utama yang paling sering digunakan. <br><br><pre><code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> <span class="hljs-title"><span class="hljs-title">IJsonConverter</span></span> { T Deserialize&lt;T&gt;(<span class="hljs-keyword"><span class="hljs-keyword">string</span></span> json); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Serialize</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params"> source</span></span></span><span class="hljs-function">)</span></span>; }</code> </pre> <br>  "Di bawah tenda," deserialisasi termasuk tokenization (parsing teks JSON) dan membangun beberapa primitif yang membuatnya lebih mudah untuk membuat representasi objek di kemudian hari.  Untuk tujuan pelatihan, kami akan melewati konstruksi primitif menengah (misalnya, JObject, JProperty dari Json.NET) dan kami akan segera menulis data ke objek.  Ini adalah minus, karena mengurangi opsi untuk kustomisasi, tetapi tidak mungkin untuk membuat seluruh perpustakaan dalam kerangka satu artikel. <br><br><h2>  Tokenisasi </h2><br>  Biarkan saya mengingatkan Anda bahwa proses tokenization atau <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">analisis leksikal</a> adalah penguraian teks dengan tujuan mendapatkan representasi yang berbeda, lebih ketat dari data yang terkandung di dalamnya.  Biasanya, representasi ini disebut <b>token</b> atau token.  Untuk keperluan parsing JSON, kita harus menyoroti properti, nilainya, simbol awal dan akhir struktur - yaitu, token yang dapat direpresentasikan sebagai JsonToken dalam kode. <br><br>  <a href="">JsonToken</a> adalah struktur yang berisi nilai (teks), serta jenis token.  JSON adalah notasi yang ketat, sehingga semua jenis token dapat dikurangi ke <a href="">enum berikutnya</a> .  Tentu saja, akan bagus untuk menambahkan token koordinatnya dalam data yang masuk (baris dan kolom), tetapi debugging berada di luar cakupan implementasi, yang berarti bahwa JsonToken tidak mengandung data ini. <br><br>  Jadi, cara termudah untuk mem-parsing teks menjadi token adalah membaca setiap karakter secara berurutan dan membandingkannya dengan pola.  Kita perlu memahami apa arti simbol ini atau itu.  Ada kemungkinan bahwa kata kunci (true, false, null) dimulai dengan karakter ini, ada kemungkinan bahwa ini adalah awal dari garis (tanda kutip), atau mungkin karakter ini sendiri adalah token ([,], {,}).  Ide umumnya terlihat seperti ini: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> tokens = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;JsonToken&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; json.Length; i++) { <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> ch = json[i]; <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (ch) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">'['</span></span>: tokens.Add(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> JsonToken(JsonTokenType.ArrayStart)); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">']'</span></span>: tokens.Add(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> JsonToken(JsonTokenType.ArrayEnd)); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">'"'</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> stringValue = ReadString(); tokens.Add(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> JsonToken(JsonTokenType.String, stringValue); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; ... } }</code> </pre><br>  Melihat kode tersebut, tampaknya Anda dapat membaca dan segera melakukan sesuatu dengan data yang dibaca.  Mereka tidak perlu disimpan, mereka harus segera dikirim ke konsumen.  Jadi, seorang IEnumerator memohon, yang akan mem-parsing teks menjadi beberapa bagian.  Pertama, ini akan mengurangi alokasi, karena kita tidak perlu menyimpan hasil antara (array token).  Kedua, kami akan meningkatkan kecepatan kerja - ya, dalam contoh kami inputnya berupa string, tetapi dalam situasi nyata, input akan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">diganti oleh Stream</a> (dari file atau jaringan), yang kami baca secara berurutan. <br><br>  Saya sudah menyiapkan kode <b>JsonTokenizer</b> , yang dapat <a href="">ditemukan di sini</a> .  Idenya adalah sama - tokenizer secara berurutan berjalan sepanjang garis, mencoba menentukan apa simbol atau urutannya merujuk.  Jika kami berhasil memahami, maka kami membuat token dan mentransfer kendali ke konsumen.  Jika belum jelas, baca terus. <br><br><h2>  Bersiap untuk Deserialize Objek </h2><br>  Paling sering, permintaan untuk mengonversi data dari JSON adalah panggilan ke metode generik Deserialize, di mana <b>TOut</b> adalah tipe data yang harus dipetakan dengan token JSON.  Di mana <a href="">Type adalah</a> : saatnya menerapkan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Reflection</a> dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ExpressionTrees</a> .  Dasar-dasar bekerja dengan ExpressionTrees, serta mengapa ekspresi yang dikompilasi lebih baik daripada Refleksi "telanjang", saya jelaskan dalam artikel sebelumnya tentang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">cara membuat AutoMapper Anda</a> .  Jika Anda tidak tahu apa-apa tentang Expression.Labmda.Compile () - Saya sarankan membacanya.  Sepertinya saya bahwa contoh mapper ternyata cukup dimengerti. <br><br>  Jadi, rencana untuk membuat deserializer objek didasarkan pada pengetahuan bahwa kita bisa mendapatkan tipe properti dari tipe TOut kapan saja, yaitu koleksi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">PropertyInfo</a> .  Pada saat yang sama, tipe properti dibatasi oleh notasi JSON: angka, string, array dan objek.  Bahkan jika kita tidak melupakan null, ini tidak sebanyak yang terlihat pada pandangan pertama.  Dan jika untuk setiap tipe primitif kita akan dipaksa untuk membuat deserializer terpisah, maka untuk array dan objek kita dapat membuat kelas generik.  Jika Anda berpikir sedikit, semua serializer-deserializers (atau <b>konverter</b> ) dapat dikurangi menjadi antarmuka berikut: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> <span class="hljs-title"><span class="hljs-title">IJsonConverter</span></span>&lt;<span class="hljs-title"><span class="hljs-title">T</span></span>&gt; { <span class="hljs-function"><span class="hljs-function">T </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Deserialize</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">JsonTokenizer tokenizer</span></span></span><span class="hljs-function">)</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Serialize</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">T </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">value</span></span></span></span><span class="hljs-function"><span class="hljs-params">, StringBuilder builder</span></span></span><span class="hljs-function">)</span></span>; }</code> </pre><br>  Kode konverter tipe primitif sangat sederhana: kita mengekstrak JsonToken saat ini dari tokenizer dan mengubahnya menjadi nilai dengan menguraikan.  Misalnya, float.Parse (currentToken.Value).  Lihatlah <a href="">BoolConverter</a> atau <a href="">FloatConverter</a> - tidak ada yang rumit.  Selanjutnya, jika Anda membutuhkan deserializer untuk bool?  atau float ?, bisa juga ditambahkan. <br><br><h2>  Deserialisasi array </h2><br>  <a href="">Kode kelas umum</a> untuk mengkonversi array dari JSON juga relatif sederhana.  Itu diparameterisasi oleh tipe elemen yang bisa kita ekstrak <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Type.GetElementType ()</a> .  Menentukan bahwa suatu tipe adalah array juga sederhana: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Type.IsArray</a> .  Deserialisasi array datang ke tokenizer.MoveNext () hingga token jenis ArrayEnd tercapai.  Deserialisasi elemen array adalah deserialisasi tipe elemen array, oleh karena itu, ketika membuat ArrayConverter, elemen deserializer diteruskan ke sana. <br><br>  Terkadang ada kesulitan dengan Instansiasi implementasi generik, jadi saya akan segera memberitahu Anda bagaimana melakukannya.  Refleksi memungkinkan Anda untuk membuat tipe generik secara realtime, yang berarti kita dapat menggunakan tipe yang dibuat sebagai argumen untuk Activator.CreateInstance.  Manfaatkan ini: <br><br><pre> <code class="cs hljs">Type elementType = arrayType.GetElementType(); Type converterType = <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(ArrayConverter&lt;&gt;).MakeGenericType(elementType); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> converterInstance = Activator.CreateInstance(converterType, <span class="hljs-keyword"><span class="hljs-keyword">object</span></span>[] args);</code> </pre><br>  Menyelesaikan persiapan untuk membuat deserializer objek, Anda dapat menempatkan semua kode infrastruktur yang terkait dengan pembuatan dan penyimpanan deserializer dalam fasad <a href="">JConverter</a> .  Dia akan bertanggung jawab atas semua operasi serialisasi dan deserialisasiisasi JSON dan tersedia untuk konsumen sebagai layanan. <br><br><h2>  Deserialisasi objek </h2><br>  Biarkan saya mengingatkan Anda bahwa Anda bisa mendapatkan semua properti bertipe T seperti ini: typeof (T) .GetProperties ().  Untuk setiap properti, Anda dapat mengekstrak <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">PropertyInfo.PropertyType</a> , yang akan memberi kami kesempatan untuk membuat IJsonConverter yang diketik untuk membuat serial dan deserialisasi data dari tipe tertentu.  Jika jenis properti adalah array, maka kami instantiate ArrayConverter atau menemukan yang cocok di antara yang ada.  Jika tipe properti adalah tipe primitif, maka deserializers (konverter) sudah dibuat untuk mereka di konstruktor JConverter. <br><br>  Kode yang dihasilkan dapat dilihat di <a href="">ObjectConverter</a> kelas generik.  Aktivator dibuat dalam konstruktornya, properti diekstraksi dari kamus yang disiapkan khusus, dan untuk masing-masingnya dibuat metode deserialisasi - Action &lt;TObject, JsonTokenizer&gt;.  Diperlukan, pertama, untuk segera menghubungkan IJsonConverter dengan properti yang diinginkan, dan kedua, untuk menghindari tinju saat mengekstraksi dan menulis tipe primitif.  Setiap metode deserialisasi tahu properti mana dari objek yang keluar yang akan dicatat, deserializer nilai diketik secara ketat dan mengembalikan nilai persis dalam bentuk yang dibutuhkan. <br><br>  Ikatan IJsonConverter ke properti adalah sebagai berikut: <br><br><pre> <code class="cs hljs">Type converterType = propertyValueConverter.GetType(); ConstantExpression Expression.Constant(propertyValueConverter, converterType); MethodInfo deserializeMethod = converterType.GetMethod(<span class="hljs-string"><span class="hljs-string">"Deserialize"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> <span class="hljs-keyword"><span class="hljs-keyword">value</span></span> = Expression.Call(converter, deserializeMethod, tokenizer);</code> </pre><br>  Konstanta <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Expression.Constant</a> dibuat langsung dalam ekspresi, yang menyimpan referensi ke instance deserializer untuk nilai properti.  Ini bukan konstanta yang kita tulis dalam “regular C #”, karena ia dapat menyimpan tipe referensi.  Selanjutnya, metode Deserialize diambil dari jenis deserializer, yang mengembalikan nilai dari tipe yang diinginkan, dan kemudian disebut - <a href="">Expression.Call</a> .  Jadi, kita mendapatkan metode yang tahu persis di mana dan apa yang harus ditulis.  Tetap memasukkannya ke dalam kamus dan menyebutnya ketika token dari tipe Properti dengan nama yang diinginkan "berasal" dari tokenizer.  Kelebihan lainnya adalah semuanya bekerja dengan sangat cepat. <br><br><h2>  Seberapa cepat </h2><br>  Sepeda, seperti disebutkan di awal, masuk akal untuk menulis dalam beberapa kasus: jika ini adalah upaya untuk memahami cara kerja teknologi, atau Anda perlu mencapai beberapa hasil khusus.  Misalnya, kecepatan.  Anda dapat memastikan bahwa deserializer benar-benar deserialize <a href="">dengan tes yang disiapkan</a> (saya menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">AutoFixture</a> untuk mendapatkan data uji).  Ngomong-ngomong, Anda mungkin memperhatikan bahwa saya juga menulis serialisasi objek.  Tapi karena artikelnya ternyata cukup besar, saya tidak akan menjelaskannya, tetapi hanya memberikan tolok ukur.  Ya, sama seperti dengan artikel sebelumnya, saya menulis benchmark menggunakan perpustakaan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">BenchmarkDotNet</a> . <br><br>  Tentu saja, saya <a href="">membandingkan</a> kecepatan deserialisasi dengan Newtonsoft (Json.NET), sebagai solusi yang paling umum dan direkomendasikan untuk bekerja dengan JSON.  Selain itu, tepat di situs web mereka tertulis: 50% lebih cepat dari DataContractJsonSerializer, dan 250% lebih cepat dari JavaScriptSerializer.  Singkatnya, saya ingin tahu berapa banyak kode saya akan hilang.  Hasilnya mengejutkan saya: perhatikan bahwa alokasi data hampir tiga kali lebih sedikit, dan laju deserialisasi sekitar dua kali lebih cepat. <br><div class="scrollable-table"><table><thead><tr><th>  Metode </th><th>  Berarti </th><th>  Kesalahan </th><th>  Stddev </th><th>  Rasio </th><th>  Dialokasikan </th></tr></thead><tbody><tr><td>  Newtonsoft </td><td>  75,39 ms </td><td>  0,3027 ms </td><td>  0,2364 ms </td><td>  1,00 </td><td>  35,47 MB </td></tr><tr><td>  Velo </td><td>  31,78 ms </td><td>  0,1135 ms </td><td>  0,1062 ms </td><td>  0,42 </td><td>  12,36 MB </td></tr></tbody></table></div><br>  Perbandingan kecepatan dan alokasi <a href="">selama serialisasi data</a> menghasilkan hasil yang lebih menarik.  Ternyata serializer sepeda mengalokasikan hampir lima kali lebih sedikit dan bekerja hampir tiga kali lebih cepat.  Jika kecepatan benar-benar mengganggu saya (sangat banyak), itu akan menjadi keberhasilan yang jelas. <br><div class="scrollable-table"><table><thead><tr><th>  Metode </th><th>  Berarti </th><th>  Kesalahan </th><th>  Stddev </th><th>  Rasio </th><th>  Dialokasikan </th></tr></thead><tbody><tr><td>  Newtonsoft </td><td>  54,83 ms </td><td>  0,5582 ms </td><td>  0,5222 ms </td><td>  1,00 </td><td>  25,44 MB </td></tr><tr><td>  Velo </td><td>  20,66 ms </td><td>  0,0484 ms </td><td>  0,0429 ms </td><td>  0,38 </td><td>  5,93 MB </td></tr></tbody></table></div><br>  Ya, ketika mengukur kecepatan, saya tidak menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tips untuk meningkatkan produktivitas</a> yang diposting di situs web Json.NET.  Saya mengambil pengukuran dari kotak, yaitu, sesuai dengan skenario yang paling umum digunakan: JsonConvert.DeserializeObject.  Mungkin ada cara lain untuk meningkatkan kinerja, tetapi saya tidak tahu tentang mereka. <br><br><h2>  Kesimpulan </h2><br>  Meskipun kecepatan serialisasi dan deserialisasi yang relatif tinggi, saya tidak akan merekomendasikan meninggalkan Json.NET mendukung solusi saya sendiri.  Keuntungan dalam kecepatan dihitung dalam milidetik, dan mereka dengan mudah "tenggelam" dalam penundaan jaringan, disk atau kode, yang secara hierarkis terletak di atas tempat serialisasi diterapkan.  Untuk mendukung solusi eksklusif semacam itu adalah neraka, di mana hanya pengembang yang fasih dalam bidang ini yang diizinkan. <br><br>  Ruang lingkup sepeda tersebut adalah aplikasi yang dirancang sepenuhnya dengan tujuan untuk kinerja tinggi, atau proyek kesayangan di mana Anda memahami bagaimana teknologi ini atau itu bekerja.  Saya harap saya sedikit membantu Anda dalam semua ini. <br></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id464525/">https://habr.com/ru/post/id464525/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id464511/index.html">Cara mengumpulkan kohort pengguna dalam bentuk grafik di Grafana [+ buruh pelabuhan gambar dengan contoh]</a></li>
<li><a href="../id464513/index.html">Duffle: Transformer dari XD Design</a></li>
<li><a href="../id464515/index.html">Cara Membuat Email dan Tidak Mengacaukan: Kiat Praktis</a></li>
<li><a href="../id464517/index.html">Kartu CUBA Baru</a></li>
<li><a href="../id464523/index.html">Sistem Pembayaran (PSP) untuk bisnis TI: kami bermain besar</a></li>
<li><a href="../id464529/index.html">Untuk iklan kontekstual dengan nama pesaing sekarang dapat didenda 500.000 rubel</a></li>
<li><a href="../id464535/index.html">Detail tentang perangkat dan fungsi skuter listrik KickScooter T60</a></li>
<li><a href="../id464537/index.html">Arduino DIY Carousel Iblis</a></li>
<li><a href="../id464539/index.html">Studi klinis. Bagaimana cara masuk ke dalam kelompok eksperimen, mendapatkan perawatan kanker gratis dan membantu sains</a></li>
<li><a href="../id464543/index.html">Apa yang ada dan apa yang tidak ada dalam Go. Bagian 2</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>