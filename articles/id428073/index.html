<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ“ ğŸ™… ğŸ¥¤ Rust 1.30 Release ğŸ‘ ğŸ‘©ğŸ¾â€ğŸ³ ğŸšƒ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Tim pengembangan Rust dengan bangga mengumumkan rilis versi baru Rust: 1.30.0. Rust adalah bahasa pemrograman sistem yang ditujukan untuk keamanan, ke...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Rust 1.30 Release</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/428073/"><p>  Tim pengembangan Rust dengan bangga mengumumkan rilis versi baru Rust: 1.30.0.  Rust adalah bahasa pemrograman sistem yang ditujukan untuk keamanan, kecepatan, dan eksekusi kode paralel. </p><br><p> Jika Anda memiliki versi Rust sebelumnya yang diinstal menggunakan <code>rustup</code> , maka untuk meningkatkan versi Rust ke versi 1.30.0 Anda hanya perlu melakukan: </p><br><pre> <code class="bash hljs">$ rustup update stable</code> </pre> <br><p>  Jika Anda belum menginstal <code>rustup</code> , Anda dapat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">menginstalnya</a> dari halaman yang sesuai di situs web kami.  <a href="">Catatan rilis terperinci untuk Rust 1.30.0</a> tersedia di GitHub. </p><br><h2 id="chto-voshlo-v-stabilnuyu-versiyu-1300">  Apa yang termasuk dalam versi stabil 1.30.0 </h2><br><p>  Rust 1.30 adalah rilis luar biasa dengan sejumlah inovasi penting.  Tetapi pada hari Senin, blog resmi akan menerbitkan permintaan untuk memeriksa versi beta Rust 1.31, yang akan menjadi rilis pertama "Rust 2018".  Anda akan menemukan informasi lebih lanjut tentang ini di publikasi kami sebelumnya <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">"Apa itu Rust 2018"</a> . </p><br><h3 id="procedurnye-makrosy">  Makro Prosedural </h3><br><p>  Kembali di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Rust 1.15,</a> kami menambahkan kemampuan untuk mendefinisikan "macro turunan khusus."  Misalnya, menggunakan <code>serde_derive</code> , Anda dapat mendeklarasikan: </p><br><pre> <code class="rust hljs"><span class="hljs-meta"><span class="hljs-meta">#[derive(Serialize, Deserialize, Debug)]</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Pet</span></span></span></span> { name: <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>, }</code> </pre> <br><p>  Dan konversi <code>Pet</code> ke JSON dan kembali ke struktur menggunakan <code>serde_json</code> .  Ini dimungkinkan berkat inferensi otomatis <code>Deserialize</code> <code>Serialize</code> dan <code>Deserialize</code> menggunakan makro prosedural di <code>serde_derive</code> . </p><br><p>  Karat 1,30 memperluas fungsionalitas makro prosedural dengan menambahkan kemampuan untuk mendefinisikan dua jenis makro lain: "atribut prosedural makro" dan "makro prosedural fungsional". </p><a name="habracut"></a><br><p>  Makro atribut mirip dengan mendapatkan makro untuk keluaran otomatis, tetapi alih-alih menghasilkan kode hanya untuk atribut <code>#[derive]</code> , makro memungkinkan pengguna untuk membuat atribut baru mereka sendiri.  Ini membuatnya lebih fleksibel: turunan makro hanya berfungsi untuk struktur dan enumerasi, tetapi atribut dapat diterapkan ke objek lain, seperti fungsi.  Misalnya, atribut macro akan memungkinkan Anda untuk melakukan hal berikut saat menggunakan kerangka kerja web: </p><br><pre> <code class="hljs rust"><span class="hljs-meta"><span class="hljs-meta">#[route(GET, </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"/"</span></span></span><span class="hljs-meta">)]</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">index</span></span></span></span>() {</code> </pre> <br><p>  Atribut <code>#[route]</code> ini akan didefinisikan dalam kerangka itu sendiri sebagai makro prosedural.  Tanda tangannya akan terlihat seperti ini: </p><br><pre> <code class="hljs rust"><span class="hljs-meta"><span class="hljs-meta">#[proc_macro_attribute]</span></span> <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">route</span></span></span></span>(attr: TokenStream, item: TokenStream) -&gt; TokenStream {</code> </pre> <br><p>  Di sini kita memiliki dua parameter input tipe <code>TokenStream</code> : yang pertama adalah untuk konten atribut itu sendiri, yaitu, ini adalah parameter <code>GET, "/"</code> .  Yang kedua adalah badan objek yang atributnya diterapkan.  Dalam kasus kami, ini adalah <code>fn index() {}</code> dan seluruh isi fungsi. </p><br><p>  Makro fungsional mendefinisikan makro yang penggunaannya mirip dengan panggilan fungsi.  Misalnya, <code>sql!</code>  : </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> sql = sql!(SELECT * FROM posts WHERE id=<span class="hljs-number"><span class="hljs-number">1</span></span>);</code> </pre> <br><p>  Makro ini di dalam dirinya sendiri akan mengurai ekspresi SQL dan memeriksanya untuk kebenaran sintaksis.  Makro yang serupa harus dinyatakan sebagai berikut: </p><br><pre> <code class="hljs rust"><span class="hljs-meta"><span class="hljs-meta">#[proc_macro]</span></span> <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sql</span></span></span></span>(input: TokenStream) -&gt; TokenStream {</code> </pre> <br><p>  Ini mirip dengan tanda tangan dari turunan makro: kami mendapatkan token yang ada di dalam tanda kurung dan mengembalikan kode yang dihasilkan oleh mereka. </p><br><h3 id="makrosy-i-use">  Macro dan <code>use</code> </h3><br><p>  Sekarang Anda dapat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">mengimpor makro ke dalam cakupan menggunakan kata kunci penggunaan</a> .  Misalnya, untuk menggunakan makro <code>json</code> dari paket <code>serde-json</code> , entri yang digunakan adalah: </p><br><pre> <code class="rust hljs"><span class="hljs-meta"><span class="hljs-meta">#[macro_use]</span></span> <span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-keyword"><span class="hljs-keyword">crate</span></span> serde_json; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> john = json!({ <span class="hljs-string"><span class="hljs-string">"name"</span></span>: <span class="hljs-string"><span class="hljs-string">"John Doe"</span></span>, <span class="hljs-string"><span class="hljs-string">"age"</span></span>: <span class="hljs-number"><span class="hljs-number">43</span></span>, <span class="hljs-string"><span class="hljs-string">"phones"</span></span>: [ <span class="hljs-string"><span class="hljs-string">"+44 1234567"</span></span>, <span class="hljs-string"><span class="hljs-string">"+44 2345678"</span></span> ] });</code> </pre> <br><p>  Dan sekarang Anda harus menulis: </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-keyword"><span class="hljs-keyword">crate</span></span> serde_json; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> serde_json::json; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> john = json!({ <span class="hljs-string"><span class="hljs-string">"name"</span></span>: <span class="hljs-string"><span class="hljs-string">"John Doe"</span></span>, <span class="hljs-string"><span class="hljs-string">"age"</span></span>: <span class="hljs-number"><span class="hljs-number">43</span></span>, <span class="hljs-string"><span class="hljs-string">"phones"</span></span>: [ <span class="hljs-string"><span class="hljs-string">"+44 1234567"</span></span>, <span class="hljs-string"><span class="hljs-string">"+44 2345678"</span></span> ] });</code> </pre> <br><p>  Di sini, makro diimpor serta elemen lainnya, jadi tidak perlu menggunakan anotasi <code>macro_use</code> . </p><br><p>  Akhirnya, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">paket proc_macro distabilkan</a> , yang menyediakan API yang diperlukan untuk menulis makro prosedural.  Itu juga secara signifikan meningkatkan API penanganan kesalahan, dan paket-paket seperti <code>syn</code> dan <code>quote</code> sudah menggunakannya.  Misalnya, sebelumnya: </p><br><pre> <code class="hljs rust"><span class="hljs-meta"><span class="hljs-meta">#[derive(Serialize)]</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Demo</span></span></span></span> { ok: <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>, bad: std::thread::Thread, }</code> </pre> <br><p>  menyebabkan kesalahan ini: </p><br><pre> <code class="hljs rust">error[E0277]: the <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">trait</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">bound</span></span></span></span> `std::thread::Thread: _IMPL_SERIALIZE_FOR_Demo::_serde::Serialize` is not satisfied --&gt; src/main.rs:<span class="hljs-number"><span class="hljs-number">3</span></span>:<span class="hljs-number"><span class="hljs-number">10</span></span> | <span class="hljs-number"><span class="hljs-number">3</span></span> | <span class="hljs-meta"><span class="hljs-meta">#[derive(Serialize)]</span></span> | ^^^^^^^^^ the <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">trait</span></span></span><span class="hljs-class"> `</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">_IMPL_SERIALIZE_FOR_Demo</span></span></span></span>::_serde::Serialize` is not implemented <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> `std::thread::Thread`</code> </pre> <br><p>  Sekarang akan diterbitkan: </p><br><pre> <code class="hljs cpp">error[E0277]: the trait bound `<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::thread::Thread: serde::Serialize` is <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> satisfied --&gt; src/main.rs:<span class="hljs-number"><span class="hljs-number">7</span></span>:<span class="hljs-number"><span class="hljs-number">5</span></span> | <span class="hljs-number"><span class="hljs-number">7</span></span> | bad: <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::thread::Thread, | ^^^ the trait `serde::Serialize` is <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> implemented <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> `<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::thread::Thread`</code> </pre> <br><h2 id="uluchshenie-sistemy-moduley">  Memperbaiki sistem modul </h2><br><p>  Sistem modul telah lama menjadi tempat sakit bagi pemula di Rust;  beberapa aturannya tidak praktis dalam praktik.  Perubahan ini adalah langkah pertama yang kami ambil untuk menyederhanakan sistem modul. </p><br><p>  Selain perubahan di atas untuk makro, ada dua peningkatan baru untuk <code>use</code> .  Pertama, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">paket eksternal sekarang ditambahkan ke pendahuluan</a> , yaitu: </p><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">//  let json = ::serde_json::from_str("..."); //  let json = serde_json::from_str("...");</span></span></code> </pre> <br><p>  Tangkapannya adalah bahwa gaya lama tidak selalu diperlukan karena fitur sistem modul Rust: </p><br><pre> <code class="hljs powershell">extern crate serde_json; fn main() { //   ;     ,  `serde_json` //     let json = serde_json::from_str(<span class="hljs-string"><span class="hljs-string">"..."</span></span>); } mod foo { fn bar() { //   ;     `foo`,  `serde_json` //    let json = serde_json::from_str(<span class="hljs-string"><span class="hljs-string">"..."</span></span>); } //   -        `use` use serde_json; fn baz() { //   -   `::serde_json`,   //  ,   let json = ::serde_json::from_str(<span class="hljs-string"><span class="hljs-string">"..."</span></span>); } }</code> </pre> <br><p>  Itu menjengkelkan untuk mendapatkan kode yang rusak hanya dengan memindahkan fungsi ke submodule.  Sekarang bagian pertama dari jalan akan diperiksa, dan jika itu sesuai dengan beberapa <code>extern crate</code> , maka itu akan digunakan terlepas dari posisi panggilan dalam hirarki modul. </p><br><p>  Akhirnya, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">penggunaan mulai mendukung impor elemen ke dalam cakupan saat ini dengan jalur yang dimulai pada peti</a> : </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">mod</span></span> foo { <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bar</span></span></span></span>() { <span class="hljs-comment"><span class="hljs-comment">// ... } } //  use ::foo::bar; //  use foo::bar; //  use crate::foo::bar;</span></span></code> </pre> <br><p>  Kata kunci <code>crate</code> di awal jalan menunjukkan bahwa jalan akan dimulai pada akar paket.  Sebelumnya, jalur yang ditunjukkan dalam baris impor <code>use</code> selalu ditentukan relatif terhadap akar paket, tetapi jalur di sisa kode yang secara langsung merujuk ke elemen ditentukan relatif terhadap modul saat ini, yang menyebabkan perilaku yang bertentangan dari jalur: </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">mod</span></span> foo { <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bar</span></span></span></span>() { <span class="hljs-comment"><span class="hljs-comment">// ... } } mod baz { pub fn qux() { //  ::foo::bar(); //  ,    `use`: // foo::bar(); //  crate::foo::bar(); } }</span></span></code> </pre> <br><p>  Segera setelah gaya baru ini digunakan secara luas, diharapkan akan membuat jalur absolut menjadi lebih jelas tanpa perlu menggunakan awalan jelek <code>::</code> . </p><br><p>  Semua perubahan ini bersama-sama menyederhanakan pemahaman tentang bagaimana jalur diselesaikan.  Di mana pun Anda melihat jalan <code>a::b::c</code> , kecuali untuk pernyataan <code>use</code> , Anda dapat bertanya: </p><br><ul><li>  Apakah nama paket?  Maka Anda perlu mencari <code>b::c</code> di dalamnya. </li><li>  Apakah <code>a</code> kata kunci?  Maka Anda perlu mencari <code>b::c</code> dari root paket saat ini. </li><li>  Jika tidak, Anda perlu mencari <code>a::b::c</code> dari posisi saat ini di hierarki modul. </li></ul><br><p>  Perilaku lama jalur yang <code>use</code> , selalu dimulai dari akar paket, masih berlaku.  Tetapi dengan transisi satu kali ke gaya baru, aturan ini akan diterapkan ke jalur di mana-mana secara seragam, dan Anda harus lebih khawatir tentang impor saat memindahkan kode. </p><br><h2 id="syrye-identifikatory">  Pengidentifikasi mentah </h2><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Anda sekarang dapat menggunakan kata kunci sebagai pengidentifikasi</a> menggunakan sintaks baru berikut: </p><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">//      `for` let r#for = true; //     `for` fn r#for() { // ... } //    r#for();</span></span></code> </pre> <br><p>  Sejauh ini, tidak banyak kasus saat ini berguna bagi Anda.  Tetapi suatu hari Anda akan mencoba menggunakan paket untuk Rust 2015 dalam proyek untuk Rust 2018 atau sebaliknya, maka rangkaian kata kunci mereka akan berbeda.  Kami akan membicarakan lebih lanjut tentang hal ini dalam pengumuman Rust 2018 yang akan datang. </p><br><h2 id="prilozheniya-bez-standartnoy-biblioteki">  Aplikasi tanpa pustaka standar </h2><br><p>  Kembali di Rust 1.6, kami mengumumkan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">stabilisasi "no_std" dan libcore</a> untuk membuat proyek tanpa pustaka standar.  Namun, dengan satu klarifikasi: itu mungkin untuk membuat perpustakaan saja, tetapi tidak aplikasi. </p><br><p>  Di Rust 1.30, Anda dapat menggunakan atribut <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><code>#[panic_handler]</code></a> untuk secara mandiri menerapkan panik.  Ini berarti bahwa sekarang Anda dapat membuat aplikasi, bukan hanya perpustakaan yang tidak menggunakan perpustakaan standar. </p><br><h2 id="drugoe">  Lainnya </h2><br><p>  Satu hal terakhir: di makro, Anda sekarang dapat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">memetakan pengubah ruang lingkup</a> , seperti <code>pub</code> , menggunakan kualifikasi <code>vis</code> .  Selain itu, "atribut alat", seperti <code>#[rustfmt::skip]</code> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sekarang distabilkan</a> .  Benar untuk digunakan dengan <em>alat analisis statis</em> , seperti <code>#[allow(clippy::something)]</code> , mereka belum stabil. </p><br><p>  Lihat <a href="">catatan rilis untuk lebih</a> jelasnya. </p><br><h3 id="stabilizaciya-standartnoy-biblioteki">  Stabilisasi perpustakaan standar </h3><br><p>  <a href="">API berikut</a> telah <a href="">distabilkan</a> dalam rilis ini: </p><br><ul><li> <code>Ipv4Addr::{BROADCAST, LOCALHOST, UNSPECIFIED}</code> </li> <li> <code>Ipv6Addr::{BROADCAST, LOCALHOST, UNSPECIFIED}</code> </li> <li> <code>Iterator::find_map</code> </li> </ul><br><p>  Selain itu, pustaka standar telah lama memiliki fungsi untuk menghapus spasi di satu sisi beberapa teks, seperti <code>trim_left</code> .  Namun, untuk bahasa RTL, arti "kanan" dan "kiri" di sini menyebabkan kebingungan.  Karena itu, kami memperkenalkan nama-nama baru untuk fungsi-fungsi ini: </p><br><ul><li>  <code>trim_left</code> -&gt; <code>trim_start</code> </li><li>  <code>trim_right</code> -&gt; <code>trim_end</code> </li><li>  <code>trim_left_matches</code> -&gt; <code>trim_start_matches</code> </li><li>  <code>trim_right_matches</code> -&gt; <code>trim_end_matches</code> </li></ul><br><p>  Kami berencana untuk mendeklarasikan nama-nama lama usang (tetapi tidak menghapus, tentu saja) di Rust 1.33. </p><br><p>  Lihat <a href="">catatan rilis untuk lebih</a> jelasnya. </p><br><h3 id="uluchsheniya-v-cargo">  Peningkatan Kargo </h3><br><p>  Peningkatan Cargo terbesar dalam rilis ini adalah bahwa kami sekarang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">memiliki progress bar!</a> </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/84f/4ce/626/84f4ce6263525deded821b6007735dec.gif" alt="demo gif"></p><br><p>  Lihat <a href="">catatan rilis untuk lebih</a> jelasnya. </p><br><h2 id="razrabotchiki-1300">  Pengembang 1.30.0 </h2><br><p>  Banyak orang bersama-sama menciptakan Rust 1.30.  Kami tidak dapat menyelesaikan pekerjaan tanpa Anda masing-masing.  <a href="">Terima kasih</a> </p><br><p>  <em>Dari penerjemah: Saya mengucapkan terima kasih khusus kepada anggota komunitas Rustycrate dan secara pribadi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" class="user_link">vitvakatu</a> dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" class="user_link">Virtuos86</a> atas bantuan mereka dengan terjemahan dan proofreading.</em> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id428073/">https://habr.com/ru/post/id428073/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id428061/index.html">Mengelola Biaya Proyek dengan Manajemen Nilai yang Diperoleh</a></li>
<li><a href="../id428063/index.html">Browser menolak dukungan untuk TLS 1.0 dan 1.1</a></li>
<li><a href="../id428065/index.html">Lebih sedikit tidak berarti lebih buruk: langit dan dinding domain di ferromagnet</a></li>
<li><a href="../id428067/index.html">AntiFuzzing: Keamanan melalui ketidakjelasan!?</a></li>
<li><a href="../id428069/index.html">Optimalkan load balancing dalam infrastruktur Veeam Backup & Replication</a></li>
<li><a href="../id428075/index.html">Sama saja, Anda tidak bisa melakukannya! - Menggunakan antarmuka dan injeksi ketergantungan untuk desain jangka panjang</a></li>
<li><a href="../id428077/index.html">React.js: A Beginner's Guide</a></li>
<li><a href="../id428079/index.html">Menerapkan Prinsip SOLID untuk Bereaksi Pengembangan Aplikasi</a></li>
<li><a href="../id428081/index.html">Menggunakan RxJS dalam React Development untuk Mengelola Status Aplikasi</a></li>
<li><a href="../id428083/index.html">Matriks pengaruh analisis web - sistem strategis Avinash Koshik</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>