<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ˜‘ ğŸ‘¿ ğŸ Mencoba menyusun skema docking yang tidak dapat dikomposisikan âœ¨ ğŸ”¦ ğŸ‘©â€ğŸ’¼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Pendahuluan 
 Di Haskell, sudah lazim untuk bekerja dengan efek sebagai functors yang objeknya adalah beberapa ekspresi yang kita minati saat ini. 

 ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Mencoba menyusun skema docking yang tidak dapat dikomposisikan</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/467683/"><h2>  Pendahuluan </h2><br>  Di Haskell, sudah lazim untuk bekerja dengan efek sebagai functors yang objeknya adalah beberapa ekspresi yang kita minati saat ini. <br><br>  Ketika kita melihat jenis ekspresi <b>Mungkin a</b> , kita abstrak dari keberadaan aktual dari beberapa, memusatkan semua perhatian kita pada ini.  Kisah yang sama dengan <b>Daftar a</b> - nilai jamak dari;  Status <b>sa</b> - <b>a</b> , tergantung pada beberapa kondisi saat ini;  <b>Baik ea</b> - <b>a</b> , yang mungkin mengembalikan beberapa kesalahan <b>e</b> . <br><a name="habracut"></a><br>  Sebelum melanjutkan, artikel ini akan menggunakan beberapa definisi: <br><br><pre><code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> (:=) ta = ta </span><span class="hljs-comment"><span class="hljs-class"><span class="hljs-comment">-- |   type (:.) tua = t (ua) -- |   type (~&gt;) tu = forall a . ta -&gt; ua -- |  </span></span></span></span></code> </pre> <br>  Misalnya: <b>Daftar</b> : <b>.</b>  <b>Mungkin: = a</b> - ungkapan ini mudah dibayangkan, ini adalah daftar nilai yang keberadaannya dipertanyakan. <br><br>  Lebih lanjut, sebagai contoh, kita akan menggunakan empat tipe umum: <b>Reader</b> , <b>State</b> , <b>Either</b> , <b>Maybe</b> . <br><br><h2>  Komposisi dan Transformer </h2><br>  Cara yang paling jelas untuk menerapkan lebih dari satu efek ke ekspresi adalah dengan hanya menanamkan satu ke yang lain, ini adalah komposisi fungsi yang biasa.  Dalam komposisi, efek tidak berpengaruh satu sama lain (kecuali metode <b>Traversable</b> digunakan di atasnya).  Dan untuk menggabungkan banyak efek menjadi satu, transformer digunakan.  Setiap metode memiliki kelebihan dan kekurangan: <br><br>  Komposisi: <br><br><ul><li>  Tidak diperlukan jenis tambahan untuk membuatnya </li><li>  Tidak ada metode umum untuk menggabungkan efek dengan kelas <b>Functor</b> / <b>Applicative</b> / <b>Monad</b> </li><li>  Semuanya menyusun luar biasa sampai datang ke monads </li></ul><br>  Transformer: <br><br><ul><li>  Memungkinkan Anda menggabungkan beberapa efek menjadi satu </li><li>  Tetapi Anda memerlukan jenis yang terpisah (paling sering beberapa <b>jenis baru</b> ) </li><li>  Dengan menggunakan <b>lift,</b> Anda dapat melakukan perhitungan pada setiap lapisan tumpukan transformasi. </li><li>  Tetapi Anda tidak dapat memperhitungkan efek secara terpisah, meskipun ada fungsi khusus </li></ul><br>  Transformer berbeda dari komposisi kopling (saya tidak tahu harus menyebutnya apa secara berbeda).  Memiliki komposisi, Anda dapat mengubahnya menjadi transformator dan sebaliknya.  Skema docking akan membantu kita dengan ini. <br><br><h2>  Skema Docking </h2><br>  Jika kita melihat lebih dekat pada tipe untuk transformator monad, kita dapat mengidentifikasi beberapa pola: <br><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">newtype</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">ReaderT</span></span></span><span class="hljs-class"> rma = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">ReaderT</span></span></span><span class="hljs-class"> { </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">runReaderT</span></span></span><span class="hljs-class"> :: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">r</span></span></span><span class="hljs-class"> -&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ma</span></span></span><span class="hljs-class"> } </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">newtype</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">MaybeT</span></span></span><span class="hljs-class"> ma = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">MaybeT</span></span></span><span class="hljs-class"> { </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">runMaybeT</span></span></span><span class="hljs-class"> :: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">m</span></span></span><span class="hljs-class"> (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Maybe</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class">) } </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">newtype</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">ExceptT</span></span></span><span class="hljs-class"> ema = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">ExceptT</span></span></span><span class="hljs-class"> { </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">runExceptT</span></span></span><span class="hljs-class"> :: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">m</span></span></span><span class="hljs-class"> (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Either</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ea</span></span></span><span class="hljs-class">)) } </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">newtype</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">StateT</span></span></span><span class="hljs-class"> sma = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">StateT</span></span></span><span class="hljs-class"> { </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">runStateT</span></span></span><span class="hljs-class"> :: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">s</span></span></span><span class="hljs-class"> -&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">m</span></span></span><span class="hljs-class"> (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class">,</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">s</span></span></span><span class="hljs-class">) }</span></span></code> </pre><br>  Transformer menggambarkan kasus khusus tentang bagaimana efek pasti dan tidak pasti saat ini harus bertautan. <br><br>  Biarkan <b>t</b> menjadi pasti dan <b>Anda</b> tidak terbatas, coba: <br><br><pre> <code class="haskell hljs"><span class="hljs-type"><span class="hljs-type">Reader</span></span>: r -&gt; ua ===&gt; (-&gt;) r :. u := a ===&gt; t :. u := a <span class="hljs-comment"><span class="hljs-comment">-- t ~ (-&gt;) r Maybe: u (Maybe a) ===&gt; u :. Maybe := a ===&gt; u :. t := a -- t ~ Maybe Either: u (Either ea) ===&gt; u :. Either e := a ===&gt; u :. t := a -- t ~ Either e</span></span></code> </pre><br>  Beberapa efek cukup kompleks dan dapat didefinisikan melalui komposisi efek lain yang lebih sederhana: <br><br><pre> <code class="haskell hljs"><span class="hljs-type"><span class="hljs-type">State</span></span>: s -&gt; u (a, s) ===&gt; (-&gt;) s :. (,) s := a ==&gt; t :. u :. t' := a <span class="hljs-comment"><span class="hljs-comment">-- t ~ (-&gt;) s, t' ~ (,) s newtype State sa = State ((-&gt;) s :. (,) s := a)</span></span></code> </pre><br>  Jika kita melihat lebih dekat pada 3 contoh pertama, kita dapat melihat pola umum: jika di <b>Reader</b> , efek tertentu membungkus yang tidak terbatas (membawanya ke tanda kurung, menjadi objek dari functor), kemudian dengan <b>Either</b> dan <b>Maybe</b> itu sebaliknya - efek tidak terbatas merangkum yang spesifik.  Dalam kasus <b>State,</b> kami bahkan menempatkan functor antara dua efek yang didefinisikan lebih sederhana. <br><br>  Mari kita coba untuk mengekspresikan pola-pola ini dalam tipe: <br><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">newtype</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">TU</span></span></span><span class="hljs-class"> tua = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">TU</span></span></span><span class="hljs-class"> (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">t</span></span></span><span class="hljs-class"> :. </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">u</span></span></span><span class="hljs-class"> := </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class">) </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">newtype</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">UT</span></span></span><span class="hljs-class"> tua = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">UT</span></span></span><span class="hljs-class"> (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">u</span></span></span><span class="hljs-class"> :. </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">t</span></span></span><span class="hljs-class"> := </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class">) </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">newtype</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">TUT</span></span></span><span class="hljs-class"> tut' a = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">TUT</span></span></span><span class="hljs-class"> (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">t</span></span></span><span class="hljs-class"> :. </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">u</span></span></span><span class="hljs-class"> :. </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">t'</span></span></span><span class="hljs-class"> := </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class">)</span></span></code> </pre><br>  Kami baru saja menetapkan skema docking - ini adalah komposisi fungsi dalam bungkus yang menunjukkan posisi efek spesifik dan tidak terbatas. <br><br>  Pada kenyataannya, metode untuk transformer yang namanya dimulai dengan <b>menjalankan</b> cukup menghapus pembungkus transformator, mengembalikan komposisi functors.  Kami menggambarkan kelas jenis tersebut: <br><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Composition</span></span></span><span class="hljs-class"> t </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">where</span></span></span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Primary</span></span></span><span class="hljs-class"> ta :: * run :: ta -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Primary</span></span></span><span class="hljs-class"> ta</span></span></code> </pre><br>  Sekarang kita memiliki cara universal untuk menjalankan sirkuit ini: <br><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">instance</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Composition</span></span></span><span class="hljs-class"> (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">TU</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">tu</span></span></span><span class="hljs-class">) </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">where</span></span></span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Primary</span></span></span><span class="hljs-class"> (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">TU</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">tu</span></span></span><span class="hljs-class">) a = t :. u := a run (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">TU</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">x</span></span></span><span class="hljs-class">) = x instance </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Composition</span></span></span><span class="hljs-class"> (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">UT</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">tu</span></span></span><span class="hljs-class">) where </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Primary</span></span></span><span class="hljs-class"> (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">UT</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">tu</span></span></span><span class="hljs-class">) a = u :. t := a run (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">UT</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">x</span></span></span><span class="hljs-class">) = x instance </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Composition</span></span></span><span class="hljs-class"> (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">TUT</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">tu</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">t'</span></span></span><span class="hljs-class">) where </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Primary</span></span></span><span class="hljs-class"> (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">TUT</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">tu</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">t'</span></span></span><span class="hljs-class">) a = t :. u :. t' := a run (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">TUT</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">x</span></span></span><span class="hljs-class">) = x</span></span></code> </pre><br>  Bagaimana dengan transformer?  Di sini Anda juga akan memerlukan kelas tipe di mana skema docking ditentukan untuk jenis tertentu, metode <b>penanaman</b> dinyatakan untuk meningkatkan efek tidak terbatas ke tingkat transformator dan <b>membangun</b> untuk membangun efek tertentu menjadi transformator: <br><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Composition</span></span></span><span class="hljs-class"> t =&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Transformer</span></span></span><span class="hljs-class"> t </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">where</span></span></span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Schema</span></span></span><span class="hljs-class"> (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">t</span></span></span><span class="hljs-class"> :: * -&gt; *) (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">u</span></span></span><span class="hljs-class"> :: * -&gt; *) = (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">r</span></span></span><span class="hljs-class"> :: * -&gt; *) | r -&gt; tu embed :: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Functor</span></span></span><span class="hljs-class"> u =&gt; u ~&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Schema</span></span></span><span class="hljs-class"> tu build :: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Applicative</span></span></span><span class="hljs-class"> u =&gt; t ~&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Schema</span></span></span><span class="hljs-class"> tu </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> (:&gt;) tua = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Transformer</span></span></span><span class="hljs-class"> t =&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Schema</span></span></span><span class="hljs-class"> tua</span></span></code> </pre><br>  Sekarang tinggal mendeklarasikan instance, mulai dengan <b>Maybe</b> and <b>Either</b> : <br><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">instance</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Transformer</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Maybe</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">where</span></span></span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Schema</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Maybe</span></span></span><span class="hljs-class"> u = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">UT</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Maybe</span></span></span><span class="hljs-class"> u embed x = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">UT</span></span></span><span class="hljs-class"> $ </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Just</span></span></span><span class="hljs-class"> &lt;$&gt; x build x = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">UT</span></span></span><span class="hljs-class"> . pure $ x instance </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Transformer</span></span></span><span class="hljs-class"> (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Either</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">e</span></span></span><span class="hljs-class">) where </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Schema</span></span></span><span class="hljs-class"> (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Either</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">e</span></span></span><span class="hljs-class">) u = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">UT</span></span></span><span class="hljs-class"> (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Either</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">e</span></span></span><span class="hljs-class">) u embed x = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">UT</span></span></span><span class="hljs-class"> $ </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Right</span></span></span><span class="hljs-class"> &lt;$&gt; x build x = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">UT</span></span></span><span class="hljs-class"> . pure $ x</span></span></code> </pre><br>  Kami akan membuat tipe kami sendiri untuk <b>Pembaca</b> , karena tidak ada di <b>pangkalan</b> .  Dan dia juga membutuhkan turunan dari kelas <b>Komposisi</b> , karena ini adalah pembungkus untuk functor panah: <br><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">newtype</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Reader</span></span></span><span class="hljs-class"> ea = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Reader</span></span></span><span class="hljs-class"> (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">e</span></span></span><span class="hljs-class"> -&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class">) instance </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Composition</span></span></span><span class="hljs-class"> (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Reader</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">e</span></span></span><span class="hljs-class">) where </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Primary</span></span></span><span class="hljs-class"> (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Reader</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">e</span></span></span><span class="hljs-class">) a = (-&gt;) ea run (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Reader</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">x</span></span></span><span class="hljs-class">) = x instance </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Transformer</span></span></span><span class="hljs-class"> (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Reader</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">e</span></span></span><span class="hljs-class">) where </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Schema</span></span></span><span class="hljs-class"> (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Reader</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">e</span></span></span><span class="hljs-class">) u = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">TU</span></span></span><span class="hljs-class"> ((-&gt;) e) u embed x = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">TU</span></span></span><span class="hljs-class"> . const $ x build x = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">TU</span></span></span><span class="hljs-class"> $ pure &lt;$&gt; run x</span></span></code> </pre><br>  Lakukan sesuatu yang mirip dengan <b>Negara</b> : <br><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">newtype</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">State</span></span></span><span class="hljs-class"> sa = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">State</span></span></span><span class="hljs-class"> ((-&gt;) s :. (,) s := a) instance </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Composition</span></span></span><span class="hljs-class"> (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">State</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">s</span></span></span><span class="hljs-class">) where </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Primary</span></span></span><span class="hljs-class"> (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">State</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">s</span></span></span><span class="hljs-class">) a = (-&gt;) s :. (,) s := a run (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">State</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">x</span></span></span><span class="hljs-class">) = x instance </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Transformer</span></span></span><span class="hljs-class"> (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">State</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">s</span></span></span><span class="hljs-class">) where </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Schema</span></span></span><span class="hljs-class"> (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">State</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">s</span></span></span><span class="hljs-class">) u = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">TUT</span></span></span><span class="hljs-class"> ((-&gt;) s) u ((,) s) embed x = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">TUT</span></span></span><span class="hljs-class"> $ \s -&gt; (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">s</span></span></span><span class="hljs-class">,) &lt;$&gt; x build x = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">TUT</span></span></span><span class="hljs-class"> $ pure &lt;$&gt; run x</span></span></code> </pre><br><h2>  Sebagai contoh </h2><br>  Masih untuk menguji ini pada masalah dunia nyata - sebagai contoh, kami akan menulis sebuah program yang menghitung penempatan berbagai jenis kurung yang benar. <br><br>  Tentukan jenis untuk tanda kurung: mereka dapat membuka dan menutup;  dan juga memiliki gaya yang berbeda: <br><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Shape</span></span></span><span class="hljs-class"> = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Opened</span></span></span><span class="hljs-class"> | </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Closed</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Style</span></span></span><span class="hljs-class"> = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Round</span></span></span><span class="hljs-class"> | </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Square</span></span></span><span class="hljs-class"> | </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Angle</span></span></span><span class="hljs-class"> | </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Curly</span></span></span></span></code> </pre><br>  Simbol lain dari program kami tidak menarik: <br><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Symbol</span></span></span><span class="hljs-class"> = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Nevermind</span></span></span><span class="hljs-class"> | </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Bracket</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Style</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Shape</span></span></span></span></code> </pre> <br>  Kami juga menetapkan daftar kesalahan yang mungkin ditemui program kami: <br><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Stumble</span></span></span><span class="hljs-class"> = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Deadend</span></span></span><span class="hljs-class"> (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Int</span></span></span><span class="hljs-class">, </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Style</span></span></span><span class="hljs-class">) </span><span class="hljs-comment"><span class="hljs-class"><span class="hljs-comment">--     | Logjam (Int, Style) --     | Mismatch (Int, Style) (Int, Style) --      </span></span></span></span></code> </pre><br>  Apa efek yang dibutuhkan oleh program kami?  Kami harus menyimpan daftar tanda kurung yang menunggu verifikasi dan kami harus berhenti pada kesalahan pertama yang ditemui.  Kami membuat transformator: <br><br><pre> <code class="haskell hljs"><span class="hljs-type"><span class="hljs-type">State</span></span> [(<span class="hljs-type"><span class="hljs-type">Int</span></span>, <span class="hljs-type"><span class="hljs-type">Style</span></span>)] :&gt; <span class="hljs-type"><span class="hljs-type">Either</span></span> <span class="hljs-type"><span class="hljs-type">Stumble</span></span> := ()</code> </pre> <br>  Algoritma ini sederhana: kita melalui struktur dengan tanda kurung yang diindeks, jika setelah bagian kita tidak menemukan kesalahan dan kita masih memiliki tanda kurung di negara bagian, maka braket terbuka tidak memiliki yang tertutup: <br><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">checking</span></span> :: <span class="hljs-type"><span class="hljs-type">Traversable</span></span> t =&gt; t (<span class="hljs-type"><span class="hljs-type">Int</span></span>, <span class="hljs-type"><span class="hljs-type">Symbol</span></span>) -&gt; <span class="hljs-type"><span class="hljs-type">Either</span></span> <span class="hljs-type"><span class="hljs-type">Stumble</span></span> () checking struct = run (traverse proceed struct) [] &gt;&gt;= \<span class="hljs-keyword"><span class="hljs-keyword">case</span></span> (s : _, _) -&gt; <span class="hljs-type"><span class="hljs-type">Left</span></span> . <span class="hljs-type"><span class="hljs-type">Logjam</span></span> $ s <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> ([], _) -&gt; <span class="hljs-type"><span class="hljs-type">Right</span></span> ()</code> </pre><br>  Kami ingat setiap braket terbuka, bandingkan yang tertutup dengan yang terakhir diingat terbuka: <br><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">proceed</span></span> :: (<span class="hljs-type"><span class="hljs-type">Int</span></span>, <span class="hljs-type"><span class="hljs-type">Symbol</span></span>) -&gt; <span class="hljs-type"><span class="hljs-type">State</span></span> [(<span class="hljs-type"><span class="hljs-type">Int</span></span>, <span class="hljs-type"><span class="hljs-type">Style</span></span>)] :&gt; <span class="hljs-type"><span class="hljs-type">Either</span></span> <span class="hljs-type"><span class="hljs-type">Stumble</span></span> := () proceed (_, <span class="hljs-type"><span class="hljs-type">Nevermind</span></span>) = pure () proceed (n, <span class="hljs-type"><span class="hljs-type">Bracket</span></span> style <span class="hljs-type"><span class="hljs-type">Opened</span></span>) = build . modify . (:) $ (n, style) procceed (n, <span class="hljs-type"><span class="hljs-type">Bracket</span></span> closed <span class="hljs-type"><span class="hljs-type">Closed</span></span>) = build get &gt;&gt;= \<span class="hljs-keyword"><span class="hljs-keyword">case</span></span> []-&gt; embed $ <span class="hljs-type"><span class="hljs-type">Left</span></span> . <span class="hljs-type"><span class="hljs-type">Deadend</span></span> $ (n, closed) ((m, opened) : ss) -&gt; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> closed /= opened <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> embed . <span class="hljs-type"><span class="hljs-type">Left</span></span> $ <span class="hljs-type"><span class="hljs-type">Mismatch</span></span> (m, opened) (n, closed) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> build $ put ss <span class="hljs-keyword"><span class="hljs-keyword">where</span></span></code> </pre><br><h2>  Kesimpulan </h2><br>  Menggunakan skema docking, memiliki beberapa komposisi fungsi, kita dapat mengubahnya menjadi transfomers dan sebaliknya.  Sayangnya, trik seperti itu tidak akan berhasil dengan ibu dari monad - sekuel.  Dan semuanya karena mereka tidak dapat dibayangkan sebagai komposisi dari para pelaku, tetapi itu mungkin sebagai komposisi dari para ahli ... ... Namun, ini adalah kisah yang sama sekali berbeda. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Kode Perpustakaan tentang Github</a> |  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Dokumentasi Hackage</a> |  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Contoh parenthesis</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id467683/">https://habr.com/ru/post/id467683/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id467673/index.html">Fitur Go bawaan</a></li>
<li><a href="../id467675/index.html">Pemodelan status aplikasi menggunakan objek Store di SwiftUI</a></li>
<li><a href="../id467677/index.html">Tes atau tipe</a></li>
<li><a href="../id467679/index.html">PyCrunch - Eksekusi uji cerdas dan cakupan kode visual dalam IDE</a></li>
<li><a href="../id467681/index.html">Routing SOAP Memutar Kerentanan</a></li>
<li><a href="../id467689/index.html">Gambaran kecil tentang SIMD di .NET / C #</a></li>
<li><a href="../id467691/index.html">Intel Nervana NNP-T dan NNP-I - chip khusus untuk AI</a></li>
<li><a href="../id467693/index.html">September Digest Event TI (Bagian Dua)</a></li>
<li><a href="../id467697/index.html">Benarkah GOPATH dan GOROOT tidak lagi dibutuhkan?</a></li>
<li><a href="../id467699/index.html">Bagaimana tidak, membuat strlen tercepat dan menemukan kekurangan di Visual Studio 2019 Community</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>