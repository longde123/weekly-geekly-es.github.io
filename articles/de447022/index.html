<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üß§ üèß üçΩÔ∏è Zwingen Sie die Zuh√∂rer nicht zum Nachdenken üçø üë®üèº‚Äçüåæ ü§Ωüèº</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Einf√ºhrung 



 W√§hrend des Entwicklungsprozesses ist es h√§ufig erforderlich, eine Instanz einer Klasse zu erstellen, deren Name in der XML-Konfigurat...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Zwingen Sie die Zuh√∂rer nicht zum Nachdenken</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/haulmont/blog/447022/"><h2 id="vvedenie">  Einf√ºhrung </h2><br><p><img src="https://habrastorage.org/webt/c0/6s/s8/c06ss8od1zjumrcisda44pa5j0q.png"><br>  W√§hrend des Entwicklungsprozesses ist es h√§ufig erforderlich, eine Instanz einer Klasse zu erstellen, deren Name in der XML-Konfigurationsdatei gespeichert ist, oder eine Methode aufzurufen, deren Name als Zeichenfolge als Wert des Anmerkungsattributs geschrieben ist.  In solchen F√§llen lautet die Antwort: ‚ÄûReflektion verwenden!‚Äú. </p><br><p>  In der neuen Version von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">CUBA Platform bestand</a> eine der Aufgaben zur Verbesserung des Frameworks darin, die explizite Erstellung von Ereignishandlern in den Controller-Klassen der UI-Bildschirme zu beseitigen.  In fr√ºheren Versionen waren die Handler-Deklarationen in der Controller-Initialisierungsmethode sehr √ºberladen mit dem Code. In der siebten Version haben wir uns daher entschlossen, alles zu bereinigen. </p><a name="habracut"></a><br><p> Ein Ereignis-Listener ist nur ein Verweis auf die Methode, die zum richtigen Zeitpunkt aufgerufen werden muss (siehe <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Observer-Vorlage</a> ).  Eine solche Vorlage ist mit der Klasse <code>java.lang.reflect.Method</code> recht einfach zu implementieren.  Beim Start m√ºssen Sie nur die Klassen scannen, die mit Anmerkungen versehenen Methoden aus ihnen herausziehen, die Verweise auf sie speichern und die Links (oder Methoden) verwenden, um die Methode (oder Methoden) aufzurufen, wenn das Ereignis auftritt, wie dies in den meisten Frameworks der Fall ist.  Das einzige, was uns daran gehindert hat, war, dass traditionell viele Ereignisse in der Benutzeroberfl√§che generiert werden. Wenn Sie die Reflection-API verwenden, m√ºssen Sie einen Preis in Form des Zeitpunkts des Methodenaufrufs zahlen.  Aus diesem Grund haben wir uns √ºberlegt, wie Sie Event-Handler ohne Reflexion erstellen k√∂nnen. </p><br><p>  Wir haben bereits Materialien √ºber <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">MethodHandles</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">LambdaMetafactory auf einem Habr ver√∂ffentlicht</a> , und dieses Material ist eine Art Fortsetzung.  Wir werden die Vor- und Nachteile der Verwendung der Reflection-API sowie Alternativen untersuchen - das Generieren von Code mit AOT-Kompilierung und LambdaMetafactory sowie dessen Verwendung im CUBA-Framework. </p><br><h2 id="reflection-staryy-dobryy-nadezhnyy">  Reflexion: Alt.  Gut  Zuverl√§ssig </h2><br><p>  <em>In der Informatik bedeutet Reflexion oder Reflexion (das Holonym f√ºr Selbstbeobachtung, englische Reflexion) einen Prozess, bei dem ein Programm zur Laufzeit seine eigene Struktur und sein eigenes Verhalten verfolgen und √§ndern kann.</em>  (c) Wikipedia. </p><br><p>  F√ºr die meisten Java-Entwickler ist Reflexion nie neu.  Es scheint mir, dass Java ohne diesen Mechanismus nicht zu Java geworden w√§re, das jetzt einen gro√üen Marktanteil in der Entwicklung von Anwendungssoftware einnimmt.  Denken Sie nur: Proxy, Binden von Methoden an Ereignisse durch Anmerkungen, Abh√§ngigkeitsinjektion, Aspekte und sogar Instanziieren des JDBC-Treibers in den ersten Versionen von JDK!  Reflexion √ºberall ist der Eckpfeiler aller modernen Rahmenbedingungen. </p><br><p>  Gibt es Probleme mit der Reflexion in Bezug auf unsere Aufgabe?  Wir haben drei identifiziert: </p><br><p>  <em>Geschwindigkeit</em> - Ein Methodenaufruf √ºber die Reflection-API ist langsamer als ein direkter Aufruf.  In jeder neuen Version der JVM beschleunigen Entwickler Aufrufe st√§ndig durch Reflektion, der JIT-Compiler versucht, den Code noch weiter zu optimieren, aber der Unterschied zum direkten Methodenaufruf ist sp√ºrbar. </p><br><p>  <em>Eingabe</em> - Wenn Sie im Code <code>java.lang.reflect.Method</code> verwenden, ist dies nur ein Verweis auf eine Methode.  Und nirgends steht geschrieben, wie viele Parameter √ºbergeben werden und welcher Typ sie sind.  Ein Aufruf mit den falschen Parametern f√ºhrt zur Laufzeit zu einem Fehler und nicht zum Zeitpunkt des Kompilierens oder Herunterladens der Anwendung. </p><br><p>  <em>Transparenz</em> - Wenn die durch Reflektion aufgerufene Methode fehlschl√§gt, m√ºssen wir mehrere <code>invoke()</code> -Aufrufe durchlaufen <code>invoke()</code> bevor wir der eigentlichen Fehlerursache auf den Grund gehen. </p><br><p>  Wenn wir uns jedoch den Code der Spring- oder JPA-Ereignishandler in Hibernate ansehen, befindet sich die gute alte <code>java.lang.reflect.Method</code> im Inneren.  Und in naher Zukunft wird sich dies wahrscheinlich nicht √§ndern.  Diese Frameworks sind zu gro√ü und zu stark an sie gebunden, und es scheint, dass die Leistung der Ereignishandler auf der Serverseite ausreicht, um dar√ºber nachzudenken, durch was Sie Aufrufe durch Reflexion ersetzen k√∂nnen. </p><br><p>  Und welche anderen M√∂glichkeiten gibt es? </p><br><h2 id="aot-kompilyaciya-i-kodogeneraciya---vernem-prilozheniyam-skorost">  AOT-Kompilierung und Codegenerierung - geben Sie Anwendungen Geschwindigkeit zur√ºck! </h2><br><p>  Der erste Kandidat, der die Reflection-API ersetzt, ist die Codegenerierung.  Jetzt tauchen Frameworks wie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Micronaut</a> oder <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Quarkus</a> auf, die versuchen, zwei Probleme zu l√∂sen: Reduzierung der Startgeschwindigkeit der Anwendung und Reduzierung des Speicherverbrauchs.  Diese beiden Metriken sind in unserem Zeitalter von Containern, Microservices und serverlosen Architekturen von entscheidender Bedeutung, und neue Frameworks versuchen, dies durch AOT-Kompilierung zu l√∂sen.  Mit verschiedenen Techniken (die Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> zum Beispiel lesen k√∂nnen) wird der Anwendungscode so ge√§ndert, dass alle reflexiven Aufrufe von Methoden, Konstruktoren usw. erfolgen.  durch direkte Anrufe ersetzt.  Daher m√ºssen Sie beim Start der Anwendung keine Klassen scannen und Beans erstellen, und JIT optimiert den Code zur Laufzeit effizienter, wodurch die Leistung von Anwendungen, die auf solchen Frameworks basieren, erheblich gesteigert wird.  Hat dieser Ansatz Nachteile?  Antwort: Nat√ºrlich gibt es. </p><br><p>  Erstens f√ºhren Sie den von Ihnen geschriebenen Code nicht aus. Der Quellcode √§ndert sich w√§hrend der Kompilierung. Wenn also etwas schief geht, ist es manchmal schwierig zu verstehen, wo der Fehler liegt: in Ihrem Code oder im Generierungsalgorithmus (normalerweise nat√ºrlich in Ihrem )  Und von hier aus tritt das Debugging-Problem auf - Sie m√ºssen Ihren eigenen Code debuggen. </p><br><p>  Die zweite - um eine Anwendung auszuf√ºhren, die im Framework mit AOT-Kompilierung geschrieben wurde, ben√∂tigen Sie ein spezielles Tool.  Sie k√∂nnen beispielsweise nicht einfach eine in Quarkus geschriebene Anwendung abrufen und ausf√ºhren.  Wir ben√∂tigen ein spezielles Plugin f√ºr maven / gradle, das Ihren Code vorverarbeitet.  Und jetzt m√ºssen Sie bei Fehlern im Framework nicht nur die Bibliotheken, sondern auch das Plugin aktualisieren. </p><br><p>  In Wahrheit ist die Codegenerierung auch in der Java-Welt nicht neu, sie ist bei <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Micronaut</a> oder <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Quarkus</a> nicht <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">aufgetreten</a> .  In der einen oder anderen Form wird es von einigen Frameworks verwendet.  Hier k√∂nnen wir uns an lombok, aspectj mit seiner vorl√§ufigen Generierung von Code f√ºr Aspekte oder Eclipselink erinnern, der Entit√§tsklassen Code f√ºr eine effizientere Deserialisierung hinzuf√ºgt.  Bei <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">CUBA verwenden</a> wir die Codegenerierung, um Ereignisse √ºber √Ñnderungen im Status einer Entit√§t zu generieren und Validierungsnachrichten in den Klassencode aufzunehmen, um die Arbeit mit Entit√§ten in der Benutzeroberfl√§che zu vereinfachen. </p><br><p>  F√ºr CUBA-Entwickler w√§re die Implementierung der statischen Codegenerierung f√ºr Ereignishandler ein extremer Schritt, da viele √Ñnderungen an der internen Architektur und am Plugin f√ºr die Codegenerierung vorgenommen werden mussten.  Gibt es etwas, das wie Reflexion aussieht, aber schneller ist? </p><br><h2 id="lambdametafactory---takie-zhe-vyzovy-metodov-no-bystree">  LambdaMetafactory - gleiche Methodenaufrufe, aber schneller </h2><br><p>  Java 7 hat eine neue Anweisung f√ºr die JVM eingef√ºhrt - <code>invokedynamic</code> .  √úber sie gibt es hier einen ausgezeichneten Bericht von Vladimir Ivanov auf jug.ru.  Urspr√ºnglich f√ºr die Verwendung in dynamischen Sprachen wie Groovy konzipiert, war diese Anweisung ein hervorragender Kandidat f√ºr den Aufruf von Methoden in Java ohne Verwendung von Reflexion.  Gleichzeitig mit der neuen Anweisung wurde im JDK eine zugeh√∂rige API angezeigt: </p><br><ul><li>  Class <code>MethodHandle</code> - erschien bereits in Java 7, wird aber immer noch nicht sehr oft verwendet </li><li>  <code>LambdaMetafactory</code> - diese Klasse ist bereits aus Java 8, es wurde eine Weiterentwicklung der API f√ºr dynamische Aufrufe, verwendet <code>MethodHandle</code> Inneren. </li></ul><br><p>  Es schien, dass <code>MethodHandle</code> , das im Wesentlichen ein typisierter Zeiger auf eine Methode (Konstruktor usw.) ist, die Rolle von <code>java.lang.reflect.Method</code> erf√ºllen kann.  Die Aufrufe sind schneller, da alle Typpr√ºfungen, die in der Reflection-API bei jedem Aufruf durchgef√ºhrt werden, in diesem Fall nur einmal ausgef√ºhrt werden, wenn das <code>MethodHandle</code> . </p><br><p>  <code>MethodHandle</code> erwies sich das reine <code>MethodHandle</code> als noch langsamer als Aufrufe √ºber die Reflection-API.  Leistungssteigerungen k√∂nnen erzielt werden, indem <code>MethodHandle</code> statisch gemacht wird, jedoch nicht in allen F√§llen.  Es gibt eine ausgezeichnete Diskussion √ºber die Geschwindigkeit von <code>MethodHandle</code> Aufrufen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">auf der OpenJDK-Mailingliste</a> . </p><br><p>  Aber als die <code>LambdaMetafactory</code> Klasse <code>LambdaMetafactory</code> , gab es eine echte Chance, Methodenaufrufe zu beschleunigen.  <code>LambdaMetafactory</code> k√∂nnen <code>LambdaMetafactory</code> ein Lambda-Objekt erstellen und einen direkten Methodenaufruf darin <code>MethodHandle</code> , der √ºber das <code>MethodHandle</code> abgerufen werden <code>MethodHandle</code> .  Anschlie√üend k√∂nnen Sie mit dem generierten Objekt die gew√ºnschte Methode aufrufen.  Hier ist ein Beispiel f√ºr die Generierung, die die als Parameter an BiFunction √ºbergebene Getter-Methode umschlie√üt: </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> BiFunction </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createGetHandlerLambda</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Object bean, Method method)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> Throwable </span></span>{ MethodHandles.Lookup caller = MethodHandles.lookup(); CallSite site = LambdaMetafactory.metafactory(caller, <span class="hljs-string"><span class="hljs-string">"apply"</span></span>, MethodType.methodType(BiFunction.class), MethodType.methodType(Object.class, Object.class, Object.class), caller.findVirtual(bean.getClass(), method.getName(), MethodType.methodType(method.getReturnType(), method.getParameterTypes()[<span class="hljs-number"><span class="hljs-number">0</span></span>])), MethodType.methodType(method.getReturnType(), bean.getClass(), method.getParameterTypes()[<span class="hljs-number"><span class="hljs-number">0</span></span>])); MethodHandle factory = site.getTarget(); BiFunction listenerMethod = (BiFunction) factory.invoke(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> listenerMethod; }</code> </pre> <br><p>  Als Ergebnis erhalten wir eine Instanz von BiFunction anstelle von Method.  Und jetzt, selbst wenn wir Method in unserem Code verwendet haben, ist es nicht schwierig, sie durch BiFunction zu ersetzen.  Nehmen Sie den echten (leicht vereinfachten, wahren) Code zum Aufrufen des Methodenhandlers mit der <code>@EventListener</code> aus dem Spring Framework: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ApplicationListenerMethodAdapter</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">GenericApplicationListener</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Method method; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onApplicationEvent</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ApplicationEvent event)</span></span></span><span class="hljs-function"> </span></span>{ Object bean = getTargetBean(); Object result = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.method.invoke(bean, event); handleResult(result); } }</code> </pre> <br><p>  Und hier ist der gleiche Code, der jedoch einen Methodenaufruf √ºber ein Lambda verwendet: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ApplicationListenerLambdaAdapter</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ApplicationListenerMethodAdapter</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> BiFunction funHandler; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onApplicationEvent</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ApplicationEvent event)</span></span></span><span class="hljs-function"> </span></span>{ Object bean = getTargetBean(); Object result = funHandler.apply(bean, event); handleResult(result); } }</code> </pre> <br><p>  Minimale √Ñnderungen, die Funktionalit√§t ist die gleiche, aber es gibt Vorteile: </p><br><p>  <em>Ein Lambda hat einen Typ</em> - er wird bei der Erstellung angegeben, sodass der Aufruf von ‚Äûnur eine Methode‚Äú fehlschl√§gt. </p><br><p>  <em>Der Trace-Stack ist k√ºrzer</em> - beim Aufrufen einer Methode √ºber ein Lambda wird nur ein zus√§tzlicher Aufruf hinzugef√ºgt - <code>apply()</code> .  Und alle.  Als n√§chstes wird die Methode selbst aufgerufen. </p><br><p>  Aber die Geschwindigkeit muss gemessen werden. </p><br><h3 id="zameryaem-skorost">  Messen Sie die Geschwindigkeit </h3><br><p>  Um die Hypothese zu testen, haben wir mit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">JMH</a> ein Mikrobenchmark erstellt, um die Ausf√ºhrungszeit und den Durchsatz zu vergleichen, wenn dieselbe Methode auf unterschiedliche Weise aufgerufen wird: √ºber die Reflection-API, √ºber LambdaMetafactory, und einen direkten Methodenaufruf zum Vergleich hinzugef√ºgt.  Vor Beginn des Tests wurden Links zu Methode und Lambdas erstellt und zwischengespeichert. </p><br><p>  Testparameter: </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@BenchmarkMode</span></span>({Mode.Throughput, Mode.AverageTime}) <span class="hljs-meta"><span class="hljs-meta">@Warmup</span></span>(iterations = <span class="hljs-number"><span class="hljs-number">5</span></span>, time = <span class="hljs-number"><span class="hljs-number">1000</span></span>, timeUnit = TimeUnit.MILLISECONDS) <span class="hljs-meta"><span class="hljs-meta">@Measurement</span></span>(iterations = <span class="hljs-number"><span class="hljs-number">10</span></span>, time = <span class="hljs-number"><span class="hljs-number">1000</span></span>, timeUnit = TimeUnit.MILLISECONDS)</code> </pre> <br><p>  Der Test selbst kann von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">GitHub</a> heruntergeladen und bei Interesse selbst ausgef√ºhrt werden. </p><br><p>  Testergebnisse f√ºr Oracle JDK 11.0.2 und JMH 1.21 (die Zahlen k√∂nnen variieren, aber der Unterschied bleibt sp√ºrbar und ungef√§hr gleich): </p><br><table><thead><tr><th>  <strong>Test - Wert erhalten</strong> </th><th>  <strong>Durchsatz (ops / us)</strong> </th><th>  <strong>Ausf√ºhrungszeit (us / op)</strong> </th></tr></thead><tbody><tr><td>  LambdaGetTest </td><td>  72 </td><td>  0,0118 </td></tr><tr><td>  ReflectionGetTest </td><td>  65 </td><td>  0,0177 </td></tr><tr><td>  DirectMethodGetTest </td><td>  260 </td><td>  0,0048 </td></tr><tr><td>  <strong>Test - Wert einstellen</strong> </td><td>  <strong>Durchsatz (ops / us)</strong> </td><td>  <strong>Ausf√ºhrungszeit (us / op</strong> </td></tr><tr><td>  LambdaSetTest </td><td>  96 </td><td>  0,0092 </td></tr><tr><td>  ReflectionSetTest </td><td>  58 </td><td>  0,0173 </td></tr><tr><td>  DirectMethodSetTest </td><td>  415 </td><td>  0,0031 </td></tr></tbody></table><br><p>  Im Durchschnitt stellte sich heraus, dass das Aufrufen einer Methode √ºber ein Lambda etwa 30% schneller ist als √ºber eine Reflection-API.  Es gibt hier eine weitere gro√üartige Diskussion √ºber die Leistung des Methodenaufrufs <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">,</a> wenn sich jemand f√ºr die Details interessiert.  Kurz gesagt - der Geschwindigkeitsgewinn wird unter anderem dadurch erzielt, dass die generierten Lambdas in den Programmcode eingef√ºgt werden k√∂nnen und im Gegensatz zur Reflexion noch keine Typpr√ºfungen durchgef√ºhrt werden. </p><br><p>  Nat√ºrlich ist dieser Benchmark recht einfach. Er beinhaltet nicht das Aufrufen von Methoden in einer Klassenhierarchie oder das Messen der Geschwindigkeit beim Aufrufen endg√ºltiger Methoden.  Wir haben jedoch komplexere Messungen durchgef√ºhrt, und die Ergebnisse waren immer f√ºr die Verwendung von LambdaMetafactory. </p><br><h2 id="ispolzovanie">  Verwenden Sie </h2><br><p>  Im CUBA-Framework der Version 7 k√∂nnen Sie in UI-Controllern die Annotation <code>@Subscribe</code> , um eine Methode f√ºr bestimmte Benutzeroberfl√§chenereignisse zu ‚Äûsignieren‚Äú.  Intern wird dies in <code>LambdaMetafactory</code> implementiert, Links zu Listener-Methoden werden beim ersten Aufruf erstellt und zwischengespeichert. </p><br><p>  Diese Innovation erm√∂glichte es, den Code stark zu l√∂schen, insbesondere bei Formularen mit einer gro√üen Anzahl von Elementen, einer komplexen Interaktion und dementsprechend mit einer gro√üen Anzahl von Ereignishandlern.  Ein einfaches Beispiel aus CUBA QuickStart: Stellen Sie sich vor, Sie m√ºssen den Bestellbetrag neu berechnen, wenn Sie Produktartikel hinzuf√ºgen oder entfernen.  Sie m√ºssen Code schreiben, der die Methode <code>calculateAmount()</code> ausf√ºhrt, wenn sich die Auflistung in der Entit√§t √§ndert.  Wie es vorher aussah: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">OrderEdit</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AbstractEditor</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Order</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Inject</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> CollectionDatasource&lt;OrderLine, UUID&gt; linesDs; <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">init</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( Map&lt;String, Object&gt; params)</span></span></span><span class="hljs-function"> </span></span>{ linesDs.addCollectionChangeListener(e -&gt; calculateAmount()); } ... }</code> </pre> <br><p>  Und in CUBA 7 sieht der Code folgenderma√üen aus: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">OrderEdit</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">StandardEditor</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Order</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Subscribe</span></span>(id = <span class="hljs-string"><span class="hljs-string">"linesDc"</span></span>, target = Target.DATA_CONTAINER) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onOrderLinesDcCollectionChange</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(CollectionChangeEvent&lt;OrderLine&gt; event)</span></span></span><span class="hljs-function"> </span></span>{ calculateAmount(); } ... }</code> </pre> <br><p>  Fazit: Der Code ist sauberer und es gibt keine magische <code>init()</code> -Methode, die mit zunehmender Komplexit√§t des Formulars tendenziell w√§chst und sich mit Ereignishandlern f√ºllt.  Und doch - wir m√ºssen nicht einmal ein Feld mit der Komponente erstellen, die wir abonnieren. CUBA findet diese Komponente anhand der ID. </p><br><h3 id="vyvody">  Schlussfolgerungen </h3><br><p>  Trotz des Aufkommens einer neuen Generation von Frameworks mit AOT-Kompilierung ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Micronaut</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Quarkus</a> ), die unbestreitbare Vorteile gegen√ºber ‚Äûtraditionellen‚Äú Frameworks haben (haupts√§chlich im Vergleich zu <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Spring</a> ), wird immer noch eine gro√üe Menge Code mithilfe der Reflection-API geschrieben (und danke f√ºr den gleichen Fr√ºhling).  Und es sieht so aus, als ob das Spring Framework derzeit immer noch f√ºhrend unter den Frameworks f√ºr die Anwendungsentwicklung ist, und wir werden noch lange mit reflexionsbasiertem Code arbeiten. </p><br><p>  Und wenn Sie dar√ºber nachdenken, die Reflection-API in Ihrem Code zu verwenden - sei es eine Anwendung oder ein Framework -, √ºberlegen Sie es sich zweimal.  Zuerst √ºber die Codegenerierung und dann √ºber MethodHandles / LambdaMetafactory.  Die zweite Methode kann sich als schneller herausstellen, und der Entwicklungsaufwand wird nicht h√∂her sein als bei Verwendung der Reflection-API. </p><br><p>  <em>Einige weitere n√ºtzliche Links:</em> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Eine schnellere Alternative zu Java Reflection</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Lambda-Ausdr√ºcke in Java hacken</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Methodenhandles in Java</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Java Reflection, aber viel schneller</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Warum ist LambdaMetafactory 10% langsamer als ein statischer MethodHandle, aber 80% schneller als ein nicht statischer MethodHandle?</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Zu schnell, zu megamorph: Was beeinflusst die Leistung von Methodenaufrufen in Java?</a> <br></p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de447022/">https://habr.com/ru/post/de447022/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de447010/index.html">Nicht lange spielte die Musik ... oder wie das Betriebssystem Elbrus nie frei wurde</a></li>
<li><a href="../de447014/index.html">Einweg-Ref-Strukturen in C # 8.0</a></li>
<li><a href="../de447016/index.html">25 Jahre sp√§ter: ein Interview mit Linus Torvalds</a></li>
<li><a href="../de447018/index.html">Quantenanreicherung in einer Multi-Welt-Interpretation</a></li>
<li><a href="../de447020/index.html">Bei Produktivit√§t geht es nicht um Zeitmanagement, sondern um Aufmerksamkeitsmanagement</a></li>
<li><a href="../de447024/index.html">Wie kann man die Vorteile eines Laptops und eines Desktop-Computers kombinieren? Analyse des Problems und L√∂sungen</a></li>
<li><a href="../de447026/index.html">Wir schreiben den OTA-Loader f√ºr ATmega128RFA1 (als Teil des Smart Response XE-Ger√§ts)</a></li>
<li><a href="../de447028/index.html">Steganographie vergangene Dateien: Wir verstecken Daten direkt in Sektoren</a></li>
<li><a href="../de447034/index.html">Mit dem neuen Fehler in Telegram Desktop k√∂nnen Sie die letzte Nachricht lesen</a></li>
<li><a href="../de447036/index.html">Ein Cocktail f√ºr eine gesunde Ern√§hrung - er wird von einem Startup des Beschleunigers der ITMO University hergestellt</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>