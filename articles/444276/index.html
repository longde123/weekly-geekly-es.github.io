<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üòä üï¢ üëÜ Introducci√≥n para reaccionar la arquitectura de fibra üëê ü§© üßëüèΩ‚Äçü§ù‚Äçüßëüèº</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hola Habr! Les traigo a su atenci√≥n una traducci√≥n del art√≠culo "React Fiber Architecture" de Andrew Clark . 
 Entrada 


 React Fiber es una implemen...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Introducci√≥n para reaccionar la arquitectura de fibra</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/444276/"><p> Hola Habr!  Les traigo a su atenci√≥n una traducci√≥n del art√≠culo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">"React Fiber Architecture"</a> de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Andrew Clark</a> . </p><br><h2 id="vstuplenie">  Entrada </h2><br><p>  React Fiber es una implementaci√≥n progresiva del algoritmo clave React.  Esta es la culminaci√≥n de un estudio de dos a√±os realizado por el equipo de desarrollo de React. </p><br><p>  El objetivo de Fiber es aumentar la productividad al desarrollar tareas como la animaci√≥n, organizar elementos en una p√°gina y mover elementos.  Su caracter√≠stica principal es la representaci√≥n incremental: la capacidad de dividir el trabajo de representaci√≥n en unidades y distribuirlas entre m√∫ltiples cuadros. </p><br><p>  Otras caracter√≠sticas clave incluyen la capacidad de pausar, cancelar o reutilizar las actualizaciones entrantes del √°rbol DOM, la capacidad de priorizar diferentes tipos de actualizaciones y tambi√©n la coordinaci√≥n de primitivas. </p><a name="habracut"></a><br><p>  <em>Antes de leer este art√≠culo, le recomendamos que se familiarice con los principios b√°sicos de React:</em> </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Reaccionar componentes, elementos e instancias</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Reconciliacion</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Reaccionar - Conceptos te√≥ricos b√°sicos</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Principios de dise√±o</a> </li></ul><br><h2 id="obzor">  Revisar </h2><br><h4 id="chto-takoe-sverka-reconciliation">  ¬øQu√© es la reconciliaci√≥n? </h4><br><p>  <strong>La reconciliaci√≥n</strong> es un algoritmo de reacci√≥n utilizado para distinguir un √°rbol de elementos de otro para determinar las partes que deben reemplazarse. </p><br><p>  <strong>Una actualizaci√≥n</strong> es un cambio en los datos que se utilizan para representar una aplicaci√≥n React.  Esto suele ser el resultado de llamar al m√©todo setState;  El resultado final de renderizar el componente. </p><br><p>  La idea clave de React API es pensar en las actualizaciones como si pudieran conducir a una representaci√≥n completa de la aplicaci√≥n.  Esto permite que el desarrollador act√∫e de manera declarativa y no se preocupe por lo racional que ser√° la transici√≥n de la aplicaci√≥n de un estado a otro (de A a B, B a C, C a A, etc.). </p><br><p>  En general, la representaci√≥n de la aplicaci√≥n completa para cada cambio solo funciona en las aplicaciones m√°s tradicionales.  En el mundo real, esto afecta negativamente el rendimiento.  La ley incluye optimizaciones que crean una vista de representaci√≥n completa sin afectar una gran parte del rendimiento.  La mayor√≠a de estas optimizaciones implican un proceso llamado reconciliaci√≥n. </p><br><p>  La reconciliaci√≥n es un algoritmo detr√°s de lo que estamos acostumbrados a llamar "DOM virtual".  La definici√≥n suena as√≠: cuando renderiza una aplicaci√≥n React, el √°rbol de elementos que describe la aplicaci√≥n se genera en la memoria reservada.  Luego, este √°rbol se incluye en el entorno de representaci√≥n; con el ejemplo de una aplicaci√≥n de navegador, se traduce en un conjunto de operaciones DOM.  Cuando se actualiza el estado de la aplicaci√≥n (generalmente llamando a setState), se genera un nuevo √°rbol.  El nuevo √°rbol se compara con el anterior para calcular y habilitar exactamente aquellas operaciones que se necesitan para volver a dibujar la aplicaci√≥n actualizada. </p><br><p>  Aunque Fiber es una implementaci√≥n cercana del reconciliador, el algoritmo de alto nivel explicado en la documentaci√≥n de React ser√° pr√°cticamente el mismo. </p><br><h4 id="klyuchevye-ponyatiya">  Conceptos clave: </h4><br><ul><li>  Diferentes tipos de componentes sugieren la generaci√≥n de √°rboles sustancialmente diferentes.  React no intentar√° compararlos, sino que simplemente reemplazar√° el √°rbol viejo por completo. </li><li>  Las listas se distinguen usando claves.  Las claves deben ser "persistentes, predecibles y √∫nicas". </li></ul><br><h2 id="sverka-protiv-renderinga">  Reconciliaci√≥n vs. Renderizado </h2><br><p>  El √°rbol DOM es uno de los entornos que React puede dibujar, el resto se puede atribuir a las vistas nativas de iOS y Android usando React Native (es por eso que Virtual Dom es un nombre poco apropiado). </p><br><p>  La raz√≥n por la que React admite tantos objetivos es porque React est√° dise√±ado para que la reconciliaci√≥n y la representaci√≥n sean fases separadas.  El reconciliador, trabajando, calcula qu√© partes del √°rbol han cambiado, el procesador luego usa esta informaci√≥n para actualizar el √°rbol renderizado previamente. </p><br><p>  Esta separaci√≥n significa que React DOM y React Native pueden usar sus propios mecanismos de representaci√≥n cuando usan la misma herramienta de representaci√≥n que se encuentra en React Core. </p><br><p>  La fibra es una implementaci√≥n redise√±ada del algoritmo de reconciliaci√≥n.  Tiene una relaci√≥n indirecta con el renderizado, mientras que los mecanismos de renderizado (renders) se pueden cambiar para admitir todas las ventajas de la nueva arquitectura. </p><br><p>  <strong>La planificaci√≥n</strong> es un proceso que determina cu√°ndo se debe completar el trabajo. </p><br><p>  <strong>Trabajo</strong> : cualquier c√°lculo que deba realizarse.  El trabajo suele ser el resultado de una actualizaci√≥n (por ejemplo, llamando a setState). </p><br><p>  Los principios de la arquitectura React son tan buenos que solo se pueden describir con esta cita: </p><br><blockquote>  En la implementaci√≥n actual de React, atraviesa el √°rbol de forma recursiva y llama a las funciones de representaci√≥n en todo el √°rbol actualizado en una sola marca (16 ms).  Sin embargo, en el futuro, podr√° cancelar algunas actualizaciones para evitar saltos de fotogramas. <br>  Este es un tema frecuentemente discutido con respecto al dise√±o de React.  Algunas bibliotecas populares implementan un enfoque "push", donde los c√°lculos se realizan cuando hay nuevos datos disponibles.  Sin embargo, React se adhiere al enfoque de extracci√≥n, donde los c√°lculos pueden cancelarse cuando sea necesario. <br>  React no es una biblioteca para procesar datos generalizados.  Esta es una biblioteca para construir interfaces de usuario.  Creemos que debe tener una posici√≥n √∫nica en la aplicaci√≥n para determinar qu√© c√°lculos son adecuados y cu√°les no en este momento. <br>  Si hay algo detr√°s de escena, entonces podemos deshacer toda la l√≥gica asociada con √©l.  Si los datos llegan m√°s r√°pido que la velocidad de representaci√≥n de cuadros, podemos combinar las actualizaciones.  Podemos aumentar la prioridad del trabajo que surge como resultado de la interacci√≥n del usuario (como la aparici√≥n de una animaci√≥n cuando se presiona un bot√≥n) frente a un trabajo menos importante en segundo plano (renderizar nuevo contenido cargado desde el servidor) para evitar descargas de cuadros. </blockquote><br><h4 id="klyuchevye-ponyatiya-1">  Conceptos clave: </h4><br><ul><li>  En las interfaces de usuario, no es importante que cada actualizaci√≥n se aplique de inmediato;  de hecho, este comportamiento ser√° superfluo, contribuir√° a la ca√≠da de cuadros y al deterioro de UX. </li><li>  Los diferentes tipos de actualizaciones tienen diferentes prioridades: las actualizaciones de animaci√≥n deben terminar m√°s r√°pido que, por ejemplo, actualizar el almacenamiento de datos. </li><li>  Un enfoque basado en push requiere que la aplicaci√≥n (usted, el desarrollador) decida c√≥mo planificar el trabajo.  Un enfoque basado en la extracci√≥n permite que el marco tome decisiones por usted. </li></ul><br><p>  Reaccionar en este momento no tiene la ventaja de planificar en gran medida;  Los resultados de la actualizaci√≥n para todo el sub√°rbol se dibujar√°n de inmediato.  La idea clave de Fiber es seleccionar cuidadosamente los elementos en el algoritmo React kernel para aplicar la programaci√≥n. </p><br><h2 id="chto-zhe-takoe-fiber">  ¬øQu√© es la fibra? </h2><br><p>  Discutiremos el coraz√≥n de la arquitectura React Fiber.  La fibra es una abstracci√≥n de nivel inferior sobre la aplicaci√≥n que los desarrolladores est√°n acostumbrados a pensar.  Si considera que sus intentos de comprenderlo no tienen esperanza, no se sienta desanimado (no est√° solo).  Sigue buscando y finalmente dar√° sus frutos. </p><br><p>  Y asi! </p><br><p>  Hemos logrado ese objetivo principal de la arquitectura de Fiber: dejar que React aproveche la planificaci√≥n.  Espec√≠ficamente, necesitamos poder: </p><br><ul><li>  Detenga el trabajo y vuelva a √©l m√°s tarde. </li><li>  priorizar diferentes tipos de trabajo. </li><li>  Reutilice el trabajo realizado anteriormente. </li><li>  cancelar el trabajo si ya no es necesario. </li></ul><br><p>  Para hacer todo esto, primero debemos dividir el trabajo en unidades.  En cierto sentido, esto es fibra.  La fibra representa una unidad de trabajo. </p><br><p>  Para ir m√°s all√°, volvamos al concepto b√°sico de React <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">"componentes como datos de funci√≥n"</a> , a menudo expresados ‚Äã‚Äãcomo: </p><br><pre><code class="javascript hljs">v = f(d)</code> </pre> <br><p>  Con esto se deduce que representar una aplicaci√≥n React es como llamar a una funci√≥n cuyo cuerpo contiene llamadas a otras funciones, y as√≠ sucesivamente.  Esta analog√≠a es √∫til cuando se piensa en fibras. </p><br><p>  La forma en que las computadoras b√°sicamente verifican el orden de ejecuci√≥n de un programa se denomina pila de llamadas.  Cuando se completa la funci√≥n, el nuevo contenedor de pila se agrega a la pila.  Este contenedor de pila representa el trabajo realizado por una funci√≥n. </p><br><p>  Cuando se trabaja con interfaces de usuario, se realiza demasiado trabajo de inmediato y esto es un problema, puede provocar saltos en la animaci√≥n y se ver√° de forma intermitente.  Adem√°s, parte de este trabajo puede no ser necesario si se reemplaza por la actualizaci√≥n m√°s reciente.  En este punto, la comparaci√≥n entre la interfaz de usuario y la funci√≥n diverge, porque los componentes tienen una responsabilidad m√°s espec√≠fica que las funciones en general. <br>  Los √∫ltimos navegadores y React Native implementan API que ayudan a resolver este problema: <br>  requestIdleCallback distribuye tareas para que se invoquen funciones de baja prioridad en un per√≠odo simple, y requestAnimationFrame distribuye tareas para que se invoquen funciones altamente priorizadas en el siguiente marco.  El problema es que para usar estas API debe dividir el trabajo de representaci√≥n en unidades incrementales.  Si solo conf√≠a en la pila de llamadas, el trabajo continuar√° hasta que la pila est√© vac√≠a. </p><br><p>  ¬øNo ser√≠a bueno si pudi√©ramos personalizar el comportamiento de la pila de llamadas para optimizar la visualizaci√≥n de partes de la interfaz de usuario?  ¬øSer√≠a bueno si pudi√©ramos romper la pila de llamadas para manipular contenedores manualmente? </p><br><p>  Este es el llamado de React Fiber.  Fiber es una nueva implementaci√≥n de pila adaptada a los componentes React.  Puede pensar en una sola fibra como un contenedor de pila virtual. </p><br><p>  La ventaja de esta implementaci√≥n de la pila es que puede guardar la pila de contenedores en la memoria y ejecutarla entonces (y donde) que desee.  Esta es una definici√≥n crucial para lograr sus objetivos de planificaci√≥n. </p><br><p>  Adem√°s de la planificaci√≥n, las acciones manuales con la pila revelan el potencial de conceptos tales como consistencia (concurrencia) y manejo de errores (l√≠mites de error). </p><br><p>  En la siguiente secci√≥n, observamos la estructura de las fibras. </p><br><h2 id="struktura-volokna">  Estructura de fibra </h2><br><p>  Espec√≠ficamente, una "fibra" es un objeto JavaScript que contiene informaci√≥n sobre un componente, su entrada y salida. </p><br><p>  La fibra es consistente con el contenedor de la pila, pero tambi√©n es consistente con la esencia del componente. </p><br><p>  Estas son algunas propiedades importantes de la "fibra" (Esta lista no es exhaustiva): </p><br><p>  <strong>Tipo y clave</strong> </p><br><p>  El tipo y la clave sirven tanto a la fibra como a los elementos React.  De hecho, cuando se crea una fibra, estos dos campos se copian directamente a ella. </p><br><p>  El tipo de fibra describe el componente al que corresponde.  Para la composici√≥n de componentes, el tipo es una funci√≥n o clase de componente.  Para componentes de servicio (div, span), el tipo es una cadena. </p><br><p>  Conceptualmente, un tipo es una funci√≥n cuya ejecuci√≥n es rastreada por un contenedor de pila. </p><br><p>  Junto con el tipo, la clave se usa al comparar √°rboles para determinar si la fibra se puede reutilizar. </p><br><p>  <strong>Ni√±o y hermano</strong> <strong><br></strong> <br>  Estos campos apuntan a otras fibras, que describen la estructura recursiva de las fibras. </p><br><p>  El elemento secundario de fibra corresponde al valor que se devolvi√≥ como resultado de llamar al m√©todo de representaci√≥n en el componente.  En el siguiente ejemplo: </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Parent</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">Child</span></span></span></span><span class="xml"><span class="hljs-tag"> /&gt;</span></span></span><span class="xml"> }</span></span></code> </pre> <br><p>  Parent Fiber Child corresponde a Child. </p><br><p>  El campo relativo (o vecino) se usa si render devuelve varios elementos secundarios (una nueva funci√≥n en Fiber): </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Parent</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [<span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">Child1</span></span></span></span><span class="xml"><span class="hljs-tag"> /&gt;</span></span></span><span class="xml">, </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">Child2</span></span></span></span><span class="xml"><span class="hljs-tag"> /&gt;</span></span></span><span class="xml">] }</span></span></code> </pre> <br><p>  Las fibras secundarias son una lista enlazada individualmente en la que se encuentra el primer elemento secundario.  Entonces, en este ejemplo, el ni√±o Parent es Child1, y los parientes de Child1 son Child2. </p><br><p>  Volviendo a nuestra analog√≠a con las funciones, puede pensar en una fibra secundaria como una funci√≥n llamada al final (funci√≥n llamada cola). </p><br><p>  Ejemplo de Wikipedia: </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">data</span></span></span><span class="hljs-function">) </span></span>{ a(data); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> b(data); }</code> </pre> <br><p>  En este ejemplo, la funci√≥n llamada cola es b. </p><br><p>  <strong>Valor de retorno (retorno)</strong> </p><br><p>  La fibra de retorno es la fibra a la que el programa deber√≠a regresar despu√©s de procesar la fibra actual.  Esto es lo mismo que devolver la direcci√≥n del contenedor de la pila. <br>  Tambi√©n se puede considerar una fibra madre. </p><br><p>  Si una fibra tiene m√∫ltiples fibras secundarias, el retorno de cada fibra secundaria devuelve la fibra primaria.  En el ejemplo anterior, la fibra de retorno de Child1 y Child2 es Parent. </p><br><p>  <strong>Propiedades actuales y en cach√© (pendientesProps y memorizedProps)</strong> </p><br><p>  Conceptualmente, las propiedades son argumentos de funci√≥n.  Las propiedades de fibra actuales son un conjunto de estas propiedades al comienzo de la ejecuci√≥n, las en cach√© son un conjunto al final de la ejecuci√≥n. </p><br><p>  Cuando las propiedades de espera de entrada se almacenan en cach√©, esto significa que la salida de fibra anterior se puede reutilizar sin ning√∫n c√°lculo. </p><br><p>  <strong>Prioridad del trabajo actual (pendienteWorkPriority)</strong> </p><br><p>  La fibra muestra la cantidad de trabajo de determinaci√≥n de prioridad.  El m√≥dulo de nivel de prioridad en React <a href="">ReactPrioritylevel</a> incluye diferentes niveles de prioridad y lo que representan. </p><br><p>  Comenzando con una excepci√≥n del tipo NoWork, que es 0, un n√∫mero m√°s alto define la prioridad m√°s baja.  Por ejemplo, puede usar la siguiente funci√≥n para verificar si la prioridad de la fibra es mayor que el nivel especificado: </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">matchesPriority</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">fiber, priority</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> fiber.pendingWorkPriority !== <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; fiber.pendingWorkPriority &lt;= priority }</code> </pre> <br><p>  <em>Esta funci√≥n es solo para fines ilustrativos;</em>  <em>no forma parte de la base de datos React Fiber.</em> </p><br><p>  El planificador utiliza el campo de prioridad para encontrar la siguiente unidad de trabajo que se puede realizar.  Discutiremos este algoritmo en la siguiente secci√≥n. </p><br><p>  <strong>Alternativa (o par)</strong> </p><br><p>  Actualizaci√≥n de fibra (descarga): esto significa mostrar su salida en la pantalla. </p><br><p>  Fibra en desarrollo (trabajo en progreso): fibra que a√∫n no se ha construido;  en otras palabras, es un contenedor de pila que a√∫n no se ha devuelto. </p><br><p>  En cualquier momento, la esencia del componente no tiene m√°s de dos estados para la fibra que corresponde a: fibra en el estado actual, fibra actualizada o fibra en desarrollo. </p><br><p>  La fibra actual es seguida por la fibra que se est√° desarrollando, y luego, a su vez, la fibra se actualiza. </p><br><p>  El siguiente estado de fibra se crea perezosamente utilizando la funci√≥n cloneFiber.  Casi siempre al crear un nuevo objeto, cloneFiber intentar√° reutilizar una alternativa (par) de fibra si existe, mientras minimiza el costo de los recursos. </p><br><p>  Deber√≠a pensar en el campo de vapor (o alternativa) como un detalle de implementaci√≥n, pero aparece tan a menudo en la documentaci√≥n que era simplemente imposible no mencionarlo. </p><br><p>  La conclusi√≥n es un elemento de servicio (o un conjunto de elementos de servicio);  nodos hoja Reaccionar aplicaciones.  Son espec√≠ficos para cada entorno de visualizaci√≥n (por ejemplo, en un navegador es 'div', 'span', etc.).  En JSX, se denotan como nombres de etiqueta en min√∫sculas. </p><br><p>  En pocas palabras: recomiendo probar las caracter√≠sticas de la nueva arquitectura React v16.0 </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/444276/">https://habr.com/ru/post/444276/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../444264/index.html">¬øC√≥mo convertirse en un committer y realmente lo necesita?</a></li>
<li><a href="../444268/index.html">Semana de la seguridad 12: ataques de teclado</a></li>
<li><a href="../444270/index.html">Webinar grupal del IB ‚ÄúEnfoque grupal del IB para la educaci√≥n cibern√©tica: una visi√≥n general de los programas actuales y casos pr√°cticos‚Äù</a></li>
<li><a href="../444272/index.html">PyDERASN: como escrib√≠ la biblioteca ASN.1 con slots y blobs</a></li>
<li><a href="../444274/index.html">Una respuesta detallada al comentario, as√≠ como un poco sobre la vida de los proveedores en la Federaci√≥n Rusa</a></li>
<li><a href="../444278/index.html">C√≥mo hacer que decenas de miles de personas lean su art√≠culo en ingl√©s para Habr: 3 consejos simples</a></li>
<li><a href="../444282/index.html">7 extensiones de Chrome para aprender ingl√©s</a></li>
<li><a href="../444284/index.html">compositor y terminaci√≥n de l√≠nea de comando</a></li>
<li><a href="../444286/index.html">An√°lisis de la c√°mara PTZ: qu√© hay dentro y c√≥mo funciona</a></li>
<li><a href="../444288/index.html">Nueva aplicaci√≥n m√≥vil LampTest.ru</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>