<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üò° üßíüèæ üë®üèΩ‚Äçüéì Gestion des √©tats dans les applications Flutter üé§ ‚õ≤Ô∏è üé≥</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Principes g√©n√©raux 


 Flutter est un cadre r√©actif, et pour un d√©veloppeur sp√©cialis√© dans le d√©veloppement natif, sa philosophie peut √™tre inhabitue...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Gestion des √©tats dans les applications Flutter</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/424765/"><p><img src="https://habrastorage.org/webt/4r/cs/fa/4rcsfacb6jeocfr5aprzgmk7-a0.jpeg"></p><br><h1 id="obschie-principy">  Principes g√©n√©raux </h1><br><p>  Flutter est un cadre r√©actif, et pour un d√©veloppeur sp√©cialis√© dans le d√©veloppement natif, sa philosophie peut √™tre inhabituelle.  Par cons√©quent, nous commen√ßons par un bref examen. </p><br><p> L'interface utilisateur sur Flutter, comme dans la plupart des frameworks modernes, se compose d'une arborescence de composants (widgets).  Lorsqu'un composant change, celui-ci et tous ses composants enfants sont restitu√©s (avec des optimisations internes, d√©crites ci-dessous).  Lorsque l'affichage change globalement (par exemple, en tournant l'√©cran), l'arborescence enti√®re du widget est redessin√©e. </p><a name="habracut"></a><br><p>  Cette approche peut sembler inefficace, mais en fait, elle donne au programmeur le contr√¥le de la vitesse de travail.  Si vous mettez √† jour l'interface au plus haut niveau sans avoir besoin, tout fonctionnera lentement, mais avec la disposition correcte des widgets, les applications sur Flutter peuvent √™tre tr√®s rapides. </p><br><p>  Flutter a deux types de widgets - sans √©tat et avec √©tat.  Les premiers (analogues √† Pure Components in React) n'ont pas d'√©tat et sont enti√®rement d√©crits par leurs param√®tres.  Si les conditions d'affichage ne changent pas (par exemple, la taille de la zone dans laquelle le widget doit √™tre affich√©) et ses param√®tres, le syst√®me r√©utilise la repr√©sentation visuelle pr√©c√©demment cr√©√©e du widget, donc l'utilisation de widgets sans √©tat a un bon effet sur les performances.  Dans le m√™me temps, de toute fa√ßon, chaque fois que le widget est redessin√©, un nouvel objet est formellement cr√©√© et le constructeur est lanc√©. </p><br><p>  Les widgets avec √©tat conservent un certain √©tat entre les rendus.  Pour ce faire, ils sont d√©crits par deux classes.  La premi√®re des classes, le widget lui-m√™me, d√©crit les objets cr√©√©s lors de chaque rendu.  La deuxi√®me classe d√©crit l'√©tat du widget et ses objets sont transf√©r√©s vers les objets widget cr√©√©s.  Les widgets d'√©tat avec √©tat sont une source majeure de refonte de l'interface.  Pour ce faire, vous devez modifier ses propri√©t√©s dans l'appel √† la m√©thode SetState.  Ainsi, contrairement √† de nombreux autres frameworks, Flutter n'a pas de suivi d'√©tat implicite - tout changement dans les propri√©t√©s du widget en dehors de la m√©thode SetState ne conduit pas √† redessiner l'interface. </p><br><p>  Maintenant, apr√®s avoir d√©crit les bases, vous pouvez commencer avec une application simple qui utilise des widgets sans √©tat et avec √©tat: </p><br><div class="spoiler">  <b class="spoiler_title">Application de base</b> <div class="spoiler_text"><pre><code class="plaintext hljs">import 'dart:math'; import 'package:flutter/material.dart'; void main() =&gt; runApp(new MyApp()); class MyApp extends StatelessWidget { @override Widget build(BuildContext context) { return new MaterialApp( title: 'Flutter Demo', theme: new ThemeData( primarySwatch: Colors.blue, ), home: Scaffold( appBar: AppBar( title: Text('Sample app'), ), body: new MyHomePage(), ), ); } } class MyHomePage extends StatefulWidget { @override _MyHomePageState createState() =&gt; _MyHomePageState(); } class _MyHomePageState extends State&lt;MyHomePage&gt; { Random rand = Random(); @override Widget build(BuildContext context) { return new ListView.builder(itemBuilder: (BuildContext context, int index) { return Text('Random number ${rand.nextInt(100)}',); }); } }</code> </pre> </div></div><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Exemple complet</a> </p><br><div class="spoiler">  <b class="spoiler_title">R√©sultat</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/sd/bv/nv/sdbvnvms7mjzadqujfg8vjm2wgs.png"></p></div></div><br><h1 id="esli-nuzhny-bolee-zhivuchie-sostoyaniya">  Si vous avez besoin de conditions plus tenaces </h1><br><p>  Continuons.  L'√©tat dynamique des widgets est maintenu entre les interfaces de redessin, mais uniquement aussi longtemps que le widget est n√©cessaire, c'est-√†-dire  vraiment situ√© sur l'√©cran.  Faisons une exp√©rience simple - placez notre liste sur l'onglet: </p><br><div class="spoiler">  <b class="spoiler_title">Application Tab</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">class _MyHomePageState extends State&lt;MyHomePage&gt; with SingleTickerProviderStateMixin { Random rand = Random(); TabController _tabController; final List&lt;Tab&gt; myTabs = &lt;Tab&gt;[ new Tab(text: 'FIRST'), new Tab(text: 'SECOND'), ]; @override void initState() { super.initState(); _tabController = new TabController(vsync: this, length: myTabs.length); } @override Widget build(BuildContext context) { return Scaffold( appBar: AppBar( title: Text('Sample app'), ), body: new TabBarView( controller: _tabController, children: [ new ListView.builder(itemBuilder: (BuildContext context, int index) { return Text('Random number ${rand.nextInt(100)}',); }), Text('Second tab'), ],), bottomNavigationBar: new TabBar( controller: _tabController, tabs: myTabs, labelColor: Colors.blue, ), ); } }</code> </pre> </div></div><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Exemple complet</a> </p><br><div class="spoiler">  <b class="spoiler_title">R√©sultat</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/va/fw/km/vafwkmelvxeapujubze6ixv4him.gif"></p></div></div><br><p>  Au d√©marrage, vous pouvez voir que lors du basculement entre les onglets, l'√©tat est supprim√© (la m√©thode dispose () est appel√©e), lorsqu'il est renvoy√©, il est recr√©√© (la m√©thode initState ()).  Ceci est raisonnable, car le stockage de l'√©tat des widgets non affichables consommera des ressources syst√®me.  Dans le cas o√π l'√©tat du widget doit survivre √† sa dissimulation compl√®te, plusieurs approches sont possibles: </p><br><p>  Tout d'abord, vous pouvez utiliser des objets distincts (ViewModel) pour stocker l'√©tat.  Dart au niveau de la langue prend en charge les constructeurs d'usine qui peuvent √™tre utilis√©s pour cr√©er des usines et des singletones qui stockent les donn√©es n√©cessaires. </p><br><p>  J'aime plus cette approche, car  Il vous permet d'isoler la logique m√©tier de l'interface utilisateur.  Cela est particuli√®rement vrai en raison du fait que Flutter Release Preview 2 a ajout√© la possibilit√© de cr√©er des interfaces parfaites pour les pixels pour iOS, mais vous devez le faire, bien s√ªr, sur les widgets correspondants. </p><br><p>  Deuxi√®mement, il est possible d'utiliser l'approche d'√©l√©vation d'√©tat, famili√®re aux programmeurs React, lorsque les donn√©es sont stock√©es dans des composants situ√©s en amont.  √âtant donn√© que Flutter redessine l'interface uniquement lorsque la m√©thode setState () est appel√©e, ces donn√©es peuvent √™tre modifi√©es et utilis√©es sans rendu.  Cette approche est un peu plus complexe et augmente la connectivit√© des widgets dans la structure, mais vous permet de sp√©cifier le niveau de stockage des donn√©es de mani√®re ponctuelle. </p><br><p>  Enfin, il existe des biblioth√®ques de stockage d'√©tat comme <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">flutter_redux</a> . </p><br><p>  Pour simplifier, nous utilisons la premi√®re approche.  Cr√©ons une classe ListData distincte, singleton, qui stocke les valeurs de notre liste.  Lors de l'affichage, nous utiliserons cette classe. </p><br><div class="spoiler">  <b class="spoiler_title">Application de r√©cup√©ration de donn√©es √† onglets</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">class _MyHomePageState extends State&lt;MyHomePage&gt; with SingleTickerProviderStateMixin { TabController _tabController; final List&lt;Tab&gt; myTabs = &lt;Tab&gt;[ new Tab(text: 'FIRST'), new Tab(text: 'SECOND'), ]; @override void initState() { super.initState(); _tabController = new TabController(vsync: this, length: myTabs.length); } @override Widget build(BuildContext context) { return Scaffold( appBar: AppBar( title: Text('Sample app'), ), body: new TabBarView( controller: _tabController, children: [ new ListView.builder(itemBuilder: ListData().build), Text('Second tab'), ],), bottomNavigationBar: new TabBar( controller: _tabController, tabs: myTabs, labelColor: Colors.blue, ), ); } } class ListData { static ListData _instance = ListData._internal(); ListData._internal(); factory ListData() { return _instance; } Random _rand = Random(); Map&lt;int, int&gt; _values = new Map(); Widget build (BuildContext context, int index) { if (!_values.containsKey(index)) { _values[index] = _rand.nextInt(100); } return Text('Random number ${_values[index]}',); } }</code> </pre> </div></div><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Exemple complet</a> </p><br><div class="spoiler">  <b class="spoiler_title">R√©sultat</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/pk/tu/s1/pktus1ysyqw1xzdhvdr-jdy5o-k.gif"></p></div></div><br><h1 id="sohranenie-pozicii-skrolla">  Enregistrement d'une position de d√©filement </h1><br><p>  Si vous faites d√©filer la liste de l'exemple pr√©c√©dent, puis basculez entre les onglets, il est facile de remarquer que la position de d√©filement n'est pas enregistr√©e.  C'est logique, car il n'est pas stock√© dans notre classe ListData et le propre √©tat du widget ne survit pas √† la commutation entre les onglets.  Nous impl√©menterons le stockage de l'√©tat de d√©filement manuellement, mais pour le plaisir, nous ne l'ajouterons pas √† une classe distincte et non √† ListData, mais √† un √©tat de niveau sup√©rieur pour montrer comment travailler avec. </p><br><p>  Faites attention aux widgets ScrollController et NotificationListener (ainsi qu'aux DefaultTabController pr√©c√©demment utilis√©s).  Le concept de widgets qui n'ont pas leur propre affichage devrait √™tre familier aux d√©veloppeurs travaillant avec React / Redux - les composants du conteneur sont activement utilis√©s dans ce bundle.  Dans Flutter, les widgets non affich√©s sont couramment utilis√©s pour ajouter des fonctionnalit√©s aux widgets enfants.  Cela vous permet de laisser les widgets visuels eux-m√™mes l√©gers et de ne pas traiter les √©v√©nements syst√®me l√† o√π ils ne sont pas n√©cessaires. </p><br><p>  Le code est bas√© sur la solution propos√©e par Marcin Sza≈Çek chez Stakoverflow ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">https://stackoverflow.com/questions/45341721/flutter-listview-inside-on-a-tabbarview-loses-its-scroll-position</a> ).  Le plan est le suivant: </p><br><ol><li>  Ajoutez un ScrollController √† la liste pour travailler avec la position de d√©filement. </li><li>  Ajoutez NotificationListener √† la liste pour passer l'√©tat de d√©filement. </li><li>  Nous enregistrons la position du d√©filement dans _MyHomePageState (qui est un niveau au-dessus des onglets) et l'associons au d√©filement de la liste. </li></ol><br><div class="spoiler">  <b class="spoiler_title">Application avec sauvegarde de la position de d√©filement</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">class _MyHomePageState extends State&lt;MyHomePage&gt; with SingleTickerProviderStateMixin { double listViewOffset=0.0; TabController _tabController; final List&lt;Tab&gt; myTabs = &lt;Tab&gt;[ new Tab(text: 'FIRST'), new Tab(text: 'SECOND'), ]; @override void initState() { super.initState(); _tabController = new TabController(vsync: this, length: myTabs.length); } @override Widget build(BuildContext context) { return Scaffold( appBar: AppBar( title: Text('Sample app'), ), body: new TabBarView( controller: _tabController, children: [new ListTab( getOffsetMethod: () =&gt; listViewOffset, setOffsetMethod: (offset) =&gt; this.listViewOffset = offset, ), Text('Second tab'), ],), bottomNavigationBar: new TabBar( controller: _tabController, tabs: myTabs, labelColor: Colors.blue, ), ); } } class ListTab extends StatefulWidget { ListTab({Key key, this.getOffsetMethod, this.setOffsetMethod}) : super(key: key); final GetOffsetMethod getOffsetMethod; final SetOffsetMethod setOffsetMethod; @override _ListTabState createState() =&gt; _ListTabState(); } class _ListTabState extends State&lt;ListTab&gt; { ScrollController scrollController; @override void initState() { super.initState(); //Init scrolling to preserve it scrollController = new ScrollController( initialScrollOffset: widget.getOffsetMethod() ); } @override Widget build(BuildContext context) { return NotificationListener( child: new ListView.builder( controller: scrollController, itemBuilder: ListData().build, ), onNotification: (notification) { if (notification is ScrollNotification) { widget.setOffsetMethod(notification.metrics.pixels); } }, ); } }</code> </pre> </div></div><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Exemple complet</a> </p><br><div class="spoiler">  <b class="spoiler_title">R√©sultat</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/rd/me/am/rdmeamzm7c-4jgyc-2qjqbmr9oq.gif"></p></div></div><br><h1 id="perezhivaem-vyklyuchenie-prilozheniya">  Vivre l'arr√™t de l'application </h1><br><p>  La sauvegarde des informations pendant la dur√©e de l'application est bonne, mais vous souhaitez souvent les sauvegarder entre les sessions, en particulier compte tenu de l'habitude des syst√®mes d'exploitation de fermer les applications en arri√®re-plan lorsque la m√©moire est insuffisante.  Les principales options de stockage de donn√©es persistantes dans Flutter sont les suivantes: </p><br><ol><li>  Les pr√©f√©rences partag√©es ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">https://pub.dartlang.org/packages/shared_preferences</a> ) sont un wrapper autour de NSUserDefaults (sur iOS) et SharedPreferences (sur Android) et vous permettent de stocker un petit nombre de paires cl√©-valeur.  Id√©al pour stocker des param√®tres. </li><li>  sqflite ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">https://pub.dartlang.org/packages/sqflite</a> ) est un plugin pour travailler avec SQLite (avec quelques limitations).  Prend en charge les requ√™tes de bas niveau et les assistants.  De plus, par analogie avec Room, il vous permet de travailler avec des versions de sch√©ma de base de donn√©es et de d√©finir le code de mise √† jour du sch√©ma lors de la mise √† jour de l'application. </li><li>  Cloud Firestore ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">https://pub.dartlang.org/packages/cloud_firestore</a> ) fait partie de la famille de plugins FireBase officielle. </li></ol><br><p>  Pour illustrer cela, nous allons enregistrer l'√©tat de d√©filement dans les pr√©f√©rences partag√©es.  Pour ce faire, ajoutez la restauration de la position de d√©filement lors de l'initialisation de l'√©tat _MyHomePageState et de l'enregistrement lors du d√©filement. </p><br><p>  Ici, nous devons nous attarder sur le mod√®le asynchrone Flutter / Dart, car tous les services externes fonctionnent sur les appels asynchrones.  Le principe de fonctionnement de ce mod√®le est similaire √† node.js - il existe un thread d'ex√©cution principal (thread), qui est interrompu par des appels asynchrones.  √Ä chaque interruption suivante (et l'interface utilisateur les rend constamment), les r√©sultats des op√©rations asynchrones termin√©es sont trait√©s. En m√™me temps, il est possible d'ex√©cuter de lourds calculs dans les threads d'arri√®re-plan (via la fonction de calcul). </p><br><p>  Ainsi, l'√©criture et la lecture dans SharedPreferences se font de mani√®re asynchrone (bien que la biblioth√®que permette une lecture synchrone √† partir du cache).  Pour commencer, nous traiterons de la lecture.  L'approche standard de la r√©cup√©ration asynchrone des donn√©es ressemble √† ceci: d√©marrez le processus asynchrone et, une fois termin√©, ex√©cutez SetState en √©crivant les valeurs re√ßues.  En cons√©quence, l'interface utilisateur sera mise √† jour en utilisant les donn√©es re√ßues.  Cependant, dans ce cas, nous ne travaillons pas avec des donn√©es, mais avec la position de d√©filement.  Nous n'avons pas besoin de mettre √† jour l'interface, nous avons seulement besoin d'appeler la m√©thode jumpTo sur le ScrollController.  Le probl√®me est que le r√©sultat du traitement d'une demande asynchrone peut revenir √† tout moment et ce ne sera pas n√©cessairement quoi et o√π faire d√©filer.  Afin d'√™tre assur√© d'effectuer une op√©ration sur une interface enti√®rement initialis√©e, nous devons ... toujours faire d√©filer setState. </p><br><p>  Nous obtenons quelque chose comme ce code: </p><br><div class="spoiler">  <b class="spoiler_title">R√©glage de l'√©tat</b> <div class="spoiler_text"><pre> <code class="plaintext hljs"> @override void initState() { super.initState(); //Init scrolling to preserve it scrollController = new ScrollController( initialScrollOffset: widget.getOffsetMethod() ); _restoreState().then((double value) =&gt; scrollController.jumpTo(value)); } Future&lt;double&gt; _restoreState() async { SharedPreferences prefs = await SharedPreferences.getInstance(); return prefs.getDouble('listViewOffset'); } void setScroll(double value) { setState(() { scrollController.jumpTo(value); }); }</code> </pre> </div></div><br><p>  Avec le disque, tout est plus int√©ressant.  Le fait est que dans le processus de d√©filement, les √©v√©nements √† ce sujet arrivent constamment.  Le d√©marrage de l'enregistrement asynchrone chaque fois que la valeur est modifi√©e peut provoquer des erreurs d'application.  Nous devons traiter uniquement le dernier √©v√©nement de la cha√Æne.  En termes de programmation r√©active, cela s'appelle debounce et nous allons l'utiliser.  Dart prend en charge les principales fonctionnalit√©s de la programmation r√©active via des flux de donn√©es.Nous devrons donc cr√©er un flux √† partir des mises √† jour de la position de d√©filement et y souscrire, en le convertissant √† l'aide de Debounce.  Pour convertir, nous avons besoin de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">la biblioth√®que stream_transform</a> .  Comme approche alternative, vous pouvez utiliser RxDart et travailler en termes de ReactiveX. </p><br><p>  Il s'av√®re que le code suivant: </p><br><div class="spoiler">  <b class="spoiler_title">Enregistrement de statut</b> <div class="spoiler_text"><pre> <code class="plaintext hljs"> StreamSubscription _stream; StreamController&lt;double&gt; _controller = new StreamController&lt;double&gt;.broadcast(); @override void initState() { super.initState(); _tabController = new TabController(vsync: this, length: myTabs.length); _stream = _controller.stream.transform(debounce(new Duration(milliseconds: 500))).listen(_saveState); } void _saveState(double value) async { SharedPreferences prefs = await SharedPreferences.getInstance(); await prefs.setDouble('listViewOffset', value); }</code> </pre> </div></div><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Exemple complet</a> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr424765/">https://habr.com/ru/post/fr424765/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr424753/index.html">Nouveaut√©s de YouTrack 2018.3</a></li>
<li><a href="../fr424755/index.html">L'argent aime le projet de loi: comment les voitures trient les factures</a></li>
<li><a href="../fr424757/index.html">Le condens√© des √©v√©nements pour les professionnels des RH dans le domaine des TI en octobre 2018</a></li>
<li><a href="../fr424761/index.html">Introduction au d√©marrage du noyau Linux et aux processus de d√©marrage</a></li>
<li><a href="../fr424763/index.html">Un √©diteur de texte n'est pas votre plus haute math√©matique, vous devez penser ici</a></li>
<li><a href="../fr424767/index.html">Nous faisons un g√¢teau de Habr. Encore une fois</a></li>
<li><a href="../fr424771/index.html">Exp√©rience personnelle: d'une id√©e et d'une feuille blanche √† une version provisoire d'un site</a></li>
<li><a href="../fr424773/index.html">Biopharma et mod√©lisation num√©rique: exp√©rience et pratique d'Amgen</a></li>
<li><a href="../fr424777/index.html">Utilisation de Consul pour faire √©voluer les services avec √©tat</a></li>
<li><a href="../fr424779/index.html">SPA multi-page en Python</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>