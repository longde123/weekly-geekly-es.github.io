<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üëÇ üëàüèø üèø C≈ìurs de processeur ou qu'est-ce que SMP et que mange-t-il ü§æüèæ ‚ôíÔ∏è ‚ôÇÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Pr√©sentation 
 Bonjour, aujourd'hui, je voudrais aborder un sujet assez simple qui est presque inconnu des programmeurs ordinaires, mais chacun de vou...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>C≈ìurs de processeur ou qu'est-ce que SMP et que mange-t-il</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/426497/"><h2>  Pr√©sentation </h2><br>  Bonjour, aujourd'hui, je voudrais aborder un sujet assez simple qui est presque inconnu des programmeurs ordinaires, mais chacun de vous l'a probablement utilis√©. <br>  Il s'agira du multitraitement sym√©trique (populairement - SMP) - l'architecture que l'on retrouve dans tous les syst√®mes d'exploitation multit√¢che, et bien s√ªr, en fait partie int√©grante.  Tout le monde sait que plus un processeur a de c≈ìurs, plus le processeur sera puissant, oui, mais comment un syst√®me d'exploitation peut-il utiliser plusieurs c≈ìurs en m√™me temps?  Certains programmeurs ne descendent pas √† ce niveau d'abstraction - ils n'en ont tout simplement pas besoin, mais je pense que tout le monde sera int√©ress√© par le fonctionnement de SMP. <br><a name="habracut"></a><br><h2>  Le multit√¢che et sa mise en ≈ìuvre </h2><br>  Ceux qui ont d√©j√† √©tudi√© l'architecture informatique savent que le processeur lui-m√™me n'est pas en mesure d'effectuer plusieurs t√¢ches √† la fois, le multit√¢che ne nous donne que le syst√®me d'exploitation, qui commute ces t√¢ches.  Il existe plusieurs types de multit√¢che, mais le plus ad√©quat, pratique et largement utilis√© est l'√©viction du multit√¢che (vous pouvez lire ses principaux aspects sur Wikip√©dia).  Il est bas√© sur le fait que chaque processus (t√¢che) a sa propre priorit√©, ce qui affecte le temps processeur qui lui sera allou√©.  Chaque t√¢che re√ßoit une tranche de temps pendant laquelle le processus fait quelque chose; apr√®s l'expiration de la tranche de temps, le syst√®me d'exploitation transf√®re le contr√¥le √† une autre t√¢che.  La question se pose - comment r√©partir les ressources informatiques, telles que la m√©moire, les p√©riph√©riques, etc.  entre les processus?  Tout est tr√®s simple: Windows le fait lui-m√™me, Linux utilise un syst√®me de s√©maphore.  Mais un noyau n'est pas s√©rieux, nous allons de l'avant. <br><br><h3>  Interruptions et PIC </h3><br>  Peut-√™tre que pour certains, ce sera une nouvelle, pour certains non, mais l'architecture i386 (je vais parler de l'architecture x86, ARM ne compte pas, parce que je n'ai pas √©tudi√© cette architecture, et je ne l'ai jamais rencontr√©e) (m√™me au niveau de l'√©criture d'un service ou d'un programme r√©sident)) utilise des interruptions (nous ne parlerons que des interruptions mat√©rielles, IRQ) afin de notifier le syst√®me d'exploitation ou le programme d'un √©v√©nement.  Par exemple, il y a une interruption 0x8 (pour les modes prot√©g√©s et longs, par exemple 0x20, selon la fa√ßon de configurer le PIC, plus √† ce sujet plus tard), qui est appel√©e par PIT, qui, par exemple, peut g√©n√©rer des interruptions avec n'importe quelle fr√©quence n√©cessaire.  Ensuite, le travail de l'OS pour la distribution des tranches de temps est r√©duit √† 0, lorsqu'une interruption est appel√©e, le programme s'arr√™te et le contr√¥le est donn√©, par exemple, au noyau, qui √† son tour enregistre les donn√©es du programme actuel (registres, drapeaux, etc.) et donne le contr√¥le au processus suivant . <br><br>  Comme vous l'avez probablement compris, les interruptions sont des fonctions (ou proc√©dures) qui sont appel√©es √† un moment donn√© par l'√©quipement ou par le programme lui-m√™me.  Au total, le processeur prend en charge 16 interruptions sur deux PIC.  Le processeur a des drapeaux, et l'un d'eux est le drapeau ¬´I¬ª - Interrupt Control.  En d√©finissant cet indicateur sur 0, le processeur ne provoquera aucune interruption mat√©rielle.  Mais, je tiens √©galement √† noter qu'il existe des d√©nomm√©s NMI - Interruptions non masquables - les donn√©es d'interruption seront toujours appel√©es, m√™me si le bit I est d√©fini sur 0. En utilisant la programmation PIC, vous pouvez d√©sactiver les donn√©es d'interruption, mais apr√®s √™tre revenu d'une interruption avec IRET - ils ne seront √† nouveau pas interdits.  Je note que sous un programme r√©gulier, vous ne pouvez pas suivre l'appel d'interruption - votre programme s'arr√™te et ne reprend qu'apr√®s un certain temps, votre programme ne le remarque m√™me pas (oui, vous pouvez v√©rifier que l'interruption a √©t√© appel√©e - mais pourquoi? <br><br><h5>  PIC - Contr√¥leur d'interruption programmable </h5><br>  De Wiki: <br><blockquote>  En r√®gle g√©n√©rale, il s'agit d'un appareil √©lectronique, parfois fabriqu√© dans le cadre du processeur lui-m√™me ou de puces complexes de sa trame, dont les entr√©es sont connect√©es √©lectriquement aux sorties correspondantes de divers appareils.  Le num√©ro d'entr√©e du contr√¥leur d'interruption est indiqu√© par ¬´IRQ¬ª.  Ce num√©ro doit √™tre distingu√© de la priorit√© d'interruption, ainsi que du num√©ro d'entr√©e dans la table des vecteurs d'interruption (INT).  Ainsi, par exemple, dans un PC IBM en mode de fonctionnement r√©el (MS-DOS fonctionne dans ce mode) du processeur, l'interruption du clavier standard utilise IRQ 1 et INT 9. <br><br>  La plate-forme IBM PC d'origine utilise un sch√©ma d'interruption tr√®s simple.  Le contr√¥leur d'interruption est un simple compteur qui it√®re s√©quentiellement sur les signaux de diff√©rents appareils ou est r√©initialis√© au d√©but lorsqu'une nouvelle interruption est trouv√©e.  Dans le premier cas, les appareils ont une priorit√© √©gale; dans le second, les appareils avec un num√©ro de s√©rie inf√©rieur (ou sup√©rieur dans le comptage) ont une priorit√© plus √©lev√©e. </blockquote><br>  Comme vous le comprenez, il s'agit d'un circuit √©lectronique qui permet aux appareils d'envoyer des demandes d'interruption, g√©n√©ralement il y en a exactement 2. <br><br>  Passons maintenant au sujet de l'article. <br><br><h2>  SMP </h2><br>  Pour mettre en ≈ìuvre cette norme, de nouveaux sch√©mas ont commenc√© √† √™tre mis sur les cartes m√®res: APIC et ACPI.  Parlons du premier. <br><br>  APIC - Advanced Programmable Interrupt Controller, une version am√©lior√©e de PIC.  Il est utilis√© dans les syst√®mes multiprocesseurs et fait partie int√©grante de tous les derniers processeurs Intel (et compatibles).  APIC est utilis√© pour le transfert d'interruption complexe et pour l'envoi d'interruptions entre processeurs.  Ces choses n'√©taient pas possibles en utilisant l'ancienne sp√©cification PIC. <br><br><h3>  APIC local et IO APIC </h3><br>  Dans un syst√®me bas√© sur APIC, chaque processeur se compose d'un ¬´c≈ìur¬ª et d'un ¬´APIC local¬ª.  L'APIC local est responsable de la gestion de la configuration d'interruption sp√©cifique au processeur.  Entre autres, il contient une table vectorielle locale (LVT), qui traduit les √©v√©nements, tels que "l'horloge interne" et d'autres sources d'interruption "locales", en un vecteur d'interruption (par exemple, le contact LocalINT1 peut d√©clencher une exception NMI tout en conservant " 2 ‚Äù√† l'entr√©e LVT correspondante). <br><br>  Pour plus d'informations sur l'APIC local, consultez le "Guide de programmation syst√®me" des processeurs Intel modernes. <br><br>  De plus, il existe un APIC IO (par exemple, Intel 82093AA), qui fait partie du chipset et fournit un contr√¥le d'interruption multiprocesseur, y compris une distribution sym√©trique statique et dynamique des interruptions pour tous les processeurs.  Sur les syst√®mes avec plusieurs sous-syst√®mes d'E / S, chaque sous-syst√®me peut avoir son propre ensemble d'interruptions. <br><br>  Chaque broche d'interruption est programm√©e individuellement comme d√©clench√©e par front ou par niveau.  Le vecteur d'interruption et les informations de commande d'interruption peuvent √™tre sp√©cifi√©s pour chaque interruption.  Le sch√©ma d'acc√®s au registre indirect optimise l'espace m√©moire n√©cessaire pour acc√©der aux registres d'E / S internes APIC.  Pour augmenter la flexibilit√© du syst√®me lors de l'allocation d'espace m√©moire, les deux registres d'E / S APIC sont d√©pla√ßables, mais la valeur par d√©faut est 0xFEC00000. <br><br><h3>  Initialisation d'un APIC ¬´local¬ª </h3><br>  L'APIC local est activ√© au d√©marrage et peut √™tre d√©sactiv√© en r√©initialisant le bit 11 IA32_APIC_BASE (MSR) (cela ne fonctionne qu'avec les processeurs avec une famille&gt; 5, car Pentium n'a pas un tel MSR), puis le processeur re√ßoit ses interruptions directement du PIC 8259 compatible .  Cependant, le guide de d√©veloppement logiciel d'Intel indique qu'apr√®s avoir d√©sactiv√© l'APIC local via IA32_APIC_BASE, vous ne pourrez pas l'activer tant qu'il n'aura pas √©t√© compl√®tement r√©initialis√©.  L'APO IO peut √©galement √™tre configur√© pour fonctionner en mode h√©rit√© afin d'√©muler un p√©riph√©rique 8259. <br><br>  Les APIC locaux sont mapp√©s √† la page physique FEE00xxx (voir Tableau 8-1 Intel P4 SPG).  Cette adresse est la m√™me pour chaque APIC local qui existe dans la configuration, ce qui signifie que vous pouvez acc√©der directement aux registres du noyau APIC local dans lequel votre code s'ex√©cute actuellement.  Notez qu'il existe un MSR qui d√©finit la base APIC r√©elle (disponible uniquement pour les processeurs avec une famille&gt; 5).  MADT contient une base APIC locale, et sur les syst√®mes 64 bits, il peut √©galement contenir un champ sp√©cifiant une red√©finition 64 bits de l'adresse de base, que vous devez utiliser √† la place.  Vous ne pouvez quitter la base APIC locale que l√† o√π vous la trouvez, ou la d√©placer o√π vous le souhaitez.  Remarque: je ne pense pas que vous puissiez le d√©placer plus loin que le 4√®me Go de RAM. <br><br>  Pour permettre √† l'APIC local de recevoir des interruptions, vous devez configurer le registre vectoriel d'interruption parasite.  La valeur correcte pour ce champ est le num√©ro IRQ que vous souhaitez mapper sur les fausses interruptions avec les 8 bits inf√©rieurs et le 8e bit d√©fini sur 1 pour activer r√©ellement APIC (pour plus de d√©tails, voir la sp√©cification).  Vous devez s√©lectionner un num√©ro d'interruption dont les 4 bits inf√©rieurs sont d√©finis;  Le moyen le plus simple consiste √† utiliser 0xFF.  Ceci est important pour certains processeurs plus anciens, car pour ces valeurs, les 4 bits inf√©rieurs doivent √™tre d√©finis sur 1. <br><br>  D√©sactivez correctement le PIC 8259.  C'est presque aussi important que de configurer APIC.  Vous effectuez cette op√©ration en deux √©tapes: masquage de toutes les interruptions et r√©affectation de l'IRQ.  D√©guiser toutes les interruptions les d√©sactive dans le PIC.  Le remappage des interruptions est ce que vous avez probablement d√©j√† fait lorsque vous avez utilis√© PIC: vous voulez que les demandes d'interruption commencent √† 32 au lieu de 0 pour √©viter les conflits avec les exceptions (en mode processeur prot√©g√© et long (Long), car Les 32 premi√®res interruptions sont des exceptions).  Vous devez ensuite √©viter d'utiliser ces vecteurs d'interruption √† d'autres fins.  Ceci est n√©cessaire car, malgr√© le fait que vous ayez masqu√© toutes les interruptions PIC, il pourrait toujours g√©n√©rer de fausses interruptions, qui seraient alors incorrectement trait√©es comme exceptions dans votre noyau. <br>  Passons √† SMP. <br><br><h3>  Multit√¢che sym√©trique: initialisation </h3><br>  La s√©quence de d√©marrage est diff√©rente pour diff√©rents CPU.  Le Guide du programmeur Intel (Section 7.5.4) contient un protocole d'initialisation pour les processeurs Intel Xeon et ne couvre pas les processeurs plus anciens.  Pour un algorithme g√©n√©ral ¬´tous les types de processeur¬ª, voir Sp√©cifications multiprocesseurs Intel. <br><br>  Pour 80486 (avec APIC 8249DX externe), vous devez utiliser IPIT INIT suivi de l'IPI ¬´INIT level de-assert¬ª sans SIPI.  Cela signifie que vous ne pouvez pas leur dire o√π commencer √† ex√©cuter votre code (la partie vectorielle de SIPI), et ils commencent toujours √† ex√©cuter le code BIOS.  Dans ce cas, vous d√©finissez la valeur de r√©initialisation du BIOS CMOS sur ¬´d√©marrage √† chaud avec saut loin¬ª (c'est-√†-dire, d√©finissez la position CMOS 0x0F sur 10) afin que le BIOS ex√©cute jmp loin ~ [0: 0x0469], puis d√©finissez le segment et le d√©calage Points d'entr√©e AP √† 0x0469. <br><br>  L'IPI ¬´INIT level de-assert¬ª n'est pas pris en charge sur les nouveaux processeurs (Pentium 4 et Intel Xeon), et AFAIK est compl√®tement ignor√© sur ces processeurs. <br><br>  Pour les nouveaux processeurs (P6, Pentium 4), un seul SIPI suffit, mais je ne sais pas si les anciens processeurs Intel (Pentium) ou les processeurs d'autres fabricants ont besoin d'un second SIPI.  Il est √©galement possible qu'un deuxi√®me SIPI existe en cas d'√©chec de livraison du premier SIPI (bruit de bus, etc.). <br><br>  Habituellement, j'envoie le premier SIPI, puis j'attends de voir si l'AP augmente le nombre de processeurs en cours d'ex√©cution.  S'il n'augmente pas ce compteur en quelques millisecondes, j'enverrai un deuxi√®me SIPI.  Ceci est diff√©rent de l'algorithme g√©n√©ral d'Intel (qui a un retard de 200 microsecondes entre SIPI), mais il n'est pas si simple de trouver une source de temps qui puisse mesurer avec pr√©cision le retard de 200 microsecondes lors d'un d√©marrage pr√©coce.  J'ai √©galement constat√© que sur du mat√©riel r√©el, si le d√©lai entre SIPI est trop long (et que vous n'utilisez pas ma m√©thode), l'AP principal peut ex√©cuter deux fois le code de d√©marrage de l'AP pour l'OS (ce qui, dans mon cas, am√®nera l'OS √† penser que nous avons deux fois plus de processeurs que nous le sommes actuellement). <br><br>  Vous pouvez diffuser ces signaux sur le bus pour d√©marrer chaque appareil pr√©sent.  Cependant, vous pouvez √©galement activer des processeurs sp√©cialement d√©sactiv√©s (car ils √©taient "d√©fectueux"). <br><br><h3>  Recherche d'informations √† l'aide de la table MT </h3><br>  Certaines informations (qui peuvent ne pas √™tre disponibles sur les machines plus r√©centes) destin√©es au multitraitement.  Vous devez d'abord trouver la structure du pointeur flottant MP.  Il est align√© sur une limite de 16 octets et contient une signature au d√©but de "_MP_" ou 0x5F504D5F.  Le syst√®me d'exploitation doit regarder dans EBDA, l'espace ROM du BIOS et dans le dernier kilo-octet de ¬´m√©moire de base¬ª;  la taille de la m√©moire de base est sp√©cifi√©e dans une valeur de 2 octets de 0x413 en kilo-octets, moins 1 Ko.  Voici √† quoi ressemble la structure: <br><br><pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">mp_floating_pointer_structure</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> signature[<span class="hljs-number"><span class="hljs-number">4</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> configuration_table; <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> length; <span class="hljs-comment"><span class="hljs-comment">// In 16 bytes (eg 1 = 16 bytes, 2 = 32 bytes) uint8_t mp_specification_revision; uint8_t checksum; // This value should make all bytes in the table equal 0 when added together uint8_t default_configuration; // If this is not zero then configuration_table should be // ignored and a default configuration should be loaded instead uint32_t features; // If bit 7 is then the IMCR is present and PIC mode is being used, otherwise // virtual wire mode is; all other bits are reserved }</span></span></code> </pre> <br>  Voici √† quoi ressemble la table de configuration sur laquelle pointe la structure flottante du pointeur: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">mp_configuration_table</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> signature[<span class="hljs-number"><span class="hljs-number">4</span></span>]; <span class="hljs-comment"><span class="hljs-comment">// "PCMP" uint16_t length; uint8_t mp_specification_revision; uint8_t checksum; // Again, the byte should be all bytes in the table add up to 0 char oem_id[8]; char product_id[12]; uint32_t oem_table; uint16_t oem_table_size; uint16_t entry_count; // This value represents how many entries are following this table uint32_t lapic_address; // This is the memory mapped address of the local APICs uint16_t extended_table_length; uint8_t extended_table_checksum; uint8_t reserved; }</span></span></code> </pre><br>  Apr√®s la table de configuration se trouvent les entr√©es entry_count, qui contiennent plus d'informations sur le syst√®me, suivies d'une table √©tendue.  Les entr√©es sont soit 20 octets pour repr√©senter le processeur, soit 8 octets pour autre chose.  Voici √† quoi ressemblent le processeur APIC et les enregistrements d'E / S. <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">entry_processor</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> type; <span class="hljs-comment"><span class="hljs-comment">// Always 0 uint8_t local_apic_id; uint8_t local_apic_version; uint8_t flags; // If bit 0 is clear then the processor must be ignored // If bit 1 is set then the processor is the bootstrap processor uint32_t signature; uint32_t feature_flags; uint64_t reserved; }</span></span></code> </pre><br>  Voici l'entr√©e IO APIC. <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">entry_io_apic</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> type; <span class="hljs-comment"><span class="hljs-comment">// Always 2 uint8_t id; uint8_t version; uint8_t flags; // If bit 0 is set then the entry should be ignored uint32_t address; // The memory mapped address of the IO APIC is memory }</span></span></code> </pre><br><h3>  Recherche d'informations avec APIC </h3><br>  Vous pouvez trouver la table MADT (APIC) dans ACPI.  Le tableau r√©pertorie les APIC locaux, dont le nombre doit correspondre au nombre de c≈ìurs sur votre processeur.  Les d√©tails de ce tableau ne sont pas ici, mais vous pouvez les trouver sur Internet. <br><br><h3>  Lancer AP </h3><br>  Apr√®s avoir collect√© les informations, vous devez d√©sactiver le PIC et vous pr√©parer aux E / S APIC.  Vous devez √©galement configurer le BSP de l'APIC local.  Ensuite, d√©marrez l'AP en utilisant SIPI. <br><br>  <b>Code de lancement des noyaux:</b> <br><br>  Je note que le vecteur que vous sp√©cifiez au d√©marrage indique l'adresse de d√©part: vecteur 0x8 - adresse 0x8000, vecteur 0x9 - adresse 0x9000, etc. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// ------------------------------------------------------------------------------------------------ static u32 LocalApicIn(uint reg) { return MmioRead32(*g_localApicAddr + reg); } // ------------------------------------------------------------------------------------------------ static void LocalApicOut(uint reg, u32 data) { MmioWrite32(*g_localApicAddr + reg, data); } // ------------------------------------------------------------------------------------------------ void LocalApicInit() { // Clear task priority to enable all interrupts LocalApicOut(LAPIC_TPR, 0); // Logical Destination Mode LocalApicOut(LAPIC_DFR, 0xffffffff); // Flat mode LocalApicOut(LAPIC_LDR, 0x01000000); // All cpus use logical id 1 // Configure Spurious Interrupt Vector Register LocalApicOut(LAPIC_SVR, 0x100 | 0xff); } // ------------------------------------------------------------------------------------------------ uint LocalApicGetId() { return LocalApicIn(LAPIC_ID) &gt;&gt; 24; } // ------------------------------------------------------------------------------------------------ void LocalApicSendInit(uint apic_id) { LocalApicOut(LAPIC_ICRHI, apic_id &lt;&lt; ICR_DESTINATION_SHIFT); LocalApicOut(LAPIC_ICRLO, ICR_INIT | ICR_PHYSICAL | ICR_ASSERT | ICR_EDGE | ICR_NO_SHORTHAND); while (LocalApicIn(LAPIC_ICRLO) &amp; ICR_SEND_PENDING) ; } // ------------------------------------------------------------------------------------------------ void LocalApicSendStartup(uint apic_id, uint vector) { LocalApicOut(LAPIC_ICRHI, apic_id &lt;&lt; ICR_DESTINATION_SHIFT); LocalApicOut(LAPIC_ICRLO, vector | ICR_STARTUP | ICR_PHYSICAL | ICR_ASSERT | ICR_EDGE | ICR_NO_SHORTHAND); while (LocalApicIn(LAPIC_ICRLO) &amp; ICR_SEND_PENDING) ; } void SmpInit() { kprintf("Waking up all CPUs\n"); *g_activeCpuCount = 1; uint localId = LocalApicGetId(); // Send Init to all cpus except self for (uint i = 0; i &lt; g_acpiCpuCount; ++i) { uint apicId = g_acpiCpuIds[i]; if (apicId != localId) { LocalApicSendInit(apicId); } } // wait PitWait(200); // Send Startup to all cpus except self for (uint i = 0; i &lt; g_acpiCpuCount; ++i) { uint apicId = g_acpiCpuIds[i]; if (apicId != localId) LocalApicSendStartup(apicId, 0x8); } // Wait for all cpus to be active PitWait(10); while (*g_activeCpuCount != g_acpiCpuCount) { kprintf("Waiting... %d\n", *g_activeCpuCount); PitWait(10); } kprintf("All CPUs activated\n"); }</span></span></code> </pre><br><pre> <code class="hljs powershell">[<span class="hljs-type"><span class="hljs-type">org</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span><span class="hljs-type"><span class="hljs-type">x8000</span></span>] AP: jmp short bsp ;     -   BSP xor ax,ax mov ss,ax mov sp, <span class="hljs-number"><span class="hljs-number">0</span></span>x7c00 xor ax,ax mov ds,ax ; Mark CPU as active lock inc byte [<span class="hljs-type"><span class="hljs-type">ds</span></span>:<span class="hljs-type"><span class="hljs-type">g_activeCpuCount</span></span>] ;   ,   jmp zop bsp: xor ax,ax mov ds,ax mov dword[<span class="hljs-type"><span class="hljs-type">ds</span></span>:<span class="hljs-type"><span class="hljs-type">g_activeCpuCount</span></span>],<span class="hljs-number"><span class="hljs-number">0</span></span> mov dword[<span class="hljs-type"><span class="hljs-type">ds</span></span>:<span class="hljs-type"><span class="hljs-type">g_activeCpuCount</span></span>],<span class="hljs-number"><span class="hljs-number">0</span></span> mov word [<span class="hljs-type"><span class="hljs-type">ds</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span><span class="hljs-type"><span class="hljs-type">x8000</span></span>], <span class="hljs-number"><span class="hljs-number">0</span></span>x9090 ;  JMP   <span class="hljs-number"><span class="hljs-number">2</span></span> NOP<span class="hljs-string"><span class="hljs-string">' ;   ,  </span></span></code> </pre><br>  Maintenant, comme vous le comprenez, pour que le syst√®me d'exploitation utilise plusieurs c≈ìurs, vous devez configurer la pile pour chaque c≈ìur, chaque c≈ìur, ses interruptions, etc., mais la chose la plus importante est que lors de l'utilisation du multitraitement sym√©trique, toutes les ressources des c≈ìurs sont les m√™mes: une m√©moire, un PCI, etc., et le syst√®me d'exploitation ne peut que parall√©liser les t√¢ches entre les c≈ìurs. <br><br>  J'esp√®re que l'article n'est pas assez ennuyeux et assez informatif.  La prochaine fois, je pense que nous pourrons parler de la fa√ßon dont ils dessinaient sur l'√©cran (et maintenant ils dessinent), sans utiliser de shaders et de cartes vid√©o sympas. <br><br>  Bonne chance </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr426497/">https://habr.com/ru/post/fr426497/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr426487/index.html">Testez l'automatisation √† partir de z√©ro. Partie 1</a></li>
<li><a href="../fr426489/index.html">Sur la relation des nombres premiers et irrationnels</a></li>
<li><a href="../fr426491/index.html">Semaine de la s√©curit√© 39: √† la mort de Google+</a></li>
<li><a href="../fr426493/index.html">Remises constantes des h√©bergeurs pour VPS et VPS.today Rechercher des visiteurs</a></li>
<li><a href="../fr426495/index.html">Designer solo. Comment b√¢tir une carri√®re quand on travaille seul</a></li>
<li><a href="../fr426499/index.html">Programme √©ducatif pour travailler avec des cartes perfor√©es (ou l'histoire de la fa√ßon dont les ¬´m√©gadonn√©es¬ª ont √©t√© trait√©es de 1890 √† 1970)</a></li>
<li><a href="../fr426501/index.html">Lamoda de l'int√©rieur: pourquoi la boutique en ligne de 300 ing√©nieurs</a></li>
<li><a href="../fr426503/index.html">Fonctionnalit√© SAP HANA en tant que base de donn√©es pour SAP HANA Data Management Suite</a></li>
<li><a href="../fr426505/index.html">√âv√©nements num√©riques √† Moscou du 15 au 21 octobre</a></li>
<li><a href="../fr426507/index.html">Cr√©ation d'une architecture: utilisation du mod√®le de coordinateur iOS</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>