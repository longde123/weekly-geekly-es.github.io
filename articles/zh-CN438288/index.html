<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🥫 🌅 📑 无所畏惧的保护。 Rust的内存安全性 👷🏻 🐛 🏿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Mozilla去年发布了适用于Firefox的Quantum CSS ，并在长达八年的开发内存友好型系统编程语言Rust的最后阶段。 用了一年多的时间在Rust中重写了主要的浏览器组件。 

 到目前为止，所有主要的浏览器引擎都是使用C ++编写的，主要是出于效率方面的考虑。 但是，出色的性能带来了...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>无所畏惧的保护。 Rust的内存安全性</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/438288/"> Mozilla去年发布了适用于Firefox的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Quantum CSS</a> ，并在长达八年的开发内存友好型系统编程语言Rust的最后阶段。 用了一年多的时间在Rust中重写了主要的浏览器组件。 <br><br> 到目前为止，所有主要的浏览器引擎都是使用C ++编写的，主要是出于效率方面的考虑。 但是，出色的性能带来了巨大的责任：C ++程序员必须手动管理内存，这将打开Pandora的漏洞框。  Rust不仅可以修复此类错误，而且其方法还可以防止<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">数据争用</a> ，从而使程序员可以更有效地实现并行代码。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8bb/3c1/378/8bb3c13783ff1502b161e92f5818c2aa.jpg"></div><a name="habracut"></a><br><h1> 什么是内存安全性？ </h1><br> 当我们谈论创建安全的应用程序时，我们经常提到内存安全性。 非官方地，我们的意思是程序在任何状态下都不能访问无效的内存。 安全漏洞的原因： <br><br><ul><li> 释放内存后保存指针（释放后使用）； <br></li><li> 解引用空指针； <br></li><li> 使用未初始化的内存； <br></li><li> 程序尝试释放同一单元两次（两次释放）； <br></li><li> 缓冲区溢出。 </li></ul><br> 有关更正式的定义，请参阅Michael Hicks的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">“什么是内存安全性</a> ”以及有关此主题的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">科学文章</a> 。 <br><br> 此类违规行为可能导致意外崩溃或程序预期行为的更改。 潜在的后果：信息泄漏，任意代码执行和远程代码执行。 <br><br><h1> 记忆体管理 </h1><br> 内存管理对于应用程序性能和安全性至关重要。 在本节中，我们将考虑基本的内存模型。 关键概念之一是<i>指针</i> 。 这些是存储内存地址的变量。 如果我们转到该地址，我们将在那里看到一些数据。 因此，我们说指针是对此数据的引用（或指向它们）。 就像家庭住址告诉人们在哪里可以找到您一样，内存地址也可以显示程序在哪里可以找到数据。 <br><br> 程序中的所有内容都位于特定的存储器地址，包括代码指令。 错误使用指针会导致严重的漏洞，包括信息泄漏和任意代码执行。 <br><br><h3> 分配/发布 </h3><br> 创建变量时，程序应在内存中分配足够的空间来存储该变量的数据。 由于每个进程的内存量有限，因此，您需要一种<i>释放</i>资源的方法。 释放内存后，它可用于存储新数据，但是旧数据将保留在那里，直到该单元被覆盖为止。 <br><br><h3> 缓冲液 </h3><br>  <i>缓冲区</i>是一个连续的存储区，其中存储了相同数据类型的多个实例。 例如，短语“我的猫是蝙蝠侠”将存储在16字节缓冲区中。 缓冲区由起始地址和长度确定。 为了不损坏相邻存储器中的数据，重要的是要确保我们不要在缓冲区外进行读写。 <br><br><h3> 控制流程 </h3><br> 程序由按特定顺序运行的例程组成。 在子例程的末尾，计算机将转到存储的指针，该指针指向代码的下一部分（称为<i>返回地址</i> ）。 当您转到寄信人地址时，会发生以下三种情况之一： <br><br><ol><li> 该过程正常继续（返回地址不变）。 <br></li><li> 进程崩溃（地址已更改，并指向不可执行的内存）。 <br></li><li> 该过程继续，但是没有按预期进行（返回地址已更改，控制流已更改）。 </li></ol><br><h1> 语言如何提供内存安全性 </h1><br> 所有编程语言都属于<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">频谱的</a>不同部分。 一方面是像C / C ++这样的语言。 它们很有效，但是需要手动进行内存管理。 另一方面，具有自动内存管理功能的解释型语言（例如，引用计数和垃圾回收（GC）），但它们会在性能上有所回报。 甚至具有垃圾回收优化的语言也无法与没有GC的语言进行<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">性能</a>比较。 <br><br><h3> 手动内存管理 </h3><br> 某些语言（例如C）要求程序员手动管理内存：何时分配多少内存以及何时释放内存。 这使程序员可以完全控制程序如何使用资源，从而提供快速有效的代码。 但是这种方法容易出错，尤其是在复杂的代码库中。 <br><br> 容易犯的错误： <br><br><ul><li> 忘记资源是免费的，然后尝试使用它们； <br></li><li> 没有为数据存储分配足够的空间； <br></li><li> 在缓冲区外部读取内存。 </li></ul><br><div style="text-align:center;"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><img src="https://habrastorage.org/getpro/habr/post_images/657/0a0/242/6570a02427a2d03632cb41c73aa5a48d.jpg"></a> </div><br>  <i><font color="gray">适用于手动管理内存的人员的适当安全说明</font></i> <br><br><h3> 智能指针 </h3><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">智能指针可</a>提供其他信息，以防止不正确的内存管理。 它们用于自动内存管理和边界检查。 与常规指针不同，智能指针能够自毁，并且不会等待程序员手动删除它。 <br><br> 这种构造有多种选择，可以将原始指针包装在几个有用的抽象中。 一些智能指针对对每个对象的<i>引用</i>进行<i>计数</i> ，而其他一些智能指针则执行范围界定策略，以将指针的生存期限制为某些条件。 <br><br> 计数链接时，删除对对象的最后一个引用后，资源将被释放。 基本引用计数实现遭受性能低下，内存消耗增加以及在多线程环境中难以使用的困扰。 如果对象相互引用（圆形链接），则每个对象的引用计数将永远不会达到零，因此需要更复杂的方法。 <br><br><h1> 垃圾收集 </h1><br> 某些语言（例如Java，Go，Python）实现<i><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">垃圾回收</a></i> 。 运行时环境的一部分，称为垃圾收集器（GC），它跟踪变量并在对象之间的链接图中标识不可访问的资源。 一旦对象不可用，GC就会释放基本内存以供将来重用。 没有显式的编程器命令，任何分配和释放内存都会发生。 <br><br> 尽管GC确保始终正确使用内存，但它不会以最有效的方式释放内存-有时，对象的最后一次使用发生在垃圾回收器释放内存的时间之前。 对于任务关键型应用程序，性能成本高得让人望而却步：有时，您需要使用5倍以上的内存来避免性能下降。 <br><br><h3> 拥有 </h3><br>  Rust使用所有权来确保高性能和内存安全性。 更正式地说，这是<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">相似性键入</a>的示例。 所有Rust代码都遵循某些规则，这些规则允许编译器在不损失执行时间的情况下管理内存： <br><br><ol><li> 每个值都有一个称为所有者的变量。 <br></li><li> 一次只能有一个所有者。 <br></li><li> 当所有者移出范围时，该值将被删除。 </li></ol><br> 值可以从一个变量<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">转移</a>或<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">借用</a>到另一个变量。 这些规则适用于编译器的一部分，称为借位检查器。 <br><br> 当变量超出范围时，Rust释放该内存。 在下面的示例中，变量<code>s1</code>和<code>s2</code>超出了范围，它们都尝试释放相同的内存，从而导致双释放错误。 为防止这种情况，当从变量传输值时，先前的所有者无效。 如果程序员随后尝试使用无效变量，则编译器将拒绝该代码。 通过创建数据的深层副本或使用链接可以避免这种情况。 <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">示例1</a> ：所有权转移 <br><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> s1 = <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>::from(<span class="hljs-string"><span class="hljs-string">"hello"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> s2 = s1; <span class="hljs-comment"><span class="hljs-comment">//won't compile because s1 is now invalid println!("{}, world!", s1);</span></span></code> </pre> <br> 另一组借阅检查器规则与变量的生存期有关。  Rust禁止使用未初始化的变量和指向不存在对象的悬空指针。 如果从下面的示例中编译代码，则<code>r</code>将引用<code>x</code>超出范围时释放的内存：出现了悬空指针。 编译器监视所有区域并检查所有传输的有效性，有时需要程序员明确指示变量的生存期。 <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">示例2</a> ：悬吊指针 <br><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> r; { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> x = <span class="hljs-number"><span class="hljs-number">5</span></span>; r = &amp;x; } <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"r: {}"</span></span>, r);</code> </pre> <br> 所有权模型为正确访问内存提供了坚实的基础，可以防止未定义的行为。 <br><br><h1> 内存漏洞 </h1><br> 易受攻击的内存的主要后果是： <br><br><ol><li>  <b>崩溃</b> ：访问无效的内存可能会导致应用程序意外终止。 <br></li><li>  <b>信息泄漏</b> ：无意提供私人数据，包括密码等机密信息。 <br></li><li>  <b>任意代码执行（ACE）</b> ：允许攻击者在目标计算机上执行任意命令。 如果这是通过网络发生的，我们称之为远程代码执行（RCE）。 </li></ol><br> 另一个问题是程序终止后未释放分配的内存时<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">发生内存泄漏</a> 。 因此，您可以耗尽所有可用内存：然后资源请求将被阻止，这将导致拒绝服务。 这是无法在PL级别解决的内存问题。 <br><br> 在最佳情况下，出现内存错误，应用程序将崩溃。 在最坏的情况下，攻击者通过漏洞来控制程序（这可能导致进一步的攻击）。 <br><br><h3> 释放内存的滥用（释放后使用，两次释放） </h3><br> 当资源被释放但仍保留了指向其地址的链接时，会出现此漏洞子类。 这是一种<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">强大的黑客方法</a> ，可能导致超范围访问，信息泄漏，代码执行等。 <br><br> 具有垃圾回收和引用计数的语言可防止使用无效的指针，只会破坏无法访问的对象（这可能导致性能下降），并且手动控制的语言容易受到此漏洞的影响（尤其是在复杂的代码库中）。  Rust中的借位检查器工具不允许在引用对象时销毁对象，因此在编译阶段将这些错误删除。 <br><br><h3> 未初始化的变量 </h3><br> 如果在初始化之前使用了变量，则该数据可以包含任何数据，包括随机垃圾或先前丢弃的数据，这会导致信息泄漏（有时也称为<i>无效指针</i> ）。 为避免这些问题，内存管理语言通常在分配内存后使用自动初始化过程。 <br><br> 与C中一样，Rust中的大多数变量最初都没有初始化。 但是与C不同，您无法在初始化之前读取它们。 以下代码无法编译： <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">示例3</a> ：使用未初始化的变量 <br><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> x: <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"{}"</span></span>, x); }</code> </pre> <br><h3> 空指针 </h3><br> 当应用程序取消引用原来为空的指针时，它通常仅访问垃圾并导致崩溃。 在某些情况下，这些漏洞可能导致执行任意代码（ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">1、2、3</a> ）。  Rust有两种类型的指针： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">链接</a>和原始指针。 链接是安全的，但原始指针可能会成为问题。 <br><br>  Rust防止通过两种方式取消引用空指针： <br><br><ol><li> 避免使用可为空的指针。 <br></li><li> 避免取消引用原始指针。 </li></ol><br>  Rust通过将空指针替换为特殊的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><code> Option</code></a>避免空指针。 要更改<code>Option</code>类型中可能的null值，该语言要求程序员使用null值显式处理大小写，否则程序将无法编译。 <br><br> 如果无法避免允许空值的指针（例如，与另一种语言的代码进行交互时）怎么办？ 尝试隔离损坏。 原始指针的解除引用必须在隔离的不安全块中进行。 它<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">放宽了Rust规则，</a>并解决了一些可能导致未定义行为的操作（例如，取消引用原始指针）。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e58/bd7/b69/e58bd7b69e8f2f399e431bdb4f6d151f.jpg"></div><br>  <i><font color="gray">“关于借来的东西的一切……那个黑暗的地方呢？”</font></i> <i><font color="gray"><br></font></i>  <i><font color="gray">-这是不安全的封锁。</font></i>  <i><font color="gray">永远不要去那里，辛巴</font></i> <br><br><h3> 缓冲区溢出 </h3><br> 我们讨论了可以通过限制对未定义内存的访问来避免的漏洞。 但是问题是缓冲区溢出不能正确访问未定义但合法分配的内存。 像释放后使用的bug一样，这种访问可能会成为问题，因为它访问释放的内存，该内存仍包含不应再存在的机密信息。 <br><br> 缓冲区溢出只是意味着越界访问。 由于缓冲区存储在内存中的方式，它们经常泄漏可能包含敏感数据（包括密码）的信息。 在更严重的情况下，可以通过覆盖指令指针来实现ACE / RCE漏洞。 <br><br> 示例4：缓冲区溢出（C代码） <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> buf[] = {<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>}; <span class="hljs-comment"><span class="hljs-comment">// print out of bounds printf("Out of bounds: %d\n", buf[10]); // write out of bounds buf[10] = 10; printf("Out of bounds: %d\n", buf[10]); return 0; }</span></span></code> </pre> <br> 防止缓冲区溢出的最简单方法是在访问元素时始终要求进行边界检查，但这会导致<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">性能下降</a> 。 <br><br> 锈有什么作用？ 标准库中的内置缓冲区类型需要对任何随机访问进行边界检查，而且还提供迭代器API以加快顺序调用的速度。 这确保了对于这些类型不可能进行外部边界的读取和写入。  Rust提倡仅在几乎肯定要手动将其放置在C / C ++中的地方才需要边界检查的图案。 <br><br><h1> 内存安全仅是成功的一半 </h1><br> 安全漏洞导致漏洞，例如数据泄漏和远程代码执行。 有多种保护内存的方法，包括智能指针和垃圾回收。 您甚至可以<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">正式证明内存的安全性</a> 。 虽然某些语言为了内存安全性而降低了性能，但Rust的所有权概念提供了安全性并最大程度地减少了开销。 <br><br> 不幸的是，当我们谈论编写安全代码时，内存错误只是故事的一部分。 在下一篇文章中，我们将考虑线程安全和对并行代码的攻击。 <br><br><h1> 利用内存漏洞：其他资源 </h1><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">堆内存和开发</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">从黑客位置破坏堆栈</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">信息安全类比</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">售后使用漏洞简介</a> </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN438288/">https://habr.com/ru/post/zh-CN438288/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN438272/index.html">我们如何从山洞发送短信</a></li>
<li><a href="../zh-CN438274/index.html">IT中“有毒人格”的定义</a></li>
<li><a href="../zh-CN438278/index.html">教孩子编程</a></li>
<li><a href="../zh-CN438280/index.html">在Django中“删除”对象</a></li>
<li><a href="../zh-CN438286/index.html">在JavaScript中使用时区</a></li>
<li><a href="../zh-CN438290/index.html">GGJ-2019的事后分析：如何获得成功，但仍能使游戏成为现实</a></li>
<li><a href="../zh-CN438292/index.html">使用HomePod，Raspberry Pi和Node.js的公寓自动化</a></li>
<li><a href="../zh-CN438294/index.html">在PUBG比赛中查找抽搐彩带</a></li>
<li><a href="../zh-CN438296/index.html">OpenSceneGraph：插件系统</a></li>
<li><a href="../zh-CN438298/index.html">为什么要教开发是否更有利可图。 与GeekBrains的对话</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>