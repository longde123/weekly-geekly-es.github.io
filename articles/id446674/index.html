<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>💦 ⏱️ 👩🏼‍🚀 Kami memodelkan algoritma MUSIK untuk menentukan arah kedatangan gelombang elektromagnetik 👨‍👨‍👧‍👧 〰️ 🌽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Kata Pengantar 


 Saya akan mulai perkenalan saya dari jauh. Sekali waktu, di kejauhan 2016-2017, hambamu yang rendah hati berhasil mengikuti kursus ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Kami memodelkan algoritma MUSIK untuk menentukan arah kedatangan gelombang elektromagnetik</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/446674/"><p><img src="https://media.moddb.com/cache/images/groups/1/3/2392/thumb_620x2000/music-cats.jpg" alt="aaspcats"></p><br><h2 id="predislovie">  Kata Pengantar </h2><br><p>  Saya akan mulai perkenalan saya dari jauh.  Sekali waktu, di kejauhan 2016-2017, hambamu yang rendah hati berhasil mengikuti kursus pelatihan enam bulan ke kota jauh <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow">Ilmenau</a> (Jerman), di mana ia berhasil (pada umumnya) menyelesaikan program master <strong>Komunikasi dan pemrosesan sinyal</strong> .  Program itu tidak mudah, tetapi sekarang bahkan menyenangkan untuk mengingatnya.  Terkadang ... </p><a name="habracut"></a><br><p>  Jadi, di akhir pelatihan ini, selain ijazah, saya masih memiliki beberapa materi yang berbeda di tangan saya, yang saya pikir salah untuk tidak dibagikan. </p><br><p>  Salah satu bahan ini ada di depan Anda. </p><br><p>  <strong>Apa tujuan yang saya kejar saat mempersiapkan seminar</strong> : </p><br><ol><li>  berbicara tentang beberapa pendekatan "pintar" yang sudah mapan dalam topik susunan antena yang paling mudah diakses dan melakukannya dalam bahasa Rusia; </li><li>  melakukan simulasi kecil dengan <strong><em>Python 3</em></strong> untuk menggerakkan sesama insinyur radio untuk melihat lebih dekat bahasa pemrograman (jika Anda belum melihat dari dekat); </li><li>  menyediakan tautan ke literatur berbahasa Inggris yang baik - tanpa membaca sumber asing, sekarang, sayangnya, tidak ada tempat. </li></ol><br><p>  <strong>Apa yang harus dipertimbangkan</strong> : </p><br><ul><li>  Metode MUSIK (Klasifikasi Sebagian Besar) - ini, pada kenyataannya, mengacu pada pratinjau. </li></ul><br><blockquote>  Contoh pembentukan bagan dan metode MVDR dapat ditemukan di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow">sini</a> (jika ada pertanyaan atau saran untuk bahan tambahan, diskusi dapat dilanjutkan di Github.Gist). </blockquote><p>  Seperti yang saya katakan di atas, kita akan menggunakan Python, yaitu: </p><br><pre><code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> numpy <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> np <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> matplotlib.pyplot <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> plt</code> </pre> <br><p>  Mengapa tidak MATLAB, salah satu kandidat paling populer dan nyaman untuk pemodelan aljabar linier, Anda bertanya?  Karena, saya ingin menunjukkan bahwa pekerjaan serupa dapat dilakukan dengan Python, dan cakupan Python jauh lebih luas daripada MATLAB.  Oleh karena itu, mengenal sintaksis Python adalah hal yang berguna, menurut saya. </p><br><p>  Ayo mulai! </p><br><blockquote>  Rumus disiapkan melalui <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow">https://upmath.me/</a> .  Terima kasih kepada pencipta untuk alat yang hebat! </blockquote><br><h2 id="postanovka-zadachi">  Pernyataan masalah </h2><br><p>  Misalkan ada array antena linier yang terdiri dari sejumlah elemen yang terpisah satu sama lain <img src="https://tex.s2cms.ru/svg/%5CDelta%20%3D%20%5Cfrac%7B%5Clambda%7D%7B2%7D" alt="\ Delta = \ frac {\ lambda} {2}">  (langkah array antena), di mana <img src="https://tex.s2cms.ru/svg/%5Clambda" alt="\ lambda">  - panjang gelombang pembawa elektromagnetik (EM). </p><br><p>  Gelombang elektromagnetik jatuh pada susunan antena ini dari arah yang berbeda. </p><br><p><img src="https://habrastorage.org/webt/mk/3w/zz/mk3wzzmb4bonpno72euep64v0ao.png"></p><br><blockquote>  Fig.  1. <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow">Sistem antena adaptif.</a> </blockquote><p>  Seperti dapat dilihat dari gambar, susunan antena dianggap sebagai filter adaptif. </p><br><p>  Sebenarnya, menemukan vektor koefisien optimal ( <img src="https://tex.s2cms.ru/svg/%5Cmathbf%7Bw%7D_%7Bopt%7D" alt="\ mathbf {w} _ {opt}">  ) adalah tugas utama array antena adaptif dari sudut pandang matematika. </p><br><p>  Awalnya, kita tidak tahu dari arah mana sinyal datang dan berapa banyak dari mereka.  Untuk menyelesaikan kontradiksi ini kita akan menggunakan algoritma MUSIC, sebuah algoritma untuk memperkirakan frekuensi spasial dengan resolusi tinggi. </p><br><h2 id="modelirovanie-prinyatogo-signala">  Simulasi sinyal yang diterima </h2><br><p>  Kami dapat menyajikan model sinyal yang diterima melalui rumus: </p><br><p></p><div style="text-align:center;"><img src="https://tex.s2cms.ru/svg/%20%5Cmathbf%7BX%7D%20%3D%20%5Cmathbf%7BA%7D%20%5Cmathbf%7BS%7D%20%2B%20%5Cmathbf%7BN%7D%20" alt="\ mathbf {X} = \ mathbf {A} \ mathbf {S} + \ mathbf {N}"></div><p></p><br><p>  dimana <img src="https://tex.s2cms.ru/svg/%5Cmathbf%7BA%7D%20%3D%20%5B%5Cmathbf%7Ba%7D(%5Ctheta_1)%20%5Cquad%20%5Cmathbf%7Ba%7D(%5Ctheta_2)%20%5Cquad%20...%20%5Cquad%20%5Cmathbf%7Ba%7D(%5Ctheta_d)%5D" alt="\ mathbf {A} = [\ mathbf {a} (\ theta_1) \ quad \ mathbf {a} (\ theta_2) \ quad ... \ quad \ mathbf {a} (\ theta_d)]">  - matriks vektor pemindaian (vektor kemudi) dari susunan antena ( <img src="https://tex.s2cms.ru/svg/%20a_i%20%3D%20%5Cexp(-j%20%5Cmu%20m_i)" alt="a_i = \ exp (-j \ mu m_i)">  , <img src="https://tex.s2cms.ru/svg/m%20%3D%200%2C%201%20...%20(M-1)" alt="m = 0, 1 ... (M-1)">  , <img src="https://tex.s2cms.ru/svg/M" alt="M.">  - jumlah elemen array antena, <img src="https://tex.s2cms.ru/svg/d" alt="d">  - jumlah sumber gelombang EM, <img src="https://tex.s2cms.ru/svg/%5Ctheta" alt="\ theta">  - miringkan arah kedatangan gelombang EM), <img src="https://tex.s2cms.ru/svg/%5Cmathbf%7BS%7D" alt="\ mathbf {S}">  - matriks karakter yang dikirimkan, dan <img src="https://tex.s2cms.ru/svg/%5Cmathbf%7BN%7D" alt="\ mathbf {N}">  - Matriks noise tambahan. </p><br><img src="https://raw.githubusercontent.com/kirlf/CSP/master/Different/assets/ULA.png" alt="ULA" width="600"><br><blockquote>  Fig.  2. Array antena linear omnidirectional (ULAA - array anntenna linear seragam) [1, hal.  32]. </blockquote><p>  Mari kita memikirkan kembali formula ini dengan cara "sehari-hari": di grid kita, kita mendapatkan beberapa "kekacauan" dari berbagai sinyal, yang kita tandai dengan <img src="https://tex.s2cms.ru/svg/%5Cmathbf%7BX%7D" alt="\ mathbf {X}">  .  Kami tidak secara eksplisit menerima informasi tentang jumlah sumber dan arah, namun, informasi tentang ini tetap terkandung dalam sinyal yang diterima. </p><br><p>  Kami mulai mencari! </p><br><p>  Untuk melakukan ini, mereka biasanya melanjutkan ke manipulasi tidak dengan matriks dari sinyal kompleks yang diamplitasikan sendiri, tetapi dengan kovarian mereka (yaitu, pada dasarnya, dengan kekuatan): </p><br><p></p><div style="text-align:center;"><img src="https://tex.s2cms.ru/svg/%20%5Cmathbf%7BR%7D_%7Bxx%7D%20%3D%20%5Cmathbf%7BX%7D%5Cmathbf%7BX%7D%5EH%20%3D%20%20%5Cmathbf%7BA%7D%20%5Cmathbf%7BR%7D_%7Bss%7D%20%5Cmathbf%7BA%7D%5EH%20%2B%20%5Cmathbf%7BR%7D_%7Bnn%7D%20" alt="\ mathbf {R} _ {xx} = \ mathbf {X} \ mathbf {X} ^ H = \ mathbf {A} \ mathbf {R} _ {ss} \ mathbf {A} ^ H + \ mathbf {R} _ {nn}"></div><p></p><br><h2 id="usloviya">  Ketentuan </h2><br><p>  Kami memperkenalkan kondisi penting untuk dipertimbangkan: batas resolusi sudut Rayleigh: </p><br><p></p><div style="text-align:center;"><img src="https://tex.s2cms.ru/svg/sin%20(%5Ctheta_R)%20%3D%20%5Cfrac%7B%5Clambda%7D%7BD%7D" alt="sin (\ theta_R) = \ frac {\ lambda} {D}"></div><p></p><br><p>  dimana <img src="https://tex.s2cms.ru/svg/D%20%3D%20M%20%5CDelta" alt="D = M \ Delta">  Apakah panjang kisi linear. </p><br><p>  Kami mendefinisikan kembali sudut kedatangan gelombang elektromagnetik melalui konsep frekuensi spasial: </p><br><p></p><div style="text-align:center;"><img src="https://tex.s2cms.ru/svg/%20%5Cmu_R%20%3D%20%5Cfrac%7B2%20%5Cpi%7D%7B%5Clambda%7D%5CDelta%20sin(%5Ctheta_R)%20%3D%20%5Cfrac%7B2%20%5Cpi%7D%7B%5Clambda%7D%5CDelta%20%5Cfrac%7B%5Clambda%7D%7B%5CDelta%20M%7D%20%3D%20%5Cfrac%7B2%20%5Cpi%7D%7BM%7D" alt="\ mu_R = \ frac {2 \ pi} {\ lambda} \ Delta dosa (\ theta_R) = \ frac {2 \ pi} {\ lambda} \ Delta \ frac {\ lambda} {\ Delta M} = \ frac { 2 \ pi} {M}"></div><p></p><br><p>  dimana <img src="https://tex.s2cms.ru/svg/%5Cmu_R" alt="\ mu_R">  - ada lebar standar dari lobus utama balok ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow">beamwidth standar</a> ). </p><br><p>  Untuk memeriksa seberapa efektif metode kami dan dalam kondisi apa, kami memperkenalkan beberapa nilai yang diberikan untuk pemisahan sudut: </p><br><ol><li><p><img src="https://tex.s2cms.ru/svg/%5Cmu_1%20%3D%20-%20%5Cmu_R%2C%20%5Cquad%20%5Cmu_2%20%3D%200%2C%20%5Cquad%20%5Cmu_3%20%3D%20%20%5Cmu_R%20%5Cquad%20" alt="\ mu_1 = - \ mu_R, \ quad \ mu_2 = 0, \ quad \ mu_3 = \ mu_R \ quad">  - pembagian menjadi satu lebar balok; </p><br></li><li><p><img src="https://tex.s2cms.ru/svg/%5Cmu_1%20%3D%20-0.5%20%5Cmu_R%2C%20%5Cquad%20%5Cmu_2%20%3D%200%2C%20%5Cquad%20%5Cmu_3%20%3D%200.5%20%5Cmu_R%20%5Cquad%20" alt="\ mu_1 = -0.5 \ mu_R, \ quad \ mu_2 = 0, \ quad \ mu_3 = 0,5 \ mu_R \ quad">  - Pembagian menjadi satu lebar balok kedua; </p><br></li><li><p><img src="https://tex.s2cms.ru/svg/%5Cmu_1%20%3D%20-0.3%20%5Cmu_R%2C%20%5Cquad%20%5Cmu_2%20%3D%200%2C%20%5Cquad%20%5Cmu_3%20%3D%200.3%20%5Cmu_R%20%5Cquad%20" alt="\ mu_1 = -0,3 \ mu_R, \ quad \ mu_2 = 0, \ quad \ mu_3 = 0,3 \ mu_R \ quad">  - Pembagian menjadi tiga persepuluh dari lebar balok. </p><br></li></ol><br><p>  Tentukan parameter input: </p><br><pre> <code class="python hljs">M = <span class="hljs-number"><span class="hljs-number">10</span></span> <span class="hljs-comment"><span class="hljs-comment">#    () SNR = 10 #  - (dB) d = 3 #     N = 50 #  "" (snapshots) S = ( np.sign(np.random.randn(d,N)) + 1j * np.sign(np.random.randn(d,N)) ) / np.sqrt(2) # QPSK W = ( np.random.randn(M,N) + 1j * np.random.randn(M,N) ) / np.sqrt(2) * 10**(-SNR/20) # AWGN #  : # sqrt(N0/2)*(G1 + jG2), #  G1  G2 -   . # .. Es( )  QPSK  1 ,    (noise spectral density): # N0 = (Es/N)^(-1) = SNR^(-1) [] (   ,  SNR = Es/N0); #    : # SNR_dB = 10log10(SNR) =&gt; N0_dB = -10log10(SNR) = -SNR_dB []; #    SNR    (..  ),   : # SNR = 10^(SNR_dB/10) =&gt; sqrt(N0) = (10^(-SNR_dB/10))^(1/2) = 10^(-SNR_dB/20) mu_R = 2*np.pi / M</span></span></code> </pre> <br><h2 id="nemnogo-teorii-o-samom-metode">  Sedikit teori tentang metode itu sendiri </h2><br><p>  Pertama-tama, kami mencatat bahwa leluhur dari metode MUSIK adalah metode <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow">Pisarenko</a> (1973).  Masalah yang dipertimbangkan dari metode Pisarenko adalah memperkirakan frekuensi jumlah eksponensial kompleks dalam white noise.  V.F. Pisarenko menunjukkan bahwa frekuensi dapat ditemukan dari vektor eigen yang sesuai dengan nilai eigen minimum dari matriks autokorelasi.  Selanjutnya, metode ini menjadi kasus khusus dari metode MUSIC.  [2, hlm.  459] </p><br><p>  Schmidt dan rekan-rekannya mengusulkan Algoritma Klasifikasi Beberapa Sinyal (MUSIK) pada tahun 1979 [4].  Pendekatan utama dari algoritma ini adalah untuk menguraikan matriks kovarians dari sinyal yang diterima menjadi nilai eigen.  Karena algoritma ini memperhitungkan kebisingan yang tidak berkorelasi, matriks kovarian yang dihasilkan memiliki bentuk diagonal.  Di sini, sinyal dan kebisingan subruang dihitung menggunakan aljabar linier, dan saling orthogonal.  Oleh karena itu, algoritma ini menggunakan properti orthogonality untuk mengekstraksi subruang sinyal dan noise [5]. </p><br><p>  Algoritma MUSIC yang digeneralisasi dapat didefinisikan sebagai berikut: </p><br><ul><li>  Temukan matriks kovarians <img src="https://tex.s2cms.ru/svg/%20%5Cmathbf%7BR%7D_%7Bxx%7D%20" alt="\ mathbf {R} _ {xx}"></li><li>  Temukan vektor eigen melalui <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow">EVD</a> atau algoritma numerik lain yang sesuai: </li></ul><br><p></p><div style="text-align:center;"><img src="https://tex.s2cms.ru/svg/%20%5Cmathbf%7BR%7D_%7Bxx%7D%20%3D%20%5Cmathbf%7BU%7D%5Cmathbf%7B%5CLambda%7D%5Cmathbf%7BU%7D%5EH%20%5Cqquad(1)" alt="\ mathbf {R} _ {xx} = \ mathbf {U} \ mathbf {\ Lambda} \ mathbf {U} ^ H \ qquad (1)"></div><p></p><br><ul><li>  Temukan spektrum pseudo (mengapa dengan pseudo awalan, kita akan bahas di bawah) MUSIK melalui rumus berikut: </li></ul><br><p></p><div style="text-align:center;"><img src="https://tex.s2cms.ru/svg/%20P_%7BMU%7D(e%5E%7Bj%5Comega%7D)%20%3D%20%5Cfrac%7B1%7D%7B%5Csum%20%5Climits_%7Bi%3Dd%2B1%7D%5E%7BM%7D%7C%5Cmathbf%7Ba%7D%5EH%5Cmathbf%7Bu%7D_i%7C%5E2%7D%20%5Cqquad(2)%20" alt="P_ {MU} (e ^ {j \ omega}) = \ frac {1} {\ sum \ limit_ {i = d + 1} ^ {M} | \ mathbf {a} ^ H \ mathbf {u} _i | ^ 2} \ qquad (2)"></div><p></p><br><p>  dimana <img src="https://tex.s2cms.ru/svg/%5Cmathbf%7Ba%7D%20%3D%20%5Cbegin%7Bbmatrix%7D%20%20e%5E%7Bj0%5Comega%7D%20%26%20e%5E%7Bj1%5Comega%7D%20%26%20e%5E%7Bj2%5Comega%7D%20%26%20...%20%26%20e%5E%7Bj(M-1)%5Comega%7D%20%5Cend%7Bbmatrix%7D%5ET" alt="\ mathbf {a} = \ begin {bmatrix} e ^ {j0 \ omega} &amp; e ^ {j1 \ omega} &amp; e ^ {j2 \ omega} &amp; ... &amp; e ^ {j (M-1) \ omega } \ end {bmatrix} ^ T">  Apakah vektor eksponensial untuk frekuensi ω terletak pada rentang tertentu, dan <img src="https://tex.s2cms.ru/svg/%5Cmathbf%7Bu%7D_i" alt="\ mathbf {u} _i">  - vektor eigen ke-i (vektor eigen) dari matriks kovarians (1) yang sesuai dengan subruang kebisingan dari matriks (1) - maka indeksasi dengan <img src="https://tex.s2cms.ru/svg/d%2B1" alt="d +1">  ( <img src="https://tex.s2cms.ru/svg/d" alt="d">  Apakah pangkat matriks (1)). </p><br><blockquote>  Untuk kejelasan yang lebih besar, cobalah menjalankan skrip MATLAB yang sesuai dengan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow">referensi</a> .  Perhatikan dua poin utama: <br><ul><li>  alih-alih menghitung kuadrat dari norma kedua dalam penyebut (2), penulis menerapkan algoritma FFT ke vektor eigen, yang memfasilitasi pemodelan dengan menggunakan fungsi bawaan dan, secara umum, tidak bertentangan dengan teori dari sudut pandang matematika; </li><li>  matriks kovarians dihitung melalui matriks konvolusional, pendekatan yang berbeda ditunjukkan di atas untuk memperkirakan frekuensi spasial. </li></ul><br></blockquote><p>  Seperti yang Anda tebak dari namanya, MUSIC juga merupakan metode klasik untuk memperkirakan arah penerimaan dengan resolusi tinggi.  Algoritma untuk menghitung pseudo-spektra dalam konteks ini diberikan di bawah ini: </p><br><ul><li><p>  kami menemukan matriks kovarians dari sinyal yang diterima; </p><br></li><li><p>  temukan subruang nol <img src="https://tex.s2cms.ru/svg/%5Cmathbf%7BU%7D_0" alt="\ mathbf {U} _0">  : </p><br></li></ul><br><br><p></p><div style="text-align:center;"><img src="https://tex.s2cms.ru/svg/%20%5Cmathbf%7BU%7D%20%3D%20%5B%5Cmathbf%7BU%7D_s%20%5Cquad%20%5Cmathbf%7BU%7D_0%5D%20" alt="\ mathbf {U} = [\ mathbf {U} _s \ quad \ mathbf {U} _0]"></div><p></p><br><ul><li>  pilih beberapa rentang pencarian: </li></ul><br><p></p><div style="text-align:center;"><img src="https://tex.s2cms.ru/svg/%20a(%5Cmu)%20%3D%20%5Cbegin%7Bbmatrix%7D%20e%5E%7Bj0%5Cmu_1%7D%20%26%20...%20%26%20e%5E%7Bj0%5Cmu_Q%7D%20%5C%5C%20...%20%26...%26...%20%5C%5C%20e%5E%7Bj(M-1)%5Cmu_1%7D%20%26%20...%20%26%20e%5E%7Bj(M-1)%5Cmu_Q%7D%20%5Cend%7Bbmatrix%7D%20" alt="a (\ mu) = \ begin {bmatrix} e ^ {j0 \ mu_1} &amp; ... &amp; e ^ {j0 \ mu_Q} \\ ... &amp; ... &amp; ... \\ e ^ {j ( M-1) \ mu_1} &amp; ... &amp; e ^ {j (M-1) \ mu_Q} \ end {bmatrix}"></div><p></p><br><p>  dimana <img src="https://tex.s2cms.ru/svg/%5Cmu%20%3D%20-%5Cfrac%7B2%5Cpi%20f_c%7D%7Bc%7D%5CDelta%20sin%5Ctheta%20%3D%20-%5Cfrac%7B2%5Cpi%20%7D%7B%5Clambda%20%7D%5CDelta%20sin%5Ctheta" alt="\ mu = - \ frac {2 \ pi f_c} {c} \ Delta sin \ theta = - \ frac {2 \ pi} {\ lambda} \ Delta sin \ theta"></p><br><ul><li>  hitung spektrum pseudo: </li></ul><br><p></p><div style="text-align:center;"><img src="https://tex.s2cms.ru/svg/%20P_%7BMU%7D(%5Ctheta)%3D%5Cfrac%7B%5Cmathbf%7Ba%7D%5EH%20(%5Ctheta)%5Cmathbf%7Ba%7D(%5Ctheta)%7D%7B%5Cmathbf%7Ba%7D%5EH(%5Ctheta)%5Cmathbf%7BU%7D_0%20%5Cmathbf%7BU%7D_0%5EH%20%5Cmathbf%7Ba%7D(%5Ctheta)%7D%20" alt="P_ {MU} (\ theta) = \ frac {\ mathbf {a} ^ H (\ theta) \ mathbf {a} (\ theta)} {\ mathbf {a} ^ H (\ theta) \ mathbf {U} _0 \ mathbf {U} _0 ^ H \ mathbf {a} (\ theta)}"></div><p></p><br><p>  Hubungan antara analisis spektral dan analisis sudut kedatangan (DoA - arah kedatangan) gelombang EM dijelaskan pada tabel 1. </p><br><p>  Tabel 1 <strong>Komunikasi antara aplikasi MUSIC</strong> : Pemrosesan array sinyal dan pencarian Harmonic [6]. </p><br><div class="scrollable-table"><table><thead><tr><th>  Variabel </th><th>  Pemrosesan Array Sinyal </th><th>  Pencarian Harmonis </th></tr></thead><tbody><tr><td><div style="text-align:center;"><img src="https://tex.s2cms.ru/svg/M" alt="M."></div></td><td>  Jumlah sensor </td><td>  Jumlah periode waktu </td></tr><tr><td><div style="text-align:center;"><img src="https://tex.s2cms.ru/svg/N" alt="N"></div></td><td>  Jumlah periode waktu </td><td>  Jumlah percobaan </td></tr><tr><td><div style="text-align:center;"><img src="https://tex.s2cms.ru/svg/d" alt="d"></div></td><td>  Jumlah front gelombang </td><td>  Jumlah komponen kompleks </td></tr><tr><td><div style="text-align:center;"><img src="https://tex.s2cms.ru/svg/%5Cmu" alt="\ mu"></div></td><td>  Frekuensi spasial </td><td>  Frekuensi yang dinormalisasi </td></tr></tbody></table></div><br><p>  Secara umum, proses penerimaan melalui array (grating) dapat dibandingkan dengan proses diskritisasi klasik, karena  pada kenyataannya, setiap sensor, yang menerima gelombang dengan penundaan fase tertentu (yaitu, dengan penundaan waktu tertentu), melakukan fungsi pulsa delta sampel.  Jumlah realisasi (percobaan) analisis spektral klasik akan sesuai dengan jumlah segmen waktu (foto).  Setiap sumber akan memiliki muka gelombang sendiri, yang setara dengan jumlah sinusoid unik dari sinyal dalam kasus analisis spektral. </p><br><p>  Dan sekarang kembali ke saat menghitung vektor eigen.  Kami sudah disebutkan di atas vektor itu <img src="https://tex.s2cms.ru/svg/a(%5Ctheta_i)%5Cepsilon%20A" alt="a (\ theta_i) \ epsilon A">  dimana <img src="https://tex.s2cms.ru/svg/i%3D1%2C2%2C..%2Cd" alt="i = 1,2, .., d">  bersifat ortogonal ke subruang kebisingan dari matriks kovarians, yaitu .: </p><br><p></p><div style="text-align:center;"><img src="https://tex.s2cms.ru/svg/%20a(%5Ctheta_i)%5ETU_0%3D0%5ET%20" alt="a (\ theta_i) ^ TU_0 = 0 ^ T"></div><p></p><br><p>  Sebenarnya, kita melihat sistem persamaan, pemecahan yang dapat kita temukan akar - vektor eigen.  Metode seperti itu, berbeda dengan algoritma numerik (yang, seperti yang kami sebutkan di atas, berlaku untuk EVD), memungkinkan seseorang untuk mendapatkan nilai eigen yang nyata daripada perkiraan.  Itulah sebabnya pendekatan ini memungkinkan kita untuk mendapatkan bukan pseudospectrum, tetapi spektrum.  Ide yang sama membentuk dasar dari algoritma <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow">Root MUSIC</a> . </p><br><h2 id="modelirovanie">  Pemodelan </h2><br><p>  Fuf!  Akhirnya, semua formula dijelaskan dan agak dijelaskan.  Kita bisa memulai pemodelan. </p><br><pre> <code class="python hljs">cases = [[<span class="hljs-number"><span class="hljs-number">-1.</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1.</span></span>], [<span class="hljs-number"><span class="hljs-number">-0.5</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0.5</span></span>], [<span class="hljs-number"><span class="hljs-number">-0.3</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0.3</span></span>],] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> idxm, c <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> enumerate(cases): <span class="hljs-comment"><span class="hljs-comment">#   ( ): mu_1 = c[0]*mu_R mu_2 = c[1]*mu_R mu_3 = c[2]*mu_R #   a_1 = np.exp(1j*mu_1*np.arange(M)) a_2 = np.exp(1j*mu_2*np.arange(M)) a_3 = np.exp(1j*mu_3*np.arange(M)) A = (np.array([a_1, a_2, a_3])).T #    X = np.dot(A,S) + W #    R = np.dot(X,np.matrix(X).H) U, Sigma, Vh = np.linalg.svd(X, full_matrices=True) U_0 = U[:,d:] #   thetas = np.arange(-90,91)*(np.pi/180) #   mus = np.pi*np.sin(thetas) #    a = np.empty((M, len(thetas)), dtype = complex) for idx, mu in enumerate(mus): a[:,idx] = np.exp(1j*mu*np.arange(M)) # MVDR: S_MVDR = np.empty(len(thetas), dtype = complex) for idx in range(np.shape(a)[1]): a_idx = (a[:, idx]).reshape((M, 1)) S_MVDR[idx] = 1 / (np.dot(np.matrix(a_idx).H, np.dot(np.linalg.pinv(R),a_idx))) # MUSIC: S_MUSIC = np.empty(len(thetas), dtype = complex) for idx in range(np.shape(a)[1]): a_idx = (a[:, idx]).reshape((M, 1)) S_MUSIC[idx] = np.dot(np.matrix(a_idx).H,a_idx)\ / (np.dot(np.matrix(a_idx).H, np.dot(U_0,np.dot(np.matrix(U_0).H,a_idx)))) plt.subplots(figsize=(10, 5), dpi=150) plt.semilogy(thetas*(180/np.pi), np.real( (S_MVDR / max(S_MVDR))), color='green', label='MVDR') plt.semilogy(thetas*(180/np.pi), np.real((S_MUSIC/ max(S_MUSIC))), color='red', label='MUSIC') plt.grid(color='r', linestyle='-', linewidth=0.2) plt.xlabel('Azimuth angles θ (degrees)') plt.ylabel('Power (pseudo)spectrum (normalized)') plt.legend() plt.title('Case #'+str(idxm+1)) plt.show()</span></span></code> </pre> <br><p><img src="https://habrastorage.org/webt/g1/u-/al/g1u-almrcy6s22pas2skmwvw-t0.png"><br><img src="https://habrastorage.org/webt/cu/mo/ml/cumomltqiwfzp-4lpvly0gzrtby.png"><br><img src="https://habrastorage.org/webt/_j/bo/kn/_jboknyjydjcgjuk9igu7nbfo_a.png"></p><br><p>  Seperti yang dapat kita lihat, MUSIC memiliki resolusi yang lebih tinggi dan memungkinkan untuk mencapai, secara umum, hasil yang lebih baik daripada, misalnya, MVDR memungkinkan - perwakilan yang sama dari metode parametrik analisis spektral. </p><br><p>  Namun, harus diingat bahwa ketika menggunakan MUSIC kita menggunakan algoritma yang lebih mahal secara komputasi, seperti EVD atau SVD, yang harganya terjangkau untuk akurasi yang lebih tinggi. </p><br><p>  Hal-hal seperti itu. </p><br><h2 id="spisok-ispolzovannoy-literatury">  Daftar literatur yang digunakan: </h2><br><ol><li>  Haykin, Simon, dan KJ Ray Liu.  Buku pegangan tentang pemrosesan array dan jaringan sensor.  Vol.  63. John Wiley &amp; Sons, 2010. hlm.  102-107 </li><li>  Hayes MH Statistik pemrosesan sinyal digital dan pemodelan.  - John Wiley &amp; Sons, 2009. </li><li>  Haykin, Simon S. Adaptive filter theory.  Pearson Education India, 2008. hlm.  422-427 </li><li>  Richmond, Christ D. "Algoritma Capon berarti ambang batas kesalahan prediksi SNR dan probabilitas resolusi."  Transaksi IEEE pada Pemrosesan Sinyal 53.8 (2005): 2748-2764. </li><li>  SKP Gupta, MUSIC, dan algoritme MUSIC yang ditingkatkan untuk memperkirakan kedatangan, IEEE, 2015. </li><li>  Kuliah Profesor Martin Haardt ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow">array array</a> ) </li></ol></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id446674/">https://habr.com/ru/post/id446674/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id446660/index.html">AI, siswa dan hadiah besar: bagaimana melakukan pembelajaran mesin di kelas 8</a></li>
<li><a href="../id446662/index.html">Transaksi dan mekanisme untuk kontrol mereka</a></li>
<li><a href="../id446664/index.html">SAP Forum 2019 hanya 2 minggu lagi! Apa yang akan ada di sana?</a></li>
<li><a href="../id446666/index.html">Peras kalkulator grafis: game di TI-83</a></li>
<li><a href="../id446668/index.html">Python untuk web: apa yang perlu diketahui junior untuk bekerja dan tumbuh</a></li>
<li><a href="../id446676/index.html">Membuat Kunci yang Hilang untuk Commodore 116 Keyboard Karet</a></li>
<li><a href="../id446678/index.html">Pertempuran Langsung: Final ICPC Porto</a></li>
<li><a href="../id446680/index.html">Naluri utama pembuat enkode adalah menghilangkan solusi yang tidak efektif dari mana-mana</a></li>
<li><a href="../id446682/index.html">Mempercepat WebGL / Three.js dengan OffscreenCanvas dan Pekerja Web</a></li>
<li><a href="../id446688/index.html">Ekstensi SIMD ke C ++ OpenMP di Visual Studio</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>