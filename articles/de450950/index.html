<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>💇🏼 👩🏾‍🎨 👎🏾 Dart Streams Grundlagen 👃🏿 ⚒️ 🚳</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dies ist der zweite Teil meiner Serie über Flatterarchitektur: 


- Einführung 
- Dart Streams Basics (dieser Beitrag) 
- RxDart: magische Transformat...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Dart Streams Grundlagen</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/450950/"><p>  Dies ist der zweite Teil meiner Serie über Flatterarchitektur: </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Einführung</a> </li><li>  <strong>Dart Streams Basics (dieser Beitrag)</strong> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">RxDart: magische Transformationen von Flüssen</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">RxVMS-Grundlagen: RxCommand und GetIt</a> </li><li>  RxVMS: Services und Manager </li><li>  RxVMS: in sich geschlossene Widgets </li><li>  Benutzerauthentifizierung mit RxVMS </li></ul><br><p>  Streams sind der Hauptbaustein von <strong>RxVMS</strong> . Ihr Verständnis ist für die Arbeit mit dieser Bibliothek unbedingt erforderlich. Wir werden uns in diesem Beitrag ausführlicher mit ihnen <strong>befassen</strong> . </p><br><p>  Es stellte sich heraus, dass die Aufnahme von Rx in diesen Beitrag zu lang werden würde, also habe ich es in zwei Teile geteilt. </p><br><h2 id="pust-techet">  Lass es fließen </h2><br><p>  Ich habe viele Kommentare gelesen, denen zufolge Streams und insbesondere Rx zu kompliziert sind, um sie zu verstehen und daher zu verwenden. </p><br><p> Ich möchte, dass Sie wissen, dass ich mich nicht als Rx-Guru betrachte.  Es ist nicht einfach, all seine Kräfte zu nutzen, und ich gebe zu, dass ich weiter lerne.  Aber lassen Sie mich von Anfang an einen Fehler beheben: <strong>Sie müssen kein Rx-Assistent sein, um eine Menge Vorteile aus der Verwendung von Threads und dieser Technologie zu ziehen</strong> .  Ich werde alle Anstrengungen unternehmen, um Ihnen die Abläufe auf die am besten zugängliche Weise zu erklären. </p><a name="habracut"></a><br><h2 id="chto-takoe-potoki">  Was sind Threads? </h2><br><p>  Die beste Analogie zu Gewinden ist meiner Meinung nach das Förderband.  Sie können etwas an einem Ende anbringen und dieses „Etwas“ wird automatisch auf das andere übertragen.  Im Gegensatz zur physischen Pipeline manipulieren Threads Datenobjekte und übertragen sie automatisch von Anfang an - aber wo?  Wie in der realen Pipeline werden die Daten am anderen Ende einfach "fallen" und verschwinden, wenn sie nicht erfasst werden (dies gilt natürlich nicht ganz für Dart-Streams, aber es ist am besten, Streams so zu behandeln, als ob dies der Fall wäre). . </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/266/3a1/04f/2663a104fc0e4c1ad735881ef36fe32c.gif"></p><br><p>  Um Datenverlust zu vermeiden, können Sie einen "Trap" für die Stream-Ausgabe festlegen.  Auf diese Weise können Sie Daten erfassen und die erforderlichen Manipulationen damit durchführen, wenn Datenobjekte das Ende des Streams erreichen. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/dd3/331/b2f/dd3331b2fa9036bee28628d563f3ceb7.gif"></p><br><p>  <strong>Denken Sie daran:</strong> </p><br><ul><li>  Wenn die Falle nicht gesetzt ist, verschwinden die Daten einfach für immer und es gibt keine Möglichkeit, sie erneut abzurufen (wieder nicht genau mit Dart Streams, aber Sie tun besser so, als ob es so wäre). </li><li>  Nachdem Sie Daten an den Stream gesendet haben, müssen Sie das Programm nicht anhalten und warten, bis es das Ende erreicht hat. Dies alles geschieht im Hintergrund. </li><li>  Der Trap kann jederzeit Daten empfangen, dies ist nicht sofort nach dem Senden erforderlich (aber keine Sorge, die Streams sind tatsächlich sehr schnell).  Stellen Sie sich vor, Sie wissen nicht, wie schnell oder wie lange sich das Förderband bewegt.  Dies bedeutet, dass das Platzieren von etwas im Stream völlig unabhängig von der Reaktion auf das Element am anderen Ende ist.  Ihre Falle wird funktionieren und den Gegenstand fangen, wenn er dort ankommt.  (Einige von Ihnen stellen möglicherweise bereits fest, dass dies gut zu der reaktiven Art und Weise passt, wie Flutter seine Widgets aktualisiert.) </li><li>  Sie können eine Falle stellen, lange bevor die Arbeit beginnt und das erste Element angezeigt wird </li><li>  Der Ablauf erfolgt nach dem FIFO-Prinzip.  Die Daten kommen immer in der Reihenfolge, in der sie im Stream abgelegt werden. </li></ul><br><h2 id="a-chto-takoe-rx">  Was ist Rx? </h2><br><p>  Rx, kurz für Reactive Extensions, sind Steroidströme.  Dies ist ein Konzept, das Streams sehr ähnlich ist und vom Microsoft-Team für das .NET-Framework erfunden wurde.  Da .Net bereits den Stream-Typ hatte, der für Datei-E / A verwendet wird, haben sie die Rx-Streams <strong>Observables</strong> aufgerufen und viele Funktionen erstellt, um die durch sie fließenden Daten zu bearbeiten.  Dart hat Streams in seine Sprachspezifikation integriert, die bereits den größten Teil dieser Funktionalität bieten, jedoch nicht alle.  Aus diesem Grund wurde das RxDart-Paket entwickelt.  Es basiert auf Dart Streams, erweitert jedoch deren Funktionalität.  Ich werde Rx und RxDart im nächsten Teil dieser Serie behandeln. </p><br><h2 id="nemnogo-terminov">  Einige Begriffe </h2><br><p>  Dart Streams und Rx verwenden eine Terminologie, die beängstigend aussehen kann. Hier ist die Übersetzung.  Zuerst kommt der Begriff Dart, dann Rx. </p><br><ul><li>  <strong>Stream / Observable</strong> .  Dies ist die zuvor beschriebene "Pipeline".  Stream kann in Observable konvertiert werden. Wo immer Stream erwartet wird, können Sie Observable zuweisen.  Seien Sie also nicht verwirrt, wenn ich diese Begriffe während des Erklärungsprozesses mische </li><li>  <strong>listen / subscribe</strong> - Setzt die <strong>Listener-</strong> Falle </li><li>  <strong>StreamController / Betreff</strong> .  Die "linke" Seite des Förderbandes, auf der Sie die Daten in den Stream einfügen.  Sie unterscheiden sich geringfügig in ihren Eigenschaften und Merkmalen, dienen jedoch demselben Zweck. </li><li>  <strong>Senden eines Artikels / von Daten</strong> .  Der Moment, in dem Daten am Ausgang der "Pipeline" erscheinen </li></ul><br><h2 id="sozdanie-potoka">  Stream-Erstellung </h2><br><p>  Wenn Sie das Thema weiter studieren möchten, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">klonen Sie dieses Projekt</a> bitte mit Beispielen.  Ich werde das Dart / Flutter-Testsystem verwenden. </p><br><p>  Um einen Stream zu erstellen, erstellen Sie einen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">StreamController</a> </p><br><pre><code class="cpp hljs">var controller = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StreamController&lt;String&gt;(); controller.add(<span class="hljs-string"><span class="hljs-string">"Item1"</span></span>); <span class="hljs-comment"><span class="hljs-comment">//     </span></span></code> </pre> <br><p>  Der beim Erstellen des StreamController übergebene Vorlagentyp (in diesem Fall String) bestimmt den Objekttyp, den wir an den Stream senden können.  Es kann jeder Typ sein!  Wenn Sie möchten, können Sie einen <code>StreamController&lt;List&lt;MyObject&gt;&gt;()</code> erstellen, und der Stream überträgt das gesamte Blatt anstelle eines einzelnen Objekts. </p><br><h2 id="ustanovka-lovushki">  Trap-Einstellung </h2><br><p>  Wenn Sie den angegebenen Test ausgeführt haben, konnten Sie nichts sehen, da am Ausgang des Streams nichts unsere Zeile erfasst hat.  Stellen Sie nun die Falle: </p><br><pre> <code class="cpp hljs">var controller = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StreamController&lt;String&gt;(); controller.stream.listen((item) =&gt; print(item)); <span class="hljs-comment"><span class="hljs-comment">//  controller.add("Item1"); controller.add("Item2"); controller.add("Item3");</span></span></code> </pre> <br><p>  Jetzt wird der Trap mit der Methode <code>.listen()</code> .  Die Aufnahme sieht aus wie <code>controller.stream.listen</code> , aber wenn Sie sie rückwärts scrollen, wie eine Art Album aus den 60ern, wird die wahre Bedeutung des Geschriebenen angezeigt: "Hören Sie sich den Stream dieses Controllers an" </p><br><p>  Sie müssen eine bestimmte Funktion an die Methode <code>.listen()</code> , um die eingehenden Daten irgendwie zu manipulieren.  Die Funktion muss einen Parameter des beim Erstellen des StreamControllers angegebenen Typs akzeptieren, in diesem Fall String. </p><br><p>  Wenn Sie den obigen Code ausführen, werden Sie sehen </p><br><pre> <code class="cpp hljs">Item1 Item2 Item3</code> </pre> <br><p>  Meiner Meinung nach besteht das größte Problem für Stream-Neulinge darin, dass Sie die Reaktion für das emittierte Element bestimmen können, lange bevor das erste Element in den Stream aufgenommen wird, wodurch ein Aufruf dieser Reaktion ausgelöst wird. </p><br><h2 id="zavershenie-proslushivaniya">  Hör zu </h2><br><p>  Der obige Code hat den kleinen, aber wichtigen Teil übersehen.  <code>listen()</code> gibt ein <code>StreamSubscription</code> - ein Stream-Abonnementobjekt.  Ein Aufruf seiner <code>.cancel()</code> -Methode beendet das Abonnement, setzt Ressourcen frei und verhindert, dass Ihre Abhörfunktion aufgerufen wird, nachdem sie nicht mehr benötigt wird. </p><br><pre> <code class="cpp hljs">var controller = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StreamController&lt;String&gt;(); StreamSubscription subscription = controller.stream.listen((item) =&gt; print(item)); <span class="hljs-comment"><span class="hljs-comment">// This is the Trap controller.add("Item1"); controller.add("Item2"); controller.add("Item3"); //    ,        //  ,     Stream   await Future.delayed(Duration(milliseconds: 500)); subscription.cancel;</span></span></code> </pre> <br><h2 id="podrobnosti-o-slushatelyah">  Hörer Details </h2><br><p>  Die Funktion für <code>listen()</code> kann entweder ein Lambda oder eine einfache Funktion sein. </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">myPrint</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String message)</span></span></span><span class="hljs-function"> </span></span>{ print(message); } StreamSubscription subscription = controller.stream.listen((item) =&gt; print(item)); <span class="hljs-comment"><span class="hljs-comment">//  - StreamSubscription subscription2 = controller.stream.listen(myPrint); //    StreamSubscription subscription3 = controller.stream.listen((item) { print(item); print(item.toUpperCase); }); // -</span></span></code> </pre> <br><p>  <strong>Wichtiger Hinweis: Die meisten Dart-Streams erlauben nur ein einmaliges Abonnement, dh sie können nach Abschluss des Abonnements nicht erneut abonniert werden. Dies löst eine Ausnahme aus.</strong>  <strong>Dies ist ihr Unterschied zu anderen Rx-Implementierungen.</strong> </p><br><p>  Die vollständige Signatur von <code>listen()</code> sieht folgendermaßen aus: </p><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">/* excerpt from the API doc * The [onError] callback must be of type `void onError(error)` or * `void onError(error, StackTrace stackTrace)`. If [onError] accepts * two arguments it is called with the error object and the stack trace * (which could be `null` if the stream itself received an error without * stack trace). * Otherwise it is called with just the error object. * If [onError] is omitted, any errors on the stream are considered unhandled, * and will be passed to the current [Zone]'s error handler. * By default unhandled async errors are treated * as if they were uncaught top-level errors. * * If this stream closes and sends a done event, the [onDone] handler is * called. If [onDone] is `null`, nothing happens. * * If [cancelOnError] is true, the subscription is automatically canceled * when the first error event is delivered. The default is `false`. */</span></span> StreamSubscription&lt;T&gt; listen(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span> onData(T event), {Function onError, <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> onDone(), <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> cancelOnError});</code> </pre> <br><p>  Dies bedeutet, dass Sie mehr als nur einen Handler für die gesendeten Daten übergeben können.  Sie können auch einen Handler für Fehler und einen anderen zum Schließen des Streams vom Controller ( <code>onDone</code> ) haben.  Ausnahmen, die aus dem Stream <code>onError()</code> werden <code>onError()</code> wenn Sie es bereitstellen. <strong>Andernfalls werden sie einfach verschluckt und Sie werden nie erfahren, dass ein</strong> <code>onError()</code> <strong>.</strong> </p><br><h2 id="primer-flutter-potokov">  Beispiel für Flattergewinde </h2><br><p>  <em>Um das Verständnis der folgenden Kapitel zu erleichtern, habe ich einen separaten Repository-Zweig erstellt.</em> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Bitte klone sie</a> </p><br><p>  Als erstes Beispiel habe ich die bekannte Zähleranwendung, die Sie beim Erstellen eines neuen Flutter-Projekts erhalten, genommen und ein wenig neu organisiert.  Ich habe eine Modellklasse hinzugefügt, um den Status der Anwendung zu speichern. Dies ist im Grunde ein Zählerwert: </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Model</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> _counter = <span class="hljs-number"><span class="hljs-number">0</span></span>; StreamController _streamController = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StreamController&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;(); Stream&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; get counterUpdates =&gt; _streamController.stream; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">incrementCounter</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ _counter++; _streamController.add(_counter); } }</code> </pre> <br><p>  Hier sehen Sie eine sehr typische Vorlage: Anstatt den gesamten StreamController zu veröffentlichen, veröffentlichen wir einfach seine Stream-Eigenschaft. </p><br><p>  Um das Modell für die Benutzeroberfläche verfügbar zu machen, habe ich es zu einem statischen Feld im App-Objekt gemacht, da ich weder InheritedWidget noch ServiceLocator eingeben wollte.  Für ein einfaches Beispiel wird dies damit durchkommen, aber ich würde es in dieser Anwendung nicht tun! </p><br><p>  Zu <code>main.dart</code> : </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyHomePageState</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">State</span></span></span><span class="hljs-class">&lt;MyHomePage&gt; {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> _counter = <span class="hljs-number"><span class="hljs-number">0</span></span>; StreamSubscription streamSubscription; @<span class="hljs-function"><span class="hljs-function">override </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">initState</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ streamSubscription = MyApp.model.counterUpdates.listen((newVal) =&gt; setState(() { _counter = newVal; })); super.initState(); } <span class="hljs-comment"><span class="hljs-comment">//   State   ,   , //       @override void dispose() { streamSubscription?.cancel(); super.dispose(); }</span></span></code> </pre> <br><p>  <code>initState()</code> guter Ort, um den Listener einzustellen, und als gute Bürger von Darts veröffentlichen wir immer ein Abonnement, <code>dispose()</code> zu <code>dispose()</code> , oder? </p><br><p>  Im Widget-Baum müssen wir nur den onPressed-Handler der FAB-Schaltfläche anpassen (Schaltfläche mit schwebender Aktion). </p><br><pre> <code class="cpp hljs">floatingActionButton: <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FloatingActionButton( onPressed: MyApp.model.incrementCounter, tooltip: <span class="hljs-string"><span class="hljs-string">'Increment'</span></span>, child: <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Icon(Icons.add), ),</code> </pre> <br><p>  Auf diese Weise haben wir mithilfe von Stream eine saubere Trennung zwischen Ansicht und Modell erstellt. </p><br><h2 id="primenyaem-streambuilder">  Wenden Sie StreamBuilder an </h2><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Quelle</a> </p><br><p>  Anstatt <code>initState()</code> und <code>setState()</code> für unsere Anforderungen zu verwenden, wird Flutter mit einem praktischen <code>StreamBuilder</code> Widget <code>StreamBuilder</code> .  Wie Sie vielleicht erraten haben, sind eine Stream-Funktion und eine Konstruktormethode erforderlich, die aufgerufen werden, wenn Stream einen neuen Wert zurückgibt.  Und jetzt brauchen wir keine explizite Initialisierung und Freigabe: </p><br><pre> <code class="cpp hljs">body: <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Center( child: <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Column( mainAxisAlignment: MainAxisAlignment.center, children: &lt;Widget&gt;[ <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Text( <span class="hljs-string"><span class="hljs-string">'You have pushed the button this many times:'</span></span>, ), StreamBuilder&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;( initialData: <span class="hljs-number"><span class="hljs-number">0</span></span>, stream: MyApp.model.counterUpdates, builder: (context, snappShot) { String valueAsString = <span class="hljs-string"><span class="hljs-string">'NoData'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (snappShot != null &amp;&amp; snappShot.hasData) { valueAsString = snappShot.data.toString(); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Text( valueAsString, style: Theme.of(context).textTheme.display1, ); }), ], ), ),</code> </pre> <br><p>  Wir sind fast fertig, das verspreche ich.  Hier sind drei Dinge, die Sie wissen sollten: </p><br><ul><li>  Der große Vorteil der Verwendung von StreamBuilder gegenüber der ersten Lösung besteht darin, dass durch das Aufrufen von <code>setState()</code> in <code>listen()</code> immer die gesamte Seite neu angeordnet wird, während StreamBuilder nur den <code>builder</code> aufruft </li><li>  Die Variable <code>snapShot</code> enthält die neuesten von Stream empfangenen Daten.  Stellen Sie immer sicher, dass es gültige Daten enthält, bevor Sie es verwenden. </li><li><p>  Basierend auf den Prinzipien der Initialisierung während kann StreamBuilder im ersten Frame keinen Wert erhalten.  Um dies zu <code>initialData</code> , übergeben wir den Wert für <code>initialData</code> , der für die erste Assembly verwendet wird, <code>initialData</code> für den ersten Frame des Bildschirms.  Wenn wir <code>initialData</code> nicht übergeben, wird unser Builder zum ersten Mal mit ungültigen Daten aufgerufen.  Eine Alternative zur Verwendung von <code>initialData</code> besteht darin, ein Platzhalter-Widget zurückzugeben, wenn <code>snapShot</code> ungültig ist. <code>snapShot</code> wird angezeigt, bis wir gültige Daten erhalten, zum Beispiel: </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// ,           StreamBuilder&lt;int&gt;( stream: MyApp.model.databaseUpdates, builder: (context, snappShot) { if (snappShot != null &amp;&amp; snappShot.hasData) { return Text( snappShot.data.toString(), style: Theme.of(context).textTheme.display1, ); } //      ,   Spinner return CircularProgressIndicator (); })</span></span></code> </pre> <br></li></ul><br><p>  Im nächsten Beitrag werden wir uns ansehen, wie Daten in unseren Streams konvertiert und im laufenden Betrieb ausgeführt werden.  Vielen Dank an <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Scott Stoll</a> für das Lesen der Beweise und das wichtige Feedback. </p><br><hr></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de450950/">https://habr.com/ru/post/de450950/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de450938/index.html">Linux Install Fest 05.19 in Nischni Nowgorod 18. Mai 2019</a></li>
<li><a href="../de450940/index.html">Vivaldi 2.5 - Attraktiver Makrokosmos</a></li>
<li><a href="../de450942/index.html">Beiwagen für eine Code-Aufteilung</a></li>
<li><a href="../de450946/index.html">Festplatten-Handy auf LPC810</a></li>
<li><a href="../de450948/index.html">MU-MIMO: einer der Implementierungsalgorithmen</a></li>
<li><a href="../de450952/index.html">Mittlerer Index und Antibank</a></li>
<li><a href="../de450954/index.html">Wie wir gelernt haben, Java in Docker auszunutzen</a></li>
<li><a href="../de450956/index.html">Vergleich der industriellen COB: ISIM vs. Kics</a></li>
<li><a href="../de450958/index.html">AnyStub, Java-Verbindungsstubbibliothek</a></li>
<li><a href="../de450962/index.html">Insulinpumpen, manipulationssichere Mikrochips und softwaredefiniertes Radio</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>