<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üí≠ üèóÔ∏è ü§πüèΩ Vari√©t√©s de SIMD üòï üïö üçó</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Lors du d√©veloppement de meshoptimizer , la question se pose souvent: "Cet algorithme peut-il utiliser SIMD?" 

 La biblioth√®que est ax√©e sur les perf...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Vari√©t√©s de SIMD</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/441536/"><img src="https://habrastorage.org/getpro/habr/post_images/a9d/05e/c84/a9d05ec8466285f12b0a33e5978a0c00.png" align="left" width="270">  Lors du d√©veloppement de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">meshoptimizer</a> , la question se pose souvent: "Cet algorithme peut-il utiliser SIMD?" <br><br>  La biblioth√®que est ax√©e sur les performances, mais SIMD n'offre pas toujours des avantages de vitesse importants.  Malheureusement, SIMD peut rendre le code moins portable et moins maintenable.  Par cons√©quent, dans chaque cas, il est n√©cessaire de rechercher un compromis.  Lorsque les performances sont primordiales, vous devez d√©velopper et maintenir des impl√©mentations SIMD distinctes pour les jeux d'instructions SSE et NEON.  Dans d'autres cas, vous devez comprendre quel est l'effet de l'utilisation de SIMD.  Aujourd'hui, nous allons essayer d'acc√©l√©rer le simplificateur de maillage b√¢cl√© - un nouvel algorithme r√©cemment ajout√© √† la biblioth√®que - en utilisant les jeux d'instructions SSEn / AVXn. <br><a name="habracut"></a><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/068/8c9/887/0688c9887f9cb61c268383cb4b6621b7.jpg"></div><br><br>  Pour notre r√©f√©rence, nous simplifions le mod√®le du Bouddha tha√Ø de 6 millions de triangles √† 0,1% de ce nombre.  Nous utilisons le compilateur Microsoft Visual Studio 2019 pour l'architecture x64 cible.  L'algorithme scalaire peut effectuer une telle rationalisation en environ 210 ms dans un seul thread Intel Core i7-8700K (√† ~ 4,4 GHz).  Cela correspond √† environ 28,5 millions de triangles par seconde.  Peut-√™tre que cela suffit dans la pratique, mais j'√©tais curieux d'explorer les capacit√©s maximales de l'√©quipement. <br><br>  Dans certains cas, la proc√©dure peut √™tre parall√©lis√©e en divisant la grille en morceaux, mais pour cela, il est n√©cessaire de proc√©der √† une analyse suppl√©mentaire de la connectivit√© afin de maintenir les limites, donc pour l'instant nous nous limiterons √† des optimisations purement SIMD. <br><br><h1>  Sept mesures </h1><br>  Pour comprendre les possibilit√©s d'optimisation, nous effectuerons le profilage √† l'aide d'Intel VTune.  Ex√©cutez la proc√©dure 100 fois pour vous assurer qu'il y a suffisamment de donn√©es. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/1a7/6f0/cea/1a76f0ceaf9dc88617c5296d6ee73467.png"><br><br>  Ici, j'ai activ√© le mode microarchitecture pour fixer le temps d'ex√©cution de chaque fonction, ainsi que pour trouver des goulots d'√©tranglement.  On voit que la rationalisation se fait √† l'aide d'un ensemble de fonctions, chacune n√©cessitant un certain nombre de cycles.  La liste des fonctions est tri√©e par heure.  Les voici par ordre d'ex√©cution pour rendre l'algorithme plus facile √† comprendre: <br><br><ul><li> <code>rescalePositions</code> normalise les positions de tous les sommets dans un seul cube pour pr√©parer la quantification √† l'aide de <code>computeVertexIds</code> </li><li>  <code>computeVertexIds</code> calcule un identifiant quantifi√© de 30 bits pour chaque sommet sur une grille uniforme d'une taille donn√©e, o√π chaque axe est quantifi√© sur une grille (taille de grille 10 bits, donc l'identifiant est 30) </li><li>  <code>countTriangles</code> calcule le nombre approximatif de triangles que l'innovateur cr√©era pour une taille de grille donn√©e, en supposant l'union de tous les sommets dans une cellule de grille </li><li>  <code>fillVertexCells</code> remplit un tableau qui <code>fillVertexCells</code> tous les sommets aux cellules correspondantes;  tous les sommets avec le m√™me ID correspondent √† une cellule </li><li>  <code>fillCellQuadrics</code> remplit la structure <code>Quadric</code> (matrice sym√©trique <code>Quadric</code> ) pour chaque cellule afin de refl√©ter les informations agr√©g√©es sur la g√©om√©trie correspondante </li><li>  <code>fillCellRemap</code> calcule l'indice de sommet pour chaque cellule, en choisissant l'un des sommets de cette cellule et minimise la distorsion g√©om√©trique </li><li>  <code>filterTriangles</code> affiche l'ensemble final de triangles selon les tables sommet-cellule-sommet construites pr√©c√©demment;  la traduction na√Øve peut produire en moyenne ~ 5% de triangles en double, donc la fonction filtre les doublons. </li></ul><br>  <code>computeVertexIds</code> et <code>countTriangles</code> sont ex√©cut√©s plusieurs fois: l'algorithme d√©termine la taille du maillage pour la fusion des sommets, effectue une recherche binaire acc√©l√©r√©e pour atteindre le nombre cible de triangles (dans notre cas 6000) et calcule le nombre de triangles que chaque taille de maillage g√©n√©rera √† chaque it√©ration.  Les autres fonctions sont lanc√©es une fois.  Dans notre fichier, cinq passes de recherche donnent un maillage cible de 40 <sup>3</sup> . <br><br>  VTune signale utilement que la fonction la plus gourmande en ressources est celle qui calcule les quadriques: cela prend presque la moiti√© du temps d'ex√©cution total de 21 s.  Il s'agit du premier objectif d'optimisation de SIMD. <br><br><h1>  SIMD pi√®ce par pi√®ce </h1><br>  Jetons un coup d'≈ìil au code source de <code>fillCellQuadrics</code> pour mieux comprendre ce qu'il calcule exactement: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fillCellQuadrics</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Quadric* cell_quadrics, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">* indices, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> index_count, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Vector3* vertex_positions, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">* vertex_cells)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; index_count; i += <span class="hljs-number"><span class="hljs-number">3</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i0 = indices[i + <span class="hljs-number"><span class="hljs-number">0</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i1 = indices[i + <span class="hljs-number"><span class="hljs-number">1</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i2 = indices[i + <span class="hljs-number"><span class="hljs-number">2</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> c0 = vertex_cells[i0]; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> c1 = vertex_cells[i1]; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> c2 = vertex_cells[i2]; <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> single_cell = (c0 == c1) &amp; (c0 == c2); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> weight = single_cell ? <span class="hljs-number"><span class="hljs-number">3.f</span></span> : <span class="hljs-number"><span class="hljs-number">1.f</span></span>; Quadric Q; quadricFromTriangle(Q, vertex_positions[i0], vertex_positions[i1], vertex_positions[i2], weight); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (single_cell) { quadricAdd(cell_quadrics[c0], Q); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { quadricAdd(cell_quadrics[c0], Q); quadricAdd(cell_quadrics[c1], Q); quadricAdd(cell_quadrics[c2], Q); } } }</code> </pre> <br>  La fonction parcourt tous les triangles, calcule une quadrique pour chacun d'eux et l'ajoute aux quadriques de chaque cellule.  Quadrique - une matrice sym√©trique 4 √ó 4, pr√©sent√©e sous la forme de 10 nombres √† virgule flottante: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Quadric</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> a00; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> a10, a11; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> a20, a21, a22; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> b0, b1, b2, c; };</code> </pre> <br>  Le calcul d'une quadrique n√©cessite de r√©soudre l'√©quation plane d'un triangle, de construire une matrice quadratique et de la peser en utilisant l'aire du triangle: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">quadricFromPlane</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Quadric&amp; Q, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> a, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> b, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> c, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> d)</span></span></span><span class="hljs-function"> </span></span>{ Q.a00 = a * a; Q.a10 = b * a; Q.a11 = b * b; Q.a20 = c * a; Q.a21 = c * b; Q.a22 = c * c; Q.b0 = d * a; Q.b1 = d * b; Q.b2 = d * c; Qc = d * d; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">quadricFromTriangle</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Quadric&amp; Q, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Vector3&amp; p0, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Vector3&amp; p1, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Vector3&amp; p2, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> weight)</span></span></span><span class="hljs-function"> </span></span>{ Vector3 p10 = {p1.x - p0.x, p1.y - p0.y, p1.z - p0.z}; Vector3 p20 = {p2.x - p0.x, p2.y - p0.y, p2.z - p0.z}; Vector3 normal = { p10.y * p20.z - p10.z * p20.y, p10.z * p20.x - p10.x * p20.z, p10.x * p20.y - p10.y * p20.x }; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> area = normalize(normal); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> distance = normal.x*p0.x + normal.y*p0.y + normal.z*p0.z; quadricFromPlane(Q, normal.x, normal.y, normal.z, -distance); quadricMul(Q, area * weight); }</code> </pre> <br>  Il semble qu'il existe de nombreuses op√©rations en virgule flottante, elles peuvent donc √™tre parall√©lis√©es √† l'aide de SIMD.  Tout d'abord, nous repr√©sentons chaque vecteur comme un vecteur SIMD √† 4 larges, et modifions √©galement la structure <code>Quadric</code> √† 12 nombres √† virgule flottante au lieu de 10 afin qu'elle s'int√®gre exactement dans trois registres SIMD (l'augmentation de la taille n'affecte pas les performances) et changeons l'ordre des champs afin que les calculs <code>quadricFromPlane</code> est devenu plus uniforme: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Quadric</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> a00, a11, a22; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> pad0; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> a10, a21, a20; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> pad1; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> b0, b1, b2, c; };</code> </pre> <br>  Ici, certains calculs, en particulier le produit scalaire, ne sont pas tr√®s coh√©rents avec les versions ant√©rieures de SSE.  Heureusement, une instruction pour un produit scalaire est apparue dans SSE4.1, ce qui est tr√®s utile pour nous. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fillCellQuadrics</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Quadric* cell_quadrics, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">* indices, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> index_count, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Vector3* vertex_positions, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">* vertex_cells)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> yzx = _MM_SHUFFLE(<span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> zxy = _MM_SHUFFLE(<span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> dp_xyz = <span class="hljs-number"><span class="hljs-number">0x7f</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; index_count; i += <span class="hljs-number"><span class="hljs-number">3</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i0 = indices[i + <span class="hljs-number"><span class="hljs-number">0</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i1 = indices[i + <span class="hljs-number"><span class="hljs-number">1</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i2 = indices[i + <span class="hljs-number"><span class="hljs-number">2</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> c0 = vertex_cells[i0]; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> c1 = vertex_cells[i1]; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> c2 = vertex_cells[i2]; <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> single_cell = (c0 == c1) &amp; (c0 == c2); __m128 p0 = _mm_loadu_ps(&amp;vertex_positions[i0].x); __m128 p1 = _mm_loadu_ps(&amp;vertex_positions[i1].x); __m128 p2 = _mm_loadu_ps(&amp;vertex_positions[i2].x); __m128 p10 = _mm_sub_ps(p1, p0); __m128 p20 = _mm_sub_ps(p2, p0); __m128 normal = _mm_sub_ps( _mm_mul_ps( _mm_shuffle_ps(p10, p10, yzx), _mm_shuffle_ps(p20, p20, zxy)), _mm_mul_ps( _mm_shuffle_ps(p10, p10, zxy), _mm_shuffle_ps(p20, p20, yzx))); __m128 areasq = _mm_dp_ps(normal, normal, dp_xyz); <span class="hljs-comment"><span class="hljs-comment">// SSE4.1 __m128 area = _mm_sqrt_ps(areasq); // masks the result of the division when area==0 // scalar version does this in normalize() normal = _mm_and_ps( _mm_div_ps(normal, area), _mm_cmpneq_ps(area, _mm_setzero_ps())); __m128 distance = _mm_dp_ps(normal, p0, dp_xyz); // SSE4.1 __m128 negdistance = _mm_sub_ps(_mm_setzero_ps(), distance); __m128 normalnegdist = _mm_blend_ps(normal, negdistance, 8); __m128 Qx = _mm_mul_ps(normal, normal); __m128 Qy = _mm_mul_ps( _mm_shuffle_ps(normal, normal, _MM_SHUFFLE(3, 2, 2, 1)), _mm_shuffle_ps(normal, normal, _MM_SHUFFLE(3, 0, 1, 0))); __m128 Qz = _mm_mul_ps(negdistance, normalnegdist); if (single_cell) { area = _mm_mul_ps(area, _mm_set1_ps(3.f)); Qx = _mm_mul_ps(Qx, area); Qy = _mm_mul_ps(Qy, area); Qz = _mm_mul_ps(Qz, area); Quadric&amp; q0 = cell_quadrics[c0]; __m128 q0x = _mm_loadu_ps(&amp;q0.a00); __m128 q0y = _mm_loadu_ps(&amp;q0.a10); __m128 q0z = _mm_loadu_ps(&amp;q0.b0); _mm_storeu_ps(&amp;q0.a00, _mm_add_ps(q0x, Qx)); _mm_storeu_ps(&amp;q0.a10, _mm_add_ps(q0y, Qy)); _mm_storeu_ps(&amp;q0.b0, _mm_add_ps(q0z, Qz)); } else { // omitted for brevity, repeats the if() body // three times for c0/c1/c2 } } }</span></span></code> </pre> <br>  Il n'y a rien de particuli√®rement int√©ressant dans ce code;  nous utilisons abondamment des instructions de chargement / stockage non align√©es.  Bien que l'entr√©e de Vector3 puisse √™tre align√©e, il ne semble pas y avoir de p√©nalit√© notable pour les lectures non align√©es.  Veuillez noter que dans la premi√®re moiti√© des fonctions, les vecteurs ne sont pas utilis√©s, ce qui est bien - nos vecteurs ont trois composants, et dans certains cas un seul (voir calcul surfacesq / surface / distance), tandis que le processeur effectue 4 op√©rations en parall√®le.  Dans tous les cas, voyons comment la parall√©lisation a aid√©. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/193/b7c/4a0/193b7c4a0e52429831e1d6feb7999c6f.png"><br><br>  Une centaine de d√©marrages de <code>fillCellQuadrics</code> s'ex√©cute d√©sormais en 5,3 s au lieu de 9,8 s, ce qui permet d'√©conomiser environ 45 ms sur chaque op√©ration - pas mal, mais pas tr√®s impressionnant.  Dans de nombreuses instructions, nous utilisons trois au lieu de quatre composants, ainsi qu'une multiplication pr√©cise, ce qui donne un d√©lai assez important.  Si vous avez d√©j√† √©crit des instructions pour SIMD, vous savez comment faire correctement le produit scalaire. <br><br>  Pour ce faire, vous devez faire quatre vecteurs √† la fois.  Au lieu de stocker un vecteur complet dans un registre SIMD, nous utilisons trois registres - dans l'un, nous stockons quatre composantes de <code>x</code> , dans l'autre nous stockons <code></code> et dans le troisi√®me <code>z</code> .  Ici, quatre vecteurs sont n√©cessaires pour travailler √† la fois: cela signifie que nous traiterons quatre triangles simultan√©ment. <br><br>  Nous avons de nombreux tableaux avec indexation dynamique.  Habituellement, cela aide √† transf√©rer des donn√©es vers des tableaux pr√©par√©s de composants <code>x</code> / <code>y</code> / <code>z</code> (ou plut√¥t, g√©n√©ralement de petits registres SIMD sont utilis√©s, par exemple, <code>float x[8], y[8], z[8]</code> , pour chacun des 8 sommets en entr√©e donn√©es: cela s'appelle AoSoA (tableaux de structures de tableaux) et donne un bon √©quilibre entre la localisation du cache et la facilit√© de chargement dans les registres SIMD), mais ici l'indexation dynamique ne fonctionnera pas tr√®s bien, alors chargez les donn√©es pour quatre triangles comme d'habitude, et transposez les vecteurs en utilisant un moyen pratique macro <code>_MM_TRANSPOSE</code> . <br><br>  Th√©oriquement, vous devez calculer chaque composante de quatre quadriques finies dans son propre registre SIMD (par exemple, nous aurons <code>__m128 Q_a00</code> avec quatre composantes de <code>a00</code> quadriques finies).  Dans ce cas, les op√©rations sur les quadriques s'int√®grent assez bien dans les instructions SIMD √† 4 larges, et la conversion ralentit en fait le code - par cons√©quent, nous transposons uniquement les vecteurs initiaux, puis transposons les √©quations planes en arri√®re et ex√©cutons le m√™me code que nous avons utilis√© pour calculer les quadriques, mais r√©p√©tons-le quatre fois.  Voici le code qui calcule ensuite les √©quations de l'avion (les parties restantes sont omises par souci de concision): <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i00 = indices[(i + <span class="hljs-number"><span class="hljs-number">0</span></span>) * <span class="hljs-number"><span class="hljs-number">3</span></span> + <span class="hljs-number"><span class="hljs-number">0</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i01 = indices[(i + <span class="hljs-number"><span class="hljs-number">0</span></span>) * <span class="hljs-number"><span class="hljs-number">3</span></span> + <span class="hljs-number"><span class="hljs-number">1</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i02 = indices[(i + <span class="hljs-number"><span class="hljs-number">0</span></span>) * <span class="hljs-number"><span class="hljs-number">3</span></span> + <span class="hljs-number"><span class="hljs-number">2</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i10 = indices[(i + <span class="hljs-number"><span class="hljs-number">1</span></span>) * <span class="hljs-number"><span class="hljs-number">3</span></span> + <span class="hljs-number"><span class="hljs-number">0</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i11 = indices[(i + <span class="hljs-number"><span class="hljs-number">1</span></span>) * <span class="hljs-number"><span class="hljs-number">3</span></span> + <span class="hljs-number"><span class="hljs-number">1</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i12 = indices[(i + <span class="hljs-number"><span class="hljs-number">1</span></span>) * <span class="hljs-number"><span class="hljs-number">3</span></span> + <span class="hljs-number"><span class="hljs-number">2</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i20 = indices[(i + <span class="hljs-number"><span class="hljs-number">2</span></span>) * <span class="hljs-number"><span class="hljs-number">3</span></span> + <span class="hljs-number"><span class="hljs-number">0</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i21 = indices[(i + <span class="hljs-number"><span class="hljs-number">2</span></span>) * <span class="hljs-number"><span class="hljs-number">3</span></span> + <span class="hljs-number"><span class="hljs-number">1</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i22 = indices[(i + <span class="hljs-number"><span class="hljs-number">2</span></span>) * <span class="hljs-number"><span class="hljs-number">3</span></span> + <span class="hljs-number"><span class="hljs-number">2</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i30 = indices[(i + <span class="hljs-number"><span class="hljs-number">3</span></span>) * <span class="hljs-number"><span class="hljs-number">3</span></span> + <span class="hljs-number"><span class="hljs-number">0</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i31 = indices[(i + <span class="hljs-number"><span class="hljs-number">3</span></span>) * <span class="hljs-number"><span class="hljs-number">3</span></span> + <span class="hljs-number"><span class="hljs-number">1</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i32 = indices[(i + <span class="hljs-number"><span class="hljs-number">3</span></span>) * <span class="hljs-number"><span class="hljs-number">3</span></span> + <span class="hljs-number"><span class="hljs-number">2</span></span>]; <span class="hljs-comment"><span class="hljs-comment">// load first vertex of each triangle and transpose into vectors with components (pw0 isn't used later) __m128 px0 = _mm_loadu_ps(&amp;vertex_positions[i00].x); __m128 py0 = _mm_loadu_ps(&amp;vertex_positions[i10].x); __m128 pz0 = _mm_loadu_ps(&amp;vertex_positions[i20].x); __m128 pw0 = _mm_loadu_ps(&amp;vertex_positions[i30].x); _MM_TRANSPOSE4_PS(px0, py0, pz0, pw0); // load second vertex of each triangle and transpose into vectors with components __m128 px1 = _mm_loadu_ps(&amp;vertex_positions[i01].x); __m128 py1 = _mm_loadu_ps(&amp;vertex_positions[i11].x); __m128 pz1 = _mm_loadu_ps(&amp;vertex_positions[i21].x); __m128 pw1 = _mm_loadu_ps(&amp;vertex_positions[i31].x); _MM_TRANSPOSE4_PS(px1, py1, pz1, pw1); // load third vertex of each triangle and transpose into vectors with components __m128 px2 = _mm_loadu_ps(&amp;vertex_positions[i02].x); __m128 py2 = _mm_loadu_ps(&amp;vertex_positions[i12].x); __m128 pz2 = _mm_loadu_ps(&amp;vertex_positions[i22].x); __m128 pw2 = _mm_loadu_ps(&amp;vertex_positions[i32].x); _MM_TRANSPOSE4_PS(px2, py2, pz2, pw2); // p1 - p0 __m128 px10 = _mm_sub_ps(px1, px0); __m128 py10 = _mm_sub_ps(py1, py0); __m128 pz10 = _mm_sub_ps(pz1, pz0); // p2 - p0 __m128 px20 = _mm_sub_ps(px2, px0); __m128 py20 = _mm_sub_ps(py2, py0); __m128 pz20 = _mm_sub_ps(pz2, pz0); // cross(p10, p20) __m128 normalx = _mm_sub_ps( _mm_mul_ps(py10, pz20), _mm_mul_ps(pz10, py20)); __m128 normaly = _mm_sub_ps( _mm_mul_ps(pz10, px20), _mm_mul_ps(px10, pz20)); __m128 normalz = _mm_sub_ps( _mm_mul_ps(px10, py20), _mm_mul_ps(py10, px20)); // normalize; note that areasq/area now contain 4 values, not just one __m128 areasq = _mm_add_ps( _mm_mul_ps(normalx, normalx), _mm_add_ps( _mm_mul_ps(normaly, normaly), _mm_mul_ps(normalz, normalz))); __m128 area = _mm_sqrt_ps(areasq); __m128 areanz = _mm_cmpneq_ps(area, _mm_setzero_ps()); normalx = _mm_and_ps(_mm_div_ps(normalx, area), areanz); normaly = _mm_and_ps(_mm_div_ps(normaly, area), areanz); normalz = _mm_and_ps(_mm_div_ps(normalz, area), areanz); __m128 distance = _mm_add_ps( _mm_mul_ps(normalx, px0), _mm_add_ps( _mm_mul_ps(normaly, py0), _mm_mul_ps(normalz, pz0))); __m128 negdistance = _mm_sub_ps(_mm_setzero_ps(), distance); // this computes the plane equations (a, b, c, d) for each of the 4 triangles __m128 plane0 = normalx; __m128 plane1 = normaly; __m128 plane2 = normalz; __m128 plane3 = negdistance; _MM_TRANSPOSE4_PS(plane0, plane1, plane2, plane3);</span></span></code> </pre> <br>  Le code est devenu un peu plus long: nous traitons maintenant quatre triangles √† chaque it√©ration, et nous n'avons plus besoin d'instructions SSE4.1 pour cela.  En th√©orie, les unit√©s SIMD devraient √™tre utilis√©es plus efficacement.  Voyons comment cela a aid√©. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/2ca/735/f51/2ca735f51bf3aa28bbf7c28f50489c15.png"><br><br>  D'accord, √ßa va.  Le code a tr√®s l√©g√®rement acc√©l√©r√©, bien que la fonction <code>fillCellQuadrics</code> fonctionne d√©sormais presque deux fois plus vite que la fonction d'origine sans SIMD, mais il n'est pas clair si cela justifie une augmentation significative de la complexit√©.  Th√©oriquement, vous pouvez utiliser AVX2 et traiter 8 triangles par it√©ration, mais ici, vous devrez continuer de tourner la boucle manuellement (id√©alement, tout ce code est g√©n√©r√© √† l'aide d'ISPC, mais mes tentatives na√Øves pour le faire g√©n√©rer du bon code n'ont pas r√©ussi: au lieu de charger / stocker des s√©quences il a constamment √©mis un rassemblement / diffusion, ce qui ralentit consid√©rablement l'ex√©cution).  Essayons autre chose. <br><br><h1>  AVX2 = SSE2 + SSE2 </h1><br>  L'AVX2 est un peu un ensemble d'instructions.  Il poss√®de des registres √† virgule flottante sur 8 larges, et une instruction peut effectuer 8 op√©rations;  mais en substance, une telle instruction ne diff√®re pas de deux instructions SSE2 ex√©cut√©es sur deux moiti√©s du registre (pour autant que je sache, les premiers processeurs avec prise en charge AVX2 ont d√©cod√© chaque instruction en deux ou plusieurs micro-op√©rations, donc le gain de performances a √©t√© limit√© par la phase d'extraction des instructions).  Par exemple, <code>_mm_dp_ps</code> effectue un produit scalaire entre deux registres SSE2 et <code>_mm256_dp_ps</code> produit deux produits scalaires entre deux moiti√©s de deux registres AVX2, il est donc limit√© √† 4 larges pour chaque moiti√©. <br><br>  Pour cette raison, le code AVX2 diff√®re souvent du ¬´SIMD 8-wide¬ª universel, mais ici il fonctionne en notre faveur: au lieu d'essayer d'am√©liorer la vectorisation en transposant des vecteurs 4-wide, nous revenons √† la premi√®re version de SIMD et doublons la boucle en utilisant des instructions AVX2 au lieu de SSE2 / SSE4.  Nous devons encore charger et stocker des vecteurs de largeur 4, mais en g√©n√©ral, nous changeons simplement <code>__m128</code> en <code>__m256</code> et <code>_mm_</code> en <code>_mm256</code> dans le <code>_mm256</code> avec plusieurs param√®tres: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i00 = indices[(i + <span class="hljs-number"><span class="hljs-number">0</span></span>) * <span class="hljs-number"><span class="hljs-number">3</span></span> + <span class="hljs-number"><span class="hljs-number">0</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i01 = indices[(i + <span class="hljs-number"><span class="hljs-number">0</span></span>) * <span class="hljs-number"><span class="hljs-number">3</span></span> + <span class="hljs-number"><span class="hljs-number">1</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i02 = indices[(i + <span class="hljs-number"><span class="hljs-number">0</span></span>) * <span class="hljs-number"><span class="hljs-number">3</span></span> + <span class="hljs-number"><span class="hljs-number">2</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i10 = indices[(i + <span class="hljs-number"><span class="hljs-number">1</span></span>) * <span class="hljs-number"><span class="hljs-number">3</span></span> + <span class="hljs-number"><span class="hljs-number">0</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i11 = indices[(i + <span class="hljs-number"><span class="hljs-number">1</span></span>) * <span class="hljs-number"><span class="hljs-number">3</span></span> + <span class="hljs-number"><span class="hljs-number">1</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i12 = indices[(i + <span class="hljs-number"><span class="hljs-number">1</span></span>) * <span class="hljs-number"><span class="hljs-number">3</span></span> + <span class="hljs-number"><span class="hljs-number">2</span></span>]; __m256 p0 = _mm256_loadu2_m128( &amp;vertex_positions[i10].x, &amp;vertex_positions[i00].x); __m256 p1 = _mm256_loadu2_m128( &amp;vertex_positions[i11].x, &amp;vertex_positions[i01].x); __m256 p2 = _mm256_loadu2_m128( &amp;vertex_positions[i12].x, &amp;vertex_positions[i02].x); __m256 p10 = _mm256_sub_ps(p1, p0); __m256 p20 = _mm256_sub_ps(p2, p0); __m256 normal = _mm256_sub_ps( _mm256_mul_ps( _mm256_shuffle_ps(p10, p10, yzx), _mm256_shuffle_ps(p20, p20, zxy)), _mm256_mul_ps( _mm256_shuffle_ps(p10, p10, zxy), _mm256_shuffle_ps(p20, p20, yzx))); __m256 areasq = _mm256_dp_ps(normal, normal, dp_xyz); __m256 area = _mm256_sqrt_ps(areasq); __m256 areanz = _mm256_cmp_ps(area, _mm256_setzero_ps(), _CMP_NEQ_OQ); normal = _mm256_and_ps(_mm256_div_ps(normal, area), areanz); __m256 distance = _mm256_dp_ps(normal, p0, dp_xyz); __m256 negdistance = _mm256_sub_ps(_mm256_setzero_ps(), distance); __m256 normalnegdist = _mm256_blend_ps(normal, negdistance, <span class="hljs-number"><span class="hljs-number">0x88</span></span>); __m256 Qx = _mm256_mul_ps(normal, normal); __m256 Qy = _mm256_mul_ps( _mm256_shuffle_ps(normal, normal, _MM_SHUFFLE(<span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>)), _mm256_shuffle_ps(normal, normal, _MM_SHUFFLE(<span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>))); __m256 Qz = _mm256_mul_ps(negdistance, normalnegdist);</code> </pre> <br>  Ici, vous pouvez prendre chaque moiti√© de 128 bits des <code>Qz</code> <code>Qx</code> / <code>Qz</code> / <code>Qz</code> et ex√©cuter le m√™me code que nous avons utilis√© pour ajouter les quadriques.  Au lieu de cela, nous supposons que si un triangle a trois sommets dans une cellule ( <code>single_cell == true</code> ), il est tr√®s probable qu'un autre triangle ait trois sommets dans une autre cellule, et nous effectuons √©galement l'agr√©gation finale des quadriques en utilisant AVX2: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> c00 = vertex_cells[i00]; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> c01 = vertex_cells[i01]; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> c02 = vertex_cells[i02]; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> c10 = vertex_cells[i10]; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> c11 = vertex_cells[i11]; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> c12 = vertex_cells[i12]; <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> single_cell = (c00 == c01) &amp; (c00 == c02) &amp; (c10 == c11) &amp; (c10 == c12); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (single_cell) { area = _mm256_mul_ps(area, _mm256_set1_ps(<span class="hljs-number"><span class="hljs-number">3.f</span></span>)); Qx = _mm256_mul_ps(Qx, area); Qy = _mm256_mul_ps(Qy, area); Qz = _mm256_mul_ps(Qz, area); Quadric&amp; q00 = cell_quadrics[c00]; Quadric&amp; q10 = cell_quadrics[c10]; __m256 q0x = _mm256_loadu2_m128(&amp;q10.a00, &amp;q00.a00); __m256 q0y = _mm256_loadu2_m128(&amp;q10.a10, &amp;q00.a10); __m256 q0z = _mm256_loadu2_m128(&amp;q10.b0, &amp;q00.b0); _mm256_storeu2_m128(&amp;q10.a00, &amp;q00.a00, _mm256_add_ps(q0x, Qx)); _mm256_storeu2_m128(&amp;q10.a10, &amp;q00.a10, _mm256_add_ps(q0y, Qy)); _mm256_storeu2_m128(&amp;q10.b0, &amp;q00.b0, _mm256_add_ps(q0z, Qz)); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-comment"><span class="hljs-comment">// omitted for brevity }</span></span></code> </pre> <br>  Le code r√©sultant est plus simple, concis et plus rapide que notre approche SSE2 infructueuse: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/124/788/954/1247889540c5aab18d1f38738fb46fea.png"><br><br>  Bien s√ªr, nous n'avons pas atteint une acc√©l√©ration de 8 fois, mais seulement 2,45 fois.  Les op√©rations de chargement et de stockage sont toujours √† 4 niveaux, car nous sommes oblig√©s de travailler avec une disposition de m√©moire inconfortable en raison de l'indexation dynamique, et les calculs ne sont pas optimaux pour SIMD.  Mais maintenant <code>fillCellQuadrics</code> n'est plus le goulot d'√©tranglement dans notre pipeline de profils, et vous pouvez vous concentrer sur d'autres fonctions. <br><br><h1>  Rassemblez-vous, les enfants </h1><br>  Nous avons √©conomis√© 4,8 secondes lors du test (48 ms √† chaque test), et maintenant notre principal intrus est <code>countTriangles</code> .  Il semblerait que ce soit une fonction simple, mais elle est ex√©cut√©e non pas une fois, mais cinq fois: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> size_t </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">countTriangles</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">* vertex_ids, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">* indices, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> index_count)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> result = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; index_count; i += <span class="hljs-number"><span class="hljs-number">3</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> id0 = vertex_ids[indices[i + <span class="hljs-number"><span class="hljs-number">0</span></span>]]; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> id1 = vertex_ids[indices[i + <span class="hljs-number"><span class="hljs-number">1</span></span>]]; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> id2 = vertex_ids[indices[i + <span class="hljs-number"><span class="hljs-number">2</span></span>]]; result += (id0 != id1) &amp; (id0 != id2) &amp; (id1 != id2); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; }</code> </pre> <br>  La fonction √©num√®re tous les triangles source et calcule le nombre de triangles non d√©g√©n√©r√©s en comparant les identifiants des sommets.  Il n'est pas imm√©diatement clair comment le parall√©liser √† l'aide de SIMD ... sauf si vous utilisez les instructions de collecte. <br><br>  Le jeu d'instructions AVX2 a ajout√© une famille d'instructions de collecte / diffusion au SIMD x64;  chacun d'eux prend un registre vectoriel avec 4 ou 8 valeurs - et effectue simultan√©ment 4 ou 8 op√©rations de chargement ou de sauvegarde.  Si vous utilisez recueillir ici, vous pouvez t√©l√©charger trois index, ex√©cuter regrouper pour tous √† la fois (ou en groupes de 4 ou 8) et comparer les r√©sultats.  Rassembler sur les processeurs Intel a toujours √©t√© assez lent, mais essayons.  Par souci de simplicit√©, nous t√©l√©chargeons les donn√©es de 8 triangles, transposons les vecteurs de la m√™me mani√®re que lors de notre pr√©c√©dente tentative et comparons les √©l√©ments correspondants de chaque vecteur: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; (triangle_count &amp; ~<span class="hljs-number"><span class="hljs-number">7</span></span>); i += <span class="hljs-number"><span class="hljs-number">8</span></span>) { __m256 tri0 = _mm256_loadu2_m128( (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span>*)&amp;indices[(i + <span class="hljs-number"><span class="hljs-number">4</span></span>) * <span class="hljs-number"><span class="hljs-number">3</span></span> + <span class="hljs-number"><span class="hljs-number">0</span></span>], (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span>*)&amp;indices[(i + <span class="hljs-number"><span class="hljs-number">0</span></span>) * <span class="hljs-number"><span class="hljs-number">3</span></span> + <span class="hljs-number"><span class="hljs-number">0</span></span>]); __m256 tri1 = _mm256_loadu2_m128( (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span>*)&amp;indices[(i + <span class="hljs-number"><span class="hljs-number">5</span></span>) * <span class="hljs-number"><span class="hljs-number">3</span></span> + <span class="hljs-number"><span class="hljs-number">0</span></span>], (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span>*)&amp;indices[(i + <span class="hljs-number"><span class="hljs-number">1</span></span>) * <span class="hljs-number"><span class="hljs-number">3</span></span> + <span class="hljs-number"><span class="hljs-number">0</span></span>]); __m256 tri2 = _mm256_loadu2_m128( (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span>*)&amp;indices[(i + <span class="hljs-number"><span class="hljs-number">6</span></span>) * <span class="hljs-number"><span class="hljs-number">3</span></span> + <span class="hljs-number"><span class="hljs-number">0</span></span>], (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span>*)&amp;indices[(i + <span class="hljs-number"><span class="hljs-number">2</span></span>) * <span class="hljs-number"><span class="hljs-number">3</span></span> + <span class="hljs-number"><span class="hljs-number">0</span></span>]); __m256 tri3 = _mm256_loadu2_m128( (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span>*)&amp;indices[(i + <span class="hljs-number"><span class="hljs-number">7</span></span>) * <span class="hljs-number"><span class="hljs-number">3</span></span> + <span class="hljs-number"><span class="hljs-number">0</span></span>], (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span>*)&amp;indices[(i + <span class="hljs-number"><span class="hljs-number">3</span></span>) * <span class="hljs-number"><span class="hljs-number">3</span></span> + <span class="hljs-number"><span class="hljs-number">0</span></span>]); _MM_TRANSPOSE8_LANE4_PS(tri0, tri1, tri2, tri3); __m256i i0 = _mm256_castps_si256(tri0); __m256i i1 = _mm256_castps_si256(tri1); __m256i i2 = _mm256_castps_si256(tri2); __m256i id0 = _mm256_i32gather_epi32((<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>*)vertex_ids, i0, <span class="hljs-number"><span class="hljs-number">4</span></span>); __m256i id1 = _mm256_i32gather_epi32((<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>*)vertex_ids, i1, <span class="hljs-number"><span class="hljs-number">4</span></span>); __m256i id2 = _mm256_i32gather_epi32((<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>*)vertex_ids, i2, <span class="hljs-number"><span class="hljs-number">4</span></span>); __m256i deg = _mm256_or_si256( _mm256_cmpeq_epi32(id1, id2), _mm256_or_si256( _mm256_cmpeq_epi32(id0, id1), _mm256_cmpeq_epi32(id0, id2))); result += <span class="hljs-number"><span class="hljs-number">8</span></span> - _mm_popcnt_u32(_mm256_movemask_epi8(deg)) / <span class="hljs-number"><span class="hljs-number">4</span></span>; }</code> </pre> <br>  La macro <code>_MM_TRANSPOSE8_LANE4_PS</code> dans AVX2 est l'√©quivalent de <code>_MM_TRANSPOSE4_PS</code> , qui ne se trouve pas dans l'en-t√™te standard, mais est facilement affich√©e.  Il prend quatre vecteurs AVX2 et transpose deux matrices 4 √ó 4 ind√©pendamment l'une de l'autre: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> _MM_TRANSPOSE8_LANE4_PS(row0, row1, row2, row3) \ do { \ __m256 __t0, __t1, __t2, __t3; \ __t0 = _mm256_unpacklo_ps(row0, row1); \ __t1 = _mm256_unpackhi_ps(row0, row1); \ __t2 = _mm256_unpacklo_ps(row2, row3); \ __t3 = _mm256_unpackhi_ps(row2, row3); \ row0 = _mm256_shuffle_ps(__t0, __t2, _MM_SHUFFLE(1, 0, 1, 0)); \ row1 = _mm256_shuffle_ps(__t0, __t2, _MM_SHUFFLE(3, 2, 3, 2)); \ row2 = _mm256_shuffle_ps(__t1, __t3, _MM_SHUFFLE(1, 0, 1, 0)); \ row3 = _mm256_shuffle_ps(__t1, __t3, _MM_SHUFFLE(3, 2, 3, 2)); \ } while (0)</span></span></code> </pre> <br>  En raison de certaines fonctionnalit√©s des jeux d'instructions SSE2 / AVX2, nous devons utiliser des op√©rations de registre √† virgule flottante lors de la transposition de vecteurs.  Nous chargeons les donn√©es un peu n√©gligemment;  mais cela n'a pas d'importance, car les performances de collecte nous limitent: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/1ef/602/0e0/1ef6020e0d5b0c4bbf962335d77c653a.png"><br><br>  Maintenant, <code>countTriangles</code> est environ 27% plus rapide et remarque le terrible CPI (cycles par instruction): nous envoyons environ quatre fois moins d'instructions, mais rassembler prend beaucoup de temps.  C'est g√©nial que cela acc√©l√®re le travail global, mais, bien s√ªr, le gain de performances est quelque peu d√©primant.  Nous avons r√©ussi √† d√©passer <code>fillCellQuadrics</code> dans le profil, ce qui nous am√®ne √† la derni√®re fonction en haut de la liste, que nous n'avons pas encore examin√©e. <br><br><h1>  Chapitre 6, o√π tout commence √† fonctionner comme il se doit </h1><br>  La derni√®re fonction est <code>computeVertexIds</code> .  Dans l'algorithme, il est effectu√© 6 fois, il repr√©sente donc √©galement un excellent objectif d'optimisation.  Pour la premi√®re fois, nous voyons une fonction qui semble √™tre cr√©√©e pour une optimisation claire dans SIMD: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">computeVertexIds</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">* vertex_ids, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Vector3* vertex_positions, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> vertex_count, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> grid_size)</span></span></span><span class="hljs-function"> </span></span>{ assert(grid_size &gt;= <span class="hljs-number"><span class="hljs-number">1</span></span> &amp;&amp; grid_size &lt;= <span class="hljs-number"><span class="hljs-number">1024</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> cell_scale = <span class="hljs-keyword"><span class="hljs-keyword">float</span></span>(grid_size - <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; vertex_count; ++i) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Vector3&amp; v = vertex_positions[i]; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> xi = <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>(vx * cell_scale + <span class="hljs-number"><span class="hljs-number">0.5f</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> yi = <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>(vy * cell_scale + <span class="hljs-number"><span class="hljs-number">0.5f</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> zi = <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>(vz * cell_scale + <span class="hljs-number"><span class="hljs-number">0.5f</span></span>); vertex_ids[i] = (xi &lt;&lt; <span class="hljs-number"><span class="hljs-number">20</span></span>) | (yi &lt;&lt; <span class="hljs-number"><span class="hljs-number">10</span></span>) | zi; } }</code> </pre> <br>  Apr√®s les optimisations pr√©c√©dentes, nous savons quoi faire: d√©rouler le cycle 4 ou 8 fois, car il ne sert √† rien d'acc√©l√©rer une seule it√©ration, de transposer les composantes vectorielles et d'ex√©cuter les calculs en parall√®le.  Faisons-le avec AVX2, en traitant 8 sommets √† la fois: <br><br><pre> <code class="cpp hljs">__m256 scale = _mm256_set1_ps(cell_scale); __m256 half = _mm256_set1_ps(<span class="hljs-number"><span class="hljs-number">0.5f</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; (vertex_count &amp; ~<span class="hljs-number"><span class="hljs-number">7</span></span>); i += <span class="hljs-number"><span class="hljs-number">8</span></span>) { __m256 vx = _mm256_loadu2_m128( &amp;vertex_positions[i + <span class="hljs-number"><span class="hljs-number">4</span></span>].x, &amp;vertex_positions[i + <span class="hljs-number"><span class="hljs-number">0</span></span>].x); __m256 vy = _mm256_loadu2_m128( &amp;vertex_positions[i + <span class="hljs-number"><span class="hljs-number">5</span></span>].x, &amp;vertex_positions[i + <span class="hljs-number"><span class="hljs-number">1</span></span>].x); __m256 vz = _mm256_loadu2_m128( &amp;vertex_positions[i + <span class="hljs-number"><span class="hljs-number">6</span></span>].x, &amp;vertex_positions[i + <span class="hljs-number"><span class="hljs-number">2</span></span>].x); __m256 vw = _mm256_loadu2_m128( &amp;vertex_positions[i + <span class="hljs-number"><span class="hljs-number">7</span></span>].x, &amp;vertex_positions[i + <span class="hljs-number"><span class="hljs-number">3</span></span>].x); _MM_TRANSPOSE8_LANE4_PS(vx, vy, vz, vw); __m256i xi = _mm256_cvttps_epi32( _mm256_add_ps(_mm256_mul_ps(vx, scale), half)); __m256i yi = _mm256_cvttps_epi32( _mm256_add_ps(_mm256_mul_ps(vy, scale), half)); __m256i zi = _mm256_cvttps_epi32( _mm256_add_ps(_mm256_mul_ps(vz, scale), half)); __m256i id = _mm256_or_si256( zi, _mm256_or_si256( _mm256_slli_epi32(xi, <span class="hljs-number"><span class="hljs-number">20</span></span>), _mm256_slli_epi32(yi, <span class="hljs-number"><span class="hljs-number">10</span></span>))); _mm256_storeu_si256((__m256i*)&amp;vertex_ids[i], id); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Et regardez les r√©sultats: </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/895/365/9c9/8953659c9ee67385751dae656e244dbb.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nous avons acc√©l√©r√© </font></font><code>computeVertexIds</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">deux fois. Compte tenu de toutes les optimisations, le temps total d'ex√©cution du programme a √©t√© r√©duit √† environ 120 ms, ce qui correspond au calcul de 50 millions de triangles par seconde. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Il peut sembler que nous n'ayons pas encore atteint la croissance de productivit√© attendue: </font></font><code>computeVertexIds</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ne </font><font style="vertical-align: inherit;">devrait- </font><font style="vertical-align: inherit;">elle pas acc√©l√©rer plus de deux fois apr√®s la parall√©lisation? Pour r√©pondre √† cette question, essayons de voir combien de travail cette fonction effectue. </font></font><br><br> <code>computeVertexIds</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Il est ex√©cut√© six fois pour un d√©marrage de programme: cinq fois pendant la recherche binaire et une fois √† la fin pour calculer les identifiants finaux qui sont utilis√©s pour un traitement ult√©rieur. Chaque fois, cette fonction traite 3 millions de sommets, lisant 12 octets pour chaque sommet et √©crivant 4 octets.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Au total, sur plus de 100 ex√©cutions de l'innovateur, cette fonction traite 1,8 milliard de sommets, lisant 21 Go et r√©√©crivant 7 Go. </font><font style="vertical-align: inherit;">Le traitement de 28 Go en 1,46 seconde n√©cessite une bande passante de bus de 19 Go / s. </font><font style="vertical-align: inherit;">Nous pouvons v√©rifier la bande passante m√©moire en ex√©cutant </font></font><code>memcmp(block1, block2, 512 MB)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Le r√©sultat est de 45 ms, soit environ 22 Go / s sur un seul c≈ìur (bien que la r√©f√©rence AIDA64 montre des vitesses de lecture sur mon syst√®me jusqu'√† 31 Go / s, mais il utilise plusieurs c≈ìurs). </font><font style="vertical-align: inherit;">En fait, nous nous sommes approch√©s de la limite de m√©moire maximale r√©alisable, et une nouvelle augmentation des performances n√©cessitera un compactage plus √©troit de ces sommets afin qu'ils occupent moins de 12 octets.</font></font><br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Conclusion </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous avons pris un algorithme assez bien optimis√© qui simplifie les tr√®s grandes grilles √† une vitesse de 28 millions de triangles par seconde, et avons utilis√© les jeux d'instructions SSE et AVX pour l'acc√©l√©rer presque deux fois, √† 50 millions de triangles par seconde. Au cours de ce voyage, nous avons d√ª apprendre diff√©rentes fa√ßons d'utiliser SIMD: registres pour stocker des vecteurs √† 3 larges, SoA transpose, instructions AVX2 pour stocker deux vecteurs √† 3 larges, rassembler des instructions pour acc√©l√©rer le chargement des donn√©es par rapport aux instructions scalaires, et enfin nous avons directement appliqu√© AVX2 pour le traitement en streaming.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SIMD n'est souvent pas le meilleur point de d√©part pour l'optimisation: le rationaliseur de maillage a travers√© de nombreuses it√©rations d'optimisation algorithmique et de microoptimisation sans utiliser d'instructions sp√©cifiques √† la plate-forme. Mais √† un moment donn√©, ces possibilit√©s sont √©puis√©es, et si les performances sont critiques, alors SIMD est un outil fantastique qui peut √™tre utilis√© si n√©cessaire. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Je ne sais pas laquelle de ces optimisations tombera dans la branche principale </font></font><code>meshoptimizer</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">: au final, ce n'est qu'une exp√©rience pour voir combien le code est overclock√© sans changement fondamental dans les algorithmes. J'esp√®re que l'article s'est av√©r√© √™tre informatif et vous donnera des id√©es pour optimiser le code. Les sources finales de cet article </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sont ici</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ; ce travail est bas√© sur la version de </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">meshoptimizer 99ab49</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et le mod√®le Thai Buddha est publi√© </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sur Sketchfab</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr441536/">https://habr.com/ru/post/fr441536/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr441526/index.html">Facteurs de la valeur du Bitcoin</a></li>
<li><a href="../fr441528/index.html">Comment ma vie s'est transform√©e en livre de Kafka</a></li>
<li><a href="../fr441530/index.html">SDN sera lanc√© dans l'espace: pourquoi est-ce n√©cessaire</a></li>
<li><a href="../fr441532/index.html">Batfish Pr√©sentation</a></li>
<li><a href="../fr441534/index.html">√âquilibreurs de charge pour les syst√®mes d'orchestration</a></li>
<li><a href="../fr441538/index.html">Architecture d'entrep√¥t de donn√©es: traditionnelle et cloud</a></li>
<li><a href="../fr441540/index.html">Vue mixins, la mani√®re explicite (par un exemple de plugin BEM modifiers)</a></li>
<li><a href="../fr441546/index.html">Hayabusa-2 "a d'abord touch√© l'ast√©ro√Øde</a></li>
<li><a href="../fr441550/index.html">La vie d'un simple programmeur est dure et simple</a></li>
<li><a href="../fr441554/index.html">Toute l'histoire de Linux. Partie I: comment tout a commenc√©</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>