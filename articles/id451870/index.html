<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ›¸ ğŸ˜‘ ğŸ†• Fitur C ++ modern yang perlu diketahui oleh semua programmer ğŸ‘­ ğŸš¶ğŸ¼ ğŸ‘©ğŸ»â€ğŸ¤â€ğŸ‘¨ğŸ½</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Penulis materi, terjemahan yang kami terbitkan hari ini, mengatakan bahwa C ++, dalam bentuk modernnya, jika dibandingkan dengan apa yang beberapa tah...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Fitur C ++ modern yang perlu diketahui oleh semua programmer</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/451870/">  Penulis materi, terjemahan yang kami terbitkan hari ini, mengatakan bahwa C ++, dalam bentuk modernnya, jika dibandingkan dengan apa yang beberapa tahun lalu, telah berubah secara signifikan menjadi lebih baik.  Tentu saja, perubahan ini tidak terjadi segera.  Misalnya, di masa lalu, C ++ tidak memiliki dinamisme.  Tidak mudah menemukan seseorang yang dapat mengatakan bahwa ia memiliki perasaan yang lembut terhadap bahasa ini.  Semuanya berubah ketika mereka yang bertanggung jawab untuk membakukan bahasa memutuskan untuk memberikan jalan kepada inovasi.  Pada tahun 2011, C ++ menjadi bahasa yang dinamis, bahasa yang terus berkembang dan menyebabkan programmer lebih banyak emosi positif. <br><br>  Jangan berpikir bahwa bahasa menjadi lebih mudah.  Itu masih bisa disebut salah satu bahasa pemrograman yang paling kompleks digunakan, jika bukan yang paling kompleks.  Tapi C ++ modern telah menjadi jauh lebih ramah dari sebelumnya. <br><br><img src="https://habrastorage.org/webt/qk/ii/cx/qkiicxclyr6agfsxlcplndrkpd8.jpeg"><br><br>  Hari ini kita akan berbicara tentang beberapa fitur baru bahasa (dimulai dengan C ++ 11, yang, sudah, sudah berusia 8 tahun), yang akan diketahui oleh programmer mana pun. <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">Kata kunci otomatis</font> </h2><br>  Sejak kata kunci <code>auto</code> muncul di C ++ 11, kehidupan programmer menjadi lebih mudah.  Berkat kata kunci ini, kompiler dapat menampilkan tipe variabel pada waktu kompilasi, yang menyelamatkan kita dari selalu harus menentukan jenis sendiri.  Ini ternyata sangat nyaman, misalnya, dalam kasus di mana Anda harus bekerja dengan tipe data seperti <code>map&lt;string,vector&lt;pair&lt;int,int&gt;&gt;&gt;</code> .  Saat menggunakan kata kunci <code>auto</code> , ada beberapa hal yang perlu dipertimbangkan.  Pertimbangkan sebuah contoh: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> an_int = <span class="hljs-number"><span class="hljs-number">26</span></span>; <span class="hljs-comment"><span class="hljs-comment">//    ,     - int auto a_bool = false; //   bool auto a_float = 26.04; //   float auto ptr = &amp;a_float; //       auto data; // #1     ?    - .</span></span></code> </pre> <br>  Perhatikan baris terakhir dalam contoh ini, komentar yang ditandai sebagai <code>#1</code> (selanjutnya, dengan cara yang sama kita akan menandai baris yang akan kita uraikan setelah contoh).  Tidak ada penginisialisasi di baris ini, Anda tidak bisa melakukan ini.  Kode yang terletak pada baris ini mencegah kompiler mengetahui jenis variabel yang sesuai. <br><br>  Awalnya, kata kunci <code>auto</code> dalam C ++ cukup terbatas.  Kemudian, dalam versi bahasa yang lebih baru, fitur yang ditambahkan secara <code>auto</code> .  Ini adalah contoh lain: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">auto</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">merge</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">auto</span></span></span></span><span class="hljs-function"><span class="hljs-params"> a, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">auto</span></span></span></span><span class="hljs-function"><span class="hljs-params"> b)</span></span></span><span class="hljs-function"> </span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-comment">//            auto! {   std::vector&lt;int&gt; c = do_something(a, b);   return c; } std::vector&lt;int&gt; a = { ... }; // #1 -  std::vector&lt;int&gt; b = { ... }; // #2  -  auto c = merge(a,b); //      </span></span></span></span></code> </pre> <br>  Baris <code>#1</code> dan <code>#2</code> menggunakan inisialisasi variabel menggunakan kurung kurawal - fitur baru lainnya di C ++ 11. <br><br>  Ingatlah bahwa ketika menggunakan kata kunci <code>auto</code> , kompiler harus memiliki beberapa cara untuk menyimpulkan jenis variabel. <br><br>  Sekarang, pertanyaan yang menarik.  Apa yang terjadi jika Anda menggunakan desain seperti <code>auto a = {1, 2, 3}</code> ?  Apa ini  Vektor, atau penyebab kesalahan kompilasi? <br><br>  Bahkan, konstruksi bentuk <code>std::initializer_list&lt;type&gt;</code> muncul di C ++ 11.  Daftar nilai inisialisasi yang di dalam tanda kurung akan diperlakukan sebagai wadah menggunakan kata kunci <code>auto</code> . <br><br>  Dan akhirnya, seperti yang telah disebutkan, ketik inferensi oleh kompiler dapat sangat berguna jika Anda harus bekerja dengan struktur data yang kompleks.  Berikut ini sebuah contoh: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">populate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">auto</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp;data)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//    !   data.insert({"a",{1,4}});   data.insert({"b",{3,1}});   data.insert({"c",{2,3}}); } auto merge(auto data, auto upcoming_data) { //         auto result = data;   for(auto it: upcoming_data) {       result.insert(it);   }   return result; } int main() {   std::map&lt;std::string, std::pair&lt;int,int&gt;&gt; data;   populate(data);   std::map&lt;std::string, std::pair&lt;int,int&gt;&gt; upcoming_data;   upcoming_data.insert({"d",{5,3}});   auto final_data = merge(data,upcoming_data);   for(auto itr: final_data) {       auto [v1, v2] = itr.second; // #1               std::cout &lt;&lt; itr.first &lt;&lt; " " &lt;&lt; v1 &lt;&lt; " " &lt;&lt; v2 &lt;&lt; std:endl;   }   return 0; }</span></span></code> </pre> <br>  Lihatlah baris <code>#1</code> .  Ekspresi <code>auto [v1,v2] = itr.second</code> mewakili fitur baru C ++ 17. Ini adalah apa yang disebut dekomposisi ketika mendeklarasikan variabel.  Dalam versi bahasa sebelumnya, setiap nilai harus diekstraksi secara terpisah.  Berkat mekanisme ini, melakukan operasi seperti itu menjadi jauh lebih nyaman. <br><br>  Selain itu, jika Anda perlu bekerja dengan data menggunakan tautan, cukup menambahkan hanya satu karakter ke konstruksi ini, mengonversinya ke bentuk berikut: <code>auto &amp;[v1,v2] = itr.second</code> . <br><br><h2>  <font color="#3AC1EF">Ekspresi Lambda</font> </h2><br>  C ++ 11 memperkenalkan dukungan untuk ekspresi lambda.  Mereka menyerupai fungsi anonim dalam JavaScript, mereka dapat dibandingkan dengan objek fungsional tanpa nama.  Mereka menangkap variabel dalam berbagai lingkup tergantung pada deskripsi mereka, yang konstruksi sintaksis kompak digunakan.  Selain itu, mereka dapat ditugaskan ke variabel. <br><br>  Ekspresi Lambda adalah alat yang sangat berguna untuk kasus-kasus ketika Anda perlu melakukan beberapa operasi kecil dalam kode, tetapi Anda tidak ingin menulis fungsi terpisah untuk ini.  Contoh umum lain dari penggunaannya adalah penciptaan fungsi yang digunakan dalam membandingkan nilai.  Sebagai contoh: <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::pair&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>,<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;&gt; data = {{<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>}, {<span class="hljs-number"><span class="hljs-number">7</span></span>,<span class="hljs-number"><span class="hljs-number">6</span></span>}, {<span class="hljs-number"><span class="hljs-number">12</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>}}; <span class="hljs-comment"><span class="hljs-comment">//        std::sort(begin(data), end(data), [](auto a, auto b) { //   - auto!   return a.second &lt; b.second; });</span></span></code> </pre> <br>  Anda dapat menemukan banyak hal menarik dalam contoh singkat ini. <br><br>  Pertama, perhatikan betapa nyamannya menggunakan inisialisasi variabel menggunakan kurung kurawal.  Selanjutnya, kita dapat melihat konstruksi standar <code>begin()</code> dan <code>end()</code> , yang juga muncul dalam C ++ 11. Kemudian muncul fungsi lambda, yang digunakan sebagai mekanisme untuk membandingkan data.  Parameter fungsi ini dideklarasikan menggunakan kata kunci <code>auto</code> , fitur ini muncul di C ++ 14. Sebelumnya, kata kunci ini tidak dapat digunakan untuk menggambarkan parameter fungsi. <br><br>  Sekarang perhatikan bahwa ekspresi lambda dimulai dengan tanda kurung siku - <code>[]</code> .  Inilah yang disebut topeng variabel.  Ini menentukan ruang lingkup ekspresi, yaitu, memungkinkan Anda untuk mengontrol hubungan ekspresi lambda dengan variabel dan objek lokal. <br><br>  Berikut adalah kutipan dari repositori yang didedikasikan untuk fitur C ++ modern ini: <br><br><ul><li>  <code>[]</code> - ekspresi tidak menangkap apa pun.  Ini berarti bahwa dalam ekspresi lambda tidak mungkin untuk menggunakan variabel lokal dari ruang lingkup yang eksternal untuk itu.  Hanya parameter yang dapat digunakan dalam ekspresi. </li><li>  <code>[=]</code> - ekspresi menangkap nilai objek lokal (yaitu, variabel lokal, parameter).  Ini berarti bahwa mereka dapat digunakan, tetapi tidak dimodifikasi. </li><li>  <code>[&amp;]</code> - ekspresi menangkap referensi ke objek lokal.  Mereka dapat dimodifikasi, seperti yang ditunjukkan pada contoh berikut. </li><li>  <code>[this]</code> - ekspresi menangkap nilai dari pointer <code>this</code> . </li><li>  <code>[a, &amp;b]</code> - ekspresi menangkap nilai objek <code>a</code> dan referensi ke objek <code>b</code> . </li></ul><br>  Akibatnya, jika di dalam fungsi lambda Anda perlu mengkonversi data ke beberapa format lain, Anda dapat menggunakan mekanisme di atas.  Pertimbangkan sebuah contoh: <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; data = {<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">9</span></span>}; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> factor = <span class="hljs-number"><span class="hljs-number">7</span></span>; for_each(begin(data), end(data), [&amp;factor](<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> &amp;val) { <span class="hljs-comment"><span class="hljs-comment">//    factor     val = val * factor;   factor--; // #1   - ,  -    factor   }); for(int val: data) {   std::cout &lt;&lt; val &lt;&lt; ' '; // 14 24 20 4 3 6 9 }</span></span></code> </pre> <br>  Di sini, jika variabel <code>factor</code> diakses oleh nilai (maka variabel mask <code>[factor]</code> akan digunakan untuk menggambarkan ekspresi lambda), maka di baris <code>#1</code> nilai <code>factor</code> tidak dapat diubah - hanya karena kita tidak akan memiliki hak untuk melakukan operasi seperti itu.  Dalam contoh ini, kami memiliki hak untuk melakukan tindakan tersebut.  Dalam situasi seperti itu, penting untuk tidak menyalahgunakan kemampuan yang diakses oleh referensi variabel. <br><br>  Selain itu, perhatikan bahwa <code>val</code> juga diakses dengan referensi.  Ini memastikan bahwa perubahan data yang terjadi pada fungsi lambda memengaruhi <code>vector</code> . <br><br><h2>  <font color="#3AC1EF">Ekspresi inisialisasi variabel di dalam if dan switch constructs</font> </h2><br>  Saya sangat menyukai inovasi C ++ 17 ini setelah saya mengetahuinya.  Pertimbangkan sebuah contoh: <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">set</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; input = {<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>}; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> it = input.find(<span class="hljs-number"><span class="hljs-number">7</span></span>); it==input.end()){ <span class="hljs-comment"><span class="hljs-comment">//   - ,  -    std::cout &lt;&lt; 7 &lt;&lt; " not found" &lt;&lt; std:endl; } else {   //    else      it   std::cout &lt;&lt; 7 &lt;&lt; " is there!" &lt;&lt; std::endl; }</span></span></code> </pre> <br>  Ternyata sekarang Anda dapat menginisialisasi variabel dan membandingkannya dengan penggunaannya dalam satu <code>if</code> atau <code>switch</code> blok.  Ini membantu menulis kode yang akurat.  Berikut ini adalah deskripsi skematis dari struktur yang sedang dipertimbangkan: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( init-statement(x); condition(x)) {   <span class="hljs-comment"><span class="hljs-comment">//    } else {   //     x   //    }</span></span></code> </pre> <br><h2>  <font color="#3AC1EF">Melakukan perhitungan waktu kompilasi menggunakan constexpr</font> </h2><br>  <code>constexpr</code> memberi kita peluang besar.  Misalkan kita memiliki semacam ekspresi yang perlu dihitung, sedangkan nilainya, setelah menginisialisasi dengan variabel yang sesuai, tidak akan berubah.  Ungkapan seperti itu dapat dihitung di muka dan digunakan sebagai makro.  Atau, apa yang menjadi mungkin di C ++ 11, gunakan <code>constexpr</code> . <br><br>  Programmer berusaha untuk meminimalkan jumlah perhitungan yang dilakukan selama eksekusi program.  Akibatnya, jika operasi tertentu dapat dilakukan selama proses kompilasi dan dengan demikian menghapus beban dari sistem selama eksekusi program, ini akan memiliki efek yang baik pada perilaku program selama eksekusi.  Berikut ini sebuah contoh: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;iostream&gt; constexpr long long fact(long long n) { //       constexpr return n == 1 ? 1 : (fact(n-1) * n); } int main() { const long long bigval = fact(20); std::cout&lt;&lt;bigval&lt;&lt;std::endl; }</span></span></span></span></code> </pre> <br>  Ini adalah contoh yang sangat umum menggunakan <code>constexpr</code> . <br><br>  Karena kami mendeklarasikan fungsi untuk menghitung faktorial sebagai <code>constexpr</code> , kompiler dapat melakukan pra-perhitungan nilai <code>fact(20)</code> pada saat kompilasi program.  Akibatnya, setelah dikompilasi, string <code>const long long bigval = fact(20);</code>  dapat diganti dengan <code>const long long bigval = 2432902008176640000;</code>  . <br><br>  Perhatikan bahwa argumen yang diteruskan ke fungsi diwakili oleh konstanta.  Ini adalah fitur penting menggunakan fungsi yang dideklarasikan menggunakan <code>constexpr</code> .  Argumen yang disampaikan kepada mereka juga harus dideklarasikan dengan <code>constexpr</code> atau dengan kata kunci <code>const</code> .  Jika tidak, fungsi tersebut akan berperilaku seperti fungsi biasa, yaitu, selama kompilasi, nilainya tidak akan dihitung sebelumnya. <br><br>  Variabel juga dapat dideklarasikan menggunakan <code>constexpr</code> .  Dalam hal ini, seperti yang Anda duga, nilai-nilai variabel ini harus dihitung pada waktu kompilasi.  Jika ini tidak dapat dilakukan, pesan kesalahan kompilasi akan ditampilkan. <br><br>  Sangat menarik untuk dicatat bahwa kemudian, dalam C ++ 17, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">konstruksi constexpr-if</a> dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">constexpr-lambda</a> muncul. <br><br><h2>  <font color="#3AC1EF">Struktur data Tuple</font> </h2><br>  Seperti struktur data <code>pair</code> , struktur data <code>tuple</code> (tuple) adalah kumpulan nilai dari berbagai jenis ukuran tetap.  Berikut ini sebuah contoh: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> user_info = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::make_tuple(<span class="hljs-string"><span class="hljs-string">"M"</span></span>, <span class="hljs-string"><span class="hljs-string">"Chowdhury"</span></span>, <span class="hljs-number"><span class="hljs-number">25</span></span>); <span class="hljs-comment"><span class="hljs-comment">//  auto     //    std::get&lt;0&gt;(user_info); std::get&lt;1&gt;(user_info); std::get&lt;2&gt;(user_info); //  C++ 11     tie std::string first_name, last_name, age; std::tie(first_name, last_name, age) = user_info; //  C++ 17, ,       auto [first_name, last_name, age] = user_info;</span></span></code> </pre> <br>  Terkadang, alih-alih struktur data <code>tuple</code> , lebih nyaman menggunakan <code>std::array</code> .  Struktur data ini mirip dengan array sederhana yang digunakan dalam bahasa C, dilengkapi dengan fitur tambahan dari pustaka standar C ++.  Struktur data ini muncul di C ++ 11. <br><br><h2>  <font color="#3AC1EF">Secara otomatis menyimpulkan tipe argumen templat kelas</font> </h2><br>  Nama fitur ini terlihat agak panjang dan kompleks, tetapi sebenarnya tidak ada yang rumit di sini.  Gagasan utama di sini adalah bahwa dalam C ++ 17, output dari tipe argumen template juga dilakukan untuk templat kelas standar.  Sebelumnya, ini hanya didukung untuk templat fungsional.  Alhasil, ternyata mereka biasa menulis seperti ini: <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::pair&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; user = {<span class="hljs-string"><span class="hljs-string">"M"</span></span>, <span class="hljs-number"><span class="hljs-number">25</span></span>};</code> </pre> <br>  Dengan rilis C ++ 17, konstruksi ini sekarang dapat diganti dengan ini: <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::pair user = {<span class="hljs-string"><span class="hljs-string">"M"</span></span>, <span class="hljs-number"><span class="hljs-number">25</span></span>};</code> </pre> <br>  Jenis inferensi dilakukan secara implisit.  Mekanisme ini bahkan lebih nyaman digunakan untuk tupel.  Yaitu, sebelum saya harus menulis yang berikut: <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::tuple&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; user (<span class="hljs-string"><span class="hljs-string">"M"</span></span>, <span class="hljs-string"><span class="hljs-string">"Chy"</span></span>, <span class="hljs-number"><span class="hljs-number">25</span></span>);</code> </pre> <br>  Sekarang hal yang sama terlihat seperti ini: <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-function"><span class="hljs-function">tuple </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">user2</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"M"</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"Chy"</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">25</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>;</code> </pre> <br>  Perlu dicatat bahwa fitur-fitur ini tidak akan terlihat menarik bagi mereka yang tidak terlalu mengenal template C ++. <br><br><h2>  <font color="#3AC1EF">Pointer pintar</font> </h2><br>  Bekerja dengan pointer di C ++ bisa menjadi mimpi buruk yang nyata.  Berkat kebebasan yang diberikan oleh bahasa kepada programmer, kadang-kadang sangat sulit baginya, seperti yang mereka katakan, "untuk tidak menembak diri sendiri."  Dalam banyak kasus, pointer mendorong "tembakan" programmer. <br><br>  Untungnya, C ++ 11 memperkenalkan pointer pintar yang jauh lebih nyaman daripada pointer biasa.  Mereka membantu programmer menghindari kebocoran memori dengan membebaskan sumber daya bila memungkinkan.  Selain itu, mereka memberikan jaminan keamanan untuk pengecualian. <br><br><h2>  <font color="#3AC1EF">Ringkasan</font> </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Berikut adalah</a> repositori yang baik, yang kami percaya, akan menarik untuk dikunjungi oleh mereka yang mengikuti inovasi C ++.  Sesuatu yang baru terus muncul dalam bahasa ini.  Di sini kami menyentuh hanya beberapa fitur modern bahasa.  Padahal, ada banyak dari mereka.  Mungkin saja kita masih membicarakannya. <br><br>  <b>Pembaca yang budiman!</b>  Apa fitur C ++ modern yang menurut Anda paling menarik dan berguna? <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id451870/">https://habr.com/ru/post/id451870/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id451858/index.html">Membuat Circuit Breaker berbasis cache sederhana di Spring</a></li>
<li><a href="../id451860/index.html">Matematikawan telah menemukan cara sempurna untuk melipatgandakan angka</a></li>
<li><a href="../id451862/index.html">Musikal Petir Joe Diprim: Insinyur otodidak membuat gulungan Tesla untuk hiburan dan penghasilan</a></li>
<li><a href="../id451864/index.html">Kerentanan RCE kritis tingkat EternalBlue terdeteksi di OS Windows</a></li>
<li><a href="../id451866/index.html">Pilih node terdekat di jaringan</a></li>
<li><a href="../id451872/index.html">Python adalah asisten dalam mencari penerbangan murah bagi mereka yang suka bepergian</a></li>
<li><a href="../id451874/index.html">Tren SEO Teratas di Google</a></li>
<li><a href="../id451876/index.html">Pusat data Frankfurt: Pusat data Telehouse</a></li>
<li><a href="../id451878/index.html">Streaming langsung video stereo ke kacamata VR (Oculus Go)</a></li>
<li><a href="../id451880/index.html">DevPRO'19: pemandangan dari bilik Wrike</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>