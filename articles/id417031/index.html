<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨🏽‍🏭 🚦 👩🏼‍🚒 Mobile OAuth 2.0 Security 🤸 🏩 ◽️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Halo semuanya! Saya Nikita Stupin, Spesialis Keamanan Informasi, Mail.Ru Mail. Belum lama ini, saya melakukan penelitian kerentanan pada ponsel OAuth ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Mobile OAuth 2.0 Security</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/mailru/blog/417031/"><img src="https://habrastorage.org/getpro/habr/post_images/205/605/cd5/205605cd5b166f65aa8085fe1606779f.jpg"><br><br>  Halo semuanya!  Saya Nikita Stupin, Spesialis Keamanan Informasi, Mail.Ru Mail.  Belum lama ini, saya melakukan penelitian kerentanan pada ponsel OAuth 2.0.  Untuk membuat skema OAuth 2.0 seluler yang aman, tidak cukup menerapkan standar dalam bentuk murni dan memeriksa redirect_uri.  Penting untuk mempertimbangkan spesifikasi aplikasi seluler dan menerapkan mekanisme perlindungan tambahan. <br><br>  Pada artikel ini saya ingin berbagi dengan Anda pengetahuan tentang serangan pada ponsel OAuth 2.0, tentang metode perlindungan dan implementasi aman dari protokol ini.  Semua komponen perlindungan yang diperlukan, yang akan saya bahas di bawah, diimplementasikan di SDK terbaru untuk klien seluler Mail.Ru Mail. <br><a name="habracut"></a><br><h1>  Sifat dan fungsi OAuth 2.0 </h1><br>  OAuth 2.0 adalah protokol otorisasi yang menjelaskan bagaimana aman bagi layanan klien untuk mengakses sumber daya pengguna pada penyedia layanan.  Pada saat yang sama, OAuth 2.0 menyelamatkan pengguna dari keharusan memasukkan kata sandi di luar penyedia layanan: seluruh proses dikurangi menjadi mengklik tombol "Saya setuju untuk memberikan akses ke ...". <br><br>  Penyedia dalam hal OAuth 2.0 adalah layanan yang memiliki data pengguna dan, dengan izin pengguna, menyediakan layanan pihak ketiga (klien) dengan akses yang aman ke data ini.  Klien adalah aplikasi yang ingin menerima data pengguna dari penyedia. <br><br>  Beberapa waktu setelah rilis protokol OAuth 2.0, pengembang biasa mengadaptasinya untuk otentikasi, meskipun awalnya tidak dimaksudkan untuk ini.  Otentikasi menggeser vektor serangan dari data pengguna yang disimpan di penyedia layanan ke akun pengguna layanan pengguna. <br><br>  Itu tidak terbatas pada otentikasi saja.  Di era aplikasi seluler dan peninggian konversi, memasuki aplikasi dengan satu tombol menjadi sangat menggoda.  Pengembang menempatkan OAuth 2.0 di rel seluler.  Secara alami, sedikit orang yang memikirkan keamanan dan spesifikasi aplikasi seluler: sekali dan lagi, dan dalam produksi.  Namun, OAuth 2.0 umumnya tidak berfungsi dengan baik di luar aplikasi web: masalah yang sama diamati di kedua aplikasi seluler dan desktop. <br><br>  Mari kita cari tahu cara membuat OAuth 2.0 mobile yang aman. <br><br><h1>  Bagaimana cara kerjanya? </h1><br>  Ingat bahwa pada perangkat seluler, klien mungkin bukan peramban, tetapi aplikasi seluler tanpa backend.  Karena itu, kami dihadapkan pada dua masalah keamanan utama untuk seluler OAuth 2.0: <br><br><ol><li>  Klien tidak dipercaya. </li><li>  Perilaku pengalihan dari browser ke aplikasi seluler tergantung pada pengaturan dan aplikasi yang telah diinstal pengguna. </li></ol><br><h4>  Aplikasi seluler adalah klien publik </h4><br>  Untuk memahami akar masalah pertama, mari kita lihat bagaimana OAuth 2.0 bekerja jika terjadi interaksi server-ke-server, dan kemudian membandingkannya dengan OAuth 2.0 jika terjadi interaksi klien-ke-server. <br><br>  Dalam kedua kasus, semuanya dimulai dengan fakta bahwa klien layanan mendaftar dengan penyedia layanan dan menerima <code>client_id</code> dan, dalam beberapa kasus, <code>client_secret</code> .  Nilai <code>client_id</code> bersifat publik dan diperlukan untuk mengidentifikasi layanan klien, tidak seperti <code>client_secret</code> , yang nilainya bersifat pribadi.  Proses pendaftaran dijelaskan secara lebih rinci dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">RFC 7591</a> . <br><br>  Diagram di bawah ini menunjukkan operasi OAuth 2.0 dalam komunikasi server-ke-server. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f06/279/e8a/f06279e8ac68f2fe664362caec6fa063.png"><br>  <i>Gambar diambil dari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://tools.ietf.org/html/rfc6749#section-1.2</a></i> <br><br>  Ada 3 tahapan utama protokol OAuth 2.0: <br><br><ol><li>  [Langkah-langkah AC] Dapatkan Kode Otorisasi (selanjutnya hanya <code>code</code> ). </li><li>  [Langkah DE] <code>code</code> pertukaran untuk <code>access_token</code> . </li><li>  Akses sumber daya menggunakan <code>access_token</code> . </li></ol><br>  Mari kita periksa penerimaan kode secara lebih rinci: <br><br><ol><li>  [Langkah A] Klien layanan mengarahkan pengguna ke penyedia layanan. </li><li>  [Langkah B] Penyedia layanan meminta izin dari pengguna untuk memberikan data ke layanan klien (panah B ke atas).  Pengguna menyediakan akses ke data (panah B ke kanan). </li><li>  [Langkah C] Penyedia layanan mengembalikan <code>code</code> ke browser pengguna, yang mengarahkan ulang <code>code</code> layanan klien. </li></ol><br>  Mari kita <code>access_token</code> mendapatkan <code>access_token</code> lebih rinci: <br><br><ol><li>  [Langkah D] Server klien mengirimkan permintaan untuk <code>access_token</code> .  Permintaan tersebut meliputi: <code>code</code> , <code>client_secret</code> dan <code>redirect_uri</code> . </li><li>  [Langkah E] Dalam hal <code>code</code> valid, <code>client_secret</code> dan <code>redirect_uri</code> , <code>client_secret</code> disediakan. </li></ol><br>  Permintaan untuk <code>access_token</code> dilakukan sesuai dengan skema server-ke-server, oleh karena itu, secara umum, untuk mencuri <code>client_secret</code> penyerang harus meretas server-klien-server atau server penyedia layanan. <br><br>  Sekarang mari kita lihat seperti apa skema OAuth 2.0 pada perangkat seluler tanpa backend (interaksi klien-ke-server). <br><br><img src="https://habrastorage.org/getpro/habr/post_images/7cb/9fb/b7d/7cb9fbb7dcc35c74e921f18d22584254.png"><br>  <i>Gambar diambil dari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://tools.ietf.org/html/rfc8252#section-4.1</a></i> <br><br>  Skema umum dibagi menjadi 3 langkah utama yang sama: <br><br><ol><li>  [langkah 1-4 dalam gambar] Dapatkan <code>code</code> . </li><li>  [langkah 5-6 dalam gambar] <code>code</code> pertukaran untuk <code>access_token</code> . </li><li>  Akses sumber daya menggunakan <code>access_token</code> . </li></ol><br>  Namun, dalam hal ini, aplikasi seluler juga bertindak sebagai server, yang berarti <code>client_secret</code> akan <code>client_secret</code> ke dalam aplikasi.  Ini mengarah pada fakta bahwa pada perangkat seluler tidak mungkin menyimpan rahasia <code>lient_secret</code> dari penyerang.  <code>client_secret</code> dua cara untuk mendapatkan <code>client_secret</code> ke dalam aplikasi: untuk menyaring lalu lintas dari aplikasi ke server atau merekayasa balik aplikasi.  Kedua metode ini mudah diterapkan, sehingga <code>client_secret</code> berguna di perangkat seluler. <br><br>  Mengenai skema client-to-server, Anda mungkin memiliki pertanyaan: "mengapa tidak segera mendapatkan <code>access_token</code> ?".  Kelihatannya, mengapa kita perlu langkah ekstra?  Selain itu, ada skema <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Hibah Implisit</a> di mana klien segera menerima <code>access_token</code> .  Meskipun dapat digunakan dalam beberapa kasus, kita akan melihat di bawah ini bahwa <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Implisit Grant</a> tidak cocok untuk OAuth 2.0 seluler yang aman. <br><br><h4>  Redirect di perangkat seluler </h4><br>  Secara umum, untuk pengalihan dari browser ke aplikasi pada perangkat seluler, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">skema URI Khusus</a> dan mekanisme <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">AppLink</a> digunakan.  Tidak satu pun dari mekanisme ini dalam bentuk murni yang dapat diandalkan seperti pengalihan browser. <br><br>  Skema URI khusus (atau tautan dalam) digunakan sebagai berikut: pengembang menentukan skema aplikasi sebelum perakitan.  Skema dapat arbitrer, sementara pada perangkat yang sama beberapa aplikasi dengan skema yang sama dapat diinstal.  Semuanya cukup sederhana ketika setiap aplikasi pada perangkat sesuai dengan satu aplikasi.  Tetapi bagaimana jika dua aplikasi mendaftarkan sirkuit yang sama pada perangkat yang sama?  Bagaimana sistem operasi menentukan mana dari dua aplikasi yang akan dibuka ketika mengakses Skema URI Khusus?  Android akan menampilkan jendela dengan pilihan aplikasi tempat Anda ingin membuka tautan.  Di iOS, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">perilaku tidak didefinisikan</a> , yang berarti bahwa salah satu dari kedua aplikasi dapat dibuka.  Dalam kedua kasus, penyerang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dapat mencegat kode atau access_token</a> . <br><br>  AppLink, berbeda dengan Skema URI Khusus, dijamin untuk membuka aplikasi yang tepat, tetapi mekanisme ini memiliki beberapa kelemahan: <br><br><ol><li>  Setiap klien layanan harus secara independen melewati <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">prosedur verifikasi</a> . </li><li>  Pengguna Android dapat mematikan AppLink untuk aplikasi tertentu di pengaturan. </li><li>  Android di bawah 6.0 dan iOS di bawah 9.0 tidak mendukung AppLink. </li></ol><br>  Kerugian AppLink di atas, pertama, meningkatkan ambang entri untuk layanan klien potensial, dan kedua, dapat mengarah pada fakta bahwa dalam keadaan tertentu pengguna tidak akan bekerja OAuth 2.0.  Ini membuat AppLink tidak cocok untuk mengganti pengalihan browser dalam protokol OAuth 2.0. <br><br><h1>  Oke, apa yang harus diserang? </h1><br>  Masalah ponsel OAuth 2.0 juga memunculkan serangan spesifik.  Mari kita lihat siapa mereka dan bagaimana mereka bekerja. <br><br><a name="1"></a><h4>  Serangan Intersepsi Kode Otorisasi </h4><br>  Data awal: aplikasi yang sah (klien OAuth 2.0) dan aplikasi jahat yang mendaftarkan skema yang sama dengan yang sah diinstal pada perangkat pengguna.  Gambar di bawah ini menunjukkan skema serangan. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/a87/336/d4c/a87336d4c0d73c89a62bb448cb12d49b.png"><br>  <i>Gambar diambil dari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://tools.ietf.org/html/rfc7636#section-1</a></i> <br><br>  Inilah masalahnya: pada langkah 4, browser mengembalikan <code>code</code> ke aplikasi melalui Skema URI Kustom, sehingga <code>code</code> dapat dicegat oleh malware (karena terdaftar skema yang sama dengan aplikasi yang sah).  Setelah itu, malware mengubah <code>code</code> menjadi <code>access_token</code> dan mendapatkan akses ke data pengguna. <br><br>  Bagaimana cara melindungi diri sendiri?  Dalam beberapa kasus, mekanisme komunikasi antarproses dapat digunakan, kita akan membicarakannya di bawah ini.  Dalam kasus umum, Anda perlu menerapkan skema yang disebut <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Kunci Bukti untuk Pertukaran Kode</a> .  Esensinya tercermin dalam diagram di bawah ini. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/123/67e/349/12367e3497cbbd54d007a18a678bfc0d.png"><br>  <i>Gambar diambil dari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://tools.ietf.org/html/rfc7636#section-1.1</a></i> <br><br>  Dalam permintaan dari klien, ada beberapa parameter tambahan: <code>code_verifier</code> , <code>code_challenge</code> (pada <code>t(code_verifier)</code> ) dan <code>code_challenge_method</code> (pada diagram <code>t_m</code> ). <br><br>  <code>Code_verifier</code> adalah angka acak <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dengan panjang setidaknya 256 bit</a> yang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">hanya digunakan sekali</a> .  Artinya, untuk <b>setiap</b> permintaan <code>code</code> klien harus membuat <code>code_verifier</code> baru. <br><br>  <code>Code_challenge_method</code> adalah nama fungsi konversi, paling sering SHA-256. <br><br>  <code>Code_challenge</code> adalah <code>code_verifier</code> yang konversi <code>code_challenge_method</code> telah <code>code_challenge_method</code> dan dikodekan dalam URL Safe Base64. <br><br>  Konversi <code>code_verifier</code> ke <code>code_challenge</code> diperlukan untuk melindungi terhadap serangan vektor berdasarkan intersepsi <code>code_verifier</code> (misalnya, dari log sistem perangkat) ketika meminta <code>code</code> . <br><br>  Jika perangkat pengguna <b>tidak mendukung</b> SHA-256, maka <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">penurunan versi diizinkan hingga konversi code_verifier hilang</a> .  Dalam semua kasus lain, Anda harus menggunakan SHA-256. <br><br>  Skema ini bekerja sebagai berikut: <br><br><ol><li>  Klien menghasilkan <code>code_verifier</code> dan mengingatnya. </li><li>  Klien memilih <code>code_challenge_method</code> dan mendapatkan <code>code_challenge</code> dari <code>code_verifier</code> . </li><li>  [Langkah A] Klien meminta <code>code</code> , dengan <code>code_challenge</code> dan <code>code_challenge_method</code> ditambahkan ke permintaan. </li><li>  [Langkah B] Penyedia mengingat <code>code_challenge</code> dan <code>code_challenge_method</code> di server dan mengembalikan <code>code</code> klien. </li><li>  [Langkah C] Klien meminta <code>access_token</code> , dengan <code>access_token</code> ditambahkan ke <code>code_verifier</code> . </li><li>  Penyedia menerima <code>code_challenge</code> dari <code>code_challenge</code> yang masuk, dan kemudian memeriksanya terhadap <code>code_challenge</code> , yang ia ingat. </li><li>  [Langkah D] Jika nilainya cocok, penyedia akan mengeluarkan <code>access_token</code> klien. </li></ol><br>  Mari kita <code>code_challenge</code> mengapa <code>code_challenge</code> memungkinkan <code>code_challenge</code> melindungi diri dari serangan intersepsi kode.  Untuk melakukan ini, kita akan melalui tahapan mendapatkan <code>access_token</code> . <br><br><ol><li>  Pertama, <code>code</code> permintaan aplikasi yang sah ( <code>code_challenge</code> dan <code>code_challenge_method</code> dikirim bersama dengan <b>permintaan</b> ). </li><li>  Malware memotong <code>code</code> (tetapi bukan <code>code_challenge</code> , karena tidak ada <code>code_challenge</code> <b>dalam respons</b> ). </li><li>  Malware meminta <code>access_token</code> (dengan <code>code</code> valid, tetapi <b>tanpa</b> <code>code_verifier</code> valid). </li><li>  Server memperhatikan ketidakcocokan <code>code_challenge</code> dan melemparkan kesalahan. </li></ol><br>  Perhatikan bahwa penyerang tidak memiliki kemampuan untuk menebak <code>code_verifier</code> (256 bit acak!) Atau menemukannya di suatu tempat di log ( <code>code_verifier</code> ditransmisikan sekali). <br><br>  Jika semua ini direduksi menjadi satu frasa, maka <code>code_challenge</code> memungkinkan penyedia layanan menjawab pertanyaan: "apakah <code>access_token</code> diminta oleh aplikasi klien yang sama yang meminta <code>code</code> , atau oleh yang lain?" <br><br><h4>  OAuth 2.0 CSRF </h4><br>  Pada perangkat seluler, OAuth 2.0 sering digunakan sebagai mekanisme otentikasi.  Seperti yang kita ingat, otentikasi melalui OAuth 2.0 berbeda dari otorisasi dalam hal kerentanan OAuth 2.0 memengaruhi data pengguna di sisi klien layanan, dan bukan penyedia layanan.  Akibatnya, serangan CSRF pada OAuth 2.0 memungkinkan Anda untuk mencuri akun orang lain. <br><br>  Pertimbangkan serangan CSRF terhadap OAuth 2.0 menggunakan contoh aplikasi klien taksi dan penyedia provider.com.  Pertama, seorang penyerang masuk ke attacker@provider.com di perangkatnya dan menerima <code>code</code> untuk taksi.  Setelah itu, penyerang menyela proses OAuth 2.0 dan menghasilkan tautan: <br><br> <code>com.taxi.app://oauth? <br> code=b57b236c9bcd2a61fcd627b69ae2d7a6eb5bc13f2dc25311348ee08df43bc0c4 <br></code> <br>  Kemudian penyerang mengirimkan tautan ke korban, misalnya, dengan kedok surat atau SMS dari administrasi taksi.  Korban <code>access_token</code> tautan, aplikasi taksi terbuka di teleponnya, yang menerima <code>access_token</code> , dan sebagai akibatnya korban berakhir di akun taksi <b>penyerang</b> .  Tidak menyadari tangkapannya, korban menggunakan akun ini: melakukan perjalanan, memasukkan datanya, dll. <br><br>  Sekarang, penyerang dapat masuk ke akun taksi korban kapan saja karena ia terikat dengan <code>attacker@provider.com</code> .  Serangan CSRF saat masuk diizinkan mencuri akun. <br><br>  Serangan CSRF biasanya dilindungi dengan token CSRF (juga disebut <code>state</code> ), dan OAuth 2.0 tidak terkecuali.  Cara menggunakan token CSRF: <br><br><ol><li>  Aplikasi klien menghasilkan dan menyimpan token CSRF di perangkat seluler pengguna. </li><li>  Aplikasi klien menyertakan token CSRF dalam permintaan <code>code</code> . </li><li>  Server mengembalikan token CSRF yang sama dalam respons bersama dengan kode. </li><li>  Aplikasi klien membandingkan token CSRF yang masuk dan disimpan.  Jika nilainya cocok, maka prosesnya berlanjut. </li></ol><br>  Persyaratan token CSRF: panjang setidaknya 256 bit, diperoleh dari sumber sekuens pseudorandom yang baik. <br><br>  Singkatnya, token CSRF memungkinkan aplikasi klien untuk menjawab pertanyaan: "apakah saya mulai mendapatkan <code>access_token</code> , atau ada seseorang yang mencoba menipu saya?" <br><br><h4>  Malware berpura-pura menjadi klien yang sah </h4><br>  Beberapa malware dapat meniru aplikasi yang sah dan menaikkan layar izin atas nama mereka (layar persetujuan adalah layar tempat pengguna melihat: "Saya setuju untuk memberikan akses ke ...").  Pengguna yang lalai dapat mengklik "izinkan", dan sebagai hasilnya, malware memperoleh akses ke data pengguna. <br><br>  Android dan iOS menyediakan mekanisme untuk saling verifikasi aplikasi.  Aplikasi penyedia dapat memverifikasi keabsahan aplikasi klien, dan sebaliknya. <br><br>  Sayangnya, jika mekanisme OAuth 2.0 menggunakan aliran melalui browser, maka Anda tidak dapat bertahan melawan serangan ini. <br><br><h4>  Serangan lainnya </h4><br>  Kami memeriksa serangan yang unik untuk ponsel OAuth 2.0.  Namun, jangan lupa tentang serangan pada OAuth 2.0 biasa: spoofing <code>redirect_uri</code> , intersepsi lalu lintas melalui koneksi yang tidak aman, dll.  Anda dapat membaca lebih lanjut tentang mereka di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> . <br><br><h1>  Apa yang harus dilakukan </h1><br>  Kami mempelajari cara kerja protokol OAuth 2.0, dan mengetahui kerentanan apa yang ada dalam implementasi protokol ini pada perangkat seluler.  Sekarang mari kita kumpulkan skema OAuth 2.0 seluler yang aman dari setiap bagian. <br><br><h4>  Bagus, buruk OAuth 2.0 </h4><br>  Mari kita mulai dengan cara menaikkan layar izin dengan benar.  Pada perangkat seluler, ada dua cara untuk membuka halaman web dari aplikasi asli (contoh aplikasi asli: Mail.Ru Mail, VK, Facebook). <br><br><img src="https://habrastorage.org/getpro/habr/post_images/7ee/bd1/d02/7eebd1d02b5fa11a820fe37abbd1c552.png"><br><br>  Metode pertama disebut Tab Kustom Peramban (pada gambar di sebelah kiri).  <b>Catatan</b> : Tab Khusus Peramban di Android disebut Tab Kustom Chrome, dan di iOS SafariViewController.  Sebenarnya, ini adalah tab browser normal, yang ditampilkan langsung di aplikasi, mis.  Tidak ada peralihan visual antar aplikasi. <br><br>  Metode kedua disebut "meningkatkan WebView" (dalam gambar di sebelah kanan), dalam kaitannya dengan ponsel OAuth 2.0, saya menganggapnya buruk. <br><br>  WebView adalah browser mandiri untuk aplikasi asli. <br><br>  " <i>Browser yang</i> berdiri sendiri" berarti bahwa WebView tidak memungkinkan akses ke cookie, penyimpanan, cache, riwayat, dan data lainnya dari Safari dan browser Chrome.  Kebalikannya juga benar: Safari dan Chrome tidak dapat mengakses data WebView. <br><br>  “ <i>Browser untuk aplikasi asli</i> ” berarti bahwa aplikasi asli yang meningkatkan WebView memiliki akses <b>penuh</b> ke cookie, penyimpanan, cache, riwayat, dan data WebView lainnya. <br><br>  Sekarang bayangkan: pengguna menekan tombol "log in using ..." dan WebView dari aplikasi jahat meminta nama pengguna dan kata sandi dari penyedia layanan. <br><br>  Kegagalan sekaligus di semua lini: <br><br><ol><li>  Pengguna memasukkan nama pengguna dan kata sandi dari akun penyedia layanan dalam aplikasi, yang dapat dengan mudah mencuri data ini. </li><li>  OAuth 2.0 pada awalnya dikembangkan agar <i>tidak memasukkan nama pengguna dan kata sandi</i> dari penyedia layanan. </li><li>  Pengguna terbiasa memasukkan login dan kata sandi di mana saja, kemungkinan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">phishing</a> meningkat. <br></li></ol><br>  Karena semua argumen bertentangan dengan WebView, kesimpulannya menunjukkan dirinya sendiri: naikkan Tab Kustom Peramban untuk layar persetujuan. <br><br>  Jika ada di antara Anda yang mendebat WebView alih-alih Tab Kustom Peramban, tuliskan di komentar, saya akan sangat berterima kasih. <br><br><h4>  Skema OAuth 2.0 Mobile Aman </h4><br>  Kami akan menggunakan skema Pemberian Kode Otorisasi karena memungkinkan kami untuk menambahkan <code>code_challenge</code> dan melindungi <code>code_challenge</code> dari serangan intersepsi kode. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/7cb/9fb/b7d/7cb9fbb7dcc35c74e921f18d22584254.png"><br>  <i>Gambar diambil dari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://tools.ietf.org/html/rfc8252#section-4.1</a></i> <br><br>  Permintaan kode (langkah 1-2) akan terlihat seperti ini: <br><br> <code>https://o2.mail.ru/code? <br> redirect_uri=com.mail.cloud.app%3A%2F%2Foauth&amp; <br> anti_csrf=927489cb2fcdb32e302713f6a720397868b71dd2128c734181983f367d622c24&amp; code_challenge=ZjYxNzQ4ZjI4YjdkNWRmZjg4MWQ1N2FkZjQzNGVkODE1YTRhNjViNjJjMGY5MGJjNzdiOGEzMDU2ZjE3NGFiYw%3D%3D&amp; <br> code_challenge_method=S256&amp; <br> scope=email%2Cid&amp; <br> response_type=code&amp; <br> client_id=984a644ec3b56d32b0404777e1eb73390c <br></code> <br>  Pada langkah 3, browser menerima respons yang diarahkan: <br><br> <code>com.mail.cloud.app://outh? <br> code=b57b236c9bcd2a61fcd627b69ae2d7a6eb5bc13f2dc25311348ee08df43bc0c4&amp; <br> anti_csrf=927489cb2fcdb32e302713f6a720397868b71dd2128c734181983f367d622c24</code> <br> <br>  Pada langkah 4, browser membuka Skema URI Kustom dan meneruskan <code>code</code> dan token CSRF ke aplikasi klien. <br><br>  Permintaan untuk <code>access_token</code> (langkah 5): <br><br> <code>https://o2.mail.ru/token? <br> code_verifier=e61748f28b7d5daf881d571df434ed815a4a65b62c0f90bc77b8a3056f174abc&amp; <br> code=b57b236c9bcd2a61fcd627b69ae2d7a6eb5bc13f2dc25311348ee08df43bc0c4&amp; <br> client_id=984a644ec3b56d32b0404777e1eb73390c <br></code> <br>  Langkah terakhir mengembalikan respons dengan <code>access_token</code> . <br><br>  Secara umum, skema di atas aman, tetapi ada juga kasus khusus di mana OAuth 2.0 dapat dibuat lebih sederhana dan sedikit lebih aman. <br><br><h4>  Android IPC </h4><br>  Android memiliki mekanisme pertukaran data dua arah antar proses: IPC (komunikasi antar proses).  IPC lebih disukai daripada Skema URI Khusus karena dua alasan: <br><br><ol><li>  Aplikasi yang membuka saluran IPC dapat memverifikasi keaslian aplikasi yang dibuka oleh sertifikatnya.  Kebalikannya juga benar: aplikasi yang terbuka dapat memverifikasi keaslian aplikasi yang membukanya. </li><li>  Dengan mengirim permintaan melalui saluran IPC, pengirim dapat menerima respons melalui saluran yang sama.  Bersama dengan verifikasi timbal balik (butir 1), ini berarti bahwa tidak ada proses pihak ketiga yang dapat mencegat <code>access_token</code> . </li></ol><br><img src="https://habrastorage.org/getpro/habr/post_images/693/84d/6f6/69384d6f63788694137f8d559d6469fa.png"><br><br>  Dengan demikian, kita dapat menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Hibah Implisit</a> dan sangat menyederhanakan skema seluler OAuth 2.0.  Tidak ada token <code>code_challenge</code> dan CSRF.  Selain itu, kami akan dapat melindungi diri dari malware yang meniru klien yang sah untuk mencuri akun pengguna. <br><br><h4>  SDK pelanggan </h4><br>  Selain menerapkan skema keamanan seluler OAuth 2.0 yang dijelaskan di atas, penyedia layanan harus mengembangkan SDK untuk pelanggannya.  Ini akan memfasilitasi implementasi OAuth 2.0 di sisi klien dan pada saat yang sama mengurangi jumlah kesalahan dan kerentanan. <br><br><h1>  Buat kesimpulan </h1><br>  Untuk penyedia OAuth 2.0, saya menyusun "Daftar Periksa Secure Mobile OAuth 2.0": <br><br><ol><li>  Dasar yang kuat sangat penting.  Dalam hal mobile OAuth 2.0, yayasan adalah skema atau protokol yang kami pilih untuk diterapkan.  Saat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">menerapkan skema OAuth 2.0 Anda sendiri,</a> mudah untuk membuat kesalahan.  Yang lain sudah mengisi gundukan dan membuat kesimpulan, tidak ada yang salah dengan belajar dari kesalahan mereka dan segera membuat implementasi yang aman.  Secara umum, skema OAuth 2.0 seluler paling aman adalah yang ada di Bagian Apa yang Harus Dilakukan? </li><li>  <code>Access_token</code> dan data sensitif lainnya: di bawah iOS - di Gantungan Kunci, di bawah Android - di Penyimpanan Internal.  Repositori ini dirancang khusus untuk tujuan tersebut.  Jika perlu, Anda dapat menggunakan Penyedia Konten di Android, tetapi harus dikonfigurasi dengan aman. </li><li>  <code>Code</code> harus satu kali, dengan waktu hidup yang singkat. </li><li>  Untuk melindungi dari intersepsi kode, gunakan <code>code_challenge</code> . </li><li>  Untuk melindungi dari serangan CSRF pada login, gunakan token CSRF. </li><li>  Jangan gunakan WebView untuk layar persetujuan, gunakan Tab Kustom Browser. </li><li>  <code>Client_secret</code> <b>berguna</b> jika tidak disimpan di backend.  Jangan berikan kepada klien publik. </li><li>  Gunakan HTTPS di <b>mana-mana</b> , dengan larangan downgrade ke HTTP. </li><li>  Ikuti rekomendasi kriptografi (pemilihan sandi, panjang token, dll.) <b>Dari standar</b> .  Anda dapat menyalin data dan mencari tahu mengapa itu dilakukan seperti itu, tetapi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Anda tidak bisa melakukan kriptografi Anda</a> . </li><li>  Dari aplikasi klien, verifikasi siapa yang Anda buka untuk OAuth 2.0, dan dari aplikasi penyedia, periksa siapa yang membuka Anda untuk OAuth 2.0. </li><li>  Waspadai <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">kerentanan OAuth 2.0 yang biasa</a> .  Mobile OAuth 2.0 memperluas dan melengkapi yang biasa, jadi tidak ada yang membatalkan cek <code>redirect_uri</code> untuk kecocokan yang tepat dan rekomendasi lain untuk OAuth 2.0 biasa. </li><li>  Pastikan untuk memberikan SDK kepada pelanggan.  Klien akan memiliki lebih sedikit bug dan kerentanan dalam kode, dan akan lebih mudah baginya untuk mengimplementasikan OAuth 2.0 Anda. </li></ol><br><h1>  Apa yang harus dibaca </h1><br><ol><li>  [RFC] OAuth 2.0 untuk Aplikasi Asli <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://tools.ietf.org/html/rfc8252</a> </li><li>  Google OAuth 2.0 untuk Aplikasi Seluler &amp; Desktop <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://developers.google.com/identity/protocols/OAuth2InstalledApp</a> </li><li>  [RFC] Kunci Bukti untuk Pertukaran Kode oleh Klien Publik OAuth <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://tools.ietf.org/html/rfc7636</a> </li><li>  Kondisi Balapan OAuth 2.0 <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://hackerone.com/reports/55140</a> </li><li>  [RFC] OAuth 2.0 Model Ancaman dan Pertimbangan Keamanan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://tools.ietf.org/html/rfc6819</a> </li><li>  Serangan pada OAuth 2.0 biasa <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://sakurity.com/oauth</a> </li><li>  [RFC] OAuth 2.0 Protokol Registrasi Klien Dinamis <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://tools.ietf.org/html/rfc7591</a> </li></ol><br><h1>  Ucapan Terima Kasih </h1><br>  Terima kasih kepada semua orang yang membantu menulis artikel ini, terutama Sergey Belov, Andrey Sumin, Andrey Labunts ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">@isciurus</a> ) dan Daria Yakovleva. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id417031/">https://habr.com/ru/post/id417031/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id417015/index.html">Kami memahami catatan apa dan apa yang tidak merekam aplikasi Burger King</a></li>
<li><a href="../id417017/index.html">Bagaimana percobaan nuklir yang gagal secara tidak sengaja menghasilkan astronomi neutrino</a></li>
<li><a href="../id417023/index.html">Pengalaman Rambler Group: bagaimana kami mulai sepenuhnya mengontrol pembentukan dan perilaku komponen Bereaksi front-end</a></li>
<li><a href="../id417027/index.html">Bagaimana saya menulis library C ++ 11 standar atau mengapa boost sangat menakutkan. Pendahuluan</a></li>
<li><a href="../id417029/index.html">Pembuatan Kode dengan LLVM</a></li>
<li><a href="../id417033/index.html">QIWI Kitchen pada 7 Juni - video pidato para pembicara kami</a></li>
<li><a href="../id417035/index.html">UnnyWorld: post-mortem</a></li>
<li><a href="../id417037/index.html">BEERBRAZZERS. Kontrol cahaya. Lampu Vixen 3. Mulai Cepat (1/4)</a></li>
<li><a href="../id417039/index.html">Pelajari wordpress (dan banyak lagi) untuk membuat pemain Youtube dengan cepat</a></li>
<li><a href="../id417041/index.html">eslint-scope v3.7.2 mencuri token NPM</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>