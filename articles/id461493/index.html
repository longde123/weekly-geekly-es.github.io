<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>😅 🍵 🍒 Django 3.0 akan tidak sinkron ➡️ ✌🏿 🎳</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Andrew Godwin menerbitkan DEP 0009: Django yang mampu Async pada 9 Mei, dan disetujui oleh dewan teknis Django pada 21 Juli, sehingga diharapkan denga...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Django 3.0 akan tidak sinkron</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/461493/"><p>  <em>Andrew Godwin menerbitkan <a href="">DEP 0009: Django yang mampu Async</a> pada 9 Mei, dan disetujui <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">oleh dewan teknis</a> Django pada 21 Juli, sehingga diharapkan dengan rilis Django 3.0 mereka akan memiliki waktu untuk melakukan sesuatu yang menarik.</em>  <em>Itu sudah disebutkan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">di suatu tempat di komentar Habr</a> , tetapi saya memutuskan untuk menyampaikan berita ini kepada khalayak yang lebih luas dengan menerjemahkannya - terutama bagi mereka yang, seperti saya, tidak secara khusus mengikuti berita Django.</em> </p><br><div class="oembed"><twitter-widget class="twitter-tweet twitter-tweet-rendered" id="twitter-widget-0" style="position: absolute; visibility: hidden; display: block; transform: rotate(0deg); max-width: 100%; width: 500px; min-width: 220px; margin-top: 10px; margin-bottom: 10px;" data-tweet-id="1153030952915890177"></twitter-widget><blockquote class="twitter-tweet" data-lang="en_US" data-twitter-extracted-i1582370713311225466="true"><p lang="en" dir="ltr">  Saya senang mengumumkan bahwa Dewan Teknis Django telah menyetujui DEP 0009 (Async di Django)!  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://t.co/yaaR0Mjg61</a> </p> - Andrew Godwin (@andrewgodwin) <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">21 Juli 2019</a> </blockquote><script async="" src="https://platform.twitter.com/widgets.js" charset="utf-8"></script></div><br><p>  Asynchronous Python telah dikembangkan selama bertahun-tahun, dan dalam ekosistem Django, kami bereksperimen dengannya di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Channels</a> dengan fokus utama pada dukungan soket web. </p><br><p>  Ketika ekosistem berkembang, menjadi jelas bahwa sementara tidak ada kebutuhan mendesak untuk memperluas Django untuk mendukung protokol non-HTTP seperti soket web, dukungan asinkron akan memberikan banyak manfaat untuk kerangka kerja model-view-template Django tradisional. </p><br><p>  Manfaatnya dijelaskan pada bagian Motivasi di bawah ini, tetapi kesimpulan umum yang saya dapatkan adalah bahwa kita mendapatkan begitu banyak dari Django asinkron yang sepadan dengan kerja keras yang diperlukan.  Saya juga percaya bahwa sangat penting untuk membuat perubahan dengan cara yang berulang-ulang, yang didukung masyarakat yang tidak akan bergantung pada satu atau dua kontributor lama yang mungkin hangus. <a name="habracut"></a></p><br><p>  Meskipun dokumen tersebut ditetapkan sebagai DEP "Fitur", semua ini berarti bahwa ia juga sebagian merupakan DEP Proses.  Cakupan perubahan yang diusulkan di bawah ini sangat besar, dan meluncurkannya sebagai proses fitur tunggal tradisional cenderung gagal. </p><br><p>  Tentu saja, di seluruh dokumen ini, penting untuk mengingat filosofi Django, yaitu menjaga semuanya aman dan terbelakang kompatibel.  Rencananya bukan untuk menghapus Django yang sinkron - rencananya adalah menyimpannya dalam bentuk saat ini, tetapi menambahkan asinkron sebagai pilihan bagi mereka yang berpikir mereka membutuhkan kinerja atau fleksibilitas ekstra. </p><br><p>  Apakah ini pekerjaan raksasa?  Tentu saja  Tetapi saya merasa bahwa ini dapat secara signifikan mengubah masa depan Django - kami memiliki kesempatan untuk mengambil kerangka kerja yang terbukti, dan komunitas yang luar biasa, dan memperkenalkan serangkaian opsi yang benar-benar baru yang sebelumnya tidak mungkin. </p><br><p>  Web telah berubah, dan Django harus berubah dengan itu, tetapi sesuai dengan cita-cita kami, menjadi terjangkau, aman secara default, dan fleksibel ketika proyek tumbuh dan kebutuhan mereka berubah.  Dalam dunia pergudangan data cloud, arsitektur berorientasi layanan, dan backend sebagai dasar logika bisnis yang kompleks, kemampuan untuk melakukan berbagai hal secara kompetitif adalah kuncinya. </p><br><p>  DEP ini menguraikan rencana yang saya pikir akan membawa kita ke sana.  Ini adalah visi yang saya benar-benar percaya dan dengan yang saya akan bekerja untuk membantu melakukan segala yang mungkin.  Pada saat yang sama, analisis dan skeptisisme yang cermat dibenarkan;  Saya meminta kritik membangun Anda, serta kepercayaan Anda.  Django bergantung pada komunitas orang dan aplikasi yang mereka buat, dan jika kita perlu menentukan jalan menuju masa depan, kita harus melakukannya bersama. </p><br><h2 id="kratkoe-opisanie">  Deskripsi singkat </h2><br><p>  Kami akan menambahkan dukungan untuk representasi asinkron, middleware, ORM, dan elemen penting lainnya ke Django. </p><br><p>  Ini akan dilakukan dengan menjalankan kode sinkron di utas, secara bertahap menggantinya dengan kode asinkron.  API sinkron akan terus ada dan didukung penuh, dan seiring waktu akan berubah menjadi pembungkus sinkron untuk kode asinkron yang awalnya. </p><br><p>  Mode ASGI akan meluncurkan Django sebagai aplikasi asinkron asli.  Mode WSGI akan memicu loop peristiwa terpisah setiap kali Django diakses, sehingga lapisan asinkron kompatibel dengan server sinkron. </p><br><p>  Multithreading di sekitar ORM adalah kompleks dan membutuhkan konsep konteks koneksi dan lengket baru untuk menjalankan kode ORM yang sinkron. </p><br><p>  Banyak bagian Django akan terus bekerja dalam sinkronisasi, dan prioritas kami adalah untuk mendukung pengguna menulis pandangan dalam kedua gaya, memungkinkan mereka untuk memilih gaya terbaik untuk presentasi yang sedang mereka kerjakan. </p><br><p>  Beberapa fungsi, seperti templat dan caching, akan membutuhkan DEP dan studi terpisah mereka sendiri tentang cara membuatnya sama sekali tidak sinkron.  DEP ini terutama berfokus pada aliran HTTP-middleware-view dan ORM. </p><br><p>  Akan ada kompatibilitas penuh.  Proyek Django 2.2 standar harus dijalankan dalam Django asinkron (baik 3.0 atau 3.1) tanpa perubahan. </p><br><p>  Proposal ini difokuskan pada penerapan bagian-bagian kecil yang berulang dengan penempatan bertahap mereka di cabang utama untuk menghindari masalah dengan garpu berumur panjang dan memungkinkan kami untuk mengubah arah saat kami mendeteksi masalah. </p><br><p>  Ini adalah kesempatan bagus untuk menarik anggota baru.  Kita harus membiayai proyek sehingga ini terjadi lebih cepat.  Pendanaan harus dalam skala yang tidak biasa kita lakukan. </p><br><h2 id="specifikaciya">  Spesifikasi </h2><br><p>  Tujuan keseluruhan adalah untuk membuat setiap bagian Django, yang dapat memblokir - yaitu, bukan hanya perhitungan yang terikat CPU - menjadi asinkron (berjalan dalam loop peristiwa asinkron tanpa kunci). </p><br><p>  Ini termasuk fitur-fitur berikut: </p><br><ul><li>  Lapisan antara (Middleware) </li><li>  Tampilan </li><li>  ORM </li><li>  Pola </li><li>  Pengujian </li><li>  Caching </li><li>  Validasi formulir </li><li>  Email </li></ul><br><p>  Namun, ini tidak termasuk hal-hal seperti internasionalisasi, yang tidak akan membawa peningkatan kinerja, karena ini adalah tugas yang terikat CPU yang juga berjalan cepat, atau migrasi yang single-threaded ketika diluncurkan melalui perintah manajemen. </p><br><p>  Setiap fungsi individu yang menjadi asinkron di dalamnya juga akan menyediakan antarmuka sinkron yang kompatibel dengan API saat ini (dalam 2.2) untuk masa mendatang - kami dapat mengubahnya dari waktu ke waktu untuk membuatnya lebih baik, tetapi API sinkron tidak akan pergi ke mana pun. </p><br><p>  Gambaran umum bagaimana hal ini dicapai secara teknis diberikan di bawah ini, dan kemudian rincian implementasi spesifik untuk bidang-bidang tertentu diberikan.  Ini tidak lengkap untuk semua fungsi Django, tetapi jika kita mencapai tujuan awal ini, maka kita akan memasukkan hampir semua kasus penggunaan. </p><br><p>  Bagian terakhir dari bagian ini, "Prosedur," juga membahas bagaimana perubahan ini dapat diterapkan secara bertahap dan oleh beberapa kelompok pengembang secara paralel, yang penting untuk menyelesaikan perubahan ini dengan bantuan sukarelawan dalam jumlah waktu yang wajar. </p><br><h3 id="tehnicheskiy-obzor">  Ulasan teknis </h3><br><p>  Prinsip yang memungkinkan kita untuk mempertahankan implementasi sinkron dan asinkron secara paralel adalah kemampuan untuk menjalankan satu gaya di dalam yang lain. </p><br><p>  Setiap fungsi akan melalui tiga tahap implementasi: </p><br><ul><li>  Hanya sinkron (kami ada di sini) </li><li>  Implementasi sinkron dengan pembungkus asinkron </li><li>  Implementasi asinkron dengan pembungkus sinkron </li></ul><br><h4 id="asinhronnaya-obyortka">  Pembungkus asinkron </h4><br><p>  Pertama, kode sinkron yang ada akan dibungkus dalam antarmuka asinkron, yang menjalankan kode sinkron di kumpulan utas.  Ini akan memungkinkan kami untuk merancang dan menyediakan antarmuka asinkron secara relatif cepat, tanpa harus menulis ulang semua kode yang tersedia untuk asinkron. </p><br><p> Toolkit untuk ini sudah tersedia di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">asgiref</a> sebagai fungsi <code>sync_to_async</code> , yang mendukung hal-hal seperti penanganan pengecualian atau threadlocals (lebih lanjut tentang ini di bawah). </p><br><p>  Menjalankan kode di utas kemungkinan besar tidak akan mengarah pada peningkatan produktivitas - overhead yang muncul mungkin akan memperlambatnya sedikit ketika Anda hanya menjalankan kode linier normal - tetapi ini akan memungkinkan pengembang untuk mulai menjalankan sesuatu secara kompetitif dan terbiasa dengan fitur baru. </p><br><p>  Selain itu, ada beberapa bagian Django yang sensitif untuk memulai di utas yang <em>sama</em> setelah akses berulang;  misalnya, memproses transaksi dalam database.  Jika kami membungkus beberapa kode dalam <code>atomic()</code> yang kemudian akan mengakses ORM melalui utas acak yang diambil dari kumpulan, transaksi tidak akan berpengaruh, karena terikat pada koneksi di dalam utas tempat transaksi dimulai. </p><br><p>  Dalam situasi seperti itu, sebuah "sticky thread" diperlukan di mana konteks asinkron memanggil semua kode sinkron secara berurutan di thread yang sama alih-alih mendorongnya ke kumpulan thread, sambil mempertahankan perilaku yang benar dari ORM dan bagian-bagian yang sensitif terhadap thread lainnya.  Semua bagian Django yang kami duga membutuhkannya, termasuk seluruh ORM, akan menggunakan versi <code>sync_to_async</code> , yang mempertimbangkan ini, jadi semuanya aman secara default.  Pengguna akan dapat secara selektif menonaktifkan ini untuk eksekusi permintaan kompetitif - untuk lebih jelasnya lihat "ORM" di bawah ini. </p><br><h4 id="asinhronnaya-realizaciya">  Implementasi asinkron </h4><br><p>  Langkah selanjutnya adalah menulis ulang implementasi fungsi ke kode asinkron dan kemudian menyajikan antarmuka sinkron melalui pembungkus yang mengeksekusi kode asinkron dalam satu kali peristiwa loop.  Ini sudah tersedia di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">asgiref</a> sebagai fungsi <code>async_to_sync</code> . </p><br><p>  Tidak perlu menulis ulang semua fungsi sekaligus untuk dengan cepat melompat ke tahap ketiga.  Kami dapat memfokuskan upaya kami pada bagian yang dapat kami lakukan dengan baik dan yang memiliki dukungan perpustakaan pihak ketiga, sambil membantu seluruh ekosistem Python dalam hal-hal yang memerlukan lebih banyak pekerjaan untuk mengimplementasikan asinkroni asli;  Ini dibahas di bawah ini. </p><br><p>  Gambaran umum ini berfungsi dengan hampir semua fungsi Django yang seharusnya menjadi asinkron, kecuali untuk tempat-tempat yang Python tidak menyediakan setara fungsi asinkron yang sudah kita gunakan.  Hasilnya akan berupa perubahan dalam cara Django menyajikan API dalam mode asinkron, atau bekerja dengan pengembang inti Python untuk membantu mengembangkan fitur asinkron Python. </p><br><h3 id="threadlocals">  Threadlocals </h3><br><p>  Salah satu detail dasar implementasi Django yang perlu disebutkan secara terpisah dari sebagian besar fungsi yang dijelaskan di bawah ini adalah threadlocals.  Seperti namanya, threadlocals bekerja di dalam sebuah thread, dan meskipun Django membuat objek <code>HttpRequest</code> luar threadlocal, kami menempatkan beberapa hal lain di dalamnya - misalnya, koneksi database atau bahasa saat ini. </p><br><p>  Menggunakan threadlocals dapat dibagi menjadi dua opsi: </p><br><ul><li>  "Konteks lokal", di mana nilai diperlukan dalam beberapa konteks berbasis tumpukan, seperti permintaan.  Ini diperlukan untuk mengatur bahasa saat ini. </li><li>  "True threadlocals", di mana kode yang dilindungi sebenarnya tidak aman untuk memanggil dari utas lainnya.  Ini untuk menghubungkan ke database. </li></ul><br><p>  Pada pandangan pertama, mungkin terlihat bahwa “konteks lokal” dapat diselesaikan dengan menggunakan modul <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">contextvars</a> baru dengan Python, tetapi Django 3.0 masih harus mendukung Python 3.6, sementara modul ini muncul di 3.7.  Selain itu, <code>contextvars</code> dirancang khusus untuk menghilangkan konteks ketika beralih, misalnya, ke utas baru, sementara kita perlu menyimpan nilai-nilai ini untuk memungkinkan fungsi <code>sync_to_async</code> dan <code>async_to_sync</code> berfungsi normal sebagai pembungkus.  Ketika Django hanya akan mendukung 3.7 dan yang lebih baru, kami mungkin mempertimbangkan untuk menggunakan <code>contextvars</code> , tetapi itu akan membutuhkan banyak kerja di Django. </p><br><p>  Ini telah diselesaikan dengan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">asgiref</a> <code>Local</code> , yang kompatibel dengan coroutine dan utas.  Sekarang tidak menggunakan <code>contextvars</code> , tetapi kita dapat mengubahnya untuk bekerja dengan backport untuk 3,6 setelah beberapa pengujian. </p><br><p>  Di lain pihak, threadlocals sejati dapat terus bekerja di utas saat ini.  Namun, kita harus lebih berhati-hati untuk mencegah benda-benda tersebut bocor ke aliran lain;  ketika presentasi tidak lagi dieksekusi di utas yang sama, tetapi memunculkan utas untuk setiap panggilan ORM (selama fase "implementasi sinkron, pembungkus tidak sinkron"), beberapa hal yang mungkin dalam mode sinkron tidak akan mungkin dalam tidak sinkron. </p><br><p>  Ini akan membutuhkan perhatian khusus dan larangan beberapa operasi yang sebelumnya mungkin dalam mode asinkron;  Kasus-kasus yang kami ketahui dijelaskan di bawah ini di bagian tertentu. </p><br><h3 id="odnovremennaya-podderzhka-sinhronnogo-i-asinhronnogo-interfeysov">  Dukungan simultan untuk antarmuka sinkron dan asinkron </h3><br><p>  Salah satu masalah besar yang akan kita temui ketika mencoba port Django adalah bahwa Python tidak memungkinkan Anda untuk membuat versi fungsi yang sinkron dan asinkron dengan nama yang sama. </p><br><p>  Ini berarti Anda tidak bisa hanya mengambil dan membuat API yang berfungsi seperti ini: </p><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment">#   value = cache.get("foo") #   value = await cache.get("bar")</span></span></code> </pre> <br><p>  Ini adalah batasan yang disayangkan dari cara Python diimplementasikan secara asinkron, dan tidak ada solusi yang jelas.  Ketika sesuatu dipanggil, Anda tidak tahu apakah Anda akan menunggu atau tidak, jadi tidak ada cara untuk menentukan apa yang perlu dikembalikan. </p><br><p>  (Catatan: ini karena Python mengimplementasikan fungsi asinkron sebagai "callable sinkron yang mengembalikan coroutine," daripada sesuatu seperti "memanggil metode <code>__acall__</code> pada suatu objek." Manajer konteks dan iterator asinkron tidak memiliki masalah ini karena mereka memiliki metode terpisah <code>__aiter__</code> dan <code>__aenter__</code> .) </p><br><p>  Dengan mengingat hal ini, kita harus menempatkan ruang nama implementasi sinkron dan asinkron secara terpisah satu sama lain sehingga tidak bertentangan.  Kita bisa melakukan ini dengan argumen <code>sync=True</code> , tetapi ini mengarah pada kumpulan fungsi / metode yang membingungkan dan mencegah penggunaan <code>async def</code> , dan juga memungkinkan Anda untuk secara tidak sengaja lupa menulis argumen ini.  Panggilan acak ke metode sinkron ketika Anda ingin menyebutnya asinkron berbahaya. </p><br><p>  Solusi yang diusulkan untuk sebagian besar tempat di basis kode Django adalah untuk memberikan akhiran untuk nama-nama implementasi asinkron fungsi - sebagai contoh, <code>cache.get_async</code> sebagai tambahan dari <code>cache.get</code> sinkron.  Meskipun ini adalah solusi yang jelek, itu membuatnya sangat mudah untuk mendeteksi kesalahan saat melihat kode (Anda harus menggunakan <code>await</code> dengan metode <code>_async</code> ). </p><br><h3 id="predstavleniya-i-obrabotka-http">  Penanganan Tampilan dan HTTP </h3><br><p>  Tampilan mungkin merupakan landasan kegunaan asinkron, dan kami berharap sebagian besar pengguna memilih antara kode asinkron dan sinkron. </p><br><p>  Django akan mendukung dua jenis tampilan: </p><br><ul><li>  Representasi sinkron, didefinisikan, seperti sekarang, oleh fungsi atau kelas yang sinkron dengan <code>__call__</code> sinkron </li><li>  Representasi asinkron ditentukan oleh fungsi asinkron (mengembalikan coroutine) atau kelas dengan <code>__call__</code> asinkron. </li></ul><br><p>  Mereka akan ditangani oleh <code>BaseHandler</code> , yang akan memeriksa tampilan yang diterima dari penyelesai URL dan menyebutnya sesuai.  Handler dasar harus menjadi bagian pertama dari Django untuk menjadi asinkron, dan kita perlu memodifikasi handler WSGI untuk memanggilnya dalam event loop sendiri menggunakan <code>async_to_sync</code> . </p><br><p>  Lapisan perantara (middleware) atau pengaturan seperti <code>ATOMIC_REQUESTS</code> , yang membungkus tampilan dalam kode yang tidak asinkron secara aman (misalnya, blok <code>atomic()</code> ), akan terus berfungsi, tetapi kecepatannya akan terpengaruh (misalnya, larangan panggilan ORM paralel di dalam tampilan dengan <code>atomic()</code> ) </p><br><p>  Kelas <code>StreamingHttpResponse</code> ada akan dimodifikasi untuk dapat menerima iterator sinkron atau asinkron, dan kemudian implementasi internalnya akan selalu asinkron.  Demikian pula untuk <code>FileResponse</code> .  Karena ini merupakan titik ketidakcocokan mundur potensial untuk kode pihak ketiga yang secara langsung mengakses objek Respons, kita masih perlu menyediakan <code>__iter__</code> sinkron untuk periode transisi. </p><br><p>  WSGI akan terus didukung oleh Django tanpa batas waktu, tetapi handler WSGI akan melanjutkan untuk menjalankan middleware asinkron dan melihat dalam satu kali event loop.  Ini kemungkinan akan menyebabkan sedikit penurunan kinerja, tetapi dalam percobaan awal itu tidak memiliki dampak terlalu banyak. </p><br><p>  Semua fungsi HTTP asinkron akan bekerja di dalam WSGI, termasuk polling panjang dan respons lambat, tetapi mereka akan tidak seefisien sekarang, mengambil utas / proses untuk setiap koneksi.  Server ASGI akan menjadi satu-satunya yang secara efisien dapat mendukung banyak permintaan bersamaan, serta menangani protokol non-HTTP, seperti WebSocket, untuk digunakan oleh ekstensi seperti <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Channels</a> . </p><br><h3 id="promezhutochnye-sloi">  Lapisan menengah </h3><br><p>  Sementara bagian sebelumnya terutama berfokus pada jalur permintaan / respons, middleware membutuhkan bagian terpisah karena kompleksitas yang melekat dalam desain mereka saat ini. </p><br><p>  Middleware Django sekarang disusun dalam bentuk tumpukan di mana setiap middleware mendapatkan <code>get_response</code> untuk menjalankan middleware berikutnya dalam urutan (atau tampilan untuk middleware terendah pada tumpukan).  Namun, kita perlu mempertahankan campuran middleware sinkron dan asinkron untuk kompatibilitas, dan kedua jenis ini tidak akan dapat saling mengakses secara asli. </p><br><p>  Dengan demikian, untuk memastikan bahwa middleware berfungsi, kita harus menginisialisasi setiap middleware dengan get_response placeholder, yang sebaliknya mengembalikan kontrol kembali ke handler dan menangani transfer data antara middleware dan tampilan, dan pengecualian lemparan.  Di satu sisi, pada akhirnya akan terlihat seperti middleware dari era Django 1.0 dari sudut pandang internal, meskipun, tentu saja, API pengguna akan tetap sama. </p><br><p>  Kami dapat mendeklarasikan middleware sinkron yang sudah usang, tetapi saya sarankan tidak melakukan ini dalam waktu dekat.  Jika dan ketika kita sampai pada akhir siklus keusangannya, kita kemudian dapat mengembalikan implementasi middleware ke model tumpukan rekursif murni, seperti sekarang. </p><br><h3 id="orm">  ORM </h3><br><p>  ORM adalah bagian terbesar dari Django dalam hal ukuran kode dan yang paling sulit dikonversi menjadi asinkron. </p><br><p>  Hal ini sebagian besar disebabkan oleh fakta bahwa driver basis data yang mendasarinya sinkron dengan desain, dan kemajuan akan lambat menuju seperangkat driver basis data yang matang, standar, asinkron.  Sebagai gantinya, kita harus merancang masa depan di mana driver basis data pada awalnya akan sinkron, dan meletakkan dasar bagi kontributor yang selanjutnya akan mengembangkan driver asinkron dengan cara yang berulang-ulang. </p><br><p>  Masalah dengan ORM terbagi dalam dua kategori utama - utas dan pemblokiran implisit. </p><br><h4 id="potoki">  Streaming </h4><br><p>  Masalah utama dengan ORM adalah bahwa Django dirancang di sekitar objek <code>connections</code> global tunggal, yang secara ajaib memberi Anda koneksi yang tepat untuk utas Anda saat ini. </p><br><p>  Di dunia asinkron - di mana semua coroutine bekerja di utas yang sama - ini tidak hanya menjengkelkan, tetapi juga berbahaya.  Tanpa keamanan tambahan, pengguna yang mengakses ORM seperti biasa berisiko mematahkan objek koneksi dengan mengaksesnya dari beberapa tempat berbeda. </p><br><p>  Untungnya, objek koneksi setidaknya bersifat portable di antara utas, meskipun tidak dapat dipanggil dari dua utas secara bersamaan.  Django sudah peduli tentang keamanan utas untuk driver basis data dalam kode ORM, jadi kami memiliki tempat untuk mengubah perilakunya agar berfungsi dengan benar. </p><br><p>  Kami akan memodifikasi objek <code>connections</code> sehingga memahami coroutine dan utas - menggunakan kembali beberapa kode dari <code>asgiref.local</code> , tetapi dengan penambahan logika tambahan.  Koneksi akan dibagi dalam kode asinkron dan sinkron yang memanggil satu sama lain - dengan konteks melewati <code>sync_to_async</code> dan <code>async_to_sync</code> - dan kode sinkron akan dipaksa untuk dieksekusi secara berurutan dalam satu untaian lengket, jadi ini tidak akan berfungsi pada saat yang sama melanggar keamanan benang. </p><br><p>  Ini menyiratkan bahwa kita memerlukan solusi seperti manajer konteks untuk membuka dan menutup koneksi database, seperti <code>atomic()</code> .  Ini akan memungkinkan kami untuk memberikan panggilan yang konsisten dan lengket utas dalam konteks ini dan memungkinkan pengguna untuk membuat beberapa konteks jika mereka ingin membuka beberapa koneksi.  Ini juga memberi kita cara potensial untuk menyingkirkan <code>connections</code> global magis jika kita ingin mengembangkan ini lebih lanjut. </p><br><p>  Saat ini, Django tidak memiliki manajemen siklus hidup koneksi yang independen dari sinyal dari kelas handler, dan oleh karena itu kami akan menggunakannya untuk membuat dan menghapus "konteks koneksi" ini.  Dokumentasi juga akan diperbarui untuk memperjelas cara menangani koneksi dengan benar di luar siklus permintaan / respons;  bahkan dalam kode saat ini, banyak pengguna tidak tahu bahwa tim manajemen lama mana pun harus secara berkala memanggil <code>close_old_connections</code> agar berfungsi dengan benar. </p><br><p>  Kompatibilitas mundur berarti bahwa kami harus mengizinkan pengguna mengakses <code>connections</code> dari sembarang kode acak kapan saja, tetapi kami hanya akan mengizinkan ini untuk kode sinkron;  kami akan memastikan bahwa kode tersebut dibungkus dalam "konteks koneksi", jika asinkron, mulai hari pertama. </p><br><p>  Mungkin sepertinya akan menyenangkan untuk menambahkan <code>transaction.atomic()</code> di samping <code>transaction.atomic()</code> dan mengharuskan pengguna untuk menjalankan semua kode di dalam salah satu dari mereka, tetapi ini dapat menyebabkan kebingungan tentang apa yang terjadi jika Anda melampirkan salah satunya ada di dalam yang lain. </p><br><p>  Alih-alih, saya sarankan untuk membuat manajer konteks baru <code>db.new_connections()</code> yang memungkinkan perilaku ini, dan membuatnya membuat koneksi baru setiap kali dipanggil, dan memungkinkan sembarang <code>atomic()</code> bersarang di dalamnya. </p><br><p>  Setiap kali Anda <code>new_connections()</code> blok <code>new_connections()</code> , Django membuat konteks baru dengan koneksi database baru.  Semua transaksi yang dilakukan di luar blok berlanjut;  setiap panggilan ORM di dalam blok berfungsi dengan koneksi baru ke database dan akan melihat database dari sudut pandang ini.  Jika isolasi transaksi diaktifkan dalam database, seperti yang biasanya dilakukan secara default, ini berarti bahwa koneksi baru di dalam blok mungkin tidak melihat perubahan yang dilakukan oleh transaksi yang tidak berkomitmen di luarnya. </p><br><p>  Selain itu, koneksi di dalam blok <code>new_connections</code> ini sendiri dapat menggunakan <code>atomic()</code> untuk memicu transaksi tambahan pada koneksi baru ini.  Setiap sarang dari dua konteks manajer ini diperbolehkan, tetapi setiap kali <code>new_connections</code> digunakan, transaksi yang dibuka sebelumnya "ditangguhkan" dan tidak mempengaruhi panggilan ORM sampai blok <code>new_connections</code> baru baru <code>new_connections</code> . </p><br><p>  Contoh tampilan API ini: </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_authors</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(pattern)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-comment"><span class="hljs-comment"># Create a new context to call concurrently async with db.new_connections(): return [ author.name async for author in Authors.objects.filter(name__icontains=pattern) ] async def get_books(pattern): # Create a new context to call concurrently async with db.new_connections(): return [ book.title async for book in Book.objects.filter(name__icontains=pattern) ] async def my_view(request): # Query authors and books concurrently task_authors = asyncio.create_task(get_authors("an")) task_books = asyncio.create_task(get_books("di")) return render( request, "template.html", { "books": await task_books, "authors": await task_authors, }, )</span></span></code> </pre> <br><p>  Ini agak bertele-tele, tetapi tujuannya juga untuk menambahkan pintasan tingkat tinggi untuk mengaktifkan perilaku ini (dan juga mencakup transisi dari <code>asyncio.ensure_future</code> dengan Python 3.6 ke <code>asyncio.create_task</code> di 3.7). </p><br><p>  Menggunakan manajer konteks ini dan aliran sticky dalam konteks koneksi yang sama, kami menjamin bahwa semua kode akan seaman yang kami bisa secara default.  ada kemungkinan bahwa pengguna dapat menggunakan koneksi dalam satu utas untuk dua bagian berbeda dari permintaan menggunakan <code>yield</code> , tetapi ini <code>yield</code> mungkin sekarang. </p><br><h4 id="neyavnye-blokirovki">  Kunci implisit </h4><br><p>  Masalah lain dari desain ORM saat ini adalah bahwa operasi pemblokiran (terkait jaringan), khususnya bidang terkait bacaan, ditemui dalam contoh model. </p><br><p>  Jika Anda mengambil contoh model dan kemudian mengakses <code>model_instance.related_field</code> , Django akan memuat konten model terkait secara transparan dan mengembalikannya kepada Anda.  Namun, ini tidak mungkin dalam kode asinkron - kode pemblokiran tidak boleh dieksekusi di utas utama, dan tidak ada akses asinkron ke atribut. </p><br><p>  Untungnya, Django sudah memiliki jalan keluar dari hal ini - <code>select_related</code> , yang memuat bidang terkait sebelumnya, dan <code>prefetch_related</code> untuk banyak-ke-banyak hubungan.  Jika Anda menggunakan ORM secara tidak sinkron, kami akan melarang operasi apa pun yang secara implisit memblokir, seperti akses latar belakang ke atribut, dan sebagai gantinya mengembalikan kesalahan yang menunjukkan bahwa Anda harus terlebih dahulu mengambil bidang. </p><br><p>  Ini memiliki manfaat tambahan untuk mencegah kode lambat yang mengeksekusi permintaan N dalam loop <code>for</code> , yang merupakan kesalahan umum banyak programmer Django baru.  Ini memunculkan penghalang entri, tetapi ingat bahwa Django asinkron akan menjadi opsional - pengguna masih dapat menulis kode sinkron jika mereka mau (dan ini akan didorong dalam tutorial, karena kode sinkron jauh lebih sulit untuk membuat kesalahan). </p><br><p>  <code>QuerySet</code> , untungnya, dapat dengan mudah mengimplementasikan generator asinkron dan secara transparan mendukung sinkronisasi dan asinkron: </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">view</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(request)</span></span></span><span class="hljs-function">:</span></span> data = [] <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> user <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> User.objects.all(): data.append(<span class="hljs-keyword"><span class="hljs-keyword">await</span></span> extract_important_info(user)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> render(<span class="hljs-string"><span class="hljs-string">"template.html"</span></span>, data)</code> </pre> <br><h4 id="drugoe">  Lainnya </h4><br><p>  Bagian ORM yang terkait dengan perubahan skema tidak akan tidak sinkron;  mereka harus dipanggil hanya dari tim manajemen.  Beberapa proyek sudah memanggil mereka dalam pengiriman, tetapi ini bukan ide yang baik. </p><br><h3 id="shablony">  Pola </h3><br><p>  Template sekarang sepenuhnya sinkron, dan rencananya adalah membiarkannya seperti itu di langkah pertama.     ,      ,     DEP. </p><br><p>  ,  Jinja2   ,              . </p><br><p>  ,         Django     ,       .  Jinja2       ,    ,        ,    . </p><br><p>       ,     <code>render_async</code> ,   <code>render</code> ;      ,   ,        . </p><br><h3 id="keshirovanie">  </h3><br><p>    Django      —     <code>_async</code> -  (, <code>get_async</code> , <code>set_async</code> ). </p><br><p>   ,       API  <code>sync_to_async</code> ,    <code>BaseCache</code> . </p><br><p> ,     thread-safety   API ,   Django,        ,       .    ,     ORM, ,      . </p><br><h3 id="formy">  </h3><br><p>         ,        ,    ,     <code>ModelForm</code>  ORM     . </p><br><p>  ,   -   <code>clean</code>  <code>save</code> ,  ,   . ,      ,  ,                         DEP. </p><br><h3 id="email"> Email </h3><br><p>         Django,      .    <code>send_mail_async</code>  <code>send_mail</code> ,   <code>async</code> -        (, <code>mail_admins</code> ). </p><br><p>         Django  ,    -  SMTP,     .  , ,      ,      ,   . </p><br><h3 id="testirovanie">  Pengujian </h3><br><p>     ,      Django  . </p><br><p>     ASGI-     <code>asgiref.testing.ApplicationCommunicator</code> .             assert'  . </p><br><p>    Django        ,    ,      .  ,      —     ,    ,        HTTP    event loop,    WSGI. </p><br><p>                .  ,      ,      . </p><br><p>   ,     ,      .       <code>async def</code>    <code>@async_to_sync</code> ,       , ,    Django test runner. </p><br><p>        asyncio (   loop'  ,    )   , , ,   <code>DEBUG=True</code> .          —   ,       ,       . </p><br><h3 id="websockets"> WebSockets </h3><br><p>       Django;      ,   Channels   ,        ASGI,      . </p><br><p>    ,         Channels,        ,     ASGI. </p><br><h3 id="poryadok-deystviy">   </h3><br><p>      ,     ,   .       ,          . </p><br><p>   ,                .         ,       —         . </p><br><p>  ,      ,              .    ,   ORM,       ,  ,          . </p><br><p>   : </p><br><ul><li><p>   (  3.0) </p><br><ul><li>  HTTP,     (    ) </li><li>  async       ORM </li><li>    </li></ul><br></li><li><p>   (  3.1) </p><br><ul><li> ORM (     ) </li><li>  (     ) </li><li>  (     ) </li></ul><br></li><li><p>    </p><br><ul><li> ORM (       ) </li><li>  (    ) </li><li> Email </li><li>  </li></ul><br></li></ul><br><p>          ;      ,    .     ,   ,       , ,            . </p><br><p>   ,      -   ;            ,     ,        .    ,      ,  Django,     Django  async-only . </p><br><p>    ,  ,    DEP  ,   , , email  .         DBAPI —  ,        core Python , , PEP,         . </p><br><h2 id="motivaciya">  </h2><br><p>     ,  , ,    .   Django      ,   -       ,    -;             . </p><br><p>          ,      - .         ,   —  ,       ,       . </p><br><p>          Python —   . -  Python       ,     ,       . </p><br><p>  Python            <code>asyncio</code> ,       ,         .     ,     ,     ,  ,      Django-size   . </p><br><h3 id="chto-eto-dayot">    </h3><br><p>       Django,     «»;    ,    ,      — ,      Django —     . </p><br><p>     ,       .      ,    API     ,   Django      -   . </p><br><p>      ,      ,  Django     .             ,    Django ORM ,     ,    ,      -. </p><br><p>  ,   , —             .    -   long-poll   server-sent events.  Django          ,    -      . </p><br><h3 id="sinhronnost-vsyo-eschyo-imeet-znachenie">      </h3><br><p>     <em></em>    Django;         .   ,  ,             ,          . </p><br><p> Django          ,    .    ;  Django-   ,         ,  ,     ,     ,     . </p><br><p>      ,       --  Django      . </p><br><h3 id="obratnaya-sovmestimost">   </h3><br><p>  ,    .      « Django»,       ;     ,        ,          . </p><br><p>  ,      ,     ,        ,    API Django,      ,      ,    Python 3,        API,        Django  Python. </p><br><h3 id="pomosch-python">  Python </h3><br><p> Python     .           Python,  ,    ,     . </p><br><p>   , Django —   - Python   —   ,    Python,        Python   .      ,       ,    ,        . </p><br><h3 id="privlechenie-novyh-uchastnikov">    </h3><br><p>      ,   Django,              .   ,  Django   ,       . </p><br><p>                   —  ,  ,    ,   ,        . </p><br><p>  ,      —      ,   , —               Django (     ,       Python  ). </p><br><h3 id="chto-takoe-django">   Django? </h3><br><p>      ,   Django.   ,        <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Lawrence Journal-World</a>    —    ,  , SPA —  , ,    .  , ,   ,     ,     . </p><br><p>    ,   Django   ,   - ,    —        —     . , ,        ; ,     Django    , . </p><br><p>   ,     Django     .     ,       .    ,         ,    ,    — ,        ,   . </p><br><h2 id="obosnovanie">  </h2><br><p>    Django       django-developers   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="> </a>    ,        ,  ,   ,   DEP. </p><br><p>      , ,   ,      : </p><br><ul><li> :       master-        Django    . </li><li>  :     Django    ,    ,    ,     ,      Django       . </li><li> :    ,    ,      Django,   ,  Django.     ,   ,   ,      ,  . </li></ul><br><p>    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Channels</a>          DEP ;        Django      ,  . </p><br><p>   ,   ,     .  DEP    ,   ,       —      Django           . </p><br><p>                 .     Django, ,     ,    WSGI    ,    event loop     ,      .         10%   —     ,      .     ,      . </p><br><p>     ,  ,      (-  ,   Python    ).    ,     Django      ;     ,   ,     ,   Django   master-    . </p><br><p>  ,           ( ORM,    ..),      ;                 Python. </p><br><p>        ,      ,        Django,     «»  .   ,      ,              ,  ,     . </p><br><h3 id="alternativy">  Alternatif </h3><br><p>       ,   ,  , . </p><br><h4 id="asinhronnye-moduli-vmesto-_async-funkciy">    _async  </h4><br><p>        ,    ,     (, <code>django.core.cache.cache.get_async</code> ),               : </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> django.core.cache_async <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> cache cache.get(<span class="hljs-string"><span class="hljs-string">"foo"</span></span>)</code> </pre> <br><p>   ,           ;   ,    ,        . </p><br><p>   ,    ,      ;       . </p><br><h4 id="fork-django">  Django </h4><br><p> -   ,      ;  ,        ,       ,       —  . </p><br><p>           ,   ,     , —   ,      . </p><br><h4 id="rasshirenie-channels">  Channels </h4><br><p>    ,    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Channels</a>      , «»  Django. ,     -     ,  ,         Django;      ORM,   HTTP/middleware flow    . </p><br><h4 id="ne-asyncio">  asyncio </h4><br><p>      event loop'  Python,   <code>asyncio</code>          ,   Django.   <code>await</code>  <code>async</code>  Python     event loop   . </p><br><p>   ,   <code>asyncio</code> ,     ; Django     ,        ,   .         Django        ;    , ,      async runtime,    ,    . </p><br><h4 id="greenletsgevent"> Greenlets/Gevent </h4><br><p>       Gevent,      ,      Python. </p><br><p>        ,       .   <code>yield</code>  <code>await</code> ,   API,    Django,       ,         .               ,     . </p><br><p>   ,      ,  ,     .      greenlet-safe   Django ORM   -   new-connection-context,  . </p><br><p>  ,      .   Django     « »    gevent, , ,      ,   . </p><br><h2 id="finansirovanie">  </h2><br><p>             DEP. </p><br><p>   ,        —        , —     ,             (   ). </p><br><p>  ,       ,  -           .    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Django Fellows</a>  ;     —   ,           (  ), ,   ,  - . </p><br><p>       — ,   Kickstarter  <code>migrations</code>  <code>contrib.postgres</code> ,    MOSS (Mozilla)  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Channels</a> .   ,   Django,  ,          . </p><br><p>     , <em></em>     .  —      Python,    Django —    —       .        ,     Django/async,        . </p><br><p>                HTTP/middleware/view flow,     ,  ,  ,      « »,      . </p><br><p>     ,     ,     ,            (   ,  Fellows, /     ,     Channels,       ,   ),   ,       . </p><br><p>         ,         ,   ,        ,       Django,      . </p><br><h2 id="obratnaya-sovmestimost-1">   </h2><br><p> , ,   ,       ,            API. </p><br><p>   , ,        ,  , HTTP/middleware flow. ,    API,       APM,     . </p><br><p>  ,  ,   Django     ,     ,      .  ,   ORM  , ,   —      ,  ORM             . </p><br><h2 id="etalonnaya-realizaciya">   </h2><br><p>  DEP  ,    ;       Django      . </p><br><p>   ,       <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">asgiref</a> ,       ,         .      Django         Django. </p><br><p>       <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Channels</a> ,         Django,          Django. </p><br><h2 id="avtorskie-prava">   </h2><br><p>   <em>(  )</em>       <a href="">CC0 1.0 Universal</a> . </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id461493/">https://habr.com/ru/post/id461493/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id461471/index.html">.NET - Alat untuk bekerja dengan multithreading dan asynchrony - Bagian 2</a></li>
<li><a href="../id461473/index.html">Algoritma debugging pada grafik - sekarang dengan gambar</a></li>
<li><a href="../id461475/index.html">AMA dengan Habr. 1011</a></li>
<li><a href="../id461483/index.html">Openstack Load Balancing</a></li>
<li><a href="../id461487/index.html">Tugas CTF Mini</a></li>
<li><a href="../id461497/index.html">Render teks modern di Linux: bagian 1</a></li>
<li><a href="../id461499/index.html">Bahasa apa yang akan diterjemahkan gim Anda di 2019</a></li>
<li><a href="../id461501/index.html">Mengapa di AS mereka sedang menyelidiki pekerjaan perusahaan IT besar</a></li>
<li><a href="../id461503/index.html">Membuat database tersedia untuk koneksi jarak jauh</a></li>
<li><a href="../id461505/index.html">8 bug dari pengembang JavaScript pemula yang mencegah Anda menjadi profesional</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>