<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨🏻‍🚀 ✔️ 👴🏿 So überwachen Sie einfach den Status der Site 😁 👨‍🌾 🧗🏼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Um die Leistung von Servern aus der Ferne zu überwachen, verwenden Fachleute spezielle Softwaresysteme wie Zabbix oder Icinga . Wenn Sie jedoch ein un...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>So überwachen Sie einfach den Status der Site</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/439894/"> Um die Leistung von Servern aus der Ferne zu überwachen, verwenden Fachleute spezielle Softwaresysteme wie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Zabbix</a> oder <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Icinga</a> .  Wenn Sie jedoch ein unerfahrener Eigentümer oder Administrator einer oder zweier Websites mit geringer Last sind, sind keine großen Überwachungssysteme erforderlich.  Der Hauptparameter ist, ob die Site Benutzer schnell bedient.  Daher können Sie die Arbeit der Site mit einem einfachen Programm von jedem mit dem Internet verbundenen Computer aus überwachen. <br><br><img src="https://habrastorage.org/webt/qx/fj/tq/qxfjtqd07g37gx2eq8ksz80wtfm.jpeg" alt="Foto von Mikhail Vasiliev, Unsplash.Com" title="Foto von Mikhail Vasiliev, Unsplash.Com"><br><br>  Schreiben wir jetzt dieses Skript - die einfachste Überwachung der Verfügbarkeit und Geschwindigkeit der Website.  Dieses Programm kann auf einem Heimcomputer, einem Smartphone usw. ausgeführt werden.  Das Programm hat nur zwei Funktionen: <br><br><ul><li>  zeigt auf dem Bildschirm die Zeit an, in der Ihre Website Benutzerseiten bereitstellt. </li><li>  Bei langsamen Antworten der Site oder Fehlern schreibt das Programm Daten in eine Datei (ein „Protokoll“ oder eine Protokolldatei).  Diese Daten sollten von Zeit zu Zeit überprüft werden, um Probleme zu beheben, wenn sie gerade erst beginnen.  Daher werden wir darauf achten, diese Protokolle in einer übersichtlichen, bequemen Form für eine schnelle Anzeige aufzuzeichnen. </li></ul><br>  Ich werde jeden Schritt im Detail beschreiben, damit selbst Anfänger, die mit dem Schreiben von Batch-Dateien (bat und cmd unter DOS und Windows, sh auf Systemen wie UNIX) nur wenig vertraut sind, dies problemlos herausfinden und das Skript an seine Bedürfnisse anpassen können.  <b>Ich bitte Sie jedoch, dieses Skript nicht gedankenlos zu verwenden, da es bei falscher Verwendung möglicherweise nicht zu den richtigen Ergebnissen führt und außerdem viel Verkehr verschlingt</b> . <br><br>  Ich werde ein Skript für ein Betriebssystem wie Linux und dessen Verwendung auf einem Heimcomputer beschreiben.  Nach den gleichen Prinzipien kann dies auf anderen Plattformen erfolgen.  Und für diejenigen, die nur die Möglichkeiten von Linux betrachten, mag ein weiteres Beispiel interessant sein, was für ein einfaches und leistungsfähiges Werkzeug seine Skripte sind. <br><a name="habracut"></a><br><h3>  1. Organisation zuerst </h3><br>  Wir werden einen separaten Ordner für dieses Programm erstellen und 3 Dateien darin erstellen.  Zum Beispiel habe ich diesen Ordner / home / me / Progs / iNet / monitor (hier ist me der Name meines Benutzers, Progs / iNet ist mein Ordner für Programme im Zusammenhang mit dem Internet, und monitor ist der Name dieses Programms aus dem Wort monitor, d. H. Da ich der einzige Benutzer dieses Computers bin, speichere ich solche Dateien in meinen persönlichen Ordnern (/ home) in einem separaten Abschnitt der Festplatte, sodass ich sie bei der Neuinstallation des Systems speichern kann.  In diesem Ordner befinden sich Dateien: <br><br><ul><li>  README.txt - hier ist eine Beschreibung (im Falle von Sklerose): welche Art von Programm, Hintergrundinformationen dazu usw. </li><li>  mon.sh - Es wird ein Programm geben, das die Site abfragt. </li><li>  server.log - hier werden Site-Statusanzeigen aufgezeichnet.  In unserem Fall ist dies einfach das Datum, die Uhrzeit und die Dauer der Antwort der Site (plus zusätzliche Informationen, wenn der Server mit unserer Anfrage mit einem Fehler antwortet). </li></ul><br>  (Um das Bearbeiten und Wiederherstellen von Dateien zu vereinfachen, können Sie diesen Ordner in das Git-Versionskontrollsystem aufnehmen. Hier werde ich ihn nicht beschreiben.) <br><br><h3>  2. Beharrlich und entspannt </h3><br>  Wir werden die Datei mon.sh mit einem regelmäßigen kleinen Intervall ausführen, zum Beispiel 60 Sekunden.  Ich habe das vom Betriebssystem bereitgestellte Standardtool verwendet (genauer gesagt die Desktop-Umgebung). <br><br>  Meine Desktop-Umgebung ist Xfce.  Dies ist eine der beliebtesten Optionen für Linux.  Ich mag Xfce, weil Sie damit die gesamte Umgebung fast vollständig anpassen können - ganz nach Ihren Wünschen.  Gleichzeitig ist Xfce etwas kompakter und schneller als zwei andere bekannte Systeme - Gnome und KDE.  (Andere Optionen sind ebenfalls interessant - zum Beispiel ist die LXDE-Umgebung noch schneller und einfacher als Xfce, aber bisher nicht so reich an Funktionen). <br><br>  Das Tool, das wir im Fall von Xfce benötigen, ist ein Plug-In für das Arbeitsfeld Generic Monitor.  Normalerweise ist es bereits installiert, aber wenn nicht, kann der Installer es leicht finden: "Genmon" (Beschreibung: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">xfce4-genmon-plugin</a> ).  Dies ist ein Plugin, das dem Panel hinzugefügt und in den Einstellungen festgelegt werden kann: (1) der auszuführende Befehl und (2) die Häufigkeit seiner Ausführung in Sekunden.  In meinem Fall der Befehl: <br><br>  /home/me/Progs/iNet/monitor/mon.sh <br><br>  (oder gleichwertig ~ / Progs / iNet / monitor / mon.sh). <br><br><img src="https://habrastorage.org/webt/2w/pc/sz/2wpcszhqlfhyao4_qg6bpkrillw.png" alt="Genmon" title="Genmon"><br><br><h3>  3. Wenn das Programm noch nicht vorhanden ist, liegen bereits Fehler vor </h3><br>  Wenn Sie nun alle diese Schritte ausgeführt haben - Dateien erstellt und das Plug-In im Bedienfeld gestartet -, sehen Sie das Ergebnis des Startens unseres Programms dort (Fehlermeldung: Datei mon.sh ist kein Programm).  Um die Datei ausführbar zu machen, gehen Sie zu unserem Ordner und legen Sie die Berechtigung zum Ausführen fest - <ul><li>  oder Dateimanager: Eigenschaften - Berechtigungen - Diese Datei kann als Programm ausgeführt werden. </li><li>  oder ein Befehl vom Terminal: <b>chmod 755 mon.sh</b> </li></ul><br>  Und in die Datei selbst schreiben wir die ersten Zeilen: <br><br><pre><code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#!/bin/bash # Monitor server responses (run this every 60 seconds): # info=$(curl -I -o /dev/stdout -w '%{time_total}' --url https://example.ru/ -m 9 -s) errr=$(echo $?)</span></span></code> </pre> <br>  Anstelle von "example.ru" ersetzen Sie den Namen Ihrer Site, deren Status Sie beobachten werden.  Und wenn es auf http funktioniert, setzen Sie http anstelle von https.  Die Zeile #! / Bin / bash bedeutet, dass dies ein Skript ist, das vom Bash-Programm gestartet werden soll ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">bash</a> ist wahrscheinlich das häufigste Skript zum Ausführen von Skripten unter Linux).  Um eine andere Shell zu bearbeiten, wird diese anstelle von Bash angezeigt.  Die restlichen Zeilen mit einem scharfen am Anfang sind Kommentare.  Die erste Codezeile selbst lautet <b>info = $ ()</b> und in diesen Klammern steht der Befehl curl mit Parametern.  Eine solche Konstruktion - etwas = $ (etwas) - bedeutet "den Befehl in Klammern ausführen und das Ergebnis der Variablen auf der linken Seite zuweisen".  In diesem Fall habe ich die Variable "info" genannt.  Dieser Befehl in Klammern - curl (im Jargon, der von einigen als "Kurl" bezeichnet wird) - sendet eine Anfrage an das Netzwerk unter der angegebenen Adresse und gibt die Serverantwort an uns zurück.  (Mein Bekannter erklärte: "Wie der Kran grunzt - und eine Antwort von einem anderen Kran am Himmel erhält.")  Betrachten Sie die Optionen: <br><br><pre> <code class="bash hljs">curl -I -o /dev/stdout -w <span class="hljs-string"><span class="hljs-string">'%{time_total}'</span></span> --url https://example.ru/ -m 9 -s</code> </pre><br>  <b>-Ich</b> bedeutet, dass wir nicht die gesamte Seite anfordern, sondern nur die "HTTP-Header".  Jedes Mal benötigen wir nicht den gesamten Seitentext, um sicherzustellen, dass die Website funktioniert.  Da wir die Site häufig überprüfen, ist es wichtig, die Größe der übertragenen Daten so klein wie möglich zu halten.  Dies spart sowohl Verkehr als auch Strom und die Belastung des Servers - und der Tierwelt. <br><br>  Achten Sie übrigens darauf, wie viel freien Datenverkehr Sie (nicht pro Monat verwendet) auf dem Hosting haben.  Unten sehen Sie, wie viele Daten übertragen werden, und Sie können berechnen, ob Sie über genügend Reserven verfügen.  Wenn überhaupt, kann der Überprüfungszeitraum des Standorts auf 5, 10 oder sogar 30-60 Minuten erhöht werden.  Obwohl in diesem Fall das Bild nicht so vollständig ist - und kleinere Unterbrechungen möglicherweise unbemerkt bleiben;  Im Allgemeinen ist es jedoch bei der Überwachung eines Standorts wichtiger, langfristige Probleme zu erkennen als eine einzelne Unterbrechung.  Welchen Datenverkehr können Sie sich auf dem anrufenden Computer leisten?  In meinem Fall - einem Desktop-PC mit unbegrenztem Datenverkehr - ist dies nicht so wichtig.  Für ein mobiles Gerät oder einen Tarif mit Grenzwerten lohnt es sich jedoch, die Inspektionsintervalle zu berechnen und möglicherweise zu verlängern. <br><br><h3>  4. Schritt folgt Schritt mit Ausnahme des ersten Schritts </h3><br>  Gehen wir weiter: <b>-o / dev / stdout</b> bedeutet "Senden Sie die von Kurl vom Server empfangene Antwort an diese und jene Datei".  In diesem Fall handelt es sich nicht um eine Datei auf der Festplatte, sondern um / dev / stdout - Standardausgabegerät.  Normalerweise ist das "Standardausgabegerät" unser Bildschirm, auf dem wir die Ergebnisse des Programms sehen können.  Im Skript leiten wir diese „Standardausgabe“ jedoch häufig zur weiteren Verarbeitung (jetzt - speichern Sie sie in der Info-Variablen).  Und dann senden wir meistens entweder die Ergebnisse der Teams an Variablen oder geben sie an die nächsten Teams in einer Kette weiter.  Verwenden Sie zum Erstellen von Ketten aus Befehlen den Pipe-Operator ("Pipe"), der als vertikaler Balken ("|") angezeigt wird. <br><br>  <b>-w '% {time_total} eyayu'</b> : hier bedeutet -w "formatieren und solche und solche zusätzlichen Informationen an ein Standardausgabegerät weitergeben".  Insbesondere interessiert uns time_total - wie viel Zeit die Anfrage-Antwort-Übertragung zwischen uns und dem Server in Anspruch genommen hat.  Sie wissen wahrscheinlich, dass es einen einfacheren Befehl gibt, Ping, um schnell einen Server anzufordern und eine Antwort von ihm zu erhalten, Pong.  Ping überprüft jedoch nur, ob der Hosting-Server aktiv ist, und das Signal geht so lange hin und her.  Dies zeigt die maximale Zugriffsgeschwindigkeit an, sagt jedoch noch nichts darüber aus, wie schnell die Website echten Inhalt produziert.  Ping kann schnell funktionieren, und gleichzeitig kann die Site langsamer oder gar nicht funktionieren - aufgrund hoher Auslastung oder interner Probleme.  Daher verwenden wir genau Kurla und erhalten die tatsächliche Zeit, zu der der Server unsere Inhalte anzeigt. <br><br>  (Anhand dieses Parameters können Sie beurteilen, ob der Server für Ihre Aufgaben effizient arbeitet und ob die typische Antwortzeit für Benutzer günstig ist. Gibt es keine Probleme? Beispielsweise haben sich meine Websites auf vielen Hosting-Websites im Laufe der Zeit verlangsamt, und ich musste nach einem anderen Hosting suchen.) <br><br>  Haben Sie die seltsamen Buchstaben "eyu" nach {time_total} bemerkt?  Ich habe sie als eindeutige Bezeichnung hinzugefügt, die wahrscheinlich nicht in den vom Server an uns gesendeten Headern enthalten ist (obwohl davon ausgegangen wird, dass die Benutzer Ihrer Programme schlecht sind und nicht und der Weg in den Abgrund. Tun Sie dies nicht! .. Oder wenn Sie dies tun , schäme dich wenigstens für dich).  Mit diesem Label (ich hoffe) können wir dann einfach die Informationen, die wir benötigen, aus einer ganzen Reihe von Zeilen in der Info-Variablen ziehen.  <b>Curl -w '% {time_total} ehayu'</b> (mit den verbleibenden korrekten Parametern) gibt uns also etwas wie: <br><br>  0,215238eyayu <br><br>  Dies ist die Anzahl der Sekunden, die für den Zugriff auf die Website benötigt wurden, sowie unser Etikett.  (Zusätzlich zu diesem Parameter interessiert uns in der Info-Variablen hauptsächlich der „Statuscode“ - der Statuscode oder einfach der Server-Antwortcode. Wenn der Server die angeforderte Datei ausgibt, lautet der Code normalerweise „200“. Wenn die Seite nicht gefunden wird Dies ist der berühmte 404. Wenn auf dem Server Fehler auftreten, sind es meistens 500 mit etwas). <br><br><img src="https://habrastorage.org/webt/ka/rc/nk/karcnk8ggbptl5raex3j67k_aea.jpeg" alt="404" title="404"><br><br><h3>  5. Kreativität - der Vater der Selbstprüfung </h3><br>  Die verbleibenden Parameter unserer Locke sind wie folgt: <br><br><pre> <code class="bash hljs">--url https://example.ru/ -m 9 -s</code> </pre> <br>  was es bedeutet: eine solche Adresse anzufordern;  Die maximale Antwortzeit beträgt 9 Sekunden (Sie können weniger festlegen, da ein seltener Benutzer so lange auf eine Antwort von der Site wartet, dass er schnell feststellt, dass die Site nicht funktioniert).  Und "-s" bedeutet still, das heißt, Curl sagt uns keine unnötigen Details. <br><br>  Übrigens ist auf dem Desktop-Panel normalerweise nicht viel Platz vorhanden. Zum Debuggen eines Skripts ist es daher besser, es vom Terminal aus auszuführen (in seinem Ordner mit dem Befehl ./mon.sh).  Und für unser Panel-Plugin machen wir eine lange Pause zwischen den Starts des Befehls - beispielsweise 3600 Sekunden. <br><br>  Zum Debuggen können wir diese Locke ohne Rahmenklammern ausführen und sehen, was sie erzeugt.  (Daraus und berechnen Sie den Verkehrsverbrauch).  Wir werden hauptsächlich eine Reihe von HTTP-Headern sehen, wie zum Beispiel: <br><br><pre> <code class="plaintext hljs">HTTP/1.1 302 Found Server: QRATOR Date: Sun, 11 Feb 2019 08:06:57 GMT Content-Type: text/html; charset=UTF-8 Connection: keep-alive Keep-Alive: timeout=15 X-Powered-By: PHP/7.2.14-1+ubuntu16.04.1+deb.sury.org+1 Location: https://habr.com/ru/ X-Frame-Options: SAMEORIGIN X-Content-Type-Options: nosniff Strict-Transport-Security: max-age=63072000; includeSubDomains; preload X-Cache-Status: HIT 0.033113</code> </pre><br>  In der ersten Zeile sehen wir "HTTP / 1.1 302 gefunden" - was bedeutet: Das Datenübertragungsprotokoll ist "HTTP / 1.1", der Server-Antwortcode ist "302 gefunden".  Wenn Sie eine andere Seite anfordern, kann dies der Code "301 dauerhaft verschoben" usw. sein.  In einem weiteren Beispiel lautet die normale Antwort meines Servers "HTTP / 2 200".  Wenn Ihr Server normalerweise anders reagiert, ersetzen Sie ihn durch diese Antwort anstelle von "HTTP / 2 200" in diesem Skript. <br><br>  Wie wir sehen, gibt Kurl in der letzten Zeile an, in wie vielen Sekunden wir die Serverantwort mit unserem zugewiesenen Etikett erhalten haben. <br><br>  Interessant: Wir können die Site so konfigurieren, dass sie über unsere Anforderungen berichtet (und nur über diese!). Zusätzliche Informationen zu ihrem Status - zum Beispiel im "hausgemachten" HTTP-Header.  Angenommen, die Prozessoren der Site sind ausgelastet, wie viel freier Speicher und Speicherplatz vorhanden sind und wie schnell die Datenbank arbeitet.  (Dazu muss die Site natürlich dynamisch sein, dh Anforderungen müssen vom Programm verarbeitet werden - in PHP, Node.JS usw. Eine andere Option ist die Verwendung spezieller Software auf dem Server).  Aber vielleicht brauchen wir diese Details noch nicht wirklich.  Der Zweck dieses Skripts besteht lediglich darin, die Gesamtleistung der Site regelmäßig zu überwachen.  Bei Problemen werden wir uns bereits auf andere Weise mit der Diagnose befassen.  Daher schreiben wir jetzt das einfachste Skript, das für jede Site funktioniert, auch für ein statisches, und ohne zusätzliche Einstellungen auf dem Server.  Falls gewünscht, können Sie in Zukunft die Funktionen des Skripts erweitern.  Machen Sie in der Zwischenzeit die Basis. <br><br>  Der String <b>errr = $ (echo $?) Bedeutet</b> : Schreiben Sie das Ergebnis des Befehls "echo $?" In die Variable errr.  Der Befehl echo bedeutet, dass Text auf dem Standardausgabegerät (stdout) und die Zeichen "$?"  - Dies ist der aktuelle Fehlercode (vom vorherigen Befehl übrig).  Wenn unsere Locke den Server plötzlich nicht mehr erreichen kann, wird ein Fehlercode ungleich Null ausgegeben, und wir werden dies durch Überprüfen der errr-Variablen herausfinden. <br><br><h3>  6. Zweckmäßigkeit </h3><br>  Hier möchte ich einen kleinen Exkurs von technischen Fragen machen, um das Lesen des Textes interessanter zu machen.  (Wenn Sie nicht einverstanden sind, überspringen Sie drei Absätze).  Ich werde sagen, dass jede menschliche Aktivität auf ihre eigene Weise angemessen ist.  Selbst wenn eine Person absichtlich ihre Stirn gegen eine Wand schlägt (oder auf dem Boden ... auf der Tastatur ...), hat dies seine eigene Zweckmäßigkeit.  Zum Beispiel bietet es einen Ausgang für emotionale Energie - vielleicht nicht auf die „beste“ Weise, aber wie es kann.  (Ja, und das Konzept des "Besten" ist aus der Sicht <i>dieses Augenblicks an diesem Ort</i> sinnlos - weil das Beste und das Schlimmste nur im Vergleich zu etwas anderem möglich sind). <br><br>  Ich schreibe jetzt diesen Text, anstatt scheinbar wichtigere Fälle für mich - warum?  Erstens, um Bilanz zu ziehen, die Regale zu überprüfen und intern zu sortieren, die ich in diesen zwei Tagen beim Schreiben von Skripten gelernt habe ... Entfernen Sie sie aus dem RAM und speichern Sie sie.  Zweitens habe ich auf diese Weise eine kleine Pause ... Drittens hoffe ich, dass diese gekaute Erklärung jemand anderem (und mir selbst, vielleicht eines Tages) nützlich sein wird.  Wie, es spielt keine Rolle, ob die beste, aber eindeutige Erinnerung zum Thema Skripte und Serveranforderungen. <br><br>  Vielleicht korrigiert mich jemand in etwas und das Ergebnis wird noch besser.  Jemand wird nützliche Informationen erhalten.  Ist es angemessen?  Vielleicht ... das kann ich jetzt und mache es.  Morgen werde ich vielleicht aufwachen und die aktuellen Aktionen neu bewerten ... aber diese Neubewertung wird auch etwas Nützliches für das spätere Leben liefern. <br><br>  Nach Erfüllung der Anfrage haben wir also zwei Daten: <br><br><ul><li>  Als Hauptinformationsblock vom Server (wenn natürlich die Serverantwort kam) haben wir ihn in die Info-Variable geschrieben. </li><li>  Fehlercode für den Curl-Befehl (0, wenn keine Fehler vorliegen) - in die errr-Variable geschrieben. </li></ul><br>  Gerade weil beide Summen - sowohl Informationen als auch ein Fehlercode - benötigt werden, habe ich sie in Variablen geschrieben und Kurls Summen nicht sofort über die Pipe an andere Teams weitergegeben.  Aber jetzt in diesem Skript ist es Zeit, die Rohre zu besteigen: <br><br><pre> <code class="bash hljs">code=$(<span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$info</span></span></span><span class="hljs-string">"</span></span> | grep HTTP | grep -v <span class="hljs-string"><span class="hljs-string">'HTTP/2 200'</span></span>) date=$(<span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$info</span></span></span><span class="hljs-string">"</span></span> | grep -i <span class="hljs-string"><span class="hljs-string">'date:'</span></span>) dlay=$(<span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$info</span></span></span><span class="hljs-string">"</span></span> | grep  | sed -e <span class="hljs-string"><span class="hljs-string">'s///'</span></span>)</code> </pre><br>  In jede dieser Zeilen schreiben wir eine andere Variable - wir speichern die Ergebnisse der Ausführung von Befehlen.  Und in jedem Fall ist es nicht ein Team, sondern eine Kette;  Der erste Link ist überall gleich: <b>echo "$ info"</b> - Gibt den Stream von Informationen, den wir gespeichert haben und der von curl empfangen wurde, zum Stream des Standard-Ausgabegeräts (stdout) zurück.  Weiter unten in der Pipe wird dieser Stream an den Befehl grep übergeben.  Grep wählt aus allen Zeilen nur diejenigen aus, in denen es dem Muster entspricht.  (Die Option -i bedeutet "Groß- und Kleinschreibung wird nicht berücksichtigt").  Wie Sie sehen können, wählen wir im ersten Fall die Zeile mit "HTTP" aus.  Diese Zeile, die aus dem Haufen der anderen gezogen wird, wird über die Pipe an den Befehl <b>grep -v 'HTTP / 2 200' übergeben</b> .  Hier ist die <b>Option -v</b> das Gegenteil der Option <b>-e</b> . Sie filtert die Linien heraus, in denen sich ein solches Muster befindet.  Insgesamt wird in der Codevariablen eine Zeile mit dem Serverantwortcode (z. B. "HTTP / 1.1 302 gefunden") angezeigt, jedoch nur, wenn es sich nicht um "HTTP / 2 200" handelt.  Daher filtere ich die Zeilen heraus, die meine Site im Normalfall sendet, und speichere nur die "abnormalen" Antworten.  (Wenn Sie eine normale Serverantwort haben, ersetzen Sie diese dort). <br><br>  In ähnlicher Weise schreiben wir in das variable Datum die Zeile, in die der Server sein aktuelles Datum und seine aktuelle Uhrzeit ausgegeben hat.  Dies ist so etwas wie " <b>Datum: So, 11. Februar 2019, 08:06:57 GMT</b> " (normalerweise in der GMT-Zeitzone, auch bekannt als UTC).  Wir müssen das Datum (aber nur einmal am Tag!) In unsere Protokolldatei ("Serverstatusprotokoll") - server.log schreiben.  Gleichzeitig werden wir diese Zeit auf dem Bildschirm anzeigen.  Sie können von Ihrem Computer aus eine Datums- und Uhrzeitangabe in das Protokoll schreiben, diese werden jedoch zur Vereinfachung verwendet, da der Server sie trotzdem gesendet hat. <br><br>  Ähnlich verhält es sich mit unserer dritten Variablen, dlay (vom englischen Wort delay - delay).  Wir wählen die Zeile in unserem Ausschreibungsetikett "eeyu" aus, in der wir die Wartezeit auf eine Antwort vom Server beibehalten haben.  Wir entfernen dieses Etikett, das nicht mehr benötigt wird, mit dem Befehl <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">sed</a> - und speichern das Ergebnis. <br><br>  Wenn wir nun diese Variablen zur Überprüfung drucken, indem wir beispielsweise die Zeilen zu unserem Skript hinzufügen: <br><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">printf</span></span> <span class="hljs-string"><span class="hljs-string">'errr: %s\n'</span></span> <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$errr</span></span></span><span class="hljs-string">"</span></span> <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span> <span class="hljs-string"><span class="hljs-string">'code: %s\n'</span></span> <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$code</span></span></span><span class="hljs-string">"</span></span> <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span> <span class="hljs-string"><span class="hljs-string">'%s\n'</span></span> <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$date</span></span></span><span class="hljs-string">"</span></span> <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span> <span class="hljs-string"><span class="hljs-string">'dlay: %s\n'</span></span> <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$dlay</span></span></span><span class="hljs-string">"</span></span></code> </pre><br>  Sie sollten etwas bekommen wie: <br><br><pre> <code class="plaintext hljs">errr: 0 code: date: Mon, 11 Feb 2019 12:46:18 GMT dlay: 0.236549</code> </pre><br>  Gesamt: Der Fehlercode von curl ist Null (was bedeutet, dass er einwandfrei funktioniert hat).  Serverstatuscode - nicht aufgezeichnet (wie üblich).  Datum und Uhrzeit.  Die Dauer der Antwort.  Es bleibt, um das, was Sie brauchen, korrekt auf dem Bildschirm anzuzeigen und gegebenenfalls in eine Datei zu schreiben. <br><br>  Das ist das Interessanteste: Was, unter welchen Bedingungen und wie aufnehmen? <br><br><h3>  7. Schwierige Schlussfolgerungen </h3><br>  Um Sie nicht mit weiteren Details zu langweilen, werde ich es Ihnen kurz sagen (und es gibt genügend <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">gute Verzeichnisse</a> zu all diesen Befehlen im Internet).  Kürze ist übrigens eines der Hauptziele, die wir beim Schreiben in dieses Protokoll erreichen werden.  Dann ist es bequem zum Anzeigen und nimmt nie viel Speicherplatz ein (im Gegensatz zu anderen Protokollen, die in Megabyte pro Tag wachsen). <br><br>  Erstens: Wir stellen sicher, dass das Datum nur einmal und nicht in jeder Zeile in das Protokoll geschrieben wird.  Wählen Sie dazu aus unserem variablen Datum individuell das aktuelle Datum (aktuelle) und die aktuelle Uhrzeit (Uhrzeit) aus: <br><br><pre> <code class="bash hljs">curr=$(<span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$date</span></span></span><span class="hljs-string">"</span></span> | sed -e <span class="hljs-string"><span class="hljs-string">'s/\(20[0-9][0-9]\).*$/\1/'</span></span>) time=$(<span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$date</span></span></span><span class="hljs-string">"</span></span> | sed -e <span class="hljs-string"><span class="hljs-string">'s/^.*\ \([0-9][0-9]:.*\)\ GMT\r$/\1/'</span></span>)</code> </pre><br>  Außerdem betrachten wir Zeilen mit Datumsangaben aus der Protokolldatei und nehmen das letzte Datum (prev): <br><br><pre> <code class="bash hljs">prev=$(cat /home/me/Progs/iNet/monitor/site.log | grep -e <span class="hljs-string"><span class="hljs-string">'date:'</span></span> | tail -1)</code> </pre><br>  Wenn unser aktuelles Datum (curr) nicht mit dem vorherigen übereinstimmt (aus der Datei prev), ist ein neuer Tag gekommen (oder die Protokolldatei war beispielsweise leer).  Schreiben Sie dann das neue Datum in die Datei: <br><br><pre> <code class="bash hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> [[ <span class="hljs-variable"><span class="hljs-variable">$curr</span></span> != <span class="hljs-variable"><span class="hljs-variable">$prev</span></span> ]]; <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span> <span class="hljs-string"><span class="hljs-string">'%s\n'</span></span> <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$curr</span></span></span><span class="hljs-string">"</span></span> &gt;&gt;/home/me/Progs/iNet/monitor/site.log <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span> <span class="hljs-string"><span class="hljs-string">'%s %s %s\n'</span></span> <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$time</span></span></span><span class="hljs-string">"</span></span> <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$dlay</span></span></span><span class="hljs-string">"</span></span> <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$code</span></span></span><span class="hljs-string">"</span></span> &gt;&gt;/home/me/Progs/iNet/monitor/site.log</code> </pre><br>  ... und gleichzeitig zeichnen wir die aktuellen Informationen auf: Zeit, Verzögerung beim Empfang einer Antwort von der Site, Site-Antwortcode (falls nicht normal): <br><br><pre> <code class="bash hljs"> <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span> <span class="hljs-string"><span class="hljs-string">'%s %s %s\n'</span></span> <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$time</span></span></span><span class="hljs-string">"</span></span> <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$dlay</span></span></span><span class="hljs-string">"</span></span> <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$code</span></span></span><span class="hljs-string">"</span></span> &gt;&gt;/home/me/Progs/iNet/monitor/site.log</code> </pre><br>  Dies wird beim Navigieren helfen: Der eine oder andere Tag begann mit der einen oder anderen Geschwindigkeit der Site.  In anderen Fällen sollten Sie die Datei nicht mit unnötigen Einträgen überladen.  Natürlich schreiben wir es auf, wenn wir einen ungewöhnlichen Serverstatuscode erhalten: <br><br><pre> <code class="bash hljs"><span class="hljs-keyword"><span class="hljs-keyword">elif</span></span> [[ -n <span class="hljs-variable"><span class="hljs-variable">$code</span></span> ]]; <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span> <span class="hljs-string"><span class="hljs-string">'%s %s %s\n'</span></span> <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$time</span></span></span><span class="hljs-string">"</span></span> <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$dlay</span></span></span><span class="hljs-string">"</span></span> <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$code</span></span></span><span class="hljs-string">"</span></span> &gt;&gt;/home/me/Progs/iNet/monitor/site.log</code> </pre><br>  Und schreiben Sie auch, wenn die Serverantwortzeit länger als gewöhnlich ist.  Meine Website war normalerweise für 0,23 bis 0,25 Sekunden verantwortlich, daher zeichne ich Antworten auf, die länger als 0,3 Sekunden dauerten: <br><br><pre> <code class="bash hljs"><span class="hljs-keyword"><span class="hljs-keyword">elif</span></span> (( $(<span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$dlay</span></span></span><span class="hljs-string"> &gt; 0.3"</span></span> | bc -l) )); <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span> <span class="hljs-string"><span class="hljs-string">'%s %s\n'</span></span> <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$time</span></span></span><span class="hljs-string">"</span></span> <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$dlay</span></span></span><span class="hljs-string">"</span></span> &gt;&gt;/home/me/Progs/iNet/monitor/site.log</code> </pre><br>  Schließlich zeichne ich einmal pro Stunde einfach die vom Server empfangene Zeit auf - als Zeichen dafür, dass er lebt, und gleichzeitig als eine Art Markup der Datei: <br><br><pre> <code class="bash hljs"><span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$time</span></span></span><span class="hljs-string">"</span></span> | grep -e :00: | cat &gt;&gt;/home/me/Progs/iNet/monitor/site.log <span class="hljs-keyword"><span class="hljs-keyword">fi</span></span></code> </pre><br>  Wir erhalten den Inhalt der Datei, in der das Markup mit stündlichen Aufzeichnungen visuell hilft, ohne durchzulesen, um festzustellen, wann die Last höher oder niedriger ist (mehr Datensätze pro Stunde): <br><br><pre> <code class="plaintext hljs">19:42:28 0.461214 19:53:29 0.443956 20:00:29 20:09:30 2.156462 20:10:29 0.358294 20:45:29 0.313378 20:51:30 0.563886 20:54:30 0.307219 21:00:30 0.722343 21:01:30 0.310284 21:09:30 0.379662 21:10:31 1.305779 21:12:35 5.799455 21:23:31 1.054537 21:24:31 1.230391 21:40:31 0.461266 21:42:37 7.140093 22:00:31 22:12:37 5.724768 22:14:31 0.303500 22:42:37 5.735173 23:00:32 23:10:32 0.318207 date: Mon, 11 Feb 2019 00:00:34 0.235298 00:01:33 0.315093 01:00:34 01:37:41 5.741847 02:00:36 02:48:37 0.343234 02:56:37 0.647698 02:57:38 1.670538 02:58:39 2.327980 02:59:37 0.663547 03:00:37 03:40:38 0.331613 04:00:38 04:11:38 0.217022 04:50:39 0.313566 04:55:45 5.719911 05:00:39</code> </pre><br>  Und schließlich zeigen wir Informationen auf dem Bildschirm an.  Und wenn Curl fehlgeschlagen ist, zeigen wir eine Nachricht darüber an und schreiben sie (und führen gleichzeitig Ping aus und melden uns an, um zu überprüfen, ob der Server überhaupt aktiv ist): <br><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">printf</span></span> <span class="hljs-string"><span class="hljs-string">'%s\n%s\n%s'</span></span> <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$time</span></span></span><span class="hljs-string">"</span></span> <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$dlay</span></span></span><span class="hljs-string">"</span></span> <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$code</span></span></span><span class="hljs-string">"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (( <span class="hljs-variable"><span class="hljs-variable">$errr</span></span> != 0 )); <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> date &gt;&gt;/home/me/Progs/iNet/monitor/site.log date <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span> <span class="hljs-string"><span class="hljs-string">'CURL Request failed. Error: %s\n'</span></span> <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$errr</span></span></span><span class="hljs-string">"</span></span> &gt;&gt;/home/me/Progs/iNet/monitor/site.log <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span> <span class="hljs-string"><span class="hljs-string">'CURL Request failed. Error: %s\n'</span></span> <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$errr</span></span></span><span class="hljs-string">"</span></span> pung=$(ping -c 1 178.248.237.68) <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span> <span class="hljs-string"><span class="hljs-string">'Ping: %s\n----\n'</span></span> <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$pung</span></span></span><span class="hljs-string">"</span></span> &gt;&gt;/home/me/Progs/iNet/monitor/site.log <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span> <span class="hljs-string"><span class="hljs-string">'Ping: %s\n'</span></span> <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$pung</span></span></span><span class="hljs-string">"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">fi</span></span></code> </pre><br>  Ersetzen Sie die IP-Adresse in der Ping-Zeichenfolge durch die tatsächliche IP-Adresse Ihrer Site. <br><br><h3>  8. Nachwort </h3><br>  Das Ergebnis der Arbeit: <br><br><img src="https://habrastorage.org/webt/hk/zs/v-/hkzsv-3j9g-cv-wqklt2szu37hk.jpeg" alt="Der einfachste Website-Monitor" title="Der einfachste Website-Monitor"><br><br>  Links im Bedienfeld sehen Sie die Uhrzeit in UTC und die aktuelle Reaktionsfähigkeit der Site.  Auf der rechten Seite befindet sich das Protokoll: Es ist für die Rallye auch bei einem flüchtigen Bildlauf sichtbar, während welcher Stunden die Last mehr oder weniger war.  Sie können auch ungewöhnlich langsame Reaktionen feststellen (Spitzen; obwohl noch nicht klar ist, woher sie kommen). <br><br>  Das ist alles.  Das Skript erwies sich als einfach, Eiche, und es kann verbessert werden: Arbeiten an Optimierung, Portabilität, Verbesserung von Benachrichtigungen und Anzeigen unter Berücksichtigung von Proxy und Cache ... <br><br>  Aber bereits in dieser Art von Programm kann es wahrscheinlich eine Vorstellung vom Zustand Ihrer Site geben.  Und lassen Sie es eine Seite sein, die klugerweise angemessen ist und für Menschen und alle Kreaturen nützlich ist! <br><br><div class="spoiler">  <b class="spoiler_title">Volltext des Skripts mit Kommentaren.</b>  <b class="spoiler_title">Vergessen Sie nicht, die notwendigen Änderungen vorzunehmen!</b> <div class="spoiler_text"><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#!/bin/bash # Monitor server responses (run this every 60 seconds): info=$(curl -I -o /dev/stdout -w '%{time_total}' --url https://example.ru/ -m 9 -s) errr=$(echo $?) # errr = CURL error code https://curl.haxx.se/libcurl/c/libcurl-errors.html code=$(echo "$info" | grep HTTP | grep -v 'HTTP/2 200') date=$(echo "$info" | grep -i 'date:') dlay=$(echo "$info" | grep  | sed -e 's///') # code = Response code = 200? # =&gt; empty, otherwise response code string # # date = from HTTP Header of the server responded, like: # Date: Sun, 10 Feb 2019 05:01:50 GMT # # dlay = Response delay ("time_total") from CURL, like: # 0.25321 #printf 'errr: %s\n' "$errr" #printf 'code: %s\n' "$code" #printf '%s\n' "$date" #printf 'dlay: %s\n' "$dlay" curr=$(echo "$date" | sed -e 's/\(20[0-9][0-9]\).*$/\1/') time=$(echo "$date" | sed -e 's/^.*\ \([0-9][0-9]:.*\)\ GMT\r$/\1/') prev=$(cat /home/me/Progs/iNet/monitor/site.log | grep -e 'date:' | tail -1) # = Previously logged date, like: # date: Sun, 10 Feb 2019 # Day logged before vs day returned by the server; usually the same if [[ $curr != $prev ]]; then # Write date etc., at the beginning of every day: printf '%s\n' "$curr" &gt;&gt;/home/me/Progs/iNet/monitor/site.log printf '%s %s %s\n' "$time" "$dlay" "$code" &gt;&gt;/home/me/Progs/iNet/monitor/site.log elif [[ -n $code ]]; then # If the response had HTTP error code - log it: printf '%s %s ? %s\n' "$time" "$dlay" "$code" &gt;&gt;/home/me/Progs/iNet/monitor/site.log elif (( $(echo "$dlay &gt; 0.3" | bc -l) )); then # If the response delay was large - log it: printf '%s %s %s\n' "$time" "$dlay" "$code" &gt;&gt;/home/me/Progs/iNet/monitor/site.log else # If it's the start of an hour - just log the time echo "$time" | grep -e :00: | cat &gt;&gt;/home/me/Progs/iNet/monitor/site.log fi # To screen: printf '%s\n%s\n%s' "$time" "$dlay" "$code" # On CURL error: if (( $errr != 0 )); then date &gt;&gt;/home/me/Progs/iNet/monitor/site.log date printf 'CURL Request failed. Error: %s\n' "$errr" &gt;&gt;/home/me/Progs/iNet/monitor/site.log printf 'CURL Request failed. Error: %s\n' "$errr" pung=$(ping -c 1 178.248.237.68) printf 'Ping: %s\n----\n' "$pung" &gt;&gt;/home/me/Progs/iNet/monitor/site.log printf 'Ping: %s\n' "$pung" fi</span></span></code> </pre><br></div></div><br><br>  <b>PS.</b>  <b>Im Anschluss an die Diskussion</b> (am 02/12/2019): <br><br>  Wie ich gehofft hatte, haben Experten viele interessante Kommentare geschrieben. <br><br>  Nachdem ich es mir überlegt habe, kann ich die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link">rsashka-</a> Frage beantworten, was der Vorteil dieses Skripts ist. <br><br>  Andere Tools wie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">NetData</a> (danke an <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link">tchspprt</a> für den Tipp!) <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link">Stellen</a> eine große Anzahl von Daten <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link">bereit</a> , die nicht lange gespeichert werden.  NetData ist ein gutes Tool, wenn Sie jeden Tag arbeiten und Websites professionell pflegen.  Gut zur Diagnose aktueller Probleme. <br><br>  Ein Skript wie das meine soll ein Auge auf andere Dinge haben.  Das Skript erfordert keine speziellen Studien und Einstellungen.  Das ist nicht schlecht für Laien.  Und seine Protokolle nehmen so wenig Platz ein, dass sie überhaupt nicht gelöscht werden können.  Sie können sich im Laufe der Jahre ansammeln, und in den Jahren N + 1 können Sie sehen: „Wow, 2019 war meine Reaktionszeit eineinhalb Mal niedriger! ..“ <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das heißt, eine solche Lösung hat eine eigene Nische - hauptsächlich für Nicht-Systemadministratoren. (Wie </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tchspprt</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> sagt </font><font style="vertical-align: inherit;">: "Es geht darum, wie man die Katze eines Nachbarn im Urlaub füttert"). </font></font><br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">andreymal</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> empfahl eine interessante Möglichkeit, die Last der Site ohne zusätzliche Mittel zu berücksichtigen und dann einfach über die Zugriffsprotokolle auf der Site anzuzeigen. Und Sie können schöne Grafiken darauf erstellen. Ich werde diese Option wahrscheinlich ausprobieren und auf </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Github posten,</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> was passiert ist. </font></font><br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">unnforgiven hat eine</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> andere interessante Lösung empfohlen - wahrscheinlich eine einfache (Prometheus, Blackbox und Alermanager über Docker Composer installieren). Auf meinem einfachen, billigen VPS ist nicht genug für diesen Speicher; und Linux mit einem alten Kernel - Docker startet nicht. Aber danke für die Option! </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ein weiterer Tipp</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tchspprt</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : Graphit + Prometheus + Grafana. </font><font style="vertical-align: inherit;">Oder stellen Sie dem Skript schöne Grafiken zur Verfügung (gnuplot oder rrdtool). </font></font><br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mcalexvrn</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> empfiehlt ein einfaches Tool: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Uptimerobot</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font> Vielen Dank! <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ich danke allen für diese vielen Informationen! </font><font style="vertical-align: inherit;">Lass es für Menschen nützlich sein ...</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de439894/">https://habr.com/ru/post/de439894/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de439882/index.html">Abenteuer mit ptrace (2)</a></li>
<li><a href="../de439884/index.html">So lehnen Sie unnötige Newsletter mit einem einzigen Knopf ab. Yandex.Mail Team Erfahrung</a></li>
<li><a href="../de439886/index.html">Wie ich einem neuronalen Netzwerk beigebracht habe, die Positionsbewertungsfunktion beim russischen AI Cup CodeBall 2018 zu implementieren</a></li>
<li><a href="../de439890/index.html">Fähigkeiten sind 100% oder weniger.</a></li>
<li><a href="../de439892/index.html">Wie man für ein Jahr plant. Fallstudie eines IT-Unternehmens mit 120 Mitarbeitern und zwei Praktiken für kleine Teams</a></li>
<li><a href="../de439896/index.html">Ethik der automatischen Beiträge</a></li>
<li><a href="../de439898/index.html">VBA und Python für Excel- und MS Office-Automatisierung</a></li>
<li><a href="../de439900/index.html">Julia und die Koordinatenabstiegsmethode</a></li>
<li><a href="../de439902/index.html">Erklärung der physikalischen Natur des Phänomens der „Auftriebskraft des Flügels“ ohne Verwendung der Bernoulli-Gleichung. Teil 2</a></li>
<li><a href="../de439906/index.html">Kritische Sicherheitsanfälligkeit in Zemana Antivirus-Produkten und mehr</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>