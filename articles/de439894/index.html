<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë®üèª‚ÄçüöÄ ‚úîÔ∏è üë¥üèø So √ºberwachen Sie einfach den Status der Site üòÅ üë®‚Äçüåæ üßóüèº</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Um die Leistung von Servern aus der Ferne zu √ºberwachen, verwenden Fachleute spezielle Softwaresysteme wie Zabbix oder Icinga . Wenn Sie jedoch ein un...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>So √ºberwachen Sie einfach den Status der Site</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/439894/"> Um die Leistung von Servern aus der Ferne zu √ºberwachen, verwenden Fachleute spezielle Softwaresysteme wie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Zabbix</a> oder <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Icinga</a> .  Wenn Sie jedoch ein unerfahrener Eigent√ºmer oder Administrator einer oder zweier Websites mit geringer Last sind, sind keine gro√üen √úberwachungssysteme erforderlich.  Der Hauptparameter ist, ob die Site Benutzer schnell bedient.  Daher k√∂nnen Sie die Arbeit der Site mit einem einfachen Programm von jedem mit dem Internet verbundenen Computer aus √ºberwachen. <br><br><img src="https://habrastorage.org/webt/qx/fj/tq/qxfjtqd07g37gx2eq8ksz80wtfm.jpeg" alt="Foto von Mikhail Vasiliev, Unsplash.Com" title="Foto von Mikhail Vasiliev, Unsplash.Com"><br><br>  Schreiben wir jetzt dieses Skript - die einfachste √úberwachung der Verf√ºgbarkeit und Geschwindigkeit der Website.  Dieses Programm kann auf einem Heimcomputer, einem Smartphone usw. ausgef√ºhrt werden.  Das Programm hat nur zwei Funktionen: <br><br><ul><li>  zeigt auf dem Bildschirm die Zeit an, in der Ihre Website Benutzerseiten bereitstellt. </li><li>  Bei langsamen Antworten der Site oder Fehlern schreibt das Programm Daten in eine Datei (ein ‚ÄûProtokoll‚Äú oder eine Protokolldatei).  Diese Daten sollten von Zeit zu Zeit √ºberpr√ºft werden, um Probleme zu beheben, wenn sie gerade erst beginnen.  Daher werden wir darauf achten, diese Protokolle in einer √ºbersichtlichen, bequemen Form f√ºr eine schnelle Anzeige aufzuzeichnen. </li></ul><br>  Ich werde jeden Schritt im Detail beschreiben, damit selbst Anf√§nger, die mit dem Schreiben von Batch-Dateien (bat und cmd unter DOS und Windows, sh auf Systemen wie UNIX) nur wenig vertraut sind, dies problemlos herausfinden und das Skript an seine Bed√ºrfnisse anpassen k√∂nnen.  <b>Ich bitte Sie jedoch, dieses Skript nicht gedankenlos zu verwenden, da es bei falscher Verwendung m√∂glicherweise nicht zu den richtigen Ergebnissen f√ºhrt und au√üerdem viel Verkehr verschlingt</b> . <br><br>  Ich werde ein Skript f√ºr ein Betriebssystem wie Linux und dessen Verwendung auf einem Heimcomputer beschreiben.  Nach den gleichen Prinzipien kann dies auf anderen Plattformen erfolgen.  Und f√ºr diejenigen, die nur die M√∂glichkeiten von Linux betrachten, mag ein weiteres Beispiel interessant sein, was f√ºr ein einfaches und leistungsf√§higes Werkzeug seine Skripte sind. <br><a name="habracut"></a><br><h3>  1. Organisation zuerst </h3><br>  Wir werden einen separaten Ordner f√ºr dieses Programm erstellen und 3 Dateien darin erstellen.  Zum Beispiel habe ich diesen Ordner / home / me / Progs / iNet / monitor (hier ist me der Name meines Benutzers, Progs / iNet ist mein Ordner f√ºr Programme im Zusammenhang mit dem Internet, und monitor ist der Name dieses Programms aus dem Wort monitor, d. H. Da ich der einzige Benutzer dieses Computers bin, speichere ich solche Dateien in meinen pers√∂nlichen Ordnern (/ home) in einem separaten Abschnitt der Festplatte, sodass ich sie bei der Neuinstallation des Systems speichern kann.  In diesem Ordner befinden sich Dateien: <br><br><ul><li>  README.txt - hier ist eine Beschreibung (im Falle von Sklerose): welche Art von Programm, Hintergrundinformationen dazu usw. </li><li>  mon.sh - Es wird ein Programm geben, das die Site abfragt. </li><li>  server.log - hier werden Site-Statusanzeigen aufgezeichnet.  In unserem Fall ist dies einfach das Datum, die Uhrzeit und die Dauer der Antwort der Site (plus zus√§tzliche Informationen, wenn der Server mit unserer Anfrage mit einem Fehler antwortet). </li></ul><br>  (Um das Bearbeiten und Wiederherstellen von Dateien zu vereinfachen, k√∂nnen Sie diesen Ordner in das Git-Versionskontrollsystem aufnehmen. Hier werde ich ihn nicht beschreiben.) <br><br><h3>  2. Beharrlich und entspannt </h3><br>  Wir werden die Datei mon.sh mit einem regelm√§√üigen kleinen Intervall ausf√ºhren, zum Beispiel 60 Sekunden.  Ich habe das vom Betriebssystem bereitgestellte Standardtool verwendet (genauer gesagt die Desktop-Umgebung). <br><br>  Meine Desktop-Umgebung ist Xfce.  Dies ist eine der beliebtesten Optionen f√ºr Linux.  Ich mag Xfce, weil Sie damit die gesamte Umgebung fast vollst√§ndig anpassen k√∂nnen - ganz nach Ihren W√ºnschen.  Gleichzeitig ist Xfce etwas kompakter und schneller als zwei andere bekannte Systeme - Gnome und KDE.  (Andere Optionen sind ebenfalls interessant - zum Beispiel ist die LXDE-Umgebung noch schneller und einfacher als Xfce, aber bisher nicht so reich an Funktionen). <br><br>  Das Tool, das wir im Fall von Xfce ben√∂tigen, ist ein Plug-In f√ºr das Arbeitsfeld Generic Monitor.  Normalerweise ist es bereits installiert, aber wenn nicht, kann der Installer es leicht finden: "Genmon" (Beschreibung: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">xfce4-genmon-plugin</a> ).  Dies ist ein Plugin, das dem Panel hinzugef√ºgt und in den Einstellungen festgelegt werden kann: (1) der auszuf√ºhrende Befehl und (2) die H√§ufigkeit seiner Ausf√ºhrung in Sekunden.  In meinem Fall der Befehl: <br><br>  /home/me/Progs/iNet/monitor/mon.sh <br><br>  (oder gleichwertig ~ / Progs / iNet / monitor / mon.sh). <br><br><img src="https://habrastorage.org/webt/2w/pc/sz/2wpcszhqlfhyao4_qg6bpkrillw.png" alt="Genmon" title="Genmon"><br><br><h3>  3. Wenn das Programm noch nicht vorhanden ist, liegen bereits Fehler vor </h3><br>  Wenn Sie nun alle diese Schritte ausgef√ºhrt haben - Dateien erstellt und das Plug-In im Bedienfeld gestartet -, sehen Sie das Ergebnis des Startens unseres Programms dort (Fehlermeldung: Datei mon.sh ist kein Programm).  Um die Datei ausf√ºhrbar zu machen, gehen Sie zu unserem Ordner und legen Sie die Berechtigung zum Ausf√ºhren fest - <ul><li>  oder Dateimanager: Eigenschaften - Berechtigungen - Diese Datei kann als Programm ausgef√ºhrt werden. </li><li>  oder ein Befehl vom Terminal: <b>chmod 755 mon.sh</b> </li></ul><br>  Und in die Datei selbst schreiben wir die ersten Zeilen: <br><br><pre><code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#!/bin/bash # Monitor server responses (run this every 60 seconds): # info=$(curl -I -o /dev/stdout -w '%{time_total}' --url https://example.ru/ -m 9 -s) errr=$(echo $?)</span></span></code> </pre> <br>  Anstelle von "example.ru" ersetzen Sie den Namen Ihrer Site, deren Status Sie beobachten werden.  Und wenn es auf http funktioniert, setzen Sie http anstelle von https.  Die Zeile #! / Bin / bash bedeutet, dass dies ein Skript ist, das vom Bash-Programm gestartet werden soll ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">bash</a> ist wahrscheinlich das h√§ufigste Skript zum Ausf√ºhren von Skripten unter Linux).  Um eine andere Shell zu bearbeiten, wird diese anstelle von Bash angezeigt.  Die restlichen Zeilen mit einem scharfen am Anfang sind Kommentare.  Die erste Codezeile selbst lautet <b>info = $ ()</b> und in diesen Klammern steht der Befehl curl mit Parametern.  Eine solche Konstruktion - etwas = $ (etwas) - bedeutet "den Befehl in Klammern ausf√ºhren und das Ergebnis der Variablen auf der linken Seite zuweisen".  In diesem Fall habe ich die Variable "info" genannt.  Dieser Befehl in Klammern - curl (im Jargon, der von einigen als "Kurl" bezeichnet wird) - sendet eine Anfrage an das Netzwerk unter der angegebenen Adresse und gibt die Serverantwort an uns zur√ºck.  (Mein Bekannter erkl√§rte: "Wie der Kran grunzt - und eine Antwort von einem anderen Kran am Himmel erh√§lt.")  Betrachten Sie die Optionen: <br><br><pre> <code class="bash hljs">curl -I -o /dev/stdout -w <span class="hljs-string"><span class="hljs-string">'%{time_total}'</span></span> --url https://example.ru/ -m 9 -s</code> </pre><br>  <b>-Ich</b> bedeutet, dass wir nicht die gesamte Seite anfordern, sondern nur die "HTTP-Header".  Jedes Mal ben√∂tigen wir nicht den gesamten Seitentext, um sicherzustellen, dass die Website funktioniert.  Da wir die Site h√§ufig √ºberpr√ºfen, ist es wichtig, die Gr√∂√üe der √ºbertragenen Daten so klein wie m√∂glich zu halten.  Dies spart sowohl Verkehr als auch Strom und die Belastung des Servers - und der Tierwelt. <br><br>  Achten Sie √ºbrigens darauf, wie viel freien Datenverkehr Sie (nicht pro Monat verwendet) auf dem Hosting haben.  Unten sehen Sie, wie viele Daten √ºbertragen werden, und Sie k√∂nnen berechnen, ob Sie √ºber gen√ºgend Reserven verf√ºgen.  Wenn √ºberhaupt, kann der √úberpr√ºfungszeitraum des Standorts auf 5, 10 oder sogar 30-60 Minuten erh√∂ht werden.  Obwohl in diesem Fall das Bild nicht so vollst√§ndig ist - und kleinere Unterbrechungen m√∂glicherweise unbemerkt bleiben;  Im Allgemeinen ist es jedoch bei der √úberwachung eines Standorts wichtiger, langfristige Probleme zu erkennen als eine einzelne Unterbrechung.  Welchen Datenverkehr k√∂nnen Sie sich auf dem anrufenden Computer leisten?  In meinem Fall - einem Desktop-PC mit unbegrenztem Datenverkehr - ist dies nicht so wichtig.  F√ºr ein mobiles Ger√§t oder einen Tarif mit Grenzwerten lohnt es sich jedoch, die Inspektionsintervalle zu berechnen und m√∂glicherweise zu verl√§ngern. <br><br><h3>  4. Schritt folgt Schritt mit Ausnahme des ersten Schritts </h3><br>  Gehen wir weiter: <b>-o / dev / stdout</b> bedeutet "Senden Sie die von Kurl vom Server empfangene Antwort an diese und jene Datei".  In diesem Fall handelt es sich nicht um eine Datei auf der Festplatte, sondern um / dev / stdout - Standardausgabeger√§t.  Normalerweise ist das "Standardausgabeger√§t" unser Bildschirm, auf dem wir die Ergebnisse des Programms sehen k√∂nnen.  Im Skript leiten wir diese ‚ÄûStandardausgabe‚Äú jedoch h√§ufig zur weiteren Verarbeitung (jetzt - speichern Sie sie in der Info-Variablen).  Und dann senden wir meistens entweder die Ergebnisse der Teams an Variablen oder geben sie an die n√§chsten Teams in einer Kette weiter.  Verwenden Sie zum Erstellen von Ketten aus Befehlen den Pipe-Operator ("Pipe"), der als vertikaler Balken ("|") angezeigt wird. <br><br>  <b>-w '% {time_total} eyayu'</b> : hier bedeutet -w "formatieren und solche und solche zus√§tzlichen Informationen an ein Standardausgabeger√§t weitergeben".  Insbesondere interessiert uns time_total - wie viel Zeit die Anfrage-Antwort-√úbertragung zwischen uns und dem Server in Anspruch genommen hat.  Sie wissen wahrscheinlich, dass es einen einfacheren Befehl gibt, Ping, um schnell einen Server anzufordern und eine Antwort von ihm zu erhalten, Pong.  Ping √ºberpr√ºft jedoch nur, ob der Hosting-Server aktiv ist, und das Signal geht so lange hin und her.  Dies zeigt die maximale Zugriffsgeschwindigkeit an, sagt jedoch noch nichts dar√ºber aus, wie schnell die Website echten Inhalt produziert.  Ping kann schnell funktionieren, und gleichzeitig kann die Site langsamer oder gar nicht funktionieren - aufgrund hoher Auslastung oder interner Probleme.  Daher verwenden wir genau Kurla und erhalten die tats√§chliche Zeit, zu der der Server unsere Inhalte anzeigt. <br><br>  (Anhand dieses Parameters k√∂nnen Sie beurteilen, ob der Server f√ºr Ihre Aufgaben effizient arbeitet und ob die typische Antwortzeit f√ºr Benutzer g√ºnstig ist. Gibt es keine Probleme? Beispielsweise haben sich meine Websites auf vielen Hosting-Websites im Laufe der Zeit verlangsamt, und ich musste nach einem anderen Hosting suchen.) <br><br>  Haben Sie die seltsamen Buchstaben "eyu" nach {time_total} bemerkt?  Ich habe sie als eindeutige Bezeichnung hinzugef√ºgt, die wahrscheinlich nicht in den vom Server an uns gesendeten Headern enthalten ist (obwohl davon ausgegangen wird, dass die Benutzer Ihrer Programme schlecht sind und nicht und der Weg in den Abgrund. Tun Sie dies nicht! .. Oder wenn Sie dies tun , sch√§me dich wenigstens f√ºr dich).  Mit diesem Label (ich hoffe) k√∂nnen wir dann einfach die Informationen, die wir ben√∂tigen, aus einer ganzen Reihe von Zeilen in der Info-Variablen ziehen.  <b>Curl -w '% {time_total} ehayu'</b> (mit den verbleibenden korrekten Parametern) gibt uns also etwas wie: <br><br>  0,215238eyayu <br><br>  Dies ist die Anzahl der Sekunden, die f√ºr den Zugriff auf die Website ben√∂tigt wurden, sowie unser Etikett.  (Zus√§tzlich zu diesem Parameter interessiert uns in der Info-Variablen haupts√§chlich der ‚ÄûStatuscode‚Äú - der Statuscode oder einfach der Server-Antwortcode. Wenn der Server die angeforderte Datei ausgibt, lautet der Code normalerweise ‚Äû200‚Äú. Wenn die Seite nicht gefunden wird Dies ist der ber√ºhmte 404. Wenn auf dem Server Fehler auftreten, sind es meistens 500 mit etwas). <br><br><img src="https://habrastorage.org/webt/ka/rc/nk/karcnk8ggbptl5raex3j67k_aea.jpeg" alt="404" title="404"><br><br><h3>  5. Kreativit√§t - der Vater der Selbstpr√ºfung </h3><br>  Die verbleibenden Parameter unserer Locke sind wie folgt: <br><br><pre> <code class="bash hljs">--url https://example.ru/ -m 9 -s</code> </pre> <br>  was es bedeutet: eine solche Adresse anzufordern;  Die maximale Antwortzeit betr√§gt 9 Sekunden (Sie k√∂nnen weniger festlegen, da ein seltener Benutzer so lange auf eine Antwort von der Site wartet, dass er schnell feststellt, dass die Site nicht funktioniert).  Und "-s" bedeutet still, das hei√üt, Curl sagt uns keine unn√∂tigen Details. <br><br>  √úbrigens ist auf dem Desktop-Panel normalerweise nicht viel Platz vorhanden. Zum Debuggen eines Skripts ist es daher besser, es vom Terminal aus auszuf√ºhren (in seinem Ordner mit dem Befehl ./mon.sh).  Und f√ºr unser Panel-Plugin machen wir eine lange Pause zwischen den Starts des Befehls - beispielsweise 3600 Sekunden. <br><br>  Zum Debuggen k√∂nnen wir diese Locke ohne Rahmenklammern ausf√ºhren und sehen, was sie erzeugt.  (Daraus und berechnen Sie den Verkehrsverbrauch).  Wir werden haupts√§chlich eine Reihe von HTTP-Headern sehen, wie zum Beispiel: <br><br><pre> <code class="plaintext hljs">HTTP/1.1 302 Found Server: QRATOR Date: Sun, 11 Feb 2019 08:06:57 GMT Content-Type: text/html; charset=UTF-8 Connection: keep-alive Keep-Alive: timeout=15 X-Powered-By: PHP/7.2.14-1+ubuntu16.04.1+deb.sury.org+1 Location: https://habr.com/ru/ X-Frame-Options: SAMEORIGIN X-Content-Type-Options: nosniff Strict-Transport-Security: max-age=63072000; includeSubDomains; preload X-Cache-Status: HIT 0.033113</code> </pre><br>  In der ersten Zeile sehen wir "HTTP / 1.1 302 gefunden" - was bedeutet: Das Daten√ºbertragungsprotokoll ist "HTTP / 1.1", der Server-Antwortcode ist "302 gefunden".  Wenn Sie eine andere Seite anfordern, kann dies der Code "301 dauerhaft verschoben" usw. sein.  In einem weiteren Beispiel lautet die normale Antwort meines Servers "HTTP / 2 200".  Wenn Ihr Server normalerweise anders reagiert, ersetzen Sie ihn durch diese Antwort anstelle von "HTTP / 2 200" in diesem Skript. <br><br>  Wie wir sehen, gibt Kurl in der letzten Zeile an, in wie vielen Sekunden wir die Serverantwort mit unserem zugewiesenen Etikett erhalten haben. <br><br>  Interessant: Wir k√∂nnen die Site so konfigurieren, dass sie √ºber unsere Anforderungen berichtet (und nur √ºber diese!). Zus√§tzliche Informationen zu ihrem Status - zum Beispiel im "hausgemachten" HTTP-Header.  Angenommen, die Prozessoren der Site sind ausgelastet, wie viel freier Speicher und Speicherplatz vorhanden sind und wie schnell die Datenbank arbeitet.  (Dazu muss die Site nat√ºrlich dynamisch sein, dh Anforderungen m√ºssen vom Programm verarbeitet werden - in PHP, Node.JS usw. Eine andere Option ist die Verwendung spezieller Software auf dem Server).  Aber vielleicht brauchen wir diese Details noch nicht wirklich.  Der Zweck dieses Skripts besteht lediglich darin, die Gesamtleistung der Site regelm√§√üig zu √ºberwachen.  Bei Problemen werden wir uns bereits auf andere Weise mit der Diagnose befassen.  Daher schreiben wir jetzt das einfachste Skript, das f√ºr jede Site funktioniert, auch f√ºr ein statisches, und ohne zus√§tzliche Einstellungen auf dem Server.  Falls gew√ºnscht, k√∂nnen Sie in Zukunft die Funktionen des Skripts erweitern.  Machen Sie in der Zwischenzeit die Basis. <br><br>  Der String <b>errr = $ (echo $?) Bedeutet</b> : Schreiben Sie das Ergebnis des Befehls "echo $?" In die Variable errr.  Der Befehl echo bedeutet, dass Text auf dem Standardausgabeger√§t (stdout) und die Zeichen "$?"  - Dies ist der aktuelle Fehlercode (vom vorherigen Befehl √ºbrig).  Wenn unsere Locke den Server pl√∂tzlich nicht mehr erreichen kann, wird ein Fehlercode ungleich Null ausgegeben, und wir werden dies durch √úberpr√ºfen der errr-Variablen herausfinden. <br><br><h3>  6. Zweckm√§√üigkeit </h3><br>  Hier m√∂chte ich einen kleinen Exkurs von technischen Fragen machen, um das Lesen des Textes interessanter zu machen.  (Wenn Sie nicht einverstanden sind, √ºberspringen Sie drei Abs√§tze).  Ich werde sagen, dass jede menschliche Aktivit√§t auf ihre eigene Weise angemessen ist.  Selbst wenn eine Person absichtlich ihre Stirn gegen eine Wand schl√§gt (oder auf dem Boden ... auf der Tastatur ...), hat dies seine eigene Zweckm√§√üigkeit.  Zum Beispiel bietet es einen Ausgang f√ºr emotionale Energie - vielleicht nicht auf die ‚Äûbeste‚Äú Weise, aber wie es kann.  (Ja, und das Konzept des "Besten" ist aus der Sicht <i>dieses Augenblicks an diesem Ort</i> sinnlos - weil das Beste und das Schlimmste nur im Vergleich zu etwas anderem m√∂glich sind). <br><br>  Ich schreibe jetzt diesen Text, anstatt scheinbar wichtigere F√§lle f√ºr mich - warum?  Erstens, um Bilanz zu ziehen, die Regale zu √ºberpr√ºfen und intern zu sortieren, die ich in diesen zwei Tagen beim Schreiben von Skripten gelernt habe ... Entfernen Sie sie aus dem RAM und speichern Sie sie.  Zweitens habe ich auf diese Weise eine kleine Pause ... Drittens hoffe ich, dass diese gekaute Erkl√§rung jemand anderem (und mir selbst, vielleicht eines Tages) n√ºtzlich sein wird.  Wie, es spielt keine Rolle, ob die beste, aber eindeutige Erinnerung zum Thema Skripte und Serveranforderungen. <br><br>  Vielleicht korrigiert mich jemand in etwas und das Ergebnis wird noch besser.  Jemand wird n√ºtzliche Informationen erhalten.  Ist es angemessen?  Vielleicht ... das kann ich jetzt und mache es.  Morgen werde ich vielleicht aufwachen und die aktuellen Aktionen neu bewerten ... aber diese Neubewertung wird auch etwas N√ºtzliches f√ºr das sp√§tere Leben liefern. <br><br>  Nach Erf√ºllung der Anfrage haben wir also zwei Daten: <br><br><ul><li>  Als Hauptinformationsblock vom Server (wenn nat√ºrlich die Serverantwort kam) haben wir ihn in die Info-Variable geschrieben. </li><li>  Fehlercode f√ºr den Curl-Befehl (0, wenn keine Fehler vorliegen) - in die errr-Variable geschrieben. </li></ul><br>  Gerade weil beide Summen - sowohl Informationen als auch ein Fehlercode - ben√∂tigt werden, habe ich sie in Variablen geschrieben und Kurls Summen nicht sofort √ºber die Pipe an andere Teams weitergegeben.  Aber jetzt in diesem Skript ist es Zeit, die Rohre zu besteigen: <br><br><pre> <code class="bash hljs">code=$(<span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$info</span></span></span><span class="hljs-string">"</span></span> | grep HTTP | grep -v <span class="hljs-string"><span class="hljs-string">'HTTP/2 200'</span></span>) date=$(<span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$info</span></span></span><span class="hljs-string">"</span></span> | grep -i <span class="hljs-string"><span class="hljs-string">'date:'</span></span>) dlay=$(<span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$info</span></span></span><span class="hljs-string">"</span></span> | grep  | sed -e <span class="hljs-string"><span class="hljs-string">'s///'</span></span>)</code> </pre><br>  In jede dieser Zeilen schreiben wir eine andere Variable - wir speichern die Ergebnisse der Ausf√ºhrung von Befehlen.  Und in jedem Fall ist es nicht ein Team, sondern eine Kette;  Der erste Link ist √ºberall gleich: <b>echo "$ info"</b> - Gibt den Stream von Informationen, den wir gespeichert haben und der von curl empfangen wurde, zum Stream des Standard-Ausgabeger√§ts (stdout) zur√ºck.  Weiter unten in der Pipe wird dieser Stream an den Befehl grep √ºbergeben.  Grep w√§hlt aus allen Zeilen nur diejenigen aus, in denen es dem Muster entspricht.  (Die Option -i bedeutet "Gro√ü- und Kleinschreibung wird nicht ber√ºcksichtigt").  Wie Sie sehen k√∂nnen, w√§hlen wir im ersten Fall die Zeile mit "HTTP" aus.  Diese Zeile, die aus dem Haufen der anderen gezogen wird, wird √ºber die Pipe an den Befehl <b>grep -v 'HTTP / 2 200' √ºbergeben</b> .  Hier ist die <b>Option -v</b> das Gegenteil der Option <b>-e</b> . Sie filtert die Linien heraus, in denen sich ein solches Muster befindet.  Insgesamt wird in der Codevariablen eine Zeile mit dem Serverantwortcode (z. B. "HTTP / 1.1 302 gefunden") angezeigt, jedoch nur, wenn es sich nicht um "HTTP / 2 200" handelt.  Daher filtere ich die Zeilen heraus, die meine Site im Normalfall sendet, und speichere nur die "abnormalen" Antworten.  (Wenn Sie eine normale Serverantwort haben, ersetzen Sie diese dort). <br><br>  In √§hnlicher Weise schreiben wir in das variable Datum die Zeile, in die der Server sein aktuelles Datum und seine aktuelle Uhrzeit ausgegeben hat.  Dies ist so etwas wie " <b>Datum: So, 11. Februar 2019, 08:06:57 GMT</b> " (normalerweise in der GMT-Zeitzone, auch bekannt als UTC).  Wir m√ºssen das Datum (aber nur einmal am Tag!) In unsere Protokolldatei ("Serverstatusprotokoll") - server.log schreiben.  Gleichzeitig werden wir diese Zeit auf dem Bildschirm anzeigen.  Sie k√∂nnen von Ihrem Computer aus eine Datums- und Uhrzeitangabe in das Protokoll schreiben, diese werden jedoch zur Vereinfachung verwendet, da der Server sie trotzdem gesendet hat. <br><br>  √Ñhnlich verh√§lt es sich mit unserer dritten Variablen, dlay (vom englischen Wort delay - delay).  Wir w√§hlen die Zeile in unserem Ausschreibungsetikett "eeyu" aus, in der wir die Wartezeit auf eine Antwort vom Server beibehalten haben.  Wir entfernen dieses Etikett, das nicht mehr ben√∂tigt wird, mit dem Befehl <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">sed</a> - und speichern das Ergebnis. <br><br>  Wenn wir nun diese Variablen zur √úberpr√ºfung drucken, indem wir beispielsweise die Zeilen zu unserem Skript hinzuf√ºgen: <br><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">printf</span></span> <span class="hljs-string"><span class="hljs-string">'errr: %s\n'</span></span> <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$errr</span></span></span><span class="hljs-string">"</span></span> <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span> <span class="hljs-string"><span class="hljs-string">'code: %s\n'</span></span> <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$code</span></span></span><span class="hljs-string">"</span></span> <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span> <span class="hljs-string"><span class="hljs-string">'%s\n'</span></span> <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$date</span></span></span><span class="hljs-string">"</span></span> <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span> <span class="hljs-string"><span class="hljs-string">'dlay: %s\n'</span></span> <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$dlay</span></span></span><span class="hljs-string">"</span></span></code> </pre><br>  Sie sollten etwas bekommen wie: <br><br><pre> <code class="plaintext hljs">errr: 0 code: date: Mon, 11 Feb 2019 12:46:18 GMT dlay: 0.236549</code> </pre><br>  Gesamt: Der Fehlercode von curl ist Null (was bedeutet, dass er einwandfrei funktioniert hat).  Serverstatuscode - nicht aufgezeichnet (wie √ºblich).  Datum und Uhrzeit.  Die Dauer der Antwort.  Es bleibt, um das, was Sie brauchen, korrekt auf dem Bildschirm anzuzeigen und gegebenenfalls in eine Datei zu schreiben. <br><br>  Das ist das Interessanteste: Was, unter welchen Bedingungen und wie aufnehmen? <br><br><h3>  7. Schwierige Schlussfolgerungen </h3><br>  Um Sie nicht mit weiteren Details zu langweilen, werde ich es Ihnen kurz sagen (und es gibt gen√ºgend <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">gute Verzeichnisse</a> zu all diesen Befehlen im Internet).  K√ºrze ist √ºbrigens eines der Hauptziele, die wir beim Schreiben in dieses Protokoll erreichen werden.  Dann ist es bequem zum Anzeigen und nimmt nie viel Speicherplatz ein (im Gegensatz zu anderen Protokollen, die in Megabyte pro Tag wachsen). <br><br>  Erstens: Wir stellen sicher, dass das Datum nur einmal und nicht in jeder Zeile in das Protokoll geschrieben wird.  W√§hlen Sie dazu aus unserem variablen Datum individuell das aktuelle Datum (aktuelle) und die aktuelle Uhrzeit (Uhrzeit) aus: <br><br><pre> <code class="bash hljs">curr=$(<span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$date</span></span></span><span class="hljs-string">"</span></span> | sed -e <span class="hljs-string"><span class="hljs-string">'s/\(20[0-9][0-9]\).*$/\1/'</span></span>) time=$(<span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$date</span></span></span><span class="hljs-string">"</span></span> | sed -e <span class="hljs-string"><span class="hljs-string">'s/^.*\ \([0-9][0-9]:.*\)\ GMT\r$/\1/'</span></span>)</code> </pre><br>  Au√üerdem betrachten wir Zeilen mit Datumsangaben aus der Protokolldatei und nehmen das letzte Datum (prev): <br><br><pre> <code class="bash hljs">prev=$(cat /home/me/Progs/iNet/monitor/site.log | grep -e <span class="hljs-string"><span class="hljs-string">'date:'</span></span> | tail -1)</code> </pre><br>  Wenn unser aktuelles Datum (curr) nicht mit dem vorherigen √ºbereinstimmt (aus der Datei prev), ist ein neuer Tag gekommen (oder die Protokolldatei war beispielsweise leer).  Schreiben Sie dann das neue Datum in die Datei: <br><br><pre> <code class="bash hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> [[ <span class="hljs-variable"><span class="hljs-variable">$curr</span></span> != <span class="hljs-variable"><span class="hljs-variable">$prev</span></span> ]]; <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span> <span class="hljs-string"><span class="hljs-string">'%s\n'</span></span> <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$curr</span></span></span><span class="hljs-string">"</span></span> &gt;&gt;/home/me/Progs/iNet/monitor/site.log <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span> <span class="hljs-string"><span class="hljs-string">'%s %s %s\n'</span></span> <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$time</span></span></span><span class="hljs-string">"</span></span> <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$dlay</span></span></span><span class="hljs-string">"</span></span> <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$code</span></span></span><span class="hljs-string">"</span></span> &gt;&gt;/home/me/Progs/iNet/monitor/site.log</code> </pre><br>  ... und gleichzeitig zeichnen wir die aktuellen Informationen auf: Zeit, Verz√∂gerung beim Empfang einer Antwort von der Site, Site-Antwortcode (falls nicht normal): <br><br><pre> <code class="bash hljs"> <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span> <span class="hljs-string"><span class="hljs-string">'%s %s %s\n'</span></span> <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$time</span></span></span><span class="hljs-string">"</span></span> <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$dlay</span></span></span><span class="hljs-string">"</span></span> <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$code</span></span></span><span class="hljs-string">"</span></span> &gt;&gt;/home/me/Progs/iNet/monitor/site.log</code> </pre><br>  Dies wird beim Navigieren helfen: Der eine oder andere Tag begann mit der einen oder anderen Geschwindigkeit der Site.  In anderen F√§llen sollten Sie die Datei nicht mit unn√∂tigen Eintr√§gen √ºberladen.  Nat√ºrlich schreiben wir es auf, wenn wir einen ungew√∂hnlichen Serverstatuscode erhalten: <br><br><pre> <code class="bash hljs"><span class="hljs-keyword"><span class="hljs-keyword">elif</span></span> [[ -n <span class="hljs-variable"><span class="hljs-variable">$code</span></span> ]]; <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span> <span class="hljs-string"><span class="hljs-string">'%s %s %s\n'</span></span> <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$time</span></span></span><span class="hljs-string">"</span></span> <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$dlay</span></span></span><span class="hljs-string">"</span></span> <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$code</span></span></span><span class="hljs-string">"</span></span> &gt;&gt;/home/me/Progs/iNet/monitor/site.log</code> </pre><br>  Und schreiben Sie auch, wenn die Serverantwortzeit l√§nger als gew√∂hnlich ist.  Meine Website war normalerweise f√ºr 0,23 bis 0,25 Sekunden verantwortlich, daher zeichne ich Antworten auf, die l√§nger als 0,3 Sekunden dauerten: <br><br><pre> <code class="bash hljs"><span class="hljs-keyword"><span class="hljs-keyword">elif</span></span> (( $(<span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$dlay</span></span></span><span class="hljs-string"> &gt; 0.3"</span></span> | bc -l) )); <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span> <span class="hljs-string"><span class="hljs-string">'%s %s\n'</span></span> <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$time</span></span></span><span class="hljs-string">"</span></span> <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$dlay</span></span></span><span class="hljs-string">"</span></span> &gt;&gt;/home/me/Progs/iNet/monitor/site.log</code> </pre><br>  Schlie√ülich zeichne ich einmal pro Stunde einfach die vom Server empfangene Zeit auf - als Zeichen daf√ºr, dass er lebt, und gleichzeitig als eine Art Markup der Datei: <br><br><pre> <code class="bash hljs"><span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$time</span></span></span><span class="hljs-string">"</span></span> | grep -e :00: | cat &gt;&gt;/home/me/Progs/iNet/monitor/site.log <span class="hljs-keyword"><span class="hljs-keyword">fi</span></span></code> </pre><br>  Wir erhalten den Inhalt der Datei, in der das Markup mit st√ºndlichen Aufzeichnungen visuell hilft, ohne durchzulesen, um festzustellen, wann die Last h√∂her oder niedriger ist (mehr Datens√§tze pro Stunde): <br><br><pre> <code class="plaintext hljs">19:42:28 0.461214 19:53:29 0.443956 20:00:29 20:09:30 2.156462 20:10:29 0.358294 20:45:29 0.313378 20:51:30 0.563886 20:54:30 0.307219 21:00:30 0.722343 21:01:30 0.310284 21:09:30 0.379662 21:10:31 1.305779 21:12:35 5.799455 21:23:31 1.054537 21:24:31 1.230391 21:40:31 0.461266 21:42:37 7.140093 22:00:31 22:12:37 5.724768 22:14:31 0.303500 22:42:37 5.735173 23:00:32 23:10:32 0.318207 date: Mon, 11 Feb 2019 00:00:34 0.235298 00:01:33 0.315093 01:00:34 01:37:41 5.741847 02:00:36 02:48:37 0.343234 02:56:37 0.647698 02:57:38 1.670538 02:58:39 2.327980 02:59:37 0.663547 03:00:37 03:40:38 0.331613 04:00:38 04:11:38 0.217022 04:50:39 0.313566 04:55:45 5.719911 05:00:39</code> </pre><br>  Und schlie√ülich zeigen wir Informationen auf dem Bildschirm an.  Und wenn Curl fehlgeschlagen ist, zeigen wir eine Nachricht dar√ºber an und schreiben sie (und f√ºhren gleichzeitig Ping aus und melden uns an, um zu √ºberpr√ºfen, ob der Server √ºberhaupt aktiv ist): <br><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">printf</span></span> <span class="hljs-string"><span class="hljs-string">'%s\n%s\n%s'</span></span> <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$time</span></span></span><span class="hljs-string">"</span></span> <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$dlay</span></span></span><span class="hljs-string">"</span></span> <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$code</span></span></span><span class="hljs-string">"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (( <span class="hljs-variable"><span class="hljs-variable">$errr</span></span> != 0 )); <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> date &gt;&gt;/home/me/Progs/iNet/monitor/site.log date <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span> <span class="hljs-string"><span class="hljs-string">'CURL Request failed. Error: %s\n'</span></span> <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$errr</span></span></span><span class="hljs-string">"</span></span> &gt;&gt;/home/me/Progs/iNet/monitor/site.log <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span> <span class="hljs-string"><span class="hljs-string">'CURL Request failed. Error: %s\n'</span></span> <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$errr</span></span></span><span class="hljs-string">"</span></span> pung=$(ping -c 1 178.248.237.68) <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span> <span class="hljs-string"><span class="hljs-string">'Ping: %s\n----\n'</span></span> <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$pung</span></span></span><span class="hljs-string">"</span></span> &gt;&gt;/home/me/Progs/iNet/monitor/site.log <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span> <span class="hljs-string"><span class="hljs-string">'Ping: %s\n'</span></span> <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$pung</span></span></span><span class="hljs-string">"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">fi</span></span></code> </pre><br>  Ersetzen Sie die IP-Adresse in der Ping-Zeichenfolge durch die tats√§chliche IP-Adresse Ihrer Site. <br><br><h3>  8. Nachwort </h3><br>  Das Ergebnis der Arbeit: <br><br><img src="https://habrastorage.org/webt/hk/zs/v-/hkzsv-3j9g-cv-wqklt2szu37hk.jpeg" alt="Der einfachste Website-Monitor" title="Der einfachste Website-Monitor"><br><br>  Links im Bedienfeld sehen Sie die Uhrzeit in UTC und die aktuelle Reaktionsf√§higkeit der Site.  Auf der rechten Seite befindet sich das Protokoll: Es ist f√ºr die Rallye auch bei einem fl√ºchtigen Bildlauf sichtbar, w√§hrend welcher Stunden die Last mehr oder weniger war.  Sie k√∂nnen auch ungew√∂hnlich langsame Reaktionen feststellen (Spitzen; obwohl noch nicht klar ist, woher sie kommen). <br><br>  Das ist alles.  Das Skript erwies sich als einfach, Eiche, und es kann verbessert werden: Arbeiten an Optimierung, Portabilit√§t, Verbesserung von Benachrichtigungen und Anzeigen unter Ber√ºcksichtigung von Proxy und Cache ... <br><br>  Aber bereits in dieser Art von Programm kann es wahrscheinlich eine Vorstellung vom Zustand Ihrer Site geben.  Und lassen Sie es eine Seite sein, die klugerweise angemessen ist und f√ºr Menschen und alle Kreaturen n√ºtzlich ist! <br><br><div class="spoiler">  <b class="spoiler_title">Volltext des Skripts mit Kommentaren.</b>  <b class="spoiler_title">Vergessen Sie nicht, die notwendigen √Ñnderungen vorzunehmen!</b> <div class="spoiler_text"><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#!/bin/bash # Monitor server responses (run this every 60 seconds): info=$(curl -I -o /dev/stdout -w '%{time_total}' --url https://example.ru/ -m 9 -s) errr=$(echo $?) # errr = CURL error code https://curl.haxx.se/libcurl/c/libcurl-errors.html code=$(echo "$info" | grep HTTP | grep -v 'HTTP/2 200') date=$(echo "$info" | grep -i 'date:') dlay=$(echo "$info" | grep  | sed -e 's///') # code = Response code = 200? # =&gt; empty, otherwise response code string # # date = from HTTP Header of the server responded, like: # Date: Sun, 10 Feb 2019 05:01:50 GMT # # dlay = Response delay ("time_total") from CURL, like: # 0.25321 #printf 'errr: %s\n' "$errr" #printf 'code: %s\n' "$code" #printf '%s\n' "$date" #printf 'dlay: %s\n' "$dlay" curr=$(echo "$date" | sed -e 's/\(20[0-9][0-9]\).*$/\1/') time=$(echo "$date" | sed -e 's/^.*\ \([0-9][0-9]:.*\)\ GMT\r$/\1/') prev=$(cat /home/me/Progs/iNet/monitor/site.log | grep -e 'date:' | tail -1) # = Previously logged date, like: # date: Sun, 10 Feb 2019 # Day logged before vs day returned by the server; usually the same if [[ $curr != $prev ]]; then # Write date etc., at the beginning of every day: printf '%s\n' "$curr" &gt;&gt;/home/me/Progs/iNet/monitor/site.log printf '%s %s %s\n' "$time" "$dlay" "$code" &gt;&gt;/home/me/Progs/iNet/monitor/site.log elif [[ -n $code ]]; then # If the response had HTTP error code - log it: printf '%s %s ? %s\n' "$time" "$dlay" "$code" &gt;&gt;/home/me/Progs/iNet/monitor/site.log elif (( $(echo "$dlay &gt; 0.3" | bc -l) )); then # If the response delay was large - log it: printf '%s %s %s\n' "$time" "$dlay" "$code" &gt;&gt;/home/me/Progs/iNet/monitor/site.log else # If it's the start of an hour - just log the time echo "$time" | grep -e :00: | cat &gt;&gt;/home/me/Progs/iNet/monitor/site.log fi # To screen: printf '%s\n%s\n%s' "$time" "$dlay" "$code" # On CURL error: if (( $errr != 0 )); then date &gt;&gt;/home/me/Progs/iNet/monitor/site.log date printf 'CURL Request failed. Error: %s\n' "$errr" &gt;&gt;/home/me/Progs/iNet/monitor/site.log printf 'CURL Request failed. Error: %s\n' "$errr" pung=$(ping -c 1 178.248.237.68) printf 'Ping: %s\n----\n' "$pung" &gt;&gt;/home/me/Progs/iNet/monitor/site.log printf 'Ping: %s\n' "$pung" fi</span></span></code> </pre><br></div></div><br><br>  <b>PS.</b>  <b>Im Anschluss an die Diskussion</b> (am 02/12/2019): <br><br>  Wie ich gehofft hatte, haben Experten viele interessante Kommentare geschrieben. <br><br>  Nachdem ich es mir √ºberlegt habe, kann ich die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link">rsashka-</a> Frage beantworten, was der Vorteil dieses Skripts ist. <br><br>  Andere Tools wie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">NetData</a> (danke an <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link">tchspprt</a> f√ºr den Tipp!) <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link">Stellen</a> eine gro√üe Anzahl von Daten <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link">bereit</a> , die nicht lange gespeichert werden.  NetData ist ein gutes Tool, wenn Sie jeden Tag arbeiten und Websites professionell pflegen.  Gut zur Diagnose aktueller Probleme. <br><br>  Ein Skript wie das meine soll ein Auge auf andere Dinge haben.  Das Skript erfordert keine speziellen Studien und Einstellungen.  Das ist nicht schlecht f√ºr Laien.  Und seine Protokolle nehmen so wenig Platz ein, dass sie √ºberhaupt nicht gel√∂scht werden k√∂nnen.  Sie k√∂nnen sich im Laufe der Jahre ansammeln, und in den Jahren N + 1 k√∂nnen Sie sehen: ‚ÄûWow, 2019 war meine Reaktionszeit eineinhalb Mal niedriger! ..‚Äú <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das hei√üt, eine solche L√∂sung hat eine eigene Nische - haupts√§chlich f√ºr Nicht-Systemadministratoren. (Wie </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tchspprt</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> sagt </font><font style="vertical-align: inherit;">: "Es geht darum, wie man die Katze eines Nachbarn im Urlaub f√ºttert"). </font></font><br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">andreymal</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> empfahl eine interessante M√∂glichkeit, die Last der Site ohne zus√§tzliche Mittel zu ber√ºcksichtigen und dann einfach √ºber die Zugriffsprotokolle auf der Site anzuzeigen. Und Sie k√∂nnen sch√∂ne Grafiken darauf erstellen. Ich werde diese Option wahrscheinlich ausprobieren und auf </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Github posten,</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> was passiert ist. </font></font><br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">unnforgiven hat eine</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> andere interessante L√∂sung empfohlen - wahrscheinlich eine einfache (Prometheus, Blackbox und Alermanager √ºber Docker Composer installieren). Auf meinem einfachen, billigen VPS ist nicht genug f√ºr diesen Speicher; und Linux mit einem alten Kernel - Docker startet nicht. Aber danke f√ºr die Option! </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ein weiterer Tipp</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tchspprt</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : Graphit + Prometheus + Grafana. </font><font style="vertical-align: inherit;">Oder stellen Sie dem Skript sch√∂ne Grafiken zur Verf√ºgung (gnuplot oder rrdtool). </font></font><br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mcalexvrn</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> empfiehlt ein einfaches Tool: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Uptimerobot</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font> Vielen Dank! <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ich danke allen f√ºr diese vielen Informationen! </font><font style="vertical-align: inherit;">Lass es f√ºr Menschen n√ºtzlich sein ...</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de439894/">https://habr.com/ru/post/de439894/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de439882/index.html">Abenteuer mit ptrace (2)</a></li>
<li><a href="../de439884/index.html">So lehnen Sie unn√∂tige Newsletter mit einem einzigen Knopf ab. Yandex.Mail Team Erfahrung</a></li>
<li><a href="../de439886/index.html">Wie ich einem neuronalen Netzwerk beigebracht habe, die Positionsbewertungsfunktion beim russischen AI Cup CodeBall 2018 zu implementieren</a></li>
<li><a href="../de439890/index.html">F√§higkeiten sind 100% oder weniger.</a></li>
<li><a href="../de439892/index.html">Wie man f√ºr ein Jahr plant. Fallstudie eines IT-Unternehmens mit 120 Mitarbeitern und zwei Praktiken f√ºr kleine Teams</a></li>
<li><a href="../de439896/index.html">Ethik der automatischen Beitr√§ge</a></li>
<li><a href="../de439898/index.html">VBA und Python f√ºr Excel- und MS Office-Automatisierung</a></li>
<li><a href="../de439900/index.html">Julia und die Koordinatenabstiegsmethode</a></li>
<li><a href="../de439902/index.html">Erkl√§rung der physikalischen Natur des Ph√§nomens der ‚ÄûAuftriebskraft des Fl√ºgels‚Äú ohne Verwendung der Bernoulli-Gleichung. Teil 2</a></li>
<li><a href="../de439906/index.html">Kritische Sicherheitsanf√§lligkeit in Zemana Antivirus-Produkten und mehr</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>