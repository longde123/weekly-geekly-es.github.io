<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚ô•Ô∏è üë©üèΩ‚Äçü§ù‚Äçüë®üèª ‚òπÔ∏è Biblioteca de widgets ass√≠ncronos Qt-async üèçÔ∏è üßîüèª üôÖüèº</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Bom dia a todos. Quero falar um pouco sobre o meu projeto qt-async , talvez pare√ßa interessante ou at√© √∫til para algu√©m. 

 Assincronia e multithreadi...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Biblioteca de widgets ass√≠ncronos Qt-async</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/451722/"> Bom dia a todos.  Quero falar um pouco sobre o meu projeto <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">qt-async</a> , talvez pare√ßa interessante ou at√© √∫til para algu√©m. <br><br>  Assincronia e multithreading h√° muito que est√£o seriamente inclu√≠das na vida cotidiana dos desenvolvedores.  Muitas linguagens e bibliotecas modernas s√£o projetadas com o uso ass√≠ncrono em mente.  A linguagem C ++ tamb√©m est√° se movendo lentamente nessa dire√ß√£o - apareceram std :: thread, std :: promessa / future, eles est√£o prestes a trazer corotinas e redes.  A biblioteca Qt tamb√©m n√£o fica para tr√°s, oferecendo seus an√°logos QThread, QRunnable, QThreadPool, QFuture, etc.  Ao mesmo tempo, n√£o encontrei widgets para exibir a√ß√µes ass√≠ncronas no Qt (talvez estivesse parecendo mal, correto se estiver enganado). <br><br>  Portanto, decidi compensar as defici√™ncias e tentar implementar esse widget por conta pr√≥pria.  O desenvolvimento multithread √© um neg√≥cio complexo, mas interessante. <br><a name="habracut"></a><br>  Antes de prosseguir com a implementa√ß√£o do widget, √© necess√°rio descrever o modelo que ele apresentar√° ao usu√°rio na forma de uma janela.  Na sua forma mais geral, a opera√ß√£o do widget me parece a seguinte: em algum momento, o usu√°rio ou o sistema inicia uma opera√ß√£o ass√≠ncrona.  Neste ponto, o widget mostra o progresso da opera√ß√£o ou simplesmente uma indica√ß√£o da opera√ß√£o.  Opcionalmente, o usu√°rio pode cancelar a opera√ß√£o.  Em seguida, a opera√ß√£o ass√≠ncrona √© conclu√≠da de duas maneiras: ocorreu um erro e nosso widget o mostra ou o widget mostra o resultado da opera√ß√£o bem-sucedida. <br><br>  Assim, nosso modelo pode estar em um dos tr√™s estados: <br><br><ol><li>  Progresso - uma opera√ß√£o ass√≠ncrona est√° em andamento </li><li>  Erro - falha na opera√ß√£o ass√≠ncrona </li><li>  Valor - opera√ß√£o ass√≠ncrona conclu√≠da com sucesso </li></ol><br>  Em cada um dos estados, o modelo deve armazenar os dados correspondentes, ent√£o chamei o modelo AsyncValue.  √â importante observar que a pr√≥pria opera√ß√£o ass√≠ncrona n√£o faz parte do nosso modelo, apenas altera seu estado.  Acontece que o AsyncValue pode ser usado com qualquer biblioteca ass√≠ncrona, observando um padr√£o de uso simples: <br><br><ol><li>  No in√≠cio da opera√ß√£o ass√≠ncrona, defina AsuncValue como Progress </li><li>  No final - em Erro ou em Valor, dependendo do sucesso da opera√ß√£o </li><li>  Opcionalmente, durante a opera√ß√£o, voc√™ pode atualizar os dados do Progress e ouvir o sinalizador Stop se o usu√°rio tiver a oportunidade de interromper a opera√ß√£o. </li></ol><br>  Aqui est√° um exemplo esquem√°tico usando QRunnable: <br><br><pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyRunnable</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> QRunnable { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: MyRunnable(AsyncValue&amp; value) : m_value(value) {} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">run</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> final </span></span>{ m_value.setProgress(...); <span class="hljs-comment"><span class="hljs-comment">// do calculation if (success) m_value.setValue(...); else m_value.setError(...); } private: AsyncValue&amp; m_value; }</span></span></code> </pre> <br>  O mesmo esquema para trabalhar com std :: thread: <br><br><pre> <code class="cpp hljs">AsyncValue value; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-function"><span class="hljs-function">thread </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">thread</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">([&amp;value] () { value.setProgress(...); </span></span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-params"><span class="hljs-comment">// do calculation if (success) value.setValue(...); else value.setError(...); });</span></span></span></span></span></span></code> </pre><br>  Assim, a primeira vers√£o da nossa classe poderia ser algo como isto: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> ValueType_t, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> ErrorType_t, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> ProgressType_t&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AsyncValue</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> ValueType = ValueType_t; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> ErrorType = ErrorType_t; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> ProgressType = ProgressType_t; <span class="hljs-comment"><span class="hljs-comment">// public API private: QReadWriteLock m_lock; std::variant&lt;ValueType, ErrorType, ProgressType&gt; m_value; };</span></span></code> </pre><br>  Todo mundo que se depara com classes que oferecem suporte a multithreading sabe que a interface dessas classes √© diferente dos an√°logos de thread √∫nico.  Por exemplo, a fun√ß√£o size () √© in√∫til e perigosa em um vetor multiencadeado.  Seu resultado pode se tornar imediatamente inv√°lido, pois o vetor pode ser modificado no momento em outro encadeamento. <br><br>  Os usu√°rios da classe AsyncValue devem poder acessar dados da classe.  A emiss√£o de uma c√≥pia dos dados pode ser cara, qualquer um dos tipos ValueType / ErrorType / ProgressType pode ser pesado.  A emiss√£o de um link para dados internos √© perigosa - a qualquer momento, ela pode se tornar inv√°lida.  A seguinte solu√ß√£o √© proposta: <br><br>  1. Conceda acesso aos dados por meio das fun√ß√µes accessValue / accessError / accessProgress, nas quais s√£o recebidas lambdas que recebem os dados correspondentes.  Por exemplo: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Pred&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">accessValue</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Pred valuePred)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-function"><span class="hljs-function">QReadLocker </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">locker</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(&amp;m_lock)</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (m_value.index() != <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; valuePred(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::get&lt;<span class="hljs-number"><span class="hljs-number">0</span></span>&gt;(m_value)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre><br>  Assim, o acesso ao valor interno √© realizado por refer√™ncia e est√° sob o bloqueio para leitura.  Ou seja, o link no momento do acesso n√£o se tornar√° inv√°lido. <br><br>  2. O usu√°rio AsyncValue na fun√ß√£o accessValue pode lembrar o link para dados internos, desde que ele esteja inscrito no sinal stateChanged e ap√≥s o processamento o sinal n√£o precise mais usar esse link, porque  ela se tornar√° inv√°lida. <br><br>  Sob tais condi√ß√µes, o consumidor do AsyncValue sempre garante um acesso a dados v√°lido e conveniente.  Esta solu√ß√£o tem v√°rias consequ√™ncias que afetam a implementa√ß√£o da classe AsyncValue. <br><br>  Primeiro, nossa classe deve enviar um sinal quando um estado muda, mas ao mesmo tempo √© modelo.  Teremos que adicionar uma classe Qt b√°sica, onde podemos determinar o sinal pelo qual o widget atualizar√° seu conte√∫do e todos os interessados ‚Äã‚Äãatualizar√£o links para dados internos. <br><br><pre> <code class="cpp hljs">lass AsyncValueBase : <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> QObject { <span class="hljs-function"><span class="hljs-function">Q_OBJECT </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Q_DISABLE_COPY</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(AsyncValueBase)</span></span></span><span class="hljs-function"> signals: </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">stateChanged</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; };</code> </pre><br>  Em segundo lugar, o momento do envio do sinal deve ser bloqueado para leitura (para que o AsyncValue n√£o possa ser alterado at√© que todos processem o sinal) e, o <i>mais importante</i> , nesse momento deve haver links v√°lidos para dados novos e antigos.  Como no processo de envio do sinal, alguns consumidores do AsyncValue ainda usam os links antigos e aqueles que processaram o sinal usam os novos. <br><br>  Acontece que std :: variant n√£o √© adequado para n√≥s e teremos que armazenar dados na mem√≥ria din√¢mica para que os endere√ßos de dados novos e antigos n√£o sejam alterados. <br><br>  Uma pequena digress√£o. <br><br>  Voc√™ pode considerar outras implementa√ß√µes da classe AsyncValue que n√£o exigem aloca√ß√µes din√¢micas: <br><br><ol><li>  D√™ aos consumidores apenas c√≥pias dos dados internos do AsyncValue.  Como escrevi anteriormente, essa solu√ß√£o pode ser mais abaixo do ideal se os dados forem grandes. </li><li>  Defina dois sinais em vez de um: stateWillChange / stateDidChange.  Obrigar os consumidores a se livrar de links antigos no primeiro sinal e receber novos links no segundo sinal.  Parece-me que esse esquema complica excessivamente os consumidores do AsyncValue, porque  eles t√™m intervalos de tempo quando o acesso ao AsyncValue √© negado. </li></ol><br>  A seguinte implementa√ß√£o esquem√°tica da fun√ß√£o setValue √© obtida: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> AsyncValue::setValue(...) {  m_lock            {   m_lock          m_lock   }  stateChanged       m_lock   };</code> </pre><br>  Como voc√™ pode ver, precisamos aumentar o bloqueio m_lock para escrever e devolv√™-lo para leitura.  Infelizmente, n√£o existe esse suporte na classe QReadWriteLock.  Voc√™ pode obter a funcionalidade desejada com um par de QMutex / QReadWriteLock.  Aqui est√° uma implementa√ß√£o da classe AsyncValue, quase real: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//   AsyncValue enum class ASYNC_VALUE_STATE { VALUE, ERROR, PROGRESS }; Q_DECLARE_METATYPE(ASYNC_VALUE_STATE); //        class AsyncValueBase : public QObject { Q_OBJECT Q_DISABLE_COPY(AsyncValueBase) signals: void stateChanged(ASYNC_VALUE_STATE state); protected: explicit AsyncValueBase(ASYNC_VALUE_STATE state, QObject* parent = nullptr); //     PromoteToWriteLock/DemoteToReadLock QMutex m_writeLock; QReadWriteLock m_contentLock; //   ASYNC_VALUE_STATE m_state; }; template &lt;typename ValueType_t, typename ErrorType_t, typename ProgressType_t&gt; class AsyncValueTemplate : public AsyncValueBase { //  struct Content { std::unique_ptr&lt;ValueType_t&gt; value; std::unique_ptr&lt;ErrorType_t&gt; error; std::unique_ptr&lt;ProgressType+t&gt; progress; }; Content m_content; public: using ValueType = ValueType_t; using ErrorType = ErrorType_t; using ProgressType = ProgressType_t; //    template &lt;typename... Args&gt; void emplaceValue(Args&amp;&amp; ...arguments) { moveValue(std::make_unique&lt;ValueType&gt;(std::forward&lt;Args&gt;(arguments)...)); } //    void moveValue(std::unique_ptr&lt;ValueType&gt; value) { //       Content oldContent; //   emplaceXXX/moveXXX    QMutexLocker writeLocker(&amp;m_writeLock); { //       QWriteLocker locker(&amp;m_contentLock); //      oldContent = std::move(m_content); //    m_content.value = std::move(value); //    m_state = ASYNC_VALUE_STATE::VALUE; //     } //   emitStateChanged(); //    emplaceXXX/moveXXX  //    } //   value void emplaceError(Args&amp;&amp; ...arguments); void moveError(std::unique_ptr&lt;ErrorType&gt; error); void emplaceProgress(Args&amp;&amp; ...arguments); void moveProgress(std::unique_ptr&lt;ProgressType&gt; progress); template &lt;typename Pred&gt; bool accessValue(Pred valuePred) { //     QReadLocker locker(&amp;m_contentLock); //    if (m_state != ASYNC_VALUE_STATE::VALUE) return false; //      valuePred(*m_content.value); //     return true; } //  accessValue bool accessError(Pred errorPred) bool accessProgress(Pred progressPred) };</span></span></code> </pre><br>  Para quem n√£o est√° cansado e n√£o est√° perdido, continuamos. <br><br>  Como voc√™ pode ver, temos fun√ß√µes accessXXX que n√£o esperam at√© que o AsyncValue entre no estado correspondente, mas simplesmente retornam false.  √Äs vezes, √© √∫til aguardar de forma s√≠ncrona at√© que um valor ou erro apare√ßa no AsyncValue.  Essencialmente, precisamos de um an√°logo de std :: future :: get.  Aqui est√° a assinatura da fun√ß√£o: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> ValuePred, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> ErrorPred&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">wait</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ValuePred valuePred, ErrorPred errorPred)</span></span></span></span>;</code> </pre><br>  Para que essa fun√ß√£o funcione, precisamos de uma vari√°vel de condi√ß√£o - um objeto de sincroniza√ß√£o que possa ser esperado em um thread e ativado em outro.  Na fun√ß√£o de espera, devemos esperar e, ao alterar o estado de AsyncValue de Progresso para Valor ou Erro, devemos notificar os gar√ßons. <br><br>  Adicionar outro campo √† classe AsyncValue, necess√°rio em casos raros quando a fun√ß√£o de espera √© usada, me levou a pensar - esse campo pode ser opcional?  A resposta √© √≥bvia, √© claro que √© poss√≠vel se voc√™ armazenar std :: unique_ptr e cri√°-lo, se necess√°rio.  A segunda quest√£o surgiu - √© poss√≠vel tornar esse campo opcional e n√£o fazer aloca√ß√µes din√¢micas.  Quem se importa, veja o c√≥digo a seguir.  A id√©ia principal √© a seguinte: a primeira chamada de espera cria uma estrutura QWaitCondition na pilha e grava seu ponteiro em AsyncValue; as chamadas de espera subsequentes simplesmente verificam se o ponteiro n√£o est√° vazio; use a estrutura desse ponteiro; se o ponteiro estiver vazio, veja acima a primeira chamada de espera . <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AsyncValueBase</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> QObject { ... <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Waiter</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-comment"><span class="hljs-comment">//     QWaitCondition waitValue; //   wait quint16 subWaiters = 0; //  wait     QWaitCondition waitSubWaiters; }; //    Waiter* m_waiter = nullptr; }; template &lt;typename ValuePred, typename ErrorPred&gt; void wait(ValuePred valuePred, ErrorPred errorPred) { //   -      if (access(valuePred, errorPred)) return; //  AsyncValue   QMutexLocker writeLocker(&amp;m_writeLock); //     if (access(valuePred, errorPred)) return; //    wait  if (!m_waiter) { //  Waiter   Waiter theWaiter; //       if SCOPE_EXIT { //     wait, //    theWaiter if (m_waiter-&gt;subWaiters &gt; 0) { //    subWaiters   do { m_waiter-&gt;waitSubWaiters.wait(&amp;m_writeLock); } while (m_waiter-&gt;subWaiters != 0); } //   wait  , //       Waiter m_waiter = nullptr; }; //    Waiter  AsyncValue //    wait   m_waiter = &amp;theWaiter; //   AsyncValue     Value  Error //    do { m_waiter-&gt;waitValue.wait(&amp;m_writeLock); } while (!access(valuePred, errorPred)); } //   wait   else { //       else SCOPE_EXIT { //      m_waiter-&gt;subWaiters -= 1; //     -&gt;   wait if (m_waiter-&gt;subWaiters == 0) m_waiter-&gt;waitSubWaiters.wakeAll(); }; //      m_waiter-&gt;subWaiters += 1; //   AsyncValue     Value  Error //    do { m_waiter-&gt;waitValue.wait(&amp;m_writeLock); } while (!access(valuePred, errorPred)); } }</span></span></code> </pre><br>  Como j√° mencionado, o AsyncValue n√£o possui um m√©todo para computa√ß√£o ass√≠ncrona para n√£o ser vinculado a uma biblioteca espec√≠fica.  Em vez disso, s√£o usadas fun√ß√µes livres que implementam a assincronia de uma maneira ou de outra.  A seguir, √© apresentado um exemplo de computa√ß√£o do AsyncValue em um pool de threads: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> AsyncValueType, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Func, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span>... ProgressArgs&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">asyncValueRunThreadPool</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(QThreadPool *pool, AsyncValueType&amp; value, Func&amp;&amp; func, ProgressArgs&amp;&amp; ...progressArgs)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//    auto progress = std::make_unique&lt;typename AsyncValueType::ProgressType&gt;(std::forward&lt;ProgressArgs&gt;(progressArgs)...); //    auto progressPtr = progress.get(); //    AsyncValue if (!value.startProgress(std::move(progress))) return false; QtConcurrent::run(pool, [&amp;value, progressPtr, func = std::forward&lt;Func&gt;(func)](){ SCOPE_EXIT { //     AsyncValue,    value.completeProgress(progressPtr); }; //  AsyncValue func(*progressPtr, value); }); return true; }</span></span></code> </pre><br>  A biblioteca implementa mais duas fun√ß√µes semelhantes: asyncValueRunNetwork para processamento de solicita√ß√µes de rede e asyncValueRunThread, que executa uma opera√ß√£o em um thread rec√©m-criado.  Os usu√°rios da biblioteca podem criar facilmente suas pr√≥prias fun√ß√µes e us√°-las para usar as ferramentas ass√≠ncronas usadas em outros locais. <br><br>  Para aumentar a seguran√ßa, a classe AsyncValue foi estendida com outra classe de modelo AsyncTrackErrorsPolicy, que permite responder ao uso indevido de AsyncValue.  Por exemplo, aqui est√° a implementa√ß√£o padr√£o da fun√ß√£o AsyncTrackErrorsPolicy :: inProgressWhileDestruct, que ser√° chamada se AsyncValue for destru√≠do enquanto a opera√ß√£o ass√≠ncrona estiver em execu√ß√£o: <br><br><pre> <code class="cpp hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">inProgressWhileDestruct</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ Q_ASSERT(<span class="hljs-literal"><span class="hljs-literal">false</span></span> &amp;&amp; <span class="hljs-string"><span class="hljs-string">"Destructing value while it's in progress"</span></span>); }</code> </pre><br>  Quanto aos widgets, sua implementa√ß√£o √© bastante simples e concisa.  O AsyncWidget √© um cont√™iner que cont√©m um widget para exibir um erro, progresso ou valor, dependendo do estado em que o AsyncValue estiver atualmente. <br><br><pre> <code class="cpp hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> QWidget* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createValueWidgetImpl</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ValueType&amp; value, QWidget* parent)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> QWidget* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createErrorWidgetImpl</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ErrorType&amp; error, QWidget* parent)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> QWidget* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createProgressWidgetImpl</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ProgressType&amp; progress, QWidget* parent)</span></span></span></span>;</code> </pre><br>  O usu√°rio √© obrigado a redefinir apenas a primeira fun√ß√£o, para exibir valor, os outros dois t√™m implementa√ß√µes padr√£o. <br><br>  A biblioteca <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">qt-async</a> acabou sendo compacta, mas ao mesmo tempo bastante √∫til.  O uso do AsyncValue / AsyncWidget, onde anteriormente havia fun√ß√µes s√≠ncronas e uma GUI est√°tica, permitir√° que seus aplicativos se tornem modernos e mais responsivos. <br><br>  Para quem leu o b√¥nus at√© o final - um v√≠deo do aplicativo de demonstra√ß√£o <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/aTXOpmVRXq0" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt451722/">https://habr.com/ru/post/pt451722/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt451708/index.html">Como se preparar para a verifica√ß√£o do ILV sobre dados pessoais: um guia completo</a></li>
<li><a href="../pt451710/index.html">Internet para o residente de ver√£o. N√≥s obtemos a velocidade m√°xima em redes 4G. Parte 2. Escolhendo uma Antena Externa</a></li>
<li><a href="../pt451716/index.html">Melhorando o desempenho do software com as ferramentas Intel para desenvolvedores. Modelagem num√©rica de objetos astrof√≠sicos</a></li>
<li><a href="../pt451718/index.html">Criar Assistente de Voz</a></li>
<li><a href="../pt451720/index.html">FIAS carregando no banco de dados no MSSQLSERVER por meios improvisados ‚Äã‚Äã(SQLXMLBULKLOAD). Como (provavelmente) n√£o precisa ser feito</a></li>
<li><a href="../pt451724/index.html">Skyrmion to skyrmion discord: skyrmions polares tridimensionais em ferroel√°sticos</a></li>
<li><a href="../pt451726/index.html">Procurando trabalho no exterior: 7 dicas simples para profissionais de TI</a></li>
<li><a href="../pt451728/index.html">RESTinio √© um servidor HTTP ass√≠ncrono. Ass√≠ncrono</a></li>
<li><a href="../pt451738/index.html">Breve revis√£o do artigo "DeViSE: Um Modelo de Incorpora√ß√£o Visual-Sem√¢ntica Profunda"</a></li>
<li><a href="../pt451742/index.html">Um dia antes do DotNext 2019 Piter. An√∫ncio de transmiss√£o gratuita</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>