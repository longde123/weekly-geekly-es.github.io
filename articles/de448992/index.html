<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üíÜüèº ü•Å üîê Vielseitiges und perfektes Hashing ‚è´ üôéüèº üöå</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Wir beginnen die Woche mit n√ºtzlichem Material zum Start des Kurses "Algorithmen f√ºr Entwickler" . Gute Lekt√ºre. 



 1. √úbersicht 

 Hashing ist ein ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Vielseitiges und perfektes Hashing</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/otus/blog/448992/">  Wir beginnen die Woche mit n√ºtzlichem Material zum Start des Kurses <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">"Algorithmen f√ºr Entwickler"</a> .  Gute Lekt√ºre. <br><br><img src="https://habrastorage.org/webt/na/5_/ja/na5_jaknhrabunnqxjqmc1yjtvi.png"><br><br>  <b>1. √úbersicht</b> <br><br>  Hashing ist ein gro√üartiges praktisches Werkzeug mit einer interessanten und subtilen Theorie.  Neben der Verwendung von Daten als Vokabularstruktur findet sich Hashing auch in vielen verschiedenen Bereichen, einschlie√ülich Kryptographie und Komplexit√§tstheorie.  In dieser Vorlesung beschreiben wir zwei wichtige Konzepte: universelles Hashing (auch als universelle Familie von Hash-Funktionen bekannt) und ideales Hashing. <a name="habracut"></a><br><br>  Das in dieser Vorlesung hervorgehobene Material umfasst: <br><br><ul><li>  Die formale Einstellung und die allgemeine Idee des Hashing. </li><li>  Universelles Hashing. </li><li>  Perfektes Hashing. </li></ul><br>  <b>2. Einf√ºhrung</b> <br><br>  Wir werden das Hauptproblem mit dem zuvor diskutierten W√∂rterbuch betrachten und zwei Versionen betrachten: statisch und dynamisch: <br><br><ul><li>  <i>Statisch</i> : Bei vielen S-Elementen m√∂chten wir sie so speichern, dass wir schnell eine Suche durchf√ºhren k√∂nnen. </li><li>  Zum Beispiel ein festes W√∂rterbuch. </li><li>  <i>Dynamisch</i> : Hier haben wir eine Folge von Anforderungen zum Einf√ºgen, Suchen und m√∂glicherweise Entfernen.  Wir wollen das alles effektiv machen. </li></ul><br>  F√ºr das erste Problem k√∂nnten wir ein sortiertes Array und eine bin√§re Suche verwenden.  F√ºr den zweiten k√∂nnten wir einen ausgeglichenen Suchbaum verwenden.  Hashing bietet jedoch einen alternativen Ansatz, der h√§ufig der schnellste und bequemste Weg ist, um diese Probleme zu l√∂sen.  Angenommen, Sie schreiben ein Programm f√ºr die KI-Suche und m√∂chten bereits gel√∂ste Situationen (Positionen auf der Tafel oder Elemente des Statusraums) speichern, um nicht dieselben Berechnungen zu wiederholen, wenn Sie erneut darauf sto√üen.  Hashing bietet eine einfache M√∂glichkeit, diese Informationen zu speichern.  Es gibt auch viele Anwendungen in der Kryptographie, in Netzwerken und in der Komplexit√§tstheorie. <br><br>  <b>3. Hash-Grundlagen</b> <br><br>  Die formale Einstellung f√ºr das Hashing ist wie folgt. <br><br><ul><li>  Die Schl√ºssel geh√∂ren zu einem gro√üen Satz von U. (Stellen Sie sich zum Beispiel vor, U ist eine Sammlung aller Zeichenfolgen mit einer maximalen L√§nge von 80 ASCII-Zeichen.) </li><li>  Es gibt einige S-Tasten in U, die wir wirklich brauchen (Tasten k√∂nnen entweder statisch oder dynamisch sein).  Sei N = | S |.  Stellen Sie sich vor, N ist viel kleiner als die Gr√∂√üe von U. Zum Beispiel ist S die Menge der Sch√ºlernamen in einer Klasse, die viel kleiner als 128 ^ 80 ist. </li><li>  Wir werden Einf√ºgungen und Suchen mit einem Array A der Gr√∂√üe M und einer <b>Hash-Funktion</b> h: U ‚Üí {0, ..., M - 1} durchf√ºhren.  Bei gegebenem Element x besteht die Idee des Hashings darin, dass wir es in A [h (x)] speichern m√∂chten.  Beachten Sie, dass Sie, wenn U klein w√§re (z. B. 2-stellige Zeichenfolgen), x einfach in A [x] speichern k√∂nnten, wie bei der Blocksortierung.  Das Problem ist, dass U gro√ü ist, also brauchen wir eine Hash-Funktion. </li><li>  Wir brauchen eine Methode, um Kollisionen aufzul√∂sen.  Eine Kollision ist, wenn h (x) = h (y) f√ºr zwei verschiedene Schl√ºssel x und y ist.  In dieser Vorlesung werden wir Kollisionen behandeln, indem wir jedes Element von A als verkn√ºpfte Liste definieren.  Es gibt eine Reihe anderer Methoden, aber f√ºr die Probleme, auf die wir uns hier konzentrieren werden, ist dies die am besten geeignete.  Diese Methode wird als Verkettungsmethode bezeichnet.  Um ein Element einzuf√ºgen, setzen wir es einfach ganz oben in die Liste.  Wenn h eine gute Hash-Funktion ist, hoffen wir, dass die Listen klein sind. </li></ul><br>  Eines der gro√üartigen Dinge beim Hashing ist, dass alle W√∂rterbuchoperationen unglaublich einfach zu implementieren sind.  Um nach dem Schl√ºssel x zu suchen, berechnen Sie einfach den Index i = h (x) und gehen Sie dann die Liste in A [i] durch, bis Sie ihn finden (oder verlassen Sie die Liste).  Platzieren Sie zum Einf√ºgen einfach ein neues Element oben in der Liste.  Zum L√∂schen m√ºssen Sie nur den L√∂schvorgang in der verkn√ºpften Liste ausf√ºhren.  Nun wenden wir uns der Frage zu: Was brauchen wir, um eine gute Leistung zu erzielen? <br><br>  W√ºnschenswerte Eigenschaften.  Wichtige w√ºnschenswerte Eigenschaften f√ºr ein gutes Hash-Schema: <br><br><ol><li>  Die Schl√ºssel sind gut verteilt, sodass wir nicht zu viele Kollisionen haben, da Kollisionen die Such- und L√∂schzeit beeinflussen. </li><li>  M = O (N): Insbesondere m√∂chten wir, dass unsere Schaltung die Eigenschaft (1) erreicht, ohne dass die Gr√∂√üe der Tabelle M viel gr√∂√üer als die Anzahl der Elemente N sein muss. </li><li>  Die Funktion h muss schnell berechnet werden.  In unserer heutigen Analyse werden wir die Zeit zur Berechnung von h (x) als Konstante betrachten.  Es ist jedoch zu beachten, dass dies nicht zu kompliziert sein sollte, da es sich auf die Gesamtausf√ºhrungszeit auswirkt. </li></ol><br>  Vor diesem Hintergrund betr√§gt die Suchzeit f√ºr das Element x O (die Gr√∂√üe der Liste betr√§gt A [h (x)]).  Gleiches gilt f√ºr L√∂schungen.  Einf√ºgungen ben√∂tigen O (1) Zeit, unabh√§ngig von der L√§nge der Listen.  Wir m√∂chten also analysieren, wie gro√ü diese Listen sind. <br><br>  Grundlegende Intuition: Eine M√∂glichkeit, Elemente sch√∂n zu verteilen, besteht darin, sie zuf√§llig zu verteilen.  Leider k√∂nnen wir nicht einfach den Zufallszahlengenerator verwenden, um zu entscheiden, wohin das n√§chste Element geleitet werden soll, da wir es dann nie wieder finden k√∂nnen.  Wir wollen also, dass h in einem formalen Sinne etwas ‚ÄûPseudozuf√§lliges‚Äú ist. <br><br>  Jetzt werden wir einige schlechte Nachrichten und dann einige gute Nachrichten pr√§sentieren. <br><br>  Anweisung 1 (schlechte Nachrichten) F√ºr jede Hash-Funktion h if | U |  ‚â• (N ‚àí1) M +1 gibt es eine Menge S von N Elementen, die alle an einer Stelle gehasht haben. <br><br>  Beweis: nach dem Dirichlet-Prinzip.  Um Kontrapunkte zu ber√ºcksichtigen, k√∂nnte U eine Gr√∂√üe von nicht mehr als M (N - 1) haben, wenn jeder Ort nicht mehr als N - 1 Elemente von U hat, die ihn hashen. <br><br>  Dies ist teilweise der Grund, warum Hashing so mysteri√∂s erscheint - wie kann argumentiert werden, dass Hashing gut ist, wenn Sie sich f√ºr eine Hash-Funktion M√∂glichkeiten ausdenken k√∂nnen, dies zu verhindern?  Eine Antwort ist, dass es viele einfache Hash-Funktionen gibt, die in der Praxis f√ºr typische S-Mengen gut funktionieren. Aber was ist, wenn wir eine gute Garantie f√ºr den schlimmsten Fall wollen? <br><br>  Hier ist die Schl√ºsselidee: Verwenden wir die Randomisierung in unserem h-Konstrukt, √§hnlich wie bei der randomisierten Quicksortierung.  (Unn√∂tig zu sagen, dass h eine deterministische Funktion sein wird).  Wir werden zeigen, dass f√ºr jede Sequenz von Einf√ºge- und Suchoperationen (wir m√ºssen nicht annehmen, dass die Menge der eingef√ºgten Elemente S zuf√§llig ist), wenn wir h auf diese probabilistische Weise w√§hlen, die Leistung von h in dieser Sequenz in Erwartung gut ist.  Dies ist also die gleiche Garantie wie bei randomisierten Quicksort oder Fallen.  Dies ist insbesondere die Idee des universellen Hashing. <br><br>  Sobald wir diese Idee entwickelt haben, werden wir sie f√ºr eine besonders unterhaltsame Anwendung namens ‚ÄûPerfect Hashing‚Äú verwenden. <br><br>  <b>4. Universelles Hashing</b> <br><br>  Definition 1. Ein randomisierter Algorithmus H zur Konstruktion von Hash-Funktionen h: U ‚Üí {1, ..., M} <br>  universell, wenn wir f√ºr alle x! = y in U haben <br><br><img src="https://habrastorage.org/webt/bj/h3/hd/bjh3hdghlrhmfl-4mf6i3xybf14.png"><br><br>  Wir k√∂nnen auch sagen, dass die Menge H von Hash-Funktionen eine universelle Familie von Hash-Funktionen ist, wenn die Prozedur ‚Äûzuf√§llig ausgew√§hlte h ‚àà H‚Äú universell ist.  (Hier identifizieren wir den Satz von Funktionen mit einer gleichm√§√üigen Verteilung √ºber den Satz.) <br><br>  Satz 2. Wenn H universell ist, dann f√ºr jede Menge S ‚äÜ U der Gr√∂√üe N, f√ºr jedes x ‚àà U (zum Beispiel, nach dem wir suchen k√∂nnten), wenn wir h zuf√§llig gem√§√ü H konstruieren, die erwartete Anzahl von Kollisionen zwischen x und anderen Elemente in S nicht mehr als N / M. <br><br>  Beweis: Jedes y ‚àà S (y! = X) hat nach der Definition von ‚Äûuniversal‚Äú h√∂chstens 1 / M Chance auf eine Kollision mit x.  Also <br><br><ul><li>  Sei Cxy = 1, wenn x und y kollidieren, andernfalls 0. </li><li>  Cx bezeichne die Gesamtzahl der Kollisionen f√ºr x.  Also, Cx = Py‚ààS, y! = X Cxy. </li><li>  Wir wissen, dass E [Cxy] = Pr (x und y kollidieren) ‚â§ 1 / M ist. </li><li>  Somit ist in der Linearit√§t der Erwartung E [Cx] = Py E [Cxy] &lt;N / M. </li></ul><br>  Jetzt erhalten wir die folgende Folgerung. <br><br>  Folgerung 3. Wenn H universell ist, betragen f√ºr jede Folge von Einf√ºge-, Such- und L√∂schoperationen L, in denen nicht mehr als M Elemente gleichzeitig in einem System vorhanden sein k√∂nnen, die erwarteten Gesamtkosten von L Operationen f√ºr ein zuf√§lliges h ‚àà H nur O (L) (Betrachtung der Zeit) h als Konstanten berechnen). <br><br>  Beweis: F√ºr jede gegebene Operation in der Sequenz sind ihre erwarteten Kosten gem√§√ü Satz 2 konstant, so dass die erwarteten Gesamtkosten von L Operationen O (L) in der Linearit√§t der Erwartung sind. <br><br>  Frage: K√∂nnen wir tats√§chlich ein universelles H bauen?  Wenn nicht, dann ist das alles ziemlich sinnlos.  Zum Gl√ºck lautet die Antwort ja. <br><br>  <i><b>4.1.</b></i>  <i><b>Erstellen einer universellen Hash-Familie: Matrix-Methode</b></i> <br><br>  Angenommen, die Schl√ºssel sind U-Bits lang.  Angenommen, die Gr√∂√üe der Tabelle M ist gleich Grad 2, daher ist der Index mit M = 2b b-Bit lang. <br><br>  Wir w√§hlen h als Zufallsmatrix 0/1 b-by-u und definieren h (x) = hx, wobei wir Mod 2 hinzuf√ºgen. Diese Matrizen sind kurz und dick.  Zum Beispiel: <br><br><img src="https://habrastorage.org/webt/ly/q4/4k/lyq44kg-g4d8iloztroepglar9k.png"><br><br>  Satz 4. F√ºr x! = Y Prh [h (x) = h (y)] = 1 / M = 1 / 2b. <br><br>  Beweis: Was bedeutet es, h mit x zu multiplizieren?  Wir k√∂nnen uns vorstellen, dass einige der Spalten h hinzugef√ºgt werden (Vektoraddition mod 2), wobei 1 Bit in x angibt, welche hinzugef√ºgt werden sollen.  (Zum Beispiel haben wir die 1. und 3. Spalte von h oben hinzugef√ºgt.) <br><br>  Nehmen Sie nun ein beliebiges Schl√ºsselpaar x, y, so dass x! = Y ist.  Sie m√ºssen irgendwo unterschiedlich sein, damit sie sich beispielsweise in der i-ten Koordinate unterscheiden, und der Vollst√§ndigkeit halber sagen wir xi = 0 und yi = 1. Stellen Sie sich vor, wir h√§tten zuerst alle h au√üer der i-ten Spalte ausgew√§hlt.  F√ºr die verbleibenden Proben der i-ten Spalte ist h (x) festgelegt.  Jede der 2b unterschiedlichen Einstellungen der i-ten Spalte ergibt jedoch einen anderen Wert von h (y) (insbesondere jedes Mal, wenn wir ein Bit in dieser Spalte drehen, verwandeln wir das entsprechende Bit in h (y)).  Es besteht also genau eine 1 / 2b-Chance, dass h (x) = h (y) ist. <br><br>  Es gibt andere Methoden zum Aufbau universeller Hash-Familien, die ebenfalls auf der Multiplikation von Primzahlen basieren (siehe Abschnitt 6.1). <br><br>  Die n√§chste Frage, die wir uns stellen werden: Wenn wir die Menge S korrigieren, k√∂nnen wir eine Hash-Funktion h finden, so dass alle Suchvorg√§nge eine konstante Zeit haben?  Die Antwort lautet ja, und dies f√ºhrt zum Thema perfektes Hashing. <br><br>  <b>5. Perfektes Hashing</b> <br><br>  Wir sagen, dass eine Hash-Funktion f√ºr S ideal ist, wenn alle Suchen in O (1) stattfinden.  Hier sind zwei M√∂glichkeiten, um perfekte Hash-Funktionen f√ºr eine bestimmte Menge S zu erstellen. <br><br>  <i><b>5.1 Methode 1: eine L√∂sung im Raum O (N2)</b></i> <br><br>  Angenommen, wir m√∂chten eine Tabelle haben, deren Gr√∂√üe quadratisch in der Gr√∂√üe N unseres W√∂rterbuchs S ist. Dann ist hier eine einfache Methode zum Erstellen einer idealen Hash-Funktion.  Sei H universell und M = N2.  Dann w√§hlen Sie einfach ein zuf√§lliges h aus H und probieren Sie es aus!  Die Aussage ist, dass es eine mindestens 50% ige Chance gibt, dass sie keine Kollisionen hat. <br><br>  Satz 5. Wenn H universell ist und M = N2, dann ist Prh‚àºH (keine Kollisionen in S) ‚â• 1/2. <br><br>  Beweis: <br><br>  ‚Ä¢ Wie viele Paare (x, y) gibt es in S?  Die Antwort lautet: <img src="https://habrastorage.org/webt/1n/oh/w7/1nohw79oejhbrsciul36nklg4sq.png"><br>  ‚Ä¢ F√ºr jedes Paar betr√§gt die Wahrscheinlichkeit ihrer Kollision per Definition der Universalit√§t ‚â§ 1 / M. <br>  ‚Ä¢ Also Pr (es gibt eine Kollision) ‚â§ <img src="https://habrastorage.org/webt/1n/oh/w7/1nohw79oejhbrsciul36nklg4sq.png">  / M &lt;1/2. <br><br>  Dies ist wie die andere Seite des "Geburtstagsparadoxons".  Wenn die Anzahl der Tage viel gr√∂√üer ist als die Anzahl der Personen im Quadrat, besteht eine vern√ºnftige Chance, dass kein Paar denselben Geburtstag hat. <br><br>  Wir w√§hlen also einfach ein zuf√§lliges h aus H aus, und wenn Kollisionen auftreten, w√§hlen wir einfach ein neues h aus.  Im Durchschnitt m√ºssen wir dies nur zweimal tun.  Was ist nun, wenn wir nur den O (N) -Raum verwenden m√∂chten? <br><br>  5.2 Methode 2: eine L√∂sung im Raum O (N) <br><br>  Die Frage, ob es m√∂glich ist, ein perfektes Hashing im O (N) -Raum zu erreichen, ist seit einiger Zeit offen: "Sollten die Tabellen sortiert werden?"  Das hei√üt, f√ºr eine feste Menge k√∂nnen Sie eine konstante Suchzeit nur mit linearem Raum erhalten?  Es gab eine Reihe immer komplexerer Versuche, bis sie schlie√ülich mit der guten Idee universeller Hash-Funktionen in einem zweistufigen Schema gel√∂st wurden. <br><br>  Das Verfahren ist wie folgt.  Zuerst werden wir mit Universal Hashing in eine Tabelle der Gr√∂√üe N hashen.  Dies f√ºhrt zu einigen Kollisionen (es sei denn, wir haben Gl√ºck).  Dann w√§rmen wir jedoch jeden Korb mit Methode 1 erneut auf und quadrieren die Korbgr√∂√üe, um keine Kollisionen zu erhalten.  Das Schema besteht also darin, dass wir eine Hash-Funktion der ersten Ebene h und eine Tabelle A der ersten Ebene haben und dann N Hash-Funktionen der zweiten Ebene h1, ..., hN und N der Tabelle der zweiten Ebene A1, ..., . ... Um das Element x zu finden, berechnen wir zuerst i = h (x) und dann das Element in Ai [hi (x)].  (Wenn Sie dies in der Praxis tun w√ºrden, k√∂nnten Sie das Flag so setzen, dass Sie den zweiten Schritt nur dann ausf√ºhren, wenn es wirklich Konflikte mit dem Index i gibt, andernfalls w√ºrden Sie einfach x selbst in A [i] setzen, aber lassen Sie uns Machen wir uns hier keine Sorgen.) <br><br>  Angenommen, eine Hash-Funktion h hasht n Elemente von S an Position i.  Wir haben bereits bewiesen (durch Analyse von Methode 1), dass wir h1, ..., hN finden k√∂nnen, so dass der in den sekund√§ren Tabellen verwendete Gesamtraum Pi (ni) 2 ist. Es bleibt zu zeigen, dass wir eine Funktion h der ersten Ebene finden k√∂nnen, so dass Pi (ni) 2 = O (N).  In der Tat werden wir Folgendes zeigen: <br><br>  Satz 6. Wenn wir den Startpunkt h aus der universellen Menge H w√§hlen, dann <br><br><pre><code class="plaintext hljs">Pr[X i (ni)2 &gt; 4N] &lt; 1/2.</code> </pre> <br>  Beweis.  Beweisen wir dies, indem wir zeigen, dass E [Pi (ni) 2] &lt;2N ist.  Dies impliziert, was wir von der Markov-Ungleichung wollen.  (Wenn es eine Wahrscheinlichkeit von sogar 1/2 g√§be, dass die Summe mehr als 4 N betragen k√∂nnte, w√ºrde diese Tatsache allein bedeuten, dass die Erwartung mehr als 2 N betragen sollte. Wenn also die Erwartung weniger als 2 N betr√§gt, sollte die Ausfallwahrscheinlichkeit geringer sein 1/2.) <br><br>  Der knifflige Trick besteht nun darin, dass eine M√∂glichkeit zur Berechnung dieses Betrags darin besteht, die Anzahl der geordneten Paare zu z√§hlen, die eine Kollision haben, einschlie√ülich Kollisionen mit sich selbst.  Wenn der Korb beispielsweise {d, e, f} hat, hat d einen Konflikt mit jedem von {d, e, f}, e hat einen Konflikt mit jedem von {d, e, f} und f hat einen Konflikt mit jedes von {d, e, f}, also bekommen wir 9. Also haben wir: <br><br><pre> <code class="plaintext hljs">E[X i (ni)2] = E[X x X y Cxy] (Cxy = 1 if x and y collide, else Cxy = 0) = N +X x X y6=x E[Cxy] ‚â§ N + N(N ‚àí 1)/M (where the 1/M comes from the definition of universal) &lt; 2N. (since M = N)</code> </pre><br>  Also versuchen wir einfach ein zuf√§lliges h von H, bis wir eines finden, so dass Pi n2 i &lt;4N ist, und dann, indem wir diese Funktion h fixieren, finden wir N sekund√§re Hash-Funktionen h1, ..., hN wie in Methode 1. <br><br>  <b>6. Weitere Diskussion</b> <br><br>  <i><b>6.1 Eine weitere universelle Hashing-Methode</b></i> <br><br>  Hier ist eine andere Methode zum Erstellen universeller Hash-Funktionen, die etwas effizienter ist als die zuvor angegebene Matrixmethode. <br><br>  Bei der Matrixmethode haben wir den Schl√ºssel als einen Bitvektor betrachtet.  Bei dieser Methode betrachten wir stattdessen den Schl√ºssel x als einen Vektor von ganzen Zahlen [x1, x2, ..., xk] mit der einzigen Anforderung, dass jedes xi im Bereich {0, 1, ..., M-1} liegt.  Wenn wir beispielsweise Zeichenfolgen der L√§nge k hashen, kann xi das i-te Zeichen (wenn die Gr√∂√üe unserer Tabelle mindestens 256 betr√§gt) oder das i-te Zeichenpaar (wenn die Gr√∂√üe unserer Tabelle mindestens 65536 betr√§gt) sein.  Au√üerdem m√ºssen die Gr√∂√üe unserer Tabelle M eine Primzahl sein.  Um die Hash-Funktion h auszuw√§hlen, w√§hlen wir k Zufallszahlen r1, r2, ..., pk aus {0, 1, ..., M - 1} und bestimmen: <br><br><pre> <code class="plaintext hljs">h(x) = r1x1 + r2x2 + . . . + rkxk mod M.</code> </pre> <br>  Der Beweis, dass diese Methode universell ist, wird auf die gleiche Weise konstruiert wie der Beweis der Matrixmethode.  Sei x und y zwei verschiedene Schl√ºssel.  Wir wollen zeigen, dass Prh (h (x) = h (y)) ‚â§ 1 / M ist. Da x! = Y, sollte es einen Fall geben, in dem ein Index i existiert, so dass xi! = Yi.  Stellen Sie sich nun vor, Sie h√§tten zuerst alle Zufallszahlen rj f√ºr j! = I ausgew√§hlt.  Sei h '(x) = Pj6 = i rjxj.  Wenn wir also ri w√§hlen, erhalten wir h (x) = h '(x) + rixi.  Dies bedeutet, dass wir genau dann einen Konflikt zwischen x und y haben <br><br><pre> <code class="plaintext hljs">h‚Ä≤(x) + rixi = h‚Ä≤(y) + riyi mod M, or equivalently when ri(xi ‚àí yi) = h‚Ä≤(y) ‚àí h‚Ä≤(x) mod M.</code> </pre> <br>  Da M eine Primzahl ist, ist die Division durch einen Wert ungleich Null von mod M g√ºltig (jede ganze Zahl von 1 bis M ‚àí1 hat ein multiplikatives inverses Modulo M), was bedeutet, dass es genau einen Wert ri modulo M gibt, f√ºr den die obige Gleichung gilt wahr, n√§mlich ri = (h '(y) - h' (x)) / (xi - yi) mod M. Somit ist die Wahrscheinlichkeit dieses Vorfalls genau 1 / M. <br><br>  <b><i>6.2 Andere Verwendungen von Hashing</i></b> <br><br>  Angenommen, wir haben eine lange Folge von Elementen und m√∂chten sehen, wie viele verschiedene Elemente in der Liste enthalten sind.  Gibt es eine gute M√∂glichkeit, dies zu tun? <br><br>  Eine M√∂glichkeit besteht darin, eine Hash-Tabelle zu erstellen und dann die Sequenz einmal zu durchlaufen, indem nach jedem Element gesucht und dann eingef√ºgt wird, wenn es nicht bereits in der Tabelle enthalten ist.  Die Anzahl der einzelnen Elemente ist einfach die Anzahl der Einf√ºgungen. <br><br>  Und jetzt, was ist, wenn die Liste wirklich riesig ist und wir keinen Platz zum Speichern haben, aber eine ungef√§hre Antwort f√ºr uns geeignet ist.  Stellen Sie sich zum Beispiel vor, wir sind ein Router und beobachten, wie viele Pakete √ºbertragen werden, und wir m√∂chten (ungef√§hr) sehen, wie viele verschiedene Quell-IP-Adressen vorhanden sind. <br><br>  Hier ist eine gute Idee: Nehmen wir an, wir haben eine Hash-Funktion h, die sich wie eine Zufallsfunktion verh√§lt, und stellen wir uns vor, dass h (x) eine reelle Zahl von 0 bis 1 ist. Wir k√∂nnen nur das Minimum verfolgen Der Hash-Wert wurde bisher erstellt (wir haben also √ºberhaupt keine Tabelle).  Wenn zum Beispiel die Schl√ºssel 3,10,3,3,12,10,12 und h (3) = 0,4, h (10) = 0,2, h (12) = 0,7 sind, erhalten wir 0, 2. <br><br>  Tatsache ist, dass wenn wir in [0, 1] N Zufallszahlen ausw√§hlen, der erwartete Mindestwert 1 / (N + 1) ist.  Dar√ºber hinaus besteht eine gute Chance, dass es ziemlich nahe ist (wir k√∂nnen unsere Sch√§tzung verbessern, indem wir mehrere Hash-Funktionen ausf√ºhren und den Median der Tiefs nehmen). <br><br>  Frage: Warum eine Hash-Funktion verwenden und nicht jedes Mal eine Zufallszahl ausw√§hlen?  Dies liegt daran, dass wir uns um die Anzahl der verschiedenen Elemente k√ºmmern und nicht nur um die Gesamtzahl der Elemente (dieses Problem ist viel einfacher: Verwenden Sie einfach einen Z√§hler ...). <br><br>  Freunde, war dieser Artikel hilfreich f√ºr Sie?  Schreiben Sie in die Kommentare und nehmen Sie am <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Tag</a> der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">offenen T√ºr teil</a> , der am 25. April stattfinden wird. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de448992/">https://habr.com/ru/post/de448992/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de448976/index.html">Gamedev Fr√ºhlingsveranstaltungen bei HSE</a></li>
<li><a href="../de448980/index.html">Unser erstes gemeinsames Mittagessen: Warum und wie verbringen wir unseren Testtag?</a></li>
<li><a href="../de448982/index.html">Kopfloses CMS. Warum schreibe ich meine?</a></li>
<li><a href="../de448986/index.html">3D-Reverse Engineering mit 3D-Scannen</a></li>
<li><a href="../de448988/index.html">Kingston SSDs sind ger√§umiger geworden und haben fast die gleichen Kosten - wir erf√ºllen die A400-R-Serie</a></li>
<li><a href="../de448994/index.html">Ist es so schwierig, den Weg eines IT-Personalvermittlers einzuschlagen?</a></li>
<li><a href="../de448998/index.html">Wenn die Verbindung nur aus Zinn besteht, m√ºssen Sie sie begraben</a></li>
<li><a href="../de449000/index.html">Ist Deno der neue Node.js?</a></li>
<li><a href="../de449002/index.html">Formale √úberpr√ºfung am Beispiel des Wolfs-, Ziegen- und Kohlproblems</a></li>
<li><a href="../de449004/index.html">Neu in der Zertifizierung f√ºr Informationssicherheit</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>