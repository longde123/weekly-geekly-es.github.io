<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ§˜ğŸ¿ ğŸšŒ âœ‹ Bagaimana Yandex menciptakan augmented reality di Maps untuk iOS. Pengalaman menggunakan ARKit ğŸ‘ƒğŸ¾ ğŸ—ï¸ âœ´ï¸</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ada sedikit orang yang tersisa yang dapat terkejut dengan Augmented Reality (AR). Bagi sebagian orang, teknologi ini dikaitkan dengan mainan selama be...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Bagaimana Yandex menciptakan augmented reality di Maps untuk iOS. Pengalaman menggunakan ARKit</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/yandex/blog/421957/"><p>  Ada sedikit orang yang tersisa yang dapat terkejut dengan Augmented Reality (AR).  Bagi sebagian orang, teknologi ini dikaitkan dengan mainan selama beberapa jam.  Yang lain merasa lebih praktis. </p><br><p>  Nama saya Dmitry, dan saya sedang mengembangkan Yandex.Maps untuk iOS.  Hari ini saya akan memberi tahu pembaca Habr bagaimana kami membuat rute menggunakan augmented reality.  Anda juga akan belajar tentang fitur-fitur menggunakan kerangka kerja ARKit, berkat pengenalan augmented reality tidak lagi menjadi perhatian hanya spesialis di bidang visi komputer. </p><br><img width="800" src="https://habrastorage.org/webt/zb/le/i2/zblei2e2hojscltqyw2l1k4csds.png"><br><p><a name="habracut"></a>  Pada tahun 2009, majalah Esquire adalah yang pertama di antara media yang menambahkan dukungan augmented reality pada produknya.  Di sampul majalah diposting kode yang Anda dapat melihat Robert Downey Jr "hidup". </p><br><img src="https://habrastorage.org/webt/0v/-a/58/0v-a585aysdjqwyfrmtrbxgv05k.jpeg"><br><p>  Penggunaan AR dalam industri hiburan tidak terbatas pada ini.  Contoh nyata adalah game Pokemon Go, dirilis pada 2016.  Pada bulan Juli tahun itu, itu diunduh lebih dari 16 juta kali.  Keberhasilan permainan menyebabkan munculnya banyak klon dengan AR. </p><br><p>  Peristiwa penting dalam industri AR dalam beberapa tahun terakhir dapat dianggap sebagai pengumuman Google Glass dan Microsoft Hololens.  Munculnya perangkat tersebut menunjukkan vektor di mana perusahaan besar bergerak. </p><br><p>  Apple tidak terkecuali.  Pada tahun 2017, perusahaan memperkenalkan kerangka kerja ARKit, yang penting bagi industri ini sulit ditaksir terlalu tinggi.  Dan kita akan membicarakannya lebih terinci. </p><br><h2 id="arkit">  ARKit </h2><br><p>  Fitur ARKit, membuatnya mudah digunakan AR: </p><br><ul><li>  kurangnya kebutuhan akan penanda (penanda) khusus, </li><li>  integrasi dengan kerangka kerja grafis 2D / 3D Apple yang ada - SceneKit, SpriteKit, Metal, </li><li>  akurasi tinggi dalam menentukan posisi dan orientasi perangkat di ruang, </li><li>  tidak perlu mengkalibrasi kamera atau sensor. </li></ul><br><p>  Di bawah kap ARKit adalah sistem odometri inersia visual yang menggabungkan data dengan subsistem visual (kamera) dan inersia (akselerometer, giroskop) perangkat untuk menentukan posisi dan perpindahan di atas panggung.  Elemen penghubung sistem ini adalah filter Kalman - sebuah algoritma yang pada setiap saat waktu memilih pembacaan terbaik dari dua subsistem dan menyediakannya kepada kami dalam bentuk posisi dan orientasi kami di atas panggung.  ARKit juga memiliki "pemahaman" adegan - kita dapat menentukan permukaan horizontal dan vertikal, serta kondisi pencahayaan adegan.  Jadi, ketika menambahkan objek ke adegan, kita dapat menambahkan pencahayaan default untuk itu, berkat objek yang akan terlihat lebih realistis. </p><br><div class="spoiler">  <b class="spoiler_title">Ngomong-ngomong</b> <div class="spoiler_text"><p>  Segera, versi kerangka 2.0 akan dirilis, di mana fitur baru akan ditambahkan dan akurasi posisi akan ditingkatkan secara signifikan. </p></div></div><br><p>  ARKit memungkinkan pengembang untuk menanamkan augmented reality berkualitas tinggi ke dalam aplikasi mereka sambil menghabiskan banyak usaha.  Kami akan menunjukkan ini menggunakan contoh Yandex.Maps. </p><br><h2 id="marshrutizaciya-s-ar-v-yandekskartah">  Routing dengan AR di Yandex.Maps </h2><br><p>  Biasanya, setelah pengumuman versi baru iOS, banyak tim di Yandex berkumpul untuk membahas kemungkinan memperkenalkan fitur baru ke dalam aplikasi mereka.  Tim Yandex.Mart melakukan hal yang sama.  Dalam waktu satu bulan sejak pengumuman ARKit, kami sering membahas bagaimana mengimplementasikannya di Maps.  Gagasan macam apa yang tidak kami dengar dari satu sama lain!  Cukup cepat, kami sampai pada kesimpulan bahwa salah satu solusi yang paling berguna dan permukaan adalah penggunaan augmented reality dalam routing. </p><br><p>  Pilihan ide ini disebabkan oleh fakta bahwa banyak pengguna kartu sering menghadapi situasi ketika Anda menemukan diri Anda di daerah yang tidak dikenal dan Anda perlu dengan cepat memutuskan ke mana harus pergi.  Pendekatan standar untuk pengguna peta rata-rata adalah membuka aplikasi, membangun rute pejalan kaki, dan, setelah berbelok, menentukan ke mana harus bergerak.  Gagasan untuk memperkenalkan augmented reality ke dalam rute pejalan kaki adalah untuk menyelamatkan pengguna dari tindakan yang tidak perlu, segera menunjukkan di mana Anda harus bergerak langsung di atas gambar kamera. </p><br><p>  Pertama, saya ingin mengatakan beberapa kata tentang perutean.  Apa yang saya masukkan dalam konsep ini?  Dari sudut pandang implementasi dalam aplikasi seluler, ini adalah serangkaian langkah standar yang memungkinkan pengguna untuk berpindah dari titik A ke titik B: </p><br><ul><li>  pemilihan titik keberangkatan dan kedatangan, </li><li>  menerima rute dalam bentuk sekumpulan titik dalam koordinat geografis (lintang, bujur), </li><li>  ditampilkan pada peta garis rute, </li><li>  menemani pengguna dengan informasi tambahan saat bergerak di sepanjang rute. </li></ul><br><p>  Kami tidak akan membahas dua poin pertama.  Saya hanya bisa mengatakan bahwa kami mendapatkan rute melalui perpustakaan lintas-platform kami Yandex.Mapkit, yang juga tersedia untuk Anda dalam bentuk pod.  Apa perbedaan antara augmented reality dan routing standar pada peta?  Pertama-tama, perbedaan utama adalah peta yang hampir sepenuhnya tersembunyi.  Penekanan utama ditempatkan pada area layar dengan gambar aliran video dari kamera, di mana elemen visual tambahan ditumpangkan (tanda selesai, tanda tambahan dan gambar garis rute).  Setiap elemen visual ini memiliki muatan semantik dan logikanya sendiri (kapan dan bagaimana seharusnya ditampilkan).  Kami akan mempertimbangkan peran masing-masing elemen ini secara lebih rinci nanti, tetapi untuk saat ini saya mengusulkan untuk mempertimbangkan tugas-tugas yang kami miliki sebelum kami: </p><br><ul><li>  belajar memposisikan objek pada adegan ARKit, mengetahui koordinat geografisnya, </li><li>  pelajari cara menggambar UI yang diperlukan pada adegan 3D dengan kinerja yang memadai. </li></ul><br><p>  Kami perlu mengonversi koordinat titik dari geografis ke koordinat di atas panggung, memilih titik mana yang akan ditampilkan, dan menampilkan semua UI yang diperlukan di atas gambar kamera di posisi yang benar.  Tapi semuanya ternyata sedikit lebih rumit daripada yang terlihat pada pandangan pertama. </p><br><p>  Sebelum mulai mengimplementasikan fitur-fitur secara langsung, salah satu kolega saya diberi tugas membuat prototipe yang menunjukkan kemungkinan (atau ketidakmungkinan) untuk mengimplementasikan fungsionalitas serupa dengan seperangkat alat yang dapat diakses.  Selama dua minggu, kami menyaksikan San Sanych membajak ruang terbuka di ruang terbuka dan lingkungan di sekitar kantor kami dengan telepon di tangan dan memandang dunia di sekitar kami melalui prisma kamera.  Hasilnya, kami mendapatkan prototipe yang berfungsi yang menunjukkan setiap titik rute sebagai tanda di panggung dengan jarak ke sana.  Dengan bantuan prototipe ini dimungkinkan, dengan kombinasi keadaan yang sukses, untuk pergi dari kantor ke metro dan bahkan tidak tersesat.  Tapi serius, dia mengkonfirmasi kemungkinan menerapkan fungsi yang dimaksud.  Tetapi masih ada beberapa tugas yang masih harus diselesaikan oleh tim kami. </p><br><p>  Semuanya dimulai dengan mempelajari alat.  Saat itu, hanya satu orang di tim yang memiliki pengalaman bekerja dengan grafik 3D.  Mari kita lihat alat-alat yang harus dihadapi siapa pun yang berpikir untuk mengimplementasikan ide-ide semacam itu dengan ARKit. </p><br><h2 id="instrumenty-i-api">  Alat dan API </h2><br><p>  Tugas utama rendering objek adalah membuat dan mengelola objek adegan framework SceneKit.  Dengan munculnya ARKit, kelas ARSCNView (turunan dari kelas SCNView - kelas dasar untuk bekerja dengan adegan di SceneKit) tersedia untuk pengembang, yang menyelesaikan sebagian besar tugas yang memakan waktu mengintegrasikan ARKit dan SceneKit, yaitu: </p><br><ul><li>  sinkronisasi posisi ponsel di ruang angkasa dengan posisi kamera di atas panggung, </li><li>  sistem koordinat adegan bertepatan dengan sistem koordinat ARKit, </li><li>  sebagai latar belakang adegan, aliran video dari kamera perangkat digunakan. </li></ul><br><p>  Objek ARSCNView juga menyediakan pengembang dengan objek sesi augmented reality yang dapat dimulai dengan konfigurasi yang diperlukan, berhenti, atau berlangganan ke berbagai acara menggunakan objek delegasi. </p><br><p>  Untuk menambahkan objek ke adegan, pewaris atau objek SCNNode langsung digunakan.  Kelas ini mewakili posisi (vektor tiga dimensi) dalam sistem koordinat induknya.  Jadi, kita mendapatkan pohon objek pada adegan dengan root di objek khusus - rootNode adegan kita.  Semuanya di sini sangat mirip dengan hierarki objek UIView di UIKit.  Objek SCNNode dapat ditampilkan di atas panggung ketika mereka menambahkan material dan pencahayaan. </p><br><p>  Untuk menambahkan augmented reality ke aplikasi seluler, Anda juga perlu tahu tentang objek utama API ARKit.  Yang utama adalah objek dari sesi augmented reality - ARSession.  Objek ini melakukan pemrosesan data dan bertanggung jawab atas siklus hidup dari sesi augmented reality.  Tujuan artikel ini bukan untuk menceritakan kembali dokumentasi ARKit dan SceneKit, jadi saya tidak akan menulis tentang semua parameter konfigurasi yang tersedia dari sesi augmented reality, tetapi akan fokus pada salah satu parameter terpenting dari konfigurasi sesi augmented reality untuk aplikasi navigasi - worldAlignment.  Parameter ini menentukan arah sumbu adegan pada saat inisialisasi sesi.  Secara umum, ketika menginisialisasi sesi augmented reality, ARKit menciptakan sistem koordinat dengan permulaan pada titik yang bertepatan dengan posisi telepon saat ini di ruang angkasa, dan mengarahkan sumbu sistem ini tergantung pada nilai properti Penyelarasan wold.  Dalam implementasi kami, nilai gravityAndHeading digunakan, yang menyiratkan bahwa sumbu akan diarahkan sebagai berikut: sumbu Y - dalam arah yang berlawanan dengan gravitasi, sumbu Z - ke selatan, dan sumbu X - ke timur. </p><br><p><img src="https://habrastorage.org/webt/r7/cj/d5/r7cjd5acp__8jkrb83rfytbsnr4.png" alt="world-alignment-gravity-and-heading"></p><br><p>  Dengan kombinasi keadaan yang baik, sumbu X / Z memang akan disejajarkan dengan arah ke Selatan / Timur, tetapi, karena kesalahan dalam pembacaan kompas, sumbu dapat diarahkan pada sudut tertentu ke arah yang dijelaskan dalam dokumentasi.  Ini adalah salah satu masalah yang harus kami tangani, tetapi lebih banyak tentang itu nanti. </p><br><p>  Sekarang kita telah memeriksa alat dasar, mari kita rangkum: memetakan rute menggunakan SceneKit menambahkan objek SCNNode ke adegan di posisi yang diperoleh dengan mengonversi dari koordinat geografis ke koordinat pemandangan.  Sebelum kita berbicara tentang mengoordinasikan konversi dan umumnya tentang menempatkan objek di tempat kejadian, mari kita bicara tentang masalah rendering elemen UI, dengan asumsi bahwa kita tahu posisi objek di atas panggung. </p><br><h1 id="metka-finisha">  Tanda selesai </h1><br><p>  Elemen visual utama dari rute pejalan kaki dengan augmented reality adalah tanda selesai, yang menampilkan titik akhir rute.  Juga di atas tanda, kami menunjukkan kepada pengguna jarak ke titik akhir rute. </p><br><p><img src="https://habrastorage.org/webt/xw/94/hx/xw94hxwjiepqzhlov9hwmig1wee.jpeg" alt="ikhiri tanda letak-selesai"></p><br><h2 id="razmer">  Ukuran </h2><br><p>  Ketika kami pertama kali diperlihatkan desain dari tag ini, pertama-tama kami memperhatikan persyaratan untuk ukuran dari tag ini.  Mereka tidak mematuhi aturan proyeksi perspektif.  Saya akan menjelaskan bahwa dalam mesin tiga dimensi yang digunakan untuk membuat, misalnya, game komputer, "tampilan" dimodelkan menggunakan proyeksi perspektif.  Menurut aturan proyeksi perspektif, objek yang jauh digambarkan pada skala yang lebih kecil, dan garis paralel umumnya tidak paralel.  Dengan demikian, ukuran proyeksi objek pada bidang layar berubah secara linier (berkurang) saat kamera bergerak menjauh dari objek pada adegan.  Ini mengikuti dari deskripsi tata letak bahwa ukuran tanda pada layar memiliki ukuran (maksimum) tetap ketika dihapus kurang dari 50 m, kemudian menurun secara linear dari 50 m menjadi 2 km, setelah itu ukuran minimum tetap tidak berubah.  Persyaratan tersebut jelas karena kenyamanan pengguna.  Mereka memungkinkan pengguna untuk tidak pernah kehilangan titik akhir rute dari tampilan, sehingga pengguna akan selalu memiliki gagasan tentang ke mana harus pindah. </p><br><p><img src="https://habrastorage.org/webt/zr/tm/lu/zrtmluh1rmc08_bop7wkkyak3z8.png" alt="finish-placemark-size-demand"></p><br><p>  Kami harus memahami bagaimana kami dapat memasukkan mekanisme proyeksi SceneKit yang bekerja sesuai dengan aturan tertentu.  Saya ingin segera mencatat bahwa kami memiliki sekitar dua minggu untuk melakukan segalanya tentang segalanya, jadi tidak ada waktu untuk melakukan analisis mendalam tentang berbagai pendekatan untuk menyelesaikan masalah yang diajukan.  Sekarang, menganalisis keputusan kita, mengevaluasinya jauh lebih sederhana, dan kita dapat menyimpulkan bahwa sebagian besar keputusan yang diambil benar.  Persyaratan untuk ukuran, pada kenyataannya, adalah batu sandungan pertama.  Semua masalah yang diuraikan di bawah ini dapat diselesaikan dengan menggunakan SceneKit dan UIKit.  Saya mencoba menjelaskan secara terperinci bagaimana menyelesaikan setiap masalah dengan menggunakan kedua pendekatan tersebut.  Pendekatan mana yang digunakan terserah Anda. </p><br><p>  Mari kita bayangkan bahwa kami memutuskan untuk menerapkan label akhir menggunakan SceneKit.  Jika kita memperhitungkan bahwa label menurut tata letak seharusnya terlihat seperti lingkaran di layar, maka menjadi jelas bahwa dalam SceneKit objek label harus berupa bola (karena proyeksi bola ke pesawat apa pun adalah lingkaran).  Agar proyeksi memiliki jari-jari tertentu pada layar, yang ditentukan dalam persyaratan perancang, perlu diketahui jari-jari bola pada setiap saat waktu.  Dengan demikian, dengan menempatkan bola dari jari-jari tertentu pada adegan di titik tertentu dan secara konstan memperbarui jari-jarinya ketika mendekati atau bergerak menjauh, kita akan mendapatkan proyeksi ke layar ukuran yang diperlukan setiap saat.  Algoritma untuk menentukan jari-jari bola pada titik waktu yang berubah-ubah adalah sebagai berikut: </p><br><ol><li>  menentukan posisi objek di atas panggung - pusat bola, </li><li>  temukan proyeksi titik ini di bidang layar (menggunakan API SceneKit), </li><li>  untuk menentukan ukuran tanda yang diperlukan pada layar, kami menemukan jarak dari kamera ke pusat bola di panggung, </li><li>  kami menentukan ukuran yang diperlukan pada layar dengan jarak ke objek menggunakan aturan yang dijelaskan dalam desain, </li><li>  mengetahui ukuran tanda di layar (diameter lingkaran), kami memilih titik pada lingkaran ini, </li><li>  membuat proyeksi terbalik (unprojectPoint) dari titik yang dipilih, </li><li>  kami menemukan panjang vektor dari titik yang diterima di panggung ke pusat bola. </li></ol><br><p>  Nilai yang diperoleh dari panjang vektor akan menjadi jari-jari bola yang diinginkan. </p><br><p><img src="https://habrastorage.org/webt/go/2o/zu/go2ozuggr3zpucmewdrrybxbedy.png" alt="finish-placemark-size-solution-scenekit"></p><br><p>  Pada saat implementasi, kami tidak dapat menemukan cara untuk menentukan ukuran objek di tempat kejadian, dan kami memutuskan untuk menggambar tanda selesai menggunakan UIKit.  Dalam kasus ini, algoritme mengulangi langkah 1-5, setelah itu lingkaran dengan ukuran yang diinginkan digambar di layar dengan bagian tengah pada titik yang diperoleh pada langkah 2 menggunakan alat UIKit.  Contoh implementasi label menggunakan UIKit dapat ditemukan di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> . </p><br><div class="spoiler">  <b class="spoiler_title">Beberapa kata tentang kode</b> <div class="spoiler_text"><p>  Pada akhir artikel saya memberikan beberapa tautan ke materi yang bermanfaat dan menarik, termasuk sampel, di mana Anda dapat melihat secara detail kode nyata yang menyelesaikan masalah yang disajikan dalam artikel dan mengimplementasikan algoritma yang disajikan.  Minat utama menurut saya adalah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">prototipe rute pejalan kaki</a> , yang menyatukan semua fungsi, dengan pengecualian mekanisme penyesuaian sumbu, yang dijelaskan secara rinci di bawah ini. </p><br><p>  Kode di atas tidak mengklaim optimalitas, kelengkapan dan kualitas produksi =) </p></div></div><br><p>  Perbedaan antara menggunakan SceneKit dan UIKit dalam kasus ini juga terletak pada kenyataan bahwa ketika menerapkan pada SceneKit, objek SCNNode untuk titik akhir rute (tanda selesai) akan dibuat dengan bahan dan geometri, karena itu harus terlihat, saat menggunakan UIKit kita memerlukan objek node secara eksklusif untuk mencari proyeksi ke bidang layar (untuk menentukan pusat tanda di layar).  Dalam hal ini, geometri dan material tidak perlu ditambahkan.  Perhatikan bahwa jarak dari kamera ke objek SCNNode dari titik akhir rute dapat ditemukan dalam dua cara - menggunakan koordinat geografis titik-titik, atau sebagai panjang vektor antara titik-titik di tempat kejadian.  Ini dimungkinkan karena objek kamera adalah properti SCNNode.  Untuk mendapatkan simpul kamera, Anda perlu merujuk ke properti pointOfView dari adegan kami. </p><br><p>  Kami belajar cara menentukan jari-jari simpul tanda selesai pada titik arbitrer saat menerapkan pada SceneKit dan posisi tampilan tanda selesai jika diterapkan pada UIKit.  Masih mengerti kapan perlu memperbarui nilai-nilai ini?  Tempat ini adalah metode objek SCNSceneRendererDelegate: </p><br><pre><code class="hljs objectivec">renderer(_ renderer: <span class="hljs-built_in"><span class="hljs-built_in">SCNSceneRenderer</span></span>, didRenderScene scene: <span class="hljs-built_in"><span class="hljs-built_in">SCNScene</span></span>, atTime time: TimeInterval)</code> </pre> <br><p>  Metode ini dipanggil setelah setiap frame adegan yang diberikan.  Dengan memperbarui nilai properti di tubuh metode ini, kami mendapatkan label selesai yang ditampilkan dengan benar. </p><br><h2 id="animaciya">  Animasi </h2><br><p>  Setelah tanda selesai muncul di dev, kami melanjutkan untuk menambahkan animasi riak ke tanda ini.  Saya pikir untuk sebagian besar pengembang iOS membuat animasi bukan masalah besar.  Tetapi ketika berpikir tentang metode implementasi, kami mengalami masalah dengan terus memperbarui kerangka pandang kami.  Perhatikan bahwa dalam kebanyakan kasus, animasi ditambahkan ke objek UIView statis.  Masalah serupa - pembaruan konstan jari-jari geometri node muncul ketika diimplementasikan menggunakan SceneKit.  Faktanya adalah bahwa animasi berdenyut turun ke animasi ukuran lingkaran (untuk UIKit) dan jari-jari bola (untuk SceneKit).  Ya, ya, kita tahu bahwa di UIKit animasi semacam ini dapat dilakukan menggunakan CALayer, tetapi untuk kesederhanaan bercerita, saya memutuskan untuk mempertimbangkan masalah ini secara simetris untuk dua kerangka kerja.  Pertimbangkan implementasi di UIKit.  Jika Anda menambahkan kode yang menjiwai bingkai yang sama dengan kode yang ada yang memperbarui bingkai tampilan, animasi akan terganggu oleh pengaturan bingkai secara eksplisit.  Oleh karena itu, sebagai solusi untuk masalah ini, kami memutuskan untuk menggunakan animasi properti transform.scale.xy dari objek UIView.  Saat menerapkan menggunakan SceneKit, Anda harus menambahkan animasi properti skala ke objek SCNNode.  Hal yang menyenangkan tentang menggunakan SceneKit dalam kasus ini adalah kenyataan bahwa ia mendukung sepenuhnya CoreAnimation, jadi mempelajari API baru tidak diperlukan.  Kode yang mengimplementasikan animasi mirip dengan animasi label di Yandex.Maps terlihat seperti ini: </p><br><pre> <code class="hljs objectivec">let animationGroup = <span class="hljs-built_in"><span class="hljs-built_in">CAAnimationGroup</span></span>.init() animationGroup.duration = <span class="hljs-number"><span class="hljs-number">1.0</span></span> animationGroup.repeatCount = .infinity let opacityAnimation = <span class="hljs-built_in"><span class="hljs-built_in">CABasicAnimation</span></span>(keyPath: <span class="hljs-string"><span class="hljs-string">"opacity"</span></span>) opacityAnimation.fromValue = <span class="hljs-built_in"><span class="hljs-built_in">NSNumber</span></span>(value: <span class="hljs-number"><span class="hljs-number">1.0</span></span>) opacityAnimation.toValue = <span class="hljs-built_in"><span class="hljs-built_in">NSNumber</span></span>(value: <span class="hljs-number"><span class="hljs-number">0.1</span></span>) let scaleAnimation = <span class="hljs-built_in"><span class="hljs-built_in">CABasicAnimation</span></span>(keyPath: <span class="hljs-string"><span class="hljs-string">"scale"</span></span>) scaleAnimation.fromValue = <span class="hljs-built_in"><span class="hljs-built_in">NSValue</span></span>(scnVector3: <span class="hljs-built_in"><span class="hljs-built_in">SCNVector3</span></span>(<span class="hljs-number"><span class="hljs-number">1.0</span></span>, <span class="hljs-number"><span class="hljs-number">1.0</span></span>, <span class="hljs-number"><span class="hljs-number">1.0</span></span>)) scaleAnimation.toValue = <span class="hljs-built_in"><span class="hljs-built_in">NSValue</span></span>(scnVector3: <span class="hljs-built_in"><span class="hljs-built_in">SCNVector3</span></span>(<span class="hljs-number"><span class="hljs-number">1.2</span></span>, <span class="hljs-number"><span class="hljs-number">1.2</span></span>, <span class="hljs-number"><span class="hljs-number">1.2</span></span>)) animationGroup.animations = [opacityAnimation, scaleAnimation] finishNode.addAnimation(animationGroup, forKey: <span class="hljs-string"><span class="hljs-string">"animations"</span></span>)</code> </pre> <br><h2 id="bilbord">  Billboard </h2><br><p>  Di awal artikel, saya menyebutkan papan iklan dengan jarak ke titik akhir rute, yang, pada dasarnya, adalah label dengan teks yang selalu terletak di atas tanda selesai.  Secara tradisi, saya akan menguraikan masalah yang melekat pada implementasi pada UIKit dan SceneKit, menceritakan tentang kemungkinan solusi untuk masing-masing kerangka kerja. </p><br><p>  Mari kita mulai dengan UIKit.  Dalam hal ini, billboard adalah UILabel reguler, di mana teks diperbarui secara konstan, menunjukkan jarak ke titik akhir rute.  Mari kita lihat masalah yang kita hadapi. </p><br><p><img src="https://habrastorage.org/webt/in/ad/7t/inad7t6_f7xu3hskdge0--hka38.png" alt="finish-placemark-billboard-problem-uikit"></p><br><p>  Jika Anda mengatur label ke bingkai dan kemudian memutar telepon, kita akan melihat bahwa bingkai tidak berubah (akan aneh jika tidak).  Pada saat yang sama, kami ingin label tetap sejajar dengan bidang bumi. </p><br><p><img src="https://habrastorage.org/webt/wq/7w/13/wq7w13m7byfynimnxcuxktdkpyi.png" alt="finish-placemark-billboard-diinginkan-uikit"></p><br><p>  Saya pikir semua orang mengerti bahwa ketika mengubah orientasi perangkat, kita perlu mengubah label, tetapi pada sudut apa?  Jika Anda menghidupkan imajinasi dan membayangkan semua sumbu sistem koordinat dan vektor yang terlibat dalam proses ini, kita dapat menyimpulkan bahwa sudut rotasi sama dengan sudut antara sumbu x sistem koordinat UIKit dan proyeksi sumbu X sistem koordinat SceneKit pada bidang layar. </p><br><p><img src="https://habrastorage.org/webt/cx/2p/6r/cx2p6rgc8dcat469mz75u1qitbs.png" alt="finish-placemark-billboard-solution-uikit"></p><br><p>  Tugas sederhana yang sekali lagi membuktikan kegunaan kursus geometri sekolah. </p><br><p>  Saat menerapkan tanda selesai menggunakan SceneKit, kemungkinan besar Anda harus membuat papan iklan dengan jarak menggunakan alat SceneKit, yang berarti bahwa Anda pasti akan memiliki tugas untuk membuat objek SCNNode selalu berorientasi ke arah kamera.  Saya pikir masalahnya akan menjadi lebih jelas jika Anda melihat gambar: </p><br><p><img src="https://habrastorage.org/webt/ns/pz/we/nspzwezwp8erjsfxoit4un1pgie.png" alt="finish-placemark-billboard-problem-scenekit"></p><br><p>  Masalah ini diselesaikan dengan menggunakan SCNBillboardConstraint API.  Menambahkan konstanta dengan sumbu bebas Y ke kumpulan ruas simpul kami, kami mendapatkan simpul yang berputar di sekitar sumbu Y sistem koordinatnya, sehingga selalu berorientasi ke arah kamera.  Satu-satunya tugas pengembang adalah menempatkan simpul ini pada ketinggian yang benar sehingga papan iklan dengan jarak selalu terlihat oleh pengguna. </p><br><pre> <code class="hljs objectivec">let billboardConstraint = <span class="hljs-built_in"><span class="hljs-built_in">SCNBillboardConstraint</span></span>() billboardConstraint.freeAxes = <span class="hljs-built_in"><span class="hljs-built_in">SCNBillboardAxis</span></span>.Y finishNode.constraints = [billboardConstraint]</code> </pre> <br><h1 id="vspomogatelnaya-metka">  Tag Asisten </h1><br><p>  Salah satu fitur utama perutean pejalan kaki dengan augmented reality, di dalam tim, kami mempertimbangkan tanda bantu - elemen visual khusus yang muncul di layar saat titik akhir rute meninggalkan zona visibilitas dan menunjukkan kepada pengguna tempat membalikkan ponsel sehingga tanda tersebut muncul di layar. garis finish. </p><br><p><img src="https://habrastorage.org/webt/ze/8x/wg/ze8xwgjihp8s2g9wl15r3epoui0.png" alt="selesaikan-tanda letak-petunjuk-petunjuk"></p><br><p>  Saya yakin banyak pembaca telah menemukan fungsi yang sama di beberapa permainan, paling sering penembak.  Betapa mengejutkan tim kami ketika kami melihat elemen UI ini di tata letak.  Saya harus segera mengatakan bahwa penerapan fitur yang tepat mungkin memerlukan lebih dari satu jam percobaan dari Anda, tetapi hasil akhirnya sepadan dengan waktu yang dihabiskan.  Kami mulai dengan mendefinisikan persyaratan, yaitu: </p><br><ul><li>  untuk setiap orientasi perangkat, label bergerak di sepanjang batas layar, </li><li>  jika pengguna telah mengubah 180 derajat ke titik akhir rute, label ditampilkan di bagian bawah layar, </li><li>  pada setiap saat waktu, berbelok ke arah tanda harus menjadi belokan terpendek ke titik akhir rute. </li></ul><br><p>  Setelah menjelaskan persyaratan, kami mulai implementasi.  Hampir segera, kami sampai pada kesimpulan bahwa rendering akan dilakukan menggunakan UIKit.  Masalah utama dengan implementasi adalah penentuan pusat label ini pada setiap titik waktu.  Setelah mempertimbangkan tanda selesai, tugas seperti itu seharusnya tidak menyebabkan kesulitan, jadi saya tidak akan membahas solusinya secara rinci.  Dalam artikel ini saya hanya akan memberikan deskripsi tentang algoritma untuk memilih pusat label bantu, dan kode sumber dapat ditemukan di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> . </p><br><p>  Algoritma Pusat Pencarian Algoritma Pencarian: </p><br><ol><li>  membuat objek SCNNode untuk titik akhir rute dengan posisi di tempat kejadian yang diperoleh dari koordinat geografis titik, </li><li>  menemukan proyeksi titik pada bidang layar, </li><li>  temukan persimpangan segmen dari tengah layar ke titik proyeksi yang ditemukan dengan segmen batas layar dalam sistem koordinat layar. </li></ol><br><p><img src="https://habrastorage.org/webt/pm/77/-v/pm77-vmlq5p6zmi7qe0yfkm7rvo.png" alt="finish-placemark-hint-solution"></p><br><p>  Titik persimpangan yang ditemukan adalah pusat yang diinginkan dari tanda bantu.  Dengan analogi dengan kode yang memperbarui parameter label selesai, kami menempatkan kode yang membuat label tambahan dalam metode delegasi yang sudah disuarakan di atas. </p><br><h1 id="poliliniya-marshruta">  Rute polyline </h1><br><p>  Setelah membangun rute dan setelah melihat tanda selesai di layar, pengguna dapat mencapainya dengan hanya mengarahkan ke arah tanda, tetapi perutean disebut demikian karena menunjukkan rute ke pengguna.  Kami berpikir bahwa akan sangat aneh untuk mengurangi fungsionalitas rute pejalan kaki, tidak termasuk tampilan rute dari versi AR.  Untuk memvisualisasikan garis rute, diputuskan untuk menampilkan satu set panah yang bergerak di sepanjang itu.  Dalam hal ini, para desainer puas bahwa panah praktis akan hilang ketika pindah (ukuran akan ditentukan oleh aturan proyeksi perspektif), dan diputuskan untuk menggunakan SceneKit untuk implementasi. </p><br><p>  Sebelum melanjutkan untuk menggambarkan implementasi, penting untuk dicatat bahwa, secara desain, panah harus berada pada jarak 3 m dari satu sama lain.  Jika Anda memperkirakan jumlah objek (panah) yang perlu dirender dengan rute sekitar 1 km, maka itu akan menjadi sekitar 330 buah.  Pada saat yang sama, setiap objek ditambahkan animasi gerakan di sepanjang bagian rute.  Perhatikan bahwa panah yang berada jauh dari posisi kamera di atas panggung pada jarak sekitar 100-150 meter praktis tidak terlihat karena ukurannya yang kecil.  Setelah mempertimbangkan faktor-faktor ini, diputuskan untuk tidak menampilkan semua objek, tetapi untuk menampilkan hanya yang dihapus dari pengguna tidak lebih dari 100 meter di sepanjang garis rute, secara berkala memperbarui set objek yang ditampilkan.  Kami menampilkan informasi visual dalam jumlah yang cukup, menghilangkan perhitungan SceneKit yang tidak perlu dan menghemat baterai pengguna. </p><br><p><img src="https://habrastorage.org/webt/q3/fz/r6/q3fzr6zbcifepwqzs9gwncj8-3k.png" alt="rute-polyline-ikhtisar"></p><br><p>  Mari kita lihat langkah-langkah utama yang harus kita sadari untuk mendapatkan hasil akhir: </p><br><ul><li>  pemilihan bagian rute di mana kami akan menampilkan primitif, </li><li>  pembuatan model 3D, </li><li>  pembuatan animasi </li><li>  perbarui saat mengemudi di sepanjang rute. </li></ul><br><h2 id="vybor-uchastka-dlya-otobrazheniya">  Memilih plot untuk ditampilkan </h2><br><p>  Seperti yang saya catat di atas, kami tidak menampilkan panah untuk seluruh rute, tetapi memilih bagian yang optimal untuk ditampilkan.  Pilihan segmen pada titik arbitrer dalam waktu terdiri dalam mencari segmen rute terdekat (rute adalah urutan segmen / segmen) ke posisi saat ini dari pengguna dan memilih segmen dari rute terdekat menuju titik akhir rute sampai total panjangnya melebihi 100 meter. </p><br><p><img src="https://habrastorage.org/webt/ay/_r/jr/ay_rjrcnkgtufpecvwezfyv0b_g.png" alt="route-polyline-route-part-selection"></p><br><h2 id="sozdanie-3d-modeli">  Pembuatan model 3D </h2><br><p>  Mari kita pertimbangkan lebih detail proses pembuatan model 3D.  Dalam kebanyakan kasus, yang perlu Anda lakukan untuk membuat model 3D sederhana (seperti panah kami) adalah membuka editor 3D apa saja, meluangkan waktu untuk menguasainya, dan membuat model ini di dalamnya.  Jika orang-orang dari tim Anda memiliki pengalaman dalam pemodelan 3D, atau mereka punya waktu untuk belajar, misalnya, 3DMax (dan harus dibeli), maka Anda sangat beruntung.  Sayangnya, pada saat penerapan fitur ini, tidak ada dari kami yang memiliki pengalaman khusus, tidak ada waktu luang untuk pelatihan, jadi kami harus membuat model, sehingga untuk berbicara, dengan sarana improvisasi.  Maksud saya deskripsi model dalam kode.  Semuanya dimulai dengan penyajian model 3D dalam bentuk segitiga.  Kemudian kita harus secara manual menemukan koordinat simpul segitiga ini dalam sistem koordinat model, dan kemudian membuat array indeks indeks simpul segitiga.  Dengan data ini, kami dapat membuat geometri yang diperlukan langsung di SceneKit.  Anda dapat membuat model yang mirip dengan kami, misalnya, seperti ini: </p><br><pre> <code class="hljs powershell"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ARSCNArrowGeometry</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SCNGeometry</span></span></span></span> { convenience init(material: SCNMaterial) { let vertices: [<span class="hljs-type"><span class="hljs-type">SCNVector3</span></span>] = [ <span class="hljs-type"><span class="hljs-type">SCNVector3Make</span></span>(-<span class="hljs-number"><span class="hljs-number">0.02</span></span>, <span class="hljs-number"><span class="hljs-number">0.00</span></span>, <span class="hljs-number"><span class="hljs-number">0.00</span></span>), // <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-type"><span class="hljs-type">SCNVector3Make</span></span>(-<span class="hljs-number"><span class="hljs-number">0.02</span></span>, <span class="hljs-number"><span class="hljs-number">0.50</span></span>, -<span class="hljs-number"><span class="hljs-number">0.33</span></span>), // <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-type"><span class="hljs-type">SCNVector3Make</span></span>(-<span class="hljs-number"><span class="hljs-number">0.10</span></span>, <span class="hljs-number"><span class="hljs-number">0.44</span></span>, -<span class="hljs-number"><span class="hljs-number">0.50</span></span>), // <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-type"><span class="hljs-type">SCNVector3Make</span></span>(-<span class="hljs-number"><span class="hljs-number">0.22</span></span>, <span class="hljs-number"><span class="hljs-number">0.00</span></span>, -<span class="hljs-number"><span class="hljs-number">0.39</span></span>), // <span class="hljs-number"><span class="hljs-number">3</span></span> <span class="hljs-type"><span class="hljs-type">SCNVector3Make</span></span>(-<span class="hljs-number"><span class="hljs-number">0.10</span></span>, -<span class="hljs-number"><span class="hljs-number">0.44</span></span>, -<span class="hljs-number"><span class="hljs-number">0.50</span></span>), // <span class="hljs-number"><span class="hljs-number">4</span></span> <span class="hljs-type"><span class="hljs-type">SCNVector3Make</span></span>(-<span class="hljs-number"><span class="hljs-number">0.02</span></span>, -<span class="hljs-number"><span class="hljs-number">0.50</span></span>, -<span class="hljs-number"><span class="hljs-number">0.33</span></span>), // <span class="hljs-number"><span class="hljs-number">5</span></span> <span class="hljs-type"><span class="hljs-type">SCNVector3Make</span></span>( <span class="hljs-number"><span class="hljs-number">0.02</span></span>, <span class="hljs-number"><span class="hljs-number">0.00</span></span>, <span class="hljs-number"><span class="hljs-number">0.00</span></span>), // <span class="hljs-number"><span class="hljs-number">6</span></span> <span class="hljs-type"><span class="hljs-type">SCNVector3Make</span></span>( <span class="hljs-number"><span class="hljs-number">0.02</span></span>, <span class="hljs-number"><span class="hljs-number">0.50</span></span>, -<span class="hljs-number"><span class="hljs-number">0.33</span></span>), // <span class="hljs-number"><span class="hljs-number">7</span></span> <span class="hljs-type"><span class="hljs-type">SCNVector3Make</span></span>( <span class="hljs-number"><span class="hljs-number">0.10</span></span>, <span class="hljs-number"><span class="hljs-number">0.44</span></span>, -<span class="hljs-number"><span class="hljs-number">0.50</span></span>), // <span class="hljs-number"><span class="hljs-number">8</span></span> <span class="hljs-type"><span class="hljs-type">SCNVector3Make</span></span>( <span class="hljs-number"><span class="hljs-number">0.22</span></span>, <span class="hljs-number"><span class="hljs-number">0.00</span></span>, -<span class="hljs-number"><span class="hljs-number">0.39</span></span>), // <span class="hljs-number"><span class="hljs-number">9</span></span> <span class="hljs-type"><span class="hljs-type">SCNVector3Make</span></span>( <span class="hljs-number"><span class="hljs-number">0.10</span></span>, -<span class="hljs-number"><span class="hljs-number">0.44</span></span>, -<span class="hljs-number"><span class="hljs-number">0.50</span></span>), // <span class="hljs-number"><span class="hljs-number">10</span></span> <span class="hljs-type"><span class="hljs-type">SCNVector3Make</span></span>( <span class="hljs-number"><span class="hljs-number">0.02</span></span>, -<span class="hljs-number"><span class="hljs-number">0.50</span></span>, -<span class="hljs-number"><span class="hljs-number">0.33</span></span>), // <span class="hljs-number"><span class="hljs-number">11</span></span> ] let sources: [<span class="hljs-type"><span class="hljs-type">SCNGeometrySource</span></span>] = [<span class="hljs-type"><span class="hljs-type">SCNGeometrySource</span></span>(<span class="hljs-type"><span class="hljs-type">vertices</span></span>: <span class="hljs-type"><span class="hljs-type">vertices</span></span>)] let indices: [<span class="hljs-built_in"><span class="hljs-built_in">Int</span></span><span class="hljs-number"><span class="hljs-number">32</span></span>] = [<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>,<span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>,<span class="hljs-number"><span class="hljs-number">4</span></span>,<span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>,<span class="hljs-number"><span class="hljs-number">9</span></span>,<span class="hljs-number"><span class="hljs-number">11</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>,<span class="hljs-number"><span class="hljs-number">11</span></span>,<span class="hljs-number"><span class="hljs-number">9</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>,<span class="hljs-number"><span class="hljs-number">9</span></span>,<span class="hljs-number"><span class="hljs-number">7</span></span>, <span class="hljs-number"><span class="hljs-number">9</span></span>,<span class="hljs-number"><span class="hljs-number">8</span></span>,<span class="hljs-number"><span class="hljs-number">7</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>,<span class="hljs-number"><span class="hljs-number">5</span></span>,<span class="hljs-number"><span class="hljs-number">11</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>,<span class="hljs-number"><span class="hljs-number">7</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">11</span></span>,<span class="hljs-number"><span class="hljs-number">5</span></span>,<span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">11</span></span>,<span class="hljs-number"><span class="hljs-number">4</span></span>,<span class="hljs-number"><span class="hljs-number">10</span></span>, <span class="hljs-number"><span class="hljs-number">9</span></span>,<span class="hljs-number"><span class="hljs-number">4</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">9</span></span>,<span class="hljs-number"><span class="hljs-number">10</span></span>,<span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">9</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">9</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">8</span></span>, <span class="hljs-number"><span class="hljs-number">8</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">8</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">7</span></span>] let geometryElements = [<span class="hljs-type"><span class="hljs-type">SCNGeometryElement</span></span>(<span class="hljs-type"><span class="hljs-type">indices</span></span>: <span class="hljs-type"><span class="hljs-type">indices</span></span>, <span class="hljs-type"><span class="hljs-type">primitiveType</span></span>: <span class="hljs-type"><span class="hljs-type">.triangles</span></span>)] self.init(sources: sources, elements: geometryElements) self.materials = [<span class="hljs-type"><span class="hljs-type">material</span></span>] } } <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> func arrowBlue() -&gt; SCNGeometry { let material = SCNMaterial() material.diffuse.contents = UIColor.blue material.lightingModel = .constant <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ARSCNArrowGeometry(material: material) }</code> </pre> <br><p>  Hasil akhirnya terlihat seperti ini: </p><br><p><img src="https://habrastorage.org/webt/xp/ms/ov/xpmsovmunineo54tl2dh_7tkjqi.png" alt="route-polyline-panah-model"></p><br><h2 id="animaciya-linii-marshruta">  Animasi jalur rute </h2><br><p>  Langkah selanjutnya dalam menampilkan garis animasi rute adalah tahap membuat animasi itu sendiri.  Tapi apa cara untuk mewujudkan animasi, yang dalam bentuk akhir terlihat seperti panah mulai bergerak di titik awal bagian yang dipilih dari rute dan "mengapung" di sepanjang rute hingga akhir bagian ini? </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/k3myOucSs8I" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><p>  Saya tidak akan menjelaskan semua cara yang memungkinkan untuk membuat animasi seperti itu, tetapi saya akan membahas lebih detail tentang metode yang telah kami pilih.  Setelah bagian dari rute dipilih, kami membaginya menjadi beberapa bagian dengan panjang yang sama - bagian dari animasi satu panah.  Setiap bagian tersebut disorot dalam warna dan memiliki panjang yang sama dengan jarak antara panah. </p><br><p><img src="https://habrastorage.org/webt/-t/rg/_1/-trg_11cxxxv3affm0cm3g3ur60.png" alt="rute-polyline-rute-bagian-partisi"></p><br><p>  Di awal setiap bagian, kami membuat objek SCNNode panah, yang animasinya terdiri dari bergerak di sepanjang bagiannya. </p><br><p><img src="https://habrastorage.org/webt/db/dc/cd/dbdccdds7qldg5d-2hbujicqrgm.png" alt="route-polyline-panah-posisi awal"></p><br><p>  Seperti yang Anda lihat, bagian animasi terkadang terdiri dari satu segmen, kadang-kadang dua atau lebih.  Itu semua tergantung pada langkah (dalam kasus kami - 3 meter) antara panah dan koordinat titik yang membentuk rute. </p><br><p>  Animasi panah adalah urutan dua langkah: </p><br><ul><li>  penampilan di posisi awal dengan sudut awal rotasi, </li><li>  urutan offset di sepanjang segmen dengan rotasi di titik koneksi segmen. </li></ul><br><p>  Secara skematis, tampilannya seperti ini: </p><br><p><img src="https://habrastorage.org/webt/f6/ha/7s/f6ha7sdwzchpv28sekjopugnrwo.png" alt="rute-polyline-panah-anitaion-langkah"></p><br><p>  Bagi kami, ini adalah cara termudah untuk mengimplementasikan animasi seperti itu menggunakan SCNAction API - API deklaratif yang memungkinkan Anda untuk membuat animasi berurutan, grup, dan berulang dengan mudah.  Anda dapat melihat implementasinya secara lebih rinci di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> .  Karena kenyataan bahwa setiap panah mengakhiri animasinya di titik awal dari bagian animasi dari panah berikutnya, kesan pergerakan terus menerus dari panah di sepanjang seluruh bagian rute yang dipilih dibuat. </p><br><p>  Mengenai hal ini, saya mengusulkan untuk menyelesaikan pertimbangan berbagai aspek rendering dan pergi ke bagian utama - menentukan posisi objek di atas panggung dengan koordinat geografis objek. </p><br><h1 id="opredelenie-pozicii-obekta-na-scene">  Menentukan posisi suatu objek pada adegan </h1><br><p>  Kami memulai percakapan tentang menentukan posisi suatu objek di tempat kejadian dengan mempertimbangkan sistem koordinat, konversi di antaranya harus dilakukan.  Hanya ada 2 di antaranya: </p><br><ul><li>  koordinat geodesik (atau geografis untuk kesederhanaan) - posisi objek (titik rute) di dunia nyata, </li><li>  Koordinat Cartesius - posisi objek di tempat kejadian (dalam ARKit).  Ingat bahwa sistem koordinat adegan bertepatan dengan sistem koordinat ARKit (dalam kasus menggunakan ARSCNView). </li></ul><br><p>  Terjemahan dari satu sistem koordinat ke yang lain dan sebaliknya dimungkinkan karena fakta bahwa koordinat dalam ARKit diukur dalam meter, dan offset antara dua koordinat geodetik dapat diterjemahkan dengan sangat akurat ke dalam offset dalam meter di sepanjang sumbu X dan Z dari sistem koordinat ARKit pada offset kecil.  Biarkan saya mengingatkan Anda bahwa koordinat geodetik adalah titik dengan garis bujur dan garis lintang tertentu. </p><br><p>  Mari kita ingat konsep-konsep penting seperti itu dari perjalanan geografi seperti paralel dan garis meridian, dan sifat dasarnya: </p><br><ul><li>  <strong>Paralel</strong> adalah garis dengan nilai derajat lintang.  Panjang dari berbagai persamaan itu berbeda. </li><li>  <strong>Meridian</strong> - garis dengan nilai derajat bujur.  Panjang semua meridian adalah sama. </li></ul><br><p>  Sekarang mari kita lihat bagaimana Anda dapat menghitung offset dalam meter, antara dua koordinat geodetik dengan koordinat <img src="https://habrastorage.org/getpro/habr/post_images/211/5b5/55a/2115b555a85046620be7a8523deb4d25.svg" alt="\ inline (lat_1, lon_1)">  dan <img src="https://habrastorage.org/getpro/habr/post_images/5f8/1d8/647/5f81d86472cae8dabc2ac218803f8125.svg" alt="\ inline (lat_2, lon_2)">  : </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/a44/a8c/946/a44a8c946ea2dc906e48fe45dae1a432.svg" alt="\ Delta x = \ Delta lon \ kali meterInLonDegree (lat_ {0})">  , <img src="https://habrastorage.org/getpro/habr/post_images/96a/036/d49/96a036d490185172d1ac79635788e31b.svg" alt="\ Delta z = \ Delta lat \ kali meterInLatDegree"></p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/8f5/438/3f1/8f54383f1775fe7105087c4ff5891a18.svg" alt="metersInLonDegree (\ alpha) = \ frac {2 \ pi R_ \ text {lands} \ cos \ kiri (\ alpha \ kanan)} {360 ^ {Â°}}">  , <img src="https://habrastorage.org/getpro/habr/post_images/afa/9ec/76a/afa9ec76ae9ee9dfdf5228c8ace8c603.svg" alt="metersInLatDegree = \ frac {2 \ pi R_ \ text {lands}} {360 ^ {Â°}}"></p><br><div class="spoiler">  <b class="spoiler_title">Penjelasan</b> <div class="spoiler_text"><p>  Perpindahan dalam koordinat geodetik memetakan secara linier ke meter hanya pada perpindahan kecil.  Pada pemindahan besar, perlu untuk mengambil bagian integral secara jujur. </p></div></div><br><p>  Sekarang kita dapat menerjemahkan offset dari satu sistem koordinat ke yang lain, kita perlu memutuskan titik referensi - titik di mana koordinat geografis dan koordinat di ARKit (koordinat di atas panggung) diketahui secara bersamaan.  Setelah menemukan titik seperti itu, kita dapat menentukan koordinat objek apa pun di atas panggung, mengetahui koordinat geografisnya dan menggunakan rumus di atas. </p><br><p>  Untuk kejelasan, pertimbangkan sebuah contoh: <br>  Pada awal sesi augmented reality, kami meminta CoreLocation untuk koordinat geografis kami dan menerimanya langsung - <img src="https://habrastorage.org/getpro/habr/post_images/fda/ae2/64a/fdaae264a0f9dd176411b6ff5755bff4.svg" alt="\ inline (lat_0, lon_0)">  .  Mengingat fakta bahwa asal-usul sistem koordinat ARKit adalah pada awal sesi di titik di mana perangkat berada, kami mendapat titik referensi, karena kami tahu koordinat geografis dan koordinat di tempat kejadian <img src="https://habrastorage.org/getpro/habr/post_images/24e/b89/0e6/24eb890e6f1f8beac2b3c3cecfd8fe48.svg" alt="\ sebaris (x_0, y_0, z_0) = (0,0,0)">  .  Mari kita perlu menemukan koordinat pada adegan objek dengan koordinat geografis <img src="https://habrastorage.org/getpro/habr/post_images/211/5b5/55a/2115b555a85046620be7a8523deb4d25.svg" alt="\ inline (lat_1, lon_1)">  .  Untuk melakukan ini, cari offset dalam meter antara koordinat geografis objek dan koordinat geografis dari titik referensi kami, dan kemudian tambahkan offset yang ditemukan ke koordinat di tempat titik referensi.  Koordinat yang dihasilkan di tempat kejadian akan menjadi yang diinginkan. </p><br><p><img src="https://habrastorage.org/webt/t5/n7/c7/t5n7c7_5qzbakweb9xcaal2ai0u.png" alt="koordinat-konversi-objek-posisi-di-tempat"></p><br><p>  Saya perhatikan bahwa posisi pada adegan yang ditemukan dengan cara ini akan sesuai dengan posisi objek di dunia nyata hanya jika sumbu X / Z dari sistem koordinat adegan disejajarkan dengan arah ke Selatan / Timur.  Penyelarasan sumbu, secara teori, harus dicapai dengan mengatur bendera WorldAlignment ke gravitiAndHeading.  Tapi seperti yang saya katakan di awal posting, ini jauh dari selalu terjadi. </p><br><p>  Mari kita pertimbangkan secara lebih rinci metode penentuan titik referensi.  Untuk melakukan ini, kami memperkenalkan konsep <strong>perkiraan</strong> - seperangkat koordinat geografis dan koordinat di atas panggung. </p><br><p><img src="https://habrastorage.org/webt/gl/lu/ap/glluap6lmes0g1o2q124jkyb4y0.png" alt="koordinat-konversi-estimasi-definisi"></p><br><p>  Metode yang diusulkan di atas untuk menentukan titik referensi mungkin tidak selalu digunakan.  Pada saat dimulainya sesi augmented reality, permintaan untuk CLLokasi pengguna mungkin tidak segera dieksekusi, apalagi, akurasi koordinat yang diperoleh mungkin memiliki kesalahan besar.  Akan lebih tepat untuk meminta SceneKit untuk posisi di atas panggung saat ini ketika kita mendapatkan nilai dari CoreLocation.  Dalam hal ini, komponen estimasi yang dihasilkan memang diperoleh pada saat yang sama, dan kami memiliki kesempatan untuk menggunakan salah satu estimasi tersebut sebagai titik referensi.  Saat bekerja dengan ARKit, kesalahan offset terakumulasi dari waktu ke waktu, jadi Apple tidak merekomendasikan menggunakan ARKit sebagai alat navigasi. </p><br><p>  Ketika kami memutuskan untuk menerapkan rute pejalan kaki dengan augmented reality, kami melakukan sedikit riset tentang solusi yang ada pada saat itu, menggunakan ARKit untuk tugas serupa, dan menemukan kerangka kerja ARKit + CoreLocation.  Gagasan kerangka kerja ini adalah bahwa berkat ARKit kami dapat lebih akurat menentukan lokasi pengguna daripada saat menggunakan secara eksklusif CoreLocation. </p><br><p>  Konsep ARKit + CoreLocation: </p><br><ul><li>  saat menerima CLLocation dari CLLocationManager <br><ul><li>  meminta posisi di tempat kejadian menggunakan scene.pointOfView.worldPosition </li><li>  simpan pasangan koordinat ini (perkiraan) ke buffer </li></ul></li><li>  dapatkan lokasi yang tepat jika perlu <br><ul><li>  pilih estimasi terbaik </li><li>  menghitung offset antara posisi saat ini di atas panggung dan posisi di atas panggung dari perkiraan terbaik </li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> terapkan offset yang ditemukan ke koordinat geografis estimasi terbaik </font></font></li></ul></li></ul><br><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Koordinat geografis pengguna yang dihitung menggunakan estimasi terbaik akan lebih akurat daripada nilai terakhir yang diterima dari CoreLocation, dan pada saat yang sama akan memiliki lebih sedikit kesalahan. </font></font></p><br><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tetap hanya untuk memahami apa artinya "perkiraan terbaik". </font><font style="vertical-align: inherit;">Untuk melakukan ini, mari kita lihat bagaimana itu dipilih dan kapan itu diperbarui.</font></font></p><br><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Algoritma untuk memilih estimasi terbaik (dipilih hanya menggunakan komponen geografis): </font></font></p><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> terbaik dalam akurasi (memiliki akurasi horizontal terendah), </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> yang terbaru di antara perkiraan dengan akurasi yang sama, </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dipilih di antara perkiraan pada jarak tidak lebih dari 100 meter dari lokasi saat ini. </font></font></li></ul><br><p>          CoreLocation   .    ,     ,     CoreLocation   ,             100    . </p><br><p>       ,           . ,             ,        ( 100 ). </p><br><h1 id="korrektirovka-sistemy-koordinat">    </h1><br><p>       ,   X/Z   ARKit        /   . ARKit    ,       ,            . </p><br><div class="spoiler">  <b class="spoiler_title">Mengapa</b> <div class="spoiler_text"><p>   ,       (,   IKEA,            ),       Y   ARKit â€“        ,                   .        gravity   worldAlignment. </p></div></div><br><p>    ,          .        ,     ,            ,        .         .        AR     .        ,  ,    ,   ,  .       AR. </p><br><h2 id="opredelenie-ugla-korrekcii">    </h2><br><p>    ,      .  ,     <img src="https://habrastorage.org/getpro/habr/post_images/593/7e3/1a5/5937e31a59e1e414d1a9305d5826e3aa.svg" alt="\inline t_1">    CLLocationManager   <img src="https://habrastorage.org/getpro/habr/post_images/211/5b5/55a/2115b555a85046620be7a8523deb4d25.svg" alt="\ inline (lat_1, lon_1)">      â€” <img src="https://habrastorage.org/getpro/habr/post_images/1bc/c49/846/1bcc49846ef09e14c8b3855a701f4b9f.svg" alt="\ sebaris (x_1, z_1)">  .     <img src="https://habrastorage.org/getpro/habr/post_images/1fb/2ab/c7a/1fb2abc7a7042f7bf12001fab25ae688.svg" alt="\ sebaris t_2">      CLLocationManager â€” <img src="https://habrastorage.org/getpro/habr/post_images/5f8/1d8/647/5f81d86472cae8dabc2ac218803f8125.svg" alt="\ inline (lat_2, lon_2)">     <img src="https://habrastorage.org/getpro/habr/post_images/ed3/051/02d/ed305102d4e86b54584281d6590b0492.svg" alt="\ sebaris (x_2, z_2)">  sesuai. </p><br><p>      ARKit â€” <img src="https://habrastorage.org/getpro/habr/post_images/9a1/682/65e/9a168265ec4504ebe5356d7a9803a313.svg" alt="\ inline (\ Delta x, \ Delta z)">    2     CoreLocation    <img src="https://habrastorage.org/getpro/habr/post_images/1fb/2ab/c7a/1fb2abc7a7042f7bf12001fab25ae688.svg" alt="\ sebaris t_2">  .   <img src="https://habrastorage.org/getpro/habr/post_images/5f8/1d8/647/5f81d86472cae8dabc2ac218803f8125.svg" alt="\ inline (lat_2, lon_2)">    <img src="https://habrastorage.org/getpro/habr/post_images/0ad/186/b97/0ad186b971730a033bc621b7144413d2.svg" alt="\ inline (lat_ {2calc}, lon_ {2calc})">  .      ,    CoreLocation        .      .        ARKit     /. </p><br><p><img src="https://habrastorage.org/webt/kp/cy/jc/kpcyjc9rjyxrnlnmzaved-ytw8m.png" alt="koordinat-konversi-koreksi-sudut-masalah"></p><br><p>          ARKit      Y?          .         : </p><br><ol><li>      , </li><li>  , </li><li>     , </li><li>        , </li><li>     . </li></ol><br><p>   .   .   CLLocationManager'    ,               (  ),       (  ). </p><br><div class="spoiler"> <b class="spoiler_title">   ?</b> <div class="spoiler_text"><p>            .      ,     ,         .     , ,    GPS . </p></div></div><br><p>       1, 2       : <img src="https://habrastorage.org/getpro/habr/post_images/1a3/078/c21/1a3078c2199432c003ffc50a749fbb66.svg" alt="\ inline initialBearing (1,2)">  dan <img src="https://habrastorage.org/getpro/habr/post_images/2e5/fc3/325/2e5fc3325cde601c4f4c59dae3576b62.svg" alt="\ inline initialBearing (1,2_ {calc})"> ,  <img src="https://habrastorage.org/getpro/habr/post_images/993/049/474/9930494747afd3ba004e0f512635539e.svg" alt="\ sebaris 2_ {kalk}"> â€“    2,      ARKit.   <img src="https://habrastorage.org/getpro/habr/post_images/937/c05/90c/937c0590c7c66d7762185d852a9adf1c.svg" alt="\ inline initialBearing (a, b)">   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="></a> (  Bearing). </p><br><p><img src="https://habrastorage.org/webt/wp/lf/lv/wplflvaucl_3ntt7x-of1_pmj2q.png" alt="koordinat-konversi-koreksi-sudut-perhitungan-untuk-pasangan"></p><br><p>                  .    ,        ? ,        ,  ,        ,         .          ,      ,    ,   horizontalAccuracy.  ,   ,          ,   .                    : </p><br><p><img src="https://habrastorage.org/webt/3m/qc/_k/3mqc_krnknduxupcmianxsturym.png" alt="koordinat-konversi-koreksi-sudut-perhitungan-kesalahan"></p><br><p>  ,   ,                 . </p><br><p>    . ,          .  Sebagai contoh: </p><br><ul><li>  N     , </li><li>       , </li><li> M      (  ?). </li></ul><br><p>  ,    ,    ,    ,       (),              .                ,  .    ,     ,           .   ,    ,     (    ).               . </p><br><p>  ,                . ,     ,      (          ,           ,     ). </p><br><h2 id="testirovanie">  Pengujian </h2><br><p> ,      .  ,     ,    ,     .      2 : </p><br><ul><li>     , </li><li>        . </li></ul><br><p>  -      , ,   ,      ,         . </p><br><p>                .  , ,  100  CLLocation,          .   ,     , ,  10  (       10 ).            ?        ,        "".   ,        .    ,        ,       ,    .   ,       ,     .      ,      CoreLocation.     ,     .  ,      . </p><br><p>       .     ,            .   ,     (,       ),          ,       0 . ,    ,    . </p><br><p>       " ".              .      ,        ,     ,       ,        CLLocation,        ,            .        (         )       . </p><br><p>    ,           ARKit. </p><br><p><img src="https://habrastorage.org/webt/wv/qd/8i/wvqd8ikrpgvslsgndlmvmss13yu.png" alt="koreksi-sudut-perhitungan-alg-pengujian-jalan-sebelum-koreksi"></p><br><p> ,       . </p><br><p><img src="https://habrastorage.org/webt/jx/qb/aq/jxqbaqs21nprxhb6zhfueipyj2s.png" alt="koreksi-sudut-perhitungan-alg-pengujian-jalan-setelah-koreksi"></p><br><p>    ( 3-4 )           ,    . </p><br><p><img src="https://habrastorage.org/webt/fd/1n/ct/fd1nctm6j9slks4r8rfhmmvkjz8.png" alt="koreksi-sudut-perhitungan-alg-pengujian-jalan-setelah-koreksi terakhir"></p><br><p>          JS,       AR  CoreLocation. </p><br><p><img src="https://habrastorage.org/webt/4e/gk/2r/4egk2rlbx_5aloj-tc-2rcxqoaq.png" alt="koreksi-sudut-perhitungan-alg-pengujian-trek"></p><br><p>              â€”     gravity   worldAlignment      .      ,          .              . </p><br><h1 id="vmesto-zaklyucheniya">  Alih-alih sebuah kesimpulan </h1><br><p>      Slack, ,  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="></a> ,  ,         .                      AR.  .       AR  AppStore  2017 . ,      . </p><br><h1 id="poleznye-ssylki">  Tautan yang bermanfaat </h1><br><ul><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="></a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="> </a> </li><li> ARKit+CoreLocation <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="></a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="></a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">   ARKit</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">    </a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="> AR   </a> </li></ul><br><p>      ,           <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="> .</a> . </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id421957/">https://habr.com/ru/post/id421957/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id421945/index.html">Google dan Mastercard membuat kesepakatan rahasia untuk melacak pembelian di toko</a></li>
<li><a href="../id421947/index.html">Selamat datang di Android Devs Meetup 8 September</a></li>
<li><a href="../id421949/index.html">Pasukan Bunuh Diri Bagaimana kami merekrut pengembang junior yang paling galak</a></li>
<li><a href="../id421953/index.html">Summ3r 0f h4ck: magang musim panas di Digital Security</a></li>
<li><a href="../id421955/index.html">Senat tidak ingin robot terganggu oleh bir. Dan apa lagi yang harus ditulis pada hari Jumat?</a></li>
<li><a href="../id421959/index.html">Apa yang harus dilakukan ketika "ini" kehilangan tautan konteks</a></li>
<li><a href="../id421961/index.html">Membuat demo untuk ponsel lama - AONDEMO</a></li>
<li><a href="../id421963/index.html">Pembukuan dan akuntan: peran mereka dalam organisasi</a></li>
<li><a href="../id421965/index.html">"Selain bekerja, saya masih bekerja" - 10 pertanyaan untuk programmer, edisi ketiga</a></li>
<li><a href="../id421967/index.html">Mainan anak-anak pada elemen logis</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>