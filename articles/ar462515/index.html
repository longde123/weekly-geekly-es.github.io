<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🏟️ 🕠 👩🏿‍🤝‍👨🏽 الأخطاء عند العمل مع لوحة مفاتيح النظام 🕳️ 📻 👉</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="بالتفاعل مع التطبيق ، نقوم في مرحلة ما بتنشيط لوحة مفاتيح النظام لكتابة رسالة أو ملء الحقول المطلوبة. هل واجهت مواقف عندما يتم عرض لوحة المفاتيح ، ولك...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>الأخطاء عند العمل مع لوحة مفاتيح النظام</h1><div class="post__body post__body_full" style=";text-align:right;direction:rtl"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/oleg-bunin/blog/462515/" style=";text-align:right;direction:rtl">  <em>بالتفاعل مع التطبيق ، نقوم في مرحلة ما بتنشيط لوحة مفاتيح النظام لكتابة رسالة أو ملء الحقول المطلوبة.</em>  <em>هل واجهت مواقف عندما يتم عرض لوحة المفاتيح ، ولكن لا يوجد حقل لإدخال رسالة ، أو العكس - لوحة المفاتيح موجودة ، حيث إدخال النص غير مرئي؟</em>  <em>يمكن أن تكون الأخطاء متعلقة بمشاكل في تطبيق معين ، وكذلك بأوجه القصور العامة في لوحة مفاتيح النظام.</em> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u="><em>رأى قسطنطين موردان</em></a> <em>، وهو مطور لنظام iOS من Mail.ru ، كل شيء في عمله: بعد تحليل طرق التحكم في لوحة المفاتيح في نظام iOS ، قرر مشاركة الأخطاء والطرق الرئيسية التي استخدمها لاكتشافها وإصلاحها.</em> <br><br><div style="text-align:center;;text-align:right;direction:rtl"><img src="https://habrastorage.org/webt/fb/wc/xg/fbwcxgdtopdtlj8_u7rkj1vnmne.jpeg" width="400"></div><br><br>  <i>تحذير: تحت القطع ، وضعنا الكثير من صور متحركة لإظهار الأخطاء بوضوح.</i>  <i>ستجد المزيد من الأمثلة في تقرير <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">الفيديو</a> الخاص بـ Konstantin على AppsConf.</i> <br><a name="habracut"></a><br><h1 style=";text-align:right;direction:rtl">  تطبيق استدعاء لوحة مفاتيح النظام </h1><br>  لنبدأ بفهم كيفية تنفيذ مكالمة لوحة المفاتيح بشكل عام. <br><br>  تخيل أنك تقوم بتطوير تطبيق مهمته تجميع Aika (حرف South Park) في كندي كامل باستخدام لوحة المفاتيح.  عندما تضغط على Aiku على المعدة ، تغادر لوحة المفاتيح ، وبذلك ترفع ساقي بطلنا إلى الرأس. <br><br>  لتنفيذ المهمة ، يمكنك استخدام <i>InputAccessoryView</i> أو معالجة إعلامات النظام. <br><br><h2 style=";text-align:right;direction:rtl">  InputAccessoryView </h2><br>  دعنا ننظر إلى الخيار الأول. <br><br>  في ViewController ، قم بإنشاء طريقة عرض ستظهر مع لوحة المفاتيح ، ثم قم بإعطاءها إطارًا.  من المهم عدم إضافة طريقة العرض هذه كطريقة عرض فرعية.  بعد ذلك ، فإننا <em>نتجاوز</em> خصائص <em>canBecomeFirstResponder ونعود صائبة</em> .  بعد أن نقوم بإعادة تعريف خاصية <em>UIResponder</em> - <em>inputAccessoryView</em> ووضع العرض هناك.  لإغلاق لوحة المفاتيح ، أضف <em>tapGesture</em> وفي معالجها ، قم <em>بإعادة تعيين أول مستجيب للعرض الذي أنشأناه</em> . <br><br><pre style=";text-align:right;direction:rtl"><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ViewController</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UIViewController</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> tummyView: <span class="hljs-type"><span class="hljs-type">UIView</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> frame = <span class="hljs-type"><span class="hljs-type">CGRect</span></span>(x: x, y: y, width: width, height: height) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> v = <span class="hljs-type"><span class="hljs-type">TummyView</span></span>(frame: frame) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> v } <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> canBecomeFirstResponder: <span class="hljs-type"><span class="hljs-type">Bool</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> input <span class="hljs-type"><span class="hljs-type">AccessoryView</span></span>: <span class="hljs-type"><span class="hljs-type">UIView?</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> tummyView } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">tapHandler</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( )</span></span></span></span> { tummyView.resignFirstResponder ( ) } }</code> </pre> <br>  اكتمال المهمة ، ويقوم النظام نفسه بمعالجة تغييرات حالة لوحة المفاتيح ، ويظهرها ويرفع طريقة العرض ، التي تعتمد عليها. <br><br><div style="text-align:center;;text-align:right;direction:rtl"><img src="https://habrastorage.org/webt/ew/mu/nd/ewmundnnrpbdgjgwvk_frx4qv6o.gif" width="200"></div><br><br><h2 style=";text-align:right;direction:rtl">  نظام إعلام معالجة </h2><br>  في حالة معالجة الإشعارات ، سيتعين علينا معالجة الإشعارات من المجموعات التالية بأنفسنا: <br><br><ul style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl">  متى سيتم عرض / إظهار لوحة المفاتيح: keyboardWillShowNotification، keyboardDidShowNotification؛ </li><li style=";text-align:right;direction:rtl">  عندما سوف / كانت لوحة المفاتيح مخفية: keyboardWillHideNotification، keyboardDidHideNotification؛ </li><li style=";text-align:right;direction:rtl">  عندما سيتم تغيير / تغيير إطار لوحة المفاتيح: keyboardWilChangeFrameNotification، keyboardDidChangeFrameNotification. </li></ul><br>  لتنفيذ قضيتنا ، دعنا نأخذ <em>keyboardWilChangeFrameNotification</em> ، حيث يتم إرسال هذا الإشعار عند عرض لوحة المفاتيح وعندما تكون مخفية. <br><br>  نقوم بإنشاء <em>لوحة المفاتيح Tracker ،</em> حيث نشترك في استلام إخطار <em>keyboardWillChangeFrame</em> ، وفي المعالج نحصل على إطار لوحة المفاتيح ، ونحوله من نظام إحداثيات الشاشة إلى نظام إحداثيات النافذة ، ونحسب ارتفاع لوحة المفاتيح ونغير قيمة Y للعرض ، والتي ينبغي رفعها بواسطة لوحة المفاتيح ، إلى هذا الارتفاع. <br><br><pre style=";text-align:right;direction:rtl"> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">KeyboardTracker</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">enable</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( )</span></span></span></span> { notificationCenter.add0observer(<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, seletor: #selector( keyboardWillChangeFrame), name: <span class="hljs-type"><span class="hljs-type">UIResponder</span></span>.keyboardWillChangeFrameNotification, object: <span class="hljs-literal"><span class="hljs-literal">nil</span></span>) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">keyboardWillChangeFrame</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( notification: NSNotification)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> screenCoordinatedKeyboardFrame = (userInfo [ <span class="hljs-type"><span class="hljs-type">UIResponder</span></span>.keyboardFrameEndUserInfoKey ] <span class="hljs-keyword"><span class="hljs-keyword">as</span></span>! <span class="hljs-type"><span class="hljs-type">NSValue</span></span> ) .cgRectValue <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> keyboardFrame = window.convert ( screenCoordinatedKeyboardFrame, from: <span class="hljs-literal"><span class="hljs-literal">nil</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> windowHeight = window.frame.height <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> keyboardHeight = windowHeight - keyboardFrame.minY delegate.keyboardWillChange ( keyboardHeight ) } }</code> </pre> <br>  على هذا ، تم الانتهاء من مهمتنا ، ترتفع لوحة المفاتيح ، وجمع Ike في الكندية. <br><br>  كما نرى ، يعد تنفيذ العمل باستخدام لوحة المفاتيح أمرًا سهلاً في كلتا الحالتين ، بحيث يكون لكل شخص حرية اختيار الطريقة المناسبة بمفرده.  في مشروعنا ، اتخذنا خيارًا لصالح الإشعارات ، لذلك سيتم ربط المزيد من الأمثلة والرؤى بمعالجة الإشعارات. <br><br><h2 style=";text-align:right;direction:rtl">  أبحث عن الأخطاء </h2><br>  إذا كانت طريقة الاتصال بلوحة المفاتيح بسيطة للغاية ، فمن أين تأتي الأخطاء؟  بالطبع ، إذا قام التطبيق بإعادة إنتاج البرنامج النصي لفتح لوحة المفاتيح وإغلاقها فقط ، فلن تكون هناك أية مشكلات.  ولكن إذا قمت بتغيير المسار المعتاد للأشياء ، تذكر أنه ليس بإمكان تطبيقنا فقط استخدام لوحة المفاتيح ، ولكن أيضًا الآخرين ، ويمكن للمستخدم أيضًا التبديل بينها ، فلا يمكن تجنب المفاجآت. <br><br>  لنلقِ نظرة على مثال.  للقيام بذلك ، استخدم التطبيق الخاص بنا مع Ike: افتح لوحة المفاتيح ، وقم بالتبديل إلى Notes ، وطباعة شيء والعودة إلى التطبيق. <br><br><div style="text-align:center;;text-align:right;direction:rtl"><img src="https://habrastorage.org/webt/zm/nr/4n/zmnr4nm4u8tph3bf86jkr05ix5k.gif" width="200"></div><br><br>  ما هي المشاكل مرئية بالفعل؟  أولاً ، لا توجد لوحة مفاتيح في App Switcher ، على الرغم من أنه عندما يتم تصغير التطبيق إلى الحد الأدنى ، وبدلاً من ذلك ، يكون المحتوى الآخر مرئيًا.  ثانياً ، عند العودة إلى التطبيق ، لا تزال لوحة المفاتيح غير موجودة ، وتسقط أرجل Ike أسفل الشاشة. <br><br>  لنلقِ نظرة على أسباب هذا السلوك.  كما نتذكر جميعًا من مخطط دورة حياة التطبيق ، فإن الانتقال من تطبيق ما من حالة نشطة إلى حالة غير نشطة أولاً في المقدمة ثم في الخلفية يستغرق بعض الوقت. <br><br>  ماذا عن دورة حياة لوحة المفاتيح؟  في نظام التشغيل iOS ، لكل وحدة زمنية ، يمكن امتلاك لوحة المفاتيح لواحد فقط من التطبيقات قيد التشغيل ، لكن يتم تلقي الإخطارات حول التغييرات في حالة لوحة المفاتيح من قبل جميع التطبيقات الموقعة عليها. <br><br>  عند التبديل من تطبيق إلى آخر ، يقوم النظام بإعادة ضبط أول رده ، والذي يعمل بمثابة مشغل لإخفاء لوحة المفاتيح.  يرسل النظام إخطار keyboardWillHide أولاً حتى تختفي لوحة المفاتيح ، ثم keyboardDidHideNotification.  ينتقل الإشعار إلى التطبيق الثاني.  في التطبيق الجديد ، نفتح لوحة المفاتيح: يرسل النظام keyboardWillShowNotification حتى تظهر لوحة المفاتيح ثم يرسل keyboardDidShowNotification - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">عرض توضيحي</a> ، مع مراحل الدورة. <br><br><img src="https://habrastorage.org/webt/gk/th/5c/gkth5chvrkyewmvhdrpc7eito9q.jpeg"><br><br>  إذا نظرت إلى <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">مقتطف من التقرير</a> (من 8:39) ، سترى اللحظة التي يقوم فيها النظام ، بعد إخفاء لوحة المفاتيح ، بإرسال keyboardDidHideNotification لوضع التطبيق الأول في حالة غير نشطة.  عندما تقوم بالتبديل إلى التطبيق الرياضي وتشغيل لوحة المفاتيح ، يرسل النظام keyboardWillShowNotification.  ولكن نظرًا لأن عملية التبديل والبدء تكون سريعة ، ويمكن أن يكون وقت الانتقال بين مراحل دورة الحياة أطول ، فإن الإخطار المستلم لن يعالج فقط تطبيق الرياضة ، ولكن أيضًا تطبيق البيرة ، التي لم تتمكن بعد من الانتقال إلى الخلفية. <br><br>  بعد معرفة الأسباب ، دعونا الآن نجد حلاً لمشكلة Ike. <br><br><h3 style=";text-align:right;direction:rtl">  قرار سيء </h3><br>  أول ما يتبادر إلى الذهن هو فكرة إلغاء الاشتراك / الاشتراك في الإشعارات عند تصغير / تعظيم تطبيق من خلال تمكين / تعطيل KeyboardTracker. <br><br>  لإلغاء الاشتراك ، نستخدم طريقة applicationWillResignActive أو معالج إعلام مماثل من النظام ؛ للاشتراك ، نستخدم applicationDidBecomeActive ، ولكن حتى لا نضيع أي شيء ، سنقوم أيضًا بإخطار طريقة applicationWillEnterForeground ، والتي يتم استدعاؤها عندما يدخل التطبيق المقدمة ، ولكن لا تصبح نشطة حتى الآن. <br><br>  عند بدء تشغيل لوحة المفاتيح في التطبيق ، من المرجح أن يكون كل شيء ناجحًا ، ولكن مع اختبارات أكثر تعقيدًا ، على سبيل المثال ، فتح لوحة المفاتيح ومحاولة تسجيل الاتصال الصوتي ، لن ينجح الحل. <br><br><div style="text-align:center;;text-align:right;direction:rtl"><img src="https://habrastorage.org/webt/dy/0b/_e/dy0b_eiomhqtkuqimnsdew_es-c.gif" width="200"></div><br><br>  ماذا حدث  بعد النقر على زر الاتصال بالرسائل الصوتية ، تمت إعادة تعيين التطبيق أولاً ، وتم إغلاق لوحة المفاتيح ، وتم استدعاء طريقة applicationWillResignActive وتم إلغاء اشتراكنا.  بعد إغلاق التنبيه ، استعاد النظام حالة التطبيق ، ولكن قبل أن يتم استدعاء طريقة applicationWillEnterForeground ، وخاصة applicationDidBecomeActive. <br><br><h3 style=";text-align:right;direction:rtl">  قرار جيد </h3><br>  حل آخر هو استخدام مرق واقية (Bool). <br><br><pre style=";text-align:right;direction:rtl"> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> wasTummyViewFirstResponderBeforeApp0idEnterBackground <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">willResignActive</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( notification: NSNotification)</span></span></span></span> { wasTextFieldFirstResponderBeforeAppDidEnterBackground = tummyView.isFirstResponder } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">willEnterForeground</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( notification: NSNotification)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> wasTextFieldFirstResponderBeforeAppDidEnterBackground { <span class="hljs-type"><span class="hljs-type">UIView</span></span>.performWithourAnimation { tummyView.becomeFirstResponder ( ) } } }</code> </pre> <br>  نتذكر ما إذا كان قد تم فتح لوحة المفاتيح قبل الموضوع ، وكيف توقف التطبيق عن العمل ، وفي طريقة applicationWillEnterForeground ، نستعيد الحالة السابقة.  الشيء الوحيد المتبقي لإصلاح هو ثقب في الجلاد التطبيق. <br><br><div style="text-align:center;;text-align:right;direction:rtl"><img src="https://habrastorage.org/webt/jc/sl/oc/jcsloczny6akuricp8x0bzwvbxo.jpeg" width="400"></div><br><br><h2 style=";text-align:right;direction:rtl">  الجلاد التطبيق </h2><br>  يعرض تطبيق الجلاد لقطات التطبيق التي يقوم بها النظام بعد دخول التطبيق إلى الخلفية.  توضح لقطة الشاشة أن لقطة تطبيقنا قد تم إجراؤها في وقت كانت لوحة المفاتيح قيد الاستخدام بالفعل من قبل تطبيق آخر.  هذا ليس بالأمر الحاسم ، لكن الأمر يتطلب بضع نقرات لإصلاحه. <br><br><h3 style=";text-align:right;direction:rtl">  حل جيد </h3><br>  يمكن استعارة الحل من التطبيقات المصرفية التي تعلمت إخفاء البيانات الحساسة ، وكذلك القراءة من <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">Apple</a> . <br><br>  يمكنك إخفاء البيانات في طريقة applicationDidEnterBackground ، وطمس وإظهار شاشة البداية ، وفي طريقة applicationWillEnterForeground ، نعود إلى التسلسل الهرمي للعرض المعتاد. <br><br>  لا يناسبنا هذا الخيار ، لأنه بحلول الوقت الذي يتم فيه استدعاء طريقة applicationDidEnterBackground ، لم يعد تطبيقنا يحتوي على لوحة مفاتيح. <br><br><h3 style=";text-align:right;direction:rtl">  قرار جيد </h3><br>  سوف نستخدم الطرق المألوفة التي سوف نقوم بتصميمها و إجابتها و أرضها و didBecomeActive. <br><br>  بينما لا يزال تطبيقنا يحتوي على لوحة مفاتيح ، ستحتاج إلى إنشاء لقطة خاصة بك من التطبيق بطريقة willResignActive ووضعها في التسلسل الهرمي. <br><br><pre style=";text-align:right;direction:rtl"> <code class="swift hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">willResignActive</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( notificaton: NSNotification)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> keyWindow = <span class="hljs-type"><span class="hljs-type">UIApplication</span></span>.shared.keyWindow imageView = <span class="hljs-type"><span class="hljs-type">UIImageView</span></span>( frame: keyWindow.bounds) imageView.image = snapshot ( ) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> lastSubview = keyWindow.subviews.last lastSubview( imageView) }</code> </pre> <br>  في أساليب willEnterForeground و didBecomeActive ، نقوم باستعادة التسلسل الهرمي للعرض وحذف لقطة لدينا. <br><br><pre style=";text-align:right;direction:rtl"> <code class="swift hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">willEnterForeground</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( notification: NSNotification)</span></span></span></span> { imageView.removeFromSuperview( ) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">didBecomeActive</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( notification: NSNotification)</span></span></span></span> { imageView.removeFromSuperview( ) }</code> </pre> <br>  ونتيجة لذلك ، قمنا بإصلاح الحالتين: في جهاز تبديل التطبيق ، لم تعد الصورة الجميلة ولوحة المفاتيح تقفز عند التبديل.  يبدو أن هذه ليست أشياء مهمة ، ولكن لتطوير المنتجات ، هذه النقاط مهمة للغاية. <br><br><h2 style=";text-align:right;direction:rtl">  أخبار سيئة </h2><br>  يتعلق حلنا الناجح لمشكلة Ike بالحالة عندما تم فتح لوحة المفاتيح قبل تصغير التطبيق.  إذا حدث التبديل دون توسيع لوحة المفاتيح ، فسوف نرى مرة أخرى أن أرجل Ike لدينا سقطت أدناه. <br><br><div style="text-align:center;;text-align:right;direction:rtl"><img src="https://habrastorage.org/webt/zm/nr/4n/zmnr4nm4u8tph3bf86jkr05ix5k.gif" width="200"></div><br><br>  هذه ليست مشكلة في تطبيقنا فحسب ، بل يتم ملاحظة هذا السلوك أيضًا على Facebook ، والذي يعمل مع الإشعارات ، وحتى بالنسبة لـ iMessage ، والذي يستخدم inputAccessoryView للتحكم في لوحة المفاتيح.  هذا يرجع إلى حقيقة أنه قبل التبديل إلى الخلفية ، تمكنت التطبيقات من معالجة إشعارات لوحة المفاتيح الخاصة بالأشخاص الآخرين. <br><br><h2 style=";text-align:right;direction:rtl">  تفاعلي لوحة المفاتيح الطرد </h2><br>  أضف بعض الوظائف إلى تطبيقنا مع Ike ، لتعليم البرنامج لإخفاء لوحة المفاتيح بشكل تفاعلي. <br><br><div style="text-align:center;;text-align:right;direction:rtl"><img src="https://habrastorage.org/webt/g6/cy/1g/g6cy1gparlfmqc0abfaz7rd_rr0.gif" width="200"></div><br><br><h3 style=";text-align:right;direction:rtl">  قرار سيء </h3><br>  إحدى الطرق لجعل هذه الوظيفة هي تغيير إطار عرض لوحة المفاتيح.  نقوم بإنشاء panGestureRecognizer ، في معالجها نقوم بحساب القيمة الجديدة للإحداثي Y للوحة المفاتيح ، اعتمادًا على موضع إصبعنا ، والعثور على عرض لوحة المفاتيح وتحديثه بقيمة الإحداثي Y. <br><br><pre style=";text-align:right;direction:rtl"> <code class="swift hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">panGestureHandler</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( )</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> yPosition: <span class="hljs-type"><span class="hljs-type">CGFloat</span></span> = value keyboardView( )?.frame.origin.y = yPosition }</code> </pre> <br>  يتم عرض لوحة المفاتيح في نافذة منفصلة ، لذلك تحتاج إلى تجاوز مجموعة الإطارات بالكامل في التطبيق ، والتحقق من كل عنصر من عناصر الصفيف ما إذا كان إطار لوحة المفاتيح ، وإذا كان الأمر كذلك ، احصل على عرض منه يعرض لوحة المفاتيح. <br><br><pre style=";text-align:right;direction:rtl"> <code class="swift hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">keyboardView</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( )</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">UIView?</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> windows = <span class="hljs-type"><span class="hljs-type">UIApplication</span></span>.shared.windows <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> view = windows.first { (window) -&gt; <span class="hljs-type"><span class="hljs-type">Bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> keyboardView( fromWindow: window) != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> view }</code> </pre> <br>  لسوء الحظ ، لن يعمل هذا الحل بشكل طبيعي على iPhone X والإصدارات الأحدث ، لأنه عند تحريك إصبعك ، يمكنك لمس المؤشر السفلي ، وهو المسؤول قليلاً عن تقليل التطبيق.  بعد ذلك ، يتوقف الاختباء التفاعلي عن العمل. <br><br><div style="text-align:center;;text-align:right;direction:rtl"><img src="https://habrastorage.org/webt/eg/-o/iv/eg-oiv8yrssufcejelvxqj4ksrq.gif" width="200"></div><br><br>  المشكلة تكمن في مجموعة من النوافذ. <br><br><img src="https://habrastorage.org/webt/vc/u6/9o/vcu69oekot0zgl31iikyy_0refo.jpeg" width="600"><br><br>  بعد الإيماءة ، يقوم النظام بإنشاء نافذة لوحة مفاتيح جديدة أعلى الإطار الحالي.  إنه أمر لا يمكن تصوره ، لكنه حقيقي.  نتيجة لذلك ، اتضح أن الصفيف يحتوي على نافذتي لوحة مفاتيح لهما نفس الإحداثيات ، ولكن الأول مخفي. <br><br><img src="https://habrastorage.org/webt/pp/0v/ha/pp0vhay6ionyekifnsg-9jvnpzg.jpeg"><br><br>  اتضح أنه ، بالتكرار على مجموعة من النوافذ ، نجد أول واحد يرضي الظروف ، ونبدأ في العمل معها ، على الرغم من حقيقة أنها مخفية. <br><br>  كيف يتم إصلاح هذا؟  تحول مجموعة من النوافذ. <br><br><pre style=";text-align:right;direction:rtl"> <code class="swift hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">panGeastureHandler</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( )</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> yPosition: <span class="hljs-type"><span class="hljs-type">CGFloat</span></span> = <span class="hljs-number"><span class="hljs-number">0.0</span></span> keyboardView( )?.frame.origin.y = yPosition } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">keyboardView</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( )</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">UIView?</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> windows = <span class="hljs-type"><span class="hljs-type">UIApplication</span></span>.shared.windows.reversed( ) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> view = windows.first { (window) -&gt; <span class="hljs-type"><span class="hljs-type">Bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> keyboardView( fromWindow: window) != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> view }</code> </pre> <br><h2 style=";text-align:right;direction:rtl">  ميزات لوحة المفاتيح على iPad </h2><br>  تحتوي لوحة المفاتيح على iPad على حالة إلغاء التثبيت إلى جانب حالتها المعتادة.  يمكن للمستخدم تحريكه حول الشاشة ، وتقسيمه إلى جزأين ، وحتى تشغيل التطبيق في وضع الانزلاق (أعلى الجزء الآخر).  بالطبع ، من المهم أن تعمل لوحة المفاتيح في جميع هذه الأوضاع دون أخطاء. <br><br>  دعونا التحقق من Hayke لدينا. <br><br><div style="text-align:center;;text-align:right;direction:rtl"><img src="https://habrastorage.org/webt/y1/4x/l5/y14xl5geuyxmkubopbkabplwbz4.gif"></div><br><br>  للأسف ، هذا ليس هو الحال الآن.  بعد أن يبدأ المستخدم في تحريك لوحة المفاتيح حول الشاشة ، تطير أرجل Ike فوق رأسه وتظهر في مكانها فقط بعد الافتتاح التالي للوحة المفاتيح.  دعنا نحاول إصلاحه في حالة باستخدام لوحة مفاتيح مقسمة. <br><br><h3 style=";text-align:right;direction:rtl">  أسباب </h3><br>  لنبدأ بتحليل الإشعارات.  بعد النقر على زر التقسيم ، نحصل على مجموعتين من الإخطارات - keyboardWillChangeFrameNotification ، keyboardWillHideNotification ، keyboardDidChangeFrameNotification ، keyboardDidHideNotification.  الفرق بين المجموعات هو فقط في إحداثيات لوحة المفاتيح. <br><br>  عندما نقر على زر التقسيم ، تنخفض لوحة المفاتيح وتصل المجموعة الأولى من الإخطارات.  عندما انقسمت لوحة المفاتيح وصعدت - حصلنا على حزمة ثانية من الإخطارات. <br><br>  الشيء المهم هو أننا نتلقى إخطارات بأن لوحة المفاتيح قد اختفت ، ولكن لا يتم عرضها.  هذا ، بالمناسبة ، هو إضافة أخرى لصالح استخدام keyboardWillChangeFrameNotification. <br><br>  لماذا ، إذن ، تطير أرجل Ike بمجرد أن نبدأ في تحريك لوحة المفاتيح حول الشاشة؟ <br><br>  في هذه اللحظة ، يرسل النظام إلينا لوحة المفاتيح WillChangeFrameNotification ، لكن الإحداثيات الموجودة هناك (0.0 ، 0.0 ، 0.0 ، 0.0) ، لأن النظام لا يعرف عند أي نقطة ستكون لوحة المفاتيح بعد اكتمال الحركة. <br><br>  إذا قمنا باستبدال الأصفار في الكود الحالي الذي يعالج تغيير إطار لوحة المفاتيح ، يتضح أن ارتفاع لوحة المفاتيح يساوي ارتفاع النافذة.  هذا هو السبب في أن أرجل Ike تطير من الشاشة. <br><br><h3 style=";text-align:right;direction:rtl">  قرار جيد </h3><br>  لحل مشكلتنا ، أولاً سنتعلم فهم عندما تكون لوحة المفاتيح في وضع إلغاء التثبيت ويمكن للمستخدم تحريكها حول الشاشة. <br><br>  للقيام بذلك ، ما عليك سوى مقارنة ارتفاع النافذة ولوحة المفاتيح maxY.  إذا كانت متساوية ، فإن لوحة المفاتيح في حالتها العادية ، وإذا كان maxY أقل من ارتفاع النافذة ، فإن المستخدم ينقل لوحة المفاتيح.  نتيجة لذلك ، يظهر الرمز التالي في keyboardTracker: <br><br><pre style=";text-align:right;direction:rtl"> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">KeyboardTracker</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">enable</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( )</span></span></span></span> { notificationCenter.addObserver( <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, selector:#selector( keyboardWillChangeFrame), name:<span class="hljs-type"><span class="hljs-type">UIResponder</span></span>.keyboardWillChangeFrameNotification, object:<span class="hljs-literal"><span class="hljs-literal">nil</span></span>) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">keyboardWillChangeFrame</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( notification: NSNotification)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> screenCoordinatedKeyboardFrame = (userInfo[<span class="hljs-type"><span class="hljs-type">UIResponder</span></span>.keyboardFrameEndUserInfoKey] <span class="hljs-keyword"><span class="hljs-keyword">as</span></span>! <span class="hljs-type"><span class="hljs-type">NSValue</span></span>).cgRectValue <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> leyboardFrame = window.convert ( screenCoordinatedKeyboardFrame, from: <span class="hljs-literal"><span class="hljs-literal">nil</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> windowHeight = window.frame.height <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> keyboardHeight = windowHeight - keyboardFrame.minY <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> isKeyboardUnlocked = isIPad ( ) &amp;&amp; keyboardFrame/maxY &lt; windowHeight <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> isKeyboardUnlocked { keyboardHeight = <span class="hljs-number"><span class="hljs-number">0.0</span></span> } delegate.keyboardWillChange ( keyboardHeight) } }</code> </pre> <br>  لقد قمنا بضبط الارتفاع على الصفر ، والآن مع حركة لوحة المفاتيح ، تنحدر أرجل Ike ويتم إصلاحها هناك. <br><br><div style="text-align:center;;text-align:right;direction:rtl"><img src="https://habrastorage.org/webt/tx/uv/u_/txuvu_-lhk01nhlzbcyfxc8g3k4.gif" width="400"></div><br><br>  سوء التفاهم الوحيد المتبقي هو حقيقة أنه عند تقسيم لوحة المفاتيح ، لا تسقط أرجل Ike على الفور.  كيفية اصلاحها؟ <br><br>  سنقوم بتعليم keyboardTracker للعمل ليس فقط مع keyboardWillChangeFrameNotification ، ولكن أيضًا مع keyboardDidChangeFrame.  لا يلزمك كتابة رمز جديد ، ما عليك سوى إضافة التحقق من أن هذا جهاز iPad حتى لا يقوم بإجراء عمليات حسابية غير ضرورية. <br><br><pre style=";text-align:right;direction:rtl"> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">KeyboardTracker</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">keyboardDidChangeFrame</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( notification: NSNotification)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> isIPad ( ) == <span class="hljs-literal"><span class="hljs-literal">false</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> }</code> </pre> <br><br><div style="text-align:center;;text-align:right;direction:rtl"><img src="https://habrastorage.org/webt/jd/-n/nv/jd-nnvrctruwlczh4ytw2ckfllu.gif" width="400"></div><br><br><h2 style=";text-align:right;direction:rtl">  كيفية اكتشاف الأخطاء؟ </h2><br><h3 style=";text-align:right;direction:rtl">  تسجيل وفير </h3><br>  في مشروعنا ، تتم كتابة السجلات بالتنسيق التالي: بين قوسين معقوفين ، اسم الوحدة النمطية والوحدة الفرعية ، التي ينتمي إليها السجل ، ثم نص السجل نفسه.  على سبيل المثال ، مثل هذا: <br> <code>[keyboard][tracker] keyboardWillChangeFrame: calculated height - 437.9</code> <br> <br>  في الكود ، يبدو كما يلي - يتم إنشاء مسجل بعلامة المستوى الأعلى ويتم إرساله إلى المقتفي.  داخل المتعقب ، يتم إخراج المسجل باستخدام علامة المستوى الثاني ، والتي يتم استخدامها لتسجيل الدخول داخل الفصل ، من المسجل. <br><br><pre style=";text-align:right;direction:rtl"> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">KeyboardTracker</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">init</span></span>(with logger: <span class="hljs-type"><span class="hljs-type">Logger</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.trackerLogger = logger.dequeue(withTag: <span class="hljs-string"><span class="hljs-string">"[tracker]"</span></span>) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">keyboardWillChangeFrame</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(notification: NSNotification)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> height = <span class="hljs-number"><span class="hljs-number">0.0</span></span> trackerLogger.debug(<span class="hljs-string"><span class="hljs-string">"\(#function): calculated height - \(height)"</span></span>) } }</code> </pre> <br>  لذلك تعهدت بمتابعة لوحة المفاتيح بالكامل ، وهو أمر جيد.  إذا وجد القائمون على الاختبار مشاكل ، فقد أخذت ملف السجل وبحثت عن المكان الذي لا تتناسب فيه الإطارات تمامًا.  استغرق هذا الكثير من الوقت ، وبالتالي ، بالإضافة إلى قطع الأشجار ، بدأ تطبيق طرق أخرى. <br><br><h3 style=";text-align:right;direction:rtl">  كلب الحراسة </h3><br>  في مشروعنا ، يتم استخدام الوكالة الدولية للطاقة لتحسين دفق واجهة المستخدم.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">قيل</a> هذا <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">ديمتري كوركين في واحدة من AppsConf الماضي</a> . <br><br>  الوكالة الدولية للطاقة هي عملية أو سلسلة رسائل تراقب عملية أو سلسلة <strong>رسائل</strong> أخرى.  تتيح لك هذه الآلية مراقبة حالة لوحة المفاتيح وطرق العرض التي تعتمد عليها والإبلاغ عن المشكلات. <br><br>  لتنفيذ هذه الوظيفة ، نقوم بإنشاء جهاز توقيت يقوم مرة واحدة في الثانية بفحص الموقع الصحيح للعرض بأرجل Hayk أو تسجيل ذلك إذا كان خطأ. <br><br><pre style=";text-align:right;direction:rtl"> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Watchdog</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> timer: <span class="hljs-type"><span class="hljs-type">Timer?</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">start</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( )</span></span></span></span> { timer = <span class="hljs-type"><span class="hljs-type">Timer</span></span> ( timeInterval: <span class="hljs-number"><span class="hljs-number">1.0</span></span>, repeats: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, block: { ( timer ) <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.woof ( ) } ) } }</code> </pre> <br>  بالمناسبة ، يمكنك تسجيل ليس فقط النتائج النهائية ، ولكن أيضًا الحسابات الوسيطة. <br><br>  نتيجة لذلك ، أعطت وفرة تسجيل + الوكالة الدولية للطاقة بيانات دقيقة عن المشكلة ، وحالة لوحة المفاتيح وتقليل الوقت لإصلاح الأخطاء ، لكنه لم يفعل الكثير لمساعدة مستخدمي بيتا الذين اضطروا إلى تحمل الأخطاء حتى الإصدار التالي. <br><br>  ولكن ماذا لو كان يمكن تدريب الوكالة الدولية للطاقة ليس فقط للعثور على المشاكل ، ولكن أيضا لإصلاحها؟ <br><br>  في الكود حيث تعطي الوكالة الدولية للطاقة الاستنتاج بأن إحداثيات العرض لا تتلاقى ، نضيف طريقة fixTummyPosition ونضع الإحداثيات تلقائيًا في مكانها. <br><br>  في هذا الخيار ، يتم تجميع الكثير من المعلومات المفيدة في سجلاتي ، ولا يلاحظ المستخدمون أي مشاكل مرئية على الإطلاق.  يبدو ذلك رائعًا ، لكن الآن لا يمكنني معرفة أي مشاكل في لوحة المفاتيح. <br><br>  يساعد في إضافة القدرة على إنشاء ذاكرة تخزين مؤقت للاختبار عند اكتشاف خطأ ما.  بالطبع ، يتم إضافة هذا الرمز تحت التكوين remout. <br><br>  الآن ، بعد الإصدار التالي ، يمكنك تشغيل إنشاء اختبار التعطل ، وإذا واجه المستخدم مشاكل مع لوحة المفاتيح ، تعطل تطبيقه وبفضل السجلات المجمعة ، يمكنك إصلاح الخلل. <br><br><h3 style=";text-align:right;direction:rtl">  لوحة القيادة </h3><br>  الحيلة الأخيرة التي قدمناها هي إرسال الإحصائيات في الوقت الحالي الذي سجل فيه wahtchdog الإحصاءات.  بناءً على البيانات التي تم الحصول عليها ، قمنا برسم عدد الأخطاء المكتشفة وبعد التكرار الأول ، تم تقليل عدد العمليات بأربع مرات.  بالطبع ، لم يكن من الممكن تقليل المشكلات إلى الصفر ، لكن الشكاوى الرئيسية من المستخدمين توقفت. <br><br><blockquote style=";text-align:right;direction:rtl">  سيتم عقد <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">Saint AppsConf في</a> الأسبوع القادم في مدينة سانت بطرسبرغ ، حيث يمكنك توجيه الأسئلة ليس فقط إلى Konstantin ، ولكن أيضًا إلى العديد من المتحدثين في مسار iOS. </blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/ar462515/">https://habr.com/ru/post/ar462515/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ar462505/index.html">لا تخدعني مع البرمجة الوظيفية الخاصة بك</a></li>
<li><a href="../ar462507/index.html">عندما يتم تسليم البريد: مكافحة فقدان إعلامات الدفع في نظام التشغيل iOS</a></li>
<li><a href="../ar462509/index.html">Product Fest - مؤتمر إدارة منتجات تكنولوجيا المعلومات الذي تريد الذهاب إليه</a></li>
<li><a href="../ar462511/index.html">جوجل اللعب الفوري. إعادة بيع مدى الحياة</a></li>
<li><a href="../ar462513/index.html">النقل: الإعداد والاختيار وتطوير الأراضي</a></li>
<li><a href="../ar462519/index.html">كتاب "Microservices. أنماط التطوير وإعادة البناء »</a></li>
<li><a href="../ar462523/index.html">خادم ترخيص LinOTP ثنائي العوامل</a></li>
<li><a href="../ar462525/index.html">3CX تطلق SIP Softphones جديدة لنظام التشغيل iOS و Android مع تشفير الصوت من طرف إلى طرف</a></li>
<li><a href="../ar462527/index.html">كيف تقوم شبكة SincNet العصبية بتخصيص ترددات كبيرة في الصوت من خلال الانتشار الخلفي</a></li>
<li><a href="../ar462529/index.html">ناسا فكرة القمر محطة سيئة وسيئة</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>