<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨‍👩‍👧‍👧 🤽🏻 🦄 Faire le bien, faire le mal: écrire du code maléfique avec Go, partie 2 🤟🏾 🕧 🐕</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Mauvais conseils pour un programmeur Go 



 Dans la première partie de la publication, j'ai expliqué comment devenir un programmeur Go "malveillant"....">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Faire le bien, faire le mal: écrire du code maléfique avec Go, partie 2</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/460911/">  <i><b>Mauvais conseils pour un programmeur Go</b></i> <br><br><img src="https://habrastorage.org/getpro/habr/post_images/8cc/265/872/8cc265872daa29a415c830378896ad61.png" alt="image"><br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Dans la première partie de la publication,</a> j'ai expliqué comment devenir un programmeur Go "malveillant".  Le mal se présente sous plusieurs formes, mais dans la programmation, il réside dans la difficulté délibérée de comprendre et de maintenir le code.  Les mauvais programmes ignorent les moyens de base du langage au profit de techniques qui offrent des avantages à court terme en échange de problèmes à long terme.  Pour rappel, les «mauvaises pratiques» de Go comprennent: <br><br><ul><li>  Forfaits mal nommés et organisés </li><li>  Interfaces mal organisées </li><li>  Passer des pointeurs vers des variables dans des fonctions pour remplir leurs valeurs </li><li>  Utiliser la panique au lieu des erreurs </li><li>  Utilisation des fonctions init et des importations vides pour configurer les dépendances </li><li>  Téléchargez les fichiers de configuration à l'aide des fonctions init </li><li>  Utilisation de frameworks au lieu de bibliothèques </li></ul><br><h3>  Grosse boule de mal </h3><br>  Que se passe-t-il si nous rassemblons toutes nos mauvaises pratiques?  Nous aurions un cadre qui utiliserait de nombreux fichiers de configuration, remplirait les champs de structure à l'aide de pointeurs, définirait des interfaces pour décrire les types publiés, s'appuierait sur du code «magique» et paniquerait en cas de problème. <br><br>  Et je l'ai fait.  Si vous allez sur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">https://github.com/evil-go</a> , vous verrez <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Fall</a> , un framework DI qui vous permet de mettre en œuvre toutes les pratiques «mauvaises» que vous souhaitez.  J'ai soudé Fall avec un tout petit framework web Outboy qui suit les mêmes principes. <br><br>  Vous vous demandez peut-être à quel point ils sont méchants?  Voyons voir.  Je suggère d'aller pour un simple programme Go (écrit en utilisant les meilleures pratiques) qui fournit un point de terminaison http.  Et puis réécrivez-le en utilisant Fall et Outboy. <br><a name="habracut"></a><br><h3>  Meilleures pratiques </h3><br>  Notre programme se trouve dans un seul paquet appelé Greet, qui utilise toutes les fonctions de base pour implémenter notre point de terminaison.  Comme il s'agit d'un exemple, nous utilisons un DAO de travail en mémoire, avec trois champs pour les valeurs que nous retournerons.  Nous aurons également une méthode qui, selon l'entrée, remplace l'appel à notre base de données et renvoie le message d'accueil souhaité. <br><br><pre><code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> greet <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Dao <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { DefaultMessage <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> BobMessage <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> JuliaMessage <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(sdi Dao)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GreetingForName</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(name </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">, error)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> name { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"Bob"</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> sdi.BobMessage, <span class="hljs-literal"><span class="hljs-literal">nil</span></span> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"Julia"</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> sdi.JuliaMessage, <span class="hljs-literal"><span class="hljs-literal">nil</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> sdi.DefaultMessage, <span class="hljs-literal"><span class="hljs-literal">nil</span></span> } }</code> </pre> <br>  Vient ensuite la logique métier.  Pour l'implémenter, nous définissons une structure pour stocker les données de sortie, une interface GreetingFinder pour décrire ce que la logique métier recherche au niveau de la recherche de données, et une structure pour stocker la logique métier elle-même avec un champ pour GreetingFinder.  La logique réelle est simple - elle appelle simplement GreetingFinder et gère toutes les erreurs qui pourraient se produire. <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Response <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { Message <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> GreetingFinder <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> { GreetingForName(name <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>) (<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>, error) } <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Service <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { GreetingFinder GreetingFinder } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ssi Service)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Greeting</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(name </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Response, error)</span></span></span></span> { msg, err := ssi.GreetingFinder.GreetingForName(name) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Response{}, err } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Response{Message: msg}, <span class="hljs-literal"><span class="hljs-literal">nil</span></span> }</code> </pre> <br>  Vient ensuite la couche Web, et pour cette partie, nous définissons l'interface Greeter, qui fournit toute la logique métier dont nous avons besoin, ainsi que la structure contenant le gestionnaire http configuré à l'aide de Greeter.  Ensuite, nous créons une méthode pour implémenter l'interface http.Handler, qui divise la demande http, appelle greeter-a (message d'accueil), traite les erreurs et renvoie les résultats. <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Greeter <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> { Greeting(name <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>) (Response, error) } <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Controller <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { Greeter Greeter } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(mc Controller)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ServeHTTP</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(rw http.ResponseWriter, req *http.Request)</span></span></span></span> { result, err := mc.Greeter.Greeting( req.URL.Query().Get(<span class="hljs-string"><span class="hljs-string">"name"</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { rw.WriteHeader(http.StatusInternalServerError) rw.Write([]<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>(err.Error())) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> } rw.Write([]<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>(result.Message)) }</code> </pre> <br>  Ceci est la fin du paquet d'accueil.  Ensuite, nous verrons comment un «bon» développeur Go écrira main pour utiliser ce package.  Dans le package principal, nous définissons une structure appelée Config, qui contient les propriétés que nous devons exécuter.  La fonction principale fait alors 3 choses. <br><br><ul><li>  Tout d'abord, il appelle la fonction loadProperties, qui utilise une bibliothèque simple ( <a href="">https://github.com/evil-go/good-sample/blob/master/config/config.go</a> ) pour charger les propriétés du fichier de configuration et les place dans notre copie d'une config.  Si le téléchargement de la configuration a échoué, la fonction principale signale une erreur et se ferme. </li><li>  Deuxièmement, la fonction principale lie les composants dans le package d'accueil, en leur attribuant explicitement des valeurs à partir de la configuration et en configurant les dépendances. </li><li>  Troisièmement, il appelle une petite bibliothèque de serveur ( <a href="">https://github.com/evil-go/good-sample/blob/master/server/server.go</a> ) et transmet l'adresse, la méthode HTTP et http.Handler au point de terminaison pour traitement des demandes.  Un appel de bibliothèque lance un service Web.  Et ceci est toute notre application. </li></ul><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> main <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Config <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { DefaultMessage <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> BobMessage <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> JuliaMessage <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> Path <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { c, err := loadProperties() <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { fmt.Println(err) os.Exit(<span class="hljs-number"><span class="hljs-number">1</span></span>) } dao := greet.Dao{ DefaultMessage: c.DefaultMessage, BobMessage: c.BobMessage, JuliaMessage: c.JuliaMessage, } svc := greet.Service{GreetingFinder: dao} controller := greet.Controller{Greeter: svc} err = server.Start(server.Endpoint{c.Path, http.MethodGet, controller}) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { fmt.Println(err) os.Exit(<span class="hljs-number"><span class="hljs-number">1</span></span>) } }</code> </pre> <br>  L'exemple est assez court, mais il montre à quel point le Go cool est écrit;  certaines choses sont ambiguës, mais en général, il est clair ce qui se passe.  Nous collons de petites bibliothèques spécialement conçues pour fonctionner ensemble.  Rien n'est caché;  n'importe qui peut prendre ce code, comprendre comment ses parties sont connectées entre elles et, si nécessaire, les refaire à de nouvelles. <br><br><h3>  Tache noire </h3><br>  Nous allons maintenant considérer la version de Fall et Outboy.  La première chose que nous ferons est de diviser le package de bienvenue en plusieurs packages, chacun contenant une couche d'application.  Voici le package DAO.  Il importe Fall, notre framework DI, et puisque nous sommes «diaboliques» et définissons au contraire les relations avec les interfaces, nous allons définir une interface appelée GreetDao.  Veuillez noter - nous avons supprimé tous les liens vers les erreurs;  si quelque chose ne va pas, on panique.  À ce stade, nous avons déjà un mauvais packaging, de mauvaises interfaces et de mauvais bugs.  Bon début! <br><br>  Nous avons légèrement renommé notre structure à partir d'un bon exemple.  Les champs ont maintenant des balises struct;  ils sont utilisés pour que Fall définisse la valeur enregistrée dans le champ.  Nous avons également une fonction init pour notre package, avec laquelle nous accumulons la «puissance du mal».  Dans la fonction package init, nous appelons Fall deux fois: <br><br><ul><li>  Une fois pour enregistrer un fichier de configuration qui fournit des valeurs pour les balises de structure. </li><li>  Et un autre, pour enregistrer un pointeur sur une instance de la structure.  Fall sera en mesure de remplir ces champs pour nous et de rendre le DAO disponible pour une utilisation par un autre code. </li></ul><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> dao <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ( <span class="hljs-string"><span class="hljs-string">"github.com/evil-go/fall"</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> GreetDao <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> { GreetingForName(name <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> greetDaoImpl <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { DefaultMessage <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> <span class="hljs-string"><span class="hljs-string">`value:"message.default"`</span></span> BobMessage <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> <span class="hljs-string"><span class="hljs-string">`value:"message.bob"`</span></span> JuliaMessage <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> <span class="hljs-string"><span class="hljs-string">`value:"message.julia"`</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(gdi greetDaoImpl)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GreetingForName</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(name </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">string</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> name { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"Bob"</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> gdi.BobMessage <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"Julia"</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> gdi.JuliaMessage <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> gdi.DefaultMessage } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">init</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { fall.RegisterPropertiesFile(<span class="hljs-string"><span class="hljs-string">"dao.properties"</span></span>) fall.Register(&amp;greetDaoImpl{}) }</code> </pre> <br>  Voyons le paquet de services.  Il importe le package DAO car il a besoin d'accéder à l'interface qui y est définie.  Le package de services importe également le package de modèle, que nous n'avons pas encore pris en compte - nous y stockons nos types de données.  Et nous importons Fall, car, comme tous les "bons" frameworks, il pénètre partout.  Nous définissons également une interface de service pour donner accès à la couche web.  Encore une fois, sans gestion d'erreur. <br><br>  La mise en œuvre de notre service dispose désormais d'une balise structurelle avec fil.  Le fil marqué sur le terrain connecte automatiquement sa dépendance lorsque la structure est enregistrée à l'automne.  Dans notre petit exemple, il est clair ce qui sera attribué à ce champ.  Mais dans un programme plus vaste, vous saurez seulement que quelque part cette interface GreetDao est implémentée et enregistrée à l'automne.  Vous ne pouvez pas contrôler le comportement de dépendance. <br><br>  Vient ensuite la méthode de notre service, qui a été légèrement modifiée pour obtenir la structure GreetResponse du package de modèle, et qui supprime toute gestion d'erreur.  Enfin, nous avons une fonction init dans le package qui enregistre une instance de service à l'automne. <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> service <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ( <span class="hljs-string"><span class="hljs-string">"github.com/evil-go/fall"</span></span> <span class="hljs-string"><span class="hljs-string">"github.com/evil-go/evil-sample/dao"</span></span> <span class="hljs-string"><span class="hljs-string">"github.com/evil-go/evil-sample/model"</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> GreetService <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> { Greeting(<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>) model.GreetResponse } <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> greetServiceImpl <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { Dao dao.GreetDao <span class="hljs-string"><span class="hljs-string">`wire:""`</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ssi greetServiceImpl)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Greeting</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(name </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">model</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GreetResponse</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> model.GreetResponse{Message: ssi.Dao.GreetingForName(name)} } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">init</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { fall.Register(&amp;greetServiceImpl{}) }</code> </pre> <br>  Voyons maintenant le package du modèle.  Il n'y a surtout rien à regarder.  On peut voir que le modèle est séparé du code qui le crée, seulement pour diviser le code en couches. <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> model <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> GreetResponse <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { Message <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> }</code> </pre> <br>  Dans le package Web, nous avons une interface Web.  Ici, nous importons Fall et Outboy, et nous importons également le package de services dont dépend le package Web.  Parce que les frameworks ne fonctionnent bien ensemble que lorsqu'ils s'intègrent dans les coulisses, Fall a un code spécial pour s'assurer qu'il fonctionne ensemble et Outboy.  Nous modifions également la structure pour qu'elle devienne le contrôleur de notre application Web.  Elle a deux domaines: <br><br><ul><li>  Le premier est connecté via Fall à l'implémentation de l'interface GreetService à partir du package de services. </li><li>  Le second est le chemin d'accès à notre seul point de terminaison Web.  On lui attribue la valeur du fichier de configuration enregistré dans la fonction init de ce package. </li></ul><br>  Notre gestionnaire http a été renommé GetHello et il est désormais exempt de gestion des erreurs.  Nous avons également la méthode Init (avec une majuscule), qui ne doit pas être confondue avec la fonction init.  Init est une méthode magique qui est appelée pour les structures enregistrées en automne après avoir rempli tous les champs.  Dans Init, nous appelons Outboy pour enregistrer notre contrôleur et son point de terminaison dans le chemin défini à l'aide de Fall.  En regardant le code, vous verrez le chemin et le gestionnaire, mais la méthode HTTP n'est pas spécifiée.  Dans Outboy, le nom de la méthode est utilisé pour déterminer à quelle méthode HTTP le gestionnaire répond.  Puisque notre méthode s'appelle GetHello, elle répond aux requêtes GET.  Si vous ne connaissez pas ces règles, vous ne pourrez pas comprendre à quelles demandes il répond.  C'est vrai, c'est très méchant? <br><br>  Enfin, nous appelons la fonction init pour enregistrer le fichier de configuration et le contrôleur à l'automne. <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> web <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ( <span class="hljs-string"><span class="hljs-string">"github.com/evil-go/fall"</span></span> <span class="hljs-string"><span class="hljs-string">"github.com/evil-go/outboy"</span></span> <span class="hljs-string"><span class="hljs-string">"github.com/evil-go/evil-sample/service"</span></span> <span class="hljs-string"><span class="hljs-string">"net/http"</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> GreetController <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { Service service.GreetService <span class="hljs-string"><span class="hljs-string">`wire:""`</span></span> Path <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> <span class="hljs-string"><span class="hljs-string">`value:"controller.path.hello"`</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(mc GreetController)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetHello</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(rw http.ResponseWriter, req *http.Request)</span></span></span></span> { result := mc.Service.Greeting(req.URL.Query().Get(<span class="hljs-string"><span class="hljs-string">"name"</span></span>)) rw.Write([]<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>(result.Message)) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(mc GreetController)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Init</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { outboy.Register(mc, <span class="hljs-keyword"><span class="hljs-keyword">map</span></span>[<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>]<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>{ <span class="hljs-string"><span class="hljs-string">"GetHello"</span></span>: mc.Path, }) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">init</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { fall.RegisterPropertiesFile(<span class="hljs-string"><span class="hljs-string">"web.properties"</span></span>) fall.Register(&amp;GreetController{}) }</code> </pre> <br>  Il ne reste plus qu'à montrer comment nous exécutons le programme.  Dans le package principal, nous utilisons des importations vides pour enregistrer Outboy et le package Web.  Et la fonction principale appelle fall.Start () pour lancer l'application entière. <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> main <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ( _ <span class="hljs-string"><span class="hljs-string">"github.com/evil-go/evil-sample/web"</span></span> <span class="hljs-string"><span class="hljs-string">"github.com/evil-go/fall"</span></span> _ <span class="hljs-string"><span class="hljs-string">"github.com/evil-go/outboy"</span></span> ) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { fall.Start() }</code> </pre> <br><h3>  Perturbation du tégument </h3><br>  Et le voici, un programme complet écrit en utilisant tous nos outils Go diaboliques.  C'est un cauchemar.  Elle cache comme par magie la façon dont certaines parties du programme s'emboîtent et rend la compréhension de son travail terriblement difficile. <br><br>  Et pourtant, vous devez admettre qu'il y a quelque chose d'attrayant dans l'écriture de code avec Fall et Outboy.  Pour un petit programme, on pourrait même dire que c'est une amélioration.  Voyez comme il est facile de configurer!  Je peux connecter des dépendances avec presque aucun code!  J'ai enregistré un gestionnaire pour la méthode, en utilisant simplement son nom!  Et sans aucune manipulation d'erreur, tout semble si propre! <br><br>  C'est ainsi que le mal fonctionne.  À première vue, c'est vraiment attrayant.  Mais à mesure que votre programme change et se développe, toute cette magie commence seulement à interférer, compliquant la compréhension de ce qui se passe.  Ce n'est que lorsque vous êtes complètement obsédé par le mal que vous regardez en arrière et réalisez que vous êtes pris au piège. <br><br>  Pour les développeurs Java, cela peut sembler familier.  Ces techniques peuvent être trouvées dans de nombreux frameworks Java populaires.  Comme je l'ai mentionné plus tôt, je travaille avec Java depuis plus de 20 ans, à partir de 1.0.2 en 1996.  Dans de nombreux cas, les développeurs Java ont été les premiers à rencontrer des problèmes d'écriture de logiciels d'entreprise à grande échelle à l'ère d'Internet.  Je me souviens de l'époque où les servlets, EJB, Spring et Hibernate sont apparus.  Les décisions prises par les développeurs Java à ce moment-là avaient du sens.  Mais au fil des ans, ces techniques montrent leur âge.  Les langages plus récents, tels que Go, sont conçus pour éliminer les points faibles rencontrés lors de l'utilisation de techniques plus anciennes.  Cependant, lorsque les développeurs Java commencent à apprendre Go et à écrire du code avec eux, ils doivent se rappeler qu'essayer de reproduire des modèles à partir de Java produira de mauvais résultats. <br><br>  Go a été conçu pour une programmation sérieuse - pour des projets qui couvrent des centaines de développeurs et des dizaines d'équipes.  Mais pour que Go puisse le faire, vous devez l'utiliser comme il fonctionne le mieux.  Nous pouvons choisir d'être mauvais ou bons.  Si nous choisissons le mal, nous pouvons encourager les jeunes développeurs Go à changer leur style et leurs techniques avant de comprendre Go.  Ou nous pouvons choisir le bien.  Une partie de notre travail en tant que développeurs Go est d'éduquer les jeunes Gophers (Gophers), pour les aider à comprendre les principes qui sous-tendent nos meilleures pratiques. <br><br>  Le seul inconvénient de suivre la voie du bien est que vous devez chercher une autre façon d'exprimer votre mal intérieur.  <i>Peut-être essayez-vous de rouler à une vitesse de 30 km / h sur la route fédérale?</i> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr460911/">https://habr.com/ru/post/fr460911/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr460899/index.html">26 juillet, Deworkacy - DocOps de Rostelecom</a></li>
<li><a href="../fr460901/index.html">Pourquoi les développeurs seniors ne peuvent pas trouver un emploi</a></li>
<li><a href="../fr460905/index.html">Connaissances SEO minimales pour les entrepreneurs</a></li>
<li><a href="../fr460907/index.html">Utilisation de Liquibase pour gérer la structure de la base de données dans une application Spring Boot. 2e partie</a></li>
<li><a href="../fr460909/index.html">Que mangerons-nous en 2050</a></li>
<li><a href="../fr460913/index.html">Visite photo du musée de l'Institut de physique et d'énergie d'Obninsk</a></li>
<li><a href="../fr460915/index.html">Système de gestion de base de données pratique</a></li>
<li><a href="../fr460923/index.html">Tâche de test Yandex</a></li>
<li><a href="../fr460925/index.html">Jeu en ligne avec de vrais robots RC à Tchernobyl. 2e partie</a></li>
<li><a href="../fr460929/index.html">Atlassian Confluence: extensible en python</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>