<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏾‍🤝‍👩🏻 👩🏽‍🏫 🗜️ Andrew Eun "Leidenschaft für maschinelles Lernen." Übersetzung der Kapitel 36-46 🍉 🖐🏽 👐</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Drei Jahre sind seit der Veröffentlichung der ersten Kapitel von Andrew Ngs Machine Learning Yearning vergangen. Wenn Sie den Hub "Maschinelles Lernen...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Andrew Eun "Leidenschaft für maschinelles Lernen." Übersetzung der Kapitel 36-46</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/485070/">  Drei Jahre sind seit der Veröffentlichung der ersten Kapitel von Andrew Ngs Machine Learning Yearning vergangen.  Wenn Sie den Hub "Maschinelles Lernen" abonniert haben, müssen Sie sich nicht mit dem Autor bekannt machen, und höchstwahrscheinlich haben Sie das Buch selbst bereits vor langer Zeit in der Sprache der Originalquelle gelesen.  Die Übersetzung der ersten Hälfte des Buches ins Russische wurde von <a href="https://habr.com/ru/users/alexey_nichnikov/" class="user_link">alexey_nichnikov vorgenommen</a> und zu diesem Zeitpunkt in einer <a href="https://habr.com/ru/post/419757/">Reihe von Artikeln</a> auf Habré <a href="https://habr.com/ru/post/419757/">veröffentlicht</a> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/4t/87/qr/4t87qrmbsuxfltahjbm9iunonx4.png"></div><br>  Ich präsentiere Ihnen meine Version der Übersetzung der zweiten Hälfte des Buches, nämlich die Kapitel 36-58.  Es ist geplant, die Veröffentlichung in zwei Artikel zu unterteilen.  Außerdem können Sie eine vollständige Übersetzung dieser Kapitel <a href="https://drive.google.com/open%3Fid%3D1SofaOohXwySM_6UM8wnH9J3tBmO6dMGu">im PDF-</a> Format herunterladen. Vielleicht findet jemand dieses Format für das Lesen angenehmer. <br><br>  Der erste Artikel konzentriert sich auf das Training und Testen verschiedener Distributionen sowie auf das Debuggen von Ausgabealgorithmen. <br><a name="habracut"></a><br><h1>  Training und Test auf verschiedenen Distributionen </h1><br><hr><h3>  <font color="#548dd4">Kapitel 36. Wann Sie verschiedene Distributionen trainieren und testen sollten</font> </h3><hr><br>  Benutzer Ihrer Cat Photo-App haben 10.000 Bilder hochgeladen, die Sie manuell als katzenhaltig oder katzenfrei gekennzeichnet haben.  Sie haben auch einen größeren Satz von 200.000 Bildern, die Sie aus dem Internet heruntergeladen haben.  Wie werden Training (Zugset), Validierung (Entwicklungsset) und Testauswahl (Testset) definiert? <br><br>  Da 10.000 Bilder von Benutzern die tatsächliche Wahrscheinlichkeitsverteilung der Daten widerspiegeln, mit denen Sie in Zukunft erfolgreich arbeiten möchten, können Sie diese für Ihre Validierungs- und Testmuster verwenden.  Wenn Sie einen Deep-Learning-Algorithmus trainieren, der die Anzahl der Trainingsbeispiele erfordert, können Sie ihm zusätzliche 200.000 Bilder zum Trainieren aus dem Internet herunterladen.  Somit weisen die Daten in der Validierungs- und Testprobe unterschiedliche Wahrscheinlichkeitsverteilungen auf.  Wie wird sich dies auf das Ergebnis Ihrer Arbeit auswirken? <br><br>  Anstatt unsere Daten in Trainings-, Validierungs- und Testmuster zu unterteilen, können wir alle 210.000 verfügbaren Bilder aufnehmen und sie zufällig in Trainings-, Validierungs- und Testmuster mischen.  In diesem Fall haben alle Daten dieselbe Verteilung.  Die Verwendung dieser Methode wird jedoch nicht empfohlen, da ungefähr 97,6% (205.000 / 210.000) Ihrer Validierungs- und Testmuster aus Bildern bestehen, die aus dem Internet heruntergeladen wurden und nicht die tatsächliche Verteilung widerspiegeln, auf der Sie erfolgreich sein möchten. <br><br>  Empfehlung zur Definition von Validierungs- und Prüfmustern: <br><br><ul><li>  Wählen Sie Validierungs- und Testmuster aus, die die Daten widerspiegeln, die Sie in Zukunft erwarten und mit denen Sie erfolgreich arbeiten möchten. </li></ul><br>  Die meisten akademischen Veröffentlichungen zum maschinellen Lernen legen nahe, dass die Trainings-, Validierungs- und Teststichproben alle die gleiche Verteilung aufweisen.  <sup>1</sup> Zu Beginn des maschinellen Lernens waren die Daten knapp.  Normalerweise hatten wir nur einen Datensatz mit einer gewissen Wahrscheinlichkeitsverteilung.  Aus diesem Grund haben wir den gesamten Satz zufällig in Trainings-, Validierungs- und Teststichproben aufgeteilt, unter der Annahme, dass alle Daten aus derselben Quelle stammten, die normalerweise der Realität entsprach. <br><blockquote>  <sup>1</sup> Es gibt eine Reihe von wissenschaftlichen Studien zum Training und Testen von Modellen für verschiedene Distributionen.  Beispiele hierfür sind Domain Adaptation, Transfer Learning und Multitask Learning.  Trotzdem gibt es immer noch eine große Lücke zwischen Theorie und Praxis.  Wenn Sie ein Modell auf Datensatz A trainieren und auf Datensatz B testen, was sehr unterschiedlich ist, kann das Glück einen großen Einfluss auf die Leistung Ihres Algorithmus haben.  (Unter „Glück“ versteht man hier die manuelle Auswahl von Attributen durch einen Forscher für eine bestimmte Aufgabe sowie andere Faktoren, die wir noch nicht verstehen.) Dies erschwert die Durchführung einer systematischen akademischen Studie zum Training und Testen verschiedener Distributionen. </blockquote><br>  Aber im Zeitalter von Big Data haben wir jetzt Zugang zu riesigen Trainingssets, wie z. B. Bildern mit Katzen aus dem Internet.  Auch wenn die Verteilung des Trainingsmusters von der Verteilung der Validierungs- und Testmuster abweicht, möchten wir sie dennoch für das Training verwenden, da dies viele zusätzliche Informationen liefern kann. <br><br>  In dem Beispiel mit einem Katzendetektor konnten nur 5.000 Bilder in die Validierungs- und Testmuster eingefügt werden, anstatt alle 10.000 von Benutzern hochgeladenen Bilder in die Validierungs- und Testmuster einzufügen.  Und die restlichen 5.000 Beispiele können wir in das Trainingsset aufnehmen.  Die Trainingsstichprobe wird daher aus 205.000 Beispielen bestehen und Daten mit der gleichen Verteilung wie in den Validierungs- und Teststichproben sowie 200.000 Internetbilder enthalten.  Im nächsten Kapitel werden wir diskutieren, warum diese Methode nützlich ist. <br><br>  Schauen wir uns ein zweites Beispiel an.  Angenommen, Sie erstellen ein Spracherkennungssystem zum Transkribieren von Adressen für die Navigator-Sprachanwendung.  Sie haben 20.000 Beispiele, in denen der Benutzer jeweils eine Adresse angibt.  Sie haben aber auch 500.000 andere Audioaufnahmen, in denen Benutzer über kostenlose Themen sprechen.  Sie können 10.000 Beispiele mit Adressen für Validierungs- und Testbeispiele und die verbleibenden 10.000 Beispiele sowie weitere 500.000 Beispiele für den Schulungssatz verwenden. <br><br>  Wir gehen weiterhin davon aus, dass unsere Validierungs- und Testmusterdaten dieselbe Verteilung aufweisen.  Es ist jedoch wichtig zu verstehen und sich daran zu erinnern, dass unterschiedliche Verteilungen in den Trainings- und Validierungs- / Testmustern zu besonderen Problemen führen. <br><br><hr><h3>  <font color="#548dd4">Kapitel 37. So entscheiden Sie, ob Sie alle Ihre Daten oder nur einen Teil davon verwenden möchten</font> </h3><hr><br>  Angenommen, das Trainingsmuster Ihres Katzendetektors enthält 10.000 vom Benutzer hochgeladene Bilder.  Lassen Sie diese Daten dieselbe Verteilung wie in den Validierungs- und Testmustern haben, und für eine solche Verteilung möchten Sie das maximale Ergebnis erzielen.  Sie haben auch zusätzliche 20.000 Bilder aus dem Internet heruntergeladen.  Müssen alle 20.000 + 10.000 = 30.000 Bilder in den Trainingssatz aufgenommen werden, oder ist es besser, 20.000 Internetbilder zu löschen, um Fehler in Ihren Lernalgorithmus einzufügen? <br><br>  Bei Verwendung früherer Generationen von Lernalgorithmen (z. B. eines manuell erstellten Computer-Vision-Algorithmus, gefolgt von einem einfachen linearen Klassifikator) bestand das reale Risiko, dass die Kombination von Daten aus beiden Quellen die Ergebnisse beeinträchtigen könnte.  Einige Techniker warnen Sie daher davor, 20.000 Online-Bilder aufzunehmen. <br><br>  In der modernen Ära leistungsfähiger, flexibler Lernalgorithmen wie großer neuronaler Netze wurde dieses Risiko jedoch erheblich reduziert.  Wenn Sie es sich leisten können, ein neuronales Netzwerk mit einer ausreichend großen Anzahl ausgeblendeter Ebenen aufzubauen, können Sie Ihrem Trainingssatz sicher 20.000 Internetbilder hinzufügen.  Durch das Hinzufügen von Bildern wird Ihr Geschäftsergebnis wahrscheinlich verbessert. <br><br>  Diese Beobachtung basiert auf der Tatsache, dass es eine Entsprechung <b>x</b> → <b>y gibt</b> , die für beide Datentypen gut funktioniert.  Mit anderen Worten, es gibt eine Art System, das, nachdem es entweder ein Internet-Bild oder ein Bild von einer mobilen Anwendung empfangen hat, ein Etikett zuverlässig vorhersagt, ohne die Quelle des Bildes zu kennen. <br><br>  Das Hinzufügen von 20.000 zusätzlichen Internetbildern hat folgende Auswirkungen: <br><br><ol><li>  Dies gibt Ihrem neuronalen Netzwerk mehr Beispiele dafür, wie Katzen aussehen / nicht aussehen.  Dies ist nützlich, da Webbilder und Bilder, die von Benutzern einer mobilen Anwendung hochgeladen wurden, einige Ähnlichkeiten aufweisen.  Ihr neuronales Netzwerk kann einen Teil des Wissens aus Online-Bildern auf Bilder aus einer mobilen Anwendung anwenden. </li><li>  Dies zwingt das neuronale Netzwerk, einen Teil seiner Ressourcen für das Erkennen von Eigenschaften zu verwenden, die für Internetbilder spezifisch sind (z. B. höhere Auflösung, verschiedene Entwurfsmethoden usw.). Teil der repräsentativen Fähigkeiten des neuronalen Netzes.  Daher gibt es weniger Möglichkeiten zum Erkennen von Daten, die von einer mobilen Anwendung empfangen werden, und dies sollte Sie wirklich beunruhigen.  Theoretisch kann dies die Leistung Ihres Algorithmus beeinträchtigen. </li></ol><br>  Um den zweiten Effekt mit anderen Worten zu erklären, können wir uns einer fiktiven Figur zuwenden, Sherlock Holmes, die sagt, dass Ihr Gehirn wie ein Dachboden aussieht, auf dem nur wenig Platz zur Verfügung steht.  Er sagt: „Mit jedem Wissen vergisst du, was du vorher gewusst hast.  Daher ist es äußerst wichtig, nicht zuzulassen, dass unnütze Fakten nützliche ersetzen. “  <sup>2</sup> <br><blockquote>  <sup>2</sup> "Etüde in Scharlach", Arthutre Conan Doyle, 1887 </blockquote><br>  Glücklicherweise ist dieses oben beschriebene "Verdrängen" kein ernstes Problem, wenn Sie über die Rechenleistung verfügen, die zum Aufbau eines ausreichend großen neuronalen Netzwerks, dh eines "ausreichend großen Dachbodens", erforderlich ist.  Sie haben genügend Schulungsmöglichkeiten sowohl für Internetbilder als auch für Bilder aus einer mobilen Anwendung, während beide Datentypen nicht um die Erkennungsfähigkeit konkurrieren.  Das "Gehirn" Ihres Algorithmus ist groß genug, damit Sie sich keine Sorgen machen müssen, dass Sie plötzlich nicht mehr genug "Platz auf dem Dachboden" haben. <br><br>  Wenn Sie jedoch nicht über ein ausreichend großes neuronales Netzwerk (oder einen anderen sehr flexiblen Lernalgorithmus) verfügen, sollten Sie Ihren Trainingsdaten, die Ihrer Validierung und Ihrem Testmuster entsprechen, mehr Aufmerksamkeit widmen. <br><br>  Wenn Sie der Meinung sind, dass Sie Daten haben, die keinen Nutzen bringen, sollten Sie diese einfach ausschließen, um die Berechnungen zu beschleunigen.  Angenommen, Ihre Validierungs- und Testmuster enthalten hauptsächlich zufällige Fotos von Personen, Orten, Zeichen und Zeigern sowie von Tieren.  Angenommen, Sie haben auch eine große Sammlung gescannter historischer Dokumente: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/lh/ct/fz/lhctfzvvbuqngsuaz-uk_d-nfyu.png"></div><br><br>  Diese Dokumente enthalten nichts wie eine Katze.  Sie unterscheiden sich auch grundlegend von den Daten aus Ihren Validierungs- und Testmustern.  Es ist nicht sinnvoll, diese Daten als negative Beispiele zu verwenden, da in diesem Fall die im ersten Effekt beschriebenen Vorteile zu vernachlässigen sind.  Basierend auf diesen Daten kann Ihr neuronales Netzwerk kaum etwas herausfinden, das für Ihre Validierung und Testprobe relevant sein könnte.  Das Einbeziehen dieser Beispiele führt zu einem Verlust von Rechenressourcen und einer Abnahme der Repräsentationsfähigkeit des neuronalen Netzwerks. <br><br><hr><h3>  <font color="#548dd4">Kapitel 38. Entscheiden, ob widersprüchliche Daten eingeschlossen werden sollen</font> </h3><hr><br>  Angenommen, Sie möchten lernen, wie Sie die Immobilienpreise in New York prognostizieren.  Anhand der Größe des Hauses (Eingabe <b>x</b> ) möchten Sie den Preis vorhersagen (Zielbezeichnung <b>y</b> ). <br><br>  Die Immobilienpreise in New York sind sehr hoch.  Angenommen, Sie haben einen zweiten Datensatz - Immobilienpreise in Detroit, Michigan, wo die Immobilienpreise viel niedriger sind.  Sollte ich diese Daten in mein Trainingsset aufnehmen? <br><br>  Bei gleicher Größe <b>x</b> ist der Preis eines <b>y-</b> Hauses sehr unterschiedlich, je nachdem, ob es sich in New York oder in Detroit befindet.  Wenn es Ihnen nur darum geht, die Immobilienpreise in New York vorherzusagen, wird Ihre Produktivität beeinträchtigt, wenn Sie die beiden Datensätze kombinieren.  In diesem Fall ist es besser, keine widersprüchlichen Daten aus dem Detroit-Satz zu verwenden.  <sup>3</sup> <br><blockquote>  <sup>3</sup> Es gibt einen Weg, das Problem der Inkompatibilität von Detroit-Daten mit New York-Daten zu lösen, nämlich jedem Trainingsbeispiel ein zusätzliches Merkmal hinzuzufügen, d.h.  Ortsangabe.  Mit dem Eingabewert von <b>x</b> , der nun die Stadt angibt, ist der Zielwert von <b>y</b> nun eindeutig bestimmt.  In der Praxis sehe ich es jedoch immer noch nicht oft. </blockquote><br>  Inwiefern unterscheidet sich dieses Beispiel mit Wohnungen in New York und Detroit von unserem Beispiel mit Internetbildern von Katzen und Bildern aus einer mobilen Anwendung? <br><br>  Das Beispiel mit den Bildern von Katzen unterscheidet sich darin, dass Sie anhand des Eingabebilds <b>x</b> das Etikett <b>y</b> zuverlässig vorhersagen können, das angibt, ob sich eine Katze darauf befindet, ohne zu wissen, ob wir das Bild aus dem Internet oder von einer mobilen Anwendung erhalten haben.  Das heißt  es gibt eine Funktion f (x), die die Entsprechung der Eingabe <b>x</b> zur Zielausgabe <b>y</b> zuverlässig widerspiegelt, ohne auch nur die Herkunftsquelle von <b>x zu kennen</b> .  Die Aufgabe des Erkennens von Internetbildern "entspricht" somit der Aufgabe des Erkennens von Bildern aus einer mobilen Anwendung.  Dies bedeutet, dass es ein kleines Minus (mit Ausnahme der Berechnungskosten) gab, wenn alle Daten einbezogen wurden, und ein mögliches signifikantes Plus.  Im Gegensatz zu dem Beispiel mit widersprüchlichen Daten aus New York und Detroit, in dem bei gleichem Eingabewert <b>x</b> (Hausgröße) der Preis je nach Stadt, in der sich dieses Haus befindet, sehr unterschiedlich ist. <br><br><hr><h3>  <font color="#548dd4">Kapitel 39. Wiegen von Daten</font> </h3><hr><br>  Angenommen, Sie haben 200.000 Online-Bilder und 5.000 Bilder von Benutzern Ihrer mobilen Anwendung.  Zwischen den Größen dieser Datensätze besteht ein Verhältnis von 40: 1.  Solange Sie ein riesiges neuronales Netzwerk aufbauen und es mit allen verfügbaren 205.000 Beispielen lang genug trainieren, ist theoretisch nichts falsch daran, dass der Algorithmus sowohl für Internetbilder als auch für mobile Bilder gut funktioniert. <br><br>  In der Praxis müssen Sie mit 40-mal mehr Internet-Bildern als mit Bildern einer mobilen Anwendung möglicherweise 40-mal mehr Rechenressourcen aufwenden, als wenn Sie ein Netzwerk für nur 5.000 Bilder trainiert hätten. <br><br>  Wenn Sie nicht über große Computerressourcen verfügen, können Sie Internet-Images als Kompromiss viel weniger Gewicht einräumen. <br><br>  Angenommen, Ihr Optimierungsziel ist der quadratische Fehler (dies ist keine gute Wahl für das Klassifizierungsproblem, vereinfacht jedoch unsere Erklärung).  Daher versucht Ihr Lernalgorithmus Folgendes zu optimieren: <br><p><math> </math> $$ zeige $$ \ min_θ \ sum _ {(x, y) ∈MobileImg} (h_θ (x) -y) ^ 2 + \ sum _ {(x, y) ∈InternetImg} (h_θ (x) -y) ^ 2 an $$ display $$ </p><br>  Der erste Wert oben ist der Gesamtfehler für 5.000 mobile Bilder und der zweite Wert ist der Gesamtfehler für 200.000 Internetbilder.  Stattdessen können Sie mit einem zusätzlichen Parameter optimieren <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-74"><span class="MJXp-mtext" id="MJXp-Span-75">&nbsp;</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-76">b</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-77">e</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-78">t</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-79">a</span></span></span><span class="MathJax_SVG MathJax_SVG_Processed" id="MathJax-Element-2-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="4.731ex" height="2.057ex" viewBox="0 -780.1 2037 885.9" role="img" focusable="false" style="vertical-align: -0.246ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/485070/&amp;xid=25657,15700019,15700186,15700191,15700256,15700259,15700262,15700265,15700271&amp;usg=ALkJrhjvwEoWhZlqrHiOOpUQiUCFSP7sYg#MJMATHI-62" x="250" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/485070/&amp;xid=25657,15700019,15700186,15700191,15700256,15700259,15700262,15700265,15700271&amp;usg=ALkJrhjvwEoWhZlqrHiOOpUQiUCFSP7sYg#MJMATHI-65" x="679" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/485070/&amp;xid=25657,15700019,15700186,15700191,15700256,15700259,15700262,15700265,15700271&amp;usg=ALkJrhjvwEoWhZlqrHiOOpUQiUCFSP7sYg#MJMATHI-74" x="1146" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/485070/&amp;xid=25657,15700019,15700186,15700191,15700256,15700259,15700262,15700265,15700271&amp;usg=ALkJrhjvwEoWhZlqrHiOOpUQiUCFSP7sYg#MJMATHI-61" x="1507" y="0"></use></g></svg></span><script type="math/tex" id="MathJax-Element-2"> \ beta </script>  : <br><p><math> </math> $$ display $$ \ min_θ \ sum _ {(x, y) ∈MobileImg} (h_θ (x) -y) ^ 2 + \ beta \ sum _ {(x, y) ∈InternetImg} (h_θ (x) -y) ^ 2 $$ Anzeige $$ </p><br>  Wenn Sie installieren <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-151"><span class="MJXp-mtext" id="MJXp-Span-152">&nbsp;</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-153">b</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-154">e</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-155">t</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-156">a</span></span></span><span class="MathJax_SVG MathJax_SVG_Processed" id="MathJax-Element-4-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="4.731ex" height="2.057ex" viewBox="0 -780.1 2037 885.9" role="img" focusable="false" style="vertical-align: -0.246ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/485070/&amp;xid=25657,15700019,15700186,15700191,15700256,15700259,15700262,15700265,15700271&amp;usg=ALkJrhjvwEoWhZlqrHiOOpUQiUCFSP7sYg#MJMATHI-62" x="250" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/485070/&amp;xid=25657,15700019,15700186,15700191,15700256,15700259,15700262,15700265,15700271&amp;usg=ALkJrhjvwEoWhZlqrHiOOpUQiUCFSP7sYg#MJMATHI-65" x="679" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/485070/&amp;xid=25657,15700019,15700186,15700191,15700256,15700259,15700262,15700265,15700271&amp;usg=ALkJrhjvwEoWhZlqrHiOOpUQiUCFSP7sYg#MJMATHI-74" x="1146" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/485070/&amp;xid=25657,15700019,15700186,15700191,15700256,15700259,15700262,15700265,15700271&amp;usg=ALkJrhjvwEoWhZlqrHiOOpUQiUCFSP7sYg#MJMATHI-61" x="1507" y="0"></use></g></svg></span><script type="math/tex" id="MathJax-Element-4"> \ beta </script>  = 1/40, der Algorithmus wird 5.000 mobilen Bildern und 200.000 Internetbildern das gleiche Gewicht geben.  Sie können den Parameter auch einstellen <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-157"><span class="MJXp-mtext" id="MJXp-Span-158">&nbsp;</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-159">b</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-160">e</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-161">t</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-162">a</span></span></span><span class="MathJax_SVG MathJax_SVG_Processed" id="MathJax-Element-5-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="4.731ex" height="2.057ex" viewBox="0 -780.1 2037 885.9" role="img" focusable="false" style="vertical-align: -0.246ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/485070/&amp;xid=25657,15700019,15700186,15700191,15700256,15700259,15700262,15700265,15700271&amp;usg=ALkJrhjvwEoWhZlqrHiOOpUQiUCFSP7sYg#MJMATHI-62" x="250" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/485070/&amp;xid=25657,15700019,15700186,15700191,15700256,15700259,15700262,15700265,15700271&amp;usg=ALkJrhjvwEoWhZlqrHiOOpUQiUCFSP7sYg#MJMATHI-65" x="679" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/485070/&amp;xid=25657,15700019,15700186,15700191,15700256,15700259,15700262,15700265,15700271&amp;usg=ALkJrhjvwEoWhZlqrHiOOpUQiUCFSP7sYg#MJMATHI-74" x="1146" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/485070/&amp;xid=25657,15700019,15700186,15700191,15700256,15700259,15700262,15700265,15700271&amp;usg=ALkJrhjvwEoWhZlqrHiOOpUQiUCFSP7sYg#MJMATHI-61" x="1507" y="0"></use></g></svg></span><script type="math/tex" id="MathJax-Element-5"> \ beta </script>  andere Werte, möglicherweise Anpassung an die Validierungsprobe. <br><br>  Wenn Sie Internet-Bildern eine geringere Gewichtung zuweisen, müssen Sie kein massives neuronales Netzwerk erstellen, um sicherzustellen, dass der Algorithmus beide Aufgabentypen gut bewältigt.  Diese Methode der „Neugewichtung“ ist nur erforderlich, wenn Sie den Verdacht haben, dass zusätzliche Daten (Internetbilder) eine ganz andere Verteilung aufweisen als Daten in Validierungs- und Testmustern, oder wenn wesentlich mehr zusätzliche Daten vorliegen als Daten, die mit derselben Verteilung erhalten wurden wie in den Validierungs- und Testmustern (mobile Bilder). <br><br><hr><h3>  <font color="#548dd4">Kapitel 40. Verallgemeinerung der Trainingsstichprobe zu einer Validierungsstichprobe</font> </h3><hr><br>  Angenommen, Sie wenden ML in einer Situation an, in der sich die Trainingsstichprobe von der Validierungs- / Teststichprobe unterscheidet.  Angenommen, ein Schulungsbeispiel enthält Internetbilder und mobile Bilder, und Validierungs- / Testbeispiele enthalten nur mobile Bilder.  Der Algorithmus funktioniert jedoch nicht sehr gut: Die Validierungs- / Teststichprobe weist einen viel höheren Fehler auf, als wir möchten.  Hier sind einige Gründe, warum dies möglicherweise nicht der Fall ist: <br><br><ol><li>  Der Algorithmus funktioniert mit dem Trainingssatz nicht sehr gut.  Dies ist ein Problem einer hohen (vermeidbaren) Vorspannung der Verteilung der Trainingsprobe. </li><li>  Der Algorithmus funktioniert auf dem Trainingssatz gut, verallgemeinert sich jedoch schlecht auf neue (zuvor nicht gezeigte) Daten, die mit der gleichen Verteilung wie im Trainingssatz aufgenommen wurden.  Dies ist eine hohe Varianz. </li><li>  Der Algorithmus verallgemeinert sich gut auf neue (zuvor nicht gezeigte) Daten, die mit derselben Verteilung wie in der Trainingsprobe aufgenommen wurden, jedoch nicht auf Daten aus der Validierungs- / Testprobe.  Wir nennen dieses Problem Dateninkongruenz aufgrund der Tatsache, dass die Daten aus der Trainingsstichprobe schlecht mit den Daten aus den Validierungs- / Teststichproben korrelieren. </li></ol><br>  Nehmen wir zum Beispiel an, dass Menschen bei der Identifizierung von Katzen ein nahezu perfektes Ergebnis erzielen.  Und Ihr Algorithmus hat erreicht: <br><br><ul><li>  1% der Fehler in der Trainingsstichprobe </li><li>  1,5% Fehler bei neuen (bisher nicht für den Algorithmus angezeigten) Daten mit derselben Verteilung wie das Trainingsmuster </li><li>  10% der Fehler in der Validierungsprobe </li></ul><br>  In diesem Fall liegt definitiv ein Dateninkongruenzproblem vor.  Um dies zu aktivieren, können Sie versuchen, das Schulungsbeispiel dem Validierungs- / Testbeispiel ähnlicher zu machen.  Wir werden später einige Techniken dieser Technik diskutieren. <br><br>  Um das Ausmaß zu diagnostizieren, in dem der Algorithmus unter jedem der oben beschriebenen Probleme 1-3 leidet, ist es nützlich, einen anderen Datensatz zu haben.  Anstatt dem Algorithmus alle für das Training verfügbaren Daten zur Verfügung zu stellen, können Sie diese in zwei Teile aufteilen: das tatsächliche Trainingsmuster, auf dem der Algorithmus trainiert wird, und einen separaten Satz, den wir als Trainingsvalidierung bezeichnen („trainig dev“ -Satz) ), die wir im Training nicht verwenden werden. <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Sie haben also 4 Datensätze: </font></font><br><br><ul><li> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Trainingsset (Trainingsset). </font><font style="vertical-align: inherit;">Dies sind die Daten, auf denen der Algorithmus trainiert wird (z. B. Internetbilder + Bilder von einer mobilen Anwendung). </font><font style="vertical-align: inherit;">Diese Daten müssen nicht mit derselben Verteilung erfasst werden, auf deren Ergebnis wir uns letztendlich konzentrieren (Validierungs- / Testmuster).</font></font></li><li> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Schulungs- und Validierungsbeispiel</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> („Training Dev“ -Set). </font><font style="vertical-align: inherit;">Diese Daten werden mit der gleichen Verteilung wie im Trainingsbeispiel erfasst (z. B. Internetbilder + Bilder einer mobilen Anwendung). </font><font style="vertical-align: inherit;">Dieser Satz ist normalerweise kleiner als der Trainingssatz und sollte groß genug sein, um den Fortschritt unseres Trainingsalgorithmus zu bewerten und zu verfolgen.</font></font></li><li> <b> </b> (dev set).       ,           ,         ( ,    ). </li><li> <b> </b> (test set).       ,      ( ,    ). </li></ul><br>         : <br><br><ul><li>   (training error),     . </li><li>      ,    ,     ,    - . </li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Die Effizienz des Algorithmus als Ganzes für das zu lösende Problem durch Bewertung anhand eines Validierungs- und (oder) Testmusters. </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Die meisten Empfehlungen, die in den Kapiteln 5-7 dieses Handbuchs zur Auswahl der Größe der Validierungsstichprobe gegeben wurden, gelten auch für die Schulungs- und Validierungsstichprobe. </font></font><br><br><hr><h3> <font color="#548dd4"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kapitel 41. Bestimmung der Abweichung, Varianz und des Datenfehlanpassungsfehlers</font></font></font> </h3><hr><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nehmen wir an, dass Menschen bei der Erkennung von Katzen eine nahezu perfekte Effizienz (Fehler tasks0%) erreichen und die optimale Fehlerquote bei etwa 0% liegt. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Angenommen, Sie haben:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 1% der Fehler in der Trainingsstichprobe </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 5% Fehler in der Trainings- und Validierungsprobe </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 5% der Fehler in der Validierungsstichprobe </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Was sagt uns das? </font><font style="vertical-align: inherit;">Sie wissen, dass Sie eine hohe Varianz haben. </font><font style="vertical-align: inherit;">Mit den zuvor beschriebenen Dispersionsreduktionsmethoden sollten Sie einige Fortschritte erzielen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Angenommen, Ihr Algorithmus hat erreicht:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 10% der Fehler im Trainingsmuster </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 11% der Fehler in der Schulungs- und Validierungsstichprobe </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 12% der Fehler in der Validierungsstichprobe </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Dies deutet darauf hin, dass Sie eine hohe vermeidbare Tendenz im Trainingssatz haben. </font></font> Das heißt<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der Algorithmus liefert schlechte Ergebnisse auf dem Trainingssatz, aber die Methoden zur Reduzierung des Versatzes sollten helfen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In den beiden obigen Beispielen leidet der Algorithmus nur an einer hohen Vorspannung (vermeidbare Vorspannung) oder nur an einer hohen Streuung (Varianz). </font><font style="vertical-align: inherit;">Der Algorithmus kann auch unter jeder Kombination von hoher Vorspannung, hoher Streuung und Dateninkonsistenz leiden. </font><font style="vertical-align: inherit;">Zum Beispiel:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 10% der Fehler im Trainingsmuster </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 11% der Fehler in der Schulungs- und Validierungsstichprobe </font></font></li><li> 20%     </li></ul><br>       (avoidable bias)     (data mismatch)              . <br><br> ,   ,        ,     : <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/m2/w0/iv/m2w0iviqecnkhlm2_icdxlzhzfy.png"></div><br>      ,   ,    X      (    ).   Y      :  ,   ,    ,    ,     .        ,      . <br><br>            :         («       »),  -            .     ,       ( )        ,       .          .           ,        ( A  ) . <br><br> ,         ,    ,      ,      . <br><br><hr><h3> <font color="#548dd4"> 42.    </font> </h3><hr><br> ,     ,          - .        :      .    ? <br><br>   : (i)  ,          ; (ii)     ,       ,       .  <sup>4</sup> <br><blockquote> <sup>4</sup>    « » (domain adaptation) —            .              ,  ,    . </blockquote><br> , ,           :    100    ,    .  ,     ,           ,           .           .          ,  ,   .            ,      . <br><br>     -   ,   ,           .      «»    ,    «»   - ,        ,     «»  .                ,    ,    / .       «»        / . <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Leider gibt es in dieser Angelegenheit keine Garantien. </font><font style="vertical-align: inherit;">Wenn Sie beispielsweise nicht die Möglichkeit haben, mehr Trainingsdaten zu erhalten, die besser mit den Validierungsbeispieldaten übereinstimmen, haben Sie möglicherweise keinen klaren Weg zur Verbesserung der Effizienz.</font></font><br><br><hr><h3> <font color="#548dd4"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kapitel 43. Künstliche Daten synthetisieren</font></font></font> </h3><hr><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ihr Spracherkennungssystem benötigt mehr Daten, die so klingen, als würden die Audioaufnahmen dieser Beispiele in einem Auto erstellt. </font><font style="vertical-align: inherit;">Anstatt viele Daten während der Fahrt zu sammeln, könnte es einen einfacheren Weg geben, diese Daten zu erhalten: indem Sie sie künstlich generieren.</font></font><br><br> ,       / .        . ,       ,     ,    .        «»    / ,   ,   ,      ,    .   ,      ,   ,       . <br><br>  ,   ,         ,     .         .  ,           ,   ,  ,     ,       .     -           ,           . <br><br>   ,        :     ,    ,   ,     . , ,     1000      ,   1   .             ,    1000   ,     ,            .  ,   , ,      —         ,  ,      1   .  ,       ,      . <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Angenommen, Sie haben 1000 Stunden Autolärm, aber nur 10 verschiedene Autos wurden verwendet, um sie aufzuzeichnen. In diesem Fall kann der Algorithmus die Aufzeichnungen dieser 10 Autos erneut trainieren und eine schlechte Leistung zeigen, wenn Aufzeichnungen von einem anderen Auto getestet werden. Leider sind diese Probleme schwer zu erkennen.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/7v/_5/wv/7v_5wvoffrpw4pj34pdpcbueflg.png"></div><br>    , ,        . ,    ,  ,     ,     .    ,         .       ,   (       ), ,    .     20  .   3D-   ,      , , ,   ,           , ,   -.  Das heißt       .         ,     ,      /  —    20          .  ,   100,000        20 ,        ,        / ,       . <br><br>   , ,       .      ,  <br>         ,   ,          20  ,        1   .       . <br><br>           ,       ,            .       ,          ,  . <br><br><h1>    </h1><hr><h3> <font color="#548dd4"> 44.   </font> </h3><hr><br> ,     .   ,     A,     Score <sub>A</sub> (S)      S. ,     Score <sub>A</sub> (S) = P(S|A), ..  ,       S, ,       A. <br><br>    Score <sub>A</sub> (S),        ,     : <br><p></p><p><math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math MJXp-display" id="MJXp-Span-163"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-164">O</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-165">u</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-166">t</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-167">p</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-168">u</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-169">t</span><span class="MJXp-mo" id="MJXp-Span-170" style="margin-left: 0.333em; margin-right: 0.333em;">=</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-171">a</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-172">r</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-173">g</span><span class="MJXp-munderover" id="MJXp-Span-174"><span class=""><span class="MJXp-mo" id="MJXp-Span-175" style="margin-left: 0.333em; margin-right: 0.333em;">max</span></span><span class=" MJXp-script"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-176" style="margin-left: 0px;">S</span></span></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-177">S</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-178">c</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-179">o</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-180">r</span><span class="MJXp-msubsup" id="MJXp-Span-181"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-182" style="margin-right: 0.05em;">e</span><span class="MJXp-mrow MJXp-script" id="MJXp-Span-183" style="vertical-align: -0.4em;"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-184">A</span></span></span><span class="MJXp-mo" id="MJXp-Span-185" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-186">S</span><span class="MJXp-mo" id="MJXp-Span-187" style="margin-left: 0em; margin-right: 0em;">)</span></span></span><div class="MathJax_SVG_Display MathJax_SVG_Processing"><span class="MathJax_SVG" id="MathJax-Element-6-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span></div><script type="math/tex;mode=display" id="MathJax-Element-6">Output = arg \max_S Score_{A}(S)</script></p><br>   «arg max»   ?     50,000 ,     (50,000) <sup>N</sup>    N.   ,   . <br><br> ,      ,     S,   ()  Score <sub>A</sub> (S).       « » (beam search),    <b>K</b>     . (            .)       S,    Score <sub>A</sub> (S). <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Stellen Sie sich vor, jemand sagte auf einem Tonband: "Ich liebe maschinelles Lernen." </font><font style="vertical-align: inherit;">Anstelle der korrekten Transkription gibt Ihr System jedoch das falsche "Ich liebe Roboter" aus. </font><font style="vertical-align: inherit;">Es gibt zwei mögliche Gründe für das, was schief gehen könnte:</font></font><br><br><ol><li> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Probleme im Suchalgorithmus</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Der Strahlensuchalgorithmus hat fälschlicherweise den Wert von S gefunden, wodurch die Bewertung </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (S) </font><font style="vertical-align: inherit;">maximiert wird </font><font style="vertical-align: inherit;">.</font></font></li><li> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ein objektives Problem mit der Bewertungsfunktion</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Unsere Schätzung von Score </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (S) = P (S | A) war nicht genau. </font><font style="vertical-align: inherit;">Insbesondere die ausgewählte Punktzahl </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (S) erlaubte es nicht, die korrekte Transkription "Ich liebe maschinelles Lernen" korrekt zu erkennen.</font></font></li></ol><br>           ,   -     .          ,         ,    Score <sub>A</sub> (S). <br><br>    ,         ,          Score <sub>A</sub> (S).         ,       .            ? <br><br>  S <sub>out</sub>    («  »).  S*    («   »).           ,       (Optimization Verification test):     Score <sub>A</sub> (S*)   Score <sub>A</sub> (S <sub>out</sub> ).  ,        .   : <br><br><ol><li> Score <sub>A</sub> (S*) &gt; Score <sub>A</sub> (S <sub>out</sub> ), ..         (). <br><br>               S*.          S <sub>out</sub> .    ,         S,    Score <sub>A</sub> (S).            ,       . ,           (beam search). </li><li> Score <sub>A</sub> (S*) ≤ Score <sub>A</sub> (S <sub>out</sub> ), ..          (). <br><br>     ,     Score <sub>A</sub> (.):         S <sub>out</sub> .         .              Score <sub>A</sub> (S)     S. </li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Unsere Diskussion ging auf ein einziges Beispiel ein. Um den Optimierungstest in die Praxis umzusetzen, müssen Sie die Fehler Ihrer Validierungsprobe überprüfen. Für jeden Fehler müssen Sie sicherstellen, dass die Schätzung für die erwartete (korrekte) Transkription höher ist als die Schätzung für die ausgegebene (falsche) Transkription, d. H. Punktzahl </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (S *)&gt; Punktzahl </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (S </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">out</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). Jedes Beispiel aus dem Validierungsmuster, für das eine solche Ungleichung bestehen bleibt, wird als Fehler markiert, der vom Optimierungsalgorithmus verursacht wird. Jedes Beispiel, bei dem diese Ungleichung nicht auftritt, wird aufgrund der falschen Methode zur Berechnung von Punktzahl </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (.) </font><font style="vertical-align: inherit;">Als Fehler gewertet </font><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Beispielsweise stellen Sie fest, dass 95% der Fehler durch die Arbeit der Bewertungsfunktion bei der Berechnung von Punktzahl </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A verursacht werden</font></font></sub> (.),   5%    .   ,         ,        5% .         Score <sub>A</sub> (.). <br><br><hr><h3> <font color="#548dd4"> 45.     </font> </h3><hr><br>  Sie können den Optimierungstest anwenden, wenn Sie ein x als Eingabe erhalten. Sie wissen, wie der Score <sub>X</sub> (y) berechnet wird, der angibt, wie gut die Ausgabe <b>y</b> dem angegebenen <b>x</b> an der Eingabe entspricht.  Außerdem verwenden Sie den ungefähren Suchalgorithmus, um arg max <sub>Y</sub> Score <sub>X</sub> (y) zu finden, vermuten jedoch, dass der Suchalgorithmus beim Ermitteln des Maximums falsch ist.  Im vorherigen Beispiel war bei einem Spracherkennungssystem <b>x</b> = A eine Audioaufzeichnung und <b>y</b> = S eine Ausgangstranskription. <br><br>  Angenommen, y * ist der richtige Ausgabewert, aber der Algorithmus gibt stattdessen yout zurück.  Dann ist die Hauptsache zu überprüfen, wie Score <sub>X</sub> (y *) und Score <sub>X</sub> (y <sub>out</sub> ) zusammenhängen.  Ist die erste Schätzung größer als die zweite, so liegt die Fehlerursache im Optimierungsalgorithmus, ansonsten liegt der Fehler bei der Berechnungsfunktion der Punktzahl Punktzahl <sub>X</sub> (y). <br><br>  Schauen wir uns ein anderes Beispiel an.  Angenommen, Sie erstellen ein maschinelles Übersetzungssystem von Chinesisch nach Englisch.  Ihr System empfängt einen Satz C als Eingabe und berechnet die Punktzahl <sub>C</sub> (E) für jede mögliche Version der Übersetzung E. Sie können beispielsweise die Punktzahl <sub>C</sub> (E) = P (E | C) verwenden, d. H.  die Wahrscheinlichkeit, dass die Übertragung E ist, vorausgesetzt, Satz C wurde vorgelegt. <br><br>  Ihre maschinelle Übersetzungsmaschine versucht zu berechnen: <br><p></p><p><math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math MJXp-display" id="MJXp-Span-188"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-189">O</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-190">u</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-191">t</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-192">p</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-193">u</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-194">t</span><span class="MJXp-mo" id="MJXp-Span-195" style="margin-left: 0.333em; margin-right: 0.333em;">=</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-196">a</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-197">r</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-198">g</span><span class="MJXp-mtext" id="MJXp-Span-199">&nbsp;</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-200">m</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-201">a</span><span class="MJXp-msubsup" id="MJXp-Span-202"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-203" style="margin-right: 0.05em;">x</span><span class="MJXp-mi MJXp-italic MJXp-script" id="MJXp-Span-204" style="vertical-align: -0.4em;">E</span></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-205">S</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-206">c</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-207">o</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-208">r</span><span class="MJXp-msubsup" id="MJXp-Span-209"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-210" style="margin-right: 0.05em;">e</span><span class="MJXp-mrow MJXp-script" id="MJXp-Span-211" style="vertical-align: -0.4em;"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-212">C</span></span></span><span class="MJXp-mo" id="MJXp-Span-213" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-214">E</span><span class="MJXp-mo" id="MJXp-Span-215" style="margin-left: 0em; margin-right: 0em;">)</span></span></span><div class="MathJax_SVG_Display MathJax_SVG_Processing"><span class="MathJax_SVG" id="MathJax-Element-7-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span></div><script type="math/tex;mode=display" id="MathJax-Element-7"> Output = arg \ max_E Score_ {C} (E) </script></p><br><br>  Die Menge aller möglichen E-Sätze in Englisch ist jedoch so groß, dass Sie sich auf einen heuristischen Suchalgorithmus verlassen müssen. <br><br>  Angenommen, Ihr Algorithmus erzeugt häufiger die falsche Übersetzung E <sub>out</sub> als eine korrekte Übersetzung E *.  Dann ermöglicht der Optimierungskontrolltest die Berechnung der Ungleichheit Score <sub>C</sub> (E *)&gt; Score <sub>C</sub> (E <sub>out</sub> ).  Wenn es gespeichert ist, erkennt Score <sub>C</sub> (.) E * korrekt als die beste Ausgabe E <sub>out</sub> , sodass Sie diesen Fehler dem Anteil des ungefähren Suchalgorithmus zuschreiben, andernfalls der Berechnungsfunktion Score <sub>C</sub> (.). <br><br>  Dies ist ein sehr allgemeines Muster in AI: Zuerst trainieren wir die Approximationsschätzfunktion Score <sub>x</sub> (.), Dann verwenden wir den Approximationsmaximierungsalgorithmus.  Wenn Sie sich an dieses Muster erinnern, können Sie mit dem Optimierungstest die Fehlerquelle ermitteln. <br><br><hr><h3>  <font color="#548dd4">Kapitel 46. Beispiel für das Erlernen der Verstärkung</font> </h3><hr><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/0a/gn/mt/0agnmtdytfehwg-iryyvdd6kv7w.png"></div><br>  Angenommen, Sie verwenden maschinelles Lernen, um einem Hubschrauber das Durchführen komplexer Manöver beizubringen.  Oben ist ein Zeitrafferbild eines Hubschraubers zu sehen, der von einem Computer gesteuert wird, der bei ausgeschaltetem Motor landet. <br><br>  Dieses Manöver wird als Landung bei Autorotation bezeichnet.  Dadurch kann der Hubschrauber landen, auch wenn der Motor plötzlich abstürzt.  Menschliche Piloten üben dieses Manöver im Rahmen ihres Trainings.  Ihr Ziel ist es, den Algorithmus für maschinelles Lernen zu verwenden, damit der Hubschrauber auf einer bestimmten Flugbahn T fliegen und am Ende sicher landen kann. <br><br>  Um Verstärkungstraining anzuwenden, müssen Sie eine „Belohnungsfunktion“ R (.) Entwickeln. Diese gibt eine Schätzung darüber, wie gut jede mögliche Flugbahn von T. war. Wenn die Flugbahn T beispielsweise zu einem Hubschrauberabsturz geführt hat, lassen Sie die Belohnung R (T) = - 1000, d.h.  hat einen großen negativen Wert.  Die Flugbahn T, die mit einer erfolgreichen Landung endete, weist eine positive Schätzung von R (T) auf, die genau die Abhängigkeit davon widerspiegelt, wie glatt die Landung war.  Die Belohnungsfunktion R (.) Wird normalerweise manuell ausgewählt, um zu quantifizieren, wie wünschenswert die verschiedenen Flugbahnen von T sind. Sie muss verschiedene Faktoren ausgleichen: Wie stark hat sie bei der Landung gewackelt, ob der Hubschrauber genau an der richtigen Stelle gelandet ist, wie schwer der Abstieg für die Passagiere war und so weiter.  Gute Belohnungsfunktionen sind nicht einfach zu entwickeln. <br><br>  In Anbetracht der Belohnungsfunktion R (T) besteht die Aufgabe des Verstärkungslernalgorithmus darin, den Hubschrauber so zu steuern, dass er max. <sub>TR</sub> (T) erreicht.  Verstärkungslernalgorithmen machen jedoch viele Annäherungen und können diese Maximierung möglicherweise nicht erreichen. <br><br>  Angenommen, Sie definieren eine R (.) - Belohnungsfunktion und führen Ihren Lernalgorithmus aus.  Seine Wirksamkeit ist jedoch viel schlechter als die eines menschlichen Piloten - er zittert bei der Landung stark und scheint weniger sicher zu sein.  Wie kann festgestellt werden, ob der Fehler mit dem Verstärkungslernalgorithmus zusammenhängt, der versucht, dem maximalen <sub>TR</sub> (T) -Pfad zu folgen, oder ob der Fehler mit der Belohnungsfunktion zusammenhängt, die versucht, die ideale Beziehung zwischen dem akzeptablen Ruckeln während der Landung und der Genauigkeit der Landestelle zu messen und zu bestimmen? <br><br>  Wir wenden den Optimierungstest an.  Sei T <sub>human</sub> der vom Piloten eingeschlagene Weg und T <sub>out</sub> der vom Algorithmus gewählte Weg.  Nach der obigen Beschreibung sind wir uns einig, dass die Flugbahn von T <sub>human</sub> besser ist als T <sub>out</sub> , dann <sub>lautet</sub> die Haupttestfrage, ob R (T <sub>human</sub> )&gt; R (T <sub>out</sub> ) der Realität entspricht. <br><br>  Option 1: Wenn diese Ungleichung weiterhin besteht, schätzt die Belohnungsfunktion R (.) Die Flugbahn von T <sub>human</sub> korrekt.  Der Verstärkungslernalgorithmus wählte jedoch die Trajektorie T <sub>out mit</sub> schlechterer Bewertung.  Das bedeutet, dass es sich lohnt, an der Verbesserung unseres Algorithmus zum Lernen der Verstärkung zu arbeiten. <br><br>  Option 2: Diese Ungleichung bleibt nicht erhalten, d.h.  R (T <sub>human</sub> ) ≤ R (T <sub>out</sub> ).  Dies bedeutet, dass die Belohnungsfunktion R (.) Das schlechteste Ergebnis für T <sub>human</sub> zugewiesen hat, obwohl dies bei weitem die beste Flugbahn ist.  Sie sollten daran arbeiten, R (.) Zu verbessern, um das beste Verhältnis der Faktoren zu finden, die einer guten Anpassung entsprechen. <br><br>  Viele Anwendungen für maschinelles Lernen verfügen über diese „Vorlage“ zur Optimierung der Funktion Score <sub>x</sub> (.) Unter Verwendung des ungefähren Suchalgorithmus.  Manchmal haben wir nicht genau die angegebene Eingabe x, daher wird die Optimierung nur auf die Bewertungsfunktion Punktzahl (.) Reduziert.  Im obigen Beispiel war die Belohnungsfunktion die Belohnungsfunktion Score (T) = R (T), und der Optimierungsalgorithmus war ein Verstärkungslernalgorithmus, der versucht, eine gute Flugbahn T zu berechnen. <br><br>  Der einzige Unterschied zwischen diesem Beispiel und früheren besteht darin, dass wir es nicht mit der „optimalen“ Ausgabe vergleichen, sondern mit der menschlichen Effizienz für T <sub>human</sub> .  Wir gehen davon aus, dass der T-Pfad einigermaßen gut ist, auch wenn er nicht optimal ist.  Im Allgemeinen kann der Optimierungssteuerungstest zeigen, ob es mehr gibt, solange Sie ein y * (in diesem Beispiel T <sub>human</sub> ) haben, das die beste Ausgabe in Bezug auf die Effizienz für Ihren aktuellen Lernalgorithmus darstellt (auch wenn es nicht „optimal“ ist) vielversprechend, den Optimierungsalgorithmus oder die Bewertungsfunktion zu verbessern. <br><br><br>  [ <a href="https://habr.com/ru/post/485190/">Fortsetzung</a> ] </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de485070/">https://habr.com/ru/post/de485070/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de485050/index.html">Hypercube. Wie wir Entwicklern Testgeräte zur Verfügung gestellt haben und diese nicht verloren haben</a></li>
<li><a href="../de485052/index.html">Wer ist eine gute QS?</a></li>
<li><a href="../de485056/index.html">Teilen und erobern</a></li>
<li><a href="../de485058/index.html">„Überprüfen Sie die Uhr“: Was ist über das neue Zeitsynchronisationsprotokoll des Servers bekannt?</a></li>
<li><a href="../de485068/index.html">Clean Code für TypeScript - Teil 2</a></li>
<li><a href="../de485074/index.html">Wie man nicht bei einem Projekt oder 5 Life Hacks stirbt</a></li>
<li><a href="../de485078/index.html">Schwierig, anfällig, unterkonfiguriert: Cyber-Bedrohungen 2020</a></li>
<li><a href="../de485080/index.html">NgRx Ducks | Dynamische Fassaden</a></li>
<li><a href="../de485084/index.html">Büro Plankton - Evolution</a></li>
<li><a href="../de485088/index.html">Retrospektive Rechen. Wie sich herausstellte, dass eine selbst gemachte Lösung cooler als bezahlt war</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>