<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚åöÔ∏è ‚óªÔ∏è üë©üèª‚Äç‚öñÔ∏è Exporte o Google Forms + fa√ßa o download do Google Script via API REST (Python) üå≤ üëàüèº üåΩ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="T√≠nhamos dois formul√°rios do Google, 75 perguntas em cada um, 5 usu√°rios corporativos que editaram ativamente esses formul√°rios e tamb√©m um script do ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Exporte o Google Forms + fa√ßa o download do Google Script via API REST (Python)</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/485898/"><img src="https://habrastorage.org/webt/gi/tl/nl/gitlnlklzpbmybk3jz3utl4_uow.png"><br><br>  T√≠nhamos dois formul√°rios do Google, 75 perguntas em cada um, 5 usu√°rios corporativos que editaram ativamente esses formul√°rios e tamb√©m um script do Google exportando o formul√°rio para JSON.  N√£o que seja dif√≠cil execut√°-lo todas as vezes com as m√£os, mas depois que voc√™ come√ßar a automatizar seu trabalho, siga esse hobby at√© o fim. <br><br>  Na documenta√ß√£o oficial, o diabo quebrar√° a perna; portanto, sob o gato, veremos mais de perto o download remoto e o lan√ßamento do Script do Google Apps por meio da API REST usando Python. <br><a name="habracut"></a><br><h2>  1. Introdu√ß√£o </h2><br>  No Doctor Near, estamos desenvolvendo uma plataforma para bots de bate-papo, na qual os formul√°rios do Google s√£o usados ‚Äã‚Äãpara descrever cen√°rios.  Dessa forma, quero obter um JSON dos formul√°rios com o clique de um bot√£o que cont√©m n√≥s (pontos do formul√°rio) e metadados para eles (transi√ß√µes entre n√≥s, tipos de n√≥s, seu nome).  Parece que o desejo √© simples, mas o Google n√£o suporta essa funcionalidade e voc√™ precisa montar esse "exportador" com suas pr√≥prias m√£os.  Considere as etapas para cri√°-lo. <br><br><h2>  PASSO 1. Script do Google Apps </h2><br>  O Google forneceu a capacidade de interagir com seus servi√ßos (Planilhas, Documentos, Formul√°rios) por meio do Script do Google Apps - scripts escritos em google script (.gs).  Este artigo n√£o fornece uma an√°lise da linguagem de script do Google, portanto, darei um exemplo de um script pronto que cria JSON a partir de um formul√°rio existente do Google.  O <a href="" rel="nofollow">c√≥digo de</a> usu√°rio <a href="https://github.com/stevenschmatz" rel="nofollow">Steven Schmatz</a> foi retirado do github como base, pelo qual eu expresso minha gratid√£o a ele. <br><br><div class="spoiler">  <b class="spoiler_title">C√≥digo de script</b> <div class="spoiler_text"><pre><code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// Steven Schmatz // Humanitas Labs // 13 October, 2016. // Roman Shekhovtsov // dr-telemed.ru // Autumn 2019 // Nikita Orekhov // dr-telemed.ru // Autumn 2019 /** * Converts the given form URL into a JSON object. */ function main() { form_url = "&lt;YOUR_FORM_URL&gt;" var form = FormApp.openByUrl(form_url); var items = form.getItems(); var result = { "metadata": getFormMetadata(form), "items": items.map(itemToObject), "count": items.length }; // sendEmail("&lt;YOUR_EMAIL&gt;", result) return result; } /** If we want to receive data by email * Sends JSON as text to recipient email * @param recipient: String * @param result: JSON */ function sendEmail(recipient, json_file){ var subject = "google form json import" var body = JSON.stringify(json_file); Logger.log(body); MailApp.sendEmail(recipient, subject, body); } /** * Returns the form metadata object for the given Form object. * @param form: Form * @returns (Object) object of form metadata. */ function getFormMetadata(form) { return { "title": form.getTitle(), "id": form.getId(), "description": form.getDescription(), "publishedUrl": form.getPublishedUrl(), "editorEmails": form.getEditors().map(function(user) { return user.getEmail() }), "count": form.getItems().length, "confirmationMessage": form.getConfirmationMessage(), "customClosedFormMessage": form.getCustomClosedFormMessage() }; } /** * Returns an Object for a given Item. * @param item: Item * @returns (Object) object for the given item. */ function itemToObject(item) { var data = {}; data.type = item.getType().toString(); // Downcast items to access type-specific properties var itemTypeConstructorName = snakeCaseToCamelCase("AS_" + item.getType().toString() + "_ITEM"); var typedItem = item[itemTypeConstructorName](); // Keys with a prefix of "get" have "get" stripped var getKeysRaw = Object.keys(typedItem).filter(function(s) {return s.indexOf("get") == 0}); getKeysRaw.map(function(getKey) { var propName = getKey[3].toLowerCase() + getKey.substr(4); // Image data, choices, and type come in the form of objects / enums if (["image", "choices", "type", "alignment"].indexOf(propName) != -1) {return}; // Skip feedback-related keys if ("getFeedbackForIncorrect".equals(getKey) || "getFeedbackForCorrect".equals(getKey) || "getGeneralFeedback".equals(getKey)) {return}; var propValue = typedItem[getKey](); data[propName] = propValue; }); // Bool keys are included as-is var boolKeys = Object.keys(typedItem).filter(function(s) { return (s.indexOf("is") == 0) || (s.indexOf("has") == 0) || (s.indexOf("includes") == 0); }); boolKeys.map(function(boolKey) { var propName = boolKey; var propValue = typedItem[boolKey](); data[propName] = propValue; }); // Handle image data and list choices switch (item.getType()) { case FormApp.ItemType.LIST: case FormApp.ItemType.CHECKBOX: data.choices = typedItem.getChoices().map(function(choice) { return choice.getValue() }); case FormApp.ItemType.MULTIPLE_CHOICE: data.choices = typedItem.getChoices().map(function(choice) { gotoPage = choice.getGotoPage() if (gotoPage == null) return choice.getValue() else return { "value": choice.getValue(), "gotoPage":choice.getGotoPage().getId() }; }); break; case FormApp.ItemType.IMAGE: data.alignment = typedItem.getAlignment().toString(); if (item.getType() == FormApp.ItemType.VIDEO) { return; } var imageBlob = typedItem.getImage(); data.imageBlob = { "dataAsString": "", //imageBlob.getDataAsString(), - BLOB too big "name": imageBlob.getName(), "isGoogleType": imageBlob.isGoogleType() }; break; case FormApp.ItemType.PAGE_BREAK: data.pageNavigationType = typedItem.getPageNavigationType().toString(); break; default: break; } // Have to do this because for some reason Google Scripts API doesn't have a // native VIDEO type if (item.getType().toString() === "VIDEO") { data.alignment = typedItem.getAlignment().toString(); } return data; } /** * Converts a SNAKE_CASE string to a camelCase string. * @param s: string in snake_case * @returns (string) the camelCase version of that string */ function snakeCaseToCamelCase(s) { return s.toLowerCase().replace(/(\_\w)/g, function(m) {return m[1].toUpperCase();}); }</span></span></code> </pre> <br></div></div><br>  O que acontece no c√≥digo: <br><br><ul><li>  Fun√ß√£o <i>getFormMetadata</i> - retorna JSON com metadados do formul√°rio </li><li>  fun√ß√£o <i>itemToObject</i> - converte o objeto <i>form.item</i> em JSON com os campos obrigat√≥rios </li><li>  fun√ß√£o <i>sendEmail</i> - envia um arquivo JSON para o correio especificado em texto </li><li>  fun√ß√£o <i>principal</i> - retorna o JSON resultante </li><li>  a vari√°vel <i>form_url</i> na fun√ß√£o <i>principal</i> √© o endere√ßo do nosso formul√°rio do Google </li></ul><br><h2>  PASSO 2. Testando o script </h2><br>  No momento, o desempenho do script pode ser verificado da seguinte forma: <br><br><ol><li>  <a href="https://script.google.com/home/start" rel="nofollow">crie</a> seu pr√≥prio projeto de script de aplicativo </li><li>  copie o c√≥digo nele </li><li>  em vez de <i>&lt;YOUR_FORM_URL&gt;,</i> substitu√≠mos o endere√ßo do nosso formul√°rio pelo formul√°rio <i><a href="https://docs.google.com/forms/d/FORM_IDENTIFICATOR/edit" rel="nofollow">docs.google.com/forms/d/FORM_IDENTIFICATOR/edit</a></i> </li><li>  descomente a chamada para <i>sendEmail</i> na fun√ß√£o <i>principal</i> </li><li>  em vez de <i>&lt;YOUR_EMAIL&gt;,</i> substitu√≠mos o endere√ßo de email para o qual queremos receber JSON </li><li>  salve o projeto </li><li>  execute a fun√ß√£o <i>principal</i> </li><li>  se esta for a primeira execu√ß√£o do script, o sistema informar√° sobre a necessidade de conceder permiss√£o ao script para enviar e-mail a partir do seu endere√ßo.  N√£o tenha medo.  Este √© o procedimento padr√£o necess√°rio para testar o script.  Acesse "Permiss√µes de revis√£o" -&gt; selecione sua conta -&gt; "Avan√ßado" -&gt; "V√° para o projeto PROJECT_NAME (n√£o seguro)" -&gt; "Permitir" </li><li>  esperando o script dar certo </li><li>  procure na caixa de correio e veja o arquivo JSON em forma de texto </li></ol><br>  Tudo ficaria bem, mas o uso adicional dos dados obtidos envolve c√≥pia manual do correio, processamento deste texto (em python, por exemplo) e salvamento do arquivo resultante.  N√£o parece muito pronto para produ√ß√£o.  Automatizamos o lan√ßamento desse script e obtemos seu resultado por meio da API de scripts do Google Apps, mas primeiro configuramos nosso projeto do Google de acordo. <br><br>  <b>Aten√ß√£o:</b> Para a conveni√™ncia de entender o que est√° acontecendo, abaixo vou me referir apenas a duas p√°ginas, portanto, √© recomend√°vel abri-las nas guias adjacentes: <br><br><ol><li>  <a href="https://script.google.com/home" rel="nofollow">P√°gina</a> Script / Edi√ß√£o de Script - <i>‚ÄúP√°gina 1‚Äù</i> </li><li>  P√°gina do Google Cloud Platform - <i>"P√°gina 2"</i> </li></ol><br><h2>  PASSO 3. Configure o Google Cloud Platform </h2><br>  Vamos para o Google Cloud Platform (p√°gina 2), criamos um novo projeto.  √â necess√°rio criar um novo projeto, porque o status padr√£o do projeto √© Padr√£o e o Standart √© necess√°rio para nossos prop√≥sitos.  Mais detalhes podem ser encontrados <a href="https://developers.google.com/apps-script/guides/cloud-platform-projects" rel="nofollow">aqui</a> (ponto 3). <br><br>  Retornamos √† p√°gina 2, acessamos a guia "API e servi√ßos" e, em seguida, "Janela OAuth Access Request".  Defina o Tipo de usu√°rio como "Externo". <br><br>  Na janela exibida, preencha o "Nome do aplicativo". <br><br>  Abra a p√°gina inicial no Google Cloud Platform.  No bloco "Informa√ß√µes do projeto", copie o n√∫mero do projeto. <br><br>  V√° para a p√°gina 1. Abra o script criado anteriormente.  Na janela de edi√ß√£o de script aberta, v√° para "Recursos" -&gt; "Projeto Cloud Platform".  No campo "Alterar projeto", insira o n√∫mero do projeto copiado anteriormente.  Agora este script est√° associado ao projeto criado. <br><br><h2>  PASSO 4. API REST do Python </h2><br>  √â hora de automatizar o script usando a <a href="https://developers.google.com/apps-script/api/reference/rest" rel="nofollow">API REST</a> .  Python foi usado como a linguagem. <br><br><h3>  Logon na API de scripts do Google Apps </h3><br>  O c√≥digo deve ter acesso ao projeto, portanto, o primeiro e muito importante procedimento √© o login na API de scripts do Google Apps.  Abra a p√°gina 2 -&gt; "API e servi√ßos" -&gt; "Credenciais" -&gt; "Criar credenciais" -&gt; "OAuth Client Identifier" -&gt; "Outros tipos".  Chamamos o nosso identificador, v√° para ele.  Sendo na guia "Credenciais", selecione "Baixar arquivo JSON".  Isso carregar√° o arquivo de chave para acesso do c√≥digo ao projeto no Google.  Colocamos esse arquivo na pasta de credenciais. <br><br>  Agora voc√™ precisa dar permiss√£o para usar a API (no nosso caso, a API de script de aplicativos) como parte deste projeto.  Para fazer isso, v√° para "API e servi√ßos" -&gt; "Biblioteca" -&gt; digite "API de script de aplicativos" na pesquisa e clique em "Ativar". <br><br>  Os aplicativos que interagem com o Google t√™m v√°rias permiss√µes que o usu√°rio deve conceder ao inici√°-lo.  Essa c√≥pia depende das fun√ß√µes usadas por um script espec√≠fico e voc√™ pode descobrir isso indo para a p√°gina 1 na janela de edi√ß√£o de script em ‚ÄúArquivo‚Äù -&gt; ‚ÄúPropriedades do projeto‚Äù -&gt; ‚ÄúEscopos‚Äù.  Essas permiss√µes devem ser mantidas para refer√™ncia futura no c√≥digo. <br><br>  Nesse caso, a fun√ß√£o de login ficar√° assim: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> pickle <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> os.path <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> googleapiclient.discovery <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> build <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> google_auth_oauthlib.flow <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> InstalledAppFlow <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> google.auth.transport.requests <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Request <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">login</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(config)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">try</span></span>: creds = <span class="hljs-keyword"><span class="hljs-keyword">None</span></span> <span class="hljs-comment"><span class="hljs-comment"># The file token.pickle stores the user's access and refresh tokens, and is # created automatically when the authorization flow completes for the first # time. token_file = config['credentials_path'] + config['token_file'] credentials_file = config['credentials_path'] + config['credentials_file'] if os.path.exists(token_file): with open(token_file, 'rb') as token: creds = pickle.load(token) # If there are no (valid) credentials available, let the user log in. if not creds or not creds.valid: if creds and creds.expired and creds.refresh_token: creds.refresh(Request()) else: flow = InstalledAppFlow.from_client_secrets_file(credentials_file, config['SCOPES']) creds = flow.run_local_server(port=0) # Save the credentials for the next run with open(token_file, 'wb') as token: pickle.dump(creds, token) service = build('script', 'v1', credentials=creds) pprint('Login successful') return service except Exception as e: pprint(f'Login failure: {e}') return None</span></span></code> </pre><br>  Esse bloco de c√≥digo √© o procedimento padr√£o para come√ßar a usar o Google App Script. <br>  Usamos um token de autentica√ß√£o e, ao fazer login, crie um novo token ou use um j√° existente. <br><br>  Por conveni√™ncia, foi criado um arquivo de configura√ß√£o JSON, com o seguinte formato: <br><br><pre> <code class="json hljs">{ <span class="hljs-attr"><span class="hljs-attr">"SCOPES"</span></span>: [<span class="hljs-string"><span class="hljs-string">"https://www.googleapis.com/auth/forms"</span></span>, <span class="hljs-string"><span class="hljs-string">"https://www.googleapis.com/auth/script.send_mail"</span></span>], <span class="hljs-attr"><span class="hljs-attr">"credentials_path"</span></span>: <span class="hljs-string"><span class="hljs-string">"credentials/"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"credentials_file"</span></span>: <span class="hljs-string"><span class="hljs-string">"google_test_project.json"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"token_file"</span></span>: <span class="hljs-string"><span class="hljs-string">"token.pickle"</span></span> }</code> </pre><br>  <b>Importante: o</b> token √© criado para autentica√ß√£o com um escopo espec√≠fico de permiss√µes.  Em outras palavras, ao alterar o escopo das permiss√µes, voc√™ deve excluir o token e criar um novo no logon. <br><br><h3>  C√≥digo de script de atualiza√ß√£o remota </h3><br>  Agora vamos aprender como atualizar remotamente o c√≥digo do script, executar esse c√≥digo e obter o resultado.  De fato, al√©m do c√≥digo que executamos no editor do Google, tamb√©m h√° um <a href="https://developers.google.com/apps-script/concepts/manifests" rel="nofollow">arquivo de manifesto</a> que cont√©m os direitos de inicializa√ß√£o, configura√ß√µes de implanta√ß√£o etc.  Mais informa√ß√µes sobre sua estrutura podem ser encontradas <a href="https://developers.google.com/apps-script/manifest/" rel="nofollow">aqui</a> . <br>  Para ver o arquivo de manifesto padr√£o criado pelo Google para o seu script, acesse o editor de scripts em "Visualizar" -&gt; "Mostrar arquivo de manifesto".  O manifesto aparecer√° na lista de arquivos relacionados a este script. <br><br>  Discurso sobre o manifesto n√£o foi sem motivo: a atualiza√ß√£o remota de scripts requer o download do c√≥digo dos arquivos (* .gs) e do manifesto (appscript.json). <br><br>  Primeiro, leia o c√≥digo do arquivo .gs que queremos implantar: <br><br><pre> <code class="python hljs"> <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> open(<span class="hljs-string"><span class="hljs-string">'export-google-form.gs'</span></span>, <span class="hljs-string"><span class="hljs-string">'r'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> f: sample_code = f.read()</code> </pre><br>  Agora copie o manifesto gerado automaticamente e modifique-o um pouco para nossos prop√≥sitos.  A documenta√ß√£o descreve de maneira bastante abrangente a estrutura do arquivo de manifesto, portanto n√£o vou me debru√ßar sobre esse ponto.  Para que o script funcione, voc√™ precisa adicionar a se√ß√£o "ExecutionApi" ao manifesto padr√£o, necess√°rio para executar remotamente o script por meio da API.  Nesta se√ß√£o, indicamos o c√≠rculo de pessoas que t√™m a capacidade de execut√°-lo.  Eu permiti o lan√ßamento para todos que passaram pela autoriza√ß√£o, o que corresponde ao identificador "ANYONE": <br><br><pre> <code class="python hljs">MANIFEST = <span class="hljs-string"><span class="hljs-string">''' { "timeZone": "America/New_York", "exceptionLogging": "STACKDRIVER", "executionApi": { "access": "ANYONE" } } '''</span></span>.strip()</code> </pre><br>  O corpo da solicita√ß√£o de atualiza√ß√£o deve conter uma matriz de arquivos com a seguinte estrutura: <br><br><ul><li>  <i>nome</i> : nome do arquivo a ser criado no servidor, sem extens√£o </li><li>  <i>tipo</i> : <i>tipo de</i> arquivo (JSON para manifesto, SERVER_JS para .gs) </li><li>  <i>fonte</i> : c√≥digo do arquivo </li></ul><br><pre> <code class="python hljs">request = { <span class="hljs-string"><span class="hljs-string">'files'</span></span>: [{ <span class="hljs-string"><span class="hljs-string">'name'</span></span>: <span class="hljs-string"><span class="hljs-string">'hello'</span></span>, <span class="hljs-string"><span class="hljs-string">'type'</span></span>: <span class="hljs-string"><span class="hljs-string">'SERVER_JS'</span></span>, <span class="hljs-string"><span class="hljs-string">'source'</span></span>: sample_code }, { <span class="hljs-string"><span class="hljs-string">'name'</span></span>: <span class="hljs-string"><span class="hljs-string">'appsscript'</span></span>, <span class="hljs-string"><span class="hljs-string">'type'</span></span>: <span class="hljs-string"><span class="hljs-string">'JSON'</span></span>, <span class="hljs-string"><span class="hljs-string">'source'</span></span>: MANIFEST } ] }</code> </pre><br>  Por fim, a pr√≥pria solicita√ß√£o de atualiza√ß√£o deve conter o corpo (solicita√ß√£o descrita acima) e o ID do script.  O √∫ltimo pode ser obtido acessando "Arquivo" -&gt; "Propriedades do projeto" no editor de script e copiando o "ID do script": <br><br><pre> <code class="python hljs">script_id = <span class="hljs-string"><span class="hljs-string">'qwertyuiopQWERTYUIOPasdfghjkl123456789zxcvbnmASDFGHJKL54'</span></span></code> </pre><br>  Para o objeto de servi√ßo obtido como resultado do login, obtemos o campo projects () e chamamos o m√©todo updateContent (), ap√≥s o qual chamamos o m√©todo execute () para o objeto HttpRequest recebido: <br><br><pre> <code class="python hljs">service.projects().updateContent( body=request, scriptId=script_id ).execute()</code> </pre><br>  No entanto, por enquanto, a execu√ß√£o do c√≥digo resultar√° em um erro: <br><br><pre> <code class="json hljs"><span class="hljs-string"><span class="hljs-string">"error"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"code"</span></span>: <span class="hljs-number"><span class="hljs-number">403</span></span>, <span class="hljs-attr"><span class="hljs-attr">"message"</span></span>: <span class="hljs-string"><span class="hljs-string">"Request had insufficient authentication scopes."</span></span>, <span class="hljs-attr"><span class="hljs-attr">"status"</span></span>: <span class="hljs-string"><span class="hljs-string">"PERMISSION_DENIED"</span></span> }</code> </pre><br>  Como voc√™ pode ver, n√£o h√° permiss√µes suficientes no osprey de autentica√ß√£o, conforme indicado anteriormente.  Voltamos √† documenta√ß√£o oficial da API, a saber, o m√©todo <a href="https://developers.google.com/apps-script/api/reference/rest/v1/projects/updateContent" rel="nofollow">updateContent</a> , que usamos para atualizar remotamente o script.  A documenta√ß√£o diz que o uso desse m√©todo requer o acesso ao script.projects: <br><br><pre> <code class="python hljs">https://www.googleapis.com/auth/script.projects</code> </pre> <br>  Adicione-o ao nosso arquivo de configura√ß√£o na se√ß√£o SCOPES.  Como escrevi acima, ao alterar o osprey, voc√™ precisa excluir o token gerado automaticamente. <br><br>  √ìtimo!  No momento, aprendemos a atualizar remotamente o script do Google.  Resta execut√°-lo e obter o resultado da execu√ß√£o. <br><br><h3>  Execu√ß√£o de script </h3><br>  A solicita√ß√£o de ativa√ß√£o de <a href="https://developers.google.com/apps-script/api/reference/rest/v1/scripts/run" rel="nofollow">script</a> cont√©m scriptID e corpo com a seguinte estrutura: <br><br><ul><li>  <i>function</i> : nome da fun√ß√£o que queremos executar </li><li>  <i>parameters</i> : <i>(opcional) um</i> conjunto de par√¢metros de um tipo primitivo (string, array ...) transmitidos para a fun√ß√£o </li><li>  <i>sessionState</i> : <i>(opcional)</i> √© necess√°rio apenas para aplicativos Android </li><li>  <i>devMode</i> : <i>(opcional)</i> Verdadeiro se o usu√°rio for o propriet√°rio do script e, em seguida, a vers√£o mais recente ser√° lan√ßada que a que foi implantada usando a API de scripts do Google Apps.  (por padr√£o - Falso) </li></ul><br>  Para n√£o costurar o URL do formul√°rio do Google no script, passaremos <i>form_url</i> para a fun√ß√£o <i>principal</i> como argumento. <br><br>  <b>Aten√ß√£o</b>  Quando testamos o script, a fun√ß√£o <i>principal</i> n√£o aceitou nada; portanto, alteraremos as primeiras linhas de c√≥digo no arquivo .gs da seguinte maneira: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">form_url</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> form = FormApp.openByUrl(form_url); .......</code> </pre><br>  Como nosso aplicativo n√£o √© para Android e somos os propriet√°rios do script, o corpo ficar√° assim: <br><br><pre> <code class="python hljs">body = { <span class="hljs-string"><span class="hljs-string">"function"</span></span>: <span class="hljs-string"><span class="hljs-string">"main"</span></span>, <span class="hljs-string"><span class="hljs-string">"devMode"</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>, <span class="hljs-string"><span class="hljs-string">"parameters"</span></span>: form_url }</code> </pre><br>  Execute o script e escreva o resultado da execu√ß√£o na vari√°vel resp: <br><br><pre> <code class="python hljs">resp = service.scripts().run(scriptId=script_id, body=body).execute()</code> </pre><br>  Salve resp em um arquivo com a formata√ß√£o JSON conveniente: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> json <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> open(<span class="hljs-string"><span class="hljs-string">'habr_auto.json'</span></span>, <span class="hljs-string"><span class="hljs-string">'w'</span></span>, encoding=<span class="hljs-string"><span class="hljs-string">'utf-8'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> f: json.dump(resp[<span class="hljs-string"><span class="hljs-string">'response'</span></span>][<span class="hljs-string"><span class="hljs-string">'result'</span></span>], f, ensure_ascii=<span class="hljs-keyword"><span class="hljs-keyword">False</span></span>, indent=<span class="hljs-number"><span class="hljs-number">4</span></span>)</code> </pre><br>  <b>Aten√ß√£o</b>  Devido ao fato de a solicita√ß√£o script.run () aguardar o resultado pelo soquete, quando o tempo limite for excedido pelo tempo de execu√ß√£o, ocorrer√° um erro do seguinte tipo: <br><br><pre> <code class="python hljs">socket.timeout: The read operation timed out</code> </pre><br>  Para evitar esse comportamento, recomendo que, no in√≠cio do programa, defina um limite no tempo de soquete aberto, obviamente suficiente para aguardar a conclus√£o da execu√ß√£o do script.  No meu caso, 120 segundos s√£o suficientes: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> socket socket.setdefaulttimeout(<span class="hljs-number"><span class="hljs-number">120</span></span>)</code> </pre><br>  Voila!  Um pipeline conveniente para atualiza√ß√£o remota e lan√ßamento de scripts do Google est√° pronto.  O c√≥digo completo adaptado para o lan√ßamento a partir do terminal √© fornecido no meu <a href="https://github.com/nikanor97/habr_google_script_api" rel="nofollow">github</a> . <br><br>  Al√©m disso, darei o c√≥digo das principais fun√ß√µes abaixo <br><br><div class="spoiler">  <b class="spoiler_title">login.py</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pprint <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> pprint <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> pickle <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> os.path <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> googleapiclient.discovery <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> build <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> google_auth_oauthlib.flow <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> InstalledAppFlow <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> google.auth.transport.requests <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Request <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">login</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(config)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">try</span></span>: creds = <span class="hljs-keyword"><span class="hljs-keyword">None</span></span> <span class="hljs-comment"><span class="hljs-comment"># The file token.pickle stores the user's access and refresh tokens, and is # created automatically when the authorization flow completes for the first # time. token_file = config['credentials_path'] + config['token_file'] credentials_file = config['credentials_path'] + config['credentials_file'] if os.path.exists(token_file): with open(token_file, 'rb') as token: creds = pickle.load(token) # If there are no (valid) credentials available, let the user log in. if not creds or not creds.valid: if creds and creds.expired and creds.refresh_token: creds.refresh(Request()) else: flow = InstalledAppFlow.from_client_secrets_file(credentials_file, config['SCOPES']) creds = flow.run_local_server(port=0) # Save the credentials for the next run with open(token_file, 'wb') as token: pickle.dump(creds, token) service = build('script', 'v1', credentials=creds) pprint('Login successful') return service except Exception as e: pprint(f'Login failure: {e}') return None</span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">update_script.py</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pprint <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> pprint <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> json <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> sys <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> googleapiclient <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> errors <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> google_habr_login <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> login MANIFEST = <span class="hljs-string"><span class="hljs-string">''' { "timeZone": "America/New_York", "exceptionLogging": "STACKDRIVER", "executionApi": { "access": "ANYONE" } } '''</span></span>.strip() <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">update_project</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(service, script_id, script_file_name)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-comment"><span class="hljs-comment"># Read from file code we want to deploy with open(script_file_name, 'r') as f: sample_code = f.read() # Upload two files to the project request = { 'files': [{ 'name': 'hello', 'type': 'SERVER_JS', 'source': sample_code }, { 'name': 'appsscript', 'type': 'JSON', 'source': MANIFEST } ] } # Update files in the project service.projects().updateContent( body=request, scriptId=script_id ).execute() pprint('Project was successfully updated') def main(): try: args = sys.argv if len(args) != 4: raise TypeError('Wrong number of arguments. Three argument required: &lt;config_file_name&gt;, &lt;script_id&gt; and ' '&lt;script_file_name&gt;') config_file_name = args[1] script_id = args[2] script_file_name = args[3] with open(config_file_name, "r") as f: config = json.load(f) service = login(config) update_project(service, script_id, script_file_name) except (errors.HttpError, ) as error: # The API encountered a problem. pprint(error.content.decode('utf-8')) if __name__ == '__main__': main()</span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">export_form.py</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pprint <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> pprint <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> socket <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> json <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> sys <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> googleapiclient <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> errors <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> google_habr_login <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> login socket.setdefaulttimeout(<span class="hljs-number"><span class="hljs-number">120</span></span>) <span class="hljs-comment"><span class="hljs-comment"># Get JSON, which is returned by script def get_json(service, file_name, script_id, form_url): pprint('Exporting form...') body = { "function": "main", "devMode": True, "parameters": form_url } # Get JSON from script resp = service.scripts().run(scriptId=script_id, body=body).execute() # Write out JSON to file with open(file_name, 'w', encoding='utf-8') as f: json.dump(resp['response']['result'], f, ensure_ascii=False, indent=4) pprint('Form was successfully exported') def main(): try: args = sys.argv if len(args) != 5: raise TypeError('Wrong number of arguments. Four arguments required: &lt;config_file_name&gt;, ' '&lt;result_file_name&gt;, &lt;script_id&gt; and &lt;google_form_url&gt;') config_file_name = args[1] file_name = args[2] script_id = args[3] form_url = args[4] with open(config_file_name, "r") as f: config = json.load(f) service = login(config) get_json(service, file_name, script_id, form_url) except (errors.HttpError, ) as error: # The API encountered a problem. pprint(error.content.decode('utf-8')) if __name__ == '__main__': main()</span></span></code> </pre><br></div></div><br>  Para come√ßar, voc√™ precisa colocar o arquivo JSON com as chaves de acesso do Google na pasta credenciais e a configura√ß√£o JSON no mesmo diret√≥rio que os scripts. <br><br>  Ent√£o, se queremos atualizar remotamente o script, na chamada de terminal: <br><br><pre> <code class="bash hljs">python update_script.py &lt;config_file_name&gt; &lt;script_id&gt; &lt;script_file_name&gt;</code> </pre><br>  Nesse caso: <br><br><ul><li>  <i>config_file_name</i> - nome do arquivo JSON de configura√ß√£o </li><li>  <i>script_id</i> - ID do script </li><li>  <i>script_file_name</i> - o nome do arquivo .gs que ser√° carregado no google </li></ul><br>  Para executar o script, chame: <br><br><pre> <code class="bash hljs">python export_form.py &lt;config_file_name&gt; &lt;result_file_name&gt; &lt;script_id&gt; &lt;google_form_url&gt;</code> </pre><br>  Nesse caso: <br><br><ul><li>  <i>config_file_name</i> - nome do arquivo JSON de configura√ß√£o </li><li>  <i>result_file_name</i> - o nome do arquivo JSON no qual o formul√°rio ser√° descarregado </li><li>  <i>script_id</i> - ID do script </li><li>  <i>google_form_url</i> - URL do formul√°rio do Google </li></ul><br>  Obrigado por sua aten√ß√£o, aguardando suas sugest√µes e coment√°rios :) </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt485898/">https://habr.com/ru/post/pt485898/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt485884/index.html">Como configurar o Levitron chin√™s</a></li>
<li><a href="../pt485886/index.html">Como (e por que) analisar as chaves e os an√∫ncios dos concorrentes do Yandex.Direct e Google Ads gratuitamente</a></li>
<li><a href="../pt485888/index.html">Falsifica√ß√£o de solicita√ß√£o do servidor, opera√ß√£o de SSRF cego</a></li>
<li><a href="../pt485892/index.html">O fim da era Trident</a></li>
<li><a href="../pt485896/index.html">Banco de dados massivamente paralelo Greenplum - um pequeno programa educacional</a></li>
<li><a href="../pt485904/index.html">Meetup sobre Load Testing em Raiffeisenbank</a></li>
<li><a href="../pt485908/index.html">Gra√ßas √† incr√≠vel falha em Ocarina of Time, foi poss√≠vel adicionar modelos da Star Fox 64</a></li>
<li><a href="../pt485910/index.html">Implantando APIs com o AWS Elastic Beanstalk</a></li>
<li><a href="../pt485912/index.html">Por que traduzir em nomea√ß√£o √© ruim e outras caracter√≠sticas interessantes de nossa percep√ß√£o do c√≥digo</a></li>
<li><a href="../pt485914/index.html">Desenvolvido por ZeroTier. Um guia pr√°tico para a constru√ß√£o de redes virtuais. Parte 1</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>