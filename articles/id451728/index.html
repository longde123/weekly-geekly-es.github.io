<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨‍🍳 👴🏽 🕓 RESTinio adalah server HTTP asinkron. Tidak sinkron 👩🏾‍⚕️ 🏴󠁧󠁢󠁷󠁬󠁳󠁿 🤮</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Beberapa tahun yang lalu kami menerbitkan RESTinio , kerangka kerja OpenSource C ++ kecil kami untuk menyematkan server HTTP dalam aplikasi C ++. REST...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>RESTinio adalah server HTTP asinkron. Tidak sinkron</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/451728/"><p>  Beberapa tahun yang lalu kami menerbitkan <a href="">RESTinio</a> , kerangka kerja OpenSource C ++ kecil kami untuk menyematkan server HTTP dalam aplikasi C ++.  RESTinio tidak menjadi mega-populer selama waktu ini, tetapi itu <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tidak hilang</a> .  Seseorang memilihnya untuk dukungan "asli" untuk Windows, seseorang untuk beberapa fitur individual (seperti dukungan sendfile), seseorang untuk rasio fitur, kemudahan penggunaan dan penyesuaian.  Tapi, saya pikir, pada awalnya banyak RESTinio tertarik oleh "Halo, Dunia" singkat ini: </p><br><pre><code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;restinio/all.hpp&gt; int main() { restinio::run( restinio::on_this_thread() .port(8080) .address("localhost") .request_handler([](auto req) { return req-&gt;create_response().set_body("Hello, World!").done(); })); return 0; }</span></span></span></span></code> </pre> <br><p>  Ini benar-benar semua yang diperlukan untuk menjalankan server HTTP di dalam aplikasi C ++. </p><br><p>  Dan meskipun kami selalu mencoba mengatakan bahwa fitur utama yang kami gunakan secara umum di RESTinio adalah pemrosesan permintaan masuk yang tidak sinkron, kami terkadang masih menghadapi pertanyaan tentang apa yang harus dilakukan jika di dalam request_handler Anda harus melakukan operasi yang panjang. </p><br><p>  Dan karena pertanyaan seperti itu relevan, maka Anda dapat membicarakannya lagi dan memberikan beberapa contoh kecil. </p><a name="habracut"></a><br><h1 id="nebolshaya-otsylka-k-istokam">  Sedikit referensi tentang asal-usulnya </h1><br><p>  Kami memutuskan untuk membuat server HTTP yang dapat disematkan kami setelah beberapa kali berturut-turut menghadapi tugas yang sangat mirip: perlu untuk mengatur input HTTP untuk aplikasi C ++ yang ada atau perlu untuk menulis layanan microser yang diperlukan untuk menggunakan kembali C "heavy" yang sudah ada. kode ny.  Fitur umum dari tugas-tugas ini adalah bahwa pemrosesan aplikasi permintaan dapat berlangsung selama puluhan detik. </p><br><p>  Secara kasar, untuk satu milidetik, server HTTP memilah permintaan HTTP baru, tetapi untuk mengeluarkan respons HTTP, perlu beralih ke beberapa layanan lain atau melakukan beberapa perhitungan panjang.  Jika Anda memproses permintaan HTTP dalam mode sinkron, maka server HTTP akan membutuhkan kumpulan ribuan utas kerja, yang hampir tidak dapat dianggap sebagai ide yang baik bahkan dalam kondisi modern. </p><br><p>  Ini jauh lebih nyaman ketika server HTTP dapat bekerja hanya pada satu utas yang berfungsi, di mana I / O dilakukan dan penangan permintaan dipanggil.  Penangan permintaan hanya mendelegasikan pemrosesan aktual dari beberapa utas kerja lainnya dan mengembalikan kontrol ke server HTTP.  Ketika, jauh di kemudian hari, di suatu tempat di utas lainnya, informasi siap merespons permintaan, respons HTTP dihasilkan secara otomatis yang mengambil server HTTP dan mengirimkan respons ini ke klien yang sesuai. </p><br><p>  Karena kami tidak pernah menemukan versi siap pakai yang sederhana dan nyaman untuk digunakan, itu adalah cross-platform dan mendukung Windows sebagai platform "asli", akan memberikan kinerja yang lebih atau kurang layak, dan, yang paling penting, akan dipertajam khusus untuk asinkron. bekerja, maka pada awal 2017 kami mulai mengembangkan RESTinio. </p><br><p>  Kami ingin membuat server HTTP tertanam asinkron, mudah digunakan, membebaskan pengguna dari beberapa kekhawatiran rutin, sementara lebih atau kurang produktif, lintas platform dan memungkinkan konfigurasi fleksibel untuk kondisi yang berbeda.  Tampaknya berhasil, tapi mari kita serahkan kepada pengguna untuk menilai ... </p><br><h1 id="itak-est-vhodyaschiy-zapros-trebuyuschiy-mnogo-vremeni-na-obrabotku-chto-delat">  Jadi, ada permintaan masuk yang membutuhkan banyak waktu pemrosesan.  Apa yang harus dilakukan </h1><br><h2 id="rabochie-niti-restinioasio">  Utas kerja RESTinio / Asio </h2><br><p>  Terkadang pengguna RESTinio tidak memikirkan tentang utas kerja apa dan bagaimana tepatnya menggunakan RESTinio.  Misalnya, seseorang mungkin menganggap bahwa ketika RESTinio diluncurkan pada satu utas yang berfungsi (menggunakan <code>run(on_this_thread(...))</code> , seperti dalam contoh di atas), maka pada utas kerja ini RESTinio hanya memanggil penangan permintaan.  Sedangkan untuk I / O RESTinio membuat utas terpisah di bawah tenda.  Dan utas terpisah ini terus melayani koneksi baru ketika utas kerja utama ditempati oleh request_handler. </p><br><p>  Faktanya, semua utas yang dialokasikan pengguna untuk RESTinio digunakan baik untuk melakukan operasi I / O maupun untuk memanggil request_handlers.  Oleh karena itu, jika Anda memulai server RESTinio melalui proses <code>run(on_this_thread(...))</code> , maka di dalam proses <code>run()</code> pada utas saat ini, I / O dan penangan permintaan akan dilakukan. </p><br><p>  Secara kasar, RESTinio meluncurkan loop-event Asio, di dalamnya ia memproses koneksi baru, membaca dan mem-parsing data dari koneksi yang ada, menulis data yang siap untuk dikirim, menangani koneksi penutupan, dll.  Antara lain, setelah permintaan masuk dibaca dan sepenuhnya diuraikan dari koneksi berikutnya, request_handler yang ditentukan oleh pengguna dipanggil untuk memproses permintaan ini. </p><br><p>  Dengan demikian, jika request_handler memblokir operasi utas saat ini, maka perulangan-aksi Asio yang bekerja pada utas yang sama juga diblokir.  Semuanya sederhana. </p><br><p>  Jika RESTinio dimulai pada kumpulan utas yang berfungsi (mis. Dengan <code>run(on_thread_pool(...))</code> , seperti <a href="">dalam contoh ini</a> ), maka hal yang hampir sama terjadi: loop peristiwa Asia-event diluncurkan pada setiap utas dari kumpulan tersebut.  Oleh karena itu, jika beberapa request_handler mulai melipatgandakan matriks besar, maka ini akan memblokir utas yang berfungsi dalam kumpulan dan operasi I / O tidak lagi dilayani pada utas ini. </p><br><p>  Oleh karena itu, ketika menggunakan RESTinio, tugas pengembang adalah untuk menyelesaikan request_handlers-nya secara wajar dan, lebih disukai, tidak terlalu lama. </p><br><h2 id="nuzhen-li-vam-pul-rabochih-potokov-dlya-restinioasio">  Apakah Anda memerlukan kumpulan alur kerja untuk RESTinio / Asio? </h2><br><p>  Jadi, ketika request_handler ditentukan oleh pengguna memblokir utas yang dipanggil untuk waktu yang lama, utas ini kehilangan kemampuan untuk memproses operasi I / O.  Tetapi bagaimana jika request_handler membutuhkan banyak waktu untuk membentuk respons?  Misalkan dia melakukan semacam operasi komputasi yang berat, waktu yang, pada prinsipnya, tidak dapat dipersingkat menjadi beberapa milidetik? </p><br><p>  Salah satu pengguna mungkin berpikir bahwa karena RESTinio dapat bekerja di kumpulan utas yang berfungsi, maka cukup tentukan ukuran kumpulan yang lebih besar dan hanya itu. </p><br><p>  Sayangnya, ini hanya akan berfungsi dalam kasus sederhana ketika Anda memiliki beberapa koneksi paralel.  Dan intensitas permintaannya rendah.  Jika jumlah kueri paralel mencapai ribuan (setidaknya hanya beberapa ratus), maka mudah untuk mendapatkan situasi ketika semua utas kerja kumpulan akan sibuk memproses permintaan yang sudah diterima.  Dan tidak akan ada lagi utas yang tersisa untuk melakukan operasi I / O.  Akibatnya, server akan kehilangan responsifnya.  Termasuk RESTinio akan kehilangan kemampuan untuk memproses timeout yang secara otomatis dihitung oleh RESTinio ketika menerima koneksi baru dan ketika memproses permintaan. </p><br><p>  Oleh karena itu, jika Anda perlu melakukan operasi pemblokiran yang panjang untuk melayani permintaan yang masuk, lebih baik mengalokasikan hanya satu utas kerja untuk RESTinio, tetapi menetapkan aliran kerja yang besar untuk melakukan operasi yang sama ini.  Penangan permintaan hanya akan memasukkan permintaan berikutnya dalam beberapa antrian, dari mana permintaan akan diambil dan diserahkan untuk diproses. </p><br><p>  Kami melihat contoh skema ini secara rinci ketika kami berbicara tentang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">proyek demo Udang</a> kami di artikel ini: " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Udang: Skala dan Bagikan Gambar HTTP di C ++ Modern Menggunakan ImageMagic ++, SObjectizer, dan RESTinio</a> ." </p><br><h2 id="primery-delegirovaniya-obrabotki-zaprosov-na-otdelnye-rabochie-niti">  Contoh pendelegasian pemrosesan permintaan ke utas kerja individual </h2><br><p>  Di atas, saya mencoba menjelaskan mengapa tidak perlu melakukan pemrosesan yang panjang tepat di dalam request_handler.  Dari mana hasil yang jelas berasal: pemrosesan permintaan yang panjang harus didelegasikan ke beberapa utas kerja lainnya.  Mari kita lihat bagaimana ini terlihat. </p><br><p>  Dalam dua contoh di bawah ini, kita perlu utas kerja tunggal untuk menjalankan RESTinio dan utas kerja lainnya untuk mensimulasikan pemrosesan permintaan yang panjang.  Dan juga kita perlu semacam antrian pesan untuk mentransfer permintaan dari utas RESTinio ke utas yang bekerja terpisah. </p><br><p>  Tidak mudah bagi saya untuk membuat implementasi antrian pesan thread-safe baru di lutut saya untuk dua contoh ini, jadi saya menggunakan SObjectizer asli saya dan mchainsnya, yang merupakan saluran CSP.  Anda dapat membaca lebih lanjut tentang mchain di sini: " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Pertukaran informasi antara utas yang bekerja tanpa rasa sakit? Saluran CSP untuk membantu kami</a> ." </p><br><h3 id="sohranenie-obekta-request_handle">  Menyimpan objek request_handle </h3><br><p>  Teknik dasar di mana delegasi pemrosesan permintaan dibangun adalah transfer objek <code>request_handle_t</code> suatu tempat. </p><br><p>  Ketika RESTinio memanggil request_handler yang ditentukan oleh pengguna untuk memproses permintaan yang masuk, objek tipe <code>request_handle_t</code> diteruskan ke <code>request_handle_t</code> ini.  Jenis ini tidak lebih dari penunjuk pintar ke parameter permintaan yang diterima.  Jadi jika nyaman bagi seseorang untuk berpikir bahwa <code>request_handle_t</code> adalah <code>shared_ptr</code> , maka Anda dapat dengan aman memikirkannya.  <code>shared_ptr</code> ini adalah. </p><br><p>  Dan karena <code>request_handle_t</code> adalah <code>shared_ptr</code> , kita dapat dengan aman melewatkan pointer pintar ini di suatu tempat.  Apa yang akan kita lakukan dalam contoh di bawah ini. </p><br><p>  Jadi, kami membutuhkan utas dan saluran kerja terpisah untuk berkomunikasi dengannya.  Mari kita buat semuanya: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//  SObjectizer. so_5::wrapped_env_t sobj; //  std::thread    . std::thread processing_thread; //    main      join. //    RAII. auto processing_thread_joiner = so_5::auto_join(processing_thread); //      . auto req_ch = so_5::create_mchain(sobj); //       main. //    RAII. auto ch_closer = so_5::auto_close_drop_content(req_ch); //     . //      main()  - , //     ,      join(). processing_thread = std::thread{ processing_thread_func, req_ch };</span></span></code> </pre> <br><p>  Tubuh dari utas kerja itu sendiri terletak di dalam fungsi <code>processing_thread_func()</code> , yang akan kita bahas nanti. </p><br><p>  Sekarang kami sudah memiliki utas yang terpisah dan saluran untuk berkomunikasi dengannya.  Anda dapat memulai server RESTinio: </p><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ,     . struct traits_t : public restinio::default_traits_t { using logger_t = restinio::shared_ostream_logger_t; }; restinio::run( restinio::on_this_thread&lt;traits_t&gt;() .port(8080) .address("localhost") .request_handler([req_ch](auto req) { //   GET-   . if(restinio::http_method_t::http_get == req-&gt;header().method() &amp;&amp; "/" == req-&gt;header().path()) { //    . so_5::send&lt;handle_request&gt;(req_ch, req); return restinio::request_accepted(); } else return restinio::request_rejected(); }) .cleanup_func([&amp;] { //      . //    , ..  req_ch //          //     . so_5::close_drop_content(req_ch); }));</span></span></code> </pre> <br><p>  Logika untuk server ini sangat sederhana.  Jika permintaan GET telah tiba untuk '/', maka kami mendelegasikan pemrosesan permintaan utas tunggal.  Untuk melakukan ini, kami melakukan dua operasi penting: </p><br><ul><li>  mengirim objek <code>request_handle_t</code> ke saluran CSP.  Sementara objek ini disimpan di dalam saluran CSP atau di tempat lain, RESTinio tahu bahwa permintaan tersebut masih hidup; </li><li>  kami mengembalikan nilai <code>restinio::request_accepted()</code> dari penangan permintaan.  Ini membuat RESTinio mengerti bahwa permintaan telah diterima untuk diproses dan bahwa koneksi dengan klien tidak dapat ditutup. </li></ul><br><p>  Fakta bahwa request_handler tidak segera menghasilkan respons RESTinio tidak mengganggu.  Setelah <code>restinio::request_accepted()</code> dikembalikan, maka pengguna bertanggung jawab untuk memroses permintaan dan suatu hari nanti respons terhadap permintaan akan dihasilkan. </p><br><p>  Jika penangan permintaan mengembalikan <code>restinio::request_rejected()</code> , maka RESTinio memahami bahwa permintaan tidak akan diproses dan akan mengembalikan kesalahan 501 kepada klien. </p><br><p>  Jadi, kami memperbaiki hasil awal: instance <code>request_handle_t</code> dapat dikirimkan di suatu tempat, karena itu, pada kenyataannya, <code>std::shared_ptr</code> .  Saat instance ini aktif, RESTinio menganggap bahwa permintaan sedang diproses.  Jika penangan permintaan mengembalikan <code>restinio::request_accepted()</code> , maka RESTinio tidak akan khawatir bahwa respons terhadap permintaan belum dihasilkan saat ini. </p><br><p>  Sekarang kita bisa melihat implementasi dari utas yang sangat terpisah ini: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">processing_thread_func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(so_5::</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">mchain_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> req_ch)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//       //    . std::random_device rd; std::mt19937 generator{rd()}; std::uniform_int_distribution&lt;&gt; pause_generator{350, 3500}; //      timeout_elapsed. auto delayed_ch = so_5::create_mchain(req_ch-&gt;environment()); //     -  . bool stop = false; select( so_5::from_all() //      . .on_close([&amp;stop](const auto &amp;) { stop = true; }) //     select(). //  select()     . .stop_on([&amp;stop]{ return stop; }), //   handle_request     RESTinio. case_(req_ch, [&amp;](handle_request cmd) { //     . const std::chrono::milliseconds pause{pause_generator(generator)}; //     . so_5::send_delayed&lt;timeout_elapsed&gt;(delayed_ch, //    timeout_elapsed. pause, //      timeout_elapsed. cmd.m_req, pause); }), //   timeout_elapsed. case_(delayed_ch, [](timeout_elapsed cmd) { //     . cmd.m_req-&gt;create_response() .set_body("Hello, World! (pause:" + std::to_string(cmd.m_pause.count()) + "ms)") .done(); }) ); }</span></span></code> </pre> <br><p>  Logikanya di sini sangat sederhana: kami menerima permintaan awal dalam bentuk pesan <code>handle_request</code> dan meneruskannya kepada diri kami sendiri dalam bentuk pesan <code>timeout_elapsed</code> tertunda untuk beberapa waktu acak.  Kami melakukan pemrosesan permintaan yang sebenarnya hanya setelah menerima <code>timeout_elapsed</code> . </p><br><p>  <strong>Pembaruan.</strong>  Ketika metode <code>done()</code> dipanggil pada utas yang terpisah, RESTinio diberi tahu bahwa respons siap pakai telah muncul yang perlu ditulis ke koneksi TCP.  RESTinio memulai operasi penulisan, tetapi operasi I / O itu sendiri tidak akan dieksekusi jika <code>done()</code> dipanggil, tetapi di mana RESTinio melakukan I / O dan memanggil request_handlers.  Yaitu  dalam contoh ini, <code>done()</code> dipanggil pada utas yang terpisah, dan operasi tulis akan dilakukan pada utas utama, di mana <code>restinio::run()</code> berfungsi. </p><br><p>  Pesan-pesan itu sendiri adalah sebagai berikut: </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">handle_request</span></span></span><span class="hljs-class"> {</span></span> restinio::<span class="hljs-keyword"><span class="hljs-keyword">request_handle_t</span></span> m_req; }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">timeout_elapsed</span></span></span><span class="hljs-class"> {</span></span> restinio::<span class="hljs-keyword"><span class="hljs-keyword">request_handle_t</span></span> m_req; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::chrono::milliseconds m_pause; };</code> </pre> <br><p>  Yaitu  utas yang terpisah mengambil <code>request_handle_t</code> dan menyimpannya sampai ada kesempatan untuk membentuk respons yang lengkap.  Dan ketika kesempatan ini muncul, <code>create_response()</code> dipanggil pada objek permintaan tersimpan dan respons dikembalikan ke RESTinio.  Maka RESTinio sudah dalam konteks kerjanya menulis tanggapan sehubungan dengan klien yang sesuai. </p><br><p>  Di sini, instance <code>request_handle_t</code> disimpan dalam pesan tertunda <code>timeout_elapsed</code> , karena tidak ada pemrosesan nyata dalam contoh primitif ini.  Dalam aplikasi nyata, <code>request_handle_t</code> dapat disimpan dalam semacam antrian atau di dalam beberapa objek yang dibuat untuk memproses permintaan. </p><br><p>  Kode lengkap untuk contoh ini dapat ditemukan di <a href="">antara contoh RESTinio biasa</a> . </p><br><h4 id="neskolko-nebolshih-poyasneniy-po-kodu">  Beberapa catatan kode kecil </h4><br><p>  Konstruksi ini menetapkan properti RESTinio yang harus dimiliki oleh server RESTinio: </p><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ,     . struct traits_t : public restinio::default_traits_t { using logger_t = restinio::shared_ostream_logger_t; }; restinio::run( restinio::on_this_thread&lt;traits_t&gt;()</span></span></code> </pre> <br><p>  Untuk contoh ini, saya perlu RESTinio untuk mencatat tindakan pemrosesan permintaannya.  Oleh karena itu, saya mengatur <code>logger_t</code> menjadi berbeda dari <code>null_logger_t</code> default.  Tapi sejak itu  RESTinio akan bekerja, pada kenyataannya, pada beberapa utas (RESTinio memproses permintaan yang masuk pada utas utama, tetapi tanggapan datang darinya dari utas yang bekerja terpisah), maka Anda memerlukan logger yang aman utas, yang digunakan bersama dengan <code>shared_ostream_logger_t</code> . </p><br><p>  Di dalam <code>processing_thread_func()</code> , fungsi SObjectizer <code>select()</code> , yang agak mirip dengan konstruksi Go-shn pilih: Anda dapat membaca dan memproses pesan dari beberapa saluran sekaligus.  Fungsi <code>select()</code> berfungsi sampai semua saluran yang dilewati ditutup.  Atau sampai dia secara paksa diberi tahu bahwa inilah saatnya untuk mengakhiri. </p><br><p>  Pada saat yang sama, jika saluran untuk komunikasi dengan server RESTinio ditutup, maka tidak ada gunanya melanjutkan pekerjaan.  Oleh karena itu, di <code>select()</code> , respons untuk menutup salah satu saluran ditentukan: segera setelah saluran ditutup, bendera berhenti dinaikkan.  Dan ini akan mengarah pada penyelesaian <code>select()</code> dan keluar dari <code>processing_thread_func()</code> . </p><br><h3 id="sohranenie-obekta-response_builder">  Menyimpan objek response_builder </h3><br><p>  Pada contoh sebelumnya, kami mempertimbangkan kasus sederhana saat dimungkinkan untuk menyimpan <code>request_handle_t</code> hingga kami dapat segera memberikan seluruh respons terhadap permintaan tersebut. </p><br><p>  Tetapi mungkin ada skenario yang lebih kompleks ketika, misalnya, Anda perlu memberikan jawaban di bagian.  Artinya, kami menerima permintaan, kami hanya dapat langsung membentuk bagian pertama dari respons.  Kami membentuknya.  Kemudian, setelah beberapa waktu, kami memiliki kesempatan untuk membentuk bagian kedua dari jawaban.  Kemudian, setelah beberapa waktu lagi, kita dapat membentuk bagian selanjutnya, dll. </p><br><p>  Selain itu, mungkin diinginkan bagi kita bahwa semua bagian ini hilang begitu kita membentuknya.  Yaitu  Pertama, bagian pertama dari jawaban sehingga klien dapat mengurangkannya, lalu yang kedua, kemudian yang ketiga, dll. </p><br><p>  RESTinio memungkinkan Anda melakukan ini karena <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">berbagai jenis responsce_builders</a> .  Secara khusus, tipe seperti <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">user_controlled_output</a> dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">chunked_output</a> . </p><br><p>  Dalam hal ini, tidak cukup untuk menyimpan <code>request_handle_t</code> , karena <code>request_handle_t</code> akan berguna sampai panggilan pertama ke <code>create_reponse()</code> .  Selanjutnya kita perlu bekerja dengan response_builder.  Baiklah ... </p><br><p>  Yah, tidak apa-apa.  Response_builder adalah tipe yang dapat dipindahkan, agak mirip dengan unique_ptr.  Jadi kita juga bisa menyimpannya selama kita membutuhkannya.  Dan untuk menunjukkan tampilannya, kami sedikit mengulangi contoh di atas.  Biarkan fungsi <code>processing_thread_func()</code> membentuk respons di bagian-bagian. </p><br><p>  Ini sama sekali tidak sulit. </p><br><p>  Pertama-tama kita perlu memutuskan jenis-jenis yang membutuhkan: </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">handle_request</span></span></span><span class="hljs-class"> {</span></span> restinio::<span class="hljs-keyword"><span class="hljs-keyword">request_handle_t</span></span> m_req; }; <span class="hljs-comment"><span class="hljs-comment">//     . using output_t = restinio::chunked_output_t; //   reponse_builder-   . using response_t = restinio::response_builder_t&lt;output_t&gt;; //     . struct timeout_elapsed { response_t m_resp; int m_counter; };</span></span></code> </pre> <br><p>  Pesan <code>handle_request</code> tetap tidak berubah.  Namun dalam pesan <code>timeout_elapsed</code> kami sekarang menyimpan bukan <code>request_handle_t</code> , tetapi response_builder dari jenis yang kami butuhkan.  Ditambah penghitung dari bagian yang tersisa.  Segera setelah penghitung ini diatur ulang, permintaan layanan akan berakhir. </p><br><p>  Sekarang kita dapat melihat versi baru dari fungsi <code>processing_thread_func()</code> : </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">processing_thread_func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(so_5::</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">mchain_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> req_ch)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::random_device rd; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::mt19937 generator{rd()}; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::uniform_int_distribution&lt;&gt; pause_generator{<span class="hljs-number"><span class="hljs-number">350</span></span>, <span class="hljs-number"><span class="hljs-number">3500</span></span>}; <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> delayed_ch = so_5::create_mchain(req_ch-&gt;environment()); <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> stop = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; select( so_5::from_all() .on_close([&amp;stop](<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> &amp;) { stop = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }) .stop_on([&amp;stop]{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> stop; }), case_(req_ch, [&amp;](handle_request cmd) { <span class="hljs-comment"><span class="hljs-comment">//    ,    . auto resp = cmd.m_req-&gt;create_response&lt;output_t&gt;(); resp.append_header( restinio::http_field::server, "RESTinio" ) .append_header_date_field() .append_header( restinio::http_field::content_type, "text/plain; charset=utf-8" ); //    ,  RESTinio //   . resp.flush(); //       . so_5::send_delayed&lt;so_5::mutable_msg&lt;timeout_elapsed&gt;&gt;(delayed_ch, //     . std::chrono::milliseconds{pause_generator(generator)}, //    timeout_elapsed. //     response_builder-  . std::move(resp), 3); }), case_(delayed_ch, [&amp;](so_5::mutable_mhood_t&lt;timeout_elapsed&gt; cmd) { //      . cmd-&gt;m_resp.append_chunk( "this is the next part of the response\n" ); //  RESTinio   . cmd-&gt;m_resp.flush(); cmd-&gt;m_counter -= 1; if( 0 != cmd-&gt;m_counter ) { //        . so_5::send_delayed( delayed_ch, std::chrono::milliseconds{pause_generator(generator)}, std::move(cmd)); } else // ,   . cmd-&gt;m_resp.done(); }) ); }</span></span></code> </pre> <br><p>  Yaitu     ,        .       .         . </p><br><p> <strong>Upd.</strong>   <code>flush()</code>   ,     <code>done()</code> : RESTinio   ,   I/O-    ,   <code>flush()</code> ,  ,  RESTinio  -   request_handler-.  Yaitu    <code>flush()</code>     ,        , ,   <code>restinio::run()</code> . </p><br><p>       ,    RESTinio    : </p><br><pre> <code class="plaintext hljs">[2019-05-13 15:02:35.106] TRACE: starting server on 127.0.0.1:8080 [2019-05-13 15:02:35.106] INFO: init accept #0 [2019-05-13 15:02:35.106] INFO: server started on 127.0.0.1:8080 [2019-05-13 15:02:39.050] TRACE: accept connection from 127.0.0.1:49280 on socket #0 [2019-05-13 15:02:39.050] TRACE: [connection:1] start connection with 127.0.0.1:49280 [2019-05-13 15:02:39.050] TRACE: [connection:1] start waiting for request [2019-05-13 15:02:39.050] TRACE: [connection:1] continue reading request [2019-05-13 15:02:39.050] TRACE: [connection:1] received 78 bytes [2019-05-13 15:02:39.050] TRACE: [connection:1] request received (#0): GET / [2019-05-13 15:02:39.050] TRACE: [connection:1] append response (#0), flags: { not_final_parts, connection_keepalive }, write group size: 1 [2019-05-13 15:02:39.050] TRACE: [connection:1] start next write group for response (#0), size: 1 [2019-05-13 15:02:39.050] TRACE: [connection:1] start response (#0): HTTP/1.1 200 OK [2019-05-13 15:02:39.050] TRACE: [connection:1] sending resp data, buf count: 1, total size: 167 [2019-05-13 15:02:39.050] TRACE: [connection:1] outgoing data was sent: 167 bytes [2019-05-13 15:02:39.050] TRACE: [connection:1] finishing current write group [2019-05-13 15:02:39.050] TRACE: [connection:1] should keep alive [2019-05-13 15:02:40.190] TRACE: [connection:1] append response (#0), flags: { not_final_parts, connection_keepalive }, write group size: 3 [2019-05-13 15:02:40.190] TRACE: [connection:1] start next write group for response (#0), size: 3 [2019-05-13 15:02:40.190] TRACE: [connection:1] sending resp data, buf count: 3, total size: 42 [2019-05-13 15:02:40.190] TRACE: [connection:1] outgoing data was sent: 42 bytes [2019-05-13 15:02:40.190] TRACE: [connection:1] finishing current write group [2019-05-13 15:02:40.190] TRACE: [connection:1] should keep alive [2019-05-13 15:02:43.542] TRACE: [connection:1] append response (#0), flags: { not_final_parts, connection_keepalive }, write group size: 3 [2019-05-13 15:02:43.542] TRACE: [connection:1] start next write group for response (#0), size: 3 [2019-05-13 15:02:43.542] TRACE: [connection:1] sending resp data, buf count: 3, total size: 42 [2019-05-13 15:02:43.542] TRACE: [connection:1] outgoing data was sent: 42 bytes [2019-05-13 15:02:43.542] TRACE: [connection:1] finishing current write group [2019-05-13 15:02:43.542] TRACE: [connection:1] should keep alive [2019-05-13 15:02:46.297] TRACE: [connection:1] append response (#0), flags: { not_final_parts, connection_keepalive }, write group size: 3 [2019-05-13 15:02:46.297] TRACE: [connection:1] start next write group for response (#0), size: 3 [2019-05-13 15:02:46.297] TRACE: [connection:1] sending resp data, buf count: 3, total size: 42 [2019-05-13 15:02:46.297] TRACE: [connection:1] append response (#0), flags: { final_parts, connection_keepalive }, write group size: 1 [2019-05-13 15:02:46.297] TRACE: [connection:1] outgoing data was sent: 42 bytes [2019-05-13 15:02:46.298] TRACE: [connection:1] finishing current write group [2019-05-13 15:02:46.298] TRACE: [connection:1] should keep alive [2019-05-13 15:02:46.298] TRACE: [connection:1] start next write group for response (#0), size: 1 [2019-05-13 15:02:46.298] TRACE: [connection:1] sending resp data, buf count: 1, total size: 5 [2019-05-13 15:02:46.298] TRACE: [connection:1] outgoing data was sent: 5 bytes [2019-05-13 15:02:46.298] TRACE: [connection:1] finishing current write group [2019-05-13 15:02:46.298] TRACE: [connection:1] should keep alive [2019-05-13 15:02:46.298] TRACE: [connection:1] start waiting for request [2019-05-13 15:02:46.298] TRACE: [connection:1] continue reading request [2019-05-13 15:02:46.298] TRACE: [connection:1] EOF and no request, close connection [2019-05-13 15:02:46.298] TRACE: [connection:1] close [2019-05-13 15:02:46.298] TRACE: [connection:1] close: close socket [2019-05-13 15:02:46.298] TRACE: [connection:1] close: timer canceled [2019-05-13 15:02:46.298] TRACE: [connection:1] close: reset responses data [2019-05-13 15:02:46.298] TRACE: [connection:1] destructor called</code> </pre> <br><p>   ,  RESTinio           167 .          ,           , RESTinio          . </p><br><p>   ,    RESTinio   -     response_builder     ,        . </p><br><p>      .        , ,     .       response_builder   .     ,   responce_builder       ,          .. </p><br><p>      <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="></a> . </p><br><h2 id="chto-budet-esli-obrabotka-zaprosa-zaymet-slishkom-mnogo-vremeni">  ,       ? </h2><br><p> ,   request_handler-     -   .  ,      ,           ? </p><br><p>  RESTinio    ,   -  request_handler-.    - ,     , RESTinio       . ,         . , : </p><br><pre> <code class="plaintext hljs">[2019-05-13 15:32:23.618] TRACE: starting server on 127.0.0.1:8080 [2019-05-13 15:32:23.618] INFO: init accept #0 [2019-05-13 15:32:23.618] INFO: server started on 127.0.0.1:8080 [2019-05-13 15:32:26.768] TRACE: accept connection from 127.0.0.1:49502 on socket #0 [2019-05-13 15:32:26.768] TRACE: [connection:1] start connection with 127.0.0.1:49502 [2019-05-13 15:32:26.768] TRACE: [connection:1] start waiting for request [2019-05-13 15:32:26.768] TRACE: [connection:1] continue reading request [2019-05-13 15:32:26.768] TRACE: [connection:1] received 78 bytes [2019-05-13 15:32:26.768] TRACE: [connection:1] request received (#0): GET / [2019-05-13 15:32:30.768] TRACE: [connection:1] handle request timed out [2019-05-13 15:32:30.768] TRACE: [connection:1] close [2019-05-13 15:32:30.768] TRACE: [connection:1] close: close socket [2019-05-13 15:32:30.768] TRACE: [connection:1] close: timer canceled [2019-05-13 15:32:30.768] TRACE: [connection:1] close: reset responses data [2019-05-13 15:32:31.768] WARN: [connection:1] try to write response, while socket is closed [2019-05-13 15:32:31.768] TRACE: [connection:1] destructor called</code> </pre> <br><p>   -       . ,      ,  RESTinio   , ..     . </p><br><p>   -    <code>handle_request_timeout</code> ,     RESTinio- ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="></a> ). </p><br><h1 id="zaklyuchenie">  Kesimpulan </h1><br><p> ,   ,      RESTinio —   ,   .  ,     RESTinio,    ,        RESTinio,     . </p><br><p>      RESTinio        ,  , ,  :  ? -  ? -  ? - -  ? </p><br><p>  PS.    RESTinio     ,   SObjectizer,    .  ,  -   RESTinio ,     : " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="> C++      HTTP-   </a> ", " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="> HTTP-  C++:   RESTinio,   libcurl.  1</a> ", " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Shrimp:     HTTP    C++  ImageMagic++, SObjectizer  RESTinio</a> " </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id451728/">https://habr.com/ru/post/id451728/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id451718/index.html">Buat Asisten Suara</a></li>
<li><a href="../id451720/index.html">FIAS memuat ke dalam database di MSSQLSERVER dengan cara improvisasi (SQLXMLBULKLOAD). Bagaimana itu (mungkin) tidak perlu dilakukan</a></li>
<li><a href="../id451722/index.html">Qt-async perpustakaan widget asinkron</a></li>
<li><a href="../id451724/index.html">Perselisihan skyrmion ke skyrmion: skyrmion kutub tiga dimensi dalam ferroelastik</a></li>
<li><a href="../id451726/index.html">Mencari pekerjaan di luar negeri: 7 tips sederhana untuk para profesional TI</a></li>
<li><a href="../id451738/index.html">Ulasan singkat dari artikel "DeViSE: Model Penyematan Visual-Semantik Yang Dalam"</a></li>
<li><a href="../id451742/index.html">Satu hari sebelum DotNext 2019 Piter. Pengumuman Siaran Gratis</a></li>
<li><a href="../id451746/index.html">MegaSlerm untuk insinyur dan arsitek Kubernetes</a></li>
<li><a href="../id451748/index.html">Memantau Status SSD di Array Qsan</a></li>
<li><a href="../id451750/index.html">Buku "Elasticsearch, Kibana, Logstash, dan Mesin Pencari Generasi Selanjutnya"</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>