<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ‘©ğŸ»â€ğŸ¨ ğŸ™† ğŸ‘¨ğŸ¾â€ğŸ’¼ Empat tahun pengembangan SObjectizer-5.5. Bagaimana SObjectizer berubah selama waktu ini? ğŸ”¬ ğŸ¤¸ğŸ¿ â•</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Versi pertama SObjectizer dalam kerangka cabang 5.5 dirilis sedikit lebih dari empat tahun yang lalu - pada awal Oktober 2014. Dan hari ini versi beri...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Empat tahun pengembangan SObjectizer-5.5. Bagaimana SObjectizer berubah selama waktu ini?</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/429046/">  Versi pertama SObjectizer dalam kerangka cabang 5.5 dirilis sedikit lebih dari empat tahun yang lalu - pada awal Oktober 2014.  Dan hari ini <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">versi berikutnya dirilis di bawah angka 5.5.23</a> , yang, sangat mungkin, akan menutup sejarah SObjectizer-5.5.  Menurut pendapat saya, ini adalah alasan bagus untuk melihat ke belakang dan melihat apa yang telah dilakukan selama empat tahun terakhir. <br><br>  Pada artikel ini saya akan mencoba menganalisis secara abstrak perubahan dan inovasi yang paling penting dan signifikan: apa yang ditambahkan, mengapa, bagaimana hal itu mempengaruhi SObjectizer itu sendiri atau penggunaannya. <br><br>  Mungkin seseorang akan tertarik pada cerita semacam itu dari sudut pandang arkeologi.  Dan seseorang, mungkin, akan dijauhkan dari petualangan yang meragukan seperti pengembangan kerangka aktor mereka sendiri untuk C ++;) <br><a name="habracut"></a><br><h1>  Sedikit penyimpangan liris tentang peran kompiler C ++ lama </h1><br>  Sejarah SObjectizer-5 dimulai pada pertengahan 2010.  Pada saat yang sama, kami segera fokus pada C ++ 0x.  Sudah pada tahun 2011, versi pertama SObjectizer-5 mulai digunakan untuk menulis kode produksi.  Jelas bahwa kami tidak memiliki kompiler dengan dukungan C ++ 11 yang normal saat itu. <br><br>  Untuk waktu yang lama kami tidak dapat sepenuhnya menggunakan semua fitur "C ++ modern": templat variadic, noexcept, constexpr, dll. Ini tidak bisa lain selain mempengaruhi API SObjectizer.  Dan itu mempengaruhi untuk waktu yang sangat, sangat lama.  Karena itu, jika ketika membaca deskripsi fitur Anda memiliki pertanyaan, "Mengapa belum pernah dilakukan sebelumnya?", Jawaban untuk pertanyaan ini kemungkinan besar: "Karena itu tidak mungkin sebelumnya". <br><br><h1>  Apa yang muncul dan / atau berubah di SObjectizer-5.5 di masa lalu? </h1><br>  Di bagian ini, kita akan membahas sejumlah fitur yang berdampak signifikan pada SObjectizer.  Urutan dalam daftar ini acak dan tidak terkait dengan "signifikansi" atau "bobot" dari fitur yang dijelaskan. <br><br><h2>  Menolak so_5 :: rt namespace </h2><br><h3>  Apa yang terjadi? </h3><br>  Awalnya, di SObjectizer kelima, semua yang terkait dengan runtime SObjectizer didefinisikan di dalam namespace so_5 :: rt.  Sebagai contoh, kami memiliki so_5 :: rt :: environment_t, so_5 :: rt :: agent_t, so_5 :: rt :: message_t, dll.  Apa yang dapat Anda lihat, misalnya, dalam contoh HelloWorld tradisional dari SO-5.5.0: <br><br><pre><code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;so_5/all.hpp&gt; class a_hello_t : public so_5::rt::agent_t { public: a_hello_t( so_5::rt::environment_t &amp; env ) : so_5::rt::agent_t( env ) {} void so_evt_start() override { std::cout &lt;&lt; "Hello, world! This is SObjectizer v.5." &lt;&lt; std::endl; so_environment().stop(); } void so_evt_finish() override { std::cout &lt;&lt; "Bye! This was SObjectizer v.5." &lt;&lt; std::endl; } }; int main() { try { so_5::launch( []( so_5::rt::environment_t &amp; env ) { env.register_agent_as_coop( "coop", new a_hello_t( env ) ); } ); } catch( const std::exception &amp; ex ) { std::cerr &lt;&lt; "Error: " &lt;&lt; ex.what() &lt;&lt; std::endl; return 1; } return 0; }</span></span></span></span></code> </pre> <br>  Singkatan "rt" adalah singkatan dari run-time.  Dan bagi kami tampaknya bahwa catatan "so_5 :: rt" jauh lebih baik dan lebih praktis daripada "so_5 :: runtime". <br><br>  Tetapi ternyata bagi banyak orang â€œrtâ€ hanya â€œreal-timeâ€ dan tidak ada yang lain.  Dan penggunaan "rt" sebagai singkatan untuk "runtime" melanggar perasaan mereka sehingga kadang-kadang pengumuman versi SObjectizer di RuNet berubah menjadi holivar tentang masalah interpretasi "rt" yang diizinkan selain "real-time". <br><br>  Pada akhirnya, kami bosan.  Dan kami hanya membatalkan namespace so_5 :: rt. <br><br><h3>  Apa yang terjadi? </h3><br>  Segala sesuatu yang didefinisikan di dalam "so_5 :: rt" hanya beralih ke "so_5".  Akibatnya, HelloWorld yang sama sekarang terlihat seperti ini: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;so_5/all.hpp&gt; class a_hello_t : public so_5::agent_t { public: a_hello_t( context_t ctx ) : so_5::agent_t( ctx ) {} void so_evt_start() override { std::cout &lt;&lt; "Hello, world! This is SObjectizer v.5 (" &lt;&lt; SO_5_VERSION &lt;&lt; ")" &lt;&lt; std::endl; so_environment().stop(); } void so_evt_finish() override { std::cout &lt;&lt; "Bye! This was SObjectizer v.5." &lt;&lt; std::endl; } }; int main() { try { so_5::launch( []( so_5::environment_t &amp; env ) { env.register_agent_as_coop( "coop", env.make_agent&lt;a_hello_t&gt;() ); } ); } catch( const std::exception &amp; ex ) { std::cerr &lt;&lt; "Error: " &lt;&lt; ex.what() &lt;&lt; std::endl; return 1; } return 0; }</span></span></span></span></code> </pre> <br>  Tetapi nama-nama lama dari "so_5 :: rt" tetap tersedia, melalui yang biasa menggunakan s (typedefs).  Jadi kode yang ditulis untuk versi SO-5.5 pertama juga dapat diterapkan pada versi SO-5.5 terbaru. <br><br>  Akhirnya, namespace so_5 :: rt akan dihapus di versi 5.6. <br><br><h3>  Apa dampaknya? </h3><br>  Mungkin, kode pada SObjectizer sekarang lebih mudah dibaca.  Namun, so_5 :: send () lebih baik dilihat daripada so_5 :: rt :: send (). <br><br>  Nah, di sini, seperti halnya dengan pengembang SObjectizer, sakit kepala telah berkurang.  Ada terlalu banyak obrolan kosong dan alasan yang tidak perlu di sekitar pengumuman SObjectizer pada satu waktu (mulai dari pertanyaan "Mengapa aktor diperlukan di C ++ secara umum" dan berakhir dengan "Mengapa Anda tidak menggunakan PascalCase untuk menamai entitas").  Satu topik yang mudah terbakar menjadi kurang dan itu bagus :) <br><br><h2>  Menyederhanakan pengiriman pesan dan evolusi penangan pesan </h2><br><h3>  Apa yang terjadi? </h3><br>  Bahkan dalam versi pertama SObjectizer-5.5, pesan biasa dikirim menggunakan metode deliver_message, yang harus dipanggil di mbox penerima.  Untuk mengirim pesan yang tertunda atau berkala, perlu memanggil single_timer / schedule_timer pada objek bertipe environment_t.  Dan sudah mengirimkan permintaan sinkron ke agen lain umumnya membutuhkan seluruh rangkaian operasi.  Di sini, misalnya, bagaimana semuanya terlihat empat tahun lalu (std :: make_unique (), yang belum tersedia di C ++ 11, sudah digunakan): <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//   . mbox-&gt;deliver_message(std::make_unique&lt;my_message&gt;(...)); //   . env.single_timer(std::make_unique&lt;my_message&gt;(...), mbox, std::chrono::seconds(2)); //   . auto timer_id = env.schedule_timer( std::make_unique&lt;my_message&gt;(...), mbox, std::chrono::seconds(2), std::chrono::seconds(5)); //         10 . auto reply = mbox-&gt;get_one&lt;std::string&gt;() .wait_for(std::chrono::seconds(10)) .sync_get(std::make_unique&lt;my_message&gt;(...));</span></span></code> </pre><br>  Selain itu, format penangan pesan di SObjectizer telah berevolusi ke versi 5.5.  Jika pada awalnya di SObjectizer-5 semua penangan harus memiliki format: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">evt_handler</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> so_5::</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">event_data_t</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;Msg&gt; &amp; cmd)</span></span></span></span>;</code> </pre> <br>  kemudian beberapa waktu lagi ditambahkan ke format yang diizinkan: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//  ,  Msg --  ,   . ret_value evt_handler(const Msg &amp; msg); ret_value evt_handler(Msg msg); //  ,     . ret_value evt_handler();</span></span></code> </pre><br>  Format handler baru telah banyak digunakan sejak itu  terus-menerus melukis "const so_5 :: event_data_t &lt;Msg&gt; &amp;" masih menyenangkan.  Tetapi, di sisi lain, format yang lebih sederhana tidak bersahabat dengan agen templat.  Sebagai contoh: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Msg_To_Process&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">my_actor</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> so_5::<span class="hljs-keyword"><span class="hljs-keyword">agent_t</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">on_receive</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Msg_To_Process &amp; msg)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// Oops! ... } };</span></span></code> </pre> <br>  Agen templat semacam itu hanya akan berfungsi jika Msg_To_Process adalah tipe pesan, bukan tipe sinyal. <br><br><h3>  Apa yang terjadi? </h3><br>  Di cabang 5.5, keluarga fungsi pengiriman muncul dan berevolusi secara signifikan.  Untuk melakukan ini, pertama, saya harus mendapatkan kompiler pembuangan saya dengan dukungan untuk template variadic.  Dan, kedua, untuk mengakumulasikan pengalaman yang cukup bekerja baik dengan templat variadic secara umum maupun dengan versi send-fungsi yang pertama.  Selain itu, dalam konteks yang berbeda: di agen biasa, dan di agen ad-hoc, dan di agen yang diimplementasikan oleh kelas template, dan agen luar pada umumnya.  Termasuk saat menggunakan fungsi-kirim dengan mchains (mereka akan dibahas di bawah). <br><br>  Selain mengirim fungsi, fungsi request_future / request_value muncul, yang dirancang untuk interaksi sinkron antara agen. <br><br>  Akibatnya, sekarang mengirim pesan adalah sebagai berikut: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//   . so_5::send&lt;my_message&gt;(mbox, ...); //   . so_5::send_delayed&lt;my_message&gt;(env, mbox, std::chrono::seconds(2), ...); //   . auto timer_id = so_5::send_periodic&lt;my_message&gt;( env, mbox, std::chrono::seconds(2), std::chrono::seconds(5), ...); //         10 . auto reply =so_5::request_value&lt;std::string, my_message&gt;(mbox, std::chrono::seconds(10), ...);</span></span></code> </pre> <br>  Format lain yang mungkin untuk penangan pesan telah ditambahkan.  Selain itu, format inilah yang akan dibiarkan dalam rilis utama berikutnya dari SObjectizer sebagai yang utama (dan, mungkin, satu-satunya).  Ini adalah format berikut: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">ret_type </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">evt_handler</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(so_5::</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">mhood_t</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;Msg&gt; cmd)</span></span></span></span>;</code> </pre> <br>  Di mana Msg dapat berupa tipe pesan atau tipe sinyal. <br><br>  Format ini tidak hanya mengaburkan garis antara agen dalam bentuk kelas biasa dan agen dalam bentuk kelas template.  Tetapi itu juga menyederhanakan penerusan pesan / sinyal (terima kasih kepada keluarga fungsi pengirim): <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> my_agent::on_msg(<span class="hljs-keyword"><span class="hljs-keyword">mhood_t</span></span>&lt;Some_Msg&gt; cmd) { ... <span class="hljs-comment"><span class="hljs-comment">// -  . //       . so_5::send(another_agent, std::move(cmd)); }</span></span></code> </pre> <br><h3>  Apa dampaknya? </h3><br>  Munculnya fungsi pengirim dan penangan pesan yang menerima mhood_t &lt;Msg&gt;, dapat kita katakan, secara mendasar mengubah kode di mana pesan dikirim dan diproses.  Ini hanya kasus ketika itu hanya menyesal bahwa pada awal bekerja pada SObjectizer-5 kami tidak memiliki kompiler dengan dukungan templat variadic, atau pengalaman dalam menggunakannya.  Keluarga fungsi kirim dan mhood_t seharusnya sudah dari awal.  Tetapi sejarah telah berkembang karena telah berkembang ... <br><br><h2>  Dukungan untuk jenis pesan khusus </h2><br><h3>  Apa yang terjadi? </h3><br>  Awalnya, semua pesan yang dikirim seharusnya adalah kelas turunan dari kelas so_5 :: message_t.  Sebagai contoh: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">my_message</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> so_5::<span class="hljs-keyword"><span class="hljs-keyword">message_t</span></span> { ... <span class="hljs-comment"><span class="hljs-comment">//  my_message. my_message(...) : ... {...} //   my_message. };</span></span></code> </pre> <br>  Meskipun SObjectizer kelima hanya digunakan oleh kami sendiri, ini tidak menimbulkan pertanyaan.  Nah, seperti ini dan seperti itu. <br><br>  Tapi begitu pengguna pihak ketiga mulai tertarik pada SObjectizer, kami langsung menemukan pertanyaan yang berulang: "Haruskah saya mewarisi pesan dari so_5 :: message_t?"  Masalah ini sangat relevan dalam situasi di mana perlu untuk mengirim objek jenis sebagai pesan yang tidak dapat memengaruhi pengguna sama sekali.  Katakanlah pengguna menggunakan SObjectizer dan beberapa perpustakaan eksternal lainnya.  Dan di perpustakaan eksternal ini ada tipe M tertentu, objek yang ingin dikirim pengguna sebagai pesan.  Nah dan bagaimana dalam kondisi seperti itu membuat teman mengetik M dan so_5 :: message_t?  Hanya pembungkus tambahan yang harus ditulis pengguna secara manual. <br><br><h3>  Apa yang terjadi? </h3><br>  Kami telah menambahkan kemampuan untuk mengirim pesan ke SObjectizer-5.5 bahkan jika jenis pesan tidak diwarisi dari so_5 :: message_t.  Yaitu  Sekarang pengguna dapat dengan mudah menulis: <br><br><pre> <code class="cpp hljs">so_5::send&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&gt;(mbox, <span class="hljs-string"><span class="hljs-string">"Hello, World!"</span></span>);</code> </pre> <br>  Lagipula, So_5 :: message_t tetap berada di bawah kap, hanya karena templat magic send () memahami bahwa std :: string tidak diwarisi dari so_5 :: message_t dan bukan std sederhana :: string dibangun di dalam send, tetapi pewaris khusus dari so_5 :: message_t, di dalamnya std :: string yang diinginkan pengguna telah ditemukan. <br><br>  Magic template yang sama berlaku untuk langganan.  Ketika SObjectizer melihat penangan pesan dari formulir: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">evt_handler</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">mhood_t</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt; cmd)</span></span></span><span class="hljs-function"> </span></span>{...}</code> </pre> <br>  kemudian SObjectizer memahami bahwa sebenarnya sebuah pesan khusus akan datang dengan std :: string object di dalamnya.  Dan apa yang Anda butuhkan untuk memanggil pawang dengan memberikan tautan ke std :: string dari pesan khusus ini. <br><br><h3>  Apa dampaknya? </h3><br>  Menggunakan SObjectizer menjadi lebih mudah, terutama ketika Anda harus mengirim tidak hanya objek dari tipe Anda sendiri sebagai pesan, tetapi juga mengetik objek dari perpustakaan eksternal.  Beberapa orang bahkan meluangkan waktu untuk mengucapkan terima kasih khusus untuk fitur ini. <br><br><h2>  Pesan yang bisa diubah </h2><br><h3>  Apa yang terjadi? </h3><br>  Awalnya, dalam SObjectizer-5, hanya model interaksi 1: N yang digunakan.  Yaitu  pesan terkirim dapat memiliki lebih dari satu penerima (atau mungkin ada lebih dari satu).  Sekalipun agen perlu berinteraksi dalam mode 1: 1, mereka masih berkomunikasi melalui kotak pesan multi-produsen / multi-konsumen.  Yaitu  dalam mode 1: N, hanya N dalam hal ini adalah sebuah unit. <br><br>  Dalam kondisi di mana pesan dapat diterima oleh lebih dari satu agen penerima, pesan yang dikirim harus tidak berubah.  Itulah sebabnya penangan pesan memiliki format berikut: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//       . ret_type evt_handler(const event_data_t&lt;Msg&gt; &amp; cmd); //       . ret_type evt_handler(const Msg &amp; msg); //    . //        . ret_type evt_handler(Msg msg);</span></span></code> </pre> <br>  Secara umum, pendekatan yang sederhana dan mudah dimengerti.  Namun, itu tidak terlalu nyaman ketika agen perlu berkomunikasi satu sama lain dalam mode 1: 1 dan, misalnya, mentransfer kepemilikan beberapa data satu sama lain.  Katakanlah bahwa pesan sederhana seperti itu tidak dapat dibuat jika semua pesan benar-benar benda yang tidak dapat diubah: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">process_image</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> so_5::<span class="hljs-keyword"><span class="hljs-keyword">message_t</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">unique_ptr</span></span>&lt;gif_image&gt; image_; process_image(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">unique_ptr</span></span>&lt;gif_image&gt; image) : image_{<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(image)) {} };</code> </pre> <br>  Lebih tepatnya, pesan seperti itu dapat dikirim.  Tetapi setelah menerimanya sebagai objek konstan, itu tidak akan mungkin untuk menghapus konten process_image :: image_ ke dirinya sendiri.  Saya harus menandai atribut seperti itu bisa berubah.  Tetapi kemudian kita akan kehilangan kendali dari kompiler jika process_image karena suatu alasan dikirim dalam mode 1: N. <br><br><h3>  Apa yang terjadi? </h3><br>  Dalam SObjectizer-5.5, kemampuan untuk mengirim dan menerima pesan yang dapat diubah telah ditambahkan.  Pada saat yang sama, pengguna harus secara khusus menandai pesan tersebut saat mengirim dan ketika berlangganan. <br><br>  Sebagai contoh: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//    . so_5::send&lt;my_message&gt;(mbox, ...); //     my_message. so_5::send&lt;so_5::mutable_msg&lt;my_message&gt;&gt;(mbox, ...); ... //     . void my_agent::on_some_event(mhood_t&lt;my_message&gt; cmd) {...} //      my_message. void my_agent::on_another_event(mhood_t&lt;so_5::mutable_msg&lt;my_message&gt;&gt; cmd) {...}</span></span></code> </pre><br>  Untuk SObjectizer, my_message dan mutable_msg &lt;my_message&gt; adalah dua jenis pesan yang berbeda. <br><br>  Ketika fungsi kirim melihat bahwa ia diminta untuk mengirim pesan yang bisa diubah, fungsi kirim memeriksa untuk melihat kotak surat yang mereka coba kirimi pesan.  Jika ini adalah kotak multi-konsumen, maka pengiriman tidak dilakukan, tetapi pengecualian dilemparkan dengan kode kesalahan yang sesuai.  Yaitu  SObjectizer memastikan bahwa pesan yang dapat diubah hanya dapat digunakan ketika berinteraksi dalam mode 1: 1 (melalui kotak surat atau konsumen tunggal, yang merupakan bentuk kotak surat konsumen tunggal).  Omong-omong, untuk memberikan jaminan ini, SObjectizer melarang pengiriman pesan yang bisa berubah dalam bentuk pesan berkala. <br><br><h3>  Apa dampaknya? </h3><br>  Dengan pesan yang bisa berubah, ternyata secara tak terduga.  Kami menambahkannya ke SObjectizer sebagai hasil dari diskusi di sela-sela <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">laporan tentang SObjectizer di C ++ Russia-2017</a> .  Dengan perasaan, "Yah, jika mereka bertanya, maka seseorang membutuhkannya, jadi patut dicoba."  Ya, mereka melakukannya tanpa banyak harapan akan permintaan yang meluas.  Meskipun untuk ini saya harus "merokok bambu" untuk waktu yang sangat lama sebelum saya memikirkan cara menambahkan pesan yang bisa diubah ke SO-5.5 tanpa merusak kompatibilitas. <br><br>  Tetapi ketika pesan yang bisa diubah muncul di SObjectizer, ternyata tidak ada begitu sedikit aplikasi untuk mereka.  Dan pesan yang bisa berubah itu sering digunakan secara mengejutkan (penyebutan ini dapat ditemukan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">di bagian kedua dari cerita tentang proyek demo Udang</a> ).  Jadi dalam prakteknya, fitur ini lebih berguna, karena  ini memungkinkan Anda untuk memecahkan masalah yang tanpa dukungan pesan yang dapat diubah di tingkat SObjectizer, mereka tidak memiliki solusi normal. <br><br><h2>  Agen mesin negara hierarkis </h2><br><h3>  Apa yang terjadi? </h3><br>  Agen di SObjectizer pada awalnya adalah mesin negara.  Agen harus secara eksplisit menggambarkan negara bagian dan berlangganan pesan di negara bagian tertentu. <br>  Sebagai contoh: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">worker</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> so_5::<span class="hljs-keyword"><span class="hljs-keyword">agent_t</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">state_t</span></span> st_free{<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, <span class="hljs-string"><span class="hljs-string">"free"</span></span>}; <span class="hljs-keyword"><span class="hljs-keyword">state_t</span></span> st_bufy{<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, <span class="hljs-string"><span class="hljs-string">"busy"</span></span>}; ... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">so_define_agent</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> override </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//     st_free. so_subscribe(mbox).in(st_free).event(...); //     st_busy. so_subscribe(mbox).in(st_busy).event(...); ... } };</span></span></code> </pre> <br>  Tapi ini adalah mesin negara sederhana.  Negara tidak bisa saling bersarang.  Tidak ada dukungan untuk penangan masuk dan keluar negara.  Tidak ada batasan waktu yang dihabiskan di negara bagian. <br><br>  Bahkan dukungan terbatas seperti itu untuk mesin negara sangat mudah dan kami menggunakannya selama lebih dari satu tahun.  Tetapi pada satu titik, kami menginginkan lebih. <br><br><h3>  Apa yang terjadi? </h3><br>  SObjectizer memperkenalkan dukungan untuk mesin status hierarkis. <br><br>  Sekarang negara dapat bersarang satu sama lain.  Penangan acara dari negara induk secara otomatis "diwarisi" oleh negara anak. <br><br>  Penangan untuk memasuki dan keluar dari negara didukung. <br><br>  Dimungkinkan untuk menetapkan batas waktu agen tetap di negara. <br><br>  Dimungkinkan untuk menyimpan sejarah bagi negara. <br><br>  Agar tidak berdasar, berikut adalah contoh agen yang bukan mesin status hierarkis kompleks (kode dari contoh standar blinking_led): <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">blinking_led</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">final</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> so_5::<span class="hljs-keyword"><span class="hljs-keyword">agent_t</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">state_t</span></span> off{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span> }, blinking{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span> }, blink_on{ initial_substate_of{ blinking } }, blink_off{ substate_of{ blinking } }; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> : <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">turn_on_off</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">final</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> so_5::<span class="hljs-keyword"><span class="hljs-keyword">signal_t</span></span> {}; blinking_led( <span class="hljs-keyword"><span class="hljs-keyword">context_t</span></span> ctx ) : so_5::<span class="hljs-keyword"><span class="hljs-keyword">agent_t</span></span>{ ctx } { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span> &gt;&gt;= off; off.just_switch_to&lt; turn_on_off &gt;( blinking ); blinking.just_switch_to&lt; turn_on_off &gt;( off ); blink_on .on_enter( []{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"ON"</span></span> &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; } ) .on_exit( []{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"off"</span></span> &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; } ) .time_limit( <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::chrono::milliseconds{<span class="hljs-number"><span class="hljs-number">1250</span></span>}, blink_off ); blink_off .time_limit( <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::chrono::milliseconds{<span class="hljs-number"><span class="hljs-number">750</span></span>}, blink_on ); } };</code> </pre> <br>  Kami telah menggambarkan semua ini <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dalam artikel terpisah</a> , tidak perlu mengulanginya. <br><br>  Saat ini tidak ada dukungan untuk negara ortogonal.  Tetapi fakta ini memiliki dua penjelasan.  Pertama, kami mencoba membuat dukungan ini dan menghadapi sejumlah kesulitan, yang menurut kami terlalu mahal.  Dan, kedua, belum ada yang meminta status orthogonal.  Ketika ditanya, lalu kembali ke topik ini. <br><br><h3>  Apa dampaknya? </h3><br>  Ada perasaan bahwa ini sangat serius (walaupun kita di sini, tentu saja, subyektif dan bias).  Lagi pula, itu adalah satu hal ketika, ketika dihadapkan dengan mesin negara terbatas yang kompleks di bidang subjek, Anda mulai mencari solusi, menyederhanakan sesuatu, mengeluarkan kekuatan ekstra untuk sesuatu.  Dan masalah yang sama sekali berbeda ketika Anda dapat memetakan objek dari aplikasi Anda ke kode C ++ hampir 1-in-1. <br><br>  Selain itu, menilai dari pertanyaan yang diajukan, misalnya, oleh perilaku penangan input / output dalam / luar negara, fungsi ini digunakan. <br><br><h2>  mchain </h2><br><h3>  Apa yang terjadi? </h3><br>  Itu adalah situasi yang menarik.  SObjectizer sering digunakan sehingga hanya sebagian dari aplikasi yang ditulis dalam SObjectizer.  Sisa kode dalam aplikasi tidak ada hubungannya dengan aktor pada umumnya, atau dengan SObjectizer pada khususnya.  Misalnya, aplikasi GUI di mana SObjectizer digunakan untuk beberapa tugas latar belakang, sedangkan pekerjaan utama dilakukan pada utas utama aplikasi. <br><br>  Dan dalam kasus seperti itu, ternyata dari bagian non-SObjectizer ke bagian SObjectizer, pengiriman informasi sesederhana sederhana: cukup untuk memanggil fungsi pengiriman biasa.  Tetapi penyebaran informasi dalam arah yang berlawanan tidak begitu sederhana.  Tampaknya bagi kami bahwa ini tidak baik dan Anda harus memiliki beberapa saluran komunikasi yang nyaman antara bagian-bagian SObjectizer dari aplikasi dan bagian-bagian non-SObjectizer langsung di luar kotak. <br><br><h3>  Apa yang terjadi? </h3><br>  Jadi, rantai pesan atau, dalam notasi yang lebih akrab, mochains muncul di SObjectizer. <br><br>  Mchain adalah varian spesifik dari kotak surat konsumen tunggal tempat pesan dikirim oleh fungsi pengiriman biasa.  Tetapi untuk mengekstrak pesan dari mchain, Anda tidak perlu membuat agen dan menandatanganinya.  Ada dua fungsi khusus yang bisa disebut agen bahkan di dalam, bahkan agen luar: accept () dan select ().  Yang pertama membaca pesan hanya dari satu saluran, sedangkan yang kedua dapat membaca pesan dari beberapa saluran sekaligus: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> <span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> so_5; <span class="hljs-keyword"><span class="hljs-keyword">mchain_t</span></span> ch1 = env.create_mchain(...); <span class="hljs-keyword"><span class="hljs-keyword">mchain_t</span></span> ch2 = env.create_mchain(...); select( from_all().handle_n(<span class="hljs-number"><span class="hljs-number">3</span></span>).empty_timeout(<span class="hljs-number"><span class="hljs-number">200</span></span>ms), case_(ch1, [](<span class="hljs-keyword"><span class="hljs-keyword">mhood_t</span></span>&lt;first_message_type&gt; msg) { ... }, [](<span class="hljs-keyword"><span class="hljs-keyword">mhood_t</span></span>&lt;second_message_type&gt; msg) { ... }), case_(ch2, [](<span class="hljs-keyword"><span class="hljs-keyword">mhood_t</span></span>&lt;third_message_type&gt; msg ) { ... }, [](<span class="hljs-keyword"><span class="hljs-keyword">mhood_t</span></span>&lt;some_signal_type&gt;){...}, ... ));</code> </pre> <br>  Kami telah berbicara tentang mchain beberapa kali di sini: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pada Agustus 2017</a> dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Mei 2018</a> .  Oleh karena itu, terutama pada topik bagaimana bekerja dengan mchains terlihat, kami tidak akan masuk lebih dalam di sini. <br><br><h3>  Apa dampaknya? </h3><br>  Setelah kemunculan mchains di SObjectizer-5.5, ternyata SObjectizer, pada kenyataannya, menjadi kerangka kerja "aktor" yang bahkan lebih sedikit daripada sebelumnya.  Selain mendukung Model Aktor dan Pub / Sub, SObjectizer juga menambahkan dukungan untuk model CSP (mengkomunikasikan proses sekuensial).  Mchains memungkinkan Anda untuk mengembangkan aplikasi multi-utas yang cukup rumit pada SObjectizer tanpa aktor sama sekali.  Dan untuk beberapa tugas ini lebih dari nyaman.  Apa yang kita sendiri gunakan dari waktu ke waktu. <br><br><h2>  Mekanisme batas pesan </h2><br><h3>  Apa yang terjadi? </h3><br>  Salah satu kekurangan paling serius dari Model Aktor adalah kecenderungannya untuk kelebihan beban.  Sangat mudah untuk menemukan diri Anda dalam situasi di mana aktor pengirim mengirim pesan ke aktor penerima dengan kecepatan lebih cepat daripada aktor penerima dapat memproses pesan. <br><br>  Sebagai aturan, mengirim pesan dalam kerangka aktor adalah operasi non-pemblokiran.  Karena itu, ketika sepasang "nimble-produser dan kutu buku-konsumen" terjadi, antrian aktor penerima akan meningkat sementara setidaknya ada beberapa jenis memori bebas. <br><br>  Kesulitan utama dari masalah ini adalah bahwa mekanisme perlindungan yang baik terhadap kelebihan beban harus dipertajam untuk tugas yang diterapkan dan karakteristik area subjek.  Misalnya, untuk memahami pesan mana yang dapat digandakan (dan karenanya dapat dengan aman membuang duplikat).  Untuk memahami pesan mana yang tidak bisa dibuang.  Siapa yang bisa diskors dan berapa banyak, dan siapa yang tidak diizinkan sama sekali.  Dll, dll. <br><br>  Kesulitan lain adalah tidak selalu perlu memiliki mekanisme pertahanan yang baik.  Terkadang, cukup memiliki sesuatu yang primitif, tetapi efektif, dapat diakses "di luar kotak" dan mudah digunakan.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Agar tidak memaksa pengguna untuk melakukan kontrol yang berlebihan di mana cukup dengan hanya membuang "ekstra" pesan atau meneruskan pesan ini ke agen lain. </font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Apa yang terjadi? </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hanya agar dalam skenario sederhana Anda dapat menggunakan alat perlindungan kelebihan beban yang sudah jadi, yang disebut </font><font style="vertical-align: inherit;">batas pesan. </font><font style="vertical-align: inherit;">Mekanisme ini memungkinkan Anda untuk membuang pesan yang tidak perlu, atau mengirimnya ke penerima lain, atau bahkan cukup mengganggu aplikasi jika batas terlampaui.</font></font> Sebagai contoh: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">worker</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> so_5::<span class="hljs-keyword"><span class="hljs-keyword">agent_t</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: worker(<span class="hljs-keyword"><span class="hljs-keyword">context_t</span></span> ctx) : so_5::<span class="hljs-keyword"><span class="hljs-keyword">agent_t</span></span>{ ctx <span class="hljs-comment"><span class="hljs-comment">//     100  handle_data, //      //  . + limit_then_redirect&lt;handle_data&gt;(100, [this]{ return another_worker_;}) //     1  check_status, //       . + limit_then_drop&lt;check_status&gt;(1) //     1  reconfigure, //     , ..  reconfigure //        . + limit_then_abore&lt;reconfigure&gt;(1) } {...} ... };</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Topik ini dijelaskan secara lebih rinci </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dalam artikel terpisah</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Apa dampaknya? </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ini bukan untuk mengatakan bahwa munculnya batas-batas pesan telah menjadi sesuatu yang telah secara mendasar mengubah SObjectizer, prinsip-prinsip pekerjaannya atau bekerja dengannya. </font><font style="vertical-align: inherit;">Sebaliknya, itu dapat dibandingkan dengan parasut cadangan, yang hanya digunakan sebagai pilihan terakhir. </font><font style="vertical-align: inherit;">Tetapi ketika Anda harus menggunakannya, Anda senang bahwa itu ada.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Mekanisme penelusuran pengiriman pesan </font></font></h2><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Apa yang terjadi? </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SObjectizer-5 adalah kotak hitam untuk pengembang. Di mana pesan dikirim dan ... Dan itu datang ke penerima, atau tidak datang. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jika pesan tidak mencapai penerima, maka pengguna dihadapkan dengan kebutuhan untuk melakukan pencarian yang menarik untuk mencari alasan. Dalam kebanyakan kasus, alasannya sepele: pesan dikirim ke mbox yang salah, atau langganan tidak dibuat (misalnya, pengguna membuat langganan dalam satu kondisi agen, tetapi lupa melakukannya di tempat lain). Tetapi mungkin ada kasus yang lebih kompleks ketika sebuah pesan, misalnya, ditolak oleh mekanisme perlindungan yang berlebihan.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Masalahnya adalah bahwa mekanisme pengiriman pesan tersembunyi jauh di dalam jeroan ayam itik dari SObjectizer Run-Time dan, oleh karena itu, bahkan sulit bagi pengembang SObjectizer untuk merutekan pesan ke penerima, belum lagi pengguna. </font><font style="vertical-align: inherit;">Terutama tentang pengguna pemula yang melakukan kesalahan sepele seperti itu.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Apa yang terjadi? </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dalam SObjectizer-5.5, mekanisme khusus untuk melacak proses pengiriman pesan yang disebut pelacakan pengiriman pesan (atau hanya msg_tracing) ditambahkan, dan kemudian diselesaikan. </font><font style="vertical-align: inherit;">Mekanisme ini dan kemampuannya dijelaskan secara lebih rinci dalam </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">artikel terpisah</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jadi sekarang, jika pesan hilang saat pengiriman, Anda cukup mengaktifkan msg_tracing dan lihat mengapa ini terjadi.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Apa dampaknya? </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aplikasi debug yang ditulis dalam SObjectizer menjadi lebih sederhana dan lebih menyenangkan. </font><font style="vertical-align: inherit;">Bahkan </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">untuk diri kita sendiri</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Konsep env_infrastructure dan env_infrastructure single-threaded </font></font></h2><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Apa yang terjadi? </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kami selalu menganggap SObjectizer sebagai alat untuk menyederhanakan pengembangan kode multi-utas. </font><font style="vertical-align: inherit;">Oleh karena itu, versi pertama SObjectizer-5 ditulis hanya untuk bekerja di lingkungan multi-utas. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ini dinyatakan sebagai penggunaan sinkronisasi primer di dalam SObjectizer untuk melindungi internal SObjectizer ketika bekerja di lingkungan multi-threaded. </font><font style="vertical-align: inherit;">Demikian juga dalam membuat beberapa utas kerja tambahan di dalam SObjectizer itu sendiri (untuk melakukan operasi penting seperti memperbaiki timer dan menyelesaikan deregistrasi kerjasama agen).</font></font><br><br>  Yaitu<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SObjectizer dibuat untuk pemrograman multi-utas dan untuk digunakan dalam lingkungan multi-utas. </font><font style="vertical-align: inherit;">Dan itu sangat cocok bagi kami. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Namun, karena SObjectizer digunakan "di alam liar", situasi ditemukan di mana tugas itu cukup sulit untuk menggunakan aktor dalam solusinya. </font><font style="vertical-align: inherit;">Tetapi, pada saat yang sama, semua pekerjaan dapat dan, terlebih lagi, harus dilakukan pada satu alur kerja tunggal. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dan kami menghadapi masalah yang sangat menarik: apakah mungkin mengajarkan SObjectizer untuk bekerja pada satu utas kerja?</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Apa yang terjadi? </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ternyata itu mungkin. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kami menghabiskan banyak uang, butuh banyak waktu dan upaya untuk menemukan solusi. </font><font style="vertical-align: inherit;">Tetapi solusinya ditemukan. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Suatu konsep seperti infrastruktur lingkungan diperkenalkan (atau env_infrastructure dalam bentuk yang sedikit disingkat). </font><font style="vertical-align: inherit;">Env_infrastructure mengambil tugas mengelola dapur SObjectizer internal. </font><font style="vertical-align: inherit;">Secara khusus, ia memecahkan masalah-masalah seperti timer servis, melakukan registrasi dan deregistrasi koperasi. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Untuk SObjectizer, beberapa opsi env_infrastructures single-threaded telah dibuat. </font><font style="vertical-align: inherit;">Ini memungkinkan kami untuk mengembangkan aplikasi single-threaded pada SObjectizer, yang di dalamnya terdapat agen normal yang saling bertukar pesan reguler satu sama lain. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kami berbicara tentang fungsi ini </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;">secara lebih</font></a><font style="vertical-align: inherit;"> rinci </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">di artikel terpisah.</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Apa dampaknya? </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mungkin hal terpenting yang terjadi selama implementasi fitur ini adalah kerusakan templat kita sendiri. </font><font style="vertical-align: inherit;">Melihat SObjectizer tidak akan pernah sama. </font><font style="vertical-align: inherit;">Bertahun-tahun untuk mempertimbangkan SObjectizer </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">secara eksklusif</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> sebagai alat untuk mengembangkan kode multithreaded. </font><font style="vertical-align: inherit;">Dan lagi! </font><font style="vertical-align: inherit;">Dan menemukan bahwa kode single-threaded pada SObjectizer juga dapat dikembangkan. </font><font style="vertical-align: inherit;">Hidup ini penuh kejutan.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Alat pemantauan run-time </font></font></h2><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Apa yang terjadi? </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SObjectizer-5 adalah kotak hitam tidak hanya dalam hal mekanisme pengiriman pesan. </font><font style="vertical-align: inherit;">Tetapi juga tidak ada cara untuk mengetahui berapa banyak agen yang saat ini bekerja di dalam aplikasi, berapa banyak dan yang dispatcher dibuat, berapa banyak thread kerja yang terlibat, berapa banyak pesan yang menunggu dalam antrian dispatcher, dll. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Semua informasi ini sangat berguna untuk memonitor aplikasi yang beroperasi 24/7. </font><font style="vertical-align: inherit;">Tetapi untuk debugging, saya juga ingin memahami dari waktu ke waktu apakah antrian bertambah atau jumlah agen bertambah / berkurang. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sayangnya, untuk saat ini, tangan kami sama sekali tidak mencapai titik menambahkan dana ke SObjectizer untuk mengumpulkan dan menyebarkan informasi tersebut.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Apa yang terjadi? </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pada satu titik </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">di SObjectizer-5.5, alat muncul untuk run-time memantau internal SObjectizer</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Secara default, pemantauan run-time dinonaktifkan, tetapi jika Anda mengaktifkannya, maka pesan akan dikirim ke mbox khusus secara teratur, di dalamnya akan ada informasi tentang jumlah agen dan kerjasama, tentang jumlah timer, tentang thread kerja yang dimiliki oleh dispatcher (dan sudah akan ada informasi tentang jumlah pesan dalam antrian, jumlah agen yang diikat ke utas ini). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Selain itu, seiring berjalannya waktu, dimungkinkan untuk memungkinkan pengumpulan informasi tambahan tentang berapa banyak waktu yang dihabiskan agen di dalam event handler. </font><font style="vertical-align: inherit;">Ini memungkinkan Anda untuk mendeteksi situasi ketika beberapa agen terlalu lambat (atau membuang-buang waktu untuk memblokir panggilan).</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Apa dampaknya? </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dalam praktik kami, pemantauan run-time tidak sering digunakan. </font><font style="vertical-align: inherit;">Tetapi ketika Anda membutuhkannya, maka Anda menyadari pentingnya hal itu. </font><font style="vertical-align: inherit;">Memang, tanpa mekanisme seperti itu tidak mungkin (baik, atau sangat sulit) untuk mencari tahu apa dan bagaimana tidak bekerja. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jadi ini adalah fitur dari kategori "Anda bisa melakukannya", tetapi keberadaannya, menurut pendapat kami, segera mentransfer instrumen ke kategori bobot lain.</font></font> Karena<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">membuat prototipe kerangka aktor "di lutut" tidak begitu sulit. </font><font style="vertical-align: inherit;">Banyak yang telah melakukan ini dan banyak lagi yang akan melakukannya. </font><font style="vertical-align: inherit;">Tetapi kemudian untuk melengkapi perkembangan Anda dengan hal seperti pemantauan run-time ... Saat ini, tidak semua draft berlutut bertahan.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Dan satu hal lagi dalam satu baris </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Selama empat tahun, SObjectizer-5.5 telah mendapat banyak inovasi dan perubahan, deskripsi yang, bahkan dalam sinopsisnya, akan memakan terlalu banyak ruang. Oleh karena itu, kami menyatakan bagian dari mereka dengan satu baris. Secara acak, tanpa prioritas. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SObjectizer-5.5 menambahkan dukungan untuk sistem build CMake. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sekarang SObjectizer-5 dapat dibangun baik sebagai perpustakaan dinamis maupun statis. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SObjectizer-5.5 sekarang dibangun dan berjalan di Android (baik melalui </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CrystaX NDK</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , dan melalui Android NDK segar). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dispatcher pribadi telah muncul. Sekarang Anda dapat membuat dan menggunakan dispatcher yang tidak dilihat orang lain.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Menerapkan mekanisme filter pengiriman. Sekarang, ketika berlangganan pesan dari MPMC-mboxes, Anda dapat melarang pengiriman pesan yang isinya tidak Anda sukai. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Alat untuk membuat dan mendaftarkan kerja sama telah disederhanakan secara signifikan: metode memperkenalkan_coop / memperkenalkan_child_coop, make_agent / make_agent_with_binder dan itu saja. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Konsep pabrik objek kunci muncul dan sekarang Anda dapat memilih objek kunci yang Anda butuhkan (berdasarkan pada mutex, spinlock, gabungan, atau lainnya). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kelas wrap_env_t telah muncul dan sekarang Anda dapat menjalankan SObjectizer di aplikasi Anda tidak hanya dengan so_5 :: launch ().</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Konsep stop_guards muncul dan sekarang Anda dapat memengaruhi proses mematikan SObjectizer. </font><font style="vertical-align: inherit;">Misalnya, Anda dapat mencegah SObjectizer berhenti sampai beberapa agen menyelesaikan pekerjaan aplikasinya. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sekarang Anda dapat mencegat pesan yang dikirim ke agen tetapi tidak diproses oleh agen (yang disebut dead_letter_handlers). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ada kesempatan untuk membungkus pesan dalam "amplop" khusus. </font><font style="vertical-align: inherit;">Amplop dapat membawa informasi tambahan tentang pesan dan dapat melakukan beberapa tindakan saat pesan dikirim ke penerima.</font></font><br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 5.5.0 hingga 5.5.23 dalam angka </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Menarik juga untuk melihat jalur yang dibuat dalam hal kode / tes / contoh. </font><font style="vertical-align: inherit;">Inilah yang dikatakan utilitas cloc tentang jumlah kode kernel SObjectizer-5.5.0:</font></font><br><br><pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -------------------------------------------------- -----------------------------</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
File bahasa kosong kode komentar</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
-------------------------------------------------- -----------------------------</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
C / C ++ Header 58 2119 5156 5762</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
C ++ 39 1167 779 4759</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ruby 2 30 2 75</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
-------------------------------------------------- -----------------------------</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SUM: 99 3316 5937 10596</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
-------------------------------------------------- -----------------------------</font></font><font></font>
</pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Dan di sini adalah hal yang sama, tetapi untuk v.5.5.23 (di antaranya 1147 baris adalah kode dari perpustakaan lite-opsional): </font></font><br><pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -------------------------------------------------- -----------------------------</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
File bahasa kosong kode komentar</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
-------------------------------------------------- -----------------------------</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
C / C ++ Header 133 6279 22173 21068</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
C ++ 53 2498 2760 10398</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
CMake 2 29 0 177</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ruby 4 53 2 129</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
-------------------------------------------------- -----------------------------</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SUM: 192 8859 24935 31772</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
-------------------------------------------------- -----------------------------</font></font><font></font>
</pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Volume tes untuk v.5.5.0: </font></font><br><pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -------------------------------------------------- -----------------------------</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
File bahasa kosong kode komentar</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
-------------------------------------------------- -----------------------------</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
C ++ 84 2510 390 11540</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ruby 162 496 0 1054</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
C / C ++ Header 1 11 0 32</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
-------------------------------------------------- -----------------------------</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SUM: 247 3017 390 12626</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
-------------------------------------------------- -----------------------------</font></font><font></font>
</pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Tes untuk v.5.5.23: </font></font><br><pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -------------------------------------------------- -----------------------------</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
File bahasa kosong kode komentar</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
-------------------------------------------------- -----------------------------</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
C ++ 324 7345 1305 35231</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ruby 675 2.353 0 4.671</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
CMake 338 43 0 955</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
C / C ++ Header 11 107 3 448</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
-------------------------------------------------- -----------------------------</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SUM: 1348 9848 1308 41305</font></font><font></font>
</pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Nah, contoh untuk v.5.5.0: </font></font><br><pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -------------------------------------------------- -----------------------------</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
File bahasa kosong kode komentar</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
-------------------------------------------------- -----------------------------</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
C ++ 27 765 463 3322</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ruby 28 95 0 192</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
-------------------------------------------------- -----------------------------</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SUM: 55 860 463 3514</font></font><font></font>
</pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ya, tapi sudah untuk v.5.5.23: </font></font><br><pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -------------------------------------------------- -----------------------------</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
File bahasa kosong kode komentar</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
-------------------------------------------------- -----------------------------</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
C ++ 67 2141 2061 9341</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ruby 133 451 0 868</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
CMake 67 93 0 595</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
C / C ++ Header 1 12 11 32</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
-------------------------------------------------- -----------------------------</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SUM: 268 2697 2072 10836</font></font><font></font>
</pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hampir di mana-mana, peningkatan hampir tiga kali lipat. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dan jumlah dokumentasi untuk SObjectizer mungkin meningkat lebih banyak lagi.</font></font><br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Paket untuk waktu dekat (dan tidak hanya) </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rencana pengembangan awal untuk SObjectizer setelah rilis versi 5.5.23 dijelaskan di </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sini</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> sekitar sebulan yang lalu. Pada dasarnya, mereka tidak berubah. Tetapi ada perasaan bahwa versi 5.6.0, rilis yang dijadwalkan untuk awal 2019, perlu diposisikan sebagai awal cabang stabil berikutnya dari SObjectizer. Dengan memperhatikan fakta bahwa selama 2019, SObjectizer akan berkembang di bawah cabang 5.6 tanpa ada perubahan yang berarti. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ini akan memberikan kesempatan bagi mereka yang saat ini menggunakan SO-5.5 dalam proyek mereka untuk secara bertahap beralih ke SO-5.6 tanpa takut bahwa mereka harus beralih ke SO-5.7 berikutnya.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Versi 5.7, di mana kita ingin membiarkan diri kita menyimpang dari prinsip-prinsip dasar SO-5.5 dan SO-5.6, akan dianggap eksperimental pada 2019. </font><font style="vertical-align: inherit;">Dengan stabilisasi dan rilis, jika semuanya berjalan dengan baik, sudah di tahun 2020.</font></font><br><br><h1>  Kesimpulan </h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sebagai penutup, saya ingin mengucapkan terima kasih kepada semua orang yang telah membantu kami dengan pengembangan SObjectizer selama ini. </font><font style="vertical-align: inherit;">Dan saya ingin mengucapkan terima kasih secara terpisah kepada semua orang yang berani mencoba bekerja dengan SObjectizer. </font><font style="vertical-align: inherit;">Umpan balik Anda selalu sangat berguna bagi kami. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kami ingin mengatakan kepada mereka yang belum menggunakan SObjectizer: coba. </font><font style="vertical-align: inherit;">Ini tidak seseram kelihatannya. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jika Anda tidak menyukai sesuatu atau tidak memiliki cukup di SObjectizer - beri tahu kami. </font><font style="vertical-align: inherit;">Kami selalu mendengarkan kritik yang membangun. </font><font style="vertical-align: inherit;">Dan, jika itu dalam kekuasaan kami, kami mewujudkan keinginan pengguna.</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id429046/">https://habr.com/ru/post/id429046/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id429036/index.html">Percayalah, saya tahu apa yang saya lakukan: adaptasi otomatis dari robot modular ke lingkungan pelaksanaan tugas</a></li>
<li><a href="../id429038/index.html">Rust News # 2 (Oktober 2018)</a></li>
<li><a href="../id429040/index.html">Menambal kode Java pada produksi tanpa anestesi</a></li>
<li><a href="../id429042/index.html">Kami sedang menguji SharxBase, platform virtualisasi perangkat lunak dan perangkat keras dari vendor Rusia SharxDC</a></li>
<li><a href="../id429044/index.html">Saham Apple telah mengalami kejatuhan terburuk sejak 2014. Investor besar telah kehilangan miliaran</a></li>
<li><a href="../id429048/index.html">Kiat untuk pemula hoster</a></li>
<li><a href="../id429050/index.html">Serangan pertukaran Gate.io cryptocurrency direkam</a></li>
<li><a href="../id429052/index.html">Mengapa pada laptop-sentuh beberapa SPA tidak lagi mendukung event sentuh</a></li>
<li><a href="../id429054/index.html">Temukan N Perbedaan. Pengalaman pengujian tata letak Tinkoff.ru</a></li>
<li><a href="../id429056/index.html">Fisika, bukan biologi, membuat penuaan tak terhindarkan</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>