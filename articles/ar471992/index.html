<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤠 ☎️ 👩‍👩‍👧‍👧 تنفيذ الميزات المتبقية من PEG 👨🏼‍🎨 🎀 🙎🏽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="بعد أن جمعت جميع أجزاء مولد PEG-parser معًا في المنشور السابق ، أنا مستعد لإظهار كيفية تنفيذ بعض الأشياء الأخرى المثيرة للاهتمام. 
 بيثون PEG محلل سلس...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>تنفيذ الميزات المتبقية من PEG</h1><div class="post__body post__body_full" style=";text-align:right;direction:rtl"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/471992/" style=";text-align:right;direction:rtl"><p style=";text-align:right;direction:rtl">  بعد أن جمعت جميع أجزاء مولد PEG-parser معًا في المنشور السابق ، أنا مستعد لإظهار كيفية تنفيذ بعض الأشياء الأخرى المثيرة للاهتمام. </p><br><div class="spoiler" style=";text-align:right;direction:rtl">  <b class="spoiler_title">بيثون PEG محلل سلسلة المحتوى</b> <div class="spoiler_text" style=";text-align:right;direction:rtl"><ul style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl">  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">موزعي الوتد</a> </li><li style=";text-align:right;direction:rtl">  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">تنفيذ محلل PEG</a> </li><li style=";text-align:right;direction:rtl">  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">PEG المحلل جيل</a> </li><li style=";text-align:right;direction:rtl">  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">PEG محلل التصور</a> </li><li style=";text-align:right;direction:rtl">  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">اليسار عودي PEG النحوي</a> </li><li style=";text-align:right;direction:rtl">  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">إضافة إجراءات إلى قواعد PEG</a> </li><li style=";text-align:right;direction:rtl">  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">قواعد الفوقية للمحلل PEG</a> </li><li style=";text-align:right;direction:rtl">  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">تنفيذ الميزات المتبقية من PEG</a> </li><li style=";text-align:right;direction:rtl">  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">PEG على كور المطور سبرينت</a> </li></ul></div></div><br><p style=";text-align:right;direction:rtl">  سننظر في الميزات التالية لـ PEG: </p><a name="habracut"></a><br><ul style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl"> العناصر المسماة: <code>NAME=item</code> (يمكن استخدام الاسم في الإجراء) </li><li style=";text-align:right;direction:rtl">  عناصر النظافة: <code>&amp;item</code> (إيجابي) و <code>!item</code> (سلبي) </li><li style=";text-align:right;direction:rtl">  تجميع العناصر بين قوسين: ( <code>item item ...</code> ) </li><li style=";text-align:right;direction:rtl">  العناصر الاختيارية: <code>[item item ...]</code> <code>item?</code> </li><li style=";text-align:right;direction:rtl">  العناصر المكررة: <code>item*</code> (صفر أو أكثر) <code>item+</code> (واحد أو أكثر) </li></ul><br><h2 id="imenovannye-argumenty" style=";text-align:right;direction:rtl">  الحجج المسماة </h2><br><p style=";text-align:right;direction:rtl">  لنبدأ بالعناصر المسماة.  هذا مناسب عندما يكون لدينا العديد منهم في بديل واحد لنفس القاعدة ، على سبيل المثال: </p><br><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs">expr: term '+' term</code> </pre> <br><p style=";text-align:right;direction:rtl">  يمكننا الرجوع إلى <code>term</code> الثاني عن طريق إضافة الرقم <code>1</code> إلى اسم المتغير ، بحيث يتضح في الإجراء ما يلي: </p><br><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs">expr: term '+' term { term + term1 }</code> </pre> <br><p style=";text-align:right;direction:rtl">  لكن لا يحب الجميع ذلك ، وأنا شخصياً أفضل أن أكتب شيئًا مثل هذا: </p><br><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs">expr: left=term '+' right=term { left + right }</code> </pre> <br><p style=";text-align:right;direction:rtl">  يتم دعم هذا بسهولة في قواعد التعريف عن طريق تغيير قاعدة <code>item</code> كما يلي: </p><br><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs">item: | NAME = atom { NamedItem(name.string, atom) } | atom { atom } atom: | NAME { name.string } | STRING { string.string }</code> </pre> <br><p style=";text-align:right;direction:rtl">  (حيث <code>atom</code> ليست سوى عنصر قديم) </p><br><p style=";text-align:right;direction:rtl">  يتطلب ذلك منا إضافة تعريف الفئة <code>grammar.py</code> إلى <code>grammar.py</code> .  إنها إحدى فئات البيانات التي ذكرتها سابقًا - لها أيضًا سمات <code>name</code> والعنصر. </p><br><p style=";text-align:right;direction:rtl">  نحتاج أيضًا إلى إجراء تغييرات صغيرة على مُنشئ الشفرة ، والتي سأتركها كتمرين للقارئ (أو يمكنك النظر في مستودع التخزين الخاص بي :-).  سيقوم الكود الذي تم إنشاؤه الآن بتعيين نتيجة مطابقة كل عنصر إلى متغير بالاسم المحدد ، وليس بالاسم الذي تم الحصول عليه من اسم قاعدة العنصر.  سيعمل هذا أيضًا على العناصر ذات الرموز المميزة (إما من النموذج <code>NAME</code> أو الأحرف الحرفية للسلسلة مثل <code>':='</code> ). </p><br><h2 id="lookahead" style=";text-align:right;direction:rtl">  Lookahead </h2><br><p style=";text-align:right;direction:rtl">  تليها lookahead.  ربما صادفت هذا المفهوم في تعبيرات منتظمة.  أثناء واجهة البحث الأمامية ، يمكن رفض البديل المعرب أو قبوله على الفور ، دون تحريك مؤشر الرمز المميز. </p><br><p style=";text-align:right;direction:rtl">  في الواقع ، يمكن استخدام واجهة البحث كوسيلة أكثر أناقة لإزالة الالتباس مع استثناءات المحلل اللغوي ، والتي كتبت عنها في مقالة سابقة.  بدلاً من السماح للإجراءات برفض بديل مقبول بالفعل من خلال إرجاع بلا ، يمكننا إضافة تعليمة قبل <code>OP</code> لاستبعاد <code>"}"</code> .  القاعدة القديمة تبدو مثل هذا: </p><br><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs"> | OP { None if op.string in ("{", "}") else op.string }</code> </pre> <br><p style=";text-align:right;direction:rtl">  الإصدار الجديد يشبه هذا: </p><br><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs"> | !"}" OP { op.string }</code> </pre> <br><p style=";text-align:right;direction:rtl">  يؤدي هذا إلى نقل معالجة القوس المجعد من الإجراء إلى القواعد النحوية ، حيث ينتمي.  لا نحتاج إلى التحقق من <code>"{"</code> ، لأنه يتوافق مع بديل سابق (في الواقع ، هذا صحيح أيضًا بالنسبة للإصدار القديم ، لكني نسيت ذلك :-). </p><br><p style=";text-align:right;direction:rtl">  نضيف قواعد النحو ل lookaheads إلى القاعدة <code>item</code> النحو التالي: </p><br><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs">item: | NAME = atom { NamedItem(name.string, atom) } | atom { atom } | "&amp;" atom { Lookahead(atom, True) } | "!" atom { Lookahead(atom, False) }</code> </pre> <br><p style=";text-align:right;direction:rtl">  مرة أخرى ، نحتاج إلى إضافة قاعدة بيانات Lookahead إلى <code>grammar.py</code> (واستيرادها إلى <code>@subheader</code> !) وتعديل المولد قليلاً بإضافة طريقة المساعد التالية: </p><br><pre style=";text-align:right;direction:rtl"> <code class="python hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">lookahead</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, positive, func, *args)</span></span></span><span class="hljs-function">:</span></span> mark = self.mark() ok = func(*args) <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-keyword"><span class="hljs-keyword">None</span></span> self.reset(mark) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ok == positive</code> </pre> <br><p style=";text-align:right;direction:rtl">  في حالتنا ، يبدو الرمز الذي تم إنشاؤه لهذا البديل كما يلي: </p><br><pre style=";text-align:right;direction:rtl"> <code class="python hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">True</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> self.lookahead(<span class="hljs-keyword"><span class="hljs-keyword">False</span></span>, self.expect, <span class="hljs-string"><span class="hljs-string">"}"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> (op := self.expect(OP)) ): <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> op . string</code> </pre> <br><p style=";text-align:right;direction:rtl">  كما ترون من جزء القواعد أعلاه ، لا يمكن أن تحصل lookahead على أسماء مناسبة.  هذا سهل الإصلاح ، لكن لا يزال لدي فكرة عن مدى فائدة ذلك.  بالإضافة إلى ذلك ، بالنسبة للتوقعات السلبية ، ستكون القيمة دائمًا بلا. </p><br><h2 id="gruppirovka-v-skobkah" style=";text-align:right;direction:rtl">  التجمع بين قوسين </h2><br><p style=";text-align:right;direction:rtl">  الآن لننفذ مجموعات ذات أقواس.  أفضل مكان لإضافتها إلى المخطط هو قاعدة <code>atom</code> : </p><br><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs">atom: | NAME { name.string } | STRING { string.string } | "(" alts ")" { self.synthetic_rule(alts) }</code> </pre> <br><p style=";text-align:right;direction:rtl">  لم يتغير البديلان الأولان.  يستخدم الإجراء الخاص بالبديل الجديد اختراقًا (لا يزال تطبيقه غير مفسر) ، مما يسمح للمحلل الفوقية بإضافة قواعد جديدة إلى القواعد أثناء الطيران.  هذه الدالة المساعد (المعرفة في محلل التعريف) بإرجاع اسم كائن القاعدة الجديد.  ستتكون من بادئة ثابتة متبوعة برقم ، مما يجعله فريدًا ، على سبيل المثال ، <code>_synthetic_rule_1</code> . </p><br><p style=";text-align:right;direction:rtl">  قد تسأل عما يحدث إذا تم إسقاط القاعدة الاصطناعية في النهاية.  لا أعرف كيفية تجنب ذلك ، ولكن يجب ألا تكون هناك أي مشاكل - في أسوأ الحالات ستكون هناك قاعدة غير مستخدمة في القواعد.  وبفضل المذكرة ، لن يتم تنفيذ الإجراء نفسه مرتين لنفس موضع الإدخال ، لذلك ليست هذه مشكلة أيضًا (ولكن حتى لو كان الأمر كذلك ، فسنكون لدينا حكم ميت في أسوأ الحالات). </p><br><p style=";text-align:right;direction:rtl">  استخدام <code>alts</code> داخل الأقواس يعني أنه يمكننا تحديد شريط عمودي كمحدد داخل مجموعة.  على سبيل المثال ، لن يتطابق حل الإجراء الجديد الخاص بنا عن طريق الخطأ <code>{</code> ، يمكننا تغيير النفي إلى هذا: </p><br><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs"> | !("{" | "}") OP { op.string }</code> </pre> <br><p style=";text-align:right;direction:rtl">  علاوة على ذلك ، يمكن أن تحتوي المجموعات أيضًا على إجراءات!  هذا لن يساعد في حل المشكلة مع الإجراءات ، ولكن في حالات أخرى قد يكون مفيدًا.  ونظرًا لأننا في أي حال نقوم بإنشاء قاعدة تركيبية ، فإنه لا يتطلب أي عمل إضافي لتنفيذه (باستثناء تطبيق <code>synthetic_rule</code> :-). </p><br><h2 id="opcionalnye-elementy" style=";text-align:right;direction:rtl">  العناصر الاختيارية </h2><br><p style=";text-align:right;direction:rtl">  كما هو الحال في pgen القديم ، أستخدم الأقواس المربعة للإشارة إلى مجموعة من الرموز المميزة.  هذا هو المكان الذي اتضح أنه مفيد.  على سبيل المثال ، يمكن لقاعدة النحو التي تصف Python <code>for</code> loop استخدامها للإشارة إلى أن امتدادًا <code>else</code> يمكن أن يوجد.  ومرة أخرى يمكننا توسيع قواعد اللغة <code>atom</code> كما يلي: </p><br><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs">atom: | NAME { name.string } | STRING { string.string } | "(" alts ")" { self.synthetic_rule(alts) } | "[" alts "]" { Maybe(self.synthetic_rule(alts)) }</code> </pre> <br><p style=";text-align:right;direction:rtl">  هنا <code>Maybe</code> هناك فئة بيانات أخرى ، مع سمة <code>item</code> واحد.  نقوم بتعديل مولد الشفرة بحيث لا تفشل نتيجة الوظيفة التركيبية إذا كانت هذه القيمة بلا.  للقيام بذلك ، يمكنك إضافة <code>or True</code> في التنفيذ.  على سبيل المثال ، من أجل <code>[term]</code> : </p><br><pre style=";text-align:right;direction:rtl"> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">True</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> ((term := self.term()) <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>) ): <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> term</code> </pre> <br><h2 id="povtoryayuschiesya-elementy" style=";text-align:right;direction:rtl">  العناصر المكررة </h2><br><p style=";text-align:right;direction:rtl">  التبديل إلى التكرار هو وظيفة PEG مفيدة أخرى (يتم استعار الترميز من التعبيرات العادية ويستخدم أيضًا في pgen).  هناك نموذجان: تعني إضافة <code>*</code> إلى ذرة "صفر أو أكثر من التكرار" ، بينما تعني إضافة <code>+</code> "تكرار واحد أو أكثر".  لأسباب أخرى ، اضطررت إلى إعادة كتابة القواعد النحوية <code>item</code> <code>atom</code> ، مع إضافة قاعدة وسيطة ، والتي <code>molecule</code> : </p><br><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs">item: | NAME '=' molecule { NamedItem(name.string, molecule) } | "&amp;" atom { Lookahead(atom) } | "!" atom { Lookahead(atom, False) } | molecule { molecule } molecule: | atom "?" { Maybe(atom) } | atom "*" { Loop(atom, False) } | atom "+" { Loop(atom, True) } | atom { atom } | "[" alts "]" { Maybe(self.synthetic_rule(alts)) } atom: | NAME { name.string } | STRING {string.string } | "(" alts ")" { self.synthetic_rule(alts) }</code> </pre> <br><p style=";text-align:right;direction:rtl">  لاحظ أن هذا يقدم بناء جملة بديل للعناصر الاختيارية ( <code>atom?</code> ).  لا يتطلب الأمر جهودًا إضافية للتنفيذ ، لأن هذه مجرد طريقة أخرى لإنشاء عقدة <code>Maybe</code> . </p><br><p style=";text-align:right;direction:rtl">  كانت إعادة تفعيل هذه القواعد ضرورية لأنني لا أرغب في جعل بعض المواقف صالحة: </p><br><ul style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl">  التكرار الاختياري (لأن هذا مجرد تكرار صفر أو أكثر) ؛ </li><li style=";text-align:right;direction:rtl">  التكرار (داخلي سوف يلتقط كل التطابقات ، لأن PEG يستخدم دائمًا خوارزمية جشعة) </li><li style=";text-align:right;direction:rtl">  القيم الاختيارية المتكررة (والتي من شأنها مقاطعة التحليل إذا كان العنصر الاختياري غير متطابق). </li></ul><br><p style=";text-align:right;direction:rtl">  ومع ذلك ، لا يزال هذا الحل غير مثالي ، حيث يمكنك كتابة شيء مثل <code>(foo?)*</code> .  سيكون من الضروري إضافة فحص لهذا الموقف في منشئ المحلل اللغوي ، لكنني سأفعل ذلك خارج المقالة. </p><br><p style=";text-align:right;direction:rtl">  تحتوي فئة بيانات <code>Loop</code> على سمتين: <code>item</code> وغير <code>nonempty</code> .  سيستخدم الرمز الذي تم إنشاؤه طريقة محلل مساعد <code>loop()</code> .  إنه مشابه جدًا <code>lookahead()</code> الموضحة مسبقًا: </p><br><pre style=";text-align:right;direction:rtl"> <code class="python hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">loop</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, nonempty, func, *args)</span></span></span><span class="hljs-function">:</span></span> mark = self.mark() nodes = [] <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> node := func(*args) <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-keyword"><span class="hljs-keyword">None</span></span>: nodes.append(node) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> len(nodes) &gt;= nonempty: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> nodes self.reset(mark) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">None</span></span></code> </pre> <br><p style=";text-align:right;direction:rtl">  إذا كانت قيمة <code>nonempty</code> <code>False</code> (بمعنى أن القواعد كانت <code>*</code> ) ، فلن يؤدي ذلك إلى حدوث خطأ.  لن يتم العثور على إدخالات ، وسيتم إرجاع قائمة فارغة.  لتحقيق ذلك ، نقوم بتطبيق مولد المحلل اللغوي بحيث <code>is not None</code> إضافة بلا.  سيؤدي الاختيار الأكثر نعومة من منشور سابق إلى إرجاع <code>False</code> في حالة وجود قائمة فارغة. </p><br><p style=";text-align:right;direction:rtl">  هذا كل شيء لهذا اليوم!  كنت سأناقش عامل التشغيل "cut" ( <code>~</code> ) الموجود في TatSu ، لكن حتى الآن لم تتح لي الفرصة لمواجهته.  لست مستعدًا حتى الآن لمناقشته - فوثائق TatSu لا تقدم سوى مثال بسيط يهتم بي قليلاً.  لم أجدها في مولدات أخرى من PEG-parsers ، لذلك ، ربما ، هذه الميزة هي TatSu فقط.  ربما يوما ما سأقول عنه.  (وفي الوقت نفسه ، قمت بتنفيذها فقط في حالة ، أنت لا تعرف أبدا. :-) </p><br><p style=";text-align:right;direction:rtl">  أعتقد أن المقالة التالية ستكون عن تجربتي في كتابة قواعد PEG التي يمكنها تحليل قواعد Python.  سوف أخبركم كيف حدث سباق مطوري Python kernel ، الذي كان في لندن هذا الأسبوع بدعم لوجيستي من بلومبرج ودعم مالي من PSF وبعض الشركات الأخرى (على سبيل المثال ، دفعت Dropbox لي الفندق والطيران).  شكر خاص لإميلي مورهاوس وبابلو غاليندو سالغادو ، الذين ساعدوا كثيرا في تنفيذ الأدوات والاختبارات.  بعد ذلك ، سنكتب اختبارات الأداء ، ومن ثم سنقوم بإضافة إجراءات إلى هذا النحو حتى تتمكن من إنشاء أشجار AST التي يمكن تجميعها بواسطة برنامج التحويل البرمجي لرمز بايت CPython.  هناك أشياء أكثر إثارة للاهتمام في المستقبل! </p><br><p style=";text-align:right;direction:rtl">  ترخيص لهذه المقالة ورمز استشهد: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">CC BY-NC-SA 4.0</a> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/ar471992/">https://habr.com/ru/post/ar471992/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ar471980/index.html">المحتالين الهاتف. الفصل الرابع ، النهائي ...</a></li>
<li><a href="../ar471982/index.html">مناقشة مستقبل PHP</a></li>
<li><a href="../ar471986/index.html">اليسار عودي PEG النحوي</a></li>
<li><a href="../ar471988/index.html">إضافة إجراءات إلى قواعد PEG</a></li>
<li><a href="../ar471990/index.html">قواعد الفوقية للمحلل PEG</a></li>
<li><a href="../ar471994/index.html">العمل على PEG على Core Developer Sprint</a></li>
<li><a href="../ar471998/index.html">F # 10: قوائم</a></li>
<li><a href="../ar472000/index.html">"من الأهمية بمكان أن يضع المجتمع معايير": مارشين موسكالا حول كوتلين</a></li>
<li><a href="../ar472002/index.html">حزمة إعادة التعبئة في الدرج</a></li>
<li><a href="../ar472004/index.html">Boost.Spirit ، أو إضافة "الروحانية" إلى قائمة المرشحات</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>