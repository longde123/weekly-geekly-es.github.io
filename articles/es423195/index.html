<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üßõüèº üí™üèº üåø Qu√© hay de nuevo en JPA 2.2 üßíüèº üö¶ üèñÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Felices vacaciones a todos! 

 Sucedi√≥ tan repentinamente que el inicio del segundo grupo "Java Enterprise Developer" coincidi√≥ con el d√≠a 256 del a√±o...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Qu√© hay de nuevo en JPA 2.2</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/otus/blog/423195/">  Felices vacaciones a todos! <br><br>  Sucedi√≥ tan repentinamente que el inicio del segundo grupo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">"Java Enterprise Developer"</a> coincidi√≥ con el d√≠a 256 del a√±o.  <s>¬øCoincidencia?</s>  <s>No lo creo</s> <br><br>  Bueno, compartimos el pen√∫ltimo inter√©s: qu√© cosas nuevas trajo JPA 2.2: resultados de transmisi√≥n, conversi√≥n de fecha mejorada, nuevas anotaciones, solo algunos ejemplos de mejoras √∫tiles. <br><br>  Vamos! <br><br>  La Java Persistence API (JPA) es una especificaci√≥n fundamental de Java EE que se usa ampliamente en la industria.  Independientemente de si est√° desarrollando para la plataforma Java EE o para el marco de Java alternativo, JPA es su elecci√≥n para guardar datos.  JPA 2.1 mejor√≥ la especificaci√≥n, permitiendo a los desarrolladores resolver problemas como la generaci√≥n autom√°tica de esquemas de bases de datos y un trabajo eficiente con procedimientos almacenados en la base de datos.  La √∫ltima versi√≥n, JPA 2.2, mejora la especificaci√≥n basada en estos cambios. <br>  En este art√≠culo hablar√© sobre nuevas funcionalidades y dar√© ejemplos que lo ayudar√°n a comenzar a usarlo.  Como muestra, uso el proyecto "Java EE 8 Playground", que est√° disponible en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">GitHub</a> .  La aplicaci√≥n de muestra se basa en la especificaci√≥n Java EE 8 y utiliza los marcos JavaServer Faces (JSF), Enterprise JavaBeans (EJB) y JPA para la persistencia.  Debe estar familiarizado con JPA para comprender de qu√© se trata. <br><br><img src="https://habrastorage.org/webt/2a/o5/xl/2ao5xlvs1k6qa91gdq0ndz3akis.png"><br><a name="habracut"></a><br>  <b>Usando JPA 2.2</b> <br><br>  JPA versi√≥n 2.2 es parte de la plataforma Java EE 8. Vale la pena se√±alar que solo los servidores de aplicaciones compatibles con Java EE 8 proporcionan una especificaci√≥n que est√° lista para usar de inmediato.  Al momento de escribir esto (finales de 2017), hab√≠a bastantes servidores de aplicaciones de este tipo.  Sin embargo, usar JPA 2.2 con Java EE7 es f√°cil.  Primero necesita descargar los archivos JAR apropiados usando <a href="">Maven Central</a> y agregarlos al proyecto.  Si est√° utilizando Maven en su proyecto, agregue las coordenadas al archivo POM de Maven: <br><br><pre><code class="java hljs">&lt;dependency&gt; &lt;groupId&gt;javax.persistence&lt;/groupId&gt; &lt;artifactId&gt;javax.persistence-api&lt;/artifactId&gt; &lt;version&gt;<span class="hljs-number"><span class="hljs-number">2.2</span></span>&lt;/version&gt; &lt;/dependency&gt;</code> </pre> <br>  Luego, seleccione la implementaci√≥n JPA que desea usar.  Comenzando con JPA 2.2, tanto EclipseLink como Hibernate tienen implementaciones compatibles.  Como ejemplos en este art√≠culo, uso <a href="">EclipseLink</a> agregando la siguiente dependencia: <br><br><pre> <code class="java hljs">&lt;dependency&gt; &lt;groupId&gt;org.eclipse.persistence&lt;/groupId&gt; &lt;artifactId&gt;eclipselink&lt;/artifactId&gt; &lt;version&gt;<span class="hljs-number"><span class="hljs-number">2.7</span></span>.0 &lt;/version&gt; &lt;/dependency&gt;</code> </pre> <br>  Si est√° utilizando un servidor compatible con Java EE 8, como GlassFish 5 o Payara 5, deber√≠a poder especificar el √°rea "proporcionada" para estas dependencias en el archivo POM.  De lo contrario, especifique el √°rea de "compilaci√≥n" para incluirlos en el ensamblaje del proyecto. <br><br>  <b>Soporte de fecha y hora Java 8</b> <br><br>  Quiz√°s una de las adiciones m√°s positivas es la compatibilidad con Java 8 Date and Time API.  Desde el lanzamiento de Java SE 8 en 2014, los desarrolladores han utilizado soluciones alternativas para usar la API de fecha y hora con JPA.  Aunque la mayor√≠a de las soluciones son bastante sencillas, la necesidad de agregar soporte b√°sico para la API actualizada de fecha y hora est√° muy atrasada.  El soporte de JPA para la API de fecha y hora incluye los siguientes tipos: <br><br><ul><li> <code>java.time.LocalDate</code> </li> <li> <code>java.time.LocalTime</code> </li> <li> <code>java.time.LocalDateTime</code> </li> <li> <code>java.time.OffsetTime</code> </li> <li> <code>java.time.OffsetDateTime</code> </li> </ul><br>  Para una mejor comprensi√≥n, primero explicar√© c√≥mo funciona el soporte de API de fecha y hora sin JPA 2.2.  JPA 2.1 solo puede funcionar con construcciones de fecha anteriores como <code>java.util.Date</code> y <code>java.sql.Timestamp</code> .  Por lo tanto, debe usar un convertidor para convertir la fecha almacenada en la base de datos en un dise√±o antiguo que sea compatible con JPA 2.1, y luego convertirlo en una API de fecha y hora actualizada para usar en la aplicaci√≥n.  Un convertidor de fecha en JPA 2.1 capaz de tal conversi√≥n puede parecerse al Listado 1. El convertidor en √©l se usa para convertir entre <code>LocalDate</code> y <code>java.util.Date</code> . <br><br>  <i>Listado 1</i> <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Converter</span></span>(autoApply = <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">LocalDateTimeConverter</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AttributeConverter</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">LocalDate</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Date</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Date </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">convertToDatabaseColumn</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(LocalDate entityValue)</span></span></span><span class="hljs-function"> </span></span>{ LocalTime time = LocalTime.now(); Instant instant = time.atDate(entityValue) .atZone(ZoneId.systemDefault()) .toInstant(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Date.from(instant); } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> LocalDate </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">convertToEntityAttribute</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Date databaseValue)</span></span></span></span>{ Instant instant = Instant.ofEpochMilli(databaseValue.getTime()); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> LocalDateTime.ofInstant(instant, ZoneId.systemDefault()).toLocalDate(); } }</code> </pre> <br>  JPA 2.2 ya no necesita escribir dicho convertidor, ya que est√° utilizando tipos de fecha y hora compatibles.  El soporte para tales tipos est√° integrado, por lo que puede simplemente especificar el tipo admitido en el campo de clase de entidad sin c√≥digo adicional.  El fragmento de c√≥digo siguiente muestra este concepto.  Tenga en cuenta que no es necesario agregar anotaciones al c√≥digo <code>@Temporal</code> , porque la asignaci√≥n de tipos se produce autom√°ticamente. <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Job</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Serializable</span></span></span><span class="hljs-class"> </span></span>{ . . . <span class="hljs-meta"><span class="hljs-meta">@Column</span></span>(name = <span class="hljs-string"><span class="hljs-string">"WORK_DATE"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> LocalDate workDate; . . . }</code> </pre> <br>  Dado que los tipos de fecha y hora admitidos son objetos de primera clase en el JPA, se pueden especificar sin ceremonias adicionales.  En JPA 2.1 <code>@Temporal</code> anotaci√≥n debe describirse en todos los campos y propiedades constantes del <code>java.util.Calendar</code> <code>java.util.Date</code> y <code>java.util.Calendar</code> . <br><br>  Vale la pena se√±alar que solo algunos de los tipos de fecha y hora son compatibles con esta versi√≥n, pero el convertidor de atributos se puede generar f√°cilmente para trabajar con otros tipos, por ejemplo, para convertir <code>LocalDateTime</code> a <code>ZonedDateTime</code> .  El mayor problema al escribir un convertidor de este tipo es determinar la mejor manera de convertir entre diferentes tipos.  Para facilitar a√∫n m√°s las cosas, ahora se pueden implementar convertidores de atributos.  Dar√© un ejemplo de implementaci√≥n a continuaci√≥n. <br><br>  El c√≥digo en el Listado 2 muestra c√≥mo convertir el tiempo de <code>LocalDateTime</code> a <code>ZonedDateTime</code> . <br><br>  <i>Listado 2</i> <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Converter</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">LocalToZonedConverter</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AttributeConverter</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ZonedDateTime</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">LocalDateTime</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> LocalDateTime </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">convertToDatabaseColumn</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ZonedDateTime entityValue)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> entityValue.toLocalDateTime(); } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> ZonedDateTime </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">convertToEntityAttribute</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(LocalDateTime databaseValue)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ZonedDateTime.of(databaseValue, ZoneId.systemDefault()); } }</code> </pre> <br>  Espec√≠ficamente, este ejemplo es muy sencillo porque <code>ZonedDateTime</code> contiene m√©todos que son f√°ciles de convertir.  La conversi√≥n se produce llamando al m√©todo <code>toLocalDateTime()</code> .  La conversi√≥n inversa se puede hacer llamando al m√©todo <code>ZonedDateTimeOf()</code> y pasando el valor <code>LocalDateTime</code> junto con <code>ZoneId</code> para usar la zona horaria. <br><br>  <b>Convertidores de atributos integrados</b> <br><br>  Los convertidores de atributos fueron una muy buena adici√≥n a JPA 2.1, ya que permitieron que los tipos de atributos fueran m√°s flexibles.  La actualizaci√≥n JPA 2.2 agrega una capacidad √∫til para hacer que los convertidores de atributos sean implementables.  Esto significa que puede incrustar recursos de Contextos e Inyecci√≥n de Dependencias (CDI) directamente en el convertidor de atributos.  Esta modificaci√≥n es coherente con otras mejoras de CDI en las especificaciones Java EE 8, como los convertidores JSF avanzados, ya que ahora tambi√©n pueden usar la inyecci√≥n de CDI. <br><br>  Para aprovechar esta nueva caracter√≠stica, simplemente incruste los recursos CDI en el convertidor de atributos, seg√∫n sea necesario.  El Listado 2 proporciona un ejemplo de un convertidor de atributos, y ahora lo desarmar√©, explicando todos los detalles importantes. <br><br>  La clase del convertidor debe implementar la interfaz <code>javax.persistence.AttributeConverter</code> , pasando los valores X e Y. El valor X corresponde al tipo de datos en el objeto Java, y el valor Y debe corresponder al tipo de la columna de la base de datos.  Entonces, la clase del convertidor debe ser anotada con <code>@Converter</code> .  Finalmente, la clase debe anular los <code>convertToDatabaseColumn()</code> y <code>convertToEntityAttribute()</code> .  La implementaci√≥n en cada uno de estos m√©todos debe convertir los valores de tipos espec√≠ficos y volver a ellos. <br><br>  Para aplicar autom√°ticamente el convertidor cada vez que se usa el tipo de datos especificado, agregue "autom√°tico", como en <code>@Converter(autoApply=true)</code> .  Para aplicar un convertidor a un solo atributo, use la anotaci√≥n @Converter en el nivel de atributo, como se muestra aqu√≠: <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Convert</span></span>(converter=LocalDateConverter.java) <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> LocalDate workDate;</code> </pre> <br>  El convertidor tambi√©n se puede aplicar a nivel de clase: <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Convert</span></span>(attributeName=<span class="hljs-string"><span class="hljs-string">"workDate"</span></span>, converter = LocalDateConverter.class) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Job</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Serializable</span></span></span><span class="hljs-class"> </span></span>{ . . .</code> </pre> <br>  Supongamos que quiero cifrar los valores contenidos en el campo <code>creditLimit</code> de la entidad <code>Customer</code> cuando se guarda.  Para implementar este proceso, los valores deben cifrarse antes de guardarse y descifrarse despu√©s de recuperarse de la base de datos.  El convertidor puede hacer esto y, utilizando JPA 2.2, puedo incrustar el objeto de cifrado en el convertidor para lograr el resultado deseado.  El Listado 3 proporciona un ejemplo. <br><br>  <i>Listado 3</i> <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Converter</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CreditLimitConverter</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AttributeConverter</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BigDecimal</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BigDecimal</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Inject</span></span> CreditLimitEncryptor encryptor; <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> BigDecimal </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">convertToDatabaseColumn</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(BigDecimal entityValue)</span></span></span><span class="hljs-function"> </span></span>{ String encryptedFormat = encryptor.base64encode(entityValue.toString()); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> BigDecimal.valueOf(Long.valueOf(encryptedFormat)); } ... }</code> </pre> <br>  En este c√≥digo, el proceso se realiza <code>CreditLimitEncryptor</code> clase <code>CreditLimitEncryptor</code> en el convertidor y luego us√°ndolo para ayudar al proceso. <br><br>  <b>Transmisi√≥n de resultados de consultas</b> <br><br>  Ahora puede aprovechar al m√°ximo las funciones de secuencias de Java SE 8 cuando trabaje con resultados de consultas.  Los subprocesos no solo simplifican la lectura, la escritura y el mantenimiento del c√≥digo, sino que tambi√©n ayudan a mejorar el rendimiento de las consultas en algunas situaciones.  Algunas implementaciones de hilos tambi√©n ayudan a evitar un n√∫mero simult√°neo excesivamente grande de solicitudes de datos, aunque en algunos casos el uso de la paginaci√≥n <code>ResultSet</code> puede funcionar mejor que las transmisiones. <br><br>  Para habilitar esta funci√≥n, se ha agregado el m√©todo <code>getResultStream()</code> a las <code>TypedQuery</code> <code>Query</code> y <code>TypedQuery</code> .  Este cambio menor permite que JPA simplemente devuelva una secuencia de resultados en lugar de una lista.  Por lo tanto, si est√° trabajando con un <code>ResultSet</code> grande, tiene sentido comparar el rendimiento entre una nueva implementaci√≥n de subproceso y un <code>ResultSets</code> desplazable o paginaci√≥n.  La raz√≥n es que las implementaciones de subprocesos recuperan todos los registros a la vez, los almacenan en una lista y luego los devuelven.  Un <code>ResultSet</code> desplazable y una t√©cnica de paginaci√≥n recuperan datos poco a poco, lo que podr√≠a ser mejor para grandes conjuntos de datos. <br><br>  Los proveedores de persistencia pueden decidir anular el nuevo m√©todo <code>getResultStream()</code> una implementaci√≥n mejorada.  Hibernate ya incluye un m√©todo stream () que utiliza un <code>ResultSet</code> desplazable para analizar los resultados de los registros en lugar de devolverlos por completo.  Esto le permite a Hibernate trabajar con conjuntos de datos muy grandes y hacerlo bien.  Se puede esperar que otros proveedores anulen este m√©todo para proporcionar caracter√≠sticas similares que sean beneficiosas para JPA. <br><br>  Adem√°s del rendimiento, la capacidad de transmitir resultados es una buena adici√≥n a JPA, que proporciona una forma conveniente de trabajar con datos.  Demostrar√© un par de escenarios donde esto puede ser √∫til, pero las posibilidades en s√≠ mismas son infinitas.  En ambos escenarios, consulto la entidad <code>Job</code> y devuelvo la secuencia.  Primero, mire el siguiente c√≥digo, donde simplemente analizo la secuencia de <code>Jobs</code> contra un <code>Customer</code> espec√≠fico llamando al m√©todo de interfaz <code>Query</code> <code>getResultStream()</code> .  Luego, uso este hilo para mostrar detalles sobre el <code>customer</code> y la <code>work date</code> Job'a. <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">findByCustomer</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(PoolCustomer customer)</span></span></span></span>{ Stream&lt;Job&gt; jobList = em.createQuery(<span class="hljs-string"><span class="hljs-string">"select object(o) from Job o "</span></span> + <span class="hljs-string"><span class="hljs-string">"where o.customer = :customer"</span></span>) .setParameter(<span class="hljs-string"><span class="hljs-string">"customer"</span></span>, customer) .getResultStream(); jobList.map(j -&gt; j.getCustomerId() + <span class="hljs-string"><span class="hljs-string">" ordered job "</span></span> + j.getId() + <span class="hljs-string"><span class="hljs-string">" - Starting "</span></span> + j.getWorkDate()) .forEach(jm -&gt; System.out.println(jm)); }</code> </pre> <br><br>  Este m√©todo puede modificarse ligeramente para que devuelva una lista de resultados utilizando el <code>Collectors .toList()</code> siguiente manera. <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> List&lt;Job&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">findByCustomer</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(PoolCustomer customer)</span></span></span></span>{ Stream&lt;Job&gt; jobList = em.createQuery( <span class="hljs-string"><span class="hljs-string">"select object(o) from Job o "</span></span> + <span class="hljs-string"><span class="hljs-string">"where o.customerId = :customer"</span></span>) .setParameter(<span class="hljs-string"><span class="hljs-string">"customer"</span></span>, customer) .getResultStream(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> jobList.collect(Collectors.toList()); }</code> </pre> <br>  En el siguiente escenario, que se muestra a continuaci√≥n, encuentro una <code>List</code> tareas relacionadas con grupos de una forma espec√≠fica.  En este caso, devuelvo todas las tareas que coinciden con el formulario enviado como una cadena.  Similar al primer ejemplo, primero devuelvo una secuencia de registros de <code>Jobs</code> .  Luego, filtro los registros basados ‚Äã‚Äãen el formulario de grupo de clientes.  Como puede ver, el c√≥digo resultante es muy compacto y f√°cil de leer. <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> List&lt;Job&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">findByCustPoolShape</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String poolShape)</span></span></span></span>{ Stream&lt;Job&gt; jobstream = em.createQuery( <span class="hljs-string"><span class="hljs-string">"select object(o) from Job o"</span></span>) .getResultStream(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> jobstream.filter( c -&gt; poolShape.equals(c.getCustomerId().getPoolId().getShape())) .collect(Collectors.toList()); }</code> </pre><br>  Como mencion√© anteriormente, es importante recordar el rendimiento en escenarios donde se devuelven grandes cantidades de datos.  Existen condiciones en las que los subprocesos son m√°s √∫tiles para consultar bases de datos, pero tambi√©n existen aquellas en las que pueden causar una degradaci√≥n del rendimiento.  Una buena regla general es que si los datos pueden consultarse como parte de una consulta SQL, tiene sentido hacerlo.  A veces, los beneficios del uso de la elegante sintaxis de subprocesos no superan el mejor rendimiento que se puede lograr con el filtrado SQL est√°ndar. <br><br>  <b>Soporte de anotaciones duplicadas</b> <br><br>  Cuando se lanz√≥ Java SE 8, se hicieron posibles anotaciones duplicadas, lo que le permite reutilizar las anotaciones en la declaraci√≥n.  Algunas situaciones requieren el uso de la misma anotaci√≥n en una clase o campo varias veces.  Por ejemplo, puede haber m√°s de una anotaci√≥n <code>@SqlResultSetMapping</code> para una clase de entidad dada.  En situaciones donde se requiere soporte para la re-anotaci√≥n, se debe usar la anotaci√≥n de contenedor.  Las anotaciones duplicadas no solo reducen el requisito de envolver colecciones de anotaciones id√©nticas en anotaciones de contenedor, sino que tambi√©n pueden hacer que el c√≥digo sea m√°s f√°cil de leer. <br><br>  Esto funciona de la siguiente manera: la implementaci√≥n de la clase de anotaci√≥n debe marcarse con la <code>@Repeatable</code> para indicar que se puede usar m√°s de una vez.  La <code>@Repeatable</code> toma el tipo de la clase de anotaci√≥n del contenedor.  Por ejemplo, la <code>NamedQuery</code> anotaci√≥n <code>NamedQuery</code> ahora <code>NamedQuery</code> marcada con la <code>@Repeatable(NamedQueries.class)</code> .  En este caso, la anotaci√≥n del contenedor todav√≠a est√° en uso, pero no tiene que pensar en ello cuando usa la misma anotaci√≥n en la declaraci√≥n o clase, porque <code>@Repeatable</code> este detalle. <br><br>  Damos un ejemplo.  Si desea agregar m√°s de una anotaci√≥n <code>@NamedQuery</code> a una clase de entidad en JPA 2.1, debe encapsularlas dentro de la anotaci√≥n <code>@NamedQueries</code> , como se muestra en el Listado 4. <br><br>  <i>Listado 4</i> <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Entity</span></span> <span class="hljs-meta"><span class="hljs-meta">@Table</span></span>(name = <span class="hljs-string"><span class="hljs-string">"CUSTOMER"</span></span>) <span class="hljs-meta"><span class="hljs-meta">@XmlRootElement</span></span> <span class="hljs-meta"><span class="hljs-meta">@NamedQueries</span></span>({ <span class="hljs-meta"><span class="hljs-meta">@NamedQuery</span></span>(name = <span class="hljs-string"><span class="hljs-string">"Customer.findAll"</span></span>, query = <span class="hljs-string"><span class="hljs-string">"SELECT c FROM Customer c"</span></span>) , <span class="hljs-meta"><span class="hljs-meta">@NamedQuery</span></span>(name = <span class="hljs-string"><span class="hljs-string">"Customer.findByCustomerId"</span></span>, query = <span class="hljs-string"><span class="hljs-string">"SELECT c FROM Customer c "</span></span> + <span class="hljs-string"><span class="hljs-string">"WHERE c.customerId = :customerId"</span></span>) , <span class="hljs-meta"><span class="hljs-meta">@NamedQuery</span></span>(name = <span class="hljs-string"><span class="hljs-string">"Customer.findByName"</span></span>, query = <span class="hljs-string"><span class="hljs-string">"SELECT c FROM Customer c "</span></span> + <span class="hljs-string"><span class="hljs-string">"WHERE c.name = :name"</span></span>) . . .)}) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Customer</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Serializable</span></span></span><span class="hljs-class"> </span></span>{ . . . }</code> </pre> <br>  Sin embargo, en JPA 2.2, todo es diferente.  Como <code>@NamedQuery</code> es una anotaci√≥n duplicada, se puede especificar en la clase de entidad m√°s de una vez, como se muestra en el Listado 5. <br><br>  <i>Listado 5</i> <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Entity</span></span> <span class="hljs-meta"><span class="hljs-meta">@Table</span></span>(name = <span class="hljs-string"><span class="hljs-string">"CUSTOMER"</span></span>) <span class="hljs-meta"><span class="hljs-meta">@XmlRootElement</span></span> <span class="hljs-meta"><span class="hljs-meta">@NamedQuery</span></span>(name = <span class="hljs-string"><span class="hljs-string">"Customer.findAll"</span></span>, query = <span class="hljs-string"><span class="hljs-string">"SELECT c FROM Customer c"</span></span>) <span class="hljs-meta"><span class="hljs-meta">@NamedQuery</span></span>(name = <span class="hljs-string"><span class="hljs-string">"Customer.findByCustomerId"</span></span>, query = <span class="hljs-string"><span class="hljs-string">"SELECT c FROM Customer c "</span></span> + <span class="hljs-string"><span class="hljs-string">"WHERE c.customerId = :customerId"</span></span>) <span class="hljs-meta"><span class="hljs-meta">@NamedQuery</span></span>(name = <span class="hljs-string"><span class="hljs-string">"Customer.findByName"</span></span>, query = <span class="hljs-string"><span class="hljs-string">"SELECT c FROM Customer c "</span></span> + <span class="hljs-string"><span class="hljs-string">"WHERE c.name = :name"</span></span>) . . . <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Customer</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Serializable</span></span></span><span class="hljs-class"> </span></span>{ . . . }</code> </pre> <br>  Lista de anotaciones duplicadas: <br><br><ul><li> <code>@AssociationOverride</code> </li> <li> <code>@AttributeOverride</code> </li> <li> <code>@Convert</code> </li> <li> <code>@JoinColumn</code> </li> <li> <code>@MapKeyJoinColumn</code> </li> <li> <code>@NamedEntityGraphy</code> </li> <li> <code>@NamedNativeQuery</code> </li> <li> <code>@NamedQuery</code> </li> <li> <code>@NamedStoredProcedureQuery</code> </li> <li> <code>@PersistenceContext</code> </li> <li> <code>@PersistenceUnit</code> </li> <li> <code>@PrimaryKeyJoinColumn</code> </li> <li> <code>@SecondaryTable</code> </li> <li> <code>@SqlResultSetMapping</code> </li> </ul><br>  <b>Conclusi√≥n</b> <br><br>  La versi√≥n 2.2 de JPA tiene algunos cambios, pero las mejoras incluidas son significativas.  Finalmente, el JPA est√° alineado con Java SE 8, lo que permite a los desarrolladores utilizar funciones como la API de fecha y hora, la transmisi√≥n de resultados de consultas y la repetici√≥n de anotaciones.  Esta versi√≥n tambi√©n mejora la consistencia de CDI al agregar la capacidad de incrustar recursos de CDI en convertidores de atributos.  JPA 2.2 ya est√° disponible y es parte de Java EE 8, creo que le gustar√≠a usarlo. <br><br>  El fin <br><br>  Como siempre, estamos esperando preguntas y comentarios. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es423195/">https://habr.com/ru/post/es423195/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es423185/index.html">¬°No te lo comas! √ötil impresi√≥n 3D de az√∫car</a></li>
<li><a href="../es423187/index.html">Certificados ra√≠z e intermedios de autoridades de certificaci√≥n autorizadas de Rusia</a></li>
<li><a href="../es423189/index.html">Investigaci√≥n: la mitad de las empresas repara vulnerabilidades en un mes, ¬øpor qu√©?</a></li>
<li><a href="../es423191/index.html">Lanzamiento de los elementos de plataformas offshore. Parte 1</a></li>
<li><a href="../es423193/index.html">Configure las Notificaciones Web Push usando pywebpush paso a paso</a></li>
<li><a href="../es423197/index.html">LOLWUT: una obra de arte en un equipo de db</a></li>
<li><a href="../es423203/index.html">El l√≠der del equipo ser√° responsable del servicio.</a></li>
<li><a href="../es423205/index.html">Proyecto de almacenamiento en MS SQL Server, integraci√≥n con 1C 7.7 y automatizaci√≥n del desarrollo en SSDT</a></li>
<li><a href="../es423207/index.html">C√≥mo hacer una actualizaci√≥n autom√°tica de un cliente de juego en l√≠nea</a></li>
<li><a href="../es423209/index.html">Killer Form 2? Descripci√≥n general de la impresora 3D Dental MoonRay S100</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>