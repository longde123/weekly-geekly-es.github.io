<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üç∑ üë©üèø üÜî Zenject: Wie ein IoC-Container die Abh√§ngigkeitsinjektion f√ºr Ihr Projekt beenden kann ‚ò™Ô∏è üë®üèΩ‚Äçü§ù‚Äçüë®üèª üçã</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Wo beginnt die Gefahr? Angenommen, Sie sind fest entschlossen, ein Projekt zu entwickeln, das sich an ein bestimmtes Konzept oder einen bestimmten Ans...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Zenject: Wie ein IoC-Container die Abh√§ngigkeitsinjektion f√ºr Ihr Projekt beenden kann</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/420235/">  Wo beginnt die Gefahr?  Angenommen, Sie sind fest entschlossen, ein Projekt zu entwickeln, das sich an ein bestimmtes Konzept oder einen bestimmten Ansatz h√§lt.  In unserer Situation ist dies DI, obwohl beispielsweise auch die reaktive Programmierung an ihrer Stelle sein kann.  Es ist logisch, dass Sie sich zur Erreichung Ihres Ziels vorgefertigten L√∂sungen zuwenden (in unserem Beispiel dem DI Zenject-Container).  Sie werden sich mit der Dokumentation vertraut machen und mit dem Erstellen des Anwendungsframeworks unter Verwendung der Hauptfunktionalit√§t beginnen.  Wenn Sie in den ersten Phasen der Verwendung der L√∂sung keine unangenehmen Empfindungen haben, bleibt sie h√∂chstwahrscheinlich ein Leben lang in Ihrem Projekt.  W√§hrend Sie mit den Grundfunktionen der L√∂sung (Container) arbeiten, haben Sie m√∂glicherweise Fragen oder W√ºnsche, um einige Funktionen sch√∂ner oder effektiver zu gestalten.  Sicherlich wenden Sie sich zun√§chst den erweiterten ‚ÄûFunktionen‚Äú der L√∂sung (Container) zu.  In diesem Stadium kann die folgende Situation auftreten: Sie kennen die gew√§hlte L√∂sung bereits gut und vertrauen ihr, weshalb viele m√∂glicherweise nicht dar√ºber nachdenken, wie ideologisch korrekt die Verwendung der einen oder anderen Funktion in der L√∂sung sein kann, oder der √úbergang zu einer anderen L√∂sung ist bereits recht teuer und unangemessen ( z. B. n√§hert sich die Frist).  In diesem Stadium kann die gef√§hrlichste Situation auftreten - die L√∂sungsfunktionalit√§t wird mit wenig Sorgfalt oder in seltenen F√§llen einfach auf der Maschine (gedankenlos) verwendet. <br><a name="habracut"></a><br><h3>  Wer k√∂nnte daran interessiert sein? </h3><br>  Dieser Artikel ist sowohl f√ºr diejenigen n√ºtzlich, die mit DI-Anh√§ngern vertraut sind, als auch f√ºr Anf√§nger.  Um gen√ºgend Grundkenntnisse dar√ºber zu verstehen, welche Muster von DI verwendet werden, welchen Zweck DI hat und welche Funktionen ein IoC-Container ausf√ºhrt.  Es geht nicht um die Feinheiten der Zenject-Implementierung, sondern um die Anwendung eines Teils ihrer Funktionalit√§t.  Der Artikel st√ºtzt sich nur auf die offizielle Zenject-Dokumentation und Codebeispiele sowie auf Mark Simans Buch ‚ÄûDependency Injection in .NET‚Äú, eine klassische, umfassende Arbeit zum Thema DI-Theorie.  Alle Zitate in diesem Artikel sind Ausz√ºge aus Mark Simans Buch.  Trotz der Tatsache, dass wir √ºber einen bestimmten Container sprechen werden, kann der Artikel f√ºr diejenigen n√ºtzlich sein, die andere Container verwenden. <br><br>  Der Zweck dieses Artikels ist es zu zeigen, wie ein Tool, das Ihnen bei der Implementierung von DI in Ihrem Projekt helfen soll, Sie in eine v√∂llig andere Richtung f√ºhren kann und Sie dazu bringt, Fehler zu machen, die Ihren Code binden, die Testbarkeit von Code verringern und Ihnen im Allgemeinen alle Vorteile vorenthalten, die sich bieten k√∂nnen du DI. <br><br>  <i><b>Haftungsausschluss</b></i> : Der Zweck dieses Artikels besteht nicht darin, Zenject oder seine Autoren zu kritisieren.  Zenject kann f√ºr den beabsichtigten Zweck verwendet werden und dient als hervorragendes Werkzeug f√ºr die Implementierung von DI, vorausgesetzt, Sie verwenden nicht alle Funktionen, da Sie einige Einschr√§nkungen f√ºr sich selbst definiert haben. <br><br><h3>  Einf√ºhrung </h3><br>  <i>Zenject</i> ist ein Open-Source-Container f√ºr Abh√§ngigkeitsinjektionen, der auf die Verwendung der Unity3D-Spiele-Engine abzielt, die auf den meisten von Unity3D unterst√ºtzten Plattformen funktioniert.  Es ist erw√§hnenswert, dass Zenject auch f√ºr C # -Anwendungen verwendet werden kann, die ohne Unity3D entwickelt wurden.  Dieser Container ist bei Unity-Entwicklern sehr beliebt, wird aktiv unterst√ºtzt und entwickelt.  Dar√ºber hinaus verf√ºgt Zenject √ºber alle erforderlichen DI-Container-Funktionen. <br><br>  Ich habe Zenject in 3 gro√üen Unity-Projekten verwendet und auch mit einer gro√üen Anzahl von Entwicklern kommuniziert, die es verwendet haben.  Der Grund f√ºr das Schreiben dieses Artikels sind h√§ufig gestellte Fragen: <br><br><ul><li>  Ist die Verwendung von Zenject eine gute L√∂sung? </li><li>  Was ist los mit Zenject? </li><li>  Welche Schwierigkeiten treten bei der Verwendung von Zenject auf? </li></ul><br>  Und auch einige Projekte, bei denen die Verwendung von Zenject nicht zur L√∂sung von Problemen mit starker Code-Konnektivit√§t und erfolgloser Architektur f√ºhrte, sondern im Gegenteil die Situation versch√§rfte. <br><br>  Mal sehen, warum Entwickler solche Fragen und Probleme haben.  Sie k√∂nnen wie folgt antworten: <br><blockquote>  Ironischerweise neigen DI-Container selbst dazu, stabile Abh√§ngigkeiten zu sein.  ... Wenn Sie sich entscheiden, Ihre Anwendung basierend auf einem bestimmten DI-Container zu entwickeln, laufen Sie Gefahr, w√§hrend des gesamten Anwendungslebenszyklus auf diese Auswahl beschr√§nkt zu sein. </blockquote>  Es ist anzumerken, dass bei ordnungsgem√§√üer und eingeschr√§nkter Verwendung des Containers die Umstellung auf die Verwendung eines anderen Containers in der Anwendung (oder die Verweigerung der Verwendung des Containers zugunsten der ‚Äû <i>Implementierung f√ºr die Armen</i> ‚Äú) durchaus m√∂glich ist und nicht viel Zeit in Anspruch nimmt.  In einer solchen Situation ist es zwar unwahrscheinlich, dass Sie sie ben√∂tigen. <br><br>  Bevor Sie beginnen, die potenziell gef√§hrliche Funktionalit√§t von Zenject zu zerlegen, ist es sinnvoll, einige grundlegende Aspekte von DI oberfl√§chlich zu aktualisieren. <br><br>  Der erste Aspekt ist der <i>Zweck von DI-Containern.</i>  Mark Siman schreibt in seinem Buch Folgendes zu diesem Thema: <br><blockquote>  Ein DI-Container ist eine Softwarebibliothek, die viele der Aufgaben automatisieren kann, die beim Zusammenstellen von Objekten und Verwalten ihres Lebenszyklus ausgef√ºhrt werden. </blockquote><blockquote>  Erwarten Sie nicht, dass der DI-Container stark gekoppelten Code auf magische Weise in lose gekoppelten Code verwandelt.  Ein Container kann die Effizienz der Verwendung von DI verbessern. Der Schwerpunkt der Anwendung sollte jedoch in erster Linie auf der Verwendung von Mustern und der Arbeit mit DI liegen. </blockquote>  Der zweite Aspekt sind <i>DI-Muster</i> .  Mark Siman identifiziert vier Hauptmuster, sortiert nach H√§ufigkeit und Notwendigkeit ihrer Verwendung: <br><br><ol><li>  Implementierung des Konstruktors - Wie k√∂nnen wir sicherstellen, dass die erforderliche Abh√§ngigkeit f√ºr die zu entwickelnde Klasse immer verf√ºgbar ist? </li><li>  Eigenschaftsimplementierung - Wie kann ich DI als Option in der Klasse aktivieren, wenn ein geeigneter lokaler Standard vorhanden ist? </li><li>  Implementierung der Methode - Wie kann ich Abh√§ngigkeiten in eine Klasse einf√ºgen, wenn sie f√ºr jede Operation unterschiedlich sind? </li><li>  Umgebungskontext - Wie k√∂nnen wir eine Abh√§ngigkeit in jedem Modul verf√ºgbar machen, ohne √ºbergreifende Aspekte der Anwendung in jede API-Komponente aufzunehmen? </li></ol><br>  Die neben dem Namen der Muster angegebenen Fragen beschreiben ihren Umfang vollst√§ndig.  Gleichzeitig wird in dem Artikel nicht auf die Implementierung des Konstruktors (da praktisch keine Beschwerden √ºber seine Implementierung in Zenject vorliegen) und den Umgebungskontext (seine Implementierung befindet sich nicht im Container, aber Sie k√∂nnen ihn basierend auf vorhandenen Funktionen problemlos implementieren) eingegangen. <br>  Jetzt k√∂nnen Sie direkt zur potenziell gef√§hrlichen Funktionalit√§t von Zenject wechseln. <br><br><h3>  Gef√§hrliche Funktionalit√§t. </h3><br><h4>  Implementieren Sie Eigenschaften </h4><br>  Dies ist nach der Implementierung des Konstruktors das zweith√§ufigste DI-Muster, wird jedoch viel seltener verwendet.  In Zenject wie folgt implementiert: <br><br><pre><code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Foo</span></span> { [Inject] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> IBar Bar { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } }</code> </pre> <br>  Dar√ºber hinaus hat Zenject auch ein Konzept wie "Field Injection".  Mal sehen, warum diese Funktionalit√§t in allen Zenjects am gef√§hrlichsten ist. <br><br><ul><li>  Ein Attribut wird verwendet, um dem Container anzuzeigen, welches Feld eingebettet werden soll.  Dies ist unter dem Gesichtspunkt der Einfachheit und Logik der Implementierung des Containers selbst eine vollst√§ndig verst√§ndliche L√∂sung.  Wir sehen jedoch ein Attribut (sowie einen Namespace) im Klassencode.  Das ist zumindest indirekt, aber die Klasse beginnt zu wissen, woher sie die Abh√§ngigkeit bezieht.  Au√üerdem fangen wir an, den Klassencode f√ºr den Container zu versch√§rfen.  Mit anderen Worten, wir k√∂nnen die Verwendung von Zenject nicht l√§nger ablehnen, ohne den Klassencode zu manipulieren. </li><li>  Das Muster selbst wird in Situationen verwendet, in denen die Abh√§ngigkeit einen lokalen Standard hat.  Das hei√üt, dies ist eine optionale Abh√§ngigkeit. Wenn der Container sie nicht bereitstellen kann, gibt es keine Fehler im Projekt und alles funktioniert.  Bei Verwendung von Zenject erhalten Sie jedoch immer diese Abh√§ngigkeit - die Abh√§ngigkeit wird nicht optional. </li><li>  Da die Abh√§ngigkeit in diesem Fall nicht optional ist, wird die gesamte Logik der Konstruktorimplementierung beeintr√§chtigt, da dort nur die erforderlichen Abh√§ngigkeiten eingef√ºhrt werden sollten.  Durch die Implementierung nicht optionaler Abh√§ngigkeiten √ºber Eigenschaften erhalten Sie die M√∂glichkeit, zirkul√§re Abh√§ngigkeiten im Code zu erstellen.  Sie sind nicht so offensichtlich, da in Zenject zuerst die Implementierung des Konstruktors und dann die Implementierung der Eigenschaft erf√ºllt wird und Sie keine Warnung vom Container erhalten. </li><li>  Die Verwendung des DI-Containers impliziert die Implementierung des Composition Root-Musters. Die Verwendung des Attributs zum Konfigurieren der Implementierung der Eigenschaft f√ºhrt jedoch dazu, dass Sie den Code nicht nur im Composition Root, sondern auch nach Bedarf in jeder Klasse konfigurieren. </li></ul><br><h4>  Fabriken (und MemoryPool) </h4><br>  Die Zenject-Dokumentation enth√§lt einen ganzen <a href="">Abschnitt</a> √ºber Fabriken.  Diese Funktionalit√§t wird auf der Ebene des Containers selbst implementiert, und es ist auch m√∂glich, eigene benutzerdefinierte Fabriken zu erstellen.  Schauen wir uns das erste Beispiel aus der Dokumentation an: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Enemy</span></span> { DiContainer Container; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Enemy</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">DiContainer container</span></span></span><span class="hljs-function">)</span></span> { Container = container; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Update</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { ... <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> player = Container.Resolve&lt;Player&gt;(); WalkTowards(player.Position); ... etc. } }</code> </pre> <br>  Bereits in diesem Beispiel liegt eine grobe Verletzung von DI vor.  Dies ist jedoch eher ein Beispiel f√ºr die Herstellung einer vollst√§ndig benutzerdefinierten Fabrik.  Was ist hier das Hauptproblem? <br><blockquote>  Ein DI-Container kann f√§lschlicherweise als Service Locator betrachtet werden, sollte jedoch nur als Mechanismus zum Verkn√ºpfen von Objektgraphen verwendet werden.  Wenn wir den Container unter diesem Gesichtspunkt betrachten, ist es sinnvoll, seine Verwendung nur auf den Stamm des Layouts zu beschr√§nken.  Dieser Ansatz hat den wichtigen Vorteil, dass keine Bindung zwischen dem Container und dem Rest des Anwendungscodes besteht. </blockquote>  Schauen wir uns an, wie die ‚Äûeingebauten‚Äú Fabriken von Zenject funktionieren.  Hierf√ºr gibt es eine IFactory-Schnittstelle, deren Implementierung uns zur PlaceholderFactory-Klasse f√ºhrt: <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">abstract</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">PlaceholderFactory</span></span>&lt;<span class="hljs-title"><span class="hljs-title">TValue</span></span>&gt; : <span class="hljs-title"><span class="hljs-title">IPlaceholderFactory</span></span> { [Inject] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Construct</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IProvider provider, InjectContext injectContext</span></span></span><span class="hljs-function">)</span></span></code> </pre> <br>  Darin sehen wir den InjectContext-Parameter, der viele Konstruktoren der Form hat: <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">InjectContext</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">DiContainer container, Type memberType</span></span></span><span class="hljs-function">) : </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">this</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Container = container; MemberType = memberType; }</code> </pre> <br>  Und wieder erhalten wir die √úbertragung des Containers selbst als Abh√§ngigkeit von der Klasse.  Dieser Ansatz ist eine grobe Verletzung von DI und eine teilweise Umwandlung des Containers in einen Services Locator. <br>  Dar√ºber hinaus besteht der Nachteil dieser L√∂sung darin, dass der Container zum Erstellen kurzfristiger Abh√§ngigkeiten verwendet wird und nur langfristige Abh√§ngigkeiten erstellen sollte. <br><br>  Um solche Verst√∂√üe zu vermeiden, k√∂nnten die Autoren des Containers die M√∂glichkeit, den Container als Abh√§ngigkeit an alle registrierten Klassen zu √ºbergeben, vollst√§ndig ausschlie√üen.  Es w√§re nicht schwierig, dies zu implementieren, da der gesamte Container durch Reflexion und Analyse der Parameter von Methoden und Konstruktoren arbeitet, um das Diagramm von Anwendungsobjekten zu erstellen und zu gestalten. <br><br><h4>  Methodenimplementierung </h4><br>  Die Logik der Implementierung der Methode in Zenject lautet wie folgt: Zuerst wird in allen Klassen der Konstruktor implementiert, dann werden die Eigenschaften implementiert und schlie√ülich wird die Methode implementiert.  Betrachten Sie das Implementierungsbeispiel in der Dokumentation: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Foo</span></span> { [Inject] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Init</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IBar bar, Qux qux</span></span></span><span class="hljs-function">)</span></span> { _bar = bar; _qux = qux; } }</code> </pre> <br>  Was sind die Nachteile hier: <br><br><ul><li>  Sie k√∂nnen beliebig viele Methoden schreiben, die im Rahmen einer Klasse implementiert werden.  So erhalten wir wie bei der Implementierung der Eigenschaft die M√∂glichkeit, m√∂glichst viele zyklische Abh√§ngigkeiten herzustellen. </li><li>  Wie die Implementierung einer Eigenschaft wird die Implementierung einer Methode mithilfe eines Attributs implementiert, das Ihren Code mit dem Code des Containers selbst verkn√ºpft. </li><li>  Die Implementierung der Methode in Zenject wird nur als Alternative zu Konstruktoren verwendet, was im Fall von MonoBehavior-Klassen praktisch ist, widerspricht jedoch absolut der von Mark Siman beschriebenen Theorie.  Das klassische Beispiel f√ºr die kanonische Implementierung der Methode kann die Verwendung von Fabriken (Fabrikmethoden) sein. </li><li>  Wenn es in der Klasse mehrere eingef√ºhrte Methoden gibt oder zus√§tzlich zu der Methode auch einen Konstruktor, stellt sich heraus, dass die f√ºr die Klasse erforderlichen Abh√§ngigkeiten an verschiedenen Stellen verstreut sind, was das gesamte Bild beeintr√§chtigt.  Das hei√üt, wenn Klasse 1 einen Konstruktor hat, kann die Anzahl ihrer Parameter deutlich zeigen, ob Entwurfsfehler in der Klasse vorliegen und ob das Prinzip der alleinigen Verantwortung verletzt wird und ob die Abh√§ngigkeiten durch mehrere Methoden, durch den Konstruktor oder m√∂glicherweise durch einige Eigenschaften verstreut sind. dann wird das Bild nicht so offensichtlich sein, wie es sein k√∂nnte. </li></ul><br>  Daraus folgt, dass das Vorhandensein einer solchen Implementierung der Methodenimplementierung im Container, die der DI-Theorie widerspricht, kein einziges Plus hat.  Mit einer gro√üen Einschr√§nkung kann ein Plus nur als die M√∂glichkeit angesehen werden, die implementierte Methode als Konstruktor f√ºr MonoBehaviour zu verwenden.  Dies ist jedoch ein ziemlich kontroverser Punkt, da aus Sicht der Containerlogik, der DI-Muster und des internen Unity3D-Speicherger√§ts alle MonoBehaviour-Objekte in Ihrer Anwendung als ressourcenverwaltet betrachtet werden k√∂nnen. In diesem Fall ist es viel effizienter, die Lebenszyklusverwaltung solcher Objekte zu delegieren kein DI-Container, sondern eine Hilfsklasse (sei es Wrapper, ViewModel, Fasade oder etwas anderes). <br><br><h4>  Globale Bindungen </h4><br>  Dies ist eine recht praktische Zusatzfunktion, mit der Sie globale Ordner festlegen k√∂nnen, die unabh√§ngig vom √úbergang zwischen Szenen leben k√∂nnen.  Weitere Informationen finden Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">in der Dokumentation</a> .  Diese Funktionalit√§t ist √§u√üerst praktisch und sehr n√ºtzlich.  Es ist erw√§hnenswert, dass es nicht gegen die Muster und Prinzipien von DI verst√∂√üt, jedoch eine nicht offensichtliche und h√§ssliche Implementierung hat.  Die Quintessenz ist, dass Sie eine spezielle Art von Fertighaus erstellen, ein Skript mit der Containerkonfiguration (Installationsprogramm) anh√§ngen und es in einem streng definierten Projektordner speichern, ohne die M√∂glichkeit, irgendwohin zu wechseln und ohne Links dazu.  Der Nachteil dieses Tools liegt allein in seiner Implizit√§t.  Bei normalen Installationsprogrammen ist alles ganz einfach: Sie haben ein Objekt auf der B√ºhne, das Installationsskript h√§ngt daran.  Wenn ein neuer Entwickler zum Projekt kommt, wird der Installer zu einem hervorragenden Punkt f√ºr das Eintauchen in das Projekt.  Basierend auf einem einzelnen Installationsprogramm kann ein Entwickler eine Vorstellung davon machen, aus welchen Modulen ein Projekt besteht und wie ein Diagramm von Objekten erstellt wird.  Mit der Verwendung globaler Bindemittel ist der Installer auf der B√ºhne jedoch keine ausreichende Quelle f√ºr diese Informationen mehr.  Es gibt keinen einzigen Link zur globalen Bindung im Code anderer Installationsprogramme (in den Szenen vorhanden), und daher wird nicht das vollst√§ndige Diagramm der Objekte angezeigt.  Und nur w√§hrend der Analyse der Klassen verstehen Sie, dass einige der Ordner im Installationsprogramm auf der B√ºhne nicht ausreichen.  Ich werde noch einmal einen Vorbehalt machen, dass dieser Nachteil rein kosmetischer Natur ist. <br><br><h4>  Kennungen </h4><br>  Die M√∂glichkeit, eine bestimmte Bindung f√ºr einen Bezeichner festzulegen, um eine bestimmte Abh√§ngigkeit von einer Reihe √§hnlicher Abh√§ngigkeiten in einer Klasse zu erhalten.  Ein Beispiel: <br><br><pre> <code class="cs hljs">Container.Bind&lt;IFoo&gt;().WithId(<span class="hljs-string"><span class="hljs-string">"foo"</span></span>).To&lt;Foo1&gt;().AsSingle(); Container.Bind&lt;IFoo&gt;().To&lt;Foo2&gt;().AsSingle(); <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Bar1</span></span> { [Inject(Id = <span class="hljs-string"><span class="hljs-string">"foo"</span></span>)] IFoo _foo; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Bar2</span></span> { [Inject] IFoo _foo; }</code> </pre> <br>  Diese Funktionalit√§t kann wirklich situativ n√ºtzlich sein und ist eine zus√§tzliche Option f√ºr die Implementierung von Eigenschaften.  Neben der Benutzerfreundlichkeit werden jedoch alle im Abschnitt ‚ÄûImplementieren von Eigenschaften‚Äú genannten Probleme √ºbernommen, wodurch der Code noch koh√§renter wird, indem eine bestimmte Konstante eingef√ºhrt wird, die Sie bei der Konfiguration Ihres Codes ber√ºcksichtigen m√ºssen.  Wenn Sie diese Kennung versehentlich l√∂schen, k√∂nnen Sie leicht eine nicht funktionierende aus der funktionierenden Anwendung abrufen. <br><br><h4>  Signale und ITickable </h4><br>  Signale sind ein Analogon des in den Container integrierten Ereignisaggregatormechanismus.  Die Idee, diese Funktionalit√§t zu implementieren, ist zweifellos nobel, da sie darauf abzielt, die Anzahl der Verbindungen zwischen Objekten zu verringern, die √ºber den Mechanismus von Ereignisabonnements kommunizieren.  Ein ziemlich umfangreiches Beispiel finden Sie in der <a href="">Dokumentation</a> , es wird jedoch nicht im Artikel enthalten sein, da die spezifische Implementierung keine Rolle spielt. <br><br>  Unterst√ºtzung f√ºr die ITickable-Schnittstelle - Ersetzen der Standardmethoden Update, LateUpdate und FixedUpdate in Unity durch Delegieren von Aufrufen an Methoden zum Aktualisieren von Objekten mit der ITickable-Schnittstelle an den Container.  Ein Beispiel finden Sie auch in der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Dokumentation</a> , und die Implementierung im Kontext des Artikels spielt ebenfalls keine Rolle. <br><br>  Das Problem von Signals und ITickable betrifft keine Aspekte ihrer Implementierung, seine Wurzel liegt in der Verwendung von Nebenwirkungen des Containers.  Im Kern kennt der Container fast alle Klassen und ihre Instanzen innerhalb des Projekts. Seine Aufgabe besteht jedoch darin, ein Diagramm der Objekte zu erstellen und ihren Lebenszyklus zu verwalten.  Durch Hinzuf√ºgen von Mechanismen wie Signale, ITickable usw. f√ºgen wir dem Container mehr Verantwortlichkeiten hinzu und f√ºgen ihm immer mehr den Anwendungscode hinzu, wodurch er zum exklusiven und unersetzlichen Teil des Codes wird, praktisch zu einem ‚Äûg√∂ttlichen Objekt‚Äú. <br><br><h3>  Anstelle von Ausgabe </h3><br><blockquote>  Das Wichtigste an Containern ist zu verstehen, dass die Verwendung von DI unabh√§ngig von der Verwendung eines DI-Containers ist.  Eine Anwendung kann aus vielen lose gekoppelten Klassen und Modulen erstellt werden, und keines dieser Module sollte etwas √ºber den Container wissen. </blockquote>  Seien Sie vorsichtig, wenn Sie Out-of-the-Box-L√∂sungen (Boxed-L√∂sungen) oder kleine Plugins verwenden.  Verwenden Sie sie nachdenklich.  In der Tat k√∂nnen noch gro√üartigere Dinge, auf die Sie sich verlassen (zum Beispiel Spiel-Engines der Gr√∂√üenordnung von Unity3D selbst), mit solchen theoretischen Fehlern und Blots s√ºndigen.  Dies wirkt sich letztendlich nicht auf die Arbeit der von Ihnen verwendeten L√∂sung aus, sondern auf die Nachhaltigkeit, Arbeit und Qualit√§t Ihres Endprodukts.  Ich hoffe, jeder, der bis zum Ende gelesen hat, der Artikel wird n√ºtzlich sein oder zumindest die Zeit, die er damit verbracht hat, nicht zu bereuen. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de420235/">https://habr.com/ru/post/de420235/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de420223/index.html">Ein paar einfache Tipps: So verhindern Sie Sch√§den an der Drohne</a></li>
<li><a href="../de420225/index.html">Unendliche algorithmische Melodie basierend auf Primzahlen</a></li>
<li><a href="../de420227/index.html">Der t√ºrkische Pr√§sident gibt ein Verbot des US-Imports von Elektronik bekannt</a></li>
<li><a href="../de420229/index.html">K√∂nnen Kinder in den D√∂rfern Programmierer werden, wenn sie in der N√§he nur Eisenbahnarbeiter unterrichten? Gespr√§ch mit dem "Kreis"</a></li>
<li><a href="../de420233/index.html">UE4 | Ausr√ºstung f√ºr den Mehrspielermodus # 5 | Informations√ºbertragung zwischen Server und Client</a></li>
<li><a href="../de420237/index.html">Qt-Wrapper um das gRPC-Framework in C ++</a></li>
<li><a href="../de420239/index.html">Mobile Entwicklung. Swift: das Geheimnis der Protokolle</a></li>
<li><a href="../de420243/index.html">Durchbruch Philanthropie: Humanit√§re Durchbruchsprojekte</a></li>
<li><a href="../de420245/index.html">So verhindern Sie einen Speicher√ºberlauf bei Verwendung von Java-Sammlungen</a></li>
<li><a href="../de420251/index.html">Apple behauptet, dass der Hauptsitzkomplex des Unternehmens nur 200 US-Dollar kostet</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>