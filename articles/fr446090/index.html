<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚òïÔ∏è üé§ ü•ì Micropython sur module GSM + GPS A9G üë©üèº‚Äçüåæ üë®üèΩ‚Äçü§ù‚Äçüë®üèº üìç</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Cette fois, j'ai pens√© √† cacher un tracker GPS dans mon v√©lo par pr√©caution. Il existe des tonnes d'appareils autonomes sur le march√© pour suivre les ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Micropython sur module GSM + GPS A9G</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/446090/"><p>  Cette fois, j'ai pens√© √† cacher un tracker GPS dans mon v√©lo par pr√©caution.  Il existe des tonnes d'appareils autonomes sur le march√© pour suivre les voitures, les marchandises, les v√©los, les bagages, les enfants et les animaux.  La grande majorit√© d'entre eux interagissent avec l'utilisateur via SMS.  Des options plus co√ªteuses offrent la fonctionnalit√© Localiser mon t√©l√©phone, mais sont li√©es √† un service en ligne sp√©cifique. <br>  Id√©alement, je voudrais avoir un contr√¥le total sur le tracker: utilisez-le dans un mode pratique sans SMS ni inscription.  Google superficiel m'a apport√© quelques modules en provenance de Chine, dont un que j'ai command√© (carte de pudding A9G) (~ 15 $). </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/f7f/b34/fe0/f7fb34fe016bb3a6c532712b9b2e75e1.png" alt="Module"></p><br><p>  Cet article explique comment j'ai fait fonctionner python sur ce module. </p><a name="habracut"></a><br><p>  Si l'A9G est un analogue de l'ESP (le fabricant est d'ailleurs le m√™me), la carte de pudding elle-m√™me est un analogue de la carte NodeMCU, sauf que la carte de pudding n'a pas de convertisseur USB-UART int√©gr√©.  Mais il y a beaucoup d'autres choses int√©ressantes.  Sp√©cifications du <a href="">fabricant</a> : </p><br><ul><li>  Noyau 32 bits (RISC), jusqu'√† 312 MHz </li><li>  29x GPIO (tous sont soud√©s, toutes les interfaces sont incluses dans ce num√©ro) </li><li>  montres et chien de garde </li><li>  1x interface USB 1.1 (je ne l'ai pas trouv√©e l√†-bas, mais copie hors site) et microUSB pour l'alimentation </li><li>  2x UART (+1 service) </li><li>  2x SPI (non essay√©) </li><li>  3x I2C (non essay√©) </li><li>  1x SDMMC (avec emplacement physique) </li><li>  2x entr√©es analogiques (10 bits, dont l'une est utilis√©e par les contr√¥leurs de batterie au lithium) </li><li>  Flash 4 Mo </li><li>  4 Mo de PSRAM </li><li>  ADC (microphone, existe physiquement sur la carte) et DAC (haut-parleur, absent) </li><li>  contr√¥leur de charge de la batterie (il n'y a pas de batterie elle-m√™me) </li><li>  en fait, GSM (800, 900, 1800, 1900 MHz) avec SMS, voix et GPRS </li><li>  GPS connect√© via UART2 (il y a un module ¬´A9¬ª sans) </li><li>  Emplacement SIM (nanoSIM) </li><li>  deux boutons (un reset, l'autre - inclusion et fonction programmable) </li><li>  deux LED </li></ul><br><p>  La tension de fonctionnement est de 3,3 V, la tension d'entr√©e est de 5 √† 3,8 V (selon la connexion).  En g√©n√©ral, le module dispose de tout le mat√©riel n√©cessaire pour en assembler un simple appareil mobile √† bouton poussoir.  Mais d'apr√®s les exemples, il semble que les Chinois l'ach√®tent pour la vente √† partir de machines √† sous ou de machines √† sous ou quelque chose comme √ßa.  Les alternatives au module sont des modules SIM800 tr√®s populaires, qui, malheureusement, n'ont pas de SDK dans le domaine public (c'est-√†-dire que les modules sont vendus comme modems AT). </p><br><h1>  SDK </h1><br><p> Le module est livr√© avec un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">SDK</a> dans un anglais satisfaisant.  S'installe sous Ubuntu, mais Windows et les conteneurs sont pr√©f√©r√©s.  Tout fonctionne par piquer dans l'interface graphique: ESPtool pour ce module n'a pas encore √©t√© annul√©.  Le firmware lui-m√™me est construit par le Makefile.  Le d√©bogueur est pr√©sent: avant le gel, le module jette la trace de pile dans le port de service.  Mais personnellement, je n'ai pas pu traduire les adresses en lignes de code (gdb rapporte que les adresses ne correspondent √† rien).  Il est possible que cela soit d√ª √† une mauvaise prise en charge de Linux en tant que tel.  En cons√©quence, si vous voulez bricoler avec le module - essayez de le faire sous Windows (et d√©sabonnez-vous sur github).  Sinon, voici les <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">instructions</a> pour Linux.  Apr√®s l'installation, vous devez v√©rifier l'exactitude des chemins d'acc√®s dans .bashrc et supprimer (renommer) tous les <code>CSDTK/lib/libQt*</code> : sinon, le clignotant (aka d√©bogueur) ne d√©marre tout simplement pas en raison d'un conflit avec, probablement, install√© libQt. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/7a7/955/5bc/7a79555bca02e1ad6363b8da9559c91e.png" alt="Flasher"></p><br><p>  Pour le clignotant, il y a une <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">instruction</a> . </p><br><h1>  Connexion </h1><br><p>  Tout est plus compliqu√© que sur NodeMCU.  Les modules se ressemblent, mais il n'y a pas de puce USB-TTY sur la carte de pudding et microUSB n'est utilis√© que pour l'alimentation.  En cons√©quence, vous aurez besoin d'un port USB-TTY √† 3,3 V.  Deux sont meilleurs: un pour le port de d√©bogage et un pour UART1: le premier est utilis√© pour t√©l√©charger le firmware et le second que vous pouvez utiliser comme terminal normal.  Afin de ne pas faire glisser toutes ces morve sur l'ordinateur, j'ai √©galement achet√© un s√©parateur USB √† 4 ports avec un c√¢ble de deux m√®tres et une alimentation externe (requise).  Le co√ªt total de ce kit avec le module lui-m√™me sera de 25-30 $ (sans alimentation: utilisation depuis le t√©l√©phone). </p><br><h1>  Firmware </h1><br><p>  Le module est livr√© avec le firmware AT: vous pouvez vous connecter √† un Arduino 3.3V et l'utiliser comme modem via UART1.  Leur firmware est √©crit en C. <code>make</code> cr√©e deux fichiers de firmware: l'un est cousu pendant environ une minute, l'autre est assez rapide.  Un seul de ces fichiers peut √™tre cousu: la premi√®re fois est grande, les heures suivantes sont petites.  Au total, pendant le processus de d√©veloppement, j'ai le SDK chinois ( <code>coolwatcher</code> ) ouvert sur le bureau pour g√©rer le module, le miniterm comme stdio et l'√©diteur de code. </p><br><h1>  API </h1><br><p>  Le contenu de l' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">API</a> refl√®te la liste ci-dessus et ressemble √† l'ESP8266 √† ses d√©buts: il m'a fallu environ 3 heures pour lancer HelloWorld.  Malheureusement, l'ensemble des fonctions disponibles pour l'utilisateur est tr√®s limit√©: par exemple, il n'y a pas d'acc√®s au r√©pertoire t√©l√©phonique sur la carte SIM, des informations de bas niveau sur la connexion au r√©seau cellulaire, etc.  La documentation de l'API est encore moins compl√®te, vous devez donc vous fier √† des exemples (dont il en existe deux douzaines) et inclure des fichiers.  N√©anmoins, le module peut faire beaucoup de choses jusqu'aux connexions SSL: √©videmment, le constructeur s'est concentr√© sur les fonctions les plus prioritaires. </p><br><p>  Cependant, la programmation des microcontr√¥leurs chinois via l'API chinoise doit √™tre appr√©ci√©e.  Pour tout le monde, le fabricant a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">commenc√© √† porter le</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">micropython</a> sur ce module.  J'ai d√©cid√© de m'essayer dans un projet open-source et de poursuivre ce bon travail (lien en fin d'article). </p><br><h1>  micropython </h1><br><p><img src="https://habrastorage.org/getpro/habr/post_images/9a1/b46/e00/9a1b46e00d290db2f478ebb54f7d9e74.jpg" alt="logo"></p><br><p>  Micropython est un projet open-source portant cPython sur des microcontr√¥leurs.  Le d√©veloppement s'effectue dans deux directions.  Le premier est le support et le d√©veloppement de biblioth√®ques de base communes √† tous les microcontr√¥leurs qui d√©crivent le travail avec les principaux types de donn√©es en python: objets, fonctions, classes, cha√Ænes, types atomiques, etc.  Le second est, en fait, les ports: pour chaque microcontr√¥leur il faut ¬´apprendre¬ª √† la biblioth√®que √† travailler avec UART pour les entr√©es-sorties, s√©lectionner une pile pour une machine virtuelle, sp√©cifier un ensemble d'optimisations.  En option, le travail avec le mat√©riel est d√©crit: GPIO, alimentation, sans fil, syst√®me de fichiers. <br>  Tout cela est √©crit en C pur avec des macros: micropython a un ensemble de recettes recommand√©es de la d√©claration de cha√Ænes dans la ROM aux modules d'√©criture.  En plus de cela, les modules auto-√©crits python sont enti√®rement pris en charge (l'essentiel est de ne pas oublier la taille de la m√©moire).  Les conservateurs du projet se sont donn√© comme objectif <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">de lancer un dzhanga</a> (photo avec une miche de pain).  Comme publicit√©: le projet vend sa propre carte pour les √©tudiants <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">pyboard</a> , mais les ports pour les modules ESP8266 et ESP32 sont √©galement populaires. </p><br><p>  Lorsque le firmware est pr√™t et t√©l√©charg√© - il vous suffit de vous connecter au microcontr√¥leur via UART et d'acc√©der au Python REPL. </p><br><pre> <code class="bash hljs">$ miniterm.py /dev/ttyUSB1 115200 --raw MicroPython cd2f742 on 2017-11-29; unicorn with Cortex-M3 Type <span class="hljs-string"><span class="hljs-string">"help()"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> more information. &gt;&gt;&gt; <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(<span class="hljs-string"><span class="hljs-string">"hello"</span></span>) hello</code> </pre> <br><p>  Apr√®s cela, vous pouvez commencer √† √©crire <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">en python3 presque normal</a> sans oublier les limitations de m√©moire. </p><br><p>  Le module A9G n'est pas officiellement pris en charge (une liste des modules officiellement pris en charge est disponible dans <code>micropython/ports</code> , il y en a environ une douzaine).  N√©anmoins, le fabricant de fer a bifurqu√© le micropython et a cr√©√© l'environnement pour le port <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><code>micropython/ports/gprs_a9</code></a> : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><code>micropython/ports/gprs_a9</code></a> , pour lequel merci beaucoup √† lui.  Au moment o√π je me suis int√©ress√© √† ce probl√®me, le port a √©t√© compil√© avec succ√®s et le microcontr√¥leur m'a accueilli avec REPL.  Mais, malheureusement, √† partir de modules tiers, il n'y avait que du travail avec le syst√®me de fichiers et GPIO: rien li√© au r√©seau sans fil et au GPS n'√©tait disponible.  J'ai d√©cid√© de corriger ce d√©faut et me suis fix√© comme objectif de porter toutes les fonctions n√©cessaires √† un tracker GPS.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">La documentation officielle</a> de cette affaire est inutilement concise: j'ai donc d√ª fouiller dans le code. </p><br><h2>  Par o√π commencer </h2><br><p>  Tout d'abord, acc√©dez √† <code>micropython/ports</code> et copiez <code>micropython/ports/minimal</code> dans le nouveau dossier o√π le port sera situ√©.  Ensuite, modifiez <code>main.c</code> pour votre plateforme.  Gardez √† l'esprit que tout le d√©licieux est dans la fonction <code>main</code> , o√π vous devez appeler l'initialiseur <code>mp_init()</code> , apr√®s avoir pr√©par√© le microcontr√¥leur et les param√®tres de pile pour cela.  Ensuite, pour l'API √©v√©nementielle, vous devez appeler <code>pyexec_event_repl_init()</code> et <code>pyexec_event_repl_init()</code> les caract√®res saisis via UART √† la fonction <code>pyexec_event_repl_process_char(char)</code> .  Cela fournira l'interop√©rabilit√© via REPL.  Le deuxi√®me fichier, <code>micropython/ports/minimal/uart_core.c</code> d√©crit le blocage des entr√©es et des sorties dans UART.  J'apporte le code original pour STM32 pour ceux qui sont trop paresseux pour chercher. </p><br><p> <code>main.c</code> </p> <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> argc, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> **argv)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> stack_dummy; stack_top = (<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>*)&amp;stack_dummy; <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> MICROPY_ENABLE_GC gc_init(heap, heap + sizeof(heap)); #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> mp_init(); #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> MICROPY_ENABLE_COMPILER #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> MICROPY_REPL_EVENT_DRIVEN pyexec_event_repl_init(); for (;;) { int c = mp_hal_stdin_rx_chr(); </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (pyexec_event_repl_process_char(c)) { break; } } #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">else</span></span></span><span class="hljs-meta"> pyexec_friendly_repl(); #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//do_str("print('hello world!', list(x+1 for x in range(10)), end='eol\\n')", MP_PARSE_SINGLE_INPUT); //do_str("for i in range(10):\r\n print(i)", MP_PARSE_FILE_INPUT); #else pyexec_frozen_module("frozentest.py"); #endif mp_deinit(); return 0; }</span></span></span></span></code> </pre> <br><p> <code>uart_core.c</code> </p> <br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Receive single character int mp_hal_stdin_rx_chr(void) { unsigned char c = 0; #if MICROPY_MIN_USE_STDOUT int r = read(0, &amp;c, 1); (void)r; #elif MICROPY_MIN_USE_STM32_MCU // wait for RXNE while ((USART1-&gt;SR &amp; (1 &lt;&lt; 5)) == 0) { } c = USART1-&gt;DR; #endif return c; } // Send string of given length void mp_hal_stdout_tx_strn(const char *str, mp_uint_t len) { #if MICROPY_MIN_USE_STDOUT int r = write(1, str, len); (void)r; #elif MICROPY_MIN_USE_STM32_MCU while (len--) { // wait for TXE while ((USART1-&gt;SR &amp; (1 &lt;&lt; 7)) == 0) { } USART1-&gt;DR = *str++; } #endif }</span></span></code> </pre> <br><p>  Apr√®s cela, vous devez r√©√©crire le Makefile en utilisant les recommandations / compilateur du fabricant: tout est individuel ici.  Tout, id√©alement, cela devrait suffire: nous collectons, remplissons le firmware et voyons REPL dans UART. <br>  Apr√®s avoir relanc√© le <code>micropython</code> vous devez prendre soin de son bien-√™tre: configurer le garbage collector, la bonne r√©action √† Ctrl-D (soft reset) et quelques autres choses sur lesquelles je ne m'attarderai pas: voir le fichier <code>mpconfigport.h</code> . </p><br><h2>  Cr√©er un module </h2><br><p>  La chose la plus int√©ressante est d'√©crire vos propres modules.  Ainsi, le module (non n√©cessaire, mais souhaitable) commence par son propre fichier <code>mod[].c</code> , qui est ajout√© par le <code>Makefile</code> (variable <code>SRC_C</code> si vous suivez la convention).  Un module vide est le suivant: </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// nlr - non-local return:  C  ,      goto-  . //  nlr_raise             . #include "py/nlr.h" //   .  ,  mp_map_elem_t,  ,   . #include "py/obj.h" //   . mp_raise_ValueError(char* msg)  mp_raise_OSError(int errorcode)   . //  ,   mp_call_function_*     Callable (  callback-). #include "py/runtime.h" #include "py/binary.h" //  header   :       #include "portmodules.h" //    --  .     MP_QSTR_[ ]. MP_OBJ_NEW_QSTR   . //             RAM. //      -      __name__ STATIC const mp_map_elem_t mymodule_globals_table[] = { { MP_OBJ_NEW_QSTR(MP_QSTR___name__), MP_OBJ_NEW_QSTR(MP_QSTR_mymodule) }, }; //      STATIC MP_DEFINE_CONST_DICT (mp_module_mymodule_globals, mymodule_globals_table); //   :             const mp_obj_module_t mp_module_mymodule = { .base = { &amp;mp_type_module }, .globals = (mp_obj_dict_t*)&amp;mp_module_mymodule_globals, };</span></span></code> </pre> <br><p>  Bien s√ªr, le port lui-m√™me ne reconna√Æt pas la constante <code>mp_module_mymodule</code> : elle doit √™tre ajout√©e √† la variable <code>MICROPY_PORT_BUILTIN_MODULES</code> dans les param√®tres de port de <code>mpconfigport.h</code> .  Au fait <del>  fonds d'√©cran ennuyeux </del>  le nom de la puce et le nom du port y changent √©galement.  Apr√®s toutes ces modifications, vous pouvez essayer de compiler le module et de l'importer depuis REPL.  Un seul attribut <code>__name__</code> avec le nom du module sera disponible pour le module (un excellent cas pour v√©rifier l'auto-compl√©tion dans REPL via Tab). </p><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> mymodule &gt;&gt;&gt; mymodule.__name__ <span class="hljs-string"><span class="hljs-string">'mymodule'</span></span></code> </pre> <br><h2>  Constantes </h2><br><p>  L'√©tape suivante de la complexit√© consiste √† ajouter des constantes.  Les constantes sont souvent n√©cessaires pour les r√©glages ( <code>INPUT</code> , <code>OUTPUT</code> , <code>HIGH</code> , <code>LOW</code> , etc.) Tout est assez simple ici.  Ici, par exemple, la constante <code>magic_number = 10</code> : </p><br><pre> <code class="cpp hljs">STATIC <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mp_map_elem_t</span></span> mymodule_globals_table[] = { { MP_OBJ_NEW_QSTR(MP_QSTR___name__), MP_OBJ_NEW_QSTR(MP_QSTR_mymodule) }, { MP_OBJ_NEW_QSTR(MP_QSTR_magic_number), MP_OBJ_NEW_SMALL_INT(<span class="hljs-number"><span class="hljs-number">10</span></span>) }, };</code> </pre> <br><p>  Test: </p><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> mymodule &gt;&gt;&gt; mymodule.magic_number <span class="hljs-number"><span class="hljs-number">10</span></span></code> </pre> <br><h2>  Les fonctions </h2><br><p>  L'ajout d'une fonction √† un module suit le principe g√©n√©ral: d√©clarer, encapsuler, ajouter (je donne un exemple un peu plus complexe que dans la documentation). </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//  STATIC mp_obj_t conditional_add_one(mp_obj_t value) { //   int.         -  :   . int value_int = mp_obj_get_int(value); value_int ++; if (value_int == 10) { //  None return mp_const_none; } //   int return mp_obj_new_int(value); } //    .     // runtime.h   . STATIC MP_DEFINE_CONST_FUN_OBJ_1(conditional_add_one_obj, conditional_add_one); //  STATIC const mp_map_elem_t mymodule_globals_table[] = { { MP_OBJ_NEW_QSTR(MP_QSTR___name__), MP_OBJ_NEW_QSTR(MP_QSTR_mymodule) }, { MP_OBJ_NEW_QSTR(MP_QSTR_magic_number), MP_OBJ_NEW_SMALL_INT(10) }, { MP_OBJ_NEW_QSTR(MP_QSTR_conditional_add_one), (mp_obj_t)&amp;conditional_add_one_obj }, };</span></span></code> </pre> <br><p>  Test: </p><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> mymodule &gt;&gt;&gt; mymodule.conditional_add_one(<span class="hljs-number"><span class="hljs-number">3</span></span>) <span class="hljs-number"><span class="hljs-number">4</span></span> &gt;&gt;&gt; mymodule.conditional_add_one(<span class="hljs-number"><span class="hljs-number">9</span></span>) &gt;&gt;&gt;</code> </pre> <br><h2>  Classes (types) </h2><br><p>  Avec les classes (types), tout est aussi relativement simple.  Voici un exemple tir√© de la documentation (enfin, presque): </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//     STATIC const mp_map_elem_t mymodule_hello_locals_dict_table[] = {}; //   STATIC MP_DEFINE_CONST_DICT(mymodule_hello_locals_dict, mymodule_hello_locals_dict_table); // ,  ,   const mp_obj_type_t mymodule_helloObj_type = { //    { &amp;mp_type_type }, // : helloObj .name = MP_QSTR_helloObj, //  .locals_dict = (mp_obj_dict_t*)&amp;mymodule_hello_locals_dict, }; //    STATIC const mp_map_elem_t mymodule_globals_table[] = { { MP_OBJ_NEW_QSTR(MP_QSTR___name__), MP_OBJ_NEW_QSTR(MP_QSTR_mymodule) }, { MP_OBJ_NEW_QSTR(MP_QSTR_magic_number), MP_OBJ_NEW_SMALL_INT(10) }, { MP_OBJ_NEW_QSTR(MP_QSTR_conditional_add_one), (mp_obj_t)&amp;conditional_add_one_obj }, { MP_OBJ_NEW_QSTR(MP_QSTR_conditional_add_one), (mp_obj_t)&amp;mymodule_helloObj_type }, };</span></span></code> </pre> <br><p>  Test: </p><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>mymodule.helloObj &lt;type <span class="hljs-string"><span class="hljs-string">'helloObj'</span></span>&gt;</code> </pre> <br><p>  Le type r√©sultant peut √™tre h√©rit√©, compar√©, mais il n'a pas de constructeur ni de donn√©es associ√©es.  Les donn√©es sont ajout√©es "√† c√¥t√©" du constructeur: il est propos√© de cr√©er une structure distincte dans laquelle le type Python sera stock√© s√©par√©ment et s√©par√©ment - un ensemble de donn√©es arbitraires. </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//  -. ,    typedef struct _mymodule_hello_obj_t { //   mp_obj_base_t base; // -  uint8_t hello_number; } mymodule_hello_obj_t;</span></span></code> </pre> <br><p>  Comment interagir avec ces donn√©es?  L'une des voies les plus difficiles passe par le constructeur. </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// -,   (,  ,   mymodule_helloObj_type //   ,     - ),   (args  kwargs)  //        : args, kwargs STATIC mp_obj_t mymodule_hello_make_new( const mp_obj_type_t *type, size_t n_args, size_t n_kw, const mp_obj_t *args ) { //    mp_arg_check_num(n_args, n_kw, 1, 1, true); //   mymodule_hello_obj_t *self = m_new_obj(mymodule_hello_obj_t); //     self-&gt;base.type = &amp;mymodule_hello_type; //   self-&gt;hello_number = mp_obj_get_int(args[0]) //   return MP_OBJ_FROM_PTR(self); //    __init__, ,  } //      make_new const mp_obj_type_t mymodule_helloObj_type = { { &amp;mp_type_type }, .name = MP_QSTR_helloObj, .locals_dict = (mp_obj_dict_t*)&amp;mymodule_hello_locals_dict, //  .make_new = mymodule_hello_make_new, };</span></span></code> </pre> <br><p>  Parmi les autres domaines, il y a aussi <code>.print</code> , et je suppose que le reste de la magie de <code>Python3</code> . </p><br><p>  Mais <code>make_new</code> n'est pas du tout n√©cessaire pour obtenir une instance d'un objet: l'initialisation peut se faire dans une fonction arbitraire.  Voici un bon exemple de <code>micropython/ports/esp32/modsocket.c</code> : </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//   :       STATIC mp_obj_t get_socket(size_t n_args, const mp_obj_t *args) { socket_obj_t *sock = m_new_obj_with_finaliser(socket_obj_t); sock-&gt;base.type = &amp;socket_type; sock-&gt;domain = AF_INET; sock-&gt;type = SOCK_STREAM; sock-&gt;proto = 0; sock-&gt;peer_closed = false; if (n_args &gt; 0) { sock-&gt;domain = mp_obj_get_int(args[0]); if (n_args &gt; 1) { sock-&gt;type = mp_obj_get_int(args[1]); if (n_args &gt; 2) { sock-&gt;proto = mp_obj_get_int(args[2]); } } } sock-&gt;fd = lwip_socket(sock-&gt;domain, sock-&gt;type, sock-&gt;proto); if (sock-&gt;fd &lt; 0) { exception_from_errno(errno); } _socket_settimeout(sock, UINT64_MAX); return MP_OBJ_FROM_PTR(sock); } //     0-3  STATIC MP_DEFINE_CONST_FUN_OBJ_VAR_BETWEEN(get_socket_obj, 0, 3, get_socket);</span></span></code> </pre> <br><h2>  M√©thodes li√©es </h2><br><p>  L'√©tape suivante consiste √† ajouter les m√©thodes li√©es.  Cependant, ce n'est pas tr√®s diff√©rent de toutes les autres m√©thodes.  Nous revenons √† l'exemple de la documentation: </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//    :     1 (self) STATIC mp_obj_t mymodule_hello_increment(mp_obj_t self_in) { mymodule_hello_obj_t *self = MP_OBJ_TO_PTR(self_in); self-&gt;hello_number += 1; return mp_const_none; } //     MP_DEFINE_CONST_FUN_OBJ_1(mymodule_hello_increment_obj, mymodule_hello_increment); //      'inc' STATIC const mp_map_elem_t mymodule_hello_locals_dict_table[] = { { MP_OBJ_NEW_QSTR(MP_QSTR_inc), (mp_obj_t)&amp;mymodule_hello_increment_obj }, }</span></span></code> </pre> <br><p>  C‚Äôest tout! </p><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>x = mymodule.helloObj(<span class="hljs-number"><span class="hljs-number">12</span></span>) &gt;&gt;&gt; x.inc()</code> </pre> <br><h2>  Tous les autres attributs: <strong>getattr</strong> , <strong>setattr</strong> </h2><br><p>  Que diriez-vous d'ajouter des non-fonctions, d'utiliser <code>@property</code> et g√©n√©ralement votre propre <code>__getattr__</code> ?  S'il vous pla√Æt: cela se fait manuellement en contournant <code>mymodule_hello_locals_dict_table</code> . </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//     ... STATIC void mymodule_hello_attr(mp_obj_t self_in, qstr attr, mp_obj_t *dest) { mymodule_hello_obj_t *self = MP_OBJ_TO_PTR(self_in); if (dest[0] != MP_OBJ_NULL) { // __setattr__ if (attr == MP_QSTR_val) { self-&gt;val = dest[1]; dest[0] = MP_OBJ_NULL; } } else { // __getattr__ if (attr == MP_QSTR_val) { dest[0] = self-&gt;val; } } } // ...     attr const mp_obj_type_t mymodule_helloObj_type = { { &amp;mp_type_type }, .name = MP_QSTR_helloObj, //     //.locals_dict = (mp_obj_dict_t*)&amp;mymodule_hello_locals_dict, .make_new = mymodule_hello_make_new, //   - attr .attr = mymodule_hello_attr, };</span></span></code> </pre><br><p>  Quelque chose de douloureusement concis s'est av√©r√©, dites-vous.  O√π sont tous ces <code>mp_raise_AttributeError</code> ( <em>note</em> : une telle fonction n'existe pas)?  En fait, une <code>AttributeError</code> sera appel√©e automatiquement.  Le secret est que <code>dest</code> est un tableau de deux √©l√©ments.  Le premier √©l√©ment a la signification de "sortie", en √©criture seule: il prend la valeur <code>MP_OBJ_SENTINEL</code> si la valeur doit √™tre √©crite et <code>MP_OBJ_NULL</code> si elle doit √™tre lue.  En cons√©quence, √† la sortie de la fonction, <code>MP_OBJ_NULL</code> est attendu dans le premier cas et quelque chose <code>mp_obj_t</code> dans le second.  Le deuxi√®me √©l√©ment est entr√©e, en lecture seule: prend la valeur de l'objet √† √©crire si la valeur doit √™tre √©crite et <code>MP_OBJ_NULL</code> si elle doit √™tre lue.  Vous n'avez pas besoin de le changer. </p><br><p>  C'est tout, vous pouvez v√©rifier: </p><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>x = mymodule.helloObj(<span class="hljs-number"><span class="hljs-number">12</span></span>) &gt;&gt;&gt; x.val = <span class="hljs-number"><span class="hljs-number">3</span></span> &gt;&gt;&gt; x.val <span class="hljs-number"><span class="hljs-number">3</span></span></code> </pre> <br><p>  Le plus int√©ressant est que l'ach√®vement des onglets dans REPL fonctionne toujours et offre <code>.val</code> !  Pour √™tre honn√™te, je ne suis pas un expert en C, donc je ne peux que deviner comment cela se produit (en red√©finissant l'op√©rateur '=='). </p><br><h2>  Port </h2><br><p>  Revenant au module A9G, j'ai <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">d√©crit le</a> support de toutes les fonctions de base, √† savoir, SMS, GPRS (usockets), GPS, gestion de l'alimentation.  Maintenant, vous pouvez t√©l√©charger quelque chose comme √ßa dans le module et cela fonctionnera: </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> cellular <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> c <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> usocket <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> sock <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> time <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> gps <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> machine <span class="hljs-comment"><span class="hljs-comment">#   print("Waiting network registration ...") while not c.is_network_registered(): time.sleep(1) time.sleep(2) #  GPRS print("Activating ...") c.gprs_activate("internet", "", "") print("Local IP:", sock.get_local_ip()) #  GPS gps.on() #    thingspeak host = "api.thingspeak.com" api_key = "some-api-key" fields = ('latitude', 'longitude', 'battery', 'sat_visible', 'sat_tracked') #  ,      ! fields = dict(zip(fields, map(lambda x: "field{}".format(x+1), range(len(fields))) )) x, y = gps.get_location() level = machine.get_input_voltage()[1] sats_vis, sats_tracked = gps.get_satellites() s = sock.socket() print("Connecting ...") s.connect((host, 80)) print("Sending ...") #      ,     HTTP.           HTTP, SSL   print("Sent:", s.send("GET /update?api_key={}&amp;{latitude}={:f}&amp;{longitude}={:f}&amp;{battery}={:f}&amp;{sat_visible}={:d}&amp;{sat_tracked}={:d} HTTP/1.1\r\nHost: {}\r\nConnection: close\r\n\r\n".format( api_key, x, y, level, sats_vis, sats_tracked, host, **fields ))) print("Receiving ...") print("Received:", s.recv(128)) s.close()</span></span></code> </pre> <br><p>  Le projet accueille toute aide possible.  Si vous avez aim√© le projet et / ou cet article, n'oubliez pas de laisser un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">like sur le github</a> . </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr446090/">https://habr.com/ru/post/fr446090/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr446078/index.html">¬´Son¬ª: discuter d'un podcast sur la technologie audio</a></li>
<li><a href="../fr446080/index.html">Aux √âtats-Unis, le tribunal a recommand√© d'interdire l'importation de certains mod√®les d'iPhone en raison de la violation des brevets Qualcomm Apple</a></li>
<li><a href="../fr446082/index.html">Le conte des demi-anneaux</a></li>
<li><a href="../fr446086/index.html">L'histoire de Linux. Partie III: nouveaux march√©s et anciens "ennemis"</a></li>
<li><a href="../fr446088/index.html">Choses que je ne sais pas en 2018</a></li>
<li><a href="../fr446092/index.html">Seulement sans mains! Robots qui ne r√©p√®tent pas les actions des utilisateurs</a></li>
<li><a href="../fr446094/index.html">Avec un tableau p√©riodique √† vie</a></li>
<li><a href="../fr446096/index.html">Le livre ¬´TasteVill: comment faire une r√©volution dans le commerce de d√©tail, tout faire mal¬ª</a></li>
<li><a href="../fr446098/index.html">Centre de contr√¥le de vol sovi√©tique de l'√©poque de "Vostok" et "Sunrise"</a></li>
<li><a href="../fr446100/index.html">Cr√©ez automatiquement des fichiers de localisation Android et iOS √† partir d'une feuille de calcul Excel</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>