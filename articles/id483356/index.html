<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ§ ğŸ“Ÿ ğŸ¤¥ Hitungan Komunitas â€œApa?â€ Dimana? Kapan? â€(ChGK) atau berapa banyak jabat tangan di depan seorang Teman? ğŸ— ğŸ° ğŸ“</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Halo, Habr! 


 Liburan Tahun Baru adalah waktu yang tepat untuk  istirahat dari IT  Gunakan keahlian profesional dalam hobi favorit Anda. Sambil menc...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Hitungan Komunitas â€œApa?â€ Dimana? Kapan? â€(ChGK) atau berapa banyak jabat tangan di depan seorang Teman?</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/483356/"><img src="https://habrastorage.org/webt/sx/cv/ze/sxcvzemh1zfstlb99nne9_2hoxm.png"><br><p>  Halo, Habr! </p><br><p>  Liburan Tahun Baru adalah waktu yang tepat untuk <del>  istirahat dari IT </del>  Gunakan keahlian profesional dalam hobi favorit Anda.  Sambil mencari-cari di <a href="https://rating.chgk.info/" rel="nofollow">situs peringkat ChGK olahraga</a> , saya menemukan API yang luar biasa yang memungkinkan Anda untuk mendapatkan data pada semua game dari semua turnamen.  Jadi saya mendapat ide untuk membuat grafik komunitas pakar dan menguji teori enam jabat tangan di komunitas yang secara geografis tersebar dan benar-benar offline.  Di bawah gambar katom grafik dan statistik tidak berguna. </p><a name="habracut"></a><br><p>  Untuk mulai dengan, program pendidikan singkat, apa itu olahraga ChGK. </p><br><div class="spoiler">  <b class="spoiler_title">Apa itu olahraga ChGK</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/w8/fb/yk/w8fbykni1pnbv0jgab0-9sbo4j4.jpeg" alt="Turnamen Olahraga ChGK"></p><br><p>  Saya yakin itu dengan versi televisi "Apa?  Dimana?  Kapan? â€Pembaca terbiasa dengan bagian atas dan surat-surat pemirsa.  Sports ChGK adalah perpanjangan dari format televisi yang memungkinkan beberapa tim bermain secara bersamaan. </p><br><p>  Di kafe, rumah pemuda, aula pertemuan universitas, beberapa tim hingga enam orang berkumpul.  Tuan rumah membacakan pertanyaan, satu menit diberikan untuk refleksi.  Pada akhir menit, tim mencatat respons terhadap bentuk permainan dan bangkit.  Orang yang terlatih secara khusus yang disebut menelan mengumpulkan kertas.  Biasanya 36 pertanyaan dibaca per game, dibagi menjadi tiga putaran.  Yang menjawab sebagian besar, itu dilakukan dengan baik. </p><br><p>  Ada banyak turnamen di ChGK, bahkan ada Kejuaraan Eropa dan Dunia, saya mengirim yang penasaran ke <a href="http://lurkmore.to/%25D0%25A1%25D0%25BF%25D0%25BE%25D1%2580%25D1%2582%25D0%25B8%25D0%25B2%25D0%25BD%25D0%25BE%25D0%25B5_%25D0%25A7%25D0%2593%25D0%259A" rel="nofollow">sumber informasi yang memiliki reputasi baik</a> .  Dan contoh pertanyaan dapat ditemukan di <a href="https://db.chgk.info/" rel="nofollow">sini</a> . </p></div></div><br><h2 id="poluchenie-dannyh">  Pengambilan data </h2><br><p>  Kami berasumsi bahwa para pemain akrab satu sama lain jika mereka bermain setidaknya satu kali di satu meja permainan.  Berkat <a href="https://rating.chgk.info/api-doc" rel="nofollow">API yang bagus,</a> mengunduh data tentang semua turnamen dan semua tim tidak menjadi masalah. </p><br><p>  Di bawah spoiler, bahkan Sup Indah tidak digunakan, hanya permintaan.  Notebook jupyter dengan semua kode sumber akan berada di akhir artikel. </p><br><div class="spoiler">  <b class="spoiler_title">Unduh data untuk semua turnamen</b> <div class="spoiler_text"><pre><code class="python hljs">url = <span class="hljs-string"><span class="hljs-string">'https://rating.chgk.info/api/tournaments.json/?page={}'</span></span> df = pd.DataFrame(columns=[<span class="hljs-string"><span class="hljs-string">'name'</span></span>, <span class="hljs-string"><span class="hljs-string">'start'</span></span>]) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">7</span></span>): data = requests.get(url.format(i)).json() <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> item <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> data[<span class="hljs-string"><span class="hljs-string">"items"</span></span>]: df.loc[item[<span class="hljs-string"><span class="hljs-string">"idtournament"</span></span>]] = (item[<span class="hljs-string"><span class="hljs-string">"name"</span></span>], item[<span class="hljs-string"><span class="hljs-string">"date_start"</span></span>]) df.to_csv(<span class="hljs-string"><span class="hljs-string">'tournaments.csv'</span></span>)</code> </pre> </div></div><br><p>  Tetap mengunduh daftar nama permainan dari semua turnamen dan mengingat semua kenalan.  Awalnya, saya berencana untuk menyimpan fakta-fakta permainan bersama dalam DataFrame, tetapi kecepatan menambahkan catatan baru menyedihkan.  Oleh karena itu, kami akan menetapkan dari tupel (id1, id2), di mana id1, id2 adalah pengidentifikasi pemain yang akrab satu sama lain.  Pada saat yang sama, singkirkan duplikat. </p><br><div class="spoiler">  <b class="spoiler_title">Mengunduh komposisi dan berkenalan</b> <div class="spoiler_text"><pre> <code class="python hljs">df = pd.read_csv(<span class="hljs-string"><span class="hljs-string">'tournaments.csv'</span></span>).set_index(<span class="hljs-string"><span class="hljs-string">'Unnamed: 0'</span></span>) url = <span class="hljs-string"><span class="hljs-string">'https://rating.chgk.info/api/tournaments/{}/recaps.json'</span></span> links = set() <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> id <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> df.index: teams = requests.get(url.format(id)).json() <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> team <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> teams: t = team[<span class="hljs-string"><span class="hljs-string">"recaps"</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(len(t)): <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> j <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(i + <span class="hljs-number"><span class="hljs-number">1</span></span>, len(t)): first = int(t[i][<span class="hljs-string"><span class="hljs-string">"idplayer"</span></span>]) second = int(t[j][<span class="hljs-string"><span class="hljs-string">"idplayer"</span></span>]) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> first &lt; second: links.add((first, second)) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: links.add((second, first)) <span class="hljs-comment"><span class="hljs-comment">#    sleep(1) clear_output(wait=True) display('Current tournament: ' + str(df.index.get_loc(id) + 1) + '/' + str(len(df))) display('Links total: ' + str(len(links)))</span></span></code> </pre> </div></div><br><h2 id="poluchenie-grafa-i-issledovanie-komponent-svyaznosti">  Mendapatkan grafik dan menjelajahi komponen yang terhubung </h2><br><p>  Jadi, persiapan data sudah selesai, saatnya untuk membuat grafik!  Untuk melakukan ini, kita akan menggunakan <a href="https://networkx.github.io/" rel="nofollow">networkx</a> library, kapabilitas yang cukup untuk cluster kita. </p><br><pre> <code class="python hljs">players = itertools.chain(*links) G = nx.Graph() G.add_nodes_from(players) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> t <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> links: G.add_edge(*t) print(nx.info(G))</code> </pre> <br><p>  Sekarang ada sekitar dua ratus ribu orang di komunitas ChGK, dan rata-rata, seorang ahli karier telah bermain dengan 12 orang: </p><br><pre> <code class="plaintext hljs">Number of nodes: 198145 Number of edges: 1206076 Average degree: 12.1737</code> </pre> <br><p>  Saatnya mencari tahu berapa banyak komponen yang terhubung dalam grafik penanggalan.  Networkx memiliki fungsi hebat yang disebut connected_components yang melakukan apa yang Anda butuhkan: </p><br><pre> <code class="python hljs">clusters_l = [len(c) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> c <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> sorted(nx.connected_components(G), key=len, reverse=<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>)] print(clusters_l[:<span class="hljs-number"><span class="hljs-number">20</span></span>])</code> </pre> <br><p>  Hampir tiga perempat pemain berada dalam satu komponen yang terhubung, sisanya dibagi menjadi subgraph yang sangat kecil.  Ada lebih dari delapan ribu di antaranya. </p><br><pre> <code class="plaintext hljs">[145922, 153, 124, 74, 72, 56, 50, 47, 42, 40, 39, 39, 38, 38, 37, 36, 36, 36, 36, 35]</code> </pre> <br><p>  Bahkan pada skala logaritmik, dominasi komponen utama terlihat mengesankan.  Pada sumbu X - jumlah komponen dari yang terbesar hingga yang terkecil, pada sumbu Y - ukurannya (sumbu adalah logaritmik). </p><br><img src="https://habrastorage.org/webt/c9/pa/ol/c9paolwikv7_cjugzxctqtpffwy.png"><br><p>  Apa yang menyebabkan distribusi orang yang sedemikian tidak merata dalam komponen yang terhubung?  Menurut saya, intinya adalah ini: </p><br><ul><li>  sekelompok kecil orang datang ke permainan untuk pertama kalinya dan dengan demikian membentuk kelompok kecil untuk 4-6 orang; </li><li>  jika kota ini sudah memiliki komunitas besar, cluster seperti itu akan dengan cepat bergabung dengan yang utama - hanya satu orang yang perlu bermain untuk tim dari cluster utama; </li><li>  jika di kota ChGK baru saja muncul, cluster akan hidup lebih lama, karena  bermain untuk tim dari cluster utama lebih sulit. </li></ul><br><p>  Prosesnya menyerupai pembentukan tetesan hujan di awan: setetes besar menarik yang kecil dan tumbuh dengan cepat. </p><br><p>  Sebelum berurusan dengan komponen utama, mari kita lihat komponen di tempat pertama atau kesembilan (saya menganggap komponen utama menjadi nol).  Kami menguji hipotesis bahwa orang-orang di komponen ini berasal dari kota yang sama.  Penikmat tidak memiliki keterikatan pada kota (yang logis di dunia modern kita).  Namun, Anda dapat melihat port rumah tim yang ia mainkan terakhir kali </p><br><div class="spoiler">  <b class="spoiler_title">Kode statistik kota</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>): _g = list(sorted(nx.connected_components(G), key=len, reverse=<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>)[i]) s = pd.Series() p_url = <span class="hljs-string"><span class="hljs-string">'https://rating.chgk.info/api/players/{}/tournaments.json'</span></span> t_url = <span class="hljs-string"><span class="hljs-string">'https://rating.chgk.info/api/teams/{}.json'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> player <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> _g: data = requests.get(p_url.format(player)).json() <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> item <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> data: team_id = data[item][<span class="hljs-string"><span class="hljs-string">"tournaments"</span></span>][<span class="hljs-number"><span class="hljs-number">0</span></span>][<span class="hljs-string"><span class="hljs-string">"idteam"</span></span>] data = requests.get(t_url.format(team_id)).json() town = data[<span class="hljs-number"><span class="hljs-number">0</span></span>][<span class="hljs-string"><span class="hljs-string">"town"</span></span>] s.at[len(s)] = town print(<span class="hljs-string"><span class="hljs-string">' #{}'</span></span>.format(i)) print(s.value_counts())</code> </pre> </div></div><br><p>  Piring ringkasan: </p><br><div class="scrollable-table"><table><thead><tr><th>  Nomor Komponen Konektivitas </th><th>  Ukuran </th><th>  Kota </th></tr></thead><tbody><tr><td>  1 </td><td>  153 </td><td>  Kerch </td></tr><tr><td>  2 </td><td>  124 </td><td>  110 - Ust-Ilimsk, 12 - Vladivostok, 2 - Irkutsk </td></tr><tr><td>  3 </td><td>  74 </td><td>  Tambov - 72, <strong>Luksemburg - 2</strong> </td></tr><tr><td>  4 </td><td>  72 </td><td>  Hutan </td></tr><tr><td>  5 </td><td>  56 </td><td>  Yeisk </td></tr><tr><td>  6 </td><td>  50 </td><td>  Bishkek </td></tr><tr><td>  7 </td><td>  47 </td><td>  <strong>Gorno-Altaysk</strong> </td></tr><tr><td>  8 </td><td>  42 </td><td>  Zhytomyr - 37, Glazov - 5 </td></tr><tr><td>  9 </td><td>  40 </td><td>  <strong>Gorno-Altaysk - 31, Moskow - 9</strong> </td></tr></tbody></table></div><br><p>  Ya, kelompok kecil hampir seluruhnya berasal dari satu kota.  Harap perhatikan komponen tujuh puluh dua warga Tambov, yang terkait dengan Luksemburg.  Di tempat ketujuh dan kesembilan adalah komponen dari Gorno-Altaysk, yang karena beberapa alasan tidak saling berhubungan.  Saya siap membayangkan perjuangan dua klan ChGK-ash, seperti Montecca dan Capulet, yang berjuang untuk menguasai kota. <br>  Saya kira bahwa dalam waktu dekat komponen-komponen ini akan bergabung menjadi yang utama <del>  tetapi akan terus berjuang </del>  . </p><br><h2 id="osnovnaya-komponenta-svyaznosti">  Komponen utama konektivitas </h2><br><p>  Jadi, kita sampai pada komponen utama.  Kami akan mendapatkan subgraf yang diinginkan dan melihat statistiknya: </p><br><pre> <code class="python hljs">subgraph_v = list(sorted(nx.connected_components(G), key=len, reverse=<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>)[<span class="hljs-number"><span class="hljs-number">0</span></span>]) subgraph = G.subgraph(subgraph_v) print(nx.info(subgraph))</code> </pre> <br><p>  Jumlah rata-rata koneksi ternyata lebih banyak. </p><br><pre> <code class="plaintext hljs">Number of nodes: 145922 Number of edges: 1070504 Average degree: 14.6723</code> </pre> <br><p>  Dan berapa jumlah maksimum koneksi per pemain? </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> t <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> sorted(G.degree, key=<span class="hljs-keyword"><span class="hljs-keyword">lambda</span></span> x: x[<span class="hljs-number"><span class="hljs-number">1</span></span>], reverse=<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>)[:<span class="hljs-number"><span class="hljs-number">10</span></span>]: print(<span class="hljs-string"><span class="hljs-string">' {}   {} '</span></span>.format(t[<span class="hljs-number"><span class="hljs-number">0</span></span>], t[<span class="hljs-number"><span class="hljs-number">1</span></span>]))</code> </pre> <br><pre> <code class="plaintext hljs"> 42511   818   15051   798   29800   678   23020   666   16581   662   5328   657   29887   651   15811   645   30352   605   1055   602 </code> </pre> <br><p>  Terus terang, saya sedikit terkejut dengan jumlahnya.  Jika Anda bermain dengan tim baru setiap kali, maka Anda akan membutuhkan 818/5 â‰ˆ 164 game untuk mencapai tempat pertama.  Luar biasa. <br>  Kami akan mengingat dua ahli pertama dalam peringkat ini dan akan menggunakan keterampilan komunikasi mereka lebih lanjut. <br>  Mari kita perkirakan berapa banyak kenalan terdekat yang dimiliki oleh seorang pakar rata-rata: </p><br><div class="spoiler">  <b class="spoiler_title">Mendapatkan data dan merencanakan</b> <div class="spoiler_text"><pre> <code class="python hljs">_count = <span class="hljs-number"><span class="hljs-number">50</span></span> values = nx.degree_histogram(subgraph) plt.figure(figsize=(<span class="hljs-number"><span class="hljs-number">16</span></span>, <span class="hljs-number"><span class="hljs-number">8</span></span>), dpi=<span class="hljs-number"><span class="hljs-number">80</span></span>) plt.plot(range(_count),values[:_count],<span class="hljs-string"><span class="hljs-string">'ro-'</span></span>) <span class="hljs-comment"><span class="hljs-comment"># in-degree plt.xlabel(' ', fontsize=18) plt.xticks(range(0,_count, 5)) plt.ylabel(' ', fontsize=18) plt.title(' ', fontsize=22) plt.show()</span></span></code> </pre> </div></div><br><img src="https://habrastorage.org/webt/rt/cl/eh/rtclehktplh8tx_5mms3ny6gcom.png"><br><p>  Pada sumbu X - jumlah kenalan terdekat, pada sumbu Y - jumlah pakar yang memiliki jumlah kenalan yang sesuai.  Misalnya, sekitar 40.000 pakar masing-masing memiliki lima kenalan. <br>  Perhatikan bahwa fashion memiliki 5 kenalan (lucu bahwa hingga enam orang dapat hadir di meja).  Pada saat yang sama, rata-rata aritmatika dari jumlah kenalan adalah 14,67, dan median adalah 7. Faktanya adalah bahwa pria dari peringkat di atas sangat melebih-lebihkan rata-rata.  Jika seratus orang tidak bermain di ChGK, dan satu memiliki 800 kenalan, maka rata-rata mereka bermain di ChGK. </p><br><h2 id="rasstoyaniya-do-igrokov">  Jarak ke Pemain </h2><br><p>  Karena  menghitung diameter grafik semacam itu <a href="https://neerc.ifmo.ru/wiki/index.php%3Ftitle%3D%25D0%2590%25D0%25BB%25D0%25B3%25D0%25BE%25D1%2580%25D0%25B8%25D1%2582%25D0%25BC%25D1%258B_%25D0%25BD%25D0%25B0_%25D0%25B4%25D0%25B5%25D1%2580%25D0%25B5%25D0%25B2%25D1%258C%25D1%258F%25D1%2585" rel="nofollow">agak sulit</a> , mari lakukan lebih mudah: ambil daftar beberapa pemain dan temukan jarak maksimum terdekat dari mereka ke pakar lain.  Sebagai pemain ini, saya mengambil beberapa ahli terkenal, saya sendiri, pemain acak dan dua ahli dengan jumlah kenalan terbesar (lihat peringkat di atas).  Inilah yang terjadi: </p><br><pre> <code class="python hljs">famous_players = {<span class="hljs-number"><span class="hljs-number">9808</span></span>: <span class="hljs-string"><span class="hljs-string">' '</span></span>, <span class="hljs-number"><span class="hljs-number">5195</span></span>: <span class="hljs-string"><span class="hljs-string">' '</span></span>, <span class="hljs-number"><span class="hljs-number">25882</span></span>: <span class="hljs-string"><span class="hljs-string">' '</span></span>, <span class="hljs-number"><span class="hljs-number">29333</span></span>: <span class="hljs-string"><span class="hljs-string">' '</span></span>, <span class="hljs-number"><span class="hljs-number">118622</span></span>: <span class="hljs-string"><span class="hljs-string">' '</span></span>, <span class="hljs-number"><span class="hljs-number">42511</span></span>: <span class="hljs-string"><span class="hljs-string">' '</span></span>, <span class="hljs-number"><span class="hljs-number">15051</span></span>: <span class="hljs-string"><span class="hljs-string">' '</span></span>, <span class="hljs-number"><span class="hljs-number">118621</span></span>: <span class="hljs-string"><span class="hljs-string">' '</span></span>} <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> key <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> famous_players: print(<span class="hljs-string"><span class="hljs-string">'{}: {} -      '</span></span> .format(famous_players[key], nx.eccentricity(subgraph, v=key)))</code> </pre><br><pre> <code class="plaintext hljs"> : 12 -        : 12 -        : 12 -        : 12 -        : 13 -        : 12 -        : 13 -        : 13 -      </code> </pre><br><p>  Ternyata rumusan kuat dari teori enam jabat tangan (dua orang yang dipisahkan oleh tidak lebih dari lima tingkat teman bersama) tidak benar.  Diameter grafik kemungkinan besar adalah 13-14. <br>  Bagaimana dengan kata-kata yang lebih lemah ( <strong>rata-rata</strong> dua orang dipisahkan oleh tidak lebih dari lima tingkat teman yang sama)? </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> key <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> famous_players: paths = nx.shortest_path_length(subgraph, source=key).values() print(<span class="hljs-string"><span class="hljs-string">'{}: {} -      '</span></span> .format(famous_players[key], sum(paths) / len(paths)))</code> </pre><br><pre> <code class="plaintext hljs"> : 3.941461876893135 -        : 3.7971107852140182 -        : 3.89353216101753 -        : 3.8634887131481204 -        : 4.1443373857266215 -        : 3.575478680390894 -        : 3.608674497334192 -        : 4.564102739819904 -      </code> </pre><br><p>  Jika kita melonggarkan kata-kata, maka teorinya terpenuhi - rata-rata di antara para ahli pada tingkat 4-5 kenalan.  Kami memplot berapa banyak orang yang akrab dengan penikmat acak A. Druzem secara langsung, melalui satu, dua, dll.  penikmat. </p><br><div class="spoiler">  <b class="spoiler_title">Mendapatkan data dan merencanakan</b> <div class="spoiler_text"><pre> <code class="python hljs">paths = nx.shortest_path_length(subgraph, source=<span class="hljs-number"><span class="hljs-number">9808</span></span>) neighbours = [<span class="hljs-number"><span class="hljs-number">0</span></span>] * <span class="hljs-number"><span class="hljs-number">15</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> k <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> paths: neighbours[paths[k]] += <span class="hljs-number"><span class="hljs-number">1</span></span> _count = <span class="hljs-number"><span class="hljs-number">15</span></span> plt.figure(figsize=(<span class="hljs-number"><span class="hljs-number">16</span></span>, <span class="hljs-number"><span class="hljs-number">8</span></span>), dpi=<span class="hljs-number"><span class="hljs-number">80</span></span>) plt.plot(range(_count),neighbours[:_count],<span class="hljs-string"><span class="hljs-string">'ro-'</span></span>) <span class="hljs-comment"><span class="hljs-comment"># in-degree plt.xlabel(' ', fontsize=18) plt.xticks(range(_count)) plt.ylabel(' ', fontsize=18) plt.title('  .', fontsize=22) plt.show()</span></span></code> </pre> </div></div><br><p>  Pada sumbu X, tingkat kenalan dengan A. Druzem (langsung, melalui satu, dua, dll.), Pada sumbu Y, jumlah ahli yang akrab dengan A. Druzem dengan cara ini. </p><br><img src="https://habrastorage.org/webt/fj/tt/sk/fjttskyhdbiw2qrmdux5ug1mnn8.png"><br><h2 id="socialnye-grafy">  Grafik sosial </h2><br><p>  Karena  membangun grafik untuk hampir 200 ribu orang bukanlah ide yang baik, kami akan membuatnya lebih mudah: kami akan membangun komponen konektivitas Kerch dan grafik orang yang terkait dengan penulis. </p><br><h3 id="kerchenskaya-komponenta">  Komponen kerch </h3><br><pre> <code class="python hljs">little_v = list(sorted(nx.connected_components(G), key=len, reverse=<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>)[<span class="hljs-number"><span class="hljs-number">1</span></span>]) little = G.subgraph(little_v) plt.figure(figsize=(<span class="hljs-number"><span class="hljs-number">24</span></span>, <span class="hljs-number"><span class="hljs-number">12</span></span>), dpi=<span class="hljs-number"><span class="hljs-number">200</span></span>) pos = nx.kamada_kawai_layout(little) nx.draw(little, pos=pos, node_size=<span class="hljs-number"><span class="hljs-number">100</span></span>, edge_color=<span class="hljs-string"><span class="hljs-string">'gray'</span></span>, node_color=[val <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (node, val) <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> little.degree()], cmap=plt.cm.jet) plt.show()</code> </pre> <br><img src="https://habrastorage.org/webt/_p/tu/k6/_ptuk61dseuqzz0mviea_1jw4iy.png"><br><p>  Anda dapat melihat pemisahan komponen menjadi beberapa tim.  Selain itu, tim-tim tersebut saling berhubungan dengan bantuan, sebagai aturan, dari satu atau dua penikmat yang ramah.  Di tengah adalah inti yang agak kecil dari para ahli yang bermain dengan sejumlah besar pemain lain. </p><br><h3 id="graf-odnogo-cheloveka">  Hitungan satu orang </h3><br><p>  Kami akan menemukan kenalan terdekat dari satu orang dan melihat bagaimana mereka terkait.  Untuk menyederhanakan grafik, kami tidak akan menambahkan orang itu sendiri (dia sudah terhubung dengan semua orang) </p><br><pre> <code class="python hljs">id = <span class="hljs-number"><span class="hljs-number">118622</span></span> ego_graph = [n <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> n <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> G.neighbors(id)] <span class="hljs-comment"><span class="hljs-comment">#ego_graph.append(id) ego_graph = G.subgraph(ego_graph) plt.figure(figsize=(24, 16), dpi=200) pos = nx.kamada_kawai_layout(ego_graph) nx.draw(ego_graph, pos=pos, node_size=100, edge_color='gray', node_color=[val for (node, val) in ego_graph.degree()], cmap=plt.cm.jet) plt.show()</span></span></code> </pre> <br><img src="https://habrastorage.org/webt/ag/pq/xx/agpqxx0wdbosfslvdrrl0hu_x8u.png"><br><p>  Grafiknya jauh lebih padat, inti 10-15 orang yang akrab satu sama lain dapat dibedakan.  Ukuran klik maksimum adalah 13. </p><br><h2 id="zaklyuchenie">  Kesimpulan </h2><br><ul><li>  Jauh lebih sulit untuk mengenal seseorang di ChGK olahraga daripada di jejaring sosial, Anda harus offline dan bermain setidaknya satu turnamen.  Pada saat yang sama, para ahli tersebar di seluruh dunia.  Namun, jarak <strong>rata</strong> - <strong>rata</strong> antar pakar memang kurang dari lima. </li><li>  Situs pemeringkatan menggunakan <a href="https://rating.chgk.info/players.php%3Fshow_bacon_stats" rel="nofollow">nomor Snyatkovsky</a> , yang merupakan analog <a href="https://ru.wikipedia.org/wiki/%25D0%25A7%25D0%25B8%25D1%2581%25D0%25BB%25D0%25BE_%25D0%25AD%25D1%2580%25D0%25B4%25D1%2591%25D1%2588%25D0%25B0" rel="nofollow">dari nomor ErdÃ¶s</a> di dunia ChGK.  Tn. Snyatkovsky sendiri menempati posisi ketiga dalam peringkat kami para penikmat paling ramah. </li><li>  Kode dari sebuah artikel di <a href="https://github.com/atepaevm/ChGK" rel="nofollow">github</a> saya. </li><li>  Untuk komentar yang berharga, penulis berterima kasih kepada White Noise dan Who Framed Roger Federer, Mikhail Akulov, Vera Terentyeva, dan <a href="https://habr.com/ru/users/firemoon/" class="user_link">Firemoon</a> . </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id483356/">https://habr.com/ru/post/id483356/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id483346/index.html">Bagaimana blockchain mengubah akuntansi?</a></li>
<li><a href="../id483348/index.html">Cara menghitung "kesamaan" angka dalam paspor. Dan menemukan yang sama bahkan dengan kesalahan ketik</a></li>
<li><a href="../id483350/index.html">Apa yang Baru dalam Dokumentasi .NET Kami (Desember 2019)</a></li>
<li><a href="../id483352/index.html">Python dalam Visual Studio Code - rilis Januari 2020</a></li>
<li><a href="../id483354/index.html">Kutukan bulan kedua</a></li>
<li><a href="../id483360/index.html">Kontrol drive daya listrik. Pengalaman Amatir</a></li>
<li><a href="../id483364/index.html">Anda dapat menulis kode di tempat kerja untuk menghemat waktu luang Anda.</a></li>
<li><a href="../id483366/index.html">Sejarah Internet: Jaringan</a></li>
<li><a href="../id483368/index.html">Membuat file packer ELF x86_64 untuk linux</a></li>
<li><a href="../id483372/index.html">Cara melatih jaringan saraf DeepPavlov di laptop menggunakan GPU</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>