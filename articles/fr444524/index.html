<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👐 😄 👲🏻 Lambdas: de C ++ 11 à C ++ 20. Partie 1 👏 🏫 😖</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Bonjour mes amis. Aujourd'hui, nous avons préparé pour vous une traduction de la première partie de l'article «Lambdas: du C ++ 11 au C ++ 20» . La pu...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Lambdas: de C ++ 11 à C ++ 20. Partie 1</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/otus/blog/444524/"> Bonjour mes amis.  Aujourd'hui, nous avons préparé pour vous une traduction de la première partie de l'article <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">«Lambdas: du C ++ 11 au C ++ 20»</a> .  La publication de ce matériel est programmée pour coïncider avec le lancement du cours <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">"Développeur C ++"</a> , qui commence demain. <br><br>  Les expressions lambda sont l'un des ajouts les plus puissants de C ++ 11 et continuent d'évoluer avec chaque nouvelle norme de langage.  Dans cet article, nous allons passer en revue leur histoire et regarder l'évolution de cette partie importante du C ++ moderne. <br><br><img src="https://habrastorage.org/webt/s8/xa/l8/s8xal8zqrhmjeh-omwslxujvsmw.png"><br><br>  La deuxième partie est disponible ici: <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Lambdas: du C ++ 11 au C ++ 20, partie 2</a> <br><a name="habracut"></a><br>  <b>Entrée</b> <br><br>  Lors d'une réunion locale du groupe d'utilisateurs C ++, nous avons eu une session de programmation en direct sur «l'historique» des expressions lambda.  La conversation a été dirigée par Tomasz Kamiński, expert en C ++ ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">voir le profil Linkedin de Thomas</a> ).  Voici l'événement: <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Lambdas: de C ++ 11 à C ++ 20 - Groupe d'utilisateurs C ++ Cracovie</a> <br><br>  J'ai décidé de prendre le code de Thomas (avec sa permission!), De le décrire et de créer un article séparé. <br><br>  Nous allons commencer par explorer C ++ 03 et la nécessité d'expressions fonctionnelles locales compactes.  Ensuite, nous passons à C ++ 11 et C ++ 14.  Dans la deuxième partie de la série, nous verrons des changements en C ++ 17 et même regarderons ce qui se passera en C ++ 20. <br><br>  <b>Lambdas en C ++ 03</b> <br><br>  Dès le début, les <code>std::algorithms</code> STL, tels que <code>std::sort</code> , pouvaient prendre n'importe quel objet appelé et l'appeler sur des éléments de conteneur.  Cependant, en C ++ 03, cela n'impliquait que des pointeurs vers des fonctions et des foncteurs. <br><br>  Par exemple: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;iostream&gt; #include &lt;algorithm&gt; #include &lt;vector&gt; struct PrintFunctor { void operator()(int x) const { std::cout &lt;&lt; x &lt;&lt; std::endl; } }; int main() { std::vector&lt;int&gt; v; v.push_back(1); v.push_back(2); std::for_each(v.begin(), v.end(), PrintFunctor()); }</span></span></span></span></code> </pre> <br>  Code en cours d'exécution: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">@Wandbox</a> <br><br>  Mais le problème était que vous deviez écrire une fonction ou un foncteur séparé dans une portée différente, et non dans la portée de l'appel d'algorithme. <br><br>  En tant que solution potentielle, vous pourriez envisager d'écrire une classe de foncteur locale - car C ++ prend toujours en charge cette syntaxe.  Mais ça ne marche pas ... <br><br>  Jetez un oeil à ce code: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PrintFunctor</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">operator</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; x &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; } }; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; v; v.push_back(<span class="hljs-number"><span class="hljs-number">1</span></span>); v.push_back(<span class="hljs-number"><span class="hljs-number">2</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::for_each(v.begin(), v.end(), PrintFunctor()); }</code> </pre> <br>  Essayez de le compiler avec <code>-std=c++98</code> et vous verrez l'erreur suivante dans GCC: <br><br><pre> <code class="cpp hljs">error: <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> argument <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> <span class="hljs-string"><span class="hljs-string">'template&lt;class _IIter, class _Funct&gt; _Funct std::for_each(_IIter, _IIter, _Funct)'</span></span> uses local type <span class="hljs-string"><span class="hljs-string">'main()::PrintFunctor'</span></span></code> </pre> <br>  Essentiellement, en C ++ 98/03, vous ne pouvez pas créer une instance d'un modèle avec un type local. <br>  En raison de toutes ces limitations, le Comité a commencé à développer une nouvelle fonctionnalité que nous pouvons créer et appeler «en place» ... «expressions lambda»! <br><br>  Si nous regardons <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">N3337</a> - la version finale de C ++ 11, nous verrons une section distincte pour lambdas: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">[expr.prim.lambda]</a> . <br><br>  <b>À côté de C ++ 11</b> <br><br>  Je pense que les lambdas ont été judicieusement ajoutés à la langue.  Ils utilisent la nouvelle syntaxe, mais ensuite le compilateur «l'étend» à une classe réelle.  Ainsi, nous avons tous les avantages (et parfois les inconvénients) d'un vrai langage strictement typé. <br><br>  Voici un exemple de code de base qui montre également l'objet functor local correspondant: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;iostream&gt; #include &lt;algorithm&gt; #include &lt;vector&gt; int main() { struct { void operator()(int x) const { std::cout &lt;&lt; x &lt;&lt; '\n'; } } someInstance; std::vector&lt;int&gt; v; v.push_back(1); v.push_back(2); std::for_each(v.begin(), v.end(), someInstance); std::for_each(v.begin(), v.end(), [] (int x) { std::cout &lt;&lt; x &lt;&lt; '\n'; } ); }</span></span></span></span></code> </pre> <br>  Exemple: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">@WandBox</a> <br><br>  Vous pouvez également consulter CppInsights, qui montre comment le compilateur étend le code: <br><br>  Jetez un œil à cet exemple: <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">CppInsighs: test lambda</a> <br><br>  Dans cet exemple, le compilateur convertit: <br><br><pre> <code class="cpp hljs">[] (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x) { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; x &lt;&lt; <span class="hljs-string"><span class="hljs-string">'\n'</span></span>; }</code> </pre> <br><br>  En quelque chose de similaire à cela (forme simplifiée): <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">operator</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; x &lt;&lt; <span class="hljs-string"><span class="hljs-string">'\n'</span></span>; } } someInstance;</code> </pre> <br>  Syntaxe d'expression lambda: <br><br><pre> <code class="cpp hljs">[] () { ; } ^ ^ ^ | | | | | : <span class="hljs-keyword"><span class="hljs-keyword">mutable</span></span>, exception, trailing <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>, ... | | |   |     </code> </pre><br>  Quelques définitions avant de commencer: <br><br>  De <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">[expr.prim.lambda # 2]</a> : <br><br>  L'évaluation d'une expression lambda entraîne une valeur temporaire.  Cet objet temporaire est appelé un <i>objet de fermeture</i> . <br><br>  Et de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">[expr.prim.lambda # 3]</a> : <br><br>  Le type d'expression lambda (qui est également le type d'un objet de fermeture) est un type de non-union sans nom unique de la classe appelée <i>type de fermeture</i> . <br><br>  Quelques exemples d'expressions lambda: <br><br>  Par exemple: <br><br><pre> <code class="cpp hljs">[](<span class="hljs-keyword"><span class="hljs-keyword">float</span></span> f, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> a) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a*f; } [](MyClass t) -&gt; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> a = t.compute(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a; } [](<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> a, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> b) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a &lt; b; }</code> </pre> <br>  <b>Type lambda</b> <br><br>  Comme le compilateur génère un nom unique pour chaque lambda, il n'est pas possible de le connaître à l'avance. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> myLambda = [](<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> a) -&gt; <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">2.0</span></span> * a; }</code> </pre> <br>  De plus <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">[expr.prim.lambda]</a> : <br>  Le type de fermeture associé à l'expression lambda a un constructeur par défaut distant ([dcl.fct.def.delete]) et un opérateur d'affectation distant. <br><br>  Par conséquent, vous ne pouvez pas écrire: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> foo = [&amp;x, &amp;y]() { ++x; ++y; }; <span class="hljs-keyword"><span class="hljs-keyword">decltype</span></span>(foo) fooCopy;</code> </pre> <br>  Cela entraînera l'erreur suivante dans GCC: <br><br><pre> <code class="cpp hljs">error: use of deleted function <span class="hljs-string"><span class="hljs-string">'main()::&lt;lambda()&gt;::&lt;lambda&gt;()'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">decltype</span></span>(foo) fooCopy; ^~~~~~~ note: a lambda closure type has a deleted <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> constructor</code> </pre> <br>  <b>Opérateur d'appel</b> <br><br>  Le code que vous mettez dans le corps lambda est "traduit" en code operator () du type de fermeture correspondant. <br><br>  Par défaut, il s'agit d'une méthode constante intégrée.  Vous pouvez le changer en spécifiant mutable après avoir déclaré les paramètres: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> myLambda = [](<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> a) <span class="hljs-keyword"><span class="hljs-keyword">mutable</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; a; }</code> </pre> <br>  Bien que la méthode constante ne soit pas un "problème" pour un lambda sans liste de capture vide ... cela importe quand vous voulez capturer quelque chose. <br><br>  <b>Capturer</b> <br><br>  [] introduit non seulement un lambda, mais contient également une liste de variables capturées.  C'est ce qu'on appelle une liste de capture. <br><br>  En capturant une variable, vous créez un membre de copie de cette variable dans le type de fermeture.  Ensuite, à l'intérieur du corps lambda, vous pouvez y accéder. <br><br>  La syntaxe de base est: <br><br><ul><li>  [&amp;] - capture par référence, toutes les variables du stockage automatique sont déclarées dans la portée </li><li>  [=] - capture par valeur, la valeur est copiée </li><li>  [x, &amp; y] - capture explicitement x par valeur et y par référence </li></ul><br>  Par exemple: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x = <span class="hljs-number"><span class="hljs-number">1</span></span>, y = <span class="hljs-number"><span class="hljs-number">1</span></span>; { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; x &lt;&lt; <span class="hljs-string"><span class="hljs-string">" "</span></span> &lt;&lt; y &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> foo = [&amp;x, &amp;y]() { ++x; ++y; }; foo(); <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; x &lt;&lt; <span class="hljs-string"><span class="hljs-string">" "</span></span> &lt;&lt; y &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; }</code> </pre><br>  Vous pouvez jouer avec l'exemple complet ici: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">@Wandbox</a> <br><br>  Bien que spécifier <code>[=]</code> ou <code>[&amp;]</code> peut être pratique - car il capture toutes les variables dans le stockage automatique, il est plus évident de capturer les variables explicitement.  Ainsi, le compilateur peut vous avertir des effets indésirables (voir, par exemple, les notes sur les variables globales et statiques) <br><br>  Vous pouvez également en savoir plus au paragraphe 31 de Effective Modern C ++ de Scott Meyers: «Évitez les modes de capture par défaut». <br><br>  Et une citation importante: <br><blockquote>  Les fermetures C ++ n'augmentent pas la durée de vie des liens capturés. </blockquote><br><br>  <b>Mutable</b> <br><br>  Par défaut, l'opérateur de type de fermeture () est constant et vous ne pouvez pas modifier les variables capturées à l'intérieur du corps d'une expression lambda. <br>  Si vous souhaitez modifier ce comportement, vous devez ajouter le mot clé mutable après la liste des paramètres: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x = <span class="hljs-number"><span class="hljs-number">1</span></span>, y = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; x &lt;&lt; <span class="hljs-string"><span class="hljs-string">" "</span></span> &lt;&lt; y &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> foo = [x, y]() <span class="hljs-keyword"><span class="hljs-keyword">mutable</span></span> { ++x; ++y; }; foo(); <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; x &lt;&lt; <span class="hljs-string"><span class="hljs-string">" "</span></span> &lt;&lt; y &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>;</code> </pre> <br>  Dans l'exemple ci-dessus, nous pouvons changer les valeurs de x et y ... mais ce ne sont que des copies de x et y de la portée attachée. <br><br>  <b>Capture de variable globale</b> <br><br>  Si vous avez une valeur globale et que vous utilisez ensuite [=] dans un lambda, vous pourriez penser que la valeur globale est également capturée par valeur ... mais ce n'est pas le cas. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> global = <span class="hljs-number"><span class="hljs-number">10</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; global &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> foo = [=] () <span class="hljs-keyword"><span class="hljs-keyword">mutable</span></span> { ++global; }; foo(); <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; global &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; [] { ++global; } (); <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; global &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; [global] { ++global; } (); }</code> </pre> <br>  Vous pouvez jouer avec le code ici: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">@Wandbox</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><br></a> <br>  Seules les variables du stockage automatique sont capturées.  GCC peut même émettre l'avertissement suivant: <br><br><pre> <code class="cpp hljs">warning: capture of variable <span class="hljs-string"><span class="hljs-string">'global'</span></span> with non-automatic storage duration</code> </pre> <br>  Cet avertissement n'apparaîtra que si vous capturez explicitement la variable globale, donc si vous utilisez <code>[=]</code> , le compilateur ne vous aidera pas. <br>  Le compilateur Clang est plus utile car il génère une erreur: <br><br><pre> <code class="cpp hljs">error: <span class="hljs-string"><span class="hljs-string">'global'</span></span> cannot be captured because it does <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> have automatic storage duration</code> </pre> <br>  Voir <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">@Wandbox</a> <br><br>  <b>Capture de variables statiques</b> <br><br>  La capture de variables statiques est similaire à la capture globale: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;iostream&gt; void bar() { static int static_int = 10; std::cout &lt;&lt; static_int &lt;&lt; std::endl; auto foo = [=] () mutable { ++static_int; }; foo(); std::cout &lt;&lt; static_int &lt;&lt; std::endl; [] { ++static_int; } (); std::cout &lt;&lt; static_int &lt;&lt; std::endl; [static_int] { ++static_int; } (); } int main() { bar(); }</span></span></span></span></code> </pre> <br>  Vous pouvez jouer avec le code ici: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">@Wandbox</a> <br><br>  Conclusion: <br><br><pre> <code class="cpp hljs"><span class="hljs-number"><span class="hljs-number">10</span></span> <span class="hljs-number"><span class="hljs-number">11</span></span> <span class="hljs-number"><span class="hljs-number">12</span></span></code> </pre> <br>  Et encore, un avertissement n'apparaîtra que si vous capturez explicitement une variable statique, donc si vous utilisez <code>[=]</code> , le compilateur ne vous aidera pas. <br><br>  <b>Capture des membres de la classe</b> <br><br>  Savez-vous ce qui se passe après l'exécution du code suivant: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;iostream&gt; #include &lt;functional&gt; struct Baz { std::function&lt;void()&gt; foo() { return [=] { std::cout &lt;&lt; s &lt;&lt; std::endl; }; } std::string s; }; int main() { auto f1 = Baz{"ala"}.foo(); auto f2 = Baz{"ula"}.foo(); f1(); f2(); }</span></span></span></span></code> </pre><br>  Le code déclare un objet Baz puis appelle <code>foo()</code> .  Notez que <code>foo()</code> retourne un lambda (stocké dans <code>std::function</code> ) qui capture un membre de la classe. <br><br>  Puisque nous utilisons des objets temporaires, nous ne pouvons pas être sûrs de ce qui se passera lorsque f1 et f2 seront appelés.  Il s'agit d'un problème de lien pendant qui provoque un comportement indéfini. <br><br>  De même: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Bar</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-function"><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">string</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function">&amp; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> s; }; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> s; }; <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span>&amp;&amp; f1 = Bar{<span class="hljs-string"><span class="hljs-string">"ala"</span></span>}.foo(); <span class="hljs-comment"><span class="hljs-comment">//  </span></span></code> </pre> <br>  Jouez avec le code <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">@Wandbox</a> <br><br>  Encore une fois, si vous spécifiez explicitement la capture ([s]): <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::function&lt;<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>()&gt; foo() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [s] { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; s &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; }; }</code> </pre><br>  Le compilateur empêchera votre erreur: <br><br><pre> <code class="cpp hljs">In member function <span class="hljs-string"><span class="hljs-string">'std::function&lt;void()&gt; Baz::foo()'</span></span>: error: capture of non-variable <span class="hljs-string"><span class="hljs-string">'Baz::s'</span></span> error: <span class="hljs-string"><span class="hljs-string">'this'</span></span> was <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> captured <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span> lambda function ...</code> </pre> <br>  Voir un exemple: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">@Wandbox</a> <br><br>  <b>Objets mobiles uniquement</b> <br><br>  Si vous avez un objet qui ne peut être déplacé (par exemple, unique_ptr), vous ne pouvez pas le placer dans un lambda en tant que variable capturée.  La capture par valeur ne fonctionne pas, vous ne pouvez donc capturer que par référence ... cependant, cela ne vous sera pas transféré, et ce n'est probablement pas ce que vous vouliez. <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">unique_ptr</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; p(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[<span class="hljs-number"><span class="hljs-number">10</span></span>]); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> foo = [p] () {}; <span class="hljs-comment"><span class="hljs-comment">//  ....</span></span></code> </pre><br>  <b>Enregistrement des constantes</b> <br><br>  Si vous capturez une variable constante, la constance est préservée: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> x = <span class="hljs-number"><span class="hljs-number">10</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> foo = [x] () <span class="hljs-keyword"><span class="hljs-keyword">mutable</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::is_const&lt;<span class="hljs-keyword"><span class="hljs-keyword">decltype</span></span>(x)&gt;::value &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; x = <span class="hljs-number"><span class="hljs-number">11</span></span>; }; foo();</code> </pre> <br>  Voir le code: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">@Wandbox</a> <br><br>  <b>Type de retour</b> <br><br>  En C ++ 11, vous pouvez ignorer la <code>trailing</code> type de retour lambda, puis le compilateur le restituera pour vous. <br><br>  Initialement, la sortie du type de valeur de retour était limitée aux lambdas contenant une instruction de retour, mais cette restriction a été rapidement supprimée, car il n'y avait aucun problème avec l'implémentation d'une version plus pratique. <br><br>  Voir les <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">rapports de défauts de langage standard C ++ et les problèmes acceptés</a> (merci à Thomas d'avoir trouvé le bon lien!) <br><br>  Ainsi, à partir de C ++ 11, le compilateur peut déduire le type de la valeur de retour si toutes les instructions de retour peuvent être converties dans le même type. <br><blockquote>  Si toutes les instructions de retour renvoient l'expression et les types de retour après la conversion lvalue-to-rvalue (7.1 [conv.lval]), array-to-pointer (7.2 [conv.array]) et function-to-pointer (7.3 [conv. func]) est le même que le type générique; <br></blockquote><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> baz = [] () { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x = <span class="hljs-number"><span class="hljs-number">10</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( x &lt; <span class="hljs-number"><span class="hljs-number">20</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x * <span class="hljs-number"><span class="hljs-number">1.1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x * <span class="hljs-number"><span class="hljs-number">2.1</span></span>; };</code> </pre><br>  Vous pouvez jouer avec le code ici: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">@Wandbox</a> <br><br>  Il y a deux <code>return</code> dans le lambda ci-dessus, mais elles pointent toutes vers le <code>double</code> , de sorte que le compilateur peut déduire le type. <br><br>  <b>IIFE - Expression de fonction immédiatement invoquée</b> <br><br>  Dans nos exemples, j'ai défini un lambda, puis je l'ai appelé à l'aide de l'objet de fermeture ... mais il peut également être appelé immédiatement: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x = <span class="hljs-number"><span class="hljs-number">1</span></span>, y = <span class="hljs-number"><span class="hljs-number">1</span></span>; [&amp;]() { ++x; ++y; }(); <span class="hljs-comment"><span class="hljs-comment">// &lt;-- call () std::cout &lt;&lt; x &lt;&lt; " " &lt;&lt; y &lt;&lt; std::endl;</span></span></code> </pre> <br>  Une telle expression peut être utile dans l'initialisation complexe d'objets constants. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> val = []() { <span class="hljs-comment"><span class="hljs-comment">/*   ... */</span></span> }();</code> </pre> <br>  J'ai écrit plus à ce sujet dans le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">post IIFE for Complex Initialization</a> . <br><br>  <b>Convertir en pointeur de fonction</b> <br><blockquote>  Le type de fermeture pour une expression lambda sans capture a une fonction implicite non virtuelle ouverte de conversion d'une constante en pointeur en une fonction qui a le même paramètre et les mêmes types de retour que l'opérateur d'appel d'une fonction du type de fermeture.  La valeur renvoyée par cette fonction de conversion doit être l'adresse de la fonction qui, lorsqu'elle est appelée, a le même effet que d'appeler l'opérateur d'une fonction d'un type similaire à un type de fermeture. </blockquote>  En d'autres termes, vous pouvez convertir des lambdas sans captures en un pointeur de fonction. <br><br>  Par exemple: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;iostream&gt; void callWith10(void(* bar)(int)) { bar(10); } int main() { struct { using f_ptr = void(*)(int); void operator()(int s) const { return call(s); } operator f_ptr() const { return &amp;call; } private: static void call(int s) { std::cout &lt;&lt; s &lt;&lt; std::endl; }; } baz; callWith10(baz); callWith10([](int x) { std::cout &lt;&lt; x &lt;&lt; std::endl; }); }</span></span></span></span></code> </pre> <br>  Vous pouvez jouer avec le code ici: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">@Wandbox</a> <br><br>  <b>Améliorations dans C ++ 14</b> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Norme N4140</a> et lambda: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">[expr.prim.lambda]</a> . <br><br>  C ++ 14 a ajouté deux améliorations significatives aux expressions lambda: <br><br><ul><li>  Captures avec initialiseur </li><li>  Lambdas communs </li></ul><br>  Ces fonctionnalités résolvent plusieurs problèmes visibles en C ++ 11. <br><br>  <b>Type de retour</b> <br><br>  La sortie du type de valeur de retour de l'expression lambda a été mise à jour pour se conformer aux règles de sortie automatique des fonctions. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">[expr.prim.lambda # 4]</a> <br><blockquote>  Le type de retour du lambda est auto, qui est remplacé par le type de retour de fin, s'il est fourni et / ou déduit des instructions de retour, comme décrit dans [dcl.spec.auto]. </blockquote>  <b>Captures avec initialiseur</b> <br><br>  En bref, nous pouvons créer une nouvelle variable membre du type de fermeture, puis l'utiliser dans l'expression lambda. <br><br>  Par exemple: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x = <span class="hljs-number"><span class="hljs-number">10</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> y = <span class="hljs-number"><span class="hljs-number">11</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> foo = [z = x+y]() { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; z &lt;&lt; <span class="hljs-string"><span class="hljs-string">'\n'</span></span>; }; foo(); }</code> </pre> <br>  Cela peut résoudre plusieurs problèmes, par exemple, avec des types qui ne sont disponibles que pour le déplacement. <br><br>  <b>Déménagement</b> <br><br>  Maintenant, nous pouvons déplacer l'objet vers un membre du type de fermeture: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;memory&gt; int main() { std::unique_ptr&lt;int&gt; p(new int[10]); auto foo = [x=10] () mutable { ++x; }; auto bar = [ptr=std::move(p)] {}; auto baz = [p=std::move(p)] {}; }</span></span></span></span></code> </pre> <br>  <b>Optimisation</b> <br><br>  Une autre idée est de l'utiliser comme technique d'optimisation potentielle.  Au lieu de calculer une valeur à chaque fois que nous appelons le lambda, nous pouvons le calculer une fois dans l'initialiseur: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;iostream&gt; #include &lt;algorithm&gt; #include &lt;vector&gt; #include &lt;memory&gt; #include &lt;iostream&gt; #include &lt;string&gt; int main() { using namespace std::string_literals; std::vector&lt;std::string&gt; vs; std::find_if(vs.begin(), vs.end(), [](std::string const&amp; s) { return s == "foo"s + "bar"s; }); std::find_if(vs.begin(), vs.end(), [p="foo"s + "bar"s](std::string const&amp; s) { return s == p; }); }</span></span></span></span></code> </pre> <br>  <b>Capturer une variable membre</b> <br><br>  Un initialiseur peut également être utilisé pour capturer une variable membre.  Ensuite, nous pouvons obtenir une copie de la variable membre et ne pas nous soucier des liens pendants. <br><br>  Par exemple: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Baz</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">auto</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [s=s] { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; s &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; }; } <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> s; }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> f1 = Baz{<span class="hljs-string"><span class="hljs-string">"ala"</span></span>}.foo(); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> f2 = Baz{<span class="hljs-string"><span class="hljs-string">"ula"</span></span>}.foo(); f1(); f2(); }</code> </pre> <br>  Vous pouvez jouer avec le code ici: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">@Wandbox</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><br></a> <br><br>  Dans <code>foo()</code> nous capturons une variable membre en la copiant dans le type de fermeture.  De plus, nous utilisons auto pour afficher l'intégralité de la méthode (auparavant, en C ++ 11, nous pouvions utiliser <code>std::function</code> ). <br><br>  <b>Expressions lambda génériques</b> <br><br>  Une autre amélioration significative est le lambda généralisé. <br>  À partir de C ++ 14, vous pouvez écrire: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> foo = [](<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> x) { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; x &lt;&lt; <span class="hljs-string"><span class="hljs-string">'\n'</span></span>; }; foo(<span class="hljs-number"><span class="hljs-number">10</span></span>); foo(<span class="hljs-number"><span class="hljs-number">10.1234</span></span>); foo(<span class="hljs-string"><span class="hljs-string">"hello world"</span></span>);</code> </pre> <br>  Cela équivaut à utiliser une déclaration de modèle dans une instruction d'appel de type fermeture: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">operator</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(T x)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; x &lt;&lt; <span class="hljs-string"><span class="hljs-string">'\n'</span></span>; } } someInstance;</code> </pre><br>  Un tel lambda généralisé peut être très utile lorsqu'il est difficile de déduire un type. <br><br>  Par exemple: <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">map</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; numbers { { <span class="hljs-string"><span class="hljs-string">"one"</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span> }, {<span class="hljs-string"><span class="hljs-string">"two"</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span> }, { <span class="hljs-string"><span class="hljs-string">"three"</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span> } }; <span class="hljs-comment"><span class="hljs-comment">//      pair&lt;const string, int&gt;! std::for_each(std::begin(numbers), std::end(numbers), [](const std::pair&lt;std::string, int&gt;&amp; entry) { std::cout &lt;&lt; entry.first &lt;&lt; " = " &lt;&lt; entry.second &lt;&lt; '\n'; } );</span></span></code> </pre><br>  Ai-je tort ici?  L'entrée a-t-elle le bon type? <br>  . <br>  . <br>  . <br>  Probablement pas, car le type de valeur pour std :: map est <code>std::pair&lt;const Key, T&gt;</code> .  Donc mon code fera des copies supplémentaires des lignes ... <br>  Cela peut être corrigé avec <code>auto</code> : <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::for_each(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::begin(numbers), <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::end(numbers), [](<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span>&amp; entry) { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; entry.first &lt;&lt; <span class="hljs-string"><span class="hljs-string">" = "</span></span> &lt;&lt; entry.second &lt;&lt; <span class="hljs-string"><span class="hljs-string">'\n'</span></span>; } );</code> </pre> <br>  Vous pouvez jouer avec le code ici: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">@Wandbox</a> <br><br>  <b>Conclusion</b> <br><br>  Quelle histoire! <br><br>  Dans cet article, nous sommes partis des premiers jours des expressions lambda en C ++ 03 et C ++ 11 et sommes passés à une version améliorée en C ++ 14. <br><br>  Vous avez vu comment créer un lambda, quelle est la structure de base de cette expression, qu'est-ce qu'une liste de capture, et bien plus encore. <br><br>  Dans la prochaine partie de l'article, nous allons passer à C ++ 17 et découvrir les futures fonctionnalités de C ++ 20. <br><br>  La deuxième partie est disponible ici: <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Lambdas: du C ++ 11 au C ++ 20, partie 2</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><br></a> <br><br>  Les références <br><br>  C ++ 11 - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">[expr.prim.lambda]</a> <br>  C ++ 14 - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">[expr.prim.lambda]</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Expressions lambda en C ++ |</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Documents Microsoft</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Démystifier les lambdas C ++ - Sticky Bits - Propulsé par Feabhas; Sticky Bits - Propulsé par Feabhas</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><br></a> <br><br>  Nous attendons vos commentaires et invitons toutes les personnes intéressées par le cours <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">"Développeur C ++"</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr444524/">https://habr.com/ru/post/fr444524/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr444514/index.html">Webinaire "Sécurité de l'apprentissage automatique: problèmes naturels de l'intelligence artificielle"</a></li>
<li><a href="../fr444516/index.html">Wolfenstein 3D: lancer de rayons avec WebGL1</a></li>
<li><a href="../fr444518/index.html">Vers une théorie fondamentale de la conscience</a></li>
<li><a href="../fr444520/index.html">2. Check Point Getting Started R80.20. Architecture de la solution</a></li>
<li><a href="../fr444522/index.html">Apocalypse est annulée</a></li>
<li><a href="../fr444526/index.html">Pile DOTS: C ++ & C #</a></li>
<li><a href="../fr444528/index.html">Situation: le Japon peut limiter le téléchargement de contenu à partir du réseau - nous comprenons et discutons</a></li>
<li><a href="../fr444530/index.html">L'avenir de l'injection de dépendance dans Android</a></li>
<li><a href="../fr444534/index.html">Analyse des vulnérabilités et développement sécurisé. Partie 1</a></li>
<li><a href="../fr444536/index.html">MVCC-2. Calques, fichiers, pages</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>