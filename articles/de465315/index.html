<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏼‍🤝‍👩🏻 🌷 🧑🏾‍🤝‍🧑🏽 Kafka und Microservices: ein Überblick 🔓 📓 ◀️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hallo an alle. In diesem Artikel werde ich Ihnen erklären, warum wir uns vor neun Monaten in Avito für Kafka entschieden haben und was es ist. Ich wer...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Kafka und Microservices: ein Überblick</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/avito/blog/465315/"><p><img src="https://habrastorage.org/webt/ds/35/lj/ds35ljzkot_2jqkr7tnjuf8ynwg.png"></p><br><p>  Hallo an alle.  In diesem Artikel werde ich Ihnen erklären, warum wir uns vor neun Monaten in Avito für Kafka entschieden haben und was es ist.  Ich werde einen der Anwendungsfälle teilen - einen Nachrichtenbroker.  Lassen Sie uns abschließend darüber sprechen, welche Vorteile sich aus der Anwendung des Kafka as a Service-Ansatzes ergeben. </p><a name="habracut"></a><br><h1 id="problema">  Das Problem </h1><br><p><img src="https://habrastorage.org/webt/xd/gl/fu/xdglfupecap80heoegvpab_iy74.png"></p><br><p>  Zunächst ein kleiner Kontext.  Vor einiger Zeit haben wir begonnen, uns von der monolithischen Architektur zu entfernen, und jetzt gibt es in Avito bereits mehrere hundert verschiedene Dienstleistungen.  Sie haben ihre eigenen Repositorys, ihren eigenen Technologie-Stack und sind für ihren Teil der Geschäftslogik verantwortlich. </p><br><p>  Eines der Probleme bei einer großen Anzahl von Diensten ist die Kommunikation.  Dienst A möchte häufig die Informationen wissen, über die Dienst B verfügt. In diesem Fall greift Dienst A über eine synchrone API auf Dienst B zu.  Dienst B möchte wissen, was mit den Diensten G und D passiert, und diese wiederum sind an den Diensten A und B interessiert. Wenn es viele solcher „neugierigen“ Dienste gibt, verwandeln sich die Verbindungen zwischen ihnen in einen Wirrwarr. </p><br><p>  Darüber hinaus kann Service A jederzeit nicht mehr verfügbar sein.  Und was tun in diesem Fall, Service B und alle anderen damit verbundenen Services?  Und wenn Sie eine Kette aufeinanderfolgender synchroner Aufrufe ausführen müssen, um einen Geschäftsvorgang abzuschließen, wird die Wahrscheinlichkeit eines Ausfalls des gesamten Vorgangs noch höher (und je höher, desto länger diese Kette). </p><br><h1 id="vybor-tehnologii">  Technologieauswahl </h1><br><p><img src="https://habrastorage.org/webt/pr/t4/xo/prt4xoqz2xianmupqbdqk1unc8i.png" width="300" alt="Bild" align="left"></p><br><p>  OK, die Probleme sind klar.  Sie können sie beseitigen, indem Sie ein zentrales Nachrichtensystem zwischen den Diensten einrichten.  Jetzt reicht jeder der Dienste aus, um nur über dieses Nachrichtensystem Bescheid zu wissen.  Darüber hinaus muss das System selbst fehlertolerant und horizontal skalierbar sein und bei Unfällen einen Anrufpuffer für die anschließende Verarbeitung ansammeln. </p><br><p>  Wählen wir nun die Technologie aus, auf der die Nachrichtenübermittlung implementiert werden soll.  Um dies zu tun, verstehen Sie zuerst, was wir von ihr erwarten: </p><br><ul><li>  Nachrichten zwischen Diensten sollten nicht verloren gehen. </li><li>  Nachrichten können dupliziert werden </li><li>  Nachrichten können bis zu einer Tiefe von mehreren Tagen gespeichert und gelesen werden (persistenter Puffer); </li><li>  Dienste können Daten abonnieren, die für sie von Interesse sind; </li><li>  Mehrere Dienste können dieselben Daten lesen. </li><li>  Nachrichten können detaillierte Massennutzdaten enthalten (ereignisgesteuerte Statusübertragung). </li><li>  Manchmal benötigen Sie eine Garantie für die Nachrichtenbestellung. </li></ul><br><p>  Für uns war es auch wichtig, das skalierbarste und zuverlässigste System mit hohem Durchsatz auszuwählen (mindestens 100.000 Nachrichten mit wenigen Kilobyte pro Sekunde). </p><br><p> Zu diesem Zeitpunkt haben wir uns von RabbitMQ (es ist schwierig, bei hohen Drehzahlen stabil zu bleiben), SkyTools PGQ (nicht schnell genug und schlecht skalierbar) und NSQ (nicht persistent) verabschiedet.  Alle diese Technologien werden in unserem Unternehmen eingesetzt, aber sie passten nicht zur jeweiligen Aufgabe. </p><br><p>  Dann suchten wir nach neuen Technologien für uns - Apache Kafka, Apache Pulsar und NATS Streaming. </p><br><p>  Der erste, der Pulsar fallen ließ.  Wir haben entschieden, dass Kafka und Pulsar ziemlich ähnliche Lösungen sind.  Und trotz der Tatsache, dass Pulsar von großen Unternehmen getestet wird, neuer ist und (theoretisch) eine geringere Latenz bietet, haben wir beschlossen, Kafka als De-facto-Standard für solche Aufgaben aus den beiden herauszulassen.  Wir werden wahrscheinlich in Zukunft zu Apache Pulsar zurückkehren. </p><br><p>  Und es waren noch zwei Kandidaten übrig: NATS Streaming und Apache Kafka.  Wir haben beide Lösungen eingehend untersucht und beide haben die Aufgabe erfüllt.  Am Ende hatten wir jedoch Angst vor der relativen Jugend von NATS Streaming (und vor der Tatsache, dass einer der Hauptentwickler, Tyler Treat, beschlossen hat, das Projekt zu verlassen und ein eigenes zu gründen - Liftbridge).  Gleichzeitig ermöglichte der Clustering-Modus von NATS Streaming keine starke horizontale Skalierung (dies ist wahrscheinlich kein Problem mehr, nachdem 2017 der Partitionierungsmodus hinzugefügt wurde). </p><br><p>  NATS Streaming ist jedoch eine coole Technologie, die in Go geschrieben und von der Cloud Native Computing Foundation unterstützt wird.  Im Gegensatz zu Apache Kafka muss Zookeeper nicht funktionieren ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">möglicherweise kann man bald dasselbe über Kafka sagen</a> ), da darin RAFT implementiert ist.  Gleichzeitig ist NATS Streaming einfacher zu verwalten.  Wir schließen nicht aus, dass wir in Zukunft auf diese Technologie zurückkommen werden. </p><br><p>  Trotzdem ist Apache Kafka heute unser Gewinner geworden.  In unseren Tests erwies es sich als recht schnell (mehr als eine Million Nachrichten pro Sekunde zum Lesen und Schreiben mit einem Nachrichtenvolumen von 1 Kilobyte), zuverlässig genug, gut skalierbar und nachgewiesene Erfahrung im Verkauf durch große Unternehmen.  Darüber hinaus unterstützt Kafka mindestens mehrere große Handelsunternehmen (zum Beispiel verwenden wir die Confluent-Version), und Kafka verfügt über ein entwickeltes Ökosystem. <br><br clear="left"></p><br><h1 id="obzor-kafka">  Bewertung Kafka </h1><br><p>  Bevor ich anfange, empfehle ich sofort ein ausgezeichnetes Buch - <em>"Kafka: The Definitive Guide"</em> (es ist auch in der russischen Übersetzung, aber die Begriffe brechen das Gehirn ein wenig).  Darin finden Sie die Informationen, die für ein grundlegendes Verständnis von Kafka und noch ein wenig mehr erforderlich sind.  Die Apache-Dokumentation selbst und der Confluent-Blog sind ebenfalls gut geschrieben und leicht zu lesen. </p><br><p>  Schauen wir uns also an, wie Kafka aus der Vogelperspektive ist.  Die grundlegende Kafka-Topologie besteht aus Produzenten, Verbrauchern, Maklern und Tierpflegern. </p><br><h3 id="broker">  Makler </h3><br><p><img src="https://habrastorage.org/webt/ng/o6/l2/ngo6l2ngibz7krlckw0mpdy2x88.png"></p><br><p>  Ein Broker ist für die Speicherung Ihrer Daten verantwortlich.  Alle Daten werden in binärer Form gespeichert, und der Broker weiß wenig darüber, was sie sind und wie sie aufgebaut sind. </p><br><p>  Jeder logische Ereignistyp befindet sich normalerweise in einem eigenen Thema (Thema).  Beispielsweise kann ein Ereignis zur Anzeigenerstellung in das Thema item.created fallen, und ein Ereignis seiner Änderung kann in item.changed fallen.  Themen können als Klassifikatoren von Ereignissen betrachtet werden.  Auf Themenebene können Sie folgende Konfigurationsparameter festlegen: </p><br><ul><li>  gespeicherte Datenmenge und / oder deren Alter (Retention.bytes, Retention.ms); </li><li>  Datenredundanzfaktor (Replikationsfaktor); </li><li>  maximale Größe einer Nachricht (max.message.bytes); </li><li>  die Mindestanzahl konsistenter Replikate, mit denen Daten in das Thema geschrieben werden können (min.insync.replicas); </li><li>  die Möglichkeit eines Failovers auf ein nicht synchrones Replikat mit Verzögerung und potenziellem Datenverlust (unclean.leader.election.enable); </li><li>  und viele mehr ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://kafka.apache.org/documentation/#topicconfigs</a> ). </li></ul><br><p>  Jedes Thema ist wiederum in eine oder mehrere Partitionen (Partition) unterteilt.  In der Partition fallen letztendlich Ereignisse.  Wenn der Cluster mehr als einen Broker enthält, werden die Partitionen gleichmäßig auf alle Broker verteilt (so weit wie möglich), sodass Sie die Belastung beim Schreiben und Lesen in einem Thema auf mehrere Broker gleichzeitig skalieren können. </p><br><p>  Auf der Festplatte werden die Daten für jede Partition als Segmentdateien gespeichert, die standardmäßig einem Gigabyte entsprechen (gesteuert über log.segment.bytes).  Eine wichtige Funktion ist das Löschen von Daten aus Partitionen (wenn die Aufbewahrung ausgelöst wird) nur durch Segmente (Sie können nicht ein Ereignis aus einer Partition löschen, Sie können nur das gesamte Segment löschen und nur inaktiv). </p><br><h3 id="zookeeper">  Tierpfleger </h3><br><p> Zookeeper fungiert als Metadaten-Repository und Koordinator.  Er kann sagen, ob Broker am Leben sind (Sie können es mit den Augen eines Tierpflegers durch den Zookeeper-Shell-Befehl <code>ls /brokers/ids</code> brokers <code>ls /brokers/ids</code> ), welcher der Makler der Controller ist ( <code>get /controller</code> ), ob die Partitionen mit ihren Replikaten synchron sind ( <code>get /brokers/topics/topic_name/partitions/partition_number/state</code> ).  Außerdem gehen Produzent und Konsument zuerst zum Tierpfleger, um herauszufinden, auf welchem ​​Broker welche Themen und Partitionen gespeichert sind.  In Fällen, in denen ein Replikationsfaktor größer als 1 für das Thema angegeben ist, gibt der Tierpfleger an, welche Partitionen führend sind (sie werden beschrieben und von ihnen gelesen).  Im Falle eines Broker-Absturzes werden im Zookeeper Informationen zu den neuen Leader-Partitionen aufgezeichnet (ab Version 1.1.0 asynchron, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">und dies ist wichtig</a> ). </p><br><p>  In älteren Versionen von Kafka war zookeeper auch für das Speichern von Offsets verantwortlich. Jetzt werden sie in einem speziellen Thema <code>__consumer_offsets</code> auf dem Broker gespeichert (obwohl Sie zookeeper für diese Zwecke weiterhin verwenden können). </p><br><p>  Der einfachste Weg, Ihre Daten in einen Kürbis zu verwandeln, ist der Informationsverlust mit zookeeper.  In einem solchen Szenario ist es sehr schwierig zu verstehen, woraus und wo zu lesen ist. </p><br><h3 id="producer">  Produzent </h3><br><p>  Der Produzent ist meistens ein Dienst, der Daten direkt in Apache Kafka schreibt.  Der Produzent wählt ein Thema aus, in dem seine thematischen Nachrichten gespeichert werden, und beginnt, Informationen darauf zu schreiben.  Ein Produzent könnte beispielsweise ein Werbedienst sein.  In diesem Fall sendet er Ereignisse wie "Anzeige erstellt", "Anzeige aktualisiert", "Anzeige gelöscht" usw. an thematische Themen.  Jedes Ereignis ist ein Schlüssel-Wert-Paar. </p><br><p>  Standardmäßig werden alle Ereignisse von den Partitionspartitionen mit Round-Robin verteilt, wenn der Schlüssel nicht festgelegt ist (Verlust der Reihenfolge), und über MurmurHash (Schlüssel), wenn der Schlüssel vorhanden ist (Reihenfolge innerhalb derselben Partition). </p><br><p>  Hier ist sofort anzumerken, dass Kafka die Reihenfolge der Ereignisse innerhalb nur einer Partition garantiert.  Tatsächlich ist dies jedoch häufig kein Problem.  Beispielsweise können Sie garantiert alle Änderungen derselben Ankündigung zu einer Partition hinzufügen (wodurch die Reihenfolge dieser Änderungen innerhalb der Ankündigung beibehalten wird).  Sie können auch eine Sequenznummer in einem der Ereignisfelder übergeben. </p><br><h3 id="consumer">  Verbraucher </h3><br><p><img src="https://habrastorage.org/webt/z_/ab/oo/z_abooprhxbjgwpaqmjcdplsalc.png"></p><br><p>  Der Verbraucher ist für das Abrufen von Daten von Apache Kafka verantwortlich.  Wenn Sie zum obigen Beispiel zurückkehren, kann der Verbraucher ein Moderationsdienst sein.  Dieser Dienst wird für das Thema des Ankündigungsdienstes abonniert. Wenn eine neue Anzeige erscheint, wird sie empfangen und auf Einhaltung bestimmter Richtlinien analysiert. </p><br><p>  Apache Kafka merkt sich, welche Ereignisse der Verbraucher in letzter Zeit erhalten hat (hierfür wird das <code>__consumer__offsets</code> verwendet), wodurch sichergestellt wird, dass der Verbraucher nach erfolgreichem Lesen nicht zweimal dieselbe Nachricht erhält.  Wenn Sie jedoch die Option enable.auto.commit = true verwenden und Kafka die Aufgabe übertragen, die Position des Verbrauchers im Thema zu verfolgen, können Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Daten verlieren</a> .  Im Produktionscode wird die Position des Verbrauchers meistens manuell gesteuert (der Entwickler steuert den Moment, in dem das Festschreiben des Leseereignisses erfolgen muss). </p><br><p>  In Fällen, in denen ein Verbraucher nicht ausreicht (z. B. ist der Fluss neuer Ereignisse sehr groß), können Sie einige weitere Verbraucher hinzufügen, indem Sie sie in der Verbrauchergruppe miteinander verknüpfen.  Die Verbrauchergruppe ist logischerweise genau derselbe Verbraucher, jedoch mit der Verteilung der Daten unter den Gruppenmitgliedern.  Auf diese Weise kann jeder Teilnehmer seinen Anteil an Nachrichten übernehmen und so die Lesegeschwindigkeit erhöhen. </p><br><h1 id="rezultaty-testirovaniya">  Testergebnisse </h1><br><p><img src="https://habrastorage.org/webt/9w/fg/vy/9wfgvyrgh5ms1uhd8iutqqvu11k.png" width="300" alt="Bild" align="left"></p><br><p>  Hier werde ich nicht viel erklärenden Text schreiben, sondern nur die Ergebnisse teilen.  Die Tests wurden auf 3 physischen Maschinen (12 CPU, 384 GB RAM, 15 KB SAS-Festplatte, 10 GBit / s Net) durchgeführt. Broker und Zookeeper wurden in lxc bereitgestellt. </p><br><p>  <strong>Leistungstests</strong> </p><br><p>  Während des Testens wurden die folgenden Ergebnisse erhalten. </p><br><ul><li>  Die Geschwindigkeit der gleichzeitigen Aufzeichnung von Nachrichten mit einer Größe von 1 KB durch 9 Produzenten - 1300000 Ereignisse pro Sekunde. </li><li>  Lesegeschwindigkeit von 1 KB Nachrichten gleichzeitig von 9 Verbrauchern - 1.500.000 Ereignisse pro Sekunde. </li></ul><br><p>  <strong>Fehlertoleranzprüfung</strong> </p><br><p>  Während des Tests wurden die folgenden Ergebnisse erhalten (3 Makler, 3 Tierpfleger). </p><br><ul><li>  Eine abnormale Kündigung eines der Broker führt nicht zur Aussetzung oder Unzugänglichkeit des Clusters.  Die Arbeit geht wie gewohnt weiter, aber die restlichen Makler haben eine große Last. </li><li>  Die abnormale Beendigung von zwei Brokern bei einem Cluster von drei Brokern und min.isr = 2 führt dazu, dass der Cluster nicht zum Schreiben, sondern zur Lesbarkeit zugänglich ist.  Für den Fall min.isr = 1 steht der Cluster weiterhin zum Lesen und Schreiben zur Verfügung.  Dieser Modus widerspricht jedoch der Forderung nach hoher Datensicherheit. </li><li>  Ein abnormales Beenden eines der Zookeeper-Server führt nicht zum Herunterfahren des Clusters oder zu Unzugänglichkeiten.  Die Arbeit geht normal weiter. </li><li>  Eine abnormale Beendigung von zwei Zookeeper-Servern führt zu einer Unzugänglichkeit des Clusters, bis mindestens einer der Zookeeper-Server wiederhergestellt ist.  Diese Aussage gilt für einen Zookeeper-Cluster mit 3 Servern.  Infolgedessen wurde nach Recherchen beschlossen, den Zookeeper-Cluster auf 5 Server zu erhöhen, um die Fehlertoleranz zu erhöhen. <br clear="left"></li></ul><br><h1 id="kafka-as-a-service">  Kafka als Dienstleistung </h1><br><p><img src="https://habrastorage.org/webt/cc/hg/y_/cchgy_e8d7-cztjd5ltu97kfs2o.jpeg" width="300" alt="Bild" align="left"></p><br><p>  Wir haben sichergestellt, dass Kafka eine hervorragende Technologie ist, mit der wir die für uns gestellten Aufgaben lösen können (Implementierung eines Nachrichtenbrokers).  Trotzdem haben wir beschlossen, den Diensten den direkten Zugriff auf Kafka zu untersagen und es mit dem Datenbusdienst zu schließen.  Warum haben wir das gemacht?  Es gibt tatsächlich mehrere Gründe. </p><br><ul><li><p>  Der Datenbus übernahm alle Aufgaben im Zusammenhang mit der Integration in Kafka (Implementierung und Konfiguration von Verbrauchern und Herstellern, Überwachung, Alarmierung, Protokollierung, Skalierung usw.).  Somit ist die Integration mit dem Nachrichtenbroker so einfach wie möglich. </p><br></li><li><p>  Datenbus darf aus einer bestimmten Sprache oder Bibliothek abstrahieren, um mit Kafka zu arbeiten. </p><br></li><li><p>  Der Datenbus ermöglichte es anderen Diensten, von der Speicherschicht zu abstrahieren.  Vielleicht werden wir irgendwann Kafka in Pulsar ändern, und niemand wird etwas bemerken (alle Dienste wissen nur über die Datenbus-API Bescheid). </p><br></li><li><p>  Der Datenbus übernahm die Validierung von Ereignisschemata. </p><br></li><li><p>  Die Verwendung der Datenbusauthentifizierung ist implementiert. </p><br></li><li><p>  Unter dem Deckmantel des Datenbusses können wir ohne Ausfallzeiten Kafka-Versionen diskret aktualisieren, Konfigurationen von Herstellern, Verbrauchern, Maklern usw. zentral durchführen. </p><br></li><li><p>  Mit dem Datenbus konnten wir Funktionen hinzufügen, die nicht in Kafka enthalten sind (z. B. Themenprüfung, Überwachung von Anomalien im Cluster, Erstellen von DLQ usw.). </p><br></li><li><p>  Mit dem Datenbus kann das Failover für alle Dienste zentral implementiert werden. </p><br></li></ul><br><p>  Um Ereignisse an den Nachrichtenbroker zu senden, verbinden Sie derzeit einfach eine kleine Bibliothek mit Ihrem Servicecode.  Das ist alles.  Sie haben die Möglichkeit, mit einer Codezeile zu schreiben, zu lesen und zu skalieren.  Die gesamte Implementierung ist Ihnen verborgen, nur ein paar Sticks wie die Größe des Stapels ragen heraus.  Unter der Haube erhöht der Datenbusdienst die erforderliche Anzahl von Produzenten- und Konsumenteninstanzen in Kubernetes und fügt ihnen die erforderliche Konfiguration hinzu, aber all dies ist für Ihren Dienst transparent. </p><br><p>  Natürlich gibt es keine Silberkugel, und dieser Ansatz hat seine Grenzen. </p><br><ul><li>  Der Datenbus muss im Gegensatz zu Bibliotheken von Drittanbietern eigenständig unterstützt werden. </li><li>  Der Datenbus erhöht die Anzahl der Interaktionen zwischen Diensten und dem Nachrichtenbroker, was zu einer geringeren Leistung im Vergleich zu nacktem Kafka führt. </li><li>  Nicht alles kann so einfach vor Diensten verborgen werden. Wir möchten nicht die Funktionalität von KSQL- oder Kafka-Streams im Datenbus duplizieren. Daher müssen Sie manchmal zulassen, dass Dienste direkt ausgeführt werden. </li></ul><br><p>  In unserem Fall überwogen die Vorteile die Nachteile, und die Entscheidung, den Nachrichtenbroker mit einem separaten Dienst abzudecken, war gerechtfertigt.  Während des Betriebsjahres hatten wir keine ernsthaften Unfälle und Probleme. </p><br><p>  PS Danke an meine Freundin Ekaterina Oblyalyaeva für die coolen Bilder zu diesem Artikel.  Wenn Sie sie mochten, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">gibt</a> es noch mehr Abbildungen. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de465315/">https://habr.com/ru/post/de465315/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de465299/index.html">Apache NIFI - Ein kurzer Überblick über die Funktionen in der Praxis</a></li>
<li><a href="../de465301/index.html">So erstellen Sie einen E-Commerce-Layoutprozess, um alle benötigten Daten abzurufen</a></li>
<li><a href="../de465303/index.html">Moskauer Züge (und nicht nur): Was hat sich geändert und danke an diejenigen, die geholfen haben</a></li>
<li><a href="../de465309/index.html">Ich bin der größte Fiesling in der Entwicklung von Indie-Spielen</a></li>
<li><a href="../de465311/index.html">DIY Fahrzeugüberwachungssystem</a></li>
<li><a href="../de465319/index.html">Missverständnisse der Vergangenheit</a></li>
<li><a href="../de465321/index.html">In Zukunft können Wissenschaftler lernen, genau vorherzusagen, woran Sie sich erinnern werden.</a></li>
<li><a href="../de465323/index.html">Was wird Post-Quanten-Kryptographie sein?</a></li>
<li><a href="../de465325/index.html">Spezielle Objekte, die schwer zu greifen sind</a></li>
<li><a href="../de465329/index.html">Interpretiertes Modell des maschinellen Lernens. Teil 2</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>