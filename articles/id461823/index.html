<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🍺 👏🏾 🤚🏾 Enhanced Four Rules untuk Desain Perangkat Lunak 💥 🐒 🎓</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Halo, Habr! Saya menyajikan kepada Anda artikel "Empat Aturan Lebih Baik untuk Desain Perangkat Lunak" oleh David Bryant Copeland. David Bryant Copela...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Enhanced Four Rules untuk Desain Perangkat Lunak</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/461823/"><p>  Halo, Habr!  Saya menyajikan kepada Anda artikel "Empat Aturan Lebih Baik untuk Desain Perangkat Lunak" oleh David Bryant Copeland.  David Bryant Copeland adalah arsitek perangkat lunak dan CTO untuk Stitch Fix.  Dia memelihara <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sebuah blog</a> dan merupakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">penulis beberapa buku</a> . </p><br><p>  Martin Fowler baru-baru ini mentweet dengan tautan ke <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">posting blognya</a> tentang empat aturan desain sederhana dari Kent Beck, yang menurut saya dapat ditingkatkan lebih lanjut (dan yang kadang-kadang dapat mengirim programmer ke jalur yang salah): </p><br><p>  Aturan Kent dari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Pemrograman Ekstrim Dijelaskan</a> : </p><br><ul><li>  Kent berkata, "Jalankan semua tes." </li><li>  Jangan menduplikasi logika.  Cobalah untuk menghindari duplikat tersembunyi, seperti hierarki kelas paralel. </li><li>  Semua niat penting bagi programmer harus terlihat jelas. </li><li>  Kode harus memiliki jumlah kelas dan metode sekecil mungkin. </li></ul><br><p>  Menurut pengalaman saya, aturan-aturan ini tidak cukup memenuhi kebutuhan desain perangkat lunak. <a name="habracut"></a>  Empat aturan saya untuk sistem yang dirancang dengan baik mungkin: </p><br><ul><li>  itu ditutupi dengan baik oleh tes dan berhasil melewati mereka. </li><li>  tidak memiliki abstraksi yang tidak secara langsung dibutuhkan oleh program. </li><li>  dia memiliki perilaku yang jelas. </li><li>  membutuhkan paling sedikit konsep. </li></ul><br><p>  Bagi saya, aturan ini berasal dari apa yang kami lakukan dengan perangkat lunak kami. </p><br><h1 id="tak-chto-zhe-my-delaem-s-nashim-po">  Jadi apa yang kita <em>lakukan</em> dengan perangkat lunak kita? </h1><br><p>  Kita tidak dapat berbicara tentang desain perangkat lunak tanpa terlebih dahulu berbicara tentang apa yang ingin kita lakukan dengannya. </p><br><p>  Perangkat lunak ini ditulis untuk menyelesaikan masalah.  Program berjalan dan memiliki perilaku.  Perilaku ini dipelajari untuk memastikan operasi yang benar atau untuk mendeteksi kesalahan.  Perangkat lunak juga sering berubah untuk memberikan perilaku baru atau berubah. </p><br><p>  Oleh karena itu, setiap pendekatan desain perangkat lunak harus difokuskan pada memprediksi, mempelajari, dan memahami perilakunya untuk membuat mengubah perilaku ini sesederhana mungkin. </p><br><p>  Kami memeriksa kebenaran perilaku dengan menguji, dan oleh karena itu saya setuju dengan Kent bahwa hal pertama dan yang paling penting adalah perangkat lunak yang dirancang dengan baik harus lulus tes.  Saya bahkan akan melangkah lebih jauh dan bersikeras bahwa perangkat lunak harus memiliki tes (mis. Dicakup dengan baik oleh tes). </p><br><p>  Setelah perilaku diverifikasi, tiga poin berikut pada kedua daftar terkait dengan memahami perangkat lunak kami (dan karenanya, perilaku).  Daftarnya dimulai dengan duplikasi kode, yang benar-benar ada.  Namun, dalam pengalaman pribadi saya, terlalu banyak berfokus pada mengurangi duplikasi kode itu mahal.  Untuk menghilangkannya, perlu membuat abstraksi yang menyembunyikannya, dan abstraksi inilah yang membuat perangkat lunak sulit untuk dipahami dan diubah. </p><br><h1 id="ustranenie-dublirovaniya-koda-trebuet-abstrakciy-a-abstrakcii-privodyat-k-slozhnosti">  Menghilangkan duplikasi kode memerlukan abstraksi, dan abstraksi menyebabkan kompleksitas </h1><br><p>  Jangan Ulangi Diri Anda atau KERING digunakan untuk membenarkan keputusan desain yang kontroversial.  Pernahkah Anda melihat kode serupa? </p><br><pre><code class="ruby hljs">ZERO = BigDecimal.new(<span class="hljs-number"><span class="hljs-number">0</span></span>)</code> </pre> <br><p>  Selain itu, Anda mungkin melihat sesuatu seperti ini: </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">call</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Map payload, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">boolean</span></span></span></span><span class="hljs-function"><span class="hljs-params"> async, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> errorStrategy)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// ... }</span></span></code> </pre> <br><p>  Jika Anda melihat metode atau fungsi dengan flag, boolean, dll., Maka ini biasanya berarti bahwa seseorang menggunakan prinsip KERING saat refactoring, tetapi kode itu tidak <em>persis</em> sama di kedua tempat, sehingga kode yang dihasilkan harus memiliki cukup fleksibel untuk mengakomodasi kedua perilaku. </p><br><p>  Abstraksi umum semacam itu sulit untuk diuji dan dipahami, karena mereka harus menangani lebih banyak kasus daripada kode asli (mungkin digandakan).  Dengan kata lain, abstraksi mendukung lebih banyak perilaku daripada yang diperlukan untuk fungsi normal sistem.  Dengan demikian, menghilangkan duplikasi kode dapat menciptakan perilaku baru yang tidak diperlukan oleh sistem. </p><br><p>  Oleh karena itu, <em>sangat penting untuk</em> menggabungkan beberapa jenis perilaku, tetapi mungkin sulit untuk memahami perilaku seperti apa yang benar-benar diduplikasi.  Seringkali potongan kode terlihat serupa, tetapi ini hanya terjadi secara kebetulan. </p><br><p>  Pertimbangkan betapa lebih mudahnya menghilangkan duplikasi kode daripada mengembalikannya lagi (misalnya, setelah membuat abstraksi yang dipikirkan dengan buruk).  Oleh karena itu, kita perlu berpikir tentang meninggalkan kode duplikat, kecuali kita benar-benar yakin bahwa kita memiliki cara yang lebih baik untuk menghilangkannya. </p><br><p>  Membuat abstraksi harus membuat kita berpikir.  Jika dalam proses menghilangkan kode duplikat Anda membuat abstraksi umum yang sangat fleksibel, maka Anda mungkin salah jalan. </p><br><p>  Ini membawa kita ke titik berikutnya - niat versus perilaku. </p><br><h1 id="namerenie-programmista-bessmyslenno---povedenie-znachit-vse">  Niat Programmer tidak ada artinya - perilaku berarti segalanya </h1><br><p>  Kami sering memuji bahasa pemrograman, konstruksi, atau cuplikan kode karena "mengungkap maksud programmer."  Tapi apa gunanya mengetahui niat jika Anda tidak bisa memprediksi perilaku?  Dan jika Anda tahu perilaku, seberapa besar niatnya?  Ternyata Anda <em>perlu</em> tahu bagaimana perilakunya <em>seharusnya</em> , tetapi ini tidak sama dengan "niat programmer." </p><br><p>  Mari kita lihat contoh ini, yang mencerminkan niat programmer dengan sangat baik, tetapi tidak berperilaku sebagaimana dimaksud: </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LastModified</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">props</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ( <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> Last modified on { props.date.toLocaleDateString() } </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span> ); }</code> </pre> <br><p>  Jelas, programmer merencanakan komponen Bereaksi ini akan menampilkan tanggal dengan pesan "Terakhir diubah pada".  Apakah ini berfungsi sebagaimana dimaksud?  Tidak juga.  Bagaimana jika tanggal ini tidak penting?  Semuanya rusak.  Kami tidak tahu apakah itu dikandung, atau seseorang hanya melupakannya, dan itu bahkan tidak masalah.  Yang penting adalah perilaku. </p><br><p>  Dan inilah yang harus kita ketahui jika kita ingin mengubah bagian kode ini.  Bayangkan kita perlu mengubah baris menjadi "Modifikasi terakhir".  Meskipun kita bisa melakukan ini, tidak jelas apa yang harus terjadi jika tanggal tidak ada.  Akan lebih baik jika kita menulis komponen sedemikian rupa untuk membuat perilakunya lebih dimengerti. </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LastModified</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">props</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!props.date) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-string"><span class="hljs-string">"LastModified requires a date to be passed"</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ( <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> Last modified on { props.date.toLocaleDateString() } </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span> ); }</code> </pre> <br><p>  Atau bahkan seperti ini: </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LastModified</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">props</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (props.date) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ( <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> Last modified on { props.date.toLocaleDateString() } </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span> ); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">Never modified</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span>; } }</code> </pre> <br><p>  Dalam kedua kasus, perilaku lebih mudah dimengerti, dan niat programmer tidak penting.  Misalkan kita memilih alternatif kedua (yang menangani nilai tanggal yang hilang).  Ketika kita diminta untuk mengubah pesan, kita dapat melihat perilaku dan memeriksa apakah pesan "Tidak pernah dimodifikasi" benar atau apakah itu juga perlu diubah. </p><br><p>  Dengan demikian, semakin tidak ambigu <em>perilakunya</em> , semakin besar peluang kita untuk berhasil mengubahnya.  Dan ini berarti bahwa kita mungkin perlu menulis lebih banyak kode atau membuatnya lebih akurat, atau bahkan kadang-kadang menulis kode duplikat. </p><br><p>  Ini juga berarti bahwa kita akan membutuhkan lebih banyak kelas, fungsi, metode, dll. Tentu saja, <em>kita ingin</em> menjaga jumlah mereka minimal, tetapi kita tidak boleh menggunakan angka ini sebagai metrik kita.  Membuat sejumlah besar kelas atau metode menciptakan <em>overhead konseptual</em> , dan lebih banyak konsep muncul dalam perangkat lunak daripada unit modularitas.  Oleh karena itu, kita perlu mengurangi jumlah konsep, yang, pada gilirannya, dapat menyebabkan penurunan jumlah kelas. </p><br><h1 id="konceptualnye-rashody-sposobstvuyut-zaputannosti-i-uslozhneniyu">  Biaya konseptual berkontribusi pada kebingungan dan kompleksitas </h1><br><p>  Untuk memahami apa yang sebenarnya akan dilakukan kode, Anda perlu mengetahui tidak hanya bidang subjek, tetapi juga semua konsep yang digunakan dalam kode ini (misalnya, saat mencari standar deviasi, Anda harus mengetahui tugas, penambahan, perkalian, untuk panjang loop dan panjang array).  Ini menjelaskan mengapa ketika jumlah konsep dalam desain meningkat, kompleksitasnya untuk pemahaman meningkat. </p><br><p>  Saya <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">biasa</a> menulis tentang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pengeluaran konseptual</a> , dan efek samping yang baik dari mengurangi jumlah konsep dalam suatu sistem adalah bahwa lebih banyak orang dapat memahami sistem ini.  Ini pada gilirannya meningkatkan jumlah orang yang dapat membuat perubahan pada sistem ini.  Jelas, desain perangkat lunak yang dapat diubah dengan aman oleh banyak orang lebih baik daripada yang hanya dapat diubah oleh segelintir orang.  (Oleh karena itu, saya percaya bahwa pemrograman fungsional hardcore tidak akan pernah menjadi populer, karena memerlukan pemahaman yang mendalam tentang banyak konsep yang sangat abstrak.) </p><br><p>  Mengurangi biaya konseptual secara alami akan mengurangi jumlah abstraksi <em>dan</em> membuat perilaku lebih mudah dipahami.  Saya tidak mengatakan "tidak pernah memperkenalkan konsep baru", saya mengatakan bahwa itu memiliki harga sendiri, dan jika harga ini lebih besar daripada manfaatnya, pengenalan konsep baru harus dipertimbangkan dengan cermat. </p><br><p>  Ketika kita menulis kode atau mendesain perangkat lunak, kita harus berhenti memikirkan <em>keanggunan</em> , <em>keindahan,</em> atau ukuran subjektif lainnya dari kode kita.  Sebaliknya, kita harus selalu ingat apa yang akan kita lakukan dengan perangkat lunak. </p><br><h1 id="vy-ne-veshaete-kod-na-stenu---vy-menyaete-ego">  Anda tidak menggantung kode di dinding - Anda mengubahnya </h1><br><p>  Kode bukanlah karya seni yang dapat Anda cetak dan gantung di museum.  Kode sedang dieksekusi.  Ini dipelajari dan didebug.  Dan, yang paling penting, itu <em>berubah</em> .  Dan seringkali.  Setiap desain yang sulit untuk dikerjakan harus dipertanyakan dan ditinjau.  Setiap desain yang mengurangi jumlah orang yang dapat bekerja dengannya <em>juga</em> harus dipertanyakan. </p><br><p>  Kode harus bekerja, jadi harus diuji.  Kode memiliki bug dan akan membutuhkan penambahan fitur baru, jadi kita perlu memahami perilakunya.  Kode ini hidup lebih lama dari kemampuan programmer tertentu untuk mendukungnya, jadi kita harus mengusahakan kode yang dapat dimengerti oleh banyak orang. </p><br><p>  Ketika Anda menulis kode atau mendesain sistem Anda, apakah Anda menyederhanakan penjelasan perilaku sistem?  Apakah menjadi lebih mudah untuk memahami bagaimana dia akan berperilaku?  Apakah Anda fokus untuk menyelesaikan masalah tepat di depan Anda atau pada masalah yang lebih abstrak? </p><br><p>  Selalu berusaha untuk menjaga perilaku sederhana untuk demonstrasi, prediksi dan pemahaman, dan menjaga jumlah konsep seminimal mungkin. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id461823/">https://habr.com/ru/post/id461823/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id461813/index.html">Berita dari dunia OpenStreetMap No. 470 (07.16.2019 - 07.22.2019)</a></li>
<li><a href="../id461815/index.html">Sebuah revolusi dalam desain pasokan daya komputer setengah abad yang lalu</a></li>
<li><a href="../id461817/index.html">CMake dan C ++ - saudara selamanya</a></li>
<li><a href="../id461819/index.html">Mengapa desain situs web sederhana lebih baik secara ilmiah</a></li>
<li><a href="../id461821/index.html">Imunoterapi baru menghilangkan semua tumor pada wanita dengan kanker payudara metastatik</a></li>
<li><a href="../id461827/index.html">Pengembangan Aplikasi PHP / Go Hibrid Menggunakan RoadRunner</a></li>
<li><a href="../id461829/index.html">TCP vs UDP atau masa depan protokol jaringan</a></li>
<li><a href="../id461831/index.html">StealthWatch: Penempatan dan Kustomisasi. Bagian 2</a></li>
<li><a href="../id461833/index.html">Jangan tersesat dalam tiga pinus: representasi lingkungan yang egosentris</a></li>
<li><a href="../id461835/index.html">Bagaimana Gantt Charts Menyederhanakan dan Memberdayakan Manajemen Proyek</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>