<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🏉 🌾 👨🏼‍🚀 5 Fortgeschrittene Go-Testtechniken 🖕🏿 🧗🏻 👩🏼‍✈️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Gruß an alle! Bis zum Beginn des Kurses „Golang Developer“ verbleibt weniger als eine Woche, und wir teilen weiterhin nützliches Material zu diesem Th...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>5 Fortgeschrittene Go-Testtechniken</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/otus/blog/452772/"> Gruß an alle!  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Bis</a> zum Beginn des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Kurses „Golang Developer“ verbleibt</a> weniger als eine Woche, und wir teilen weiterhin nützliches Material zu diesem Thema.  Lass uns gehen! <br><br><img src="https://habrastorage.org/webt/mi/ly/nj/milynjiemmrcxgeldshfcz383pa.png"><br><br>  Go verfügt über eine gute und zuverlässige integrierte Bibliothek zum Testen.  Wenn Sie auf Go schreiben, wissen Sie das bereits.  In diesem Artikel werden wir über verschiedene Strategien sprechen, mit denen Sie Ihre Testfähigkeiten mit Go verbessern können.  Durch die Erfahrung mit dem Schreiben unserer beeindruckenden Codebasis auf Go haben wir gelernt, dass diese Strategien wirklich funktionieren und somit Zeit und Mühe bei der Arbeit mit dem Code sparen. <a name="habracut"></a><br><br>  <b>Verwenden Sie Testsuiten</b> <br><br>  Wenn Sie aus diesem Artikel nur eine nützliche Sache für sich selbst lernen, muss es sich um die Verwendung von Testsuiten handeln.  Für diejenigen, die mit diesem Konzept nicht vertraut sind, ist das Testen mit Kits der Prozess der Entwicklung eines Tests zum Testen einer gemeinsamen Schnittstelle, die für viele Implementierungen dieser Schnittstelle verwendet werden kann.  Unten sehen Sie, wie wir verschiedene <code>Thinger</code> Implementierungen bestehen und mit denselben Tests ausführen. <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Thinger <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> { DoThing(input <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>) (Result, error) } <span class="hljs-comment"><span class="hljs-comment">// Suite tests all the functionality that Thingers should implement func Suite(t *testing.T, impl Thinger) { res, _ := impl.DoThing("thing") if res != expected { t.Fail("unexpected result") } } // TestOne tests the first implementation of Thinger func TestOne(t *testing.T) { one := one.NewOne() Suite(t, one) } // TestOne tests another implementation of Thinger func TestTwo(t *testing.T) { two := two.NewTwo() Suite(t, two) }</span></span></code> </pre><br>  Glückliche Leser haben mit Codebasen gearbeitet, die diese Methode verwenden.  Häufig in Plugin-basierten Systemtests verwendet, die zum Testen einer Schnittstelle geschrieben wurden, können alle Implementierungen dieser Schnittstelle verwendet werden, um zu verstehen, wie sie die Verhaltensanforderungen erfüllen. <br><br>  Die Verwendung dieses Ansatzes kann möglicherweise dazu beitragen, Stunden, Tage und sogar genug Zeit zu sparen, um das Problem der Gleichheit der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Klassen P und NP</a> zu lösen.  Wenn Sie ein Basissystem durch ein anderes ersetzen, müssen Sie nicht mehr (eine große Anzahl) zusätzlicher Tests schreiben, und es besteht auch die Gewissheit, dass dieser Ansatz den Betrieb Ihrer Anwendung nicht stört.  Implizit müssen Sie eine Schnittstelle erstellen, die den Bereich des getesteten Bereichs definiert.  Mithilfe der Abhängigkeitsinjektion können Sie einen Satz aus einem Paket anpassen, das an die Implementierung des gesamten Pakets übergeben wird. <br><br>  Ein vollständiges Beispiel finden Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> .  Trotz der Tatsache, dass dieses Beispiel weit hergeholt ist, kann man sich vorstellen, dass eine Datenbank remote und die andere im Speicher ist. <br><br>  Ein weiteres cooles Beispiel für diese Technik befindet sich in der Standardbibliothek im Paket <code>golang.org/x/net/nettest</code> .  Es bietet eine Möglichkeit zu überprüfen, ob net.Conn die Schnittstelle erfüllt. <br><br>  <b>Kontamination der Schnittstelle vermeiden</b> <br><br>  Sie können nicht über das Testen in Go sprechen, aber nicht über Schnittstellen. <br><br>  Schnittstellen sind im Zusammenhang mit Tests wichtig, da sie das leistungsstärkste Werkzeug in unserem Testarsenal sind. Sie müssen sie daher korrekt verwenden. <br><br>  Pakete exportieren häufig Schnittstellen an Entwickler, und dies führt dazu, dass: <br><br>  A) Entwickler erstellen ihr eigenes Modell, um das Paket zu implementieren. <br>  B) Das Paket exportiert sein eigenes Modell. <br><br><blockquote>  <i>"Je größer die Schnittstelle, desto schwächer die Abstraktion"</i> <i><br></i>  <i>- Rob Pike, Sprüche von Go</i> </blockquote><br>  Schnittstellen müssen vor dem Export sorgfältig geprüft werden.  Es ist oft verlockend, Schnittstellen zu exportieren, um Benutzern die Möglichkeit zu geben, das von ihnen benötigte Verhalten zu simulieren.  Dokumentieren Sie stattdessen, welche Schnittstellen zu Ihren Strukturen passen, um keine enge Beziehung zwischen dem Verbraucherpaket und Ihrem eigenen herzustellen.  Ein gutes Beispiel dafür ist das <i><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Fehlerpaket</a></i> . <br><br>  Wenn wir eine Schnittstelle haben, die wir nicht exportieren möchten, können wir den <i><a href="">internen Teilbaum / Paket-Teilbaum verwenden</a></i> , um sie im Paket zu speichern.  Wir können daher nicht befürchten, dass der Endbenutzer von ihm abhängig ist, und können daher die Benutzeroberfläche flexibel an neue Anforderungen anpassen.  Normalerweise erstellen wir Schnittstellen mit externen Abhängigkeiten, um Tests lokal ausführen zu können. <br><br>  Dieser Ansatz ermöglicht es dem Benutzer, seine eigenen kleinen Schnittstellen zu implementieren, indem er einfach einen Teil der Bibliothek zum Testen umschließt.  Weitere Informationen zu diesem Konzept finden Sie im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Rakyl-Artikel zur Grenzflächenverschmutzung</a> . <br><br>  <b>Exportieren Sie keine Parallelitätsprimitive</b> <br><br>  Go bietet benutzerfreundliche Parallelitätsprimitive, die aufgrund der gleichen Einfachheit manchmal auch zu einer Überbeanspruchung führen können.  Zunächst sind wir besorgt über die Kanäle und das Synchronisierungspaket.  Manchmal ist es verlockend, einen Kanal aus Ihrem Paket zu exportieren, damit andere ihn verwenden können.  Außerdem besteht ein häufiger Fehler darin, <code>sync.Mutex</code> einzubetten, ohne es auf privat zu setzen.  Dies ist wie üblich nicht immer schlecht, führt jedoch beim Testen Ihres Programms zu bestimmten Problemen. <br><br>  Wenn Sie Kanäle exportieren, verkomplizieren Sie zusätzlich das Leben des Paketbenutzers, was sich nicht lohnt.  Sobald der Kanal aus dem Paket exportiert wird, treten beim Testen desjenigen, der diesen Kanal verwendet, Schwierigkeiten auf.  Für erfolgreiche Tests muss der Benutzer Folgendes wissen: <br><br><ul><li>  Wenn Daten über den Kanal gesendet werden. </li><li>  Gab es Fehler beim Empfang von Daten? </li><li>  Wie spült ein Paket den Kanal nach Abschluss, wenn überhaupt? </li><li>  Wie verpacke ich eine Paket-API, damit Sie sie nicht direkt aufrufen? </li></ul><br>  Schauen Sie sich das Beispiel zum Lesen der Warteschlange an.  Hier ist eine Beispielbibliothek, die aus der Warteschlange liest und dem Benutzer einen Feed zum Lesen bereitstellt. <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Reader <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> {...} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(r *Reader)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ReadChan</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> &lt;-</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">chan</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Msg</span></span></span></span> {...}</code> </pre> <br>  Jetzt möchte Ihr Bibliotheksbenutzer einen Test für seinen Verbraucher implementieren: <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TestConsumer</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(t testing.T)</span></span></span></span> { cons := &amp;Consumer{ r: libqueue.NewReader(), } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> msg := <span class="hljs-keyword"><span class="hljs-keyword">range</span></span> cons.r.ReadChan() { <span class="hljs-comment"><span class="hljs-comment">// Test thing. } }</span></span></code> </pre> <br><br>  Der Benutzer kann dann entscheiden, dass die Abhängigkeitsinjektion eine gute Idee ist, und seine eigenen Nachrichten in den Kanal schreiben: <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TestConsumer</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(t testing.T, q queueIface)</span></span></span></span> { cons := &amp;Consumer{ r: q, } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> msg := <span class="hljs-keyword"><span class="hljs-keyword">range</span></span> cons.r.ReadChan() { <span class="hljs-comment"><span class="hljs-comment">// Test thing. } }</span></span></code> </pre> <br><br>  Warten Sie, was ist mit den Fehlern? <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TestConsumer</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(t testing.T, q queueIface)</span></span></span></span> { cons := &amp;Consumer{ r: q, } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> msg := &lt;-cons.r.ReadChan(): <span class="hljs-comment"><span class="hljs-comment">// Test thing. case err := &lt;-cons.r.ErrChan(): // What caused this again? } } }</span></span></code> </pre> <br><br>  Jetzt müssen wir irgendwie Ereignisse generieren, um tatsächlich in diesen Stub zu schreiben, der das Verhalten der von uns verwendeten Bibliothek repliziert.  Wenn die Bibliothek gerade die synchrone API geschrieben hat, können wir dem Client-Code die gesamte Parallelität hinzufügen, sodass das Testen einfacher wird. <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TestConsumer</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(t testing.T, q queueIface)</span></span></span></span> { cons := &amp;Consumer{ r: q, } msg, err := cons.r.ReadMsg() <span class="hljs-comment"><span class="hljs-comment">// handle err, test thing }</span></span></code> </pre><br><br>  Wenn Sie Zweifel haben, denken Sie daran, dass es immer einfach ist, dem Verbraucherpaket (Verbrauchspaket) Parallelität hinzuzufügen, und es nach dem Export aus der Bibliothek schwierig oder unmöglich ist, es zu entfernen.  Und vor allem vergessen Sie nicht, in die Paketdokumentation zu schreiben, ob die Struktur / das Paket für den gleichzeitigen Zugriff auf mehrere Goroutinen sicher ist. <br>  Manchmal ist es immer noch wünschenswert oder notwendig, den Kanal zu exportieren.  Um einige der oben genannten Probleme zu mindern, können Sie Kanäle über Accessoren anstelle des direkten Zugriffs bereitstellen und diese nur zum Lesen ( <code>←chan</code> ) oder nur zum Schreiben ( <code>chan←</code> ) offen lassen, wenn Sie deklarieren. <br><br>  <b>Verwenden Sie <code>net/http/httptest</code></b> <br><br>  <code>Httptest</code> können <code>Httptest</code> <code>http.Handler</code> Code ausführen, ohne einen Server zu starten oder an einen Port zu binden.  Dies beschleunigt das Testen und ermöglicht es Ihnen, Tests zu geringeren Kosten parallel durchzuführen. <br><br>  Hier ist ein Beispiel für denselben Test, der auf zwei Arten implementiert wurde.  Hier gibt es nichts Großartiges, aber dieser Ansatz reduziert die Codemenge und spart Ressourcen. <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TestServe</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(t *testing.T)</span></span></span></span> { <span class="hljs-comment"><span class="hljs-comment">// The method to use if you want to practice typing s := &amp;http.Server{ Handler: http.HandlerFunc(ServeHTTP), } // Pick port automatically for parallel tests and to avoid conflicts l, err := net.Listen("tcp", ":0") if err != nil { t.Fatal(err) } defer l.Close() go s.Serve(l) res, err := http.Get("http://" + l.Addr().String() + "/?sloths=arecool") if err != nil { log.Fatal(err) } greeting, err := ioutil.ReadAll(res.Body) res.Body.Close() if err != nil { log.Fatal(err) } fmt.Println(string(greeting)) } func TestServeMemory(t *testing.T) { // Less verbose and more flexible way req := httptest.NewRequest("GET", "http://example.com/?sloths=arecool", nil) w := httptest.NewRecorder() ServeHTTP(w, req) greeting, err := ioutil.ReadAll(w.Body) if err != nil { log.Fatal(err) } fmt.Println(string(greeting)) }</span></span></code> </pre> <br>  Das vielleicht wichtigste Merkmal ist, dass Sie mit <code>httptest</code> den Test nur in die Funktion <code>httptest</code> können, die Sie testen möchten.  Keine Router, Middleware oder andere Nebenwirkungen, die beim Einrichten von Servern, Diensten, Prozessorfabriken, Prozessorfabriken oder anderen Dingen auftreten, die Sie für eine gute Idee halten. <br><br>  Um dieses Prinzip in Aktion zu sehen, lesen Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">den Artikel</a> von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Marc Berger</a> . <br><br>  <b>Verwenden Sie das separate Paket <code>_test</code></b> <br><br>  Die meisten Tests im Ökosystem werden in den Dateien <code>pkg_test.go</code> , verbleiben jedoch im selben Paket: <code>package pkg</code> .  Ein separates <code>foo_test.go</code> ist das Paket, das Sie in der neuen Datei <code>foo_test.go</code> im Verzeichnis des zu <code>foo_test.go</code> Moduls <code>foo/</code> mit dem Deklarationspaket <code>package foo_test</code> .  Von hier aus können Sie <code>github.com/example/foo</code> und andere Abhängigkeiten importieren.  Mit dieser Funktion können Sie viele Dinge tun.  Dies ist die empfohlene Lösung für zyklische Abhängigkeiten in Tests. Sie verhindert das Auftreten von „spröden Tests“ und gibt dem Entwickler das Gefühl, wie es ist, ein eigenes Paket zu verwenden.  Wenn Ihr Paket schwer zu verwenden ist, ist das Testen mit dieser Methode ebenfalls schwierig. <br><br>  Diese Strategie verhindert fragile Tests, indem der Zugriff auf private Variablen eingeschränkt wird.  Insbesondere wenn Ihre Tests unterbrochen werden und Sie separate Testpakete verwenden, ist fast garantiert, dass ein Client, der eine Funktion verwendet, die die Tests unterbricht, auch beim Aufruf unterbrochen wird. <br><br>  Schließlich hilft es, Importzyklen in Tests zu vermeiden.  Die meisten Pakete hängen eher von anderen Paketen ab, die Sie neben den Testpaketen geschrieben haben. Daher kommt es zu einer Situation, in der der Importzyklus auf natürliche Weise erfolgt.  Ein externes Paket befindet sich über beiden Paketen in der Pakethierarchie.  Nehmen Sie ein Beispiel aus der Programmiersprache Go (Kapitel 11, Abschnitt 2.4), in dem <code>net/url</code> einen URL-Parser implementiert, den <code>net/http</code> zur Verwendung importiert.  <code>net / url</code> muss jedoch mit einem realen Anwendungsfall getestet werden, indem <code>net / http</code> importiert wird.  Somit stellt sich <code>net/url_test</code> . <br><br>  Wenn Sie jetzt ein separates Testpaket verwenden, benötigen Sie möglicherweise Zugriff auf nicht exportierte Entitäten in dem Paket, in dem sie zuvor verfügbar waren.  Einige Entwickler sind zum ersten Mal damit konfrontiert, wenn sie etwas basierend auf der Zeit testen (z. B. time.Now wird mithilfe einer Funktion zu einem Stub).  In diesem Fall können wir eine zusätzliche Datei verwenden, um Entitäten ausschließlich während des Testens bereitzustellen, da die <code>_test.go</code> Dateien von regulären Builds ausgeschlossen <code>_test.go</code> . <br><br>  <b>Woran müssen Sie sich erinnern?</b> <br><br>  Es ist wichtig zu bedenken, dass keine der oben beschriebenen Methoden ein Allheilmittel ist.  Der beste Ansatz in jedem Unternehmen besteht darin, die Situation kritisch zu analysieren und unabhängig die beste Lösung für das Problem auszuwählen. <br><br>  Möchten Sie mehr über das Testen mit Go erfahren? <br>  Lesen Sie diese Artikel: <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Dave Cheneys schreibtischgesteuerte Tests in Go</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Das Kapitel Go Programming Language zum Testen.</a> <br>  Oder schauen Sie sich diese Videos an: <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Hashimotos Advanced Testing With Go-Vortrag von Gophercon 2017</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Andrew Gerrands Testtechniken sprechen von 2014</a> <br><br>  Wir hoffen, diese Übersetzung hat Ihnen geholfen.  Wir warten auf Kommentare und alle, die mehr über den Kurs erfahren möchten, laden Sie zum <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Tag</a> der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">offenen Tür ein</a> , der am 23. Mai stattfinden wird. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de452772/">https://habr.com/ru/post/de452772/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de452760/index.html">Vitamin D. Trinken oder nicht trinken, das ist die Frage. (Oder eine Geschichte darüber, wie ich eine Analyse bestanden habe, die mir nicht verschrieben wurde)</a></li>
<li><a href="../de452762/index.html">MVCC-7. Automatische Reinigung</a></li>
<li><a href="../de452764/index.html">[Peter] Treffen von JUG.ru mit Sergei Melnikov - Profiling mit superluminaler Geschwindigkeit: Theorie und Praxis</a></li>
<li><a href="../de452766/index.html">Progressive Streaming-Technologie oder das Ansehen von 4k-Videos über das Netzwerk ohne Friese</a></li>
<li><a href="../de452768/index.html">So gestalten Sie ein Produkt, wenn Sie sich für den Eintritt in den ausländischen Markt entscheiden</a></li>
<li><a href="../de452774/index.html">Dell XPS 13 9380: zuverlässiger und sehr kompakter Laptop für ernsthafte Geschäfte</a></li>
<li><a href="../de452776/index.html">N.M.D. (Nicht mein Geschäft)</a></li>
<li><a href="../de452778/index.html">So beschleunigen Sie das Entladen von LZ4 in ClickHouse</a></li>
<li><a href="../de452780/index.html">Mobius 2019 Piter: Kostenloses Live-Streaming und alles andere</a></li>
<li><a href="../de452788/index.html">Der Kampf um Qualität in Webanwendungen, Depressionen, Drachen und Westeros</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>