<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üö© üë©üèø‚Äçüîß üë®üèø‚Äçüç≥ Numerische Methoden zur L√∂sung nichtlinearer Gleichungssysteme üêÑ üë©üèø‚Äçüíº üïå</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Einf√ºhrung 
 Viele angewandte Probleme f√ºhren dazu, dass eine allgemeine L√∂sung f√ºr ein System nichtlinearer Gleichungen gefunden werden muss. Es wurd...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Numerische Methoden zur L√∂sung nichtlinearer Gleichungssysteme</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/419453/"><h3>  Einf√ºhrung </h3><br>  Viele angewandte Probleme f√ºhren dazu, dass eine allgemeine L√∂sung f√ºr ein System nichtlinearer Gleichungen gefunden werden muss.  Es wurde keine allgemeine analytische L√∂sung des Systems nichtlinearer Gleichungen gefunden.  Es gibt nur numerische Methoden. <br><br>  Es sollte eine interessante Tatsache beachtet werden, dass jedes Gleichungssystem √ºber reelle Zahlen durch eine √§quivalente Gleichung dargestellt werden kann, wenn wir alle Gleichungen in der Form nehmen <img src="https://habrastorage.org/webt/_q/09/hw/_q09hw6d1qeqerbgr7qhzfdcdfy.png">  , quadriere sie und falte sie. <br><br>  F√ºr die numerische L√∂sung werden iterative Methoden aufeinanderfolgender Approximationen (einfache Iteration) und die Newtonsche Methode in verschiedenen Modifikationen verwendet.  Iterative Prozesse werden nat√ºrlich auf den Fall eines Systems nichtlinearer Gleichungen der Form verallgemeinert: <br><br><img src="https://habrastorage.org/webt/zf/ut/do/zfutdol9bhx0jy5lbge4jnfdjyk.png">  (1) <br><br>  Bezeichnen mit <img src="https://habrastorage.org/webt/4b/fu/a_/4bfua_k_3kyr5w5cfxvmgxeat_y.png">  Vektor von Unbekannten und definieren Sie eine Vektorfunktion <img src="https://habrastorage.org/webt/im/cc/m2/imccm2nlbj0rocyhlqidmboiwps.png">  Dann wird System (1) in Form der Gleichung geschrieben: <br><br><img src="https://habrastorage.org/webt/5q/py/ph/5qpyphhrxupuofyzbeoxk8jviti.png">  (2) <br><br>  Kehren wir nun zu unserem geliebten Python zur√ºck und stellen dessen Vorrang unter den Programmiersprachen fest, die lernen m√∂chten [1]. <br><br><img src="https://habrastorage.org/webt/bx/x7/vz/bxx7vzxbfwqa-iaa5buw36pvvim.png"><br><br>  Diese Tatsache ist ein zus√§tzlicher Anreiz, numerische Methoden in Python in Betracht zu ziehen.  Python-Liebhaber sind jedoch der Meinung, dass spezielle Bibliotheksfunktionen wie <b>scipy.optimize.root, spsolve_trianular und newton_krylov</b> die beste Wahl sind, um Probleme mit numerischen Methoden zu l√∂sen. <br><br>  Es ist schwer, dem zu widersprechen, schon allein deshalb, weil die Vielfalt der Module Python zu einem H√∂hepunkt der Popularit√§t gemacht hat.  Es gibt jedoch F√§lle, in denen auch bei einer fl√ºchtigen Pr√ºfung die Verwendung direkt bekannter Methoden ohne Verwendung spezieller Funktionen der SciPy-Bibliothek ebenfalls gute Ergebnisse liefert.  Mit anderen Worten, das Neue ist das gut vergessene Alte. <br><a name="habracut"></a><br>  In der Ver√∂ffentlichung [2] wurde anhand von Computerexperimenten nachgewiesen, dass die Bibliotheksfunktion newton_krylov, die zur L√∂sung gro√üer nichtlinearer Gleichungssysteme entwickelt wurde, halb so schnell ist wie der TSLS + WD-Algorithmus <br>  (zweistufige kleinste Quadrate), implementiert von der NumPy-Bibliothek. <br><br>  <b>Der Zweck dieser Ver√∂ffentlichung</b> ist es, die Anzahl der Iterationen, die Geschwindigkeit und vor allem das Ergebnis der L√∂sung eines Modellproblems in Form eines Systems von einhundert nichtlinearen algebraischen Gleichungen mit der Bibliotheksfunktion scipy.optimize.root und der mit der NumPy-Bibliothek implementierten Newton-Methode zu vergleichen. <br><br><h3>  Scipy.optimize.root-Solver-Funktionen zum numerischen L√∂sen von Systemen algebraischer nichtlinearer Gleichungen </h3><br>  Die Bibliotheksfunktion scipy.optimize.root wurde als Vergleichsbasis gew√§hlt, da sie √ºber eine umfangreiche Bibliothek von Methoden verf√ºgt, die f√ºr die vergleichende Analyse geeignet sind. <br><br>  <b>scipy.optimize.root</b> ( <i>fun, x0, args = (), method = 'hybr', jac = None, tol = None, callback = None, ptions = None</i> ) <br>  <i>fun</i> - Eine Vektorfunktion zum Finden der Wurzel. <br>  <i>x0 -</i> Anfangsbedingungen f√ºr das Finden von Wurzeln <br><br>  <b>Methode:</b> <br>  <i>Es wird eine Hybr-</i> Powell-Modifikation der Hybridmethode verwendet. <br>  <i>lm</i> - l√∂st nichtlineare Gleichungssysteme mit der Methode der kleinsten Quadrate. <br>  Wie aus der Dokumentation [3] hervorgeht, sind die Methoden <b>broyden1, broyden2, anderson, lineares Mischen, Diagbroyden, aufregendes Mischen, Krylov</b> die genauen Newtonschen Methoden.  Die √ºbrigen Parameter sind ‚Äûoptional‚Äú und finden Sie in der Dokumentation. <br><br><h3>  Methoden zur L√∂sung nichtlinearer Gleichungssysteme </h3><br>  Das unten angegebene Material kann zwar in der Literatur gelesen werden, zum Beispiel in [4], aber ich respektiere meinen Leser und pr√§sentiere die Ableitung der Methode, wenn m√∂glich, wenn m√∂glich in gek√ºrzter Form.  Diejenigen, <b>die keine Formeln m√∂gen,</b> √ºberspringen diesen Abschnitt. <br><br>  Bei der Newtonschen Methode wird aus der L√∂sung <b>des linearen Gleichungssystems</b> eine neue N√§herung zur L√∂sung des Gleichungssystems (2) ermittelt: <br><br><img src="https://habrastorage.org/webt/oc/q3/_y/ocq3_yonljteqeoun-ep0euxsai.png">  (3) <br><br>  Definieren Sie die Jacobi-Matrix: <br><br><img src="https://habrastorage.org/webt/iu/60/s-/iu60s-ro-taedqwb3fltgypmspu.png">  (4) <br><br>  Wir schreiben (3) in der Form: <br><br><img src="https://habrastorage.org/webt/gj/be/vm/gjbevmxcuhihbxakq57qfxsok6w.png">  (5) <br><br>  Viele Ein-Schritt-Methoden zur ungef√§hren L√∂sung von (2) in Analogie zu zweischichtigen iterativen Methoden zur L√∂sung von Systemen linearer algebraischer Gleichungen k√∂nnen in folgender Form geschrieben werden: <br><br><img src="https://habrastorage.org/webt/sl/fu/fq/slfufq8wc4qnfmmeclx64qpubjw.png">  (6) <br><br>  wo <img src="https://habrastorage.org/webt/pa/t0/0a/pat00a2ixfo34e_vfqtlgf_gchg.png">  Sind iterative Parameter, a <img src="https://habrastorage.org/webt/ta/xt/2z/taxt2zyydbeigde-xcqhry0wrtq.png">  - eine quadratische Matrix n x n mit der Umkehrung. <br><br>  Bei Verwendung des Datensatzes (6) entspricht Newtons Methode (5) der Auswahl: <br><br><img src="https://habrastorage.org/webt/n5/ii/zu/n5iizujlep0bnryijprpz8-bary.png"><br><br>  Das System der linearen Gleichungen (5) zum Finden einer neuen N√§herung <img src="https://habrastorage.org/webt/so/88/h5/so88h5-fmrzbs-aplenlaar3oo4.png">  kann iterativ gel√∂st werden.  In diesem Fall haben wir einen zweistufigen iterativen Prozess mit externen und internen Iterationen.  Beispielsweise kann ein externer iterativer Prozess gem√§√ü der Newton-Methode ausgef√ºhrt werden, und interne Iterationen k√∂nnen auf der <b>Basis der iterativen Seidel-Methode ausgef√ºhrt werden.</b> <br><br>  Beim L√∂sen nichtlinearer Gleichungssysteme k√∂nnen direkte Analoga von iterativen Standardmethoden verwendet werden, die zum L√∂sen linearer Gleichungssysteme verwendet werden.  Die nichtlineare Seidel-Methode, wie sie auf L√∂sung (2) angewendet wird, ergibt: <br><br><img src="https://habrastorage.org/webt/hx/lf/wk/hxlfwknytaf-n4yc3njkqjjx6lo.png">  (7) <br><br>  In diesem Fall kann jede Komponente der neuen N√§herung aus der L√∂sung der nichtlinearen Gleichung auf der Basis der einfachen Iterationsmethode und der Newtonschen Methode in verschiedenen Modifikationen erhalten werden.  Wir kommen also wieder zu einer zweistufigen iterativen Methode, bei der externe Iterationen gem√§√ü der Seidel-Methode und interne Iterationen mit der Newton-Methode durchgef√ºhrt werden. <br><br>  Die Hauptberechnungsschwierigkeiten bei der Anwendung der Newton-Methode f√ºr die ungef√§hre L√∂sung nichtlinearer Gleichungssysteme <b>h√§ngen mit der Notwendigkeit zusammen, bei jeder Iteration ein lineares Gleichungssystem mit einer Jacobi-Matrix zu l√∂sen</b> , und diese Matrix √§ndert sich von Iteration zu Iteration.  Bei der modifizierten Newton-Methode wird die Jacobi-Matrix nur einmal invertiert: <br><br><img src="https://habrastorage.org/webt/y-/0p/tv/y-0ptvinni3bzhzirltojgjxkxc.png">  (8) <br><br><h3>  Auswahl der Modellfunktion </h3><br>  Eine solche Wahl ist keine einfache Aufgabe, da sich mit einer Zunahme der Anzahl von Gleichungen im System entsprechend einer Zunahme der Anzahl von Variablen das Ergebnis der L√∂sung nicht √§ndern sollte, da es sonst unm√∂glich ist, die Richtigkeit der L√∂sung des Gleichungssystems beim Vergleich zweier Methoden zu verfolgen.  Ich bringe die folgende L√∂sung f√ºr die Modellfunktion: <br><br><pre><code class="python hljs">n=<span class="hljs-number"><span class="hljs-number">100</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x)</span></span></span><span class="hljs-function">:</span></span> f = zeros([n]) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> arange(<span class="hljs-number"><span class="hljs-number">0</span></span>,n<span class="hljs-number"><span class="hljs-number">-1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>): f[i] = (<span class="hljs-number"><span class="hljs-number">3</span></span> + <span class="hljs-number"><span class="hljs-number">2</span></span>*x[i])*x[i] - x[i<span class="hljs-number"><span class="hljs-number">-1</span></span>] - <span class="hljs-number"><span class="hljs-number">2</span></span>*x[i+<span class="hljs-number"><span class="hljs-number">1</span></span>] - <span class="hljs-number"><span class="hljs-number">2</span></span> f [<span class="hljs-number"><span class="hljs-number">0</span></span>] = (<span class="hljs-number"><span class="hljs-number">3</span></span> + <span class="hljs-number"><span class="hljs-number">2</span></span>*x[<span class="hljs-number"><span class="hljs-number">0</span></span>] )*x[<span class="hljs-number"><span class="hljs-number">0</span></span>] - <span class="hljs-number"><span class="hljs-number">2</span></span>*x[<span class="hljs-number"><span class="hljs-number">1</span></span>] - <span class="hljs-number"><span class="hljs-number">3</span></span> f[n<span class="hljs-number"><span class="hljs-number">-1</span></span>] = (<span class="hljs-number"><span class="hljs-number">3</span></span> + <span class="hljs-number"><span class="hljs-number">2</span></span>*x[n<span class="hljs-number"><span class="hljs-number">-1</span></span>] )*x[n<span class="hljs-number"><span class="hljs-number">-1</span></span>] - x[n<span class="hljs-number"><span class="hljs-number">-2</span></span>] - <span class="hljs-number"><span class="hljs-number">4</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> f</code> </pre> <br>  <b>Die Funktion f erzeugt ein System von n nichtlinearen Gleichungen, deren L√∂sung nicht von der Anzahl der Gleichungen abh√§ngt und f√ºr jede der n Variablen gleich Eins ist.</b> <br><br><h3>  Ein Programm zum Testen einer Modellfunktion mit den Ergebnissen der L√∂sung eines Systems algebraischer nichtlinearer Gleichungen unter Verwendung der Bibliotheksfunktion optimize.root f√ºr verschiedene Methoden zum Finden von Wurzeln </h3><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> numpy <span class="hljs-keyword"><span class="hljs-keyword">import</span></span>* <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> scipy <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> optimize <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> time ti = time.clock() n=<span class="hljs-number"><span class="hljs-number">100</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x)</span></span></span><span class="hljs-function">:</span></span> f = zeros([n]) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> arange(<span class="hljs-number"><span class="hljs-number">0</span></span>,n<span class="hljs-number"><span class="hljs-number">-1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>): f[i] = (<span class="hljs-number"><span class="hljs-number">3</span></span> + <span class="hljs-number"><span class="hljs-number">2</span></span>*x[i])*x[i] - x[i<span class="hljs-number"><span class="hljs-number">-1</span></span>] - <span class="hljs-number"><span class="hljs-number">2</span></span>*x[i+<span class="hljs-number"><span class="hljs-number">1</span></span>] - <span class="hljs-number"><span class="hljs-number">2</span></span> f [<span class="hljs-number"><span class="hljs-number">0</span></span>] = (<span class="hljs-number"><span class="hljs-number">3</span></span> + <span class="hljs-number"><span class="hljs-number">2</span></span>*x[<span class="hljs-number"><span class="hljs-number">0</span></span>] )*x[<span class="hljs-number"><span class="hljs-number">0</span></span>] - <span class="hljs-number"><span class="hljs-number">2</span></span>*x[<span class="hljs-number"><span class="hljs-number">1</span></span>] - <span class="hljs-number"><span class="hljs-number">3</span></span> f[n<span class="hljs-number"><span class="hljs-number">-1</span></span>] = (<span class="hljs-number"><span class="hljs-number">3</span></span> + <span class="hljs-number"><span class="hljs-number">2</span></span>*x[n<span class="hljs-number"><span class="hljs-number">-1</span></span>] )*x[n<span class="hljs-number"><span class="hljs-number">-1</span></span>] - x[n<span class="hljs-number"><span class="hljs-number">-2</span></span>] - <span class="hljs-number"><span class="hljs-number">4</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> f x0 =zeros([n]) sol = optimize.root(f,x0, method=<span class="hljs-string"><span class="hljs-string">'krylov'</span></span>) print(<span class="hljs-string"><span class="hljs-string">'Solution:\n'</span></span>, sol.x) print(<span class="hljs-string"><span class="hljs-string">'Krylov method iteration = '</span></span>,sol.nit) print(<span class="hljs-string"><span class="hljs-string">'Optimize root time'</span></span>, round(time.clock()-ti,<span class="hljs-number"><span class="hljs-number">3</span></span>), <span class="hljs-string"><span class="hljs-string">'seconds'</span></span>)</code> </pre> <br>  Nur eine der in der Dokumentation [3] angegebenen Methoden hat die <b>Pr√ºfung des Ergebnisses der L√∂sung einer Modellfunktion bestanden. Dies ist die 'krylov'-Methode</b> . <br><br>  L√∂sung f√ºr n = 100: <br><br>  L√∂sung: <br>  [1.  1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. <br>  1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. <br>  1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. <br>  1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. <br>  1. 1. 1. 1.] <br>  Iteration der Krylov-Methode = 4219 <br>  Optimieren Sie die Root-Zeit auf 7,239 Sekunden: <br><br><div class="spoiler">  <b class="spoiler_title">L√∂sung f√ºr n = 200</b> <div class="spoiler_text">  L√∂sung: <br>  [1.00000018 0.99999972 0.99999985 1.00000001 0.99999992 1.00000049 <br>  0,99999998 0,99999992 0,99999991 1,00000001 1,00000013 1,00000002 <br>  0,9999997 0,99999987 1,00000005 0,99999978 1,0000002 1,00000012 <br>  1.00000023 1.00000017 0.99999979 1.00000012 1.00000026 0.99999987 <br>  1.00000014 0.99999979 0.99999988 1.00000046 1.00000064 1.00000007 <br>  1.00000049 1.00000005 1.00000032 1.00000031 1.00000028 0.99999992 <br>  1.0000003 1.0000001 0.99999971 1.00000023 1.00000039 1.0000003 <br>  1.00000013 0.9999999 0.99999993 0.99999996 1.00000008 1.00000016 <br>  1.00000034 1.00000004 0.99999993 0.99999987 0.99999969 0.99999985 <br>  0,99999981 1,00000051 1,0000004 1,00000035 0,9999998 1,00000065 <br>  1.00000061 1.0000006 1.0000006 1.0000006 1.0000006 1.0000006 <br>  1.0000006 1.0000006 1.0000006 1.0000006 1.0000006 1.0000006 <br>  1.0000006 1.0000006 1.0000006 1.0000006 1.0000006 1.0000006 <br>  1.0000006 1.0000006 1.0000006 1.0000006 1.0000006 1.0000006 <br>  1.0000006 1.0000006 1.0000006 1.0000006 1.0000006 1.0000006 <br>  1.0000006 1.0000006 1.0000006 1.0000006 1.0000006 1.0000006 <br>  1.0000006 1.0000006 1.0000006 1.0000006 1.0000006 1.0000006 <br>  1.0000006 1.0000006 1.0000006 1.0000006 1.0000006 1.0000006 <br>  1.0000006 1.0000006 1.0000006 1.0000006 1.0000006 1.0000006 <br>  1.0000006 1.0000006 1.0000006 1.0000006 1.0000006 1.0000006 <br>  1.0000006 1.0000006 1.0000006 1.0000006 1.00000059 1.00000056 <br>  1.00000047 1.00000016 1.00000018 0.99999988 1.00000061 1.00000002 <br>  1.00000033 1.00000034 1.0000004 1.00000046 1.00000009 1.00000024 <br>  1.00000017 1.00000014 1.00000054 1.00000006 0.99999964 0.99999968 <br>  1.00000005 1.00000049 1.0000005 1.00000028 1.00000029 1.00000027 <br>  1.00000027 0.9999998 1.00000005 0.99999974 0.99999978 0.99999988 <br>  1.00000015 1.00000007 1.00000005 0.99999973 1.00000006 0.99999995 <br>  1.00000021 1.00000031 1.00000058 1.00000023 1.00000023 1.00000044 <br>  0,99999985 0,99999948 0,99999977 0,99999991 0,99999974 0,99999978 <br>  0,99999983 1,0000002 1,00000016 1,00000008 1,00000013 1,00000007 <br>  0,99999989 0,99999959 1,00000029 1,0000003 0,99999972 1,00000003 <br>  0,99999967 0,99999977 1,00000017 1,00000005 1,00000029 1,00000034 <br>  0,99999997 0,99999989 0,99999945 0,99999985 0,99999994 0,99999972 <br>  1.00000029 1.00000016] <br>  Iteration der Krylov-Methode = 9178 <br>  Optimieren Sie die Root-Zeit 23.397 Sekunden <br></div></div><br>  <b>Schlussfolgerung:</b> Bei einer Erh√∂hung der Anzahl der Gleichungen um den Faktor zwei macht sich das Auftreten von Fehlern in der L√∂sung bemerkbar.  Mit einem weiteren Anstieg von n wird die L√∂sung inakzeptabel, was aufgrund der automatischen Anpassung an den Schritt m√∂glich ist, der gleiche Grund f√ºr einen starken Leistungsabfall.  Aber das ist nur meine Vermutung. <br><br><h3>  Ein Programm zum Testen einer Modellfunktion mit den Ergebnissen der L√∂sung eines Systems algebraischer nichtlinearer Gleichungen unter Verwendung eines in Python 3 geschriebenen Programms unter Ber√ºcksichtigung der Beziehungen (1) - (8), um die Wurzeln unter Verwendung der modifizierten Newton-Methode zu finden </h3><br><div class="spoiler">  <b class="spoiler_title">Das Programm zum Finden von Wurzeln nach der modifizierten Newton-Methode</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> numpy <span class="hljs-keyword"><span class="hljs-keyword">import</span></span>* <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> time ti = time.clock() <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">jacobian</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(f, x)</span></span></span><span class="hljs-function">:</span></span> h = <span class="hljs-number"><span class="hljs-number">1.0e-4</span></span> n = len(x) Jac = zeros([n,n]) f0 = f(x) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> arange(<span class="hljs-number"><span class="hljs-number">0</span></span>,n,<span class="hljs-number"><span class="hljs-number">1</span></span>): tt = x[i] x[i] = tt + h f1= f(x) x[i] = tt Jac [:,i] = (f1 - f0)/h <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Jac, f0 <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">newton</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(f, x, tol=</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">1.0e-9</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function">:</span></span> iterMax = <span class="hljs-number"><span class="hljs-number">50</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(iterMax): Jac, fO = jacobian(f, x) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> sqrt(dot(fO, fO) / len(x)) &lt; tol: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x, i dx = linalg.solve(Jac, fO) x = x - dx <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> (<span class="hljs-string"><span class="hljs-string">"Too many iterations for the Newton method"</span></span>) n=<span class="hljs-number"><span class="hljs-number">100</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x)</span></span></span><span class="hljs-function">:</span></span> f = zeros([n]) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> arange(<span class="hljs-number"><span class="hljs-number">0</span></span>,n<span class="hljs-number"><span class="hljs-number">-1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>): f[i] = (<span class="hljs-number"><span class="hljs-number">3</span></span> + <span class="hljs-number"><span class="hljs-number">2</span></span>*x[i])*x[i] - x[i<span class="hljs-number"><span class="hljs-number">-1</span></span>] - <span class="hljs-number"><span class="hljs-number">2</span></span>*x[i+<span class="hljs-number"><span class="hljs-number">1</span></span>] - <span class="hljs-number"><span class="hljs-number">2</span></span> f [<span class="hljs-number"><span class="hljs-number">0</span></span>] = (<span class="hljs-number"><span class="hljs-number">3</span></span> + <span class="hljs-number"><span class="hljs-number">2</span></span>*x[<span class="hljs-number"><span class="hljs-number">0</span></span>] )*x[<span class="hljs-number"><span class="hljs-number">0</span></span>] - <span class="hljs-number"><span class="hljs-number">2</span></span>*x[<span class="hljs-number"><span class="hljs-number">1</span></span>] - <span class="hljs-number"><span class="hljs-number">3</span></span> f[n<span class="hljs-number"><span class="hljs-number">-1</span></span>] = (<span class="hljs-number"><span class="hljs-number">3</span></span> + <span class="hljs-number"><span class="hljs-number">2</span></span>*x[n<span class="hljs-number"><span class="hljs-number">-1</span></span>] )*x[n<span class="hljs-number"><span class="hljs-number">-1</span></span>] - x[n<span class="hljs-number"><span class="hljs-number">-2</span></span>] - <span class="hljs-number"><span class="hljs-number">4</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> f x0 =zeros([n]) x, iter = newton(f, x0) <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> (<span class="hljs-string"><span class="hljs-string">'Solution:\n'</span></span>, x) <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> (<span class="hljs-string"><span class="hljs-string">'Newton iteration = '</span></span>, iter) print(<span class="hljs-string"><span class="hljs-string">'Newton method time'</span></span>, round(time.clock()-ti,<span class="hljs-number"><span class="hljs-number">3</span></span>), <span class="hljs-string"><span class="hljs-string">'seconds'</span></span>)</code> </pre> <br></div></div><br>  L√∂sung f√ºr n = 100: <br><br>  L√∂sung: <br>  [1.  1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. <br>  1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. <br>  1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. <br>  1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. <br>  1. 1. 1. 1.] <br>  Newton-Iteration = 13 <br>  Newton-Methodenzeit 0,496 Sekunden <br><br>  L√∂sung f√ºr n = 200: <br><br>  L√∂sung: <br>  [1.  1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. <br>  1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. <br>  1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. <br>  1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. <br>  1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. <br>  1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. <br>  1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. <br>  1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. <br>  1. 1. 1. 1. 1. 1. 1. 1. 1.] <br>  Newton-Iteration = 14 <br>  Newton-Methodenzeit 1,869 Sekunden <br><br>  Um sicherzustellen, dass das Programm das System wirklich l√∂st, schreiben wir die Modellfunktion zum Vermeiden der Wurzel mit dem Wert 1 in der folgenden Form neu: <br><br><pre> <code class="python hljs">n=<span class="hljs-number"><span class="hljs-number">10</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x)</span></span></span><span class="hljs-function">:</span></span> f = zeros([n]) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> arange(<span class="hljs-number"><span class="hljs-number">0</span></span>,n<span class="hljs-number"><span class="hljs-number">-1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>): f[i] = (<span class="hljs-number"><span class="hljs-number">3</span></span> + <span class="hljs-number"><span class="hljs-number">2</span></span>*x[i])*x[i]*sin([i]) - x[i<span class="hljs-number"><span class="hljs-number">-1</span></span>] - <span class="hljs-number"><span class="hljs-number">2</span></span>*x[i+<span class="hljs-number"><span class="hljs-number">1</span></span>] - <span class="hljs-number"><span class="hljs-number">2</span></span>+e**-x[i] f [<span class="hljs-number"><span class="hljs-number">0</span></span>] = (<span class="hljs-number"><span class="hljs-number">3</span></span> + <span class="hljs-number"><span class="hljs-number">2</span></span>*x[<span class="hljs-number"><span class="hljs-number">0</span></span>] )*x[<span class="hljs-number"><span class="hljs-number">0</span></span>] - <span class="hljs-number"><span class="hljs-number">2</span></span>*x[<span class="hljs-number"><span class="hljs-number">1</span></span>] - <span class="hljs-number"><span class="hljs-number">3</span></span> f[n<span class="hljs-number"><span class="hljs-number">-1</span></span>] = (<span class="hljs-number"><span class="hljs-number">3</span></span> + <span class="hljs-number"><span class="hljs-number">2</span></span>*x[n<span class="hljs-number"><span class="hljs-number">-1</span></span>] )*x[n<span class="hljs-number"><span class="hljs-number">-1</span></span>] - x[n<span class="hljs-number"><span class="hljs-number">-2</span></span>] - <span class="hljs-number"><span class="hljs-number">4</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> f</code> </pre> <br>  Wir bekommen: <br>  L√∂sung: <br>  [0.96472166 0.87777036 0.48175823 -0.26190496 -0.63693762 0.49232062 <br>  -1,31649896 0,6865098 0,89609091 0,98509235] <br>  Newton-Iteration = 16 <br>  Newton-Methodenzeit 0,046 Sekunden <br><br>  Fazit: <b>Das Programm funktioniert auch, wenn sich die Modellfunktion √§ndert.</b> <br><br>  Nun kehren wir zur urspr√ºnglichen Modellfunktion zur√ºck und √ºberpr√ºfen einen gr√∂√üeren Bereich f√ºr n, beispielsweise bei 2 und 500. <br>  n = 2 <br>  L√∂sung: <br>  [1.  1.] <br>  Newton-Iteration = 6 <br>  Newton-Methodenzeit 0,048 Sekunden <br>  n = 500 <br><div class="spoiler">  <b class="spoiler_title">n = 500</b> <div class="spoiler_text">  L√∂sung: <br>  [1.  1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. <br>  1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. <br>  1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. <br>  1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. <br>  1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. <br>  1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. <br>  1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. <br>  1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. <br>  1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. <br>  1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. <br>  1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. <br>  1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. <br>  1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. <br>  1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. <br>  1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. <br>  1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. <br>  1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. <br>  1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. <br>  1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. <br>  1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. <br>  1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.] <br>  Newton-Iteration = 15 <br>  Newton-Methodenzeit 11.754 Sekunden <br></div></div><br><h3>  Schlussfolgerungen: </h3><br>  Ein in Python unter Verwendung der modifizierten Newton-Methode geschriebenes Programm hat beim L√∂sen von nichtlinearen Gleichungssystemen aus der gegebenen Modellfunktion eine h√∂here L√∂sungsstabilit√§t als beim L√∂sen mit der Bibliotheksfunktion optimize.root (f, x0, method = 'krylov') f√ºr die Krylov-Methode.  In Bezug auf die Geschwindigkeit der endg√ºltigen Schlussfolgerung ist es aufgrund des unterschiedlichen Ansatzes zur Schrittsteuerung unm√∂glich zu zeichnen. <br><br>  Referenzen: <br><br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Bewertung der Programmiersprachen 2018.</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Cooper I.V., Faleychik B.V.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Nichtmatrix-iterative Prozesse mit Unterdr√ºckung des quadratischen mittleren Fehlers f√ºr gro√üe Systeme nichtlinearer Gleichungen.</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">scipy.optimize.root.</a> </li><li>  Vabishchevich P.N.  Numerische Methoden: Computerworkshop.  - M.: Buchhaus "LIBROCOM", 2010. - 320 p. </li></ol></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de419453/">https://habr.com/ru/post/de419453/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de419441/index.html">SpaceX verwendet heute erstmals die Rakete Falcon 9 Block 5</a></li>
<li><a href="../de419443/index.html">Die NASA wird wieder zum Mond fliegen und alle Elemente des Flugzeugs herstellen</a></li>
<li><a href="../de419445/index.html">Unit-Tests f√ºr Arduino-Projekte</a></li>
<li><a href="../de419449/index.html">Redux vs. React Context API</a></li>
<li><a href="../de419451/index.html">Erstellen Sie Schritt f√ºr Schritt ein Bundle f√ºr Symfony 4</a></li>
<li><a href="../de419457/index.html">RabbitMQ - SQL Server</a></li>
<li><a href="../de419459/index.html">Blei-S√§ure-Batterien: Pulsladungsalphabet</a></li>
<li><a href="../de419461/index.html">Waschrauml√ºftung</a></li>
<li><a href="../de419467/index.html">Von einer Gl√ºhbirne √ºber einen Staubsauger bis hin zu einer Drohne - wie wir Alice beigebracht haben, Hunderte von Ger√§ten zu verwalten</a></li>
<li><a href="../de419469/index.html">UE4 | Der Zyklus von Tag und Nacht √Ñnderung von SkySphere</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>