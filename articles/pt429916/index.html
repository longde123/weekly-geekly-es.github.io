<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üñ§ üë®‚Äç‚ù§Ô∏è‚Äçüë® üìì Como construir e construir üõï üòö üêÖ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Antecedentes 


 Tendo encontrado em v√°rios locais do desenvolvimento Javascript situa√ß√µes em que era necess√°rio validar valores, ficou claro que era ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Como construir e construir</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/429916/"><h2 id="predystoriya">  Antecedentes </h2><br><p>  Tendo encontrado em v√°rios locais do desenvolvimento Javascript situa√ß√µes em que era necess√°rio validar valores, ficou claro que era necess√°rio resolver de alguma forma esse problema.  Para esse fim, a seguinte tarefa foi definida: <br>  Desenvolva uma biblioteca que permita: </p><br><ul><li>  validar <strong>tipos de dados</strong> ; </li><li>  defina <strong>valores padr√£o em</strong> vez de campos ou elementos inv√°lidos; </li><li>  <strong>excluir partes inv√°lidas de um</strong> objeto ou matriz; </li><li>  Receba <strong>uma mensagem de erro</strong> </li></ul><br><p>  A base ser√°: </p><br><ul><li>  F√°cil de aprender </li><li>  Legibilidade do c√≥digo recebido. </li><li>  Facilidade de modifica√ß√£o de c√≥digo </li></ul><br><p>  Para atingir esses objetivos, uma biblioteca de valida√ß√£o de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" title="quarteto">quarteto</a> foi desenvolvida. </p><a name="habracut"></a><br><h2 id="osnovnye-kirpichi-validacii">  Tijolos de valida√ß√£o b√°sica </h2><br><p>  No cora√ß√£o da maioria dos sistemas projetados para serem aplic√°veis ‚Äã‚Äãa uma ampla gama de tarefas est√£o os <strong>elementos</strong> mais simples: a√ß√µes, dados e algoritmos.  Bem como m√©todos de <strong>composi√ß√£o</strong> - para montar algo mais complicado a partir de elementos simples para resolver problemas mais complexos. </p><br><h3 id="validator">  Validador </h3><br><p> A biblioteca do quarteto √© baseada no conceito de um <strong>validador</strong> .  Os validadores nesta biblioteca s√£o fun√ß√µes do seguinte formato </p><br><pre><code class="plaintext hljs">function validator( value: any, { key: string|int, parent: any }, { key: string|int, parent: any }, ... ): boolean</code> </pre> <br><p>  H√° v√°rias coisas nesta defini√ß√£o que devem ser descritas em mais detalhes: </p><br><p>  <strong><code>function(...): boolean</code></strong> - diz que o validador - calcula o resultado da valida√ß√£o e o resultado da valida√ß√£o √© um valor booleano - <strong>verdadeiro</strong> ou <strong>falso</strong> , respectivamente <strong>v√°lido</strong> ou <strong>inv√°lido</strong> </p><br><p>  <strong><code>value: any</code></strong> - indica que o validador - calcula o resultado da valida√ß√£o de um <strong>valor</strong> , que pode ser qualquer valor javascript.  O validador atribui o <strong>valor validado</strong> a v√°lido ou inv√°lido. </p><br><p>  <strong><code>{ key: string|int, parent: any }, ...</code></strong> - indica que o valor validado pode estar em contextos diferentes, dependendo do n√≠vel de aninhamento do valor.  Vamos mostrar com exemplos </p><br><p>  Valor de exemplo <strong>sem qualquer contexto</strong> </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> value = <span class="hljs-number"><span class="hljs-number">4</span></span>; <span class="hljs-comment"><span class="hljs-comment">//         . //         : const isValueValid = validator(4)</span></span></code> </pre> <br><p>  Valor de exemplo <b>em um contexto de matriz</b> </p><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//  0 1 2 3 4 const arr = [1, 2, 3, value, 5] //       (k): 3 //      : [1, 2, 3, value, 5] //    value -      const isValueValid = validator(4, { key: 3, parent: [1,2,3,4,5] })</span></span></code> </pre> <br><p>  Valor de exemplo <b>no contexto de um objeto</b> </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> obj = { <span class="hljs-attr"><span class="hljs-attr">a</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-attr"><span class="hljs-attr">b</span></span>: <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-attr"><span class="hljs-attr">c</span></span>: value, <span class="hljs-attr"><span class="hljs-attr">d</span></span>: <span class="hljs-number"><span class="hljs-number">8</span></span> } <span class="hljs-comment"><span class="hljs-comment">//        'c' //       : { a: 1, b: 2, c: 4, d: 8 } //    value -   //   : const isValueValid = validator(4, { key: 'c', parent: { a: 1, b: 2, c: 4, d: 8 } })</span></span></code> </pre> <br><p>  Como estruturas em um objeto podem ter um aninhamento maior, faz sentido falar sobre uma <b>variedade de contextos</b> </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> arrOfObj = [{ <span class="hljs-attr"><span class="hljs-attr">a</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-attr"><span class="hljs-attr">b</span></span>: <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-attr"><span class="hljs-attr">c</span></span>: value, <span class="hljs-attr"><span class="hljs-attr">d</span></span>: <span class="hljs-number"><span class="hljs-number">8</span></span> }, <span class="hljs-comment"><span class="hljs-comment">// ... ] //   c     'c' //    : { a: 1, b: 2, c: 4, d: 8 } //        arrOfObj, //       0. //    value -      const isValueValid = validator( 4, { key: 'c', parent: { a: 1, b: 2, c: 4, d: 8 } } { key: 0, parent: [{ a: 1, b: 2, c: 4, d: 8 }] } )</span></span></code> </pre> <br><p>  E assim por diante </p><br><div class="spoiler">  <b class="spoiler_title">Sobre a semelhan√ßa com m√©todos de matriz</b> <div class="spoiler_text"><p>  Essa defini√ß√£o de validador deve lembr√°-lo da defini√ß√£o de fun√ß√µes que s√£o passadas como argumento para m√©todos de matriz, como: <strong>map, filter, some, every</strong> e assim por diante. </p><br><ul><li>  O primeiro argumento para essas fun√ß√µes √© <strong>um elemento de matriz.</strong> </li><li>  O segundo argumento √© o <strong>√≠ndice do elemento.</strong> </li><li>  O terceiro argumento √© <strong>a pr√≥pria matriz.</strong> </li></ul><br><p>  O validador, neste caso, √© uma fun√ß√£o mais generalizada - ele pega n√£o apenas o √≠ndice do elemento na matriz e na matriz, mas tamb√©m o √≠ndice da matriz - em seu pai e pai, e assim por diante. </p></div></div><br><h3 id="chto-nam-stoit-dom-postroit">  O que devemos construir uma casa? </h3><br><p>  Os tijolos descritos acima n√£o se destacam entre outras <em>"solu√ß√µes de pedra"</em> que est√£o na <em>"praia" da</em> muleta javascript.  Portanto, vamos construir a partir deles, algo mais coerente e interessante.  Para isso, temos uma <strong>composi√ß√£o</strong> . </p><br><h3 id="kak-postroit-neboskryob-validacii-obektov">  Como construir um arranha-c√©u de valida√ß√£o de objeto? </h3><br><p>  Concordo, seria conveniente validar objetos de tal maneira que a descri√ß√£o da valida√ß√£o corresponda √† descri√ß√£o do objeto.  Para isso, usaremos a <strong>composi√ß√£o de objetos dos validadores</strong> .  √â assim: </p><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//    quartet const quartet = require('quartet') //    (v -  validator) const v = quartet() //      , //     const objectSchema = { a: a =&gt; typeof a ==='string', //   'string' b: b =&gt; typeof b === 'number', //   'number' // ... } const compositeObjValidator = v(objectSchema) const obj = { a: 'some text', b: 2 } const isObjValid = compositeObjValidator(obj) console.log(isObjValid) // =&gt; true</span></span></code> </pre> <br><p>  Como voc√™ pode ver, a partir de diferentes blocos de validadores definidos para campos espec√≠ficos, podemos montar um validador de objetos - algum "pequeno pr√©dio", que ainda est√° bastante cheio - mas melhor do que sem ele.  Para isso, usamos o compositor de validadores <code>v</code> .  <strong>A cada vez, ao encontrar o literal do objeto <code>v</code> no lugar do validador, ele ser√° considerado uma composi√ß√£o de objeto, transformando-o em um validador de objeto em seus campos.</strong> </p><br><p>  √Äs vezes, <strong>n√£o podemos descrever todos os campos</strong> .  Por exemplo, quando um objeto √© um dicion√°rio de dados: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> quartet = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'quartet'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> v = quartet() <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> isStringValidator = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">name</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span> name === <span class="hljs-string"><span class="hljs-string">'string'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> keyValueValidator = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">value, { key }</span></span></span><span class="hljs-function">) =&gt;</span></span> value.length === <span class="hljs-number"><span class="hljs-number">1</span></span> &amp;&amp; key.length === <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> dictionarySchema= { <span class="hljs-attr"><span class="hljs-attr">dictionaryName</span></span>: isStringValidator, ...v.rest(keyValueValidator) } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> compositeObjValidator = v(dictionarySchema) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> obj = { <span class="hljs-attr"><span class="hljs-attr">dictionaryName</span></span>: <span class="hljs-string"><span class="hljs-string">'next letter'</span></span>, <span class="hljs-attr"><span class="hljs-attr">b</span></span>: <span class="hljs-string"><span class="hljs-string">'c'</span></span>, <span class="hljs-attr"><span class="hljs-attr">c</span></span>: <span class="hljs-string"><span class="hljs-string">'d'</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> isObjValid = compositeObjValidator(obj) <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(isObjValid) <span class="hljs-comment"><span class="hljs-comment">// =&gt; true const obj2 = { dictionaryName: 'next letter', b: 'a', a: 'invalid value', notValidKey: 'a' } const isObj2Valid = compositeObjValidator(obj2) console.log(isObj2Valid) // =&gt; false</span></span></code> </pre> <br><h3 id="kak-pereispolzovat-stroitelnye-resheniya">  Como reutilizar solu√ß√µes de constru√ß√£o? </h3><br><p>  Como vimos acima, √© necess√°rio reutilizar validadores simples.  Nestes exemplos, j√° tivemos que usar o "validador de tipo de string" duas vezes. </p><br><p>  Para encurtar o registro e aumentar sua legibilidade, a biblioteca do quarteto usa sin√¥nimos de string de validadores.  <strong>Sempre que um compositor de validador encontra uma sequ√™ncia no local em que o validador deve estar, ele pesquisa seu validador no dicion√°rio e o usa</strong> . </p><br><p>  Por padr√£o, os validadores mais comuns j√° est√£o definidos na biblioteca. </p><br><p>  Considere os seguintes exemplos: </p><br><pre> <code class="javascript hljs">v(<span class="hljs-string"><span class="hljs-string">'number'</span></span>)(<span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-comment"><span class="hljs-comment">// =&gt; true v('number')('1') // =&gt; false v('string')('1') // =&gt; true v('string')(null) // =&gt; false v('null')(null) // =&gt; true v('object')(null) // =&gt; true v('object!')(null) // =&gt; false // ...</span></span></code> </pre> <br><p>  e muitos outros descritos na <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" title="documenta√ß√£o">documenta√ß√£o</a></strong> . </p><br><h3 id="kazhdoy-arke---svoy-vid-kirpichey">  Cada arco tem seu pr√≥prio tipo de tijolos? </h3><br><p>  O compositor validador (fun√ß√£o <code>v</code> ) tamb√©m √© uma f√°brica de validadores.  No sentido de que ele cont√©m muitos m√©todos √∫teis que retornam </p><br><ul><li>  validadores de fun√ß√£o </li><li>  valores que o compositor perceber√° como esquemas para criar validadores </li></ul><br><p>  Por exemplo, vejamos a valida√ß√£o da matriz: na maioria das vezes consiste em verificar o tipo da matriz e verificar todos os seus elementos.  Usaremos o <code>v.arrayOf(elementValidator)</code> para isso.  Por exemplo, considere uma matriz de pontos com nomes. </p><br><pre> <code class="javascript hljs"> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> a = [ {<span class="hljs-attr"><span class="hljs-attr">x</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-attr"><span class="hljs-attr">y</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">'A'</span></span>}, {<span class="hljs-attr"><span class="hljs-attr">x</span></span>: <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-attr"><span class="hljs-attr">y</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">'B'</span></span>}, {<span class="hljs-attr"><span class="hljs-attr">x</span></span>: <span class="hljs-number"><span class="hljs-number">-1</span></span>, <span class="hljs-attr"><span class="hljs-attr">y</span></span>: <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">'C'</span></span>}, {<span class="hljs-attr"><span class="hljs-attr">x</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-attr"><span class="hljs-attr">y</span></span>: <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">'D'</span></span>}, ]</code> </pre> <br><p>  Como uma matriz de pontos √© uma matriz de objetos, faz sentido usar a composi√ß√£o de objetos para validar os elementos da matriz. </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> namedPointSchema = { <span class="hljs-attr"><span class="hljs-attr">x</span></span>: <span class="hljs-string"><span class="hljs-string">'number'</span></span>, <span class="hljs-comment"><span class="hljs-comment">// number -       y: 'number', name: 'string' // string -       }</span></span></code> </pre> <br><p>  Agora, usando o m√©todo de f√°brica <code>v.arrayOf</code> , crie um validador para toda a matriz. </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> isArrayValid = v.arrayOf({ <span class="hljs-attr"><span class="hljs-attr">x</span></span>: <span class="hljs-string"><span class="hljs-string">'number'</span></span>, <span class="hljs-attr"><span class="hljs-attr">y</span></span>: <span class="hljs-string"><span class="hljs-string">'number'</span></span>, <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">'string'</span></span> })</code> </pre> <br><p>  Vamos ver como esse validador funciona: </p><br><pre> <code class="javascript hljs">isArrayValid(<span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-comment"><span class="hljs-comment">// =&gt; false isArrayValid(null) // =&gt; false isArrayValid([]) // =&gt; true isArrayValid([1, 2, 3]) // =&gt; false isArrayValid([ {x: 1, y: 1, name: 'A'}, {x: 2, y: 1, name: 'B'}, {x: -1, y: 2, name: 'C'}, {x: 1, y: 3, name: 'D'}, ]) // =&gt; true</span></span></code> </pre> <br><p>  Este √© apenas um dos m√©todos de f√°brica, cada um dos quais √© descrito na <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" title="documenta√ß√£o">documenta√ß√£o.</a> </p><br><p>  Como voc√™ viu acima, <code>v.rest</code> tamb√©m <code>v.rest</code> um m√©todo de f√°brica que retorna uma composi√ß√£o de objeto que verifica todos os campos n√£o especificados na composi√ß√£o do objeto.  Isso significa que ele pode ser incorporado em outra composi√ß√£o de objeto usando o <code>spread-operator</code> . </p><br><p>  Vamos citar como exemplo o uso de v√°rios deles: </p><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//    quartet const quartet = require('quartet') //    (v -  validator) const v = quartet() //   ,    const max = { name: 'Maxim', sex: 'male', age: 34, status: 'grandpa', friends: [ { name: 'Dima', friendDuration: '1 year'}, { name: 'Semen', friendDuration: '3 months'} ], workExperience: 2 } //  ,   "" , // ""  , ""   -  const nameSchema = v.and( 'not-empty', 'string', //   name =&gt; name[0].toUpperCase() === name[0] // - ) const maxSchema = { name: nameSchema, //       sex: v.enum('male', 'female'), //  -   . //       "" age: v.and('non-negative', 'safe-integer'), status: v.enum('grandpa', 'non-grandpa'), friends: v.arrayOf({ name: nameSchema, //      friendDuration: v.regex(/^[1-9]\d? (years?|months?)$/) }), workExperience: v.and('non-negative', 'safe-integer') } console.log(v(maxSchema)(max)) // =&gt; true</span></span></code> </pre> <br><h3 id="byt-ili-ne-byt">  Ser ou n√£o ser? </h3><br><p>  Muitas vezes acontece que dados v√°lidos assumem v√°rias formas, por exemplo: </p><br><ul><li>  <code>id</code> pode ser um n√∫mero ou uma string. </li><li>  O objeto de <code>point</code> pode ou n√£o conter algumas coordenadas, dependendo da dimens√£o. </li><li>  E muitos outros casos. </li></ul><br><p>  Para organizar a valida√ß√£o de variantes, √© fornecido um tipo separado de composi√ß√£o - composi√ß√£o de variantes.  √â representado por uma matriz de validadores de op√ß√µes poss√≠veis.  Um objeto √© considerado v√°lido quando pelo menos um dos validadores relata sua validade. </p><br><p>  Considere um exemplo com valida√ß√£o de identificador: </p><br><pre> <code class="javascript hljs"> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> isValidId = v([ v.and(<span class="hljs-string"><span class="hljs-string">'not-empty'</span></span>, <span class="hljs-string"><span class="hljs-string">'string'</span></span>), <span class="hljs-comment"><span class="hljs-comment">//       v.and('positive', 'safe-integer') //    ]) isValidId('') // =&gt; false isValidId('asdba32bas321ab321adb321abds546ba98s7') // =&gt; true isValidId(0) // =&gt; false isValidId(1) // =&gt; true isValidId(1123124) // =&gt; true</span></span></code> </pre> <br><p>  Exemplo de valida√ß√£o de ponto: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> isPointValid = v([ { <span class="hljs-comment"><span class="hljs-comment">//    -    x  dimension: v.enum(1), x: 'number', // v.rest    false // ,    -  ...v.rest(() =&gt; false) }, //   -    { dimension: v.enum(2), x: 'number', y: 'number', ...v.rest(() =&gt; false) }, //   - x, y  z { dimension: v.enum(3), x: 'number', y: 'number', z: 'number', ...v.rest(() =&gt; false) }, ]) // ,    ,      ,     -  -    isPointValid(1) // =&gt; false isPointValid(null) // =&gt; false isPointValid({ dimension: 1, x: 2 }) // =&gt; true isPointValid({ dimension: 1, x: 2, y: 3 //   }) // =&gt; false isPointValid({ dimension: 2, x: 2, y: 3 }) // =&gt; true isPointValid({ dimension: 3, x: 2, y: 3, z: 4 }) // =&gt; true // ...</span></span></code> </pre> <br><p>  Assim, <strong>sempre que um compositor v√™ uma matriz, ele a considera uma composi√ß√£o dos elementos validadores dessa matriz, de modo que, quando um deles considera o valor v√°lido, o c√°lculo da valida√ß√£o para e o valor √© reconhecido como v√°lido.</strong> </p><br><p>  Como vemos, o compositor considera n√£o apenas a fun√ß√£o validadora como validadora, mas tamb√©m tudo o que pode levar a uma fun√ß√£o validadora. </p><br><table><thead><tr><th>  Tipo de validador </th><th>  Exemplo </th><th>  Como percebido pelo compositor </th></tr></thead><tbody><tr><td>  fun√ß√£o de valida√ß√£o </td><td> <code>x =&gt; typeof x === 'bigint'</code> </td> <td>  apenas chamou os valores necess√°rios </td></tr><tr><td>  composi√ß√£o do objeto </td><td> <code>{ a: 'number' }</code> </td> <td>  cria uma fun√ß√£o validadora para um objeto com base nos validadores de campo especificados </td></tr><tr><td>  Composi√ß√£o das variantes </td><td> <code>['number', 'string']</code> </td> <td>  Cria uma fun√ß√£o validadora para validar um valor com pelo menos uma das op√ß√µes </td></tr><tr><td>  Resultados da chamada do m√©todo de f√°brica </td><td> <code>v.enum('male', 'female')</code> </td> <td>  A maioria dos m√©todos de f√°brica retorna fun√ß√µes de valida√ß√£o (com exce√ß√£o do <code>v.rest</code> , que retorna a composi√ß√£o do objeto), portanto, eles s√£o tratados como fun√ß√µes de valida√ß√£o regulares </td></tr></tbody></table><br><p>  Todas essas op√ß√µes do validador s√£o v√°lidas e podem ser usadas em qualquer lugar do esquema onde o validador deve estar. </p><br><p>  Como resultado, o esquema de trabalho √© sempre assim: <code>v(schema)</code> retorna uma fun√ß√£o de valida√ß√£o.  Em seguida, esta fun√ß√£o de valida√ß√£o √© chamada em valores espec√≠ficos: <br> <code>v(schema)(value[, ...parents])</code> </p> <br><h2 id="u-vas-avarii-na-stroyke-byli">  Voc√™ j√° teve algum acidente no canteiro de obras? </h2><br><p>  <em>- Ainda n√£o, nem um</em> <br>  <em>- Eles v√£o!</em> </p><br><p>  Acontece que os dados s√£o inv√°lidos e precisamos ser capazes de determinar a causa do inv√°lido. </p><br><p>  Para isso, a biblioteca de quartetos fornece um mecanismo de <em>explica√ß√£o</em> .  Consiste no fato de que, no caso em que o validador, interno ou externo, detecta a validade dos dados verificados, deve enviar uma <em>nota explicativa</em> . </p><br><p>  Para esses fins, <code>v</code> o segundo argumento do compositor de validadores <code>v</code> .  Ele adiciona o efeito colateral de enviar uma <em>nota explicativa</em> √† matriz <code>v.explanation</code> em caso de dados inv√°lidos. </p><br><p>  Por exemplo, vamos validar uma matriz e queremos descobrir os n√∫meros de todos os elementos inv√°lidos e seu valor: </p><br><pre> <code class="javascript hljs"> <span class="hljs-comment"><span class="hljs-comment">//   -     //   const getExplanation = (value, { key: index }) =&gt; ({ invalidValue: value, index }) // ,       . //         v.explanation //    const arrValidator = v.arrayOf( v( 'number', //   getExplanation //   "",   "" ) ) // ,     ""  //     ,     //         //   ,       const explainableArrValidator = v(arrValidator, 'this array is not valid') const arr = [1, 2, 3, 4, '5', '6', 7, '8'] explainableArrValidator(arr) // =&gt; false v.explanation // [ // { invalidValue: '5', index: 4 }, // { invalidValue: '6', index: 5 }, // { invalidValue: '8', index: 7 }, // 'this array is not valid' // ]</span></span></code> </pre> <br><p>  Como voc√™ pode ver, a escolha da explica√ß√£o depende da tarefa.  √Äs vezes nem √© necess√°rio. </p><br><p>  √Äs vezes, precisamos fazer algo com campos inv√°lidos.  Nesses casos, faz sentido usar o nome do campo inv√°lido como uma <em>explica√ß√£o</em> : </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> objSchema = { <span class="hljs-attr"><span class="hljs-attr">a</span></span>: v(<span class="hljs-string"><span class="hljs-string">'number'</span></span>, <span class="hljs-string"><span class="hljs-string">'a'</span></span>), <span class="hljs-attr"><span class="hljs-attr">b</span></span>: v(<span class="hljs-string"><span class="hljs-string">'number'</span></span>, <span class="hljs-string"><span class="hljs-string">'b'</span></span>), <span class="hljs-attr"><span class="hljs-attr">c</span></span>: v(<span class="hljs-string"><span class="hljs-string">'string'</span></span>, <span class="hljs-string"><span class="hljs-string">'c'</span></span>) } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> isObjValid = v(objSchema) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> invalidObj = { <span class="hljs-attr"><span class="hljs-attr">a</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-attr"><span class="hljs-attr">b</span></span>: <span class="hljs-string"><span class="hljs-string">'1'</span></span>, <span class="hljs-attr"><span class="hljs-attr">c</span></span>: <span class="hljs-number"><span class="hljs-number">3</span></span> } isObjValid(invalidObj) <span class="hljs-comment"><span class="hljs-comment">// =&gt; false v.explanation // ['b', 'c'] //     console.error(`${v.explanation.join(', ')} is not valid`) // =&gt; b, c is not valid //       (. ) invalidObj = v.omitInvalidProps(objSchema)(invalidObj) console.log(invalidObj) // =&gt; { a: 1 }</span></span></code> </pre> <br><p>  Com esse mecanismo de explica√ß√£o, voc√™ pode implementar qualquer comportamento associado aos resultados da valida√ß√£o. </p><br><p>  Uma explica√ß√£o pode ser qualquer coisa: </p><br><ul><li>  um objeto contendo as informa√ß√µes necess√°rias; </li><li>  fun√ß√£o que corrige o erro.  ( <code>getExplanation =&gt; function(invalid): valid</code> ); </li><li>  nome do campo inv√°lido ou √≠ndice do elemento inv√°lido; </li><li>  c√≥digo de erro </li><li>  e tudo o que √© suficiente para a sua imagina√ß√£o. </li></ul><br><h2 id="chto-delat-kogda-delo-ne-stroitsya">  O que fazer quando as coisas n√£o est√£o sendo constru√≠das? </h2><br><p>  Corrigir erros de valida√ß√£o n√£o √© uma tarefa rara.  Para esses fins, a biblioteca usa validadores com um efeito colateral que lembra o local do erro e como corrigi-lo. </p><br><ul><li>  <code>v.default(validator, value)</code> - retorna um validador que lembra um valor inv√°lido e, no momento da chamada de <code>v.fix</code> - define o valor padr√£o </li><li>  <code>v.filter(validator)</code> - retorna um validador que lembra um valor inv√°lido e, no momento da chamada de <code>v.fix</code> - remove esse valor do pai </li><li>  <code>v.addFix(validator, fixFunc)</code> - retorna um validador que lembra um valor inv√°lido e, no momento da chamada de <code>v.fix</code> - chama fixFunc com par√¢metros (valor, {key, parent}, ...).  <code>fixFunc</code> - deve alterar um dos parceiros - para alterar o valor </li></ul><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> toPositive = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">negativeValue, { key, parent }</span></span></span><span class="hljs-function">) =&gt;</span></span> { parent[key] = -negativeValue } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> objSchema = { <span class="hljs-attr"><span class="hljs-attr">a</span></span>: v.default(<span class="hljs-string"><span class="hljs-string">'number'</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>), <span class="hljs-attr"><span class="hljs-attr">b</span></span>: v.filter(<span class="hljs-string"><span class="hljs-string">'string'</span></span>, <span class="hljs-string"><span class="hljs-string">''</span></span>), <span class="hljs-attr"><span class="hljs-attr">c</span></span>: v.default(<span class="hljs-string"><span class="hljs-string">'array'</span></span>, []), <span class="hljs-attr"><span class="hljs-attr">d</span></span>: v.default(<span class="hljs-string"><span class="hljs-string">'number'</span></span>, invalidValue =&gt; <span class="hljs-built_in"><span class="hljs-built_in">Number</span></span>(invalidValue)), <span class="hljs-comment"><span class="hljs-comment">//    pos: v.and( v.default('number', 0), //     -  0 v.addFix('non-negative', toPositive) //     -   ) } const invalidObj = { a: 1, b: 2, c: 3, d: '4', pos: -3 } v.resetExplanation() //   v() v(objSchema)(invalidObj) // =&gt; false // v.hasFixes() =&gt; true const validObj = v.fix(invalidObj) console.log(validObj) // =&gt; { a: 1, b: '', c: [], d: 4 }</span></span></code> </pre> <br><h3 id="po-hozyaystvu-eschyo-prigoditsya">  As tarefas ainda s√£o √∫teis </h3><br><p>  Tamb√©m existem m√©todos utilit√°rios para a√ß√µes de valida√ß√£o nesta biblioteca: </p><br><table><thead><tr><th>  M√©todo </th><th>  Resultado </th></tr></thead><tbody><tr><td> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" title="`v.throwError`"><code>v.throwError</code></a> </td> <td>  Se inv√°lido, lan√ßa um TypeError com a mensagem fornecida. </td></tr><tr><td> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" title="`v.omitInvalidItems`"><code>v.omitInvalidItems</code></a> </td> <td>  Retorna uma nova matriz (ou objeto de dicion√°rio) sem elementos inv√°lidos (campos). </td></tr><tr><td> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" title="`v.omitInvalidProps`"><code>v.omitInvalidProps</code></a> </td> <td>  Retorna um novo objeto sem campos inv√°lidos, de acordo com o validador de objeto especificado. </td></tr><tr><td> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" title="`v.validOr`"><code>v.validOr</code></a> </td> <td>  Retorna o valor se for v√°lido, caso contr√°rio, ele ser√° substitu√≠do pelo valor padr√£o especificado. </td></tr><tr><td> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><code>v.example</code></a> </td> <td>  Verifica se os valores fornecidos se ajustam ao esquema.  Se eles n√£o couberem, um erro ser√° gerado.  Serve como documenta√ß√£o e teste de circuitos </td></tr></tbody></table><br><h2 id="rezultaty">  Resultados </h2><br><p>  As tarefas foram resolvidas das seguintes maneiras: </p><br><table><thead><tr><th>  Desafio </th><th>  Solu√ß√£o </th></tr></thead><tbody><tr><td>  Valida√ß√£o do tipo de dados </td><td>  Validadores nomeados padr√£o. </td></tr><tr><td>  Valores padr√£o </td><td> <code>v.default</code> </td> </tr><tr><td>  Remo√ß√£o de pe√ßas inv√°lidas </td><td>  <code>v.filter</code> , <code>v.omitInvalidItems</code> e <code>v.omitInvalidProps</code> . </td></tr><tr><td>  F√°cil de aprender </td><td>  Validadores simples, maneiras simples de compor em validadores complexos. </td></tr><tr><td>  Legibilidade do c√≥digo </td><td>  Um dos objetivos da biblioteca era comparar os pr√≥prios esquemas de valida√ß√£o </td></tr><tr><td>  objetos validados. </td></tr><tr><td>  Facilidade de modifica√ß√£o </td><td>  Tendo dominado os elementos das composi√ß√µes e usando suas pr√≥prias fun√ß√µes de valida√ß√£o - alterar o c√≥digo √© bastante simples. </td></tr><tr><td>  Mensagem de erro </td><td>  Explica√ß√£o na forma de uma mensagem de erro.  Ou c√°lculo de c√≥digo de erro com base em explica√ß√µes. </td></tr></tbody></table><br><h2 id="posleslovie">  Posf√°cio </h2><br><p>  Esta solu√ß√£o foi projetada para criar r√°pida e convenientemente fun√ß√µes de valida√ß√£o com a capacidade de incorporar fun√ß√µes de valida√ß√£o personalizadas.  Portanto, se houver, quaisquer corre√ß√µes, cr√≠ticas e op√ß√µes de melhoria daqueles que l√™em este artigo s√£o bem-vindas.  Obrigado pela aten√ß√£o. <br></p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt429916/">https://habr.com/ru/post/pt429916/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt429904/index.html">Hist√≥rias engra√ßadas e tristes sobre o desenvolvimento de jogos de computador</a></li>
<li><a href="../pt429908/index.html">Como usar corotinas na comida e dormir tranquilamente √† noite</a></li>
<li><a href="../pt429910/index.html">AppsConf Rises</a></li>
<li><a href="../pt429912/index.html">Desenvolvimento da biblioteca: da API ao lan√ßamento p√∫blico</a></li>
<li><a href="../pt429914/index.html">OpenSceneGraph: Gr√°fico de cena e ponteiros inteligentes</a></li>
<li><a href="../pt429918/index.html">Mundo virtual Intel. Parte 2: SMP</a></li>
<li><a href="../pt429920/index.html">Tragicomedy em NaN age: como criamos um jogo em JS e o lan√ßamos no Steam</a></li>
<li><a href="../pt429922/index.html">Como transformar um projeto simples em uma constru√ß√£o de longo prazo ou cortar todos os itens desnecess√°rios</a></li>
<li><a href="../pt429928/index.html">Tudo o que voc√™ precisa saber sobre estresse e emo√ß√µes fortes</a></li>
<li><a href="../pt429930/index.html">Splunk Solu√ß√£o de problemas f√°cil de aplicativos</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>