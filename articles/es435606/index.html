<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë∂ ü¶ã ‚ú¥Ô∏è ¬øC√≥mo escribir pruebas unitarias para actores? Enfoque de SObjectizer ü§ûüèª üôÖüèæ üë®‚Äçüíª</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Los actores simplifican la programaci√≥n multiproceso al evitar un estado mutable compartido. Cada actor posee sus propios datos que no son visibles pa...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>¬øC√≥mo escribir pruebas unitarias para actores? Enfoque de SObjectizer</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/435606/">  Los actores simplifican la programaci√≥n multiproceso al evitar un estado mutable compartido.  Cada actor posee sus propios datos que no son visibles para nadie.  Los actores interact√∫an solo a trav√©s de mensajes asincr√≥nicos.  Por lo tanto, los horrores m√°s terror√≠ficos de los subprocesos m√∫ltiples en forma de razas y puntos muertos cuando se usan actores no son terribles (aunque los actores tienen sus problemas, pero no se trata de eso ahora). <br><br>  En general, escribir aplicaciones multiproceso con actores es f√°cil y divertido.  Incluso porque los actores mismos est√°n escritos de manera f√°cil y natural.  Incluso podr√≠a decir que escribir c√≥digo de actor es la parte m√°s f√°cil del trabajo.  Pero cuando el actor est√° escrito, surge una muy buena pregunta: "¬øC√≥mo verificar la exactitud de su trabajo?" <br><br>  La pregunta es realmente muy buena.  Se nos pregunta regularmente cuando hablamos de actores en general y de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">SObjectizer</a> en particular.  Y hasta hace poco, pod√≠amos responder esta pregunta solo en t√©rminos generales. <br><br>  Pero <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">se lanz√≥ la versi√≥n 5.5.24</a> , en la que hab√≠a soporte experimental para la posibilidad de pruebas unitarias de actores.  Y en este art√≠culo trataremos de hablar sobre qu√© es, c√≥mo usarlo y con qu√© se implement√≥. <br><a name="habracut"></a><br><h1>  ¬øC√≥mo son las pruebas de actor? </h1><br>  Consideraremos las nuevas caracter√≠sticas de SObjectizer en un par de ejemplos, pasando qu√© es qu√©.  El c√≥digo fuente de los ejemplos discutidos se puede encontrar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">en este repositorio</a> . <br><br>  A lo largo de la historia, los t√©rminos "actor" y "agente" se utilizar√°n indistintamente.  Denotan lo mismo, pero SObjectizer ha usado hist√≥ricamente el t√©rmino "agente", por lo que en adelante "agente" se usar√° con m√°s frecuencia. <br><br><h2>  El ejemplo m√°s simple con Pinger y Ponger. </h2><br>  El ejemplo de los actores Pinger y Ponger es probablemente el ejemplo m√°s com√∫n para los marcos de actores.  Se puede decir un cl√°sico.  Bueno, si es as√≠, entonces comencemos con los cl√°sicos. <br><br>  Entonces, tenemos un agente Pinger, que al comienzo de su trabajo env√≠a un mensaje Ping al agente Ponger.  Y el agente Ponger devuelve un mensaje Pong.  As√≠ es como se ve en el c√≥digo C ++: <br><br><pre><code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Types of signals to be used. struct ping final : so_5::signal_t {}; struct pong final : so_5::signal_t {}; // Pinger agent. class pinger_t final : public so_5::agent_t { so_5::mbox_t m_target; public : pinger_t( context_t ctx ) : so_5::agent_t{ std::move(ctx) } { so_subscribe_self().event( [this](mhood_t&lt;pong&gt;) { so_deregister_agent_coop_normally(); } ); } void set_target( const so_5::mbox_t &amp; to ) { m_target = to; } void so_evt_start() override { so_5::send&lt; ping &gt;( m_target ); } }; // Ponger agent. class ponger_t final : public so_5::agent_t { so_5::mbox_t m_target; public : ponger_t( context_t ctx ) : so_5::agent_t{ std::move(ctx) } { so_subscribe_self().event( [this](mhood_t&lt;ping&gt;) { so_5::send&lt; pong &gt;( m_target ); } ); } void set_target( const so_5::mbox_t &amp; to ) { m_target = to; } };</span></span></code> </pre> <br>  Nuestra tarea es escribir una prueba que verifique que al registrar estos agentes con SObjectizer, Ponger recibir√° un mensaje Ping y Pinger recibir√° un mensaje Pong en respuesta. <br><br>  Ok  Escribimos dicha prueba usando el marco de prueba de unidad <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">doctest</a> y obtenemos: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DOCTEST_CONFIG_IMPLEMENT_WITH_MAIN #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;doctest/doctest.h&gt; #include &lt;ping_pong/agents.hpp&gt; #include &lt;so_5/experimental/testing.hpp&gt; namespace tests = so_5::experimental::testing; TEST_CASE( "ping_pong" ) { tests::testing_env_t sobj; pinger_t * pinger{}; ponger_t * ponger{}; sobj.environment().introduce_coop([&amp;](so_5::coop_t &amp; coop) { pinger = coop.make_agent&lt; pinger_t &gt;(); ponger = coop.make_agent&lt; ponger_t &gt;(); pinger-&gt;set_target( ponger-&gt;so_direct_mbox() ); ponger-&gt;set_target( pinger-&gt;so_direct_mbox() ); }); sobj.scenario().define_step("ping") .when(*ponger &amp; tests::reacts_to&lt;ping&gt;()); sobj.scenario().define_step("pong") .when(*pinger &amp; tests::reacts_to&lt;pong&gt;()); sobj.scenario().run_for(std::chrono::milliseconds(100)); REQUIRE(tests::completed() == sobj.scenario().result()); }</span></span></span></span></code> </pre> <br>  Parece ser facil.  Veamos que pasa aqu√≠. <br><br>  En primer lugar, descargamos descripciones de las herramientas de soporte de prueba de agentes: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;so_5/experimental/testing.hpp&gt;</span></span></span></span></code> </pre> <br>  Todas estas herramientas se describen en el espacio de nombres so_5 :: experimental :: testing, pero para no repetir un nombre tan largo, presentamos un alias m√°s corto y m√°s conveniente: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> tests = so_5::experimental::testing;</code> </pre> <br>  La siguiente es una descripci√≥n de un solo caso de prueba (y no necesitamos m√°s aqu√≠). <br><br>  Dentro del caso de prueba, hay varios puntos clave. <br><br>  En primer lugar, esta es la creaci√≥n y el lanzamiento de un entorno de prueba especial para SObjectizer: <br><br><pre> <code class="cpp hljs">tests::<span class="hljs-keyword"><span class="hljs-keyword">testing_env_t</span></span> sobj;</code> </pre> <br>  Sin este entorno, la "ejecuci√≥n de prueba" para los agentes no puede completarse, pero hablaremos de esto un poco m√°s adelante. <br><br>  La clase testing_env_t es muy similar a la clase wrap_env_t en SObjectizer.  Del mismo modo, el SObjectizer comienza en el constructor y se detiene en el destructor.  Entonces, al escribir pruebas, no tiene que pensar en iniciar y detener SObjectizer. <br><br>  A continuaci√≥n, necesitamos crear y registrar agentes Pinger y Ponger.  En este caso, necesitamos utilizar estos agentes para determinar el llamado.  "Escenario de prueba".  Por lo tanto, almacenamos separadamente los punteros a los agentes: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">pinger_t</span></span> * pinger{}; <span class="hljs-keyword"><span class="hljs-keyword">ponger_t</span></span> * ponger{}; sobj.environment().introduce_coop([&amp;](so_5::<span class="hljs-keyword"><span class="hljs-keyword">coop_t</span></span> &amp; coop) { pinger = coop.make_agent&lt; <span class="hljs-keyword"><span class="hljs-keyword">pinger_t</span></span> &gt;(); ponger = coop.make_agent&lt; <span class="hljs-keyword"><span class="hljs-keyword">ponger_t</span></span> &gt;(); pinger-&gt;set_target( ponger-&gt;so_direct_mbox() ); ponger-&gt;set_target( pinger-&gt;so_direct_mbox() ); });</code> </pre> <br>  Y luego comenzamos a trabajar con el "escenario de prueba". <br><br>  Un caso de prueba es una pieza que consiste en una secuencia directa de pasos que deben completarse de principio a fin.  La frase "de una secuencia directa" significa que en SObjectizer-5.5.24 los pasos de gui√≥n "funcionan" estrictamente secuencialmente, sin ramificaciones ni bucles. <br><br>  Escribir una prueba para agentes es la definici√≥n de un script de prueba que debe ejecutarse.  Es decir  Todos los pasos del escenario de prueba deber√≠an funcionar, desde el primero hasta el √∫ltimo. <br><br>  Por lo tanto, en nuestro caso de prueba, definimos un escenario de dos pasos.  El primer paso verifica que el agente Ponger recibir√° y procesar√° el mensaje Ping: <br><br><pre> <code class="cpp hljs">sobj.scenario().define_step(<span class="hljs-string"><span class="hljs-string">"ping"</span></span>) .when(*ponger &amp; tests::reacts_to&lt;ping&gt;());</code> </pre> <br>  El segundo paso verifica que el agente Pinger reciba un mensaje Pong: <br><br><pre> <code class="cpp hljs">sobj.scenario().define_step(<span class="hljs-string"><span class="hljs-string">"pong"</span></span>) .when(*pinger &amp; tests::reacts_to&lt;pong&gt;());</code> </pre> <br>  Estos dos pasos son suficientes para nuestro caso de prueba, por lo tanto, despu√©s de su determinaci√≥n, procedemos a la ejecuci√≥n del script.  Ejecutamos el script y permitimos que funcione no m√°s de 100 ms: <br><br><pre> <code class="cpp hljs">sobj.scenario().run_for(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::chrono::milliseconds(<span class="hljs-number"><span class="hljs-number">100</span></span>));</code> </pre> <br>  Cien milisegundos deber√≠an ser m√°s que suficientes para que los dos agentes intercambien mensajes (incluso si la prueba se ejecuta dentro de una m√°quina virtual muy lenta, como a veces es el caso con Travis CI).  Bueno, si cometimos un error al escribir agentes o describimos incorrectamente un gui√≥n de prueba, entonces esperar a que se complete un gui√≥n err√≥neo durante m√°s de 100 ms no tiene sentido. <br><br>  Entonces, despu√©s de regresar de run_for (), nuestro script puede completarse con √©xito o no.  Por lo tanto, simplemente verificamos el resultado del script: <br><br><pre> <code class="cpp hljs">REQUIRE(tests::completed() == sobj.scenario().result());</code> </pre> <br>  Si la secuencia de comandos no se complet√≥ con √©xito, esto conducir√° a la falla de nuestro caso de prueba. <br><br><h3>  Algunas aclaraciones y adiciones </h3><br>  Si ejecutamos este c√≥digo dentro de un SObjectizer normal: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">pinger_t</span></span> * pinger{}; <span class="hljs-keyword"><span class="hljs-keyword">ponger_t</span></span> * ponger{}; sobj.environment().introduce_coop([&amp;](so_5::<span class="hljs-keyword"><span class="hljs-keyword">coop_t</span></span> &amp; coop) { pinger = coop.make_agent&lt; <span class="hljs-keyword"><span class="hljs-keyword">pinger_t</span></span> &gt;(); ponger = coop.make_agent&lt; <span class="hljs-keyword"><span class="hljs-keyword">ponger_t</span></span> &gt;(); pinger-&gt;set_target( ponger-&gt;so_direct_mbox() ); ponger-&gt;set_target( pinger-&gt;so_direct_mbox() ); });</code> </pre> <br>  entonces, lo m√°s probable es que los agentes de Pinger y Ponger lograran intercambiar mensajes y completar su trabajo antes de regresar de introdu_coop (los milagros de subprocesamiento m√∫ltiple son tales).  Pero dentro del entorno de prueba, que se crea gracias a testing_env_t, esto no sucede, los agentes de Pinger y Ponger esperan pacientemente hasta que ejecutemos nuestro script de prueba.  ¬øC√≥mo sucede esto? <br><br>  El hecho es que dentro del entorno de prueba, los agentes parecen estar congelados.  Es decir  despu√©s del registro, est√°n presentes en SObjectizer, pero no pueden procesar ninguno de sus mensajes.  Por lo tanto, incluso so_evt_start () no se llama a los agentes antes de ejecutar el script de prueba. <br><br>  Cuando ejecutamos el script de prueba usando el m√©todo run_for (), el script de prueba primero descongela todos los agentes congelados.  Y luego el script comienza a recibir notificaciones del SObjectizer sobre lo que les sucede a los agentes.  Por ejemplo, que el agente Ponger recibi√≥ el mensaje Ping y que el agente Ponger proces√≥ el mensaje, pero no lo rechaz√≥. <br><br>  Cuando tales notificaciones comienzan a llegar al script de prueba, el script intenta "probarlas" hasta el primer paso.  Entonces, tenemos una notificaci√≥n de que Ponger recibi√≥ y proces√≥ Ping. ¬øNos interesa o no?  Resulta que es interesante, porque la descripci√≥n del paso dice exactamente eso: funciona cuando Ponger reacciona a Ping.  Lo que vemos en el c√≥digo: <br><br><pre> <code class="cpp hljs">.when(*ponger &amp; tests::reacts_to&lt;ping&gt;())</code> </pre> <br>  Ok  Entonces, el primer paso funcion√≥, vaya al siguiente paso. <br><br>  Luego viene una notificaci√≥n de que el Agente Pinger ha reaccionado a Pong.  Y esto es justo lo que necesita para que funcione el segundo paso: <br><br><pre> <code class="cpp hljs">.when(*pinger &amp; tests::reacts_to&lt;pong&gt;())</code> </pre> <br>  Ok  As√≠ que el segundo paso funcion√≥, ¬øtenemos algo m√°s?  No  Esto significa que se completa el script de prueba completo y puede devolver el control desde run_for (). <br><br>  Aqu√≠, en principio, c√≥mo funciona el script de prueba.  De hecho, todo es algo m√°s complicado, pero tocaremos aspectos m√°s complejos cuando consideremos un ejemplo m√°s complejo. <br><br><h2>  Ejemplo de fil√≥sofos gastron√≥micos </h2><br>  Se pueden ver ejemplos m√°s complejos de agentes de prueba para resolver la conocida tarea "Fil√≥sofos gastron√≥micos".  En los actores, este problema se puede resolver de varias maneras.  A continuaci√≥n, consideraremos la soluci√≥n m√°s trivial: tanto los actores como los fil√≥sofos est√°n representados en forma de actores, por los cuales los fil√≥sofos tienen que luchar.  Cada fil√≥sofo piensa por un momento, luego trata de tomar el tenedor a la izquierda.  Si esto tiene √©xito, intenta tomar la bifurcaci√≥n a la derecha.  Si esto tiene √©xito, entonces el fil√≥sofo come durante un tiempo, despu√©s de lo cual deja los tenedores y comienza a pensar.  Si no fue posible tomar el tap√≥n a la derecha (es decir, fue tomado por otro fil√≥sofo), entonces el fil√≥sofo regresa el tap√≥n a la izquierda y piensa un poco m√°s.  Es decir  Esta no es una buena soluci√≥n en el sentido de que alg√∫n fil√≥sofo puede morir de hambre durante demasiado tiempo.  Pero entonces es muy simple.  Y tiene el alcance para demostrar la capacidad de probar agentes. <br><br>  Los c√≥digos fuente con la implementaci√≥n de los agentes Fork y Philosopher se pueden encontrar <a href="">aqu√≠</a> , en el art√≠culo no los consideraremos para ahorrar espacio. <br><br><h3>  Prueba de horquilla </h3><br>  La primera prueba para agentes de Dining Philosophers ser√° para el agente Fork. <br><br>  Este agente funciona de acuerdo con un esquema simple.  Tiene dos estados: Libre y Tomado.  Cuando el agente est√° en estado Libre, responde a un mensaje Tomar.  En este caso, el agente ingresa al estado Tomado y responde con un mensaje de respuesta Tomado. <br><br>  Cuando el agente est√° en el estado Tomado, responde al mensaje Tomar de manera diferente: el estado del agente no cambia y Ocupado se env√≠a como un mensaje de respuesta.  Tambi√©n en el estado Tomado, el agente responde al mensaje Put: el agente vuelve al estado Libre. <br><br>  En el estado Libre, el mensaje Put se ignora. <br><br>  Intentaremos probar este mediante el siguiente caso de prueba: <br><br><pre> <code class="cpp hljs">TEST_CASE( <span class="hljs-string"><span class="hljs-string">"fork"</span></span> ) { <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">pseudo_philosopher_t</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">final</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> so_5::<span class="hljs-keyword"><span class="hljs-keyword">agent_t</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">pseudo_philosopher_t</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">context_t</span></span> ctx) : so_5::<span class="hljs-keyword"><span class="hljs-keyword">agent_t</span></span>{<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(ctx)} { so_subscribe_self() .event([](<span class="hljs-keyword"><span class="hljs-keyword">mhood_t</span></span>&lt;msg_taken&gt;) {}) .event([](<span class="hljs-keyword"><span class="hljs-keyword">mhood_t</span></span>&lt;msg_busy&gt;) {}); } }; tests::<span class="hljs-keyword"><span class="hljs-keyword">testing_env_t</span></span> sobj; so_5::<span class="hljs-keyword"><span class="hljs-keyword">agent_t</span></span> * fork{}; so_5::<span class="hljs-keyword"><span class="hljs-keyword">agent_t</span></span> * philosopher{}; sobj.environment().introduce_coop([&amp;](so_5::<span class="hljs-keyword"><span class="hljs-keyword">coop_t</span></span> &amp; coop) { fork = coop.make_agent&lt;<span class="hljs-keyword"><span class="hljs-keyword">fork_t</span></span>&gt;(); philosopher = coop.make_agent&lt;<span class="hljs-keyword"><span class="hljs-keyword">pseudo_philosopher_t</span></span>&gt;(); }); sobj.scenario().define_step(<span class="hljs-string"><span class="hljs-string">"put_when_free"</span></span>) .impact&lt;msg_put&gt;(*fork) .when(*fork &amp; tests::ignores&lt;msg_put&gt;()); sobj.scenario().define_step(<span class="hljs-string"><span class="hljs-string">"take_when_free"</span></span>) .impact&lt;msg_take&gt;(*fork, philosopher-&gt;so_direct_mbox()) .when_all( *fork &amp; tests::reacts_to&lt;msg_take&gt;() &amp; tests::store_state_name(<span class="hljs-string"><span class="hljs-string">"fork"</span></span>), *philosopher &amp; tests::reacts_to&lt;msg_taken&gt;()); sobj.scenario().define_step(<span class="hljs-string"><span class="hljs-string">"take_when_taken"</span></span>) .impact&lt;msg_take&gt;(*fork, philosopher-&gt;so_direct_mbox()) .when_all( *fork &amp; tests::reacts_to&lt;msg_take&gt;(), *philosopher &amp; tests::reacts_to&lt;msg_busy&gt;()); sobj.scenario().define_step(<span class="hljs-string"><span class="hljs-string">"put_when_taken"</span></span>) .impact&lt;msg_put&gt;(*fork) .when( *fork &amp; tests::reacts_to&lt;msg_put&gt;() &amp; tests::store_state_name(<span class="hljs-string"><span class="hljs-string">"fork"</span></span>)); sobj.scenario().run_for(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::chrono::milliseconds(<span class="hljs-number"><span class="hljs-number">100</span></span>)); REQUIRE(tests::completed() == sobj.scenario().result()); REQUIRE(<span class="hljs-string"><span class="hljs-string">"taken"</span></span> == sobj.scenario().stored_state_name(<span class="hljs-string"><span class="hljs-string">"take_when_free"</span></span>, <span class="hljs-string"><span class="hljs-string">"fork"</span></span>)); REQUIRE(<span class="hljs-string"><span class="hljs-string">"free"</span></span> == sobj.scenario().stored_state_name(<span class="hljs-string"><span class="hljs-string">"put_when_taken"</span></span>, <span class="hljs-string"><span class="hljs-string">"fork"</span></span>)); }</code> </pre> <br>  Hay mucho c√≥digo, por lo que lo trataremos en partes, omitiendo esos fragmentos que ya deber√≠an estar claros. <br><br>  Lo primero que necesitamos aqu√≠ es reemplazar el verdadero agente de Fil√≥sofo.  Un agente de Fork debe recibir mensajes de alguien y responder a alguien.  Pero no podemos usar al verdadero fil√≥sofo en este caso de prueba, porque el verdadero agente del fil√≥sofo tiene su propia l√≥gica de comportamiento, √©l mismo env√≠a mensajes y esta independencia interferir√° con nosotros aqu√≠. <br><br>  Por lo tanto, nos <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">burlamos</a> , es decir  en lugar del verdadero fil√≥sofo, presentaremos un sustituto: un agente vac√≠o que no env√≠a nada en s√≠, sino que solo recibe mensajes enviados, sin ning√∫n procesamiento √∫til.  Este es el pseudo-fil√≥sofo implementado en el c√≥digo: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">pseudo_philosopher_t</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">final</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> so_5::<span class="hljs-keyword"><span class="hljs-keyword">agent_t</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">pseudo_philosopher_t</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">context_t</span></span> ctx) : so_5::<span class="hljs-keyword"><span class="hljs-keyword">agent_t</span></span>{<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(ctx)} { so_subscribe_self() .event([](<span class="hljs-keyword"><span class="hljs-keyword">mhood_t</span></span>&lt;msg_taken&gt;) {}) .event([](<span class="hljs-keyword"><span class="hljs-keyword">mhood_t</span></span>&lt;msg_busy&gt;) {}); } };</code> </pre> <br>  Luego, creamos una colaboraci√≥n entre el agente de Fork y el agente de PseudoPhilospher y comenzamos a determinar el contenido de nuestro caso de prueba. <br><br>  El primer paso del script es verificar que Fork, al estar en estado Libre (y este es su estado inicial), no responde al mensaje Put.  As√≠ es como se escribe este cheque: <br><br><pre> <code class="cpp hljs">sobj.scenario().define_step(<span class="hljs-string"><span class="hljs-string">"put_when_free"</span></span>) .impact&lt;msg_put&gt;(*fork) .when(*fork &amp; tests::ignores&lt;msg_put&gt;());</code> </pre> <br>  Lo primero que llama la atenci√≥n es la construcci√≥n de impacto. <br><br>  Ella es necesaria porque nuestro agente Fork no hace nada, solo reacciona a los mensajes entrantes.  Por lo tanto, alguien debe enviar un mensaje al agente.  Pero quien? <br><br>  Pero el paso de gui√≥n en s√≠ mismo env√≠a a trav√©s del impacto.  De hecho, el impacto es un an√°logo de la funci√≥n de env√≠o habitual (y el formato es el mismo). <br><br>  Bueno, el paso de gui√≥n mismo enviar√° un mensaje a trav√©s del impacto.  ¬øPero cu√°ndo lo har√°? <br><br>  Y lo har√° cuando le llegue el turno.  Es decir  Si el paso en el script es el primero, el impacto se ejecutar√° inmediatamente despu√©s de ingresar run_for.  Si el paso en el script no es el primero, entonces el impacto se ejecutar√° tan pronto como el paso anterior haya funcionado y el script proceder√° a procesar el siguiente paso. <br><br>  La segunda cosa que debemos discutir aqu√≠ es ignorar llamadas.  Esta funci√≥n auxiliar dice que el paso se activa cuando el agente no puede procesar el mensaje.  Es decir  en este caso, el agente de Fork debe negarse a procesar el mensaje Put. <br><br>  Consideremos un paso m√°s del escenario de prueba con m√°s detalle: <br><br><pre> <code class="cpp hljs">sobj.scenario().define_step(<span class="hljs-string"><span class="hljs-string">"take_when_free"</span></span>) .impact&lt;msg_take&gt;(*fork, philosopher-&gt;so_direct_mbox()) .when_all( *fork &amp; tests::reacts_to&lt;msg_take&gt;() &amp; tests::store_state_name(<span class="hljs-string"><span class="hljs-string">"fork"</span></span>), *philosopher &amp; tests::reacts_to&lt;msg_taken&gt;());</code> </pre><br>  Primero, aqu√≠ vemos cu√°ndo_todos en lugar de cu√°ndo.  Esto se debe a que para activar un paso, debemos cumplir varias condiciones a la vez.  El agente tenedor necesita manejar Take.  Y Philosopher necesita manejar la respuesta Taken.  Por lo tanto, escribimos when_all, no when.  Por cierto, tambi√©n hay when_any, pero no nos reuniremos con √©l en los ejemplos considerados hoy. <br><br>  En segundo lugar, tambi√©n debemos verificar el hecho de que despu√©s del procesamiento de Take, el agente de Fork estar√° en el estado de Taken.  Hacemos la verificaci√≥n de la siguiente manera: primero indicamos que tan pronto como el agente de Fork termine de procesar Take, el nombre de su estado actual debe guardarse usando la etiqueta ‚Äúfork‚Äù.  Esta construcci√≥n solo conserva el nombre del estado del agente: <br><br><pre> <code class="cpp hljs">&amp; tests::store_state_name(<span class="hljs-string"><span class="hljs-string">"fork"</span></span>)</code> </pre> <br>  Y luego, cuando el script se completa con √©xito, verificamos este nombre guardado: <br><pre> <code class="cpp hljs">REQUIRE(<span class="hljs-string"><span class="hljs-string">"taken"</span></span> == sobj.scenario().stored_state_name(<span class="hljs-string"><span class="hljs-string">"take_when_free"</span></span>, <span class="hljs-string"><span class="hljs-string">"fork"</span></span>));</code> </pre> <br>  Es decir  le pedimos el script: denos el nombre que se guard√≥ con el marcador de la bifurcaci√≥n para el paso llamado take_when_free, y luego compare el nombre con el valor esperado. <br><br>  Aqu√≠, quiz√°s, es todo lo que se podr√≠a notar en el caso de prueba para el agente de Fork.  Si los lectores tienen alguna pregunta, pregunte en los comentarios, le responderemos con gusto. <br><br><h3>  Prueba de gui√≥n exitosa para fil√≥sofo </h3><br>  Para el agente de Philosopher, consideraremos solo un caso de prueba, para el caso en que Philosopher puede tomar ambos tenedores y comer. <br><br>  Este caso de prueba se ver√° as√≠: <br><br><pre> <code class="cpp hljs">TEST_CASE( <span class="hljs-string"><span class="hljs-string">"philosopher (takes both forks)"</span></span> ) { tests::<span class="hljs-keyword"><span class="hljs-keyword">testing_env_t</span></span> sobj{ [](so_5::<span class="hljs-keyword"><span class="hljs-keyword">environment_params_t</span></span> &amp; params) { params.message_delivery_tracer( so_5::msg_tracing::std_cout_tracer()); } }; so_5::<span class="hljs-keyword"><span class="hljs-keyword">agent_t</span></span> * philosopher{}; so_5::<span class="hljs-keyword"><span class="hljs-keyword">agent_t</span></span> * left_fork{}; so_5::<span class="hljs-keyword"><span class="hljs-keyword">agent_t</span></span> * right_fork{}; sobj.environment().introduce_coop([&amp;](so_5::<span class="hljs-keyword"><span class="hljs-keyword">coop_t</span></span> &amp; coop) { left_fork = coop.make_agent&lt;<span class="hljs-keyword"><span class="hljs-keyword">fork_t</span></span>&gt;(); right_fork = coop.make_agent&lt;<span class="hljs-keyword"><span class="hljs-keyword">fork_t</span></span>&gt;(); philosopher = coop.make_agent&lt;<span class="hljs-keyword"><span class="hljs-keyword">philosopher_t</span></span>&gt;( <span class="hljs-string"><span class="hljs-string">"philosopher"</span></span>, left_fork-&gt;so_direct_mbox(), right_fork-&gt;so_direct_mbox()); }); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> scenario = sobj.scenario(); scenario.define_step(<span class="hljs-string"><span class="hljs-string">"stop_thinking"</span></span>) .when( *philosopher &amp; tests::reacts_to&lt;<span class="hljs-keyword"><span class="hljs-keyword">philosopher_t</span></span>::msg_stop_thinking&gt;() &amp; tests::store_state_name(<span class="hljs-string"><span class="hljs-string">"philosopher"</span></span>) ) .constraints( tests::not_before(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::chrono::milliseconds(<span class="hljs-number"><span class="hljs-number">250</span></span>)) ); scenario.define_step(<span class="hljs-string"><span class="hljs-string">"take_left"</span></span>) .when( *left_fork &amp; tests::reacts_to&lt;msg_take&gt;() ); scenario.define_step(<span class="hljs-string"><span class="hljs-string">"left_taken"</span></span>) .when( *philosopher &amp; tests::reacts_to&lt;msg_taken&gt;() &amp; tests::store_state_name(<span class="hljs-string"><span class="hljs-string">"philosopher"</span></span>) ); scenario.define_step(<span class="hljs-string"><span class="hljs-string">"take_right"</span></span>) .when( *right_fork &amp; tests::reacts_to&lt;msg_take&gt;() ); scenario.define_step(<span class="hljs-string"><span class="hljs-string">"right_taken"</span></span>) .when( *philosopher &amp; tests::reacts_to&lt;msg_taken&gt;() &amp; tests::store_state_name(<span class="hljs-string"><span class="hljs-string">"philosopher"</span></span>) ); scenario.define_step(<span class="hljs-string"><span class="hljs-string">"stop_eating"</span></span>) .when( *philosopher &amp; tests::reacts_to&lt;<span class="hljs-keyword"><span class="hljs-keyword">philosopher_t</span></span>::msg_stop_eating&gt;() &amp; tests::store_state_name(<span class="hljs-string"><span class="hljs-string">"philosopher"</span></span>) ) .constraints( tests::not_before(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::chrono::milliseconds(<span class="hljs-number"><span class="hljs-number">250</span></span>)) ); scenario.define_step(<span class="hljs-string"><span class="hljs-string">"return_forks"</span></span>) .when_all( *left_fork &amp; tests::reacts_to&lt;msg_put&gt;(), *right_fork &amp; tests::reacts_to&lt;msg_put&gt;() ); scenario.run_for(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::chrono::seconds(<span class="hljs-number"><span class="hljs-number">1</span></span>)); REQUIRE(tests::completed() == scenario.result()); REQUIRE(<span class="hljs-string"><span class="hljs-string">"wait_left"</span></span> == scenario.stored_state_name(<span class="hljs-string"><span class="hljs-string">"stop_thinking"</span></span>, <span class="hljs-string"><span class="hljs-string">"philosopher"</span></span>)); REQUIRE(<span class="hljs-string"><span class="hljs-string">"wait_right"</span></span> == scenario.stored_state_name(<span class="hljs-string"><span class="hljs-string">"left_taken"</span></span>, <span class="hljs-string"><span class="hljs-string">"philosopher"</span></span>)); REQUIRE(<span class="hljs-string"><span class="hljs-string">"eating"</span></span> == scenario.stored_state_name(<span class="hljs-string"><span class="hljs-string">"right_taken"</span></span>, <span class="hljs-string"><span class="hljs-string">"philosopher"</span></span>)); REQUIRE(<span class="hljs-string"><span class="hljs-string">"thinking"</span></span> == scenario.stored_state_name(<span class="hljs-string"><span class="hljs-string">"stop_eating"</span></span>, <span class="hljs-string"><span class="hljs-string">"philosopher"</span></span>)); }</code> </pre> <br>  Bastante voluminoso, pero trivial.  Primero, verifique que Philosopher haya terminado de pensar y haya comenzado a prepararse para la comida.  Luego verificamos que trat√≥ de tomar el tenedor izquierdo.  A continuaci√≥n, debe intentar tomar el tenedor correcto.  Entonces deber√≠a comer y detener esta actividad.  Luego debe poner los dos tenedores tomados. <br><br>  En general, todo es simple.  Pero debes concentrarte en dos cosas. <br><br>  Primero, la clase testing_env_t, como su prototipo, wrap_env_t, le permite personalizar el entorno SObjectizer.  Usaremos esto para habilitar el mecanismo de rastreo de entrega de mensajes: <br><br><pre> <code class="cpp hljs">tests::<span class="hljs-keyword"><span class="hljs-keyword">testing_env_t</span></span> sobj{ [](so_5::<span class="hljs-keyword"><span class="hljs-keyword">environment_params_t</span></span> &amp; params) { params.message_delivery_tracer( so_5::msg_tracing::std_cout_tracer()); } };</code> </pre> <br>  Este mecanismo le permite "visualizar" el proceso de entrega de mensajes, lo que ayuda en la investigaci√≥n del comportamiento del agente (ya <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">hablamos</a> de esto con <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">m√°s detalle</a> ). <br><br>  En segundo lugar, el agente Fil√≥sofo realiza una serie de acciones no inmediatamente, sino despu√©s de un tiempo.  Entonces, comenzando a funcionar, el agente debe enviarse un mensaje StopThinking pendiente.  Entonces, este mensaje deber√≠a llegar al agente despu√©s de unos pocos milisegundos.  Lo que indicamos al establecer la restricci√≥n necesaria para un determinado paso: <br><br><pre> <code class="cpp hljs">scenario.define_step(<span class="hljs-string"><span class="hljs-string">"stop_thinking"</span></span>) .when( *philosopher &amp; tests::reacts_to&lt;<span class="hljs-keyword"><span class="hljs-keyword">philosopher_t</span></span>::msg_stop_thinking&gt;() &amp; tests::store_state_name(<span class="hljs-string"><span class="hljs-string">"philosopher"</span></span>) ) .constraints( tests::not_before(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::chrono::milliseconds(<span class="hljs-number"><span class="hljs-number">250</span></span>)) );</code> </pre> <br>  Es decir  Aqu√≠ decimos que no estamos interesados ‚Äã‚Äãen ninguna reacci√≥n del agente Fil√≥sofo a StopThinking, sino solo en lo que ocurri√≥ no antes de 250 ms despu√©s del inicio del procesamiento de este paso. <br><br>  Una restricci√≥n del tipo not_before le dice al script que todos los eventos que ocurren antes de que expire el tiempo de espera especificado deben ser ignorados. <br><br>  Tambi√©n hay una restricci√≥n de la forma not_after, funciona al rev√©s: solo se tienen en cuenta los eventos que ocurren hasta que el tiempo de espera especificado ha expirado. <br><br>  Las restricciones not_before y not_after se pueden combinar, por ejemplo: <br><br><pre> <code class="cpp hljs">.constraints( tests::not_before(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::chrono::milliseconds(<span class="hljs-number"><span class="hljs-number">250</span></span>)), tests::not_after(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::chrono::milliseconds(<span class="hljs-number"><span class="hljs-number">1250</span></span>)))</code> </pre> <br>  pero en este caso, SObjectizer no verifica la consistencia de los valores dados. <br><br><h1>  ¬øC√≥mo lograste implementar esto? </h1><br>  Me gustar√≠a decir algunas palabras sobre c√≥mo todo funcion√≥.  Despu√©s de todo, en general, nos enfrentamos con una gran pregunta ideol√≥gica: "¬øC√≥mo evaluar a los agentes en principio?"  y una pregunta m√°s peque√±a, ya t√©cnica: "¬øC√≥mo implementar esto?" <br><br>  Y si sobre la ideolog√≠a de prueba fue posible salir de su mente, entonces sobre la implementaci√≥n, la situaci√≥n fue m√°s complicada.  Era necesario encontrar una soluci√≥n que, en primer lugar, no requiriera una alteraci√≥n radical de los interiores de SObjectizer.  Y, en segundo lugar, se supon√≠a que era una soluci√≥n que podr√≠a implementarse en el corto plazo previsible y, muy deseable. <br><br>  Como resultado del dif√≠cil proceso de fumar bamb√∫, se encontr√≥ una soluci√≥n.  Para esto, se requer√≠a, de hecho, hacer una peque√±a innovaci√≥n en el comportamiento regular de SObjectizer.  Y la base de la soluci√≥n es el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">mecanismo del sobre</a> del <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">mensaje, que se agreg√≥ en la versi√≥n 5.5.23 y del que ya hemos hablado</a> . <br><br>  Dentro del entorno de prueba, cada mensaje enviado est√° envuelto en un sobre especial.  Cuando se entrega un sobre con un mensaje al agente para su procesamiento (o, por el contrario, el agente lo rechaza), el escenario de prueba se da cuenta de esto.  Gracias a los sobres, el gui√≥n de prueba sabe lo que est√° sucediendo y puede determinar los momentos en que los pasos del gui√≥n "funcionan". <br><br>  Pero, ¬øc√≥mo hacer que SObjectizer envuelva cada mensaje en un sobre especial? <br><br>  Esa fue una pregunta interesante.  Decidi√≥ lo siguiente: se invent√≥ un concepto como <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">event_queue_hook</a> .  Este es un objeto especial con dos m√©todos: on_bind y on_unbind. <br><br>  Cuando un agente est√° vinculado a un despachador espec√≠fico, el despachador emite un agente event_queue al agente.  A trav√©s de este event_queue, las solicitudes del agente entran en la cola necesaria y est√°n disponibles para el despachador para su procesamiento.  Cuando un agente se ejecuta dentro de un SObjectizer, tiene un puntero a event_queue.  Cuando un agente se elimina de un SObjectizer, su puntero a event_queue se anula. <br><br>  Entonces, comenzando con la versi√≥n 5.5.24, el agente, al recibir event_queue, debe llamar al m√©todo on_bind de event_queue_hook.  Donde el agente debe pasar el puntero recibido a event_queue.  Y event_queue_hook puede devolver el mismo puntero u otro puntero en respuesta.  Y el agente debe usar el valor devuelto. <br><br>  Cuando un agente se elimina de un SObjectizer, debe llamar a on_unbind en event_queue_hook.  En on_unbind, el agente pasa el valor devuelto por el m√©todo on_bind. <br><br>  Toda esta cocina se ejecuta dentro del SObjectizer y el usuario no ve nada de esto.  Y, en principio, es posible que no sepa sobre esto en absoluto.  Pero el entorno de prueba de SObjectizer, el mismo testing_env_t, explota exactamente event_queue_hook.  Dentro de testing_env_t, se crea una implementaci√≥n especial de event_queue_hook.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Esta implementaci√≥n en on_bind envuelve cada event_queue en un objeto proxy especial. </font><font style="vertical-align: inherit;">Y ya este objeto proxy coloca los mensajes enviados al agente en un sobre especial.</font></font><br><br>  Pero eso no es todo.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Puede recordar que en un entorno de prueba, los agentes deben congelarse. </font><font style="vertical-align: inherit;">Esto tambi√©n se implementa a trav√©s de los objetos proxy mencionados. </font><font style="vertical-align: inherit;">Mientras el script de prueba no se est√° ejecutando, el objeto proxy almacena los mensajes enviados al agente en casa. </font><font style="vertical-align: inherit;">Pero cuando se ejecuta el script, el objeto proxy transfiere todos los mensajes acumulados previamente a la cola de mensajes actual del agente.</font></font><br><br><h1>  Conclusi√≥n </h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En conclusi√≥n, quiero decir dos cosas. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En primer lugar, implementamos nuestra opini√≥n sobre c√≥mo se pueden probar los agentes en SObjectizer. Mi opini√≥n porque no hay tantos buenos modelos a seguir. Miramos hacia </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Akka</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;">Pruebas</font></a><font style="vertical-align: inherit;"> . Pero Akka y SObjectizer son </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">demasiado diferentes</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> para portar los enfoques que funcionan en Akka a SObjectizer. Y C ++ no es Scala / Java, en el que se pueden hacer algunas cosas relacionadas con la introspecci√≥n debido a la reflexi√≥n. As√≠ que tuve que idear un enfoque que recaer√≠a en SObjectizer.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En la versi√≥n 5.5.24, la primera implementaci√≥n experimental estuvo disponible. Seguramente puedes hacerlo mejor. ¬øPero c√≥mo entender qu√© ser√° √∫til y cu√°les son fantas√≠as in√∫tiles? Lamentablemente, nada. Tienes que tomar y probar, ver qu√© pasa en la pr√°ctica. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As√≠ que creamos una versi√≥n m√≠nima que puedes tomar y probar. Lo que proponemos hacer por todos: probar, experimentar y compartir sus impresiones con nosotros. ¬øQu√© te gust√≥, qu√© no te gust√≥? Tal vez algo falta? </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En segundo lugar, las palabras que se dijeron </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">a principios de 2017 se</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> hicieron a√∫n m√°s relevantes </font><font style="vertical-align: inherit;">:</font></font><br><blockquote> ‚Ä¶       ,   ,   ,    .      -      ‚Äî      .             .      . :  ,   . <br><br>    ,  ,   ,       ‚Äî    ,           . <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Por lo tanto, mi consejo para aquellos que buscan un marco de actor listo: preste atenci√≥n no solo a la originalidad de las ideas y la belleza de los ejemplos. </font><font style="vertical-align: inherit;">Observe tambi√©n todo tipo de elementos auxiliares que lo ayudar√°n a descubrir qu√© est√° sucediendo en su aplicaci√≥n: por ejemplo, averig√ºe cu√°ntos actores hay dentro, cu√°les son sus tama√±os de cola, si el mensaje no llega al destinatario, entonces a d√≥nde va ... Si el marco lo hace proporciona algo as√≠, ser√° m√°s f√°cil para ti. </font><font style="vertical-align: inherit;">Si no es as√≠, tendr√° m√°s trabajo.</font></font><br></blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Todo lo anterior es a√∫n m√°s importante cuando se trata de probar actores. </font><font style="vertical-align: inherit;">Por lo tanto, al elegir un marco de actor para usted, preste atenci√≥n a lo que contiene y lo que no. </font><font style="vertical-align: inherit;">Por ejemplo, ya tenemos en nuestro kit de herramientas para simplificar las pruebas :)</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es435606/">https://habr.com/ru/post/es435606/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es435592/index.html">Azores: √∫ltima reserva de flora en medio del oc√©ano Atl√°ntico</a></li>
<li><a href="../es435594/index.html">Gr√°fico de ruta para Apache Camel</a></li>
<li><a href="../es435600/index.html">C√≥mo migrar a otro operador m√≥vil y no ir a la bancarrota (para propietarios de iOS)</a></li>
<li><a href="../es435602/index.html">Preparaci√≥n del examen de Azure</a></li>
<li><a href="../es435604/index.html">BlaBlaCar se convirti√≥ en lo que no estaba destinado</a></li>
<li><a href="../es435608/index.html">Pantallas de bricolaje</a></li>
<li><a href="../es435610/index.html">Huevos de Pascua para ZX Spectrum - en el √°lbum de m√∫sica y pel√≠cula</a></li>
<li><a href="../es435612/index.html">¬øConf√≠a en Codd o en sus instalaciones?</a></li>
<li><a href="../es435614/index.html">Rust News # 4 (diciembre de 2018)</a></li>
<li><a href="../es435616/index.html">C√≥mo la zonificaci√≥n entre pares simplific√≥ nuestras vidas y ayud√≥ a equilibrar la carga de EMC VPLEX</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>