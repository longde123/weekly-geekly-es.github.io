<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>💪🏻 ☸️ 🧞 Konsep kain persisten untuk mengendalikan infrastruktur TI 🚽 🐂 🚲</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Halo semuanya. Saya akan memberi tahu Anda tentang layanan microser, tetapi dari sudut pandang yang sedikit berbeda dari Vadim Madison di postingan “A...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Konsep kain persisten untuk mengendalikan infrastruktur TI</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/oleg-bunin/blog/462937/"><p>  Halo semuanya.  Saya akan memberi tahu Anda tentang layanan microser, tetapi dari sudut pandang yang sedikit berbeda dari Vadim Madison di postingan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">“Apa yang kita ketahui tentang layanan microser”</a> .  Secara umum, saya menganggap diri saya seorang pengembang basis data.  Apa hubungan microservices dengan itu?  Avito menggunakan: Vertica, PostgreSQL, Redis, MongoDB, Tarantool, VoltDB, SQLite ... Secara total, kami memiliki 456+ database untuk 849+ layanan.  Dan entah bagaimana Anda harus hidup dengannya. </p><br><p>  Dalam posting ini saya akan memberi tahu Anda tentang bagaimana kami mengimplementasikan penemuan data dalam arsitektur microservice.  Posting ini adalah transkrip gratis laporan saya dengan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Highload ++ 2018</a> , videonya dapat dilihat di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> . </p><br><p><img src="https://habrastorage.org/webt/bj/wt/e3/bjwte39wtxw3c5gk5w-1bfu_hfk.png"></p><a name="habracut"></a><br><p>  Setiap orang harus tahu bagaimana arsitektur microservice harus dibangun dalam hal basis.  Berikut adalah pola yang biasanya dimulai oleh setiap orang.  Ada pangkalan bersama antara layanan.  Pada slide, persegi panjang oranye adalah layanan, ada basis bersama di antara mereka. </p><br><p><img src="https://habrastorage.org/webt/vc/t7/xw/vct7xwnbj875pu2fusp_xaahcwg.png"></p><br><p>  Anda tidak dapat hidup seperti itu, karena Anda tidak dapat menguji layanan secara terpisah ketika, selain komunikasi langsung di antara mereka, ada juga komunikasi melalui database.  Satu permintaan layanan dapat memperlambat layanan lainnya.  Ini buruk. </p><br><p><img src="https://habrastorage.org/webt/fv/ax/ze/fvaxzevgnmj7lkfqehybl1jv7uc.png"></p><br><p>  Dari sudut pandang bekerja dengan basis data untuk arsitektur layanan mikro, pola DataBase-per-Layanan harus digunakan - setiap layanan memiliki basis datanya sendiri.  Jika ada banyak pecahan dalam basis data, maka pangkalan tersebut harus dibagi sehingga mereka bersinkronisasi.  Ini adalah teori, tetapi kenyataannya tidak demikian. </p><br><p><img src="https://habrastorage.org/webt/il/pt/yz/ilptyzfojo0wsiclxhggpj47mag.png"></p><br><p>  Dalam perusahaan nyata, mereka tidak hanya menggunakan layanan mikro, tetapi juga monolit.  Ada layanan yang ditulis dengan benar.  Dan ada layanan lama yang masih menggunakan pola dasar umum. </p><br><p>  Vadim Madison pada presentasinya menunjukkan gambar ini dengan keterhubungan.  Hanya dia yang menunjukkannya tanpa satu komponen, dan jaringan di dalamnya seragam.  Di jaringan ini di tengah ada titik yang terhubung ke banyak titik (layanan microser).  Ini adalah monolit.  Ini kecil dalam diagram.  Namun faktanya, monolit itu besar.  Ketika kita berbicara tentang perusahaan nyata, maka Anda perlu memahami nuansa koeksistensi layanan-mikro, lahir, dan keluar, tetapi arsitektur monolitik masih penting. </p><br><p>  Bagaimana cara monolith menulis ulang ke arsitektur layanan mikro di tingkat perencanaan?  Tentu saja, ini adalah pemodelan domain.  Di mana-mana dikatakan bahwa Anda perlu melakukan pemodelan domain.  Tetapi, misalnya, kami di Avito selama beberapa tahun menciptakan layanan microser tanpa pemodelan domain.  Lalu saya mengambilnya dan pengembang basis data.  Kami menyadari aliran data yang lengkap.  Pengetahuan ini membantu merancang model domain. </p><br><p><img src="https://habrastorage.org/webt/wr/kk/qa/wrkkqaxqq5wd-2gwilprpsroqhm.png"></p><br><p>  Penemuan data memiliki interpretasi klasik - ini adalah cara bekerja dengan data yang tersebar di penyimpanan yang berbeda untuk mengarah pada kesimpulan agregat dan membuat kesimpulan yang benar.  Ini sebenarnya semua omong kosong pemasaran.  Definisi-definisi ini adalah tentang cara mengunduh semua data dari layanan microser ke penyimpanan.  Tentang ini saya punya laporan beberapa tahun yang lalu, kami tidak akan memikirkan ini. </p><br><p>  Saya akan memberi tahu Anda tentang proses lain yang lebih dekat dengan proses beralih ke layanan-mikro.  Saya ingin menunjukkan cara bagaimana Anda dapat memahami kompleksitas sistem yang terus berkembang dalam hal data, dalam hal layanan-layanan mikro.  Di mana bisa melihat seluruh gambar ratusan layanan, pangkalan, tim, orang?  Sebenarnya, pertanyaan ini adalah ide utama dari laporan tersebut. </p><br><p><img src="https://habrastorage.org/webt/uw/_a/l7/uw_al7h6mh9otso2s6sxie3fzhs.png"></p><br><p>  Agar tidak mati dalam arsitektur layanan mikro ini, Anda memerlukan kembaran digital.  Perusahaan Anda adalah totalitas dari segala sesuatu yang menyediakan infrastruktur teknologi.  Anda perlu membuat gambar yang memadai dari semua kesulitan ini, atas dasar yang Anda dapat dengan cepat menyelesaikan masalah.  Dan ini bukan repositori analitik. </p><br><p><img src="https://habrastorage.org/webt/85/hf/p_/85hfp_vxlagi-frp4cwssioo_eg.png"></p><br><p>  Tugas apa yang bisa kita atur untuk kembar digital seperti itu?  Bagaimanapun, semuanya dimulai dengan penemuan data paling sederhana. </p><br><p>  <strong>Pertanyaan:</strong> </p><br><ul><li>  Layanan apa yang menyimpan data penting? </li><li>  Di mana data pribadi tidak disimpan? </li><li>  Anda memiliki ratusan pangkalan.  Apa data pribadi yang ada?  Dan di mana tidak? </li><li>  Bagaimana aliran data penting antar layanan? </li><li>  Misalnya, layanan tidak memiliki data pribadi, dan kemudian dia mulai mendengarkan bus, dan mereka muncul.  Di mana data disalin saat dihapus? </li><li>  Siapa yang bisa bekerja dengan data apa? </li><li>  Siapa yang dapat mengakses langsung melalui layanan, beberapa melalui database, beberapa melalui bus? </li><li>  Siapa yang melalui layanan lain dapat menarik pegangan API (permintaan) dan mengunduh sesuatu? </li></ul><br><p>  Jawaban atas pertanyaan-pertanyaan ini hampir selalu berupa grafik elemen, grafik hubungan.  Grafik ini perlu diisi, diperbarui, dan dipelihara dengan data segar.  Kami memutuskan untuk menyebut grafik ini Persistent Fabric (dalam terjemahan - kain ingat).  Ini visualisasinya. </p><br><p><img src="https://habrastorage.org/webt/9l/qx/fg/9lqxfghwxvo7qdyfpvbz5zyj1m0.png"></p><br><p>  Mari kita lihat apa yang ada di dalam kain mengingat ini. </p><br><p>  <strong>Titik antarmuka</strong> .  Ini adalah elemen interaksi pengguna dengan antarmuka grafis.  Mungkin ada beberapa titik UI pada satu halaman.  Ini, secara relatif, tindakan kunci khusus. </p><br><p>  <strong>Titik akhir</strong> .  UI menunjukkan titik akhir brengsek.  Dalam tradisi Rusia, ini disebut pena.  Menangani layanan.  Endpoint menarik layanan. </p><br><p>  <strong>Layanan</strong>  Ratusan layanan.  Layanan saling terhubung.  Kami memahami layanan mana yang dapat menarik layanan.  Kami memahami panggilan ke titik UI mana yang dapat memanggil layanan mana dalam rantai. </p><br><p>  <strong>Basis (dalam arti logis)</strong> .  Basis sebagai istilah penyimpanan kedengarannya buruk, karena istilah ini merujuk pada sesuatu yang analitis.  Sekarang kami menganggap database sebagai penyimpanan.  Misalnya, Redis, PostgreSQL, Tarantool.  Jika suatu layanan menggunakan basis data, biasanya menggunakan beberapa basis data. </p><br><ul><li>  Untuk penyimpanan data jangka panjang, misalnya, PostgreSQL. </li><li>  Redis digunakan sebagai cache. </li><li>  Tarantool, yang dapat dengan cepat menghitung sesuatu dalam aliran data. </li></ul><br><p>  <strong>Tuan rumah</strong>  Basis data memiliki penyebaran ke host.  Satu markas, satu Redis sebenarnya dapat hidup di 16 mesin (master ring) dan 16 slave lainnya.  Ini memberikan pemahaman tentang server mana yang Anda butuhkan untuk membatasi akses sehingga beberapa data penting tidak bocor. </p><br><p>  <strong>Entitas</strong> .  Entitas disimpan dalam database.  Contoh entitas: pengguna, pengumuman, pembayaran.  Entitas dapat disimpan dalam beberapa basis data.  Dan di sini penting bukan hanya untuk mengetahui bahwa entitas ini ada di sana.  Penting untuk mengetahui bahwa entitas ini memiliki satu penyimpanan menjadi Sumber Emas.  Sumber Emas adalah basis tempat entitas dibuat dan diedit.  Semua basis lainnya adalah cache fungsional.  Poin penting.  Jika, Tuhan melarang, suatu entitas memiliki dua Sumber Emas, maka koordinasi yang melelahkan dari sumber-sumber yang terpisah diperlukan.  Entitas yang ada di database harus diberi akses ke layanan jika kita ingin memperkaya layanan ini dengan fungsionalitas baru. </p><br><p>  <strong>Tim</strong> .  Tim yang memiliki layanan.  Layanan yang bukan milik tim adalah layanan yang buruk.  Sulit baginya untuk menemukan seseorang yang bertanggung jawab. </p><br><p>  Sekarang saya akan sangat berkorelasi dengan laporan Vadim Madison, karena ia menyebutkan bahwa layanan tersebut mencerminkan orang yang membuat komitmen terakhir di sana.  Ini adalah titik awal yang baik.  Tetapi dalam jangka panjang, ini buruk, karena orang yang terakhir berkomitmen di sana dapat berhenti. </p><br><p>  Karena itu, Anda perlu mengetahui tim, orang-orang di dalamnya, dan peran mereka.  Kami telah mendapatkan grafik sederhana, di mana pada setiap lapisan ada beberapa ratus elemen.  Apakah Anda tahu sistem di mana semua ini dapat disimpan? </p><br><p>  Poin kuncinya.  Agar Persistent Fabric ini hidup, ia tidak boleh hanya diisi satu kali.  Layanan dibuat, mereka mati, penyimpanan dialokasikan, mereka bergerak di sekitar server, tim dibuat, rusak, orang-orang beralih ke tim lain.  Entitas baru, ditambahkan ke layanan baru, dihapus.  Titik akhir dibuat, terdaftar, lintasan pengguna dari sudut pandang GUI juga dibangun kembali.  Yang paling penting adalah bahwa Anda tidak perlu menyimpannya di suatu tempat secara teknis.  Yang paling penting adalah membuat setiap lapisan Kain Persisten segar dan mutakhir.  Itu diperbarui. </p><br><p>  Saya mengusulkan untuk berjalan melalui lapisan.  Saya akan menggambarkan bagaimana kita melakukannya.  Saya akan menunjukkan bagaimana ini dapat dilakukan pada tingkat lapisan individu. </p><br><p><img src="https://habrastorage.org/webt/pw/yn/s1/pwyns16y-x0hlef3sbs3ue3ljry.png"></p><br><p>  Informasi tentang tim dapat diambil dari struktur organisasi 1C.  Di sini saya ingin menggambarkan bahwa Kain Persisten tidak perlu mengisi seluruh grafik raksasa untuk diisi.  Setiap lapisan harus diisi dengan benar. </p><br><p><img src="https://habrastorage.org/webt/qp/xs/we/qpxswe2pdci_ztpaiogokjmdhdu.png"></p><br><p>  Informasi tentang orang dapat diambil dari LDAP.  Satu orang dapat mengambil peran berbeda dalam tim yang berbeda.  Ini sangat normal.  Sekarang kami telah membuat sistem People Avito dan dari situ kami mengambil ikatan orang ke tim dan peran mereka.  Yang paling penting adalah data sederhana tersebut pergi sehingga setidaknya mereka menyimpan tautan ke ujung tautan, sehingga nama tim sesuai dengan tim dari struktur organisasi 1C. </p><br><p><img src="https://habrastorage.org/webt/am/zp/l1/amzpl1b-c9bxgfyraff5hszrh_8.png"></p><br><p>  <strong>Layanan</strong>  Untuk layanan, Anda perlu mendapatkan nama dan tim yang memilikinya.  Sumbernya adalah Service Discovery.  Ini adalah sistem yang disebutkan Vadim Madison dengan nama Atlas.  Atlas adalah daftar umum layanan. </p><br><p>  Sangat berguna untuk memahami bahwa hampir semua sistem seperti Atlas menyimpan informasi tentang 95% layanan.  5% layanan dalam sistem seperti itu tidak ada, karena  layanan lama dibuat tanpa registrasi di Atlas.  Dan ketika Anda mulai bekerja dengan skema ini, Anda merasakan apa yang Anda lewatkan. </p><br><p><img src="https://habrastorage.org/webt/1e/vc/mo/1evcmoycczxblnbdje8pb3jgbto.png"></p><br><p>  <strong>Penyimpanan</strong> adalah repositori generik.  Itu bisa PostgreSQL, MongoDB, Memcache, Vertica.  Kami memiliki beberapa sumber untuk Penemuan Penyimpanan.  Database NoSQL menggunakan setengah dari Atlas mereka sendiri.  Untuk informasi tentang database PostgreSQL, parsing yaml digunakan.  Tetapi mereka ingin membuat Storage Discovery mereka lebih benar. </p><br><p><img src="https://habrastorage.org/webt/uk/kd/e_/ukkde_ys0c44uyk6wexiycnxlsw.png"></p><br><p>  Jadi, penyimpanan dan informasi tentang apa yang menggunakan layanan, baik, atau memiliki (ini adalah jenis yang berbeda) penyimpanan.  Lihat, semua yang saya jelaskan, pada prinsipnya, cukup sederhana, dapat diisi bahkan di Google Sheets. </p><br><p>  Apa yang bisa dilakukan dengan ini?  Mari kita bayangkan bahwa ini adalah grafik.  Bagaimana cara kerjanya dengan grafik?  Tambahkan ke basis grafik.  Misalnya, dalam Neo4j.  Ini sudah merupakan contoh dari kueri nyata dan contoh hasil dari kueri ini. </p><br><p><img src="https://habrastorage.org/webt/-3/oi/df/-3oidf3lu-h4wxgov4-rwjqequq.png"></p><br><p>  Skenario pertama.  Kami perlu mengeluarkan hak untuk pangkalan.  Pangkalan harus benar-benar dalam pelayanan.  Ini harus mencakup hanya layanan ini dan hanya anggota tim yang memiliki layanan.  Tapi kita hidup di dunia nyata.  Cukup sering, tim lain merasa perlu untuk pergi ke pangkalan layanan lain.  Pertanyaan: siapa yang bertanya tentang pemberian hak?  Masalah yang sangat besar adalah ratusan pangkalan untuk memahami siapa yang bertanggung jawab.  Terlepas dari kenyataan bahwa siapa yang membuatnya, berhenti dulu, atau dipindahkan ke posisi lain, atau tidak ingat sama sekali siapa yang bekerja dengannya. </p><br><p>  Dan di sini adalah permintaan grafik paling sederhana (Neo4j).  Anda membutuhkan akses ke penyimpanan.  Anda beralih dari penyimpanan ke layanan yang memilikinya.  Pergi ke tim yang memiliki layanan.  Selanjutnya untuk layanan ini, Anda akan mengetahui siapa yang dimiliki tim TechLead ini.  Di Avito, tim produk memiliki manajer teknis dan manajer produk yang tidak dapat membantu dengan pangkalan.  Hanya setengah dari permintaan yang benar-benar ditampilkan pada slide.  Akses ke penyimpanan bukan operasi atom.  Untuk mengakses penyimpanan, Anda perlu mengakses server tempat penyimpanannya.  Ini adalah tugas terpisah yang agak menarik. </p><br><p><img src="https://habrastorage.org/webt/jh/tr/mj/jhtrmjkc8podppfie6bfqe5eje8.png"></p><br><p>  Untuk mengatasinya, kami menambahkan entitas baru.  Ini adalah instalasi.  Inilah masalah terminologisnya.  Ada penyimpanan, misalnya pangkalan Redis (redis: address).  Ada host - bisa berupa mesin fisik, wadah lxc, kubernetes.  Menginstal penyimpanan di host yang kita sebut Instance. </p><br><p>  Itu dapat memiliki empat instalasi pada tiga host, seperti yang ditunjukkan pada contoh di atas.  Penyimpanan untuk produksi sebaiknya dipasang pada mesin fisik yang terpisah untuk meningkatkan kinerja.  Untuk lingkungan dev, yang harus Anda lakukan adalah menginstal pada satu host dan menetapkan port yang berbeda untuk Redis. </p><br><p><img src="https://habrastorage.org/webt/t6/zl/pf/t6zlpfpuqnhzojgr9csffdljnji.png"></p><br><p>  Permintaan pertama untuk penerbitan hak ke pangkalan pergi ke kepala.  Kepala menegaskan bahwa hak dapat diberikan. </p><br><p>  Berikutnya adalah bagian kedua dari permintaan.  Permintaan kedua dari penyimpanan pergi ke instance dan host.  Permintaan ini mempertimbangkan semua instalasi untuk lingkungan yang sesuai.  Pada slide adalah contoh untuk lingkungan produksi.  Berdasarkan hal ini, hak untuk terhubung ke host tertentu dan port spesifik sudah dikeluarkan.  Ini adalah contoh permintaan hibah untuk karyawan non-tim. </p><br><p><img src="https://habrastorage.org/webt/dz/aq/hk/dzaqhkkreobrnhfdyivpq078vha.png"></p><br><p>  Pertimbangkan sebuah contoh ketika sebuah tim perlu mengambil karyawan baru.  Ia perlu diberikan akses (untuk pemula - hanya baca) ke semua layanan, ke semua penyimpanan perintah ini.  Pada slide, tim yang sebenarnya dengan pilihan yang tidak lengkap.  Lingkaran hijau adalah pemimpin tim.  Lingkaran merah muda adalah tim.  Kuning adalah layanan.  Sejumlah layanan kuning memiliki penyimpanan biru.  Yang abu-abu adalah tuan rumah.  Violet adalah instalasi penyimpanan di host.  Ini adalah contoh untuk unit kecil.  Tetapi ada banyak unit yang layanannya bukan 7, tetapi 27. Untuk unit seperti itu, gambarnya akan besar.  Jika Anda menggunakan Persistent Fabric, Anda dapat membuat permintaan di dalamnya dan mendapatkan jawaban dalam daftar. </p><br><p><img src="https://habrastorage.org/webt/40/-v/tv/40-vtvltatfneyrxw7qhfbw10cs.png"></p><br><p>  Mari terus mengisi bahan pintar kami dan berbicara tentang entitas bisnis.  Entitas di Avito adalah pengumuman, pengguna, pembayaran, dan sebagainya.  Dari publikasi saya ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">HP Vertica, merancang gudang data</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">data besar</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Vertica + Anchor Modeling = mulai menumbuhkan jamur Anda</a> ) tentang gudang data, Anda tahu bahwa ada ratusan entitas ini di Avito.  Faktanya, semuanya tidak harus dicatat.  Dari mana saya bisa mendapatkan daftar entitas?  Dari repositori analitik.  Anda dapat mengunggah informasi tentang dari mana mereka mendapatkan entitas ini.  Pada tahap pertama, ini sudah cukup. </p><br><p>  Selanjutnya kami mengembangkan pengetahuan ini: untuk setiap entitas kami membuat daftar repositori di mana ia berada.  Kami juga menunjukkan bahwa penyimpanan menyimpan entitas sebagai cache atau penyimpanan menyimpan entitas sebagai Sumber Emas, yaitu, itu adalah sumber utamanya. </p><br><p><img src="https://habrastorage.org/webt/ly/z-/et/lyz-etcdkr_wuqrgxnuwwar6aec.png"></p><br><p>  Saat Anda mengisi kolom ini, Anda memiliki kesempatan untuk mengajukan permintaan.  Anda memiliki beberapa entitas, dan Anda perlu memahami: di layanan apa entitas itu hidup, di mana ia mencerminkan, di mana penyimpanan, di mana host itu diinstal?  Misalnya, saat memproses data pribadi, Anda perlu memusnahkan file log.  Untuk melakukan ini, sangat penting untuk memahami mesin fisik mana file log dapat tetap. </p><br><p><img src="https://habrastorage.org/webt/je/fm/ge/jefmgeljgwsrg5oqjckgqyfht8c.png"></p><br><p>  Slide menggambarkan permintaan sederhana untuk entitas imajiner.  Jumlah penyimpanan dikurangi sehingga grafik pas ke slide.  Lingkaran merah adalah entitas.  Lingkaran biru adalah pangkalan tempat entitas ini berada.  Sisanya seperti pada slide sebelumnya: lingkaran abu-abu adalah host, lingkaran ungu adalah instalasi penyimpanan pada host. </p><br><p>  Dengan demikian, jika Anda ingin melalui PCI DSS, Anda perlu membatasi akses ke entitas tertentu.  Untuk melakukan ini, Anda perlu membatasi akses ke lingkaran abu-abu.  Jika Anda membutuhkan akses waktu nyata, kami menutup akses ke lingkaran ungu.  Ini informasi statis. </p><br><p><img src="https://habrastorage.org/webt/_w/dy/tx/_wdytxhtuarcxx4v_elq4eckhpo.png"></p><br><p>  Ketika kita berbicara tentang arsitektur microservice, yang paling penting adalah bahwa itu berubah.  Penting untuk tidak hanya memiliki hubungan hirarkis antara entitas, tetapi juga hubungan saudara.  Banyak layanan adalah contoh dari koneksi tingkat tunggal, yang telah kami pompakan dengan baik dan gunakan.  Satu bundel dari bentuk "layanan panggilan layanan".  Ada informasi tentang panggilan langsung - layanan memanggil API dari layanan lain. </p><br><p>  Seharusnya juga ada informasi tentang koneksi formulir: layanan No. 1 mengirimkan acara ke bus (antrian), dan layanan No. 2 berlangganan ke acara ini.  Ini seperti koneksi lambat asinkron yang melewati bus.  Hubungan ini juga penting dalam hal pergerakan data.  Dengan menggunakan tautan seperti itu, Anda dapat memeriksa operasi layanan jika versi layanan yang mereka berlangganan telah berubah. </p><br><p><img src="https://habrastorage.org/webt/bx/wu/fe/bxwufe8rh4oqpya2apdmwjs6y7k.png"><br><img src="https://habrastorage.org/webt/o9/6b/zh/o96bzhtcwcpe6le99c5-j80xgk4.png"></p><br><p>  Ada entitas dan kita tahu bahwa itu disimpan dalam penyimpanan tertentu.  Jika kita mempertimbangkan masalah menemukan titik menggunakan entitas, maka kueri jelas yang muncul bersama kita adalah pemeriksaan perimeter.  Penyimpanan milik beberapa layanan.  Di mana entitas ini bisa bocor (disalin) dari perimeter?  Itu dapat bocor melalui panggilan layanan.  Layanan ini menghubungi, menerima, dan mempertahankan pengguna.  Itu bisa bocor melalui ban.  Ban dapat menghubungkan Anda satu sama lain menggunakan RabbitMQ, Londiste.  Pada slide Londiste, kami belum memuatnya.  Namun panggilan sudah dimuat. </p><br><p>  Berikut ini adalah contoh dari permintaan nyata: sebuah iklan, dua basis data tempat ia disimpan, dua layanan yang memiliki basis data ini.  Setelah tiga kolom adalah layanan yang bekerja dengan layanan yang memiliki entitas ini.  Ini adalah titik kebocoran potensial yang perlu ditambahkan. </p><br><p><img src="https://habrastorage.org/webt/f1/cu/hg/f1cuhgk8m_6zltf4vaolu54z1jg.png"></p><br><p>  Titik akhir.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Vadim menyebutkan</a> bahwa Anda dapat menggunakan dokumentasi untuk membangun registri layanan titik akhir.  Anda juga dapat memperoleh informasi ini dari pemantauan.  Jika Endpoint penting, maka pengembang sendiri akan menambahkannya ke pemantauan.  Jika Endpoint tidak dimonitor, maka kami tidak membutuhkannya. </p><br><p><img src="https://habrastorage.org/webt/sr/wu/pk/srwupkfwo41g8vdgo_i2-_oejum.png"></p><br><p>  Dengan demikian, metrik dapat diperoleh dari pemantauan.  Mengikat metrik ke penyimpanan, ke layanan, ke host, ke instance (basis data) dan titik akhir. </p><br><p><img src="https://habrastorage.org/webt/bu/sc/ec/buscec_nm5a9a5w3jy34_ke0u5y.png"></p><br><p>  Ketika Anda menemukan kegagalan, misalnya, titik akhir mengeluarkan kode HTTP 500, maka untuk melacak akar masalah, Anda perlu membuat permintaan untuk titik akhir ini.  Dari endpoint, pergi ke layanan, pergi ke layanan yang panggilan layanan ini, dari layanan pergi ke penyimpanan, dari penyimpanan pergi ke instance dan host. </p><br><p><img src="https://habrastorage.org/webt/m-/lx/hu/m-lxhubwizopmc8tevtkqaxexn4.png"></p><br><p>  Selanjutnya, jika Anda turun grafik ini, atas dasar itu Anda bisa mendapatkan daftar pengidentifikasi untuk pemantauan.  Anda dapat mencari titik akhir ini seluruh rantai ke bawah, yang dapat menyebabkan kegagalan.  Dalam arsitektur microservice, kegagalan di titik akhir dapat disebabkan oleh kegagalan jaringan pada beberapa server tempat satu basis data digunakan.  Hal ini dapat dilihat dalam pemantauan, tetapi dengan struktur layanan yang besar, sangat sulit untuk memeriksa semua layanan dalam pemantauan. </p><br><p><img src="https://habrastorage.org/webt/ti/qe/bx/tiqebxhp2cezstldxdblhhfj0ik.png"></p><br><p>  Pengujian.  Untuk menguji secara memadai layanan mikro, Anda perlu memeriksa layanan dengan layanan lain yang perlu berfungsi.  Anda perlu meningkatkan dalam lingkungan pengujian layanan yang dipanggil.  Dan untuk layanan yang dipanggil, naikkan semua pangkalan.  Dalam ingatan kita, kita mendapatkan subgraf yang terhubung.  Di kolom ini, tidak semua koneksi diperlukan, beberapa dapat diabaikan.  Subgraf ini dapat diisolasi beban diuji sebagai sistem tertutup sepenuhnya. </p><br><p>  Akan lebih baik sekarang untuk menunjukkan grafik entitas Avito, di mana subgraph terisolasi dari layanan mikro yang dapat ditingkatkan secara independen dapat diuji dan diluncurkan dalam produksi.  Faktanya, ternyata panggilan subgraph dari hampir semua layanan microser masuk dan keluar dari monolith.  —  ,          ,                    . </p><br><p>          ,    .       ,   .     .          . </p><br><p><img src="https://habrastorage.org/webt/9c/vw/o0/9cvwo0htj3q_rzayek1uqdmoivo.png"></p><br><p>   —  ,      .        . </p><br><ul><li>        .          .      .         .     storage.   — .   endpoint.     ,    ,      ..      . </li><li>          .       «»  .  , ,   ,  connection,  connection ,    .     ,            . (    ,       <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Anchor Modeling</a> ).           .     « ».           .      Neo4j,     . </li><li>     ,           .        . , UI points  frontend ,   backend , storage  DBA,   DevOps ,   . </li></ul><br><h1 id="zadachi-in-progress">  in-progress </h1><br><p>       . <br>           (Londiste, PGQ, RabbitMQ). </p><br><p>       .   UI points          .       .             (Persistent Fabric),        UI points,   Endpoint,   .             , ,   ,       ,    . </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id462937/">https://habr.com/ru/post/id462937/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id462917/index.html">Mengikis web dengan R. Perbandingan peringkat film di Kinopoisk dan IMDB</a></li>
<li><a href="../id462923/index.html">Memasuki Aeronet Episode 3: Finding the Ball</a></li>
<li><a href="../id462929/index.html">Aku melihatmu: taktik topeng kelelawar</a></li>
<li><a href="../id462933/index.html">Cara kerja pemblokiran Internet: ulasan metode modern dengan contoh nyata</a></li>
<li><a href="../id462935/index.html">Bagaimana cara tetap fokus saat bekerja di kantor rencana terbuka?</a></li>
<li><a href="../id462939/index.html">10 Laporan C ++ Rusia teratas dan daftar putar konferensi akses terbuka</a></li>
<li><a href="../id462943/index.html">Berburu Wumpus atau pengalaman menulis game Android klasik</a></li>
<li><a href="../id462945/index.html">Hasilkan kata sandi satu kali untuk 2FA di JS menggunakan Web Crypto API</a></li>
<li><a href="../id462947/index.html">Kisah bagaimana PVS-Studio menemukan kesalahan di perpustakaan yang digunakan di ... PVS-Studio</a></li>
<li><a href="../id462949/index.html">Kisah bagaimana PVS-Studio menemukan kesalahan di perpustakaan yang digunakan di ... PVS-Studio</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>