<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üå± ü•ô üë®‚Äç‚ù§Ô∏è‚Äçüë® Funciones Go integradas üï∫üèº üèè üõë</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ir le permite escribir en ensamblador. Pero los autores del lenguaje escribieron una biblioteca tan est√°ndar que no tendr√≠a que hacerse. Hay formas de...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Funciones Go integradas</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/467673/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/v5/jg/mv/v5jgmvuskpn_epxwt8vt6vd1dny.png" width="200"></div><br>  Ir le permite escribir en ensamblador.  Pero los autores del lenguaje escribieron una biblioteca tan est√°ndar que no tendr√≠a que hacerse.  Hay formas de escribir c√≥digo port√°til y r√°pido al mismo tiempo.  Como?  Bienvenido bajo corte. <br><a name="habracut"></a><br>  Comenzar a escribir funciones en ensamblador en go es muy simple.  Por ejemplo, declare (declaraci√≥n de reenv√≠o) la funci√≥n <code>Add</code> , que agrega 2 int64: <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Add</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(a </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int64</span></span></span></span><span class="hljs-function"><span class="hljs-params">, b </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int64</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">int64</span></span></span></span></code> </pre><br>  Esta es una funci√≥n normal, pero falta el cuerpo de la funci√≥n.  El compilador jurar√° razonablemente cuando intente compilar un paquete. <br><br><pre> <code class="bash hljs">% go build examples/asm ./decl.go:4:6: missing <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> body</code> </pre><br>  Agregue un archivo con la extensi√≥n .s e implemente la funci√≥n en ensamblador. <br><br><pre> <code class="apache hljs"><span class="hljs-attribute"><span class="hljs-attribute">TEXT</span></span> ¬∑Add(SB),<span class="hljs-number"><span class="hljs-number">$0</span></span>-24 MOVQ a+0(FP), AX ADDQ b+8(FP), AX MOVQ AX, ret+16(FP) RET</code> </pre><br>  Ahora puede compilar, probar y usar <code>Add</code> como una funci√≥n normal.  Esto es ampliamente utilizado por los propios desarrolladores de lenguaje en los paquetes <abbr title="encuentre $ {GOROOT} / src -name '* .s' | xargs dirname | uniq --count | sort --reverse --numeric-sort | encabezado - l√≠neas = 20; # paquetes principales para usar asm">runtime, math, bytealg, syscall, reflect, crypto</abbr> .  Esto le permite utilizar optimizaciones de procesador de hardware y <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">comandos que no est√°n representados en el idioma</a> . <br><br>  Pero hay un problema: las funciones en asm no se pueden optimizar ni incorporar (en l√≠nea).  Sin esto, los gastos generales pueden ser prohibitivos. <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> Result <span class="hljs-keyword"><span class="hljs-keyword">int64</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BenchmarkAddNative</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(b *testing.B)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> r <span class="hljs-keyword"><span class="hljs-keyword">int64</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i := <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; bN; i++ { r = <span class="hljs-keyword"><span class="hljs-keyword">int64</span></span>(i) + <span class="hljs-keyword"><span class="hljs-keyword">int64</span></span>(i) } Result = r } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BenchmarkAddAsm</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(b *testing.B)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> r <span class="hljs-keyword"><span class="hljs-keyword">int64</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i := <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; bN; i++ { r = Add(<span class="hljs-keyword"><span class="hljs-keyword">int64</span></span>(i), <span class="hljs-keyword"><span class="hljs-keyword">int64</span></span>(i)) } Result = r }</code> </pre><br><pre> <code class="plaintext hljs">BenchmarkAddNative-8 1000000000 0.300 ns/op BenchmarkAddAsm-8 606165915 1.930 ns/op</code> </pre><br>  Hubo varias sugerencias para el ensamblador en l√≠nea, como la directiva <code>asm(...)</code> en gcc.  Ninguno de ellos fue aceptado.  En lugar de esto, vaya agregando funciones <abbr title="Puede que este no sea el nombre oficial, pero aparece en el c√≥digo y las pruebas del compilador.">intr√≠nsecas</abbr> . <br><br>  Las funciones integradas de Go est√°n escritas en simple go.  Pero el compilador sabe que pueden reemplazarse por algo m√°s √≥ptimo.  En Go 1.13, las funciones integradas est√°n contenidas en <code>math/bits</code> y <code>sync/atomic</code> . <br><br>  Las funciones en estos paquetes tienen firmas elegantes.  De hecho, repiten las firmas de los comandos del procesador.  Esto permite que el compilador, si la arquitectura de destino lo admite, reemplace de manera transparente las llamadas a funciones con instrucciones de ensamblador. <br><br>  A continuaci√≥n, quiero hablar sobre dos formas diferentes en que el compilador go crea un c√≥digo m√°s eficiente utilizando funciones integradas. <br><br><h4>  Recuento de la poblaci√≥n </h4><br>  Este n√∫mero de unidades en la representaci√≥n binaria de un n√∫mero es una primitiva criptogr√°fica importante.  Dado que esta es una operaci√≥n importante, la mayor√≠a de las CPU modernas proporcionan implementaci√≥n en hardware. <br>  El paquete <code>math/bits</code> proporciona esta operaci√≥n en las funciones <code>OnesCount*</code> .  Se reconocen y reemplazan con la <code>POPCNT</code> procesador <code>POPCNT</code> . <br><br>  Para ver c√≥mo esto puede ser m√°s eficiente, comparemos 3 implementaciones.  El primero es <abbr title="The C Programming Language 2nd Ed, 1998">el algoritmo Kernigan</abbr> . <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">kernighan</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint64</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(count </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> x &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> { count++ x &amp;= x - <span class="hljs-number"><span class="hljs-number">1</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> count }</code> </pre><br>  El n√∫mero de ciclos del algoritmo coincide con el n√∫mero de bits establecidos.  M√°s bits: mayor tiempo de ejecuci√≥n, lo que potencialmente conduce a la fuga de informaci√≥n en canales de terceros. <br><br>  El segundo algoritmo es de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Hacker's Delight</a> . <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">hackersdelight</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint64</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">uint8</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> m1 = <span class="hljs-number"><span class="hljs-number">0</span></span>b0101010101010101010101010101010101010101010101010101010101010101 <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> m2 = <span class="hljs-number"><span class="hljs-number">0</span></span>b0011001100110011001100110011001100110011001100110011001100110011 <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> m4 = <span class="hljs-number"><span class="hljs-number">0</span></span>b0000111100001111000011110000111100001111000011110000111100001111 <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> h1 = <span class="hljs-number"><span class="hljs-number">0</span></span>b0000000100000001000000010000000100000001000000010000000100000001 x -= (x &gt;&gt; <span class="hljs-number"><span class="hljs-number">1</span></span>) &amp; m1 x = (x &amp; m2) + ((x &gt;&gt; <span class="hljs-number"><span class="hljs-number">2</span></span>) &amp; m2) x = (x + (x &gt;&gt; <span class="hljs-number"><span class="hljs-number">4</span></span>)) &amp; m4 <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8</span></span>((x * h1) &gt;&gt; <span class="hljs-number"><span class="hljs-number">56</span></span>) }</code> </pre><br>  La estrategia de dividir y conquistar permite que esta versi√≥n funcione para O (log‚ÇÇ) desde un n√∫mero largo y durante un tiempo constante desde el n√∫mero de bits, lo cual es importante para la criptograf√≠a.  Comparemos el rendimiento con <code>math/bits.OnesCount64</code> . <code>math/bits.OnesCount64</code> . <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BenchmarkKernighan</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(b *testing.B)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> r <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i := <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; bN; i++ { r = kernighan(<span class="hljs-keyword"><span class="hljs-keyword">uint64</span></span>(i)) } runtime.KeepAlive(r) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BenchmarkPopcnt</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(b *testing.B)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> r <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i := <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; bN; i++ { r = hackersdelight(<span class="hljs-keyword"><span class="hljs-keyword">uint64</span></span>(i)) } runtime.KeepAlive(r) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BenchmarkMathBitsOnesCount64</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(b *testing.B)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> r <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i := <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; bN; i++ { r = bits.OnesCount64(<span class="hljs-keyword"><span class="hljs-keyword">uint64</span></span>(i)) } runtime.KeepAlive(r) }</code> </pre><br>  Para ser sincero, pasamos los mismos par√°metros a las funciones: una secuencia de 0 a bN Esto es m√°s cierto para el m√©todo Kernigan, ya que su tiempo de ejecuci√≥n aumenta con el n√∫mero de bits del argumento de entrada.  <abbr title="Si est√° interesado, intente pasar 0xdeadbeef a cada funci√≥n y vea los resultados.">‚ûö</abbr> <br><br><pre> <code class="plaintext hljs">BenchmarkKernighan-4 100000000 12.9 ns/op BenchmarkPopcnt-4 485724267 2.63 ns/op BenchmarkMathBitsOnesCount64-4 1000000000 0.673 ns/op</code> </pre><br>  <code>math/bits.OnesCount64</code> gana en velocidad 4 veces.  Pero, ¬ørealmente usa una implementaci√≥n de hardware o el compilador mejor√≥ mejor el algoritmo de Hackers Delight?  Es hora de entrar en ensamblador. <br><br><pre> <code class="bash hljs">go <span class="hljs-built_in"><span class="hljs-built_in">test</span></span> -c <span class="hljs-comment"><span class="hljs-comment">#    </span></span></code> </pre><br>  Hay una sencilla utilidad para desarmar la herramienta go objdump, pero yo (a diferencia del autor del art√≠culo original), usar√© la IDA. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/nb/fj/q1/nbfjq1wg43hutueud_3c3pzbt4o.png"></div><br>  Est√°n pasando muchas cosas aqu√≠.  Lo m√°s importante: la instrucci√≥n x86 <code>POPCNT</code> est√° integrada en el c√≥digo de la prueba en s√≠, como esper√°bamos.  Esto hace que el punto de referencia sea m√°s r√°pido que las alternativas. <br><br>  Esta ramificaci√≥n es interesante. <br><br><pre> <code class="apache hljs"><span class="hljs-attribute"><span class="hljs-attribute">cmp</span></span> cs:runtime_x86HasPOPCNT, 0 jz lable</code> </pre><br>  S√≠, esto es polifilo en ensamblador.  No todos los procesadores admiten <code>POPCNT</code> .  Cuando se inicia el programa, antes de su <code>main</code> , la funci√≥n <code>runtime.cpuinit</code> verifica si hay una instrucci√≥n necesaria y la guarda en <code>runtime.x86HasPOPCNT</code> .  Cada vez que el programa verifica si es posible usar <code>POPCNT</code> o usar un archivo polif√≥nico.  Dado que el valor de <code>runtime.x86HasPOPCNT</code> no cambia despu√©s de la inicializaci√≥n, la predicci√≥n de la ramificaci√≥n del procesador es relativamente precisa. <br><br><h4>  Contador at√≥mico </h4><br>  Las funciones intr√≠nsecas son c√≥digos Go regulares; pueden estar en l√≠nea en una secuencia de instrucciones.  Por ejemplo, haremos una abstracci√≥n de un contador con m√©todos de las firmas extra√±as de las funciones del paquete at√≥mico. <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> main <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ( <span class="hljs-string"><span class="hljs-string">"sync/atomic"</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> counter <span class="hljs-keyword"><span class="hljs-keyword">uint64</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(c *counter)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">uint64</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> atomic.LoadUint64((*<span class="hljs-keyword"><span class="hljs-keyword">uint64</span></span>)(c)) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(c *counter)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">inc</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">uint64</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> atomic.AddUint64((*<span class="hljs-keyword"><span class="hljs-keyword">uint64</span></span>)(c), <span class="hljs-number"><span class="hljs-number">1</span></span>) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(c *counter)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">reset</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">uint64</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> atomic.SwapUint64((*<span class="hljs-keyword"><span class="hljs-keyword">uint64</span></span>)(c), <span class="hljs-number"><span class="hljs-number">0</span></span>) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">F</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">uint64</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> c counter c.inc() c.get() <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> c.reset() } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { F() }</code> </pre><br>  Alguien pensar√° que tal OOP agregar√° gastos generales.  Pero Go no es Java: el lenguaje no usa el enlace en tiempo de ejecuci√≥n a menos que expl√≠citamente use interfaces.  El c√≥digo anterior se colapsar√° en una secuencia eficiente de instrucciones del procesador.  ¬øC√≥mo ser√° el aspecto principal? <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/nx/cp/ps/nxcppsylwv0dy0gzvoixw43iq3s.png"></div><br>  En orden  <code>c.inc</code> convierte en <code>lock xadd [rax], 1</code> - adici√≥n at√≥mica de x86.  <code>c.get</code> convierte en la instrucci√≥n <code>mov</code> habitual, que ya es at√≥mica en x86.  <code>c.reset</code> convierte en el intercambio at√≥mico de <code>xchg</code> entre un registro nulo y la memoria. <br><br><h4>  Conclusi√≥n </h4><br>  Las funciones integradas son una soluci√≥n ordenada que proporciona acceso a operaciones de bajo nivel sin ampliar la especificaci√≥n del lenguaje.  Si la arquitectura no tiene primitivas de sincronizaci√≥n / at√≥micas espec√≠ficas (como algunas variantes ARM), u operaciones de matem√°ticas / bits, entonces el compilador inserta un archivo polivin√≠lico sobre la marcha. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/467673/">https://habr.com/ru/post/467673/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../467663/index.html">Soporte para instrucciones espec√≠ficas de hardware en .NET Core (ahora no solo SIMD)</a></li>
<li><a href="../467665/index.html">Carro para camiones ROS. Parte 5. Trabajando en rviz y gazebo: xacro, nuevos sensores</a></li>
<li><a href="../467667/index.html">Planificaci√≥n de proyectos de organizaci√≥n (Parte 4)</a></li>
<li><a href="../467669/index.html">M√≠rame completo: aprovecha al m√°ximo el video en vivo en plataformas m√≥viles</a></li>
<li><a href="../467671/index.html">Computadora retro NLX</a></li>
<li><a href="../467675/index.html">Modelado del estado de la aplicaci√≥n utilizando objetos Store en SwiftUI</a></li>
<li><a href="../467677/index.html">Pruebas o tipos</a></li>
<li><a href="../467679/index.html">PyCrunch: ejecuci√≥n de prueba inteligente y cobertura de c√≥digo visual en el IDE</a></li>
<li><a href="../467681/index.html">Vulnerabilidad de desv√≠os de enrutamiento SOAP</a></li>
<li><a href="../467683/index.html">Tratando de componer lo no composable: esquemas de acoplamiento</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>