<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚úåüèª üë®üèΩ‚Äçüç≥ üò™ Funktionsweise der Stapelverfolgung in ARM üñáÔ∏è üñ±Ô∏è ‚ùå</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Guten Tag! Vor einigen Tagen bin ich in unserem Projekt auf ein kleines Problem gesto√üen - im GDB-Interrupt-Handler wurde die Stapelverfolgung f√ºr Cor...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Funktionsweise der Stapelverfolgung in ARM</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/embox/blog/424365/">  Guten Tag!  Vor einigen Tagen bin ich in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">unserem Projekt</a> auf ein kleines Problem gesto√üen - im GDB-Interrupt-Handler wurde die Stapelverfolgung f√ºr Cortex-M falsch angezeigt.  Daher war es erneut hilfreich herauszufinden, und auf welche Weise kann ich einen Stack-Trace f√ºr ARM erhalten?  Welche Kompilierungsflags wirken sich auf die Stapelverfolgbarkeit in ARM aus?  Wie ist das im Linux-Kernel implementiert?  Aufgrund der Recherche habe ich beschlossen, diesen Artikel zu schreiben. <br><a name="habracut"></a><br>  Schauen wir uns die beiden wichtigsten Stack-Trace-Methoden im Linux-Kernel an. <br><br><h4>  Stapeln Sie sich durch Frames </h4><br>  Beginnen wir mit einem einfachen Ansatz, der im Linux-Kernel zu finden ist, aber derzeit in GCC einen veralteten Status hat. <br><br>  Stellen Sie sich vor, ein bestimmtes Programm l√§uft auf dem Stapel im RAM, und irgendwann unterbrechen wir es und m√∂chten den Aufrufstapel aufrufen.  Angenommen, wir haben einen Zeiger auf den aktuellen Befehl, der vom Prozessor (PC) ausgef√ºhrt wird, sowie den aktuellen Zeiger auf die Oberseite des Stapels (SP).  Um den Stapel zur vorherigen Funktion hochzuspringen, m√ºssen Sie verstehen, um welche Art von Funktion es sich handelt und wo wir zu dieser Funktion springen sollten.  ARM verwendet zu diesem Zweck das Link Register (LR). <br><blockquote>  Das Verbindungsregister (LR) ist das Register R14.  Es speichert die R√ºckgabeinformationen f√ºr Unterprogramme, Funktionsaufrufe und Ausnahmen.  Beim Zur√ºcksetzen setzt der Prozessor den LR-Wert auf 0xFFFFFFFF <br></blockquote>  Als n√§chstes m√ºssen wir den Stapel hochgehen und die neuen Werte der LR-Register vom Stapel laden.  Die Struktur des Stapelrahmens f√ºr den Compiler ist wie folgt: <br><br><pre><code class="hljs smalltalk">/* <span class="hljs-type"><span class="hljs-type">The</span></span> stack backtrace structure is as follows: fp points to here: | save code pointer | [fp] | return link value | [fp, #<span class="hljs-number"><span class="hljs-number">-4</span></span>] | return sp value | [fp, #<span class="hljs-number"><span class="hljs-number">-8</span></span>] | return fp value | [fp, #<span class="hljs-number"><span class="hljs-number">-12</span></span>] [| saved r10 value |] [| saved r9 value |] [| saved r8 value |] ... [| saved r0 value |] r0-r3 are not normally saved in a <span class="hljs-type"><span class="hljs-type">C</span></span> function. */</code> </pre> <br>  Diese Beschreibung stammt aus der GCC-Header-Datei gcc / gcc / config / arm / arm.h. <br><br>  Das hei√üt,  Der Compiler (in unserem Fall GCC) kann irgendwie dar√ºber informiert werden, dass wir einen Stack-Trace durchf√ºhren m√∂chten.  Und dann bereitet der Compiler im Prolog jeder Funktion eine Art Hilfsstruktur vor.  Sie k√∂nnen feststellen, dass in dieser Struktur der ‚Äûn√§chste‚Äú Wert des LR-Registers liegt, den wir ben√∂tigen, und vor allem die Adresse des n√§chsten Frames enth√§lt <code>| return fp value | [fp, #-12]</code> <br><br>  Dieser Compilermodus wird durch die Option -mapcs-frame angegeben.  In der Beschreibung der Option zum Thema "Wenn Sie -fomit-frame-pointer mit dieser Option angeben, werden die Stapelrahmen nicht f√ºr Blattfunktionen generiert."  Unter Blattfunktionen werden hier diejenigen verstanden, die keine anderen Funktionen aufrufen, so dass sie etwas einfacher gemacht werden k√∂nnen. <br><br>  M√∂glicherweise fragen Sie sich auch, was Sie in diesem Fall mit Assembler-Funktionen tun sollen.  Eigentlich nichts kniffliges - Sie m√ºssen spezielle Makros einf√ºgen.  Aus der Datei <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">tools / objtool / Documentation / stack-validation.txt</a> im Linux-Kernel: <br><blockquote>  Jede aufrufbare Funktion muss als solche mit dem ELF versehen werden <br>  Funktionstyp.  Im asm-Code erfolgt dies normalerweise mit dem <br>  ENTRY / ENDPROC-Makros. <br></blockquote>  In demselben Dokument wird jedoch er√∂rtert, dass dies auch ein offensichtlicher Nachteil dieses Ansatzes ist.  Das Dienstprogramm objtool pr√ºft, ob alle Funktionen im Kernel im richtigen Format f√ºr den Stack-Trace geschrieben sind. <br><br>  Das Folgende ist die Funktion zum Abwickeln eines Stacks vom Linux-Kernel: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> defined(CONFIG_FRAME_POINTER) &amp;&amp; !defined(CONFIG_ARM_UNWIND) int notrace unwind_frame(struct stackframe *frame) { unsigned long high, low; unsigned long fp = frame-&gt;fp; </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/*    ,    */</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* restore the registers from the stack frame */</span></span></span><span class="hljs-meta"> frame-&gt;fp = *(unsigned long *)(fp - 12); frame-&gt;sp = *(unsigned long *)(fp - 8); frame-&gt;pc = *(unsigned long *)(fp - 4); return 0; } #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span></span></code> </pre><br>  Aber hier m√∂chte ich die Zeile mit <code>defined(CONFIG_ARM_UNWIND)</code> .  Sie weist darauf hin, dass der Linux-Kernel auch eine andere Implementierung von unwind_frame verwendet, und wir werden etwas sp√§ter dar√ºber sprechen. <br><br>  Die Option <i>-mapcs-frame</i> ist nur f√ºr den ARM-Befehlssatz g√ºltig.  Es ist jedoch bekannt, dass ARM-Mikrocontroller einen anderen Befehlssatz haben - Thumb (Thumb-1 und Thumb-2, genauer gesagt), der haupts√§chlich f√ºr die Cortex-M-Serie verwendet wird.  Verwenden Sie die <i>Flags -mtpcs-frame</i> und <i>-mtpcs-leaf-frame,</i> um die Frame-Generierung f√ºr den Thumb-Modus zu <i>aktivieren</i> <i>.</i>  Im Wesentlichen ist es ein Analogon von -mapcs-frame.  Interessanterweise funktionieren diese Optionen derzeit nur f√ºr den Cortex-M0 / M1.  F√ºr einige Zeit konnte ich nicht herausfinden, warum ich das gew√ºnschte Bild f√ºr Cortex-M3 / M4 / .... nicht kompilieren konnte.  Nachdem ich alle gcc-Optionen f√ºr ARM erneut gelesen und im Internet gesucht hatte, stellte ich fest, dass dies wahrscheinlich ein Fehler war.  Daher bin ich direkt in den Quellcode des <i>arm-none-eabi-gcc-</i> Compilers <i>geklettert</i> .  Nachdem ich untersucht hatte, wie der Compiler Frames f√ºr ARM, Thumb-1 und Thumb-2 generiert, kam ich zu dem Schluss, dass sie Thumb-2 umgangen haben, d. H. Im Moment werden Frames nur f√ºr Thumb-1 und ARM generiert.  Nach dem Erstellen der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Fehler</a> erkl√§rten die GCC-Entwickler, dass sich der Standard f√ºr ARM bereits mehrmals ge√§ndert hat und diese Flags sehr veraltet sind, aber aus irgendeinem Grund alle noch im Compiler vorhanden sind.  Unten sehen Sie den Disassembler der Funktion, f√ºr die der Frame generiert wird. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">my_func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> a)</span></span></span><span class="hljs-function"> </span></span>{ my_func2(<span class="hljs-number"><span class="hljs-number">7</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre><br><pre> <code class="hljs delphi"><span class="hljs-number"><span class="hljs-number">00008134</span></span> &lt;my_func&gt;: <span class="hljs-number"><span class="hljs-number">8134</span></span>: b084 sub sp, <span class="hljs-string"><span class="hljs-string">#16</span></span> <span class="hljs-number"><span class="hljs-number">8136</span></span>: b580 push <span class="hljs-comment"><span class="hljs-comment">{r7, lr}</span></span> <span class="hljs-number"><span class="hljs-number">8138</span></span>: aa06 add r2, sp, <span class="hljs-string"><span class="hljs-string">#24</span></span> <span class="hljs-number"><span class="hljs-number">813</span></span>a: <span class="hljs-number"><span class="hljs-number">9203</span></span> str r2, [sp, <span class="hljs-string"><span class="hljs-string">#12</span></span>] <span class="hljs-number"><span class="hljs-number">813</span></span>c: <span class="hljs-number"><span class="hljs-number">467</span></span>a mov r2, pc <span class="hljs-number"><span class="hljs-number">813</span></span>e: <span class="hljs-number"><span class="hljs-number">9205</span></span> str r2, [sp, <span class="hljs-string"><span class="hljs-string">#20</span></span>] <span class="hljs-number"><span class="hljs-number">8140</span></span>: <span class="hljs-number"><span class="hljs-number">465</span></span>a mov r2, fp <span class="hljs-number"><span class="hljs-number">8142</span></span>: <span class="hljs-number"><span class="hljs-number">9202</span></span> str r2, [sp, <span class="hljs-string"><span class="hljs-string">#8</span></span>] <span class="hljs-number"><span class="hljs-number">8144</span></span>: <span class="hljs-number"><span class="hljs-number">4672</span></span> mov r2, lr <span class="hljs-number"><span class="hljs-number">8146</span></span>: <span class="hljs-number"><span class="hljs-number">9204</span></span> str r2, [sp, <span class="hljs-string"><span class="hljs-string">#16</span></span>] <span class="hljs-number"><span class="hljs-number">8148</span></span>: aa05 add r2, sp, <span class="hljs-string"><span class="hljs-string">#20</span></span> <span class="hljs-number"><span class="hljs-number">814</span></span>a: <span class="hljs-number"><span class="hljs-number">4693</span></span> mov fp, r2 <span class="hljs-number"><span class="hljs-number">814</span></span>c: b082 sub sp, <span class="hljs-string"><span class="hljs-string">#8</span></span> <span class="hljs-number"><span class="hljs-number">814</span></span>e: af00 add r7, sp, <span class="hljs-string"><span class="hljs-string">#0</span></span></code> </pre><br>  Im Vergleich dazu ein Disassembler der gleichen Funktion f√ºr ARM-Befehle <br><br><pre> <code class="hljs go"><span class="hljs-number"><span class="hljs-number">000081f</span></span>8 &lt;my_func&gt;: <span class="hljs-number"><span class="hljs-number">81f</span></span>8: e1a0c00d mov ip, sp <span class="hljs-number"><span class="hljs-number">81f</span></span>c: e92dd800 push {fp, ip, lr, pc} <span class="hljs-number"><span class="hljs-number">8200</span></span>: e24cb004 sub fp, ip, #<span class="hljs-number"><span class="hljs-number">4</span></span> <span class="hljs-number"><span class="hljs-number">8204</span></span>: e24dd008 sub sp, sp, #<span class="hljs-number"><span class="hljs-number">8</span></span></code> </pre><br>  Auf den ersten Blick scheint es, dass dies v√∂llig andere Dinge sind.  Tats√§chlich sind die Frames jedoch genau gleich. Tatsache ist, dass im Thumb-Modus mit dem Push-Befehl nur niedrige Register (r0 - r7) und das lr-Register gestapelt werden k√∂nnen.  F√ºr alle anderen Register muss dies in zwei Schritten durch die Anweisungen mov und str erfolgen, wie im obigen Beispiel. <br><br><h4>  Stapel durch Ausnahmen abwickeln </h4><br>  Ein alternativer Ansatz ist das Abwickeln des Stapels basierend auf dem ABI f√ºr die Ausnahmebehandlung f√ºr den ARM-Architekturstandard ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">EHABI</a> ).  Das Hauptbeispiel f√ºr die Verwendung dieses Standards ist die Ausnahmebehandlung in Sprachen wie C ++.  Informationen, die vom Compiler f√ºr die Ausnahmebehandlung vorbereitet wurden, k√∂nnen auch zum Verfolgen des Stapels verwendet werden.  Dieser Modus wird mit der Option GCC <i>-fexceptions</i> (oder <i>-funwind-frame</i> ) <i>aktiviert</i> . <br><br>  Schauen wir uns genauer an, wie das gemacht wird.  Dieses Dokument (EHABI) stellt zun√§chst bestimmte Anforderungen an den Compiler, um die Hilfstabellen .ARM.exidx und .ARM.extab zu generieren.  So wird dieser Abschnitt .ARM.exidx in den Linux-Kernelquellen definiert.  Aus der Datei <a href="">arch / arm / kernel / vmlinux.lds.h</a> : <br><br><pre> <code class="hljs tex">/* Stack unwinding tables */ #define ARM_UNWIND_SECTIONS <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"> </span></span></span></span>. = ALIGN(8); <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"> </span></span></span></span>.ARM.unwind_idx : { <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"> </span></span></span></span>__start_unwind_idx = .; <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"> </span></span></span></span>*(.ARM.exidx*) <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"> </span></span></span></span>__stop_unwind_idx = .; <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"> </span></span></span></span>} <span class="hljs-tag"><span class="hljs-tag">\</span></span></code> </pre><br>  Der Standard ‚ÄûABI f√ºr die Ausnahmebehandlung f√ºr die ARM-Architektur‚Äú definiert jedes Element der Tabelle .ARM.exidx wie folgt: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">unwind_idx</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> addr_offset; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> insn; };</code> </pre> <br>  Das erste Element ist der Versatz relativ zum Beginn der Funktion, und das zweite Element ist die Adresse in der Befehlstabelle, die auf besondere Weise interpretiert werden muss, um den Stapel weiter zu drehen.  Mit anderen Worten, jedes Element dieser Tabelle ist einfach eine Folge von W√∂rtern und Halbw√∂rtern, die eine Folge von Anweisungen sind.  Das erste Wort gibt die Anzahl der Anweisungen an, die ausgef√ºhrt werden m√ºssen, um den Stapel zum n√§chsten Frame zu drehen. <br><br>  Diese Anweisungen sind im bereits erw√§hnten EHABI-Standard beschrieben: <br><br><img src="https://habrastorage.org/webt/x9/3d/hx/x93dhxr8vqlkj-c_wcqk-ht1_m0.png"><br><br>  Die Hauptimplementierung dieses Interpreters unter Linux befindet sich in der Datei <a href="">arch / arm / kernel / unwind.c</a> <br><br><div class="spoiler">  <b class="spoiler_title">Implementierung der Funktion unwind_frame</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">unwind_frame</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(struct stackframe *frame)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> low; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">unwind_idx</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">idx</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">unwind_ctrl_block</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ctrl</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-comment"><span class="hljs-comment">/*   ,   */</span></span> <span class="hljs-comment"><span class="hljs-comment">/*   ARM.exidx    ,   PC */</span></span> idx = unwind_find_idx(frame-&gt;pc); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!idx) { pr_warn(<span class="hljs-string"><span class="hljs-string">"unwind: Index not found %08lx\n"</span></span>, frame-&gt;pc); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> -URC_FAILURE; } ctrl.vrs[FP] = frame-&gt;fp; ctrl.vrs[SP] = frame-&gt;sp; ctrl.vrs[LR] = frame-&gt;lr; ctrl.vrs[PC] = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (idx-&gt;insn == <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-comment"><span class="hljs-comment">/* can't unwind */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> -URC_FAILURE; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((idx-&gt;insn &amp; <span class="hljs-number"><span class="hljs-number">0x80000000</span></span>) == <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-comment"><span class="hljs-comment">/* prel31 to the unwind table */</span></span> ctrl.insn = (<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> *)prel31_to_addr(&amp;idx-&gt;insn); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((idx-&gt;insn &amp; <span class="hljs-number"><span class="hljs-number">0xff000000</span></span>) == <span class="hljs-number"><span class="hljs-number">0x80000000</span></span>) <span class="hljs-comment"><span class="hljs-comment">/* only personality routine 0 supported in the index */</span></span> ctrl.insn = &amp;idx-&gt;insn; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { pr_warn(<span class="hljs-string"><span class="hljs-string">"unwind: Unsupported personality routine %08lx in the index at %p\n"</span></span>, idx-&gt;insn, idx); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> -URC_FAILURE; } <span class="hljs-comment"><span class="hljs-comment">/*       ,    - * ,       */</span></span> <span class="hljs-comment"><span class="hljs-comment">/* check the personality routine */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((*ctrl.insn &amp; <span class="hljs-number"><span class="hljs-number">0xff000000</span></span>) == <span class="hljs-number"><span class="hljs-number">0x80000000</span></span>) { ctrl.byte = <span class="hljs-number"><span class="hljs-number">2</span></span>; ctrl.entries = <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((*ctrl.insn &amp; <span class="hljs-number"><span class="hljs-number">0xff000000</span></span>) == <span class="hljs-number"><span class="hljs-number">0x81000000</span></span>) { ctrl.byte = <span class="hljs-number"><span class="hljs-number">1</span></span>; ctrl.entries = <span class="hljs-number"><span class="hljs-number">1</span></span> + ((*ctrl.insn &amp; <span class="hljs-number"><span class="hljs-number">0x00ff0000</span></span>) &gt;&gt; <span class="hljs-number"><span class="hljs-number">16</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { pr_warn(<span class="hljs-string"><span class="hljs-string">"unwind: Unsupported personality routine %08lx at %p\n"</span></span>, *ctrl.insn, ctrl.insn); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> -URC_FAILURE; } ctrl.check_each_pop = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-comment"><span class="hljs-comment">/* ,      */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (ctrl.entries &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> urc; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((ctrl.sp_high - ctrl.vrs[SP]) &lt; <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(ctrl.vrs)) ctrl.check_each_pop = <span class="hljs-number"><span class="hljs-number">1</span></span>; urc = unwind_exec_insn(&amp;ctrl); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (urc &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> urc; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ctrl.vrs[SP] &lt; low || ctrl.vrs[SP] &gt;= ctrl.sp_high) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> -URC_FAILURE; } <span class="hljs-comment"><span class="hljs-comment">/*   */</span></span> <span class="hljs-comment"><span class="hljs-comment">/* ,       */</span></span> frame-&gt;fp = ctrl.vrs[FP]; frame-&gt;sp = ctrl.vrs[SP]; frame-&gt;lr = ctrl.vrs[LR]; frame-&gt;pc = ctrl.vrs[PC]; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> URC_OK; }</code> </pre><br></div></div><br>  Dies ist eine Implementierung der Funktion unwind_frame, die verwendet wird, wenn die Option CONFIG_ARM_UNWIND aktiviert ist.  Ich habe die Kommentare mit Erkl√§rungen in russischer Sprache direkt in den Quelltext eingef√ºgt. <br><br>  Das folgende Beispiel zeigt, wie das Tabellenelement .ARM.exidx nach der Funktion kernel_start in Embox sucht: <br><br><pre> <code class="hljs powershell"><span class="hljs-variable"><span class="hljs-variable">$</span></span> arm<span class="hljs-literal"><span class="hljs-literal">-none</span></span><span class="hljs-literal"><span class="hljs-literal">-eabi</span></span><span class="hljs-literal"><span class="hljs-literal">-readelf</span></span> <span class="hljs-literal"><span class="hljs-literal">-u</span></span> build/base/bin/embox Unwind table index <span class="hljs-string"><span class="hljs-string">'.ARM.exidx'</span></span> at offset <span class="hljs-number"><span class="hljs-number">0</span></span>xaa6d4 contains <span class="hljs-number"><span class="hljs-number">2806</span></span> entries: &lt;...&gt; <span class="hljs-number"><span class="hljs-number">0</span></span>x1c3c &lt;kernel_start&gt;: @<span class="hljs-number"><span class="hljs-number">0</span></span>xafe40 Compact model index: <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>x9b vsp = r11 <span class="hljs-number"><span class="hljs-number">0</span></span>x40 vsp = vsp - <span class="hljs-number"><span class="hljs-number">4</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>x84 <span class="hljs-number"><span class="hljs-number">0</span></span>x80 pop {r11, r14} <span class="hljs-number"><span class="hljs-number">0</span></span>xb0 finish <span class="hljs-number"><span class="hljs-number">0</span></span>xb0 finish &lt;...&gt;</code> </pre><br>  Und hier ist ihr Disassembler: <br><br><pre> <code class="hljs cs"><span class="hljs-number"><span class="hljs-number">00001</span></span>c3c &lt;kernel_start&gt;: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">kernel_start</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-number"><span class="hljs-number">1</span></span>c3c: e92d4800 push {fp, lr} <span class="hljs-number"><span class="hljs-number">1</span></span>c40: e28db004 <span class="hljs-keyword"><span class="hljs-keyword">add</span></span> fp, sp, <span class="hljs-meta"><span class="hljs-meta">#4 &lt;...&gt;</span></span></code> </pre><br>  Gehen wir die Schritte durch.  Wir sehen die Zuordnung <code>vps = r11</code> .  (R11 das ist FP) und dann <code>vps = vps - 4</code> .  Dies entspricht der Anweisung <code>add fp, sp, #4</code> .  Als n√§chstes kommt pop {r11, r14}, was der Anweisung <code>push {fp, lr}</code> .  Die letzte <code>finish</code> das Ende der Ausf√ºhrung an (um ehrlich zu sein, verstehe ich immer noch nicht, warum es dort zwei Zielanweisungen gibt). <br><br>  Nun wollen wir sehen, wie viel Speicher die Assembly mit dem <i>Flag -funwind-frame belegt.</i> <br>  F√ºr das Experiment habe ich Embox f√ºr die STM32F4-Discovery-Plattform kompiliert.  Hier sind die Objdump-Ergebnisse: <br><br><div class="spoiler">  <b class="spoiler_title">Mit dem Flag -funwind-frame:</b> <div class="spoiler_text"> <code>Sections: <br> Idx Name Size VMA LMA File off Algn <br> 0 .text 0005a600 08000000 08000000 00004000 2**14 <br> CONTENTS, ALLOC, LOAD, CODE <br> 1 .ARM.exidx 00003fd8 0805a600 0805a600 0005e600 2**2 <br> CONTENTS, ALLOC, LOAD, READONLY, DATA <br> 2 .ARM.extab 000049d0 0805e5d8 0805e5d8 000625d8 2**2 <br> CONTENTS, ALLOC, LOAD, READONLY, DATA <br> 3 .rodata 0003e380 08062fc0 08062fc0 00066fc0 2**5 <br></code> <br></div></div><br><div class="spoiler">  <b class="spoiler_title">Ohne Flagge:</b> <div class="spoiler_text"> <code>Sections: <br> Idx Name Size VMA LMA File off Algn <br> 0 .text 00058b1c 08000000 08000000 00004000 2**14 <br> CONTENTS, ALLOC, LOAD, CODE <br> 1 .ARM.exidx 00000008 08058b1c 08058b1c 0005cb1c 2**2 <br> CONTENTS, ALLOC, LOAD, READONLY, DATA <br> 2 .rodata 0003e380 08058b40 08058b40 0005cb40 2**5 <br></code> <br></div></div><br>  Es ist leicht zu berechnen, dass die Abschnitte .ARM.exidx und .ARM.extab ungef√§hr 1/10 der Textgr√∂√üe einnehmen.  Danach habe ich ein gr√∂√üeres Bild gesammelt - f√ºr ARM Integrator CP basierend auf ARM9, und dort waren diese Abschnitte 1/12 der Gr√∂√üe des Textabschnitts.  Es ist jedoch klar, dass dieses Verh√§ltnis von Projekt zu Projekt variieren kann.  Es stellte sich auch heraus, dass die Gr√∂√üe des Bildes, das das Flag -macps-frame hinzuf√ºgt, kleiner ist als die erwartete Ausnahmeoption.  Wenn beispielsweise die Gr√∂√üe des Textabschnitts 600 KB betrug, betrug die Gesamtgr√∂√üe von .ARM.exidx + .ARM.extab 50 KB, und die Gr√∂√üe des zus√§tzlichen Codes mit dem Flag -mapcs-frame betrug nur 10 KB.  Aber wenn wir oben schauen, was f√ºr ein gro√üer Prolog f√ºr Cortex-M1 generiert wurde (denken Sie daran, durch mov / str?), Dann wird klar, dass es in diesem Fall praktisch keinen Unterschied gibt, was bedeutet, dass es unwahrscheinlich ist, <i>-mtpcs-frame</i> f√ºr den Thumb-Modus zu verwenden macht zumindest einen Sinn. <br><br><h4>  Wird eine solche Stapelverfolgung jetzt f√ºr ARM ben√∂tigt?  Was sind die Alternativen? </h4><br>  Ein dritter Ansatz besteht darin, den Stapel mithilfe eines Debuggers zu verfolgen.  Es scheint, dass viele Betriebssysteme f√ºr die Arbeit mit FreeRTOS- und NuttX-Mikrocontrollern derzeit diese spezielle Ablaufverfolgungsoption <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">vorschlagen</a> oder anbieten, einen Disassembler zu √ºberwachen. <br><br>  Als Ergebnis kamen wir zu dem Schluss, dass die Stapelverfolgung f√ºr Waffen zur Laufzeit eigentlich nirgendwo verwendet wird.  Dies ist wahrscheinlich eine Folge des Wunsches, w√§hrend der Arbeit den effizientesten Code zu erstellen und die Debugging-Aktionen (einschlie√ülich der Heraufstufung des Stacks) offline auszuf√ºhren.  Wenn das Betriebssystem jedoch bereits C ++ - Code verwendet, ist es durchaus m√∂glich, die Implementierung der Ablaufverfolgung √ºber .ARM.exidx zu verwenden. <br><br>  Nun ja, das Problem mit der falschen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Stapelausgabe</a> im Interrupt in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Embox</a> wurde sehr einfach gel√∂st. Es stellte sich heraus, dass es ausreichte, um das LR-Register auf dem Stapel zu speichern. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de424365/">https://habr.com/ru/post/de424365/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de424349/index.html">"Testerkalender" f√ºr September. Tests optimieren</a></li>
<li><a href="../de424353/index.html">Hintergrund: Staatliche Internet-Suchmaschine Sputnik und ihre komplexe Geschichte</a></li>
<li><a href="../de424355/index.html">Spritzguss: wie es funktioniert</a></li>
<li><a href="../de424361/index.html">Wie Gamification die Benutzererfahrung verbessert</a></li>
<li><a href="../de424363/index.html">"Wenn Sie etwas wirklich Cooles erstellen m√∂chten, m√ºssen Sie tiefer gehen und wissen, wie Ihr Code im System und auf der Hardware funktioniert."</a></li>
<li><a href="../de424367/index.html">Der Kampf um Ressourcen, Teil 2: Wir spielen mit den Einstellungen von Cgroups</a></li>
<li><a href="../de424369/index.html">Meine Lieblingsdatei in der Chromium-Codebasis</a></li>
<li><a href="../de424371/index.html">Stellen Sie vCloud Extender bereit</a></li>
<li><a href="../de424373/index.html">Wo in der IT arbeiten, Problem 1: Voximplant</a></li>
<li><a href="../de424375/index.html">Mayku FormBox Vacuum Moulder Review: Teile sich ausbreiten lassen</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>