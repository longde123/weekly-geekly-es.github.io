<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üèÄ üíÜüèæ ‚ÜîÔ∏è Speicher und Spanne Punkt 1 üÜô üñáÔ∏è üë©üèª‚Äçüè´</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ab .NET Core 2.0 und .NET Framework 4.5 k√∂nnen wir neue Datentypen verwenden: Span und Memory . Um sie zu verwenden, m√ºssen Sie nur das System.Memory ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Speicher und Spanne Punkt 1</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/clrium/blog/443974/"><p><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img width="350" align="left" src="https://habrastorage.org/webt/vh/7j/tq/vh7jtqhzbne4h3rjhprca2pruhu.png"></a>  Ab .NET Core 2.0 und .NET Framework 4.5 k√∂nnen wir neue Datentypen verwenden: <code>Span</code> und <code>Memory</code> .  Um sie zu verwenden, m√ºssen Sie nur das <code>System.Memory</code> Nuget-Paket installieren: </p><br><blockquote> <code>PM&gt; Install-Package System.Memory</code> </blockquote> <p>  Diese Datentypen sind bemerkenswert, da das CLR-Team hervorragende Arbeit geleistet hat, um ihre spezielle Unterst√ºtzung im Code des .NET Core 2.1+ JIT-Compilers zu implementieren, indem diese Datentypen direkt in den Core eingebettet wurden.  Um welche Art von Datentypen handelt es sich und warum sind sie ein ganzes Kapitel wert? </p><br><p>  Wenn wir √ºber Probleme sprechen, die diese Typen auftreten lie√üen, sollte ich drei davon nennen.  Der erste ist nicht verwalteter Code. </p><br><p>  Sowohl die Sprache als auch die Plattform existieren seit vielen Jahren zusammen mit Mitteln zur Arbeit mit nicht verwaltetem Code.  Warum also eine andere API f√ºr die Arbeit mit nicht verwaltetem Code freigeben, wenn die erstere im Grunde viele Jahre existiert?  Um diese Frage zu beantworten, sollten wir verstehen, was uns vorher gefehlt hat. </p><br><blockquote><img src="https://habrastorage.org/webt/tu/qf/aq/tuqfaqcncvjtdmb_uxgcbbzyr9o.png" align="left">  Dieses Kapitel wurde vom Autor und von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">professionellen √úbersetzern</a> gemeinsam aus dem Russischen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">√ºbersetzt</a> .  Sie k√∂nnen uns bei der √úbersetzung von Russisch oder Englisch in eine andere Sprache helfen, haupts√§chlich ins Chinesische oder Deutsche. <br><br>  Wenn Sie sich bei uns bedanken m√∂chten, k√∂nnen Sie dies am besten tun, indem Sie uns einen Stern auf Github geben oder das Repository teilen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/webt/5n/wo/6u/5nwo6uvyk2eafkzdd0cdofjqm-0.png" width="22"></a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">github / sidristij / dotnetbook</a> . <br></blockquote><a name="habracut"></a><br><p>  Die Plattformentwickler haben bereits versucht, uns die Verwendung nicht verwalteter Ressourcen zu erleichtern.  Sie implementierten Auto-Wrapper f√ºr importierte Methoden und Marshalling, die in den meisten F√§llen automatisch funktionieren.  Hier geh√∂rt auch zu <code>stackalloc</code> , das im Kapitel √ºber einen Thread-Stack erw√§hnt wird.  Aus meiner Sicht kamen die ersten C # -Entwickler aus der C ++ - Welt (mein Fall), aber jetzt wechseln sie von h√∂heren Sprachen (ich kenne einen Entwickler, der zuvor in JavaScript geschrieben hat).  Dies bedeutet, dass die Leute gegen√ºber nicht verwaltetem Code und C / C + -Konstrukten misstrauischer werden, umso mehr gegen√ºber Assembler. </p><br><p>  Infolgedessen enthalten Projekte immer weniger unsicheren Code und das Vertrauen in die Plattform-API w√§chst immer mehr.  Dies ist leicht zu √ºberpr√ºfen, ob wir in √∂ffentlichen Repositorys nach <code>stackalloc</code> Anwendungsf√§llen suchen - sie sind rar.  Nehmen wir jedoch jeden Code, der ihn verwendet: </p><br><p>  <strong>Interop.ReadDir-Klasse</strong> <br>  <a href="">/src/mscorlib/shared/Interop/Unix/System.Native/Interop.ReadDir.cs</a> </p><br><pre> <code class="plaintext hljs">unsafe { // s_readBufferSize is zero when the native implementation does not support reading into a buffer. byte* buffer = stackalloc byte[s_readBufferSize]; InternalDirectoryEntry temp; int ret = ReadDirR(dir.DangerousGetHandle(), buffer, s_readBufferSize, out temp); // We copy data into DirectoryEntry to ensure there are no dangling references. outputEntry = ret == 0 ? new DirectoryEntry() { InodeName = GetDirectoryEntryName(temp), InodeType = temp.InodeType } : default(DirectoryEntry); return ret; }</code> </pre> <br><p>  Wir k√∂nnen sehen, warum es nicht beliebt ist.  √úberfliegen Sie einfach diesen Code und fragen Sie sich, ob Sie ihm vertrauen.  Ich denke die Antwort ist "Nein".  Dann fragen Sie sich warum.  Es ist offensichtlich: Wir sehen nicht nur das Wort " <code>Dangerous</code> , was darauf hindeutet, dass etwas schief gehen k√∂nnte, sondern es gibt auch das <code>unsafe</code> Schl√ºsselwort und das <code>byte* buffer = stackalloc byte[s_readBufferSize];</code>  Zeile (speziell - <code>byte*</code> ), die unsere Einstellung √§ndert.  Dies ist ein Ausl√∂ser f√ºr Sie zu denken: "Gab es nicht einen anderen Weg, dies zu tun"?  Kommen wir also tiefer in die Psychoanalyse: Warum k√∂nnten Sie so denken?  Einerseits verwenden wir Sprachkonstrukte und die hier angebotene Syntax ist weit entfernt von beispielsweise C ++ / CLI, die alles erlaubt (sogar das Einf√ºgen von reinem Assembler-Code).  Andererseits sieht diese Syntax ungew√∂hnlich aus. </p><br><p>  Das zweite Problem, an das Entwickler implizit oder explizit gedacht haben, ist die Inkompatibilit√§t von String- und Char [] -Typen.  Logischerweise ist eine Zeichenfolge ein Array von Zeichen, aber Sie k√∂nnen keine Zeichenfolge in char [] umwandeln: Sie k√∂nnen nur ein neues Objekt erstellen und den Inhalt einer Zeichenfolge in ein Array kopieren.  Diese Inkompatibilit√§t wird eingef√ºhrt, um Zeichenfolgen hinsichtlich des Speichers zu optimieren (es gibt keine schreibgesch√ºtzten Arrays).  Es treten jedoch Probleme auf, wenn Sie mit der Arbeit mit Dateien beginnen.  Wie lese ich sie?  Als String oder als Array?  Wenn Sie ein Array ausw√§hlen, k√∂nnen Sie einige Methoden nicht verwenden, die f√ºr die Arbeit mit Zeichenfolgen entwickelt wurden.  Was ist mit Lesen als Zeichenfolge?  Es kann zu lang sein.  Wenn Sie es dann analysieren m√ºssen, welchen Parser sollten Sie f√ºr primitive Datentypen ausw√§hlen: Sie m√∂chten sie nicht immer manuell analysieren (Ganzzahlen, Gleitkommazahlen, in verschiedenen Formaten angegeben).  Wir haben viele bew√§hrte Algorithmen, die dies schneller und effizienter machen, nicht wahr?  Solche Algorithmen arbeiten jedoch h√§ufig mit Zeichenfolgen, die nur einen primitiven Typ selbst enthalten.  Es gibt also ein Dilemma. </p><br><p>  Das dritte Problem besteht darin, dass die von einem Algorithmus ben√∂tigten Daten selten einen kontinuierlichen, soliden Datenschnitt innerhalb eines Abschnitts eines Arrays bilden, der aus einer Quelle gelesen wird.  Zum Beispiel haben wir im Fall von Dateien oder Daten, die aus einem Socket gelesen wurden, einen Teil davon bereits von einem Algorithmus verarbeitet, gefolgt von einem Teil der Daten, die von unserer Methode verarbeitet werden m√ºssen, und dann von noch nicht verarbeiteten Daten.  Im Idealfall m√∂chte unsere Methode nur die Daten, f√ºr die diese Methode entwickelt wurde.  Beispielsweise ist eine Methode, die Ganzzahlen analysiert, mit einer Zeichenfolge, die einige W√∂rter mit einer erwarteten Zahl irgendwo darunter enth√§lt, nicht zufrieden.  Diese Methode will eine Nummer und sonst nichts.  Wenn wir ein gesamtes Array √ºbergeben, muss beispielsweise der Versatz f√ºr eine Zahl vom Anfang des Arrays angegeben werden. </p><br><pre> <code class="plaintext hljs">int ParseInt(char[] input, int index) { while(char.IsDigit(input[index])) { // ... index++; } }</code> </pre> <br><p>  Dieser Ansatz ist jedoch schlecht, da diese Methode unn√∂tige Daten erh√§lt.  Mit anderen Worten, <em>die Methode wird f√ºr Kontexte aufgerufen, f√ºr die sie nicht entwickelt wurde</em> , und muss einige externe Aufgaben l√∂sen.  Das ist ein schlechtes Design.  Wie vermeide ich diese Probleme?  Optional k√∂nnen wir den <code>ArraySegment&lt;T&gt;</code> -Typ verwenden, der Zugriff auf einen Abschnitt eines Arrays <code>ArraySegment&lt;T&gt;</code> : </p><br><pre> <code class="plaintext hljs">int ParseInt(IList&lt;char&gt;[] input) { while(char.IsDigit(input.Array[index])) { // ... index++; } } var arraySegment = new ArraySegment(array, from, length); var res = ParseInt((IList&lt;char&gt;)arraySegment);</code> </pre> <br><p>  Ich denke jedoch, dass dies sowohl logisch als auch in Bezug auf die Leistung zu viel ist.  <code>ArraySegment</code> ist schlecht gestaltet und verlangsamt den Zugriff auf Elemente im Vergleich zu denselben Operationen, die mit einem Array ausgef√ºhrt werden, um das 7-fache. </p><br><p>  Wie l√∂sen wir diese Probleme?  Wie bringen wir Entwickler dazu, nicht verwalteten Code wieder zu verwenden, und geben ihnen ein einheitliches und schnelles Tool f√ºr die Arbeit mit heterogenen Datenquellen: Arrays, Zeichenfolgen und nicht verwalteten Speicher.  Es war notwendig, ihnen das Gef√ºhl des Vertrauens zu geben, dass sie nicht unwissentlich einen Fehler machen k√∂nnen.  Es war notwendig, ihnen ein Instrument zu geben, das die nativen Datentypen nicht in Bezug auf die Leistung verringert, sondern die aufgef√ºhrten Probleme l√∂st.  <code>Span&lt;T&gt;</code> Typen <code>Span&lt;T&gt;</code> und <code>Memory&lt;T&gt;</code> sind genau diese Instrumente. </p><br><h2 id="spanlttgt-readonlyspanlttgt">  Span &lt;T&gt;, ReadOnlySpan &lt;T&gt; </h2><br><p>  <code>Span</code> Typ ist ein Instrument zum Arbeiten mit Daten innerhalb eines Abschnitts eines Datenarrays oder mit einem Teilbereich seiner Werte.  Wie im Fall eines Arrays k√∂nnen sowohl die Elemente dieses Unterbereichs gelesen als auch geschrieben werden, jedoch mit einer wichtigen Einschr√§nkung: Sie erhalten oder erstellen einen <code>Span&lt;T&gt;</code> nur f√ºr eine <em>tempor√§re</em> Arbeit mit einem Array. Rufen Sie einfach eine Gruppe von Methoden auf .  Um ein allgemeines Verst√§ndnis zu erhalten, vergleichen wir jedoch die Datentypen, f√ºr die <code>Span</code> entwickelt wurde, und betrachten die m√∂glichen Verwendungsszenarien. </p><br><p>  Der erste Datentyp ist ein √ºbliches Array.  Arrays arbeiten mit <code>Span</code> folgenderma√üen: </p><br><pre> <code class="plaintext hljs"> var array = new [] {1,2,3,4,5,6}; var span = new Span&lt;int&gt;(array, 1, 3); var position = span.BinarySearch(3); Console.WriteLine(span[position]); // -&gt; 3</code> </pre> <br><p>  Zun√§chst erstellen wir ein Datenarray, wie in diesem Beispiel gezeigt.  Als N√§chstes erstellen wir <code>Span</code> (oder eine Teilmenge), die auf das Array verweist, und machen einen zuvor initialisierten Wertebereich f√ºr Code zug√§nglich, der das Array verwendet. </p><br><p>  Hier sehen wir das erste Merkmal dieser Art von Daten, dh die F√§higkeit, einen bestimmten Kontext zu erstellen.  Erweitern wir unsere Vorstellung von Kontexten: </p><br><pre> <code class="plaintext hljs">void Main() { var array = new [] {'1','2','3','4','5','6'}; var span = new Span&lt;char&gt;(array, 1, 3); if(TryParseInt32(span, out var res)) { Console.WriteLine(res); } else { Console.WriteLine("Failed to parse"); } } public bool TryParseInt32(Span&lt;char&gt; input, out int result) { result = 0; for (int i = 0; i &lt; input.Length; i++) { if(input[i] &lt; '0' || input[i] &gt; '9') return false; result = result * 10 + ((int)input[i] - '0'); } return true; } ----- 234</code> </pre> <br><p>  Wie wir sehen, bietet <code>Span&lt;T&gt;</code> abstrakten Zugriff auf einen Speicherbereich zum Lesen und Schreiben.  Was gibt es uns?  Wenn wir uns daran erinnern, wof√ºr wir <code>Span</code> sonst noch verwenden k√∂nnen, werden wir √ºber nicht verwaltete Ressourcen und Zeichenfolgen nachdenken: </p><br><pre> <code class="plaintext hljs">// Managed array var array = new[] { '1', '2', '3', '4', '5', '6' }; var arrSpan = new Span&lt;char&gt;(array, 1, 3); if (TryParseInt32(arrSpan, out var res1)) { Console.WriteLine(res1); } // String var srcString = "123456"; var strSpan = srcString.AsSpan(); if (TryParseInt32(strSpan, out var res2)) { Console.WriteLine(res2); } // void * Span&lt;char&gt; buf = stackalloc char[6]; buf[0] = '1'; buf[1] = '2'; buf[2] = '3'; buf[3] = '4'; buf[4] = '5'; buf[5] = '6'; if (TryParseInt32(buf, out var res3)) { Console.WriteLine(res3); } ----- 234 234 234</code> </pre> <br><p>  Das bedeutet, dass <code>Span&lt;T&gt;</code> ein Tool ist, mit dem die Arbeitsweise mit verwaltetem und nicht verwaltetem Speicher vereinheitlicht werden kann.  Es gew√§hrleistet die Sicherheit beim Arbeiten mit solchen Daten w√§hrend der Speicherbereinigung.  Das hei√üt, wenn Speicherbereiche mit nicht verwalteten Ressourcen verschoben werden, ist dies sicher. </p><br><p>  Sollten wir jedoch so aufgeregt sein?  K√∂nnten wir das fr√ºher erreichen?  Bei verwalteten Arrays besteht beispielsweise kein Zweifel: Sie m√ºssen nur ein Array in eine weitere Klasse einschlie√üen (z. B. [ArraySegment] ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://referencesource.microsoft.com/#mscorlib/system/). arraysegment.cs, 31</a> )) ergibt somit eine √§hnliche Schnittstelle und das ist es.  Dar√ºber hinaus k√∂nnen Sie dasselbe mit Zeichenfolgen tun - sie verf√ºgen √ºber die erforderlichen Methoden.  Auch hier m√ºssen Sie nur eine Zeichenfolge in denselben Typ einschlie√üen und Methoden bereitstellen, um damit zu arbeiten.  Um jedoch einen String, einen Puffer und ein Array in einem Typ zu speichern, haben Sie viel damit zu tun, Verweise auf jede m√∂gliche Variante in einer einzigen Instanz zu behalten (nat√ºrlich mit nur einer aktiven Variante). </p><br><pre> <code class="plaintext hljs">public readonly ref struct OurSpan&lt;T&gt; { private T[] _array; private string _str; private T * _buffer; // ... }</code> </pre> <br><p>  Basierend auf der Architektur k√∂nnen Sie drei Typen erstellen, die eine einheitliche Schnittstelle implementieren.  Daher ist es nicht m√∂glich, eine einheitliche Schnittstelle zwischen diesen Datentypen zu erstellen, die sich von <code>Span&lt;T&gt;</code> und die maximale Leistung beizubehalten. </p><br><p>  Als n√§chstes stellt sich die Frage, was <code>ref struct</code> in Bezug auf <code>Span</code> .  Dies sind genau die ‚ÄûStrukturen, die nur auf dem Stapel existieren‚Äú, von denen wir bei Vorstellungsgespr√§chen so oft h√∂ren.  Dies bedeutet, dass dieser Datentyp nur auf dem Stapel zugewiesen werden kann und nicht auf den Heap √ºbertragen werden kann.  Aus diesem Grund ist <code>Span</code> , eine Referenzstruktur, ein Kontextdatentyp, der die Arbeit von Methoden erm√∂glicht, nicht jedoch die von Objekten im Speicher.  Darauf m√ºssen wir uns st√ºtzen, wenn wir versuchen, es zu verstehen. </p><br><p>  Jetzt k√∂nnen wir den <code>Span</code> Typ und den zugeh√∂rigen <code>ReadOnlySpan</code> Typ definieren: </p><br><blockquote>  Span ist ein Datentyp, der eine einheitliche Schnittstelle f√ºr die Arbeit mit heterogenen Arten von Datenarrays implementiert und die √úbergabe einer Teilmenge eines Arrays an eine Methode erm√∂glicht, sodass die Zugriffsgeschwindigkeit auf das urspr√ºngliche Array unabh√§ngig von der Tiefe des Arrays konstant und am h√∂chsten ist Kontext. </blockquote><p>  In der Tat, wenn wir einen Code wie haben </p><br><pre> <code class="plaintext hljs">public void Method1(Span&lt;byte&gt; buffer) { buffer[0] = 0; Method2(buffer.Slice(1,2)); } Method2(Span&lt;byte&gt; buffer) { buffer[0] = 0; Method3(buffer.Slice(1,1)); } Method3(Span&lt;byte&gt; buffer) { buffer[0] = 0; }</code> </pre> <br><p>  Die Geschwindigkeit des Zugriffs auf den urspr√ºnglichen Puffer ist am h√∂chsten, wenn Sie mit einem verwalteten Zeiger und nicht mit einem verwalteten Objekt arbeiten.  Das bedeutet, dass Sie mit einem unsicheren Typ in einem verwalteten Wrapper arbeiten, jedoch nicht mit einem verwalteten .NET-Typ. </p><br><blockquote><img src="https://habrastorage.org/webt/tu/qf/aq/tuqfaqcncvjtdmb_uxgcbbzyr9o.png" align="left">  Dieses Kapitel wurde vom Autor und von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">professionellen √úbersetzern</a> gemeinsam aus dem Russischen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">√ºbersetzt</a> .  Sie k√∂nnen uns bei der √úbersetzung von Russisch oder Englisch in eine andere Sprache helfen, haupts√§chlich ins Chinesische oder Deutsche. <br><br>  Wenn Sie sich bei uns bedanken m√∂chten, k√∂nnen Sie dies am besten tun, indem Sie uns einen Stern auf Github geben oder das Repository teilen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/webt/5n/wo/6u/5nwo6uvyk2eafkzdd0cdofjqm-0.png" width="22"></a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">github / sidristij / dotnetbook</a> . <br></blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de443974/">https://habr.com/ru/post/de443974/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de443962/index.html">Einwegmuster (Prinzip des Einwegdesigns) Punkt 3</a></li>
<li><a href="../de443964/index.html">Kolesa Conf ist die gr√∂√üte IT-Konferenz in Kasachstan. Ank√ºndigung von Berichten</a></li>
<li><a href="../de443966/index.html">Google Text & Tabellen - ein beliebter Chat unter Studenten</a></li>
<li><a href="../de443968/index.html">Wie wir ein Haus mit Sonnenkollektoren gekauft haben und was daraus wurde</a></li>
<li><a href="../de443972/index.html">Yandex wird mit einem Roboter nach Piraten suchen</a></li>
<li><a href="../de443976/index.html">Speicher und Spanne Punkt 2</a></li>
<li><a href="../de443978/index.html">ATtiny13 vs PLC, oder wie man 14 E / A von einem 8-Fu√ü-Controller erh√§lt</a></li>
<li><a href="../de443980/index.html">Speicher und Spanne Punkt 3</a></li>
<li><a href="../de443984/index.html">Der neue Standard auf Basis von PCIe 5.0 wird die CPU und die GPU ‚Äûverbinden‚Äú - was dar√ºber bekannt ist</a></li>
<li><a href="../de443986/index.html">Wie ein Eichh√∂rnchen in einem Rad oder ein wenig √ºber Benutzerforschung in einer Behinderungssituation</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>