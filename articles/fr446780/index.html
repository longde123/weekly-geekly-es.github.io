<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🥒 👩‍👩‍👦‍👦 🕒 Comment créer un thème sombre et ne pas nuire. Expérience de l'équipe Yandex.Mail 🎭 👩🏽‍🎤 🈺</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Mon nom est Vladimir, je suis engagé dans un frontend mobile dans Yandex.Mail. Dans notre application, il y avait déjà un sujet sombre, mais pas assez...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Comment créer un thème sombre et ne pas nuire. Expérience de l'équipe Yandex.Mail</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/yandex/blog/446780/"><p><img src="https://habrastorage.org/webt/ji/4q/pr/ji4qprfkpuotssmzabus4cjflrq.png"></p><br><p>  Mon nom est Vladimir, je suis engagé dans un frontend mobile dans Yandex.Mail.  Dans notre application, il y avait déjà un sujet sombre, mais pas assez: nous avons pu repeindre l'interface et des lettres simples.  Mais les lettres formatées restaient claires et contrastaient avec une interface sombre, ce qui pouvait me fatiguer les yeux la nuit. </p><br><p>  Aujourd'hui, je dirai aux lecteurs de Habr comment nous avons résolu ce problème.  Vous découvrirez deux méthodes simples qui ne nous convenaient pas, puis - notre principale méthode de repeinture adaptative de pages et, enfin, la direction de la prochaine itération: repeindre des images.  Bien que la tâche elle-même - repeindre des pages avec un formatage arbitraire - soit spécifique, je pense que notre expérience vous sera également utile. </p><a name="habracut"></a><br><h2 id="prostye-sposoby">  Des moyens simples </h2><br><p>  Avant d'arriver à notre «repainter» magique, nous avons essayé deux options simples comme un bouchon: ajouter un style sombre supplémentaire ou un filtre CSS à l'élément.  Ils ne nous convenaient pas, mais peut-être que dans certains cas, ils seront encore meilleurs (parce que c'est juste = cool). </p><br><h3 id="pereopredelenie-stiley">  Remplacer les styles </h3><br><p>  La manière la plus simple, en développant logiquement le thème sombre de l'application elle-même en CSS: nous accrocherons les styles sombres sur un conteneur de lettres (dans le cas général, pour le contenu de quelqu'un d'autre qui doit être repeint): </p><br><pre><code class="css hljs"><span class="hljs-selector-class"><span class="hljs-selector-class">.message--dark</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">background-color</span></span>: black; <span class="hljs-attribute"><span class="hljs-attribute">color</span></span>: white; }</code> </pre> <br><p>  Mais si les éléments à l'intérieur de la lettre ont leurs propres styles, ils redéfiniront notre style racine.  Non <code>!important</code> n'aidera pas.  Vous pouvez presser une idée en coupant l'héritage: </p><br><pre> <code class="css hljs"><span class="hljs-selector-class"><span class="hljs-selector-class">.message--dark</span></span> * { <span class="hljs-attribute"><span class="hljs-attribute">background-color</span></span>: black <span class="hljs-meta"><span class="hljs-meta">!important</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">color</span></span>: white <span class="hljs-meta"><span class="hljs-meta">!important</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">border-color</span></span>: <span class="hljs-number"><span class="hljs-number">#333</span></span> <span class="hljs-meta"><span class="hljs-meta">!important</span></span>; }</code> </pre> <br><p>  Dans ce cas, vous ne pouvez pas vous en passer <code>!important</code> , car le sélecteur lui-même n'est pas très spécifique.  De plus, il sera nécessaire de redéfinir les styles en ligne (et les styles en ligne avec <code>!important</code> vont quand même ramper, il n'y a rien à faire). </p><br><p>  Notre style est assez maladroit et colore tout de la même manière, donc un autre problème se pose: probablement le designer voulait dire quelque chose en arrangeant les couleurs (priorités des éléments et autres choses de designer), mais nous avons pris et jeté cette idée. </p><br><p><img src="https://habrastorage.org/webt/cu/-1/ka/cu-1kav8ydvyjxlobshlklgio9u.png"></p><br><p>  Si vous respectez moins les designers que moi, et décidez toujours d'utiliser cette méthode, n'oubliez pas de terminer les bagatelles non évidentes: </p><br><ul><li>  <code>box-shadow</code> - seule la couleur ne peut pas être redéfinie; vous devez supprimer toutes les ombres ou vivre avec des ombres claires. </li><li>  Couleurs des éléments sémantiques - liens, éléments d'entrée. </li><li>  SVG en ligne - au lieu de l' <code>background</code> - <code>background</code> ils doivent définir le <code>fill</code> et au lieu de la <code>color</code> - le <code>stroke</code> , mais ce n'est pas précis, selon le SVG - cela peut être et vice versa. </li></ul><br><p>  Techniquement, la méthode n'est pas mauvaise: ce sont trois lignes de code (d'accord, trente pour la version redi de production avec des cas d'angle), la compatibilité avec tous les navigateurs du monde, le traitement des pages dynamiques hors de la boîte et aucune liaison à la façon de connecter les styles dans le document original.  Un bonus spécial est que vous pouvez facilement modifier les couleurs dans le style afin qu'elles correspondent à l'application principale (par exemple, créez l'arrière-plan <code>#bbbbb8</code> au lieu du noir). </p><br><p>  Au fait, nous avions l'habitude de repeindre les lettres de cette façon, mais si nous trouvions des styles à l'intérieur de la lettre, nous avions peur et laissions la lettre claire. </p><br><h3 id="css-filtr">  Filtre CSS </h3><br><p>  Option très spirituelle et élégante.  Vous pouvez repeindre la page avec un filtre CSS: </p><br><pre> <code class="css hljs"><span class="hljs-selector-class"><span class="hljs-selector-class">.message--dark</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">filter</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">invert</span></span>(100) <span class="hljs-built_in"><span class="hljs-built_in">hue-rotate</span></span>(180deg); <span class="hljs-comment"><span class="hljs-comment">/* hue-rotate    */</span></span> }</code> </pre> <br><p>  Après cela, les photos deviendront flippantes, mais peu importe - nous les repeindrons: </p><br><pre> <code class="css hljs"><span class="hljs-selector-class"><span class="hljs-selector-class">.message-dark</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">img</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">filter</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">invert</span></span>(100) <span class="hljs-built_in"><span class="hljs-built_in">hue-rotate</span></span>(180deg); }</code> </pre> <br><p><img src="https://habrastorage.org/webt/dr/3a/ix/dr3aix8opihd2nlq6oqzjfbdtvs.png"></p><br><p>  Il y a toujours des problèmes avec les images de contenu liées via l' <code>background</code> (nous savons qu'il est plus pratique d'ajuster le rapport d'aspect, mais qu'en est-il de la sémantique?).  Supposons que nous puissions trouver tous ces éléments, les marquer explicitement et les repeindre. </p><br><p>  La méthode est bonne en ce qu'elle conserve le rapport d'origine de luminosité et de contrastes.  En revanche, il y a beaucoup de problèmes, et ils l'emportent plutôt sur les avantages: </p><br><p><img src="https://habrastorage.org/webt/ed/qe/h1/edqeh1dpkqv-w2gydobzojuaia0.png" width="300"></p><br><ol><li>  Les pages sombres s'éclaircissent. </li><li>  Les couleurs résultantes ne peuvent pas être contrôlées - quel filtre appliquer pour affiner l'arrière-plan de votre entreprise <code>#bbbbb8</code> ?  L'énigme. </li><li>  Après deux repeintes, les images s'estompent. </li><li>  Tout ralentit (en particulier sur les téléphones) - c'est logique, maintenant au lieu d'un simple rendu, le navigateur doit piloter le traitement des images sur chaque écran. </li></ol><br><p>  Cette méthode conviendrait aux lettres composées de texte dans des tons neutres, mais qui sont les esthètes qui obtiennent une boîte de réception complète d'un contenu si particulier?  Mais les filtres peuvent repeindre des éléments dont le contenu n'est pas accessible - cadres, composants Web, images. </p><br><h2 id="adaptivnaya-tema">  Thème réactif </h2><br><p>  Il est temps pour la magie!  À partir des lacunes des deux premières approches, nous collectons une liste de contrôle: </p><br><ol><li>  Rendre l'arrière-plan sombre, le texte clair, les bordures moyennes. </li><li>  Identifiez les pages déjà sombres et ne les repeignez pas. </li><li>  Conservez le rapport d'origine de luminosité et de contraste. </li><li>  Donnez la possibilité de personnaliser les couleurs. </li><li>  Laissez les tons tels qu'ils étaient au début. </li></ol><br><p>  Nous devons changer les couleurs des styles afin que l'arrière-plan soit sombre.  Et pourquoi ne pas le faire littéralement?  Nous prenons simplement tous les styles, recherchons les règles associées aux couleurs ( <code>color</code> , <code>background</code> - <code>background</code> , <code>border</code> , <code>box-shadow</code> , leurs sous-propriétés) et le remplaçons par «assombri» - assombrissez l'arrière-plan, éclaircissez le texte, assombrissez moins les bordures que l'arrière-plan, etc. </p><br><p>  Cette méthode a un avantage incroyable qui réchauffera l'âme de tout développeur.  Chaque propriété peut être configurée (oui, décrivez directement avec un code!) Ses propres règles de conversion des couleurs.  Avec suffisamment d'imagination, vous pouvez intégrer n'importe quel thème externe, effectuer n'importe quelle correction des couleurs (par exemple, faire de la framboise claire ou gris-brun au lieu d'un thème sombre) et même ajouter un peu de contexte - par exemple, gérer différemment les bordures larges et étroites. </p><br><p>  Les inconvénients sont standard pour tout-en-js.  Oui, nous exécutons des scripts, rompons l'encapsulation des styles et analysons les expressions rationnelles CSS.  Eh bien, contrairement au HTML, ce dernier n'est pas si honteux car la grammaire CSS (du niveau dont nous avons besoin) est toujours régulière. </p><br><p>  Le plan de repeinture est le suivant: </p><br><ol><li>  Nous normalisons les propriétés héritées du style ( <code>bgcolor</code> et friends), les déplaçons vers <code>style="..."</code> . </li><li>  Trouvez tous les styles en ligne. </li><li>  Dans chaque style, nous trouvons toutes les règles de couleur (couleur de <code>background-color</code> , <code>color</code> , <code>box-shadow</code> , etc.). </li><li>  De toutes les règles de couleur, on obtient les couleurs, on trouve le convertisseur souhaité (assombrissant pour le fond, clarifiant pour le texte). </li><li>  Nous appelons le convertisseur. </li><li>  Remettre les règles converties en CSS. </li></ol><br><p>  La liaison (normalisation, recherche de style, analyse) est assez simple.  Nous allons voir comment fonctionne exactement notre <em>convertisseur</em> magique. </p><br><h3 id="hsl-preobrazovaniya">  Conversions HSL </h3><br><p>  "Gradation de la couleur" n'est pas une action aussi simple qu'il y paraît, surtout si nous voulons garder le ton (le cyan devient bleu foncé, pas orange).  Cela peut être fait en RVB normal, mais problématique.  Les amateurs de conception algorithmique savent que même les gradients sont tordus.  Mais travailler avec des couleurs en HSL est un pur plaisir: au lieu du rouge, du vert et du bleu, avec lesquels on ne sait pas quoi faire, nous avons trois autres canaux: </p><br><ul><li>  La teinte est juste le ton que nous voulons garder. </li><li>  Saturaion - saturation, ce qui n'est pas très important pour nous maintenant. </li><li>  Légèreté - la luminosité que nous changerons. </li></ul><br><p>  Il est commode d'imaginer un tel espace sous la forme d'un cylindre.  Et notre tâche est de renverser ce cylindre.  Les fonctions d'étalonnage des couleurs font quelque chose comme <code>(h, s, l) =&gt; [h, s, 1 - l]</code> . </p><br><h3 id="cveta-s-kotorymi-i-tak-vsyo-horosho">  Les couleurs avec lesquelles tout va bien </h3><br><p>  Parfois, la situation est réussie: le design exclusif de la lettre (ou d'une partie de celle-ci) est déjà sombre.  Dans ce cas, vous n'avez pas besoin de changer quoi que ce soit, il vaut mieux être juste tranquillement heureux - probablement le designer a choisi les couleurs pas pire que notre algorithme.  En HSL, regardez simplement la luminosité L.  S'il est supérieur (pour le texte) ou inférieur (pour l'arrière-plan) le seuil (qui, bien sûr, est personnalisable), nous ne faisons rien. </p><br><h3 id="dinamicheskiy-cirk">  Cirque dynamique </h3><br><p>  Bien que nous n'en ayons pas eu besoin (merci encore, désinfectant, vous m'avez sauvé de la folie!), Je vais toujours vous dire de quel type de modules complémentaires un thème adaptatif a besoin pour assombrir les pages entières, et pas seulement des lettres statiques stupides des années 90.  Plus précisément, c'est une tâche pour ceux qui aiment l'odeur des sélecteurs le matin. </p><br><h4 id="dinamicheskie-inlayn-stili">  Styles en ligne dynamiques </h4><br><p>  Le cas le plus simple qui casse notre page assombrie change les styles en ligne.  L'opération est fréquente, mais la correction est simple: ajoutez <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><code>MutationObserver</code></a> et réparez rapidement les styles en ligne lors du changement. </p><br><h4 id="vneshnie-stili">  Styles externes </h4><br><p>  Travailler avec des styles de <code>&lt;link&gt;</code> depuis l'intérieur de la page est plutôt pénible en raison de l'asynchronie et de <code>@import</code> , et <code>@import</code> n'est plus amusant.  Il semble que ce problème pourrait être résolu de façon assez élégante par le biais d'un travailleur Web (proxy pour <code>*.css</code> ). </p><br><h4 id="dinamicheskie-stili">  Styles dynamiques </h4><br><p>  Enfin, rassemblant tous nos problèmes, nous rappelons que le script peut généralement ajouter, supprimer et réorganiser (spécificité! Cascade!) <code>&lt;style&gt;</code> et <code>&lt;link&gt;</code> , et même changer les règles dans <code>&lt;style&gt;</code> .  Tout est résolu par le même <code>MutationObserver</code> pour les éléments de style, mais pour chaque changement, il y a plus de traitement. </p><br><h4 id="css-peremennye">  Variables CSS </h4><br><p>  Une toute nouvelle vague de folie survient lorsque les variables CSS entrent en jeu.  Nous ne pouvons pas obscurcir les variables elles-mêmes: même si nous supposons que nous devinerons par le format que la variable contient de la couleur (bien que je ne vous conseillerais pas de le faire), on ne sait pas dans quel rôle elle nous rencontrera - fond, texte, bordure, tout d'un coup?  De plus, les valeurs des variables sont héritées, nous devons donc considérer non seulement les styles, mais aussi les éléments auxquels elles sont appliquées, et tout cela dégénère et explose rapidement. </p><br><p>  Si les variables CSS atteignent le courant dominant, nous avons un problème.  D'un autre côté, à ce moment-là, <code>color()</code> sera déjà démarré, avec lequel il sera possible de ne pas changer les couleurs dans JS, mais simplement de remplacer les couleurs par <code>color(var(--bg) lightness(-50%))</code> . </p><br><h3 id="rezyume">  Résumé </h3><br><p><img src="https://habrastorage.org/webt/46/rl/mz/46rlmzxvgus52n7_77t3ydz2ms0.png"></p><br><p>  Dans notre cas, lorsque le désinfectant ne laisse que des styles en ligne, la gradation adaptative au niveau CSS fonctionne très bien: elle donne la meilleure qualité de gradation, ne casse pas les lettres et fonctionne relativement rapidement et facilement.  Je ne sais pas si l'option avec tout le rembourrage pour la dynamique en vaut la peine.  Heureusement, si vous travaillez avec du contenu généré par les utilisateurs et n'écrivez pas de navigateur, votre désinfectant devrait faire de même. </p><br><p>  En pratique, le mode adaptatif doit être utilisé avec la redéfinition des styles: les styles ne sont généralement pas explicitement appliqués aux éléments standard comme <code>&lt;input&gt;</code> ou <code>&lt;a&gt;</code> , mais par défaut ils sont légers. </p><br><h2 id="kak-zatemnyat-kartinki">  Comment assombrir les images </h2><br><p>  Repeindre des photos est un problème distinct qui me dérange personnellement.  C'est intéressant, et j'ai enfin la chance d'utiliser l'expression «analyse spectrale».  Il y a plusieurs problèmes courants avec les images sur un sujet sombre. </p><br><p>  Premièrement, les images sont trop claires.  Cela fonctionne de la même manière que les lettres non peintes avec lesquelles tout a commencé.  Ce sont souvent (mais pas nécessairement) des photographies ordinaires.  Étant donné que la mise en page des newsletters n'est pas très amusante, de nombreux gars exportent simplement la partie complexe de la lettre sous forme d'image, elle ne repeint pas et illumine la nuit mon perfectionnisme.  De telles images doivent être assombries, mais pas inversées - sinon un terrible négatif sortira. </p><br><p><img src="https://habrastorage.org/webt/6-/zz/nx/6-zznxvkap9ywdvgjpglm5v6wqc.png"></p><br><p>  Deuxièmement, des images sombres avec une réelle transparence.  Ce problème se retrouve souvent sur les logos - ils sont conçus pour un fond clair et, lorsque nous le remplaçons par un sombre, fusionnent avec lui.  Ces images doivent être inversées. </p><br><p><img src="https://habrastorage.org/webt/xo/at/cc/xoatcc7dg3nhb_ufdoyye4hxsoo.png"></p><br><p>  Quelque part au milieu, il y a des images pour lesquelles le blanc représente un "fond transparent", mais maintenant elles se trouvent juste dans un étrange rectangle blanc.  Dans un monde idéal, nous remplacerions un fond blanc par un fond transparent, mais si vous avez déjà travaillé avec une baguette magique dans un éditeur de photos, alors vous savez que le faire automatiquement n'est pas si facile. </p><br><p><img src="https://habrastorage.org/webt/fi/o4/v9/fio4v9n1lcpve_wa1jhj5usj4yo.png"></p><br><p>  Il est intéressant de noter que parfois les images n'ont aucune signification - ce sont des pixels de suivi et des «supports de format» dans une disposition particulièrement perverse.  Ceux-ci peuvent être rendus invisibles en toute sécurité (disons, <code>opacity: 0</code> ). </p><br><p><img src="https://habrastorage.org/webt/5y/ba/tu/5ybatucrfhczsgc_aqykbgtnop0.png"></p><br><h3 id="evristiki-s-introspekciey">  Heuristique d'introspection </h3><br><p>  Pour décider quoi faire de l'image, nous devons pénétrer à l'intérieur et analyser son contenu - et de manière simple et rapide.  Selon notre ensemble de problèmes, la première version de l'algorithme se profile.  Elle est là. </p><br><p>  Nous considérons les pixels sombres, clairs et transparents dans l'image, et pas tous, mais de manière sélective - une optimisation évidente.  Nous déterminons la luminosité globale de l'image (claire, sombre, moyenne) et la présence de transparence.  Inversez les images sombres avec transparence, la lumière sans transparence - muet, ne touchez pas le reste. </p><br><p>  La joie de cette merveilleuse heuristique a pris fin lorsque je suis tombé sur un bulletin de charité avec une photo d'une leçon dans une école africaine.  Tout irait bien, mais le concepteur l'a centré, en ajoutant des pixels transparents le long des bords.  Nous ne voulions pas nous retrouver au centre d'une nouvelle histoire sur la reconnaissance offensive des images, et nous avons décidé de ne pas du tout faire de traitement d'image dans la première version. </p><br><p>  À l'avenir, des heuristiques supplémentaires, que j'appelle simplement «analyse spectrale», devraient protéger contre de tels problèmes - nous comptons le nombre de couleurs différentes dans l'image et inversons seulement s'il y en a peu.  Le même critère peut être utilisé pour rechercher des images lumineuses graphiques et les repeindre également - cela semble tentant. </p><br><p><img src="https://habrastorage.org/webt/sj/c1/di/sjc1diiz68fpljjzii64f9j7nrq.png"></p><br><h2 id="itog">  Résumé </h2><br><p>  Pour un sujet sombre à part entière dans le courrier, nous manquions de repeindre les lettres avec des styles et nous avons trouvé comment les organiser.  Deux options simples en CSS pur - redéfinir les styles et un filtre CSS - n'ont pas fonctionné: la première est trop dure sur la conception d'origine, la seconde ne fonctionne tout simplement pas bien.  En conséquence, nous utilisons une gradation adaptative - nous analysons les styles, remplaçons les couleurs par des couleurs plus appropriées et les récupérons.  Maintenant, nous travaillons à développer le thème en images - pour cela, nous devons analyser leur contenu et n'en repeindre que quelques-uns. </p><br><p>  Si vous avez besoin de repeindre du code HTML personnalisé sur un thème sombre, gardez à l'esprit trois méthodes: </p><br><ul><li>  Remplacement des styles - vous en avez besoin de toute façon pour votre application principale, à moindre coût et avec colère, mais il tue toutes les couleurs d'origine. </li><li>  Le filtre CSS est cool, mais il fonctionne comme ça.  Utilisez uniquement pour les éléments opaques (en termes d'accès) tels que les cadres ou les composants Web. </li><li>  Conversion de styles - assombrit la très haute qualité, mais plus compliquée que les autres méthodes. </li></ul><br><p>  Même si vous ne faites jamais ça, j'espère que vous vous êtes amusé! </p><br><p>  <strong>Liens utiles</strong> : </p><br><ol><li><p>  Si vous êtes intéressé à discuter de ce sujet de manière animée et dans le contexte du développement pour Android, nous <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">vous invitons à visiter</a> le bureau de Yandex à Pétersbourg le 18 avril. </p><br></li><li><p>  Récemment, nous avons <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">parlé</a> de résoudre un autre problème des utilisateurs de messagerie - les problèmes de diffusion. </p><br></li></ol></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr446780/">https://habr.com/ru/post/fr446780/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr446768/index.html">Saisie nominale dans TypeScript ou comment protéger votre interface contre les identifiants étrangers</a></li>
<li><a href="../fr446770/index.html">12 astuces JavaScript introuvables dans la plupart des didacticiels</a></li>
<li><a href="../fr446772/index.html">N'ouvrez pas les ports au monde - ils vous briseront (risques)</a></li>
<li><a href="../fr446774/index.html">Conception de caractère Low Poly</a></li>
<li><a href="../fr446776/index.html">Preuve de travail efficace</a></li>
<li><a href="../fr446782/index.html">Yo-ho-ho et une bouteille de rhum</a></li>
<li><a href="../fr446786/index.html">Pourquoi ai-je refusé Disqus et tu devrais y aller aussi</a></li>
<li><a href="../fr446788/index.html">Trucs et astuces Kubernetes: sur le développement local et la téléprésence</a></li>
<li><a href="../fr446790/index.html">Comment j'ai découvert un œuf de Pâques dans la sécurité d'Android et que je n'ai pas décroché d'emploi chez Google</a></li>
<li><a href="../fr446794/index.html">Nous travaillons correctement avec Wordstat. Guide complet</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>