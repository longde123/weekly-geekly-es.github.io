<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üî≤ üë° üè° RxDart: transforma√ß√µes m√°gicas de fluxos üêã üßöüèª üëë</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Bem-vindo - Esta √© a terceira parte da minha s√©rie de artigos sobre Flutter Architecture. 


- 1. Introdu√ß√£o 
- Fundamentos do Dart Streams 
- RxDart:...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>RxDart: transforma√ß√µes m√°gicas de fluxos</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/451292/"><p>  Bem-vindo - Esta √© a terceira parte da minha s√©rie de artigos sobre Flutter Architecture. </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">1. Introdu√ß√£o</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Fundamentos do Dart Streams</a> </li><li>  <strong>RxDart: transforma√ß√µes de fluxo m√°gico (este post)</strong> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">No√ß√µes b√°sicas do RxVMS: RxCommand e GetIt</a> </li><li>  RxVMS: Servi√ßos e Gerentes </li><li>  RxVMS: widgets independentes </li><li>  Autentica√ß√£o de usu√°rio com RxVMS </li></ul><br><p> Desta vez, faremos um pequeno mergulho no reino m√°gico das extens√µes reativas (Rx).  Vou me concentrar nas fun√ß√µes Rx mais usadas e explicar sua aplica√ß√£o.  Se voc√™ n√£o leu a postagem anterior, agora √© a hora de fazer isso antes de prosseguir. </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">O RxDart</a> √© uma implementa√ß√£o do conceito Rx para a linguagem Dart, gra√ßas a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Frank Pepermans</a> e <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Brian Egan por isso</a> .  Se voc√™ j√° usou o Rx em outros idiomas, provavelmente notar√° uma diferen√ßa na nomea√ß√£o de v√°rias fun√ß√µes, mas √© improv√°vel que isso lhe cause dificuldades. </p><br><p>  O c√≥digo para teste est√° <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aqui</a> . </p><br><p>  At√© agora, usamos fluxos como uma maneira de transferir dados de um local para outro em nosso aplicativo, mas eles podem fazer muito mais.  Vamos dar uma olhada em alguns dos recursos que o Rx adiciona ao Streams. </p><a name="habracut"></a><br><h2 id="sozdanie-observables">  Criando Observ√°veis </h2><br><p>  Como <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">afirmado anteriormente</a> , os Observables s√£o vers√µes Rx de fluxos com √≥timos recursos.  Existem v√°rias maneiras interessantes de cri√°-los: </p><br><h3 id="iz-potoka">  Fora do fluxo </h3><br><p>  Qualquer fluxo pode ser convertido em Observable passando-o para o construtor: </p><br><pre><code class="cpp hljs">var controller = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StreamController&lt;String&gt;(); var streamObservable = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Observable(controller.stream); streamObservable.listen(print);</code> </pre> <br><h3 id="povtoryayuschiesya-sobytiya">  Eventos recorrentes </h3><br><pre> <code class="cpp hljs">var timerObservable = Observable.periodic(Duration(seconds: <span class="hljs-number"><span class="hljs-number">1</span></span>), (x) =&gt; x.toString() ); timerObservable.listen(print);</code> </pre> <br><p>  Dessa maneira, ser√° constru√≠do um Observ√°vel que exibe valores com um per√≠odo espec√≠fico.  Ent√£o voc√™ pode substituir o temporizador. </p><br><h3 id="iz-odinochnogo-znacheniya">  De um √∫nico valor </h3><br><p>  √Äs vezes, uma API espera um Stream / Observable em que voc√™ tenha apenas um valor.  Para tais casos, o Observable possui uma f√°brica. </p><br><pre> <code class="cpp hljs">var justObservable = Observable&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;.just(<span class="hljs-number"><span class="hljs-number">42</span></span>); justObservable.listen(print); <span class="hljs-comment"><span class="hljs-comment">//   : 42</span></span></code> </pre> <br><h3 id="iz-future">  Do futuro </h3><br><pre> <code class="cpp hljs"> Future&lt;String&gt; asyncFunction() async { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Future.delayed(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Duration(seconds: <span class="hljs-number"><span class="hljs-number">1</span></span>), () =&gt; <span class="hljs-string"><span class="hljs-string">"AsyncRsult"</span></span>); } test(<span class="hljs-string"><span class="hljs-string">'Create Observable from Future'</span></span>, () async { print(<span class="hljs-string"><span class="hljs-string">'start'</span></span>); var fromFutureObservable = Observable.fromFuture(asyncFunction()); fromFutureObservable.listen(print);</code> </pre> <br><p>  Criar um <code>Observable</code> partir do <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Futuro</a> aguardar√° que o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Futuro</a> seja conclu√≠do e retorne um valor para seu resultado ou <code>null</code> se o valor n√£o for retornado.  Outra maneira de criar um fluxo a partir do Future √© chamar <code>toStream()</code> para qualquer Future. </p><br><p>  Voc√™ pode estar se perguntando qual √© o sentido de converter o Futuro em um Observ√°vel / Fluxo em vez de apenas esperar por ele.  Tenha certeza, isso ficar√° claro quando examinarmos as fun√ß√µes dispon√≠veis para manipular dados enquanto eles est√£o no fluxo. </p><br><h3 id="subjects">  Assuntos </h3><br><p>  <code>Subjects</code> substituem o <code>StreamController</code> no RxDart e √© assim que eles s√£o implementados em algum lugar nas entranhas da biblioteca. </p><br><p>  Mas o comportamento deles √© um pouco diferente dos StreamControllers b√°sicos: </p><br><ul><li>  voc√™ pode aplicar <code>listen()</code> diretamente a um Assunto sem acessar a propriedade Stream </li><li>  qualquer n√∫mero de assinaturas est√° dispon√≠vel e todos os ouvintes recebem os mesmos dados ao mesmo tempo </li><li>  Existem tr√™s variedades de assuntos, que s√£o explicadas abaixo com exemplos: </li></ul><br><h4 id="publishsubjects">  PublishSubjects </h4><br><p>  <code>PublishSubjects</code> se comportam como <code>StreamControllers</code> , exceto pela possibilidade de muitos ouvintes: </p><br><pre> <code class="cpp hljs">var subject = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> PublishSubject&lt;String&gt;(); subject.listen((item) =&gt; print(item)); subject.add(<span class="hljs-string"><span class="hljs-string">"Item1"</span></span>); <span class="hljs-comment"><span class="hljs-comment">//    subject.listen((item) =&gt; print(item.toUpperCase())); subject.add("Item2"); subject.add("Item3"); //        await Future.delayed(Duration(seconds: 5)); //    subject.close;</span></span></code> </pre> <br><p>  Execute este c√≥digo e voc√™ obter√°: </p><br><pre> <code class="cpp hljs">Item1 ITEM2 Item2 ITEM3 Item3</code> </pre> <br><p>  √â claro que o segundo ouvinte que estava atrasado para a festa (n√≥s os chamaremos de assinantes atrasados) perdeu o primeiro ponto.  Para evitar isso, voc√™ pode usar o <code>BehaviourSubject</code> </p><br><h4 id="behavioursubject">  Behaviourubject </h4><br><p>  Com <code>BehaviourSubject</code> cada novo assinante receber√° primeiro o √∫ltimo valor aceito: </p><br><pre> <code class="cpp hljs">var subject = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BehaviorSubject&lt;String&gt;(); subject.listen((item) =&gt; print(item)); subject.add(<span class="hljs-string"><span class="hljs-string">"Item1"</span></span>); subject.add(<span class="hljs-string"><span class="hljs-string">"Item2"</span></span>); subject.listen((item) =&gt; print(item.toUpperCase())); subject.add(<span class="hljs-string"><span class="hljs-string">"Item3"</span></span>);</code> </pre> <br><p>  Na sa√≠da </p><br><pre> <code class="cpp hljs">Item1 ITEM2 ITEM3 Item2 Item3</code> </pre> <br><p>  Voc√™ pode ver que o <code>Item1</code> perdido para o segundo assinante, mas recebe o <code>Item2</code> .  Voc√™ pode se surpreender que o segundo assinante receba o <code>Item3</code> antes que o primeiro assinante receba o <code>Item2</code> .  Isso ocorre porque a sequ√™ncia de atendimento aos assinantes n√£o √© garantida, embora todos os assinantes recebam dados na ordem correta.  <code>BehaviourSubject</code> armazena em cache apenas o √∫ltimo item recebido para assinantes atrasados.  Se voc√™ precisar armazenar mais elementos em cache, poder√° usar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">ReplaySubject</a> .  Na maioria dos casos, isso n√£o √© necess√°rio. </p><br><h2 id="manipulirovanie-dannymi-na-letu">  Manipulando dados em tempo real </h2><br><p><img src="https://habrastorage.org/getpro/habr/post_images/ea5/dfe/1c6/ea5dfe1c65f93367e3207e2a0fe68908.gif"></p><br><p>  A verdadeira for√ßa do Rx reside no fato de permitir processar dados durante a transmiss√£o pelo fluxo.  Cada um dos m√©todos Rx retorna um novo fluxo com os dados resultantes (como na ilustra√ß√£o), o que significa que voc√™ pode vincul√°-los em um pipeline de processamento, e isso faz do Rx uma ferramenta extremamente poderosa. </p><br><h3 id="map">  Mapa </h3><br><p>  Se houver alguma opera√ß√£o de Stream que eu n√£o queira mais perder, esse √© o <code>map()</code> .  O que <code>map()</code> faz √© que leva cada item de dados a ser transferido e aplica uma certa fun√ß√£o a ele, ap√≥s o que coloca o resultado no fluxo resultante.  Um exemplo simples: </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/8e0/05a/ecc/8e005aecc11e119b7c856a4cadec9b11.gif"></p><br><pre> <code class="cpp hljs">var subject = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> PublishSubject&lt;String&gt;(); subject.<span class="hljs-built_in"><span class="hljs-built_in">map</span></span>((item) =&gt; item.toUpperCase()).listen(print); subject.add(<span class="hljs-string"><span class="hljs-string">"Item1"</span></span>); subject.add(<span class="hljs-string"><span class="hljs-string">"Item2"</span></span>); subject.add(<span class="hljs-string"><span class="hljs-string">"Item3"</span></span>);</code> </pre> <br><p>  Resultado: </p><br><pre> <code class="cpp hljs">ITEM1 ITEM2 ITEM3</code> </pre> <br><p>  Mas o <code>map</code> n√£o <code>map</code> necess√°rio para retornar o mesmo tipo de dados que ele recebe como entrada.  O exemplo a seguir ter√° n√∫meros inteiros em vez de cadeias.  Al√©m disso, vincularemos duas transforma√ß√µes: </p><br><pre> <code class="cpp hljs">var subject = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> PublishSubject&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;(); subject.<span class="hljs-built_in"><span class="hljs-built_in">map</span></span>((intValue) =&gt; intValue.toString()) .<span class="hljs-built_in"><span class="hljs-built_in">map</span></span>((item) =&gt; item.toUpperCase()) .listen(print); subject.add(<span class="hljs-number"><span class="hljs-number">1</span></span>); subject.add(<span class="hljs-number"><span class="hljs-number">2</span></span>); subject.add(<span class="hljs-number"><span class="hljs-number">3</span></span>);</code> </pre> <br><p>  ou algo parecido com isto: </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/0bb/73f/2a2/0bb73f2a2ccb82e6a920efbf2c395b0d.gif"></p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DataClass</span></span></span><span class="hljs-class">{</span></span>} <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">WrapperClass</span></span></span><span class="hljs-class"> {</span></span> final DataClass wrapped; WrapperClass(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.wrapped); } var subject = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> PublishSubject&lt;WrapperClass&gt;(); subject.<span class="hljs-built_in"><span class="hljs-built_in">map</span></span>&lt;WrapperClass&gt;((a) =&gt; <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> WrapperClass(a));</code> </pre> <br><p>  Um dos usos mais √∫teis do <code>.map</code> √© quando voc√™ obt√©m dados em um formato de alguma API REST ou de um banco de dados e deseja que eles sejam convertidos em seus pr√≥prios objetos: </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">User</span></span></span><span class="hljs-class"> {</span></span> final String name; final String adress; final String phoneNumber; final <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> age; <span class="hljs-comment"><span class="hljs-comment">//       - //   factory User.fromJson(String jsonString) { var jsonMap = json.decode(jsonString); return User( jsonMap['name'], jsonMap['adress'], jsonMap['phoneNumber'], jsonMap['age'], ); } User(this.name, this.adress, this.phoneNumber, this.age); @override String toString() { return '$name - $adress - $phoneNumber - $age'; } } void main() { test('Map', () { // -  var jsonStrings = [ '{"name": "Jon Doe", "adress": "New York", "phoneNumber":"424242","age": 42 }', '{"name": "Stephen King", "adress": "Castle Rock", "phoneNumber":"123456","age": 71 }', '{"name": "Jon F. Kennedy", "adress": "Washington", "phoneNumber":"111111","age": 66 }', ]; //   json-,    API/DB. var dataStreamFromAPI = new PublishSubject&lt;String&gt;(); dataStreamFromAPI .map&lt;User&gt;((jsonString) =&gt; User.fromJson(jsonString)) // json -&gt; User .listen((user) =&gt; print(user.toString())); //    dataStreamFromAPI.add(jsonStrings[0]); dataStreamFromAPI.add(jsonStrings[1]); dataStreamFromAPI.add(jsonStrings[2]); });</span></span></code> </pre> <br><p>  <em>Observo que n√£o apenas o Streams, mas tamb√©m qualquer Iterable oferece uma fun√ß√£o de <code>map</code> que voc√™ pode usar para transforma√ß√µes em listas.</em> </p><br><h3 id="where">  Onde </h3><br><p>  Se voc√™ estiver interessado apenas em determinados valores que ocorrem no fluxo, poder√° usar a fun√ß√£o <code>.where()</code> vez de usar a <code>if</code> no seu ouvinte, isso √© mais expressivo e f√°cil de ler: </p><br><pre> <code class="cpp hljs">var subject = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> PublishSubject&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;(); subject.where((val) =&gt; val.isOdd) .listen( (val) =&gt; print(<span class="hljs-string"><span class="hljs-string">'This only prints odd numbers: $val'</span></span>)); subject.where((val) =&gt; val.isEven) .listen( (val) =&gt; print(<span class="hljs-string"><span class="hljs-string">'This only prints even numbers: $val'</span></span>)); subject.add(<span class="hljs-number"><span class="hljs-number">1</span></span>); subject.add(<span class="hljs-number"><span class="hljs-number">2</span></span>); subject.add(<span class="hljs-number"><span class="hljs-number">3</span></span>); <span class="hljs-comment"><span class="hljs-comment">//: This only prints odd numbers: 1 This only prints even numbers: 2 This only prints odd numbers: 3</span></span></code> </pre> <br><h3 id="debounce">  Debounce </h3><br><p>  Esta √© uma das pequenas p√©rolas de Rx!  Imagine que voc√™ tenha um campo de pesquisa que chama a API REST se o texto for alterado.  Fazer uma chamada de API para cada pressionamento de tecla √© caro.  Assim, voc√™ gostaria de fazer uma liga√ß√£o apenas se o usu√°rio parar por um momento.  Para isso, √© usada a fun√ß√£o <code>debounce()</code> , que engole todos os eventos recebidos se n√£o forem seguidos por uma pausa. </p><br><pre> <code class="cpp hljs">var subject = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> PublishSubject&lt;String&gt;(); subject.debounce(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Duration(milliseconds: <span class="hljs-number"><span class="hljs-number">500</span></span>)).listen((s) =&gt; print(s)); subject.add(<span class="hljs-string"><span class="hljs-string">'A'</span></span>); subject.add(<span class="hljs-string"><span class="hljs-string">'AB'</span></span>); await Future.delayed(Duration(milliseconds: <span class="hljs-number"><span class="hljs-number">200</span></span>)); subject.add(<span class="hljs-string"><span class="hljs-string">"ABC"</span></span>); <span class="hljs-comment"><span class="hljs-comment">//    await Future.delayed(Duration(milliseconds: 700)); //       : 'ABC'</span></span></code> </pre> <br><p>  Portanto, se voc√™ converter o manipulador <code>TextField.onChanged</code> em <code>Observable</code> , obter√° uma solu√ß√£o elegante. </p><br><h3 id="expand">  Expandir </h3><br><p>  Se o seu Stream de origem emitir matrizes de objetos e voc√™ quiser processar cada objeto por conta pr√≥pria, poder√° usar <code>.expand</code> , o que far√° exatamente isso: </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/e8e/8d7/2b3/e8e8d72b36dddd0d3469107c6cdae2b1.gif" alt="imagem"></p><br><p>  Voc√™ ver√° a aplica√ß√£o deste m√©todo abaixo no exemplo do FireStore. </p><br><h3 id="merge">  Mesclar </h3><br><p>  Se voc√™ possui v√°rios threads diferentes, mas deseja processar seus objetos juntos, pode usar <code>.mergeWith</code> (em outras implementa√ß√µes de Rx apenas <code>merge</code> ), que pega uma matriz de threads e retorna um thread mesclado. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/a2f/9ba/82b/a2f9ba82b88b555841c21dc623c3d298.gif" alt="imagem"></p><br><p>  <code>.mergeWith</code> n√£o garante que nenhuma ordem nos fluxos seja mesclada.  Os dados s√£o emitidos em ordem de entrada. </p><br><p>  Por exemplo, se voc√™ possui dois componentes que relatam erros atrav√©s de um fluxo e deseja que eles sejam exibidos juntos em um di√°logo, √© poss√≠vel fazer o seguinte (pseudo-c√≥digo): </p><br><pre> <code class="cpp hljs">@<span class="hljs-function"><span class="hljs-function">override </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">initState</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ super.initState(); component1.errors.mergeWith([component2.errors]) .listen( (error) async =&gt; await showDialog(error.message)); }</code> </pre> <br><p>  ou se voc√™ quiser uma exibi√ß√£o combinada de mensagens de v√°rias redes sociais, pode ser assim (pseudoc√≥digo): </p><br><pre> <code class="cpp hljs">final observableTwitter = getTwitterStream().<span class="hljs-built_in"><span class="hljs-built_in">map</span></span>((data) =&gt; <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MyAppPost.fromTwitter(data)); final observableFacebook = getFacebookStream().<span class="hljs-built_in"><span class="hljs-built_in">map</span></span>((data) =&gt; <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MyAppPost.fromFaceBook(data)); final postStream = observableTwitter.mergeWith([observableFacebook]);</code> </pre> <br><h3 id="zipwith">  Zipwith </h3><br><p>  <code>zipWith</code> tamb√©m mescla um fluxo com outro.  Mas, diferentemente de <code>.mergeWith</code> , ele n√£o envia dados assim que recebe um elemento de um de seus fluxos de origem.  Ele espera at√© que os elementos dos dois fluxos de origem cheguem e os combina usando a fun√ß√£o <code>zipper</code> fornecida: </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/5ef/611/847/5ef611847db6bfa40237fb3622d93822.gif" alt="imagem"></p><br><p>  A assinatura <code>zipWith</code> parece assustadora, mas agora olhamos para ela: </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// R :   Stream/Observable // S :   Stream/Observable // zipper: - Observable&lt;R&gt; zipWith&lt;S, R&gt;(Stream&lt;S&gt; other, R zipper(T t, S s))</span></span></code> </pre> <br><p>  Um exemplo muito simplificado: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Observable.just(<span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-comment"><span class="hljs-comment">// .just()  Observable,    .zipWith(new Observable.just(2), (one, two) =&gt; one + two) .listen(print); //  3</span></span></code> </pre> <br><p>  Uma aplica√ß√£o mais pr√°tica √© se voc√™ precisar esperar por duas fun√ß√µes ass√≠ncronas que retornam <code>Future</code> e desejar processar os dados assim que os resultados forem retornados.  Neste exemplo um pouco artificial, apresentamos duas APIs REST: uma retorna <code>User</code> , a outra retorna <code>Product</code> como strings JSON, e queremos aguardar as duas chamadas antes de retornar o objeto <code>Invoice</code> . </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Invoice</span></span></span><span class="hljs-class"> {</span></span> final User user; final Product product; Invoice(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.user, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.product); printInvoice() { print(user.toString()); print(product.toString()); } } <span class="hljs-comment"><span class="hljs-comment">//  HTTP ,  Product,  JSON Future&lt;String&gt; getProduct() async { print("Started getting product"); await Future.delayed(Duration(seconds: 2)); print("Finished getting product"); return '{"name": "Flux compensator", "price": 99999.99}'; } //  HTTP ,  User,  JSON Future&lt;String&gt; getUser() async { print("Started getting User"); await Future.delayed(Duration(seconds: 4)); print("Finished getting User"); return '{"name": "Jon Doe", "adress": "New York", "phoneNumber":"424242","age": 42 }'; } void main() { test('zipWith', () async { var userObservable = Observable.fromFuture(getUser()).map&lt;User&gt;((jsonString) =&gt; User.fromJson(jsonString)); var productObservable = Observable.fromFuture(getProduct()) .map&lt;Product&gt;((jsonString) =&gt; Product.fromJson(jsonString)); Observable&lt;Invoice&gt; invoiceObservable = userObservable.zipWith&lt;Product, Invoice&gt;( productObservable, (user, product) =&gt; Invoice(user, product)); print("Start listening for invoices"); invoiceObservable.listen((invoice) =&gt; invoice.printInvoice()); //        await Future.delayed(Duration(seconds: 5)); }); }</span></span></code> </pre> <br><p>  Observando a sa√≠da, voc√™ pode ver como isso √© feito de forma ass√≠ncrona </p><br><pre> <code class="cpp hljs">Started getting User Started getting product Start listening <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> invoices Finished getting product Finished getting User Jon Doe - New York - <span class="hljs-number"><span class="hljs-number">424242</span></span> - <span class="hljs-number"><span class="hljs-number">42</span></span> Flux compensator - <span class="hljs-number"><span class="hljs-number">99999.99</span></span></code> </pre> <br><h3 id="combinelatest">  Combinelatest </h3><br><p>  <code>combineLatest</code> tamb√©m mescla valores de fluxo, mas de uma maneira ligeiramente diferente de <code>merge</code> e <code>zip</code> .  Ele escuta mais threads e emite um valor combinado sempre que um novo valor chega de um dos threads.  √â interessante que ele gere n√£o apenas o valor alterado, mas tamb√©m os √∫ltimos valores obtidos de todos os outros fluxos de origem.  Veja atentamente esta anima√ß√£o: </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/633/acb/bee/633acbbee01158bb7a6ad0450d39f712.gif" alt="imagem"></p><br><p>  Antes que <code>combineLates</code> seu primeiro valor, todos os encadeamentos de origem devem receber pelo menos uma entrada. </p><br><p>  Diferente dos m√©todos usados ‚Äã‚Äãanteriormente, o <code>combineLatest</code> √© est√°tico.  Al√©m disso, como o Dart n√£o permite sobrecarga do operador, existem vers√µes do <code>combLastest</code> dependendo do n√∫mero de fluxos de origem: <strong>combineLatest2 ... combineLatest9</strong> </p><br><p>  <code>combineLatest</code> bom uso, por exemplo, se voc√™ tiver dois <code>Observable&lt;bool&gt;</code> que sinalizam que algumas partes do seu aplicativo est√£o ocupadas e deseja exibir o bot√£o girat√≥rio Ocupado, se um deles estiver ocupado.  Pode ficar assim (pseudo-c√≥digo): </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Model</span></span></span><span class="hljs-class"> {</span></span> Observable&lt;<span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>&gt; get isBusy =&gt; Observable.combineLatest2(isBusyOne,isBusyTwo, (b1, b2) =&gt; b1 || b2); PublishSubject&lt;<span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>&gt; isBusyOne; PublishSubject&lt;<span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>&gt; isBusyTwo; }</code> </pre> <br><p>  Na sua interface do usu√°rio, voc√™ pode usar o <code>isBusy</code> com o <code>StreamBuilder</code> para exibir o <code>Spinner</code> se o valor resultante for verdadeiro. </p><br><p>  <code>combineLatest</code> recurso muito adequado em combina√ß√£o com os fluxos de <strong>captura instant√¢nea do FireStore</strong> . </p><br><p>  Imagine que voc√™ deseja criar um aplicativo que exiba um feed de not√≠cias e uma previs√£o do tempo.  As mensagens do rel√≥gio e os dados meteorol√≥gicos s√£o armazenados em duas cole√ß√µes diferentes do FireStore.  Ambos s√£o atualizados independentemente.  Voc√™ deseja exibir atualiza√ß√µes de dados usando o StreamBuilder.  Com o <code>combineLatest</code> √© f√°cil: </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">WeatherForecast</span></span></span><span class="hljs-class"> {</span></span> final String forecastText; final GeoPoint location; factory WeatherForecast.fromMap(Map&lt;String, dynamic&gt; <span class="hljs-built_in"><span class="hljs-built_in">map</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> WeatherForecast(<span class="hljs-built_in"><span class="hljs-built_in">map</span></span>[<span class="hljs-string"><span class="hljs-string">'forecastText'</span></span>], <span class="hljs-built_in"><span class="hljs-built_in">map</span></span>[<span class="hljs-string"><span class="hljs-string">'location'</span></span>]); } WeatherForecast(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.forecastText, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.location); } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NewsMessage</span></span></span><span class="hljs-class"> {</span></span> final String newsText; final GeoPoint location; factory NewsMessage.fromMap(Map&lt;String, dynamic&gt; <span class="hljs-built_in"><span class="hljs-built_in">map</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> NewsMessage(<span class="hljs-built_in"><span class="hljs-built_in">map</span></span>[<span class="hljs-string"><span class="hljs-string">'newsText'</span></span>], <span class="hljs-built_in"><span class="hljs-built_in">map</span></span>[<span class="hljs-string"><span class="hljs-string">'location'</span></span>]); } NewsMessage(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.newsText, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.location); } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CombinedMessage</span></span></span><span class="hljs-class"> {</span></span> final WeatherForecast forecast; final NewsMessage newsMessage; CombinedMessage(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.forecast, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.newsMessage); } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Model</span></span></span><span class="hljs-class"> {</span></span> CollectionReference weatherCollection; CollectionReference newsCollection; Model() { weatherCollection = Firestore.instance.collection(<span class="hljs-string"><span class="hljs-string">'weather'</span></span>); newsCollection = Firestore.instance.collection(<span class="hljs-string"><span class="hljs-string">'news'</span></span>); } Observable&lt;CombinedMessage&gt; getCombinedMessages() { Observable&lt;WeatherForecast&gt; weatherForecasts = weatherCollection .snapshots() .expand((snapShot) =&gt; snapShot.documents) .<span class="hljs-built_in"><span class="hljs-built_in">map</span></span>&lt;WeatherForecast&gt;((document) =&gt; WeatherForecast.fromMap(document.data)); Observable&lt;NewsMessage&gt; news = newsCollection .snapshots() .expand((snapShot) =&gt; snapShot.documents) .<span class="hljs-built_in"><span class="hljs-built_in">map</span></span>&lt;NewsMessage&gt;((document) =&gt; NewsMessage.fromMap(document.data)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Observable.combineLatest2( weatherForecasts, news, (weather, news) =&gt; CombinedMessage(weather, news)); } }</code> </pre> <br><p>  Na sua interface do usu√°rio, seria algo como isto: <code>StreamBuilder&lt;CombinedMessage&gt;(stream: model.getCombinedMessages(),...).</code> </p><br><h3 id="distinct">  Distinto </h3><br><p>  No cen√°rio descrito acima, pode acontecer que <strong>isBusyOne</strong> e <strong>isBusyTwo</strong> forne√ßam o mesmo valor, o que levar√° a uma atualiza√ß√£o da interface do usu√°rio com os mesmos dados.  Para evitar isso, podemos usar <code>.distinct()</code> .  Ele garante que os dados sejam transmitidos apenas se o valor do novo elemento for diferente do √∫ltimo.  Assim, mudar√≠amos o c√≥digo para: </p><br><pre> <code class="cpp hljs"> Observable&lt;<span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>&gt; isBusy =&gt; isBusyOne.mergeWith([isBusyTwo]).distinct();</code> </pre> <br><p>  e tamb√©m demonstra que podemos combinar nossas fun√ß√µes em diferentes cadeias √† vontade. </p><br><h3 id="asyncmap">  Asyncmap </h3><br><p>  Al√©m de <code>map()</code> tamb√©m h√° uma fun√ß√£o <code>asyncMap</code> , que permite usar uma fun√ß√£o ass√≠ncrona como uma fun√ß√£o de mapa.  Vamos introduzir uma configura√ß√£o ligeiramente diferente para o nosso exemplo do FireStore.  Agora, o <strong>WeatherForecast</strong> necess√°rio depende da localiza√ß√£o do <strong>NewsMessage</strong> e s√≥ deve ser atualizado quando um novo <strong>NewsMessage for recebido</strong> : </p><br><pre> <code class="cpp hljs">Observable&lt;CombinedMessage&gt; getDependendMessages() { Observable&lt;NewsMessage&gt; news = newsCollection.snapshots().expand((snapShot) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> snapShot.documents; }).<span class="hljs-built_in"><span class="hljs-built_in">map</span></span>&lt;NewsMessage&gt;((document) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> NewsMessage.fromMap(document.data); }); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> news.asyncMap((newsEntry) async { var weatherDocuments = await weatherCollection.where(<span class="hljs-string"><span class="hljs-string">'location'</span></span>, isEqualTo: newsEntry.location).getDocuments(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CombinedMessage( WeatherForecast.fromMap(weatherDocuments.documents.first.data), newsEntry); }); }</code> </pre> <br><p>  O Observable retornado por getDependendMessages gerar√° um novo CombinedMessage toda vez que o newsCollection for alterado. </p><br><h2 id="otladka-observables">  Observ√°veis ‚Äã‚Äãde depura√ß√£o </h2><br><p>  Observando as elegantes cadeias de chamadas Rx, parece quase imposs√≠vel depurar uma express√£o como esta: </p><br><pre> <code class="cpp hljs">Observable&lt;NewsMessage&gt; news = newsCollection .snapshots() .expand((snapShot) =&gt; snapShot.documents) .<span class="hljs-built_in"><span class="hljs-built_in">map</span></span>&lt;NewsMessage&gt;((document) =&gt; NewsMessage.fromMap(document.data));</code> </pre> <br><p>  Mas lembre-se de que <code>=&gt;</code> √© apenas um pequeno formul√°rio para uma fun√ß√£o an√¥nima.  Usando <strong>Converter para bloquear o corpo</strong> , voc√™ obter√°: </p><br><pre> <code class="cpp hljs">Observable&lt;NewsMessage&gt; news = newsCollection .snapshots() .expand((snapShot) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> snapShot.documents; }) .<span class="hljs-built_in"><span class="hljs-built_in">map</span></span>&lt;NewsMessage&gt;((document) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> NewsMessage.fromMap(document.data); });</code> </pre> <br><p>  E agora podemos definir um ponto de interrup√ß√£o ou adicionar instru√ß√µes de impress√£o em todas as etapas do nosso pipeline. </p><br><h2 id="osteregaytes-pobochnyh-effektov">  Cuidado com os efeitos colaterais </h2><br><p>  <strong>Se voc√™ deseja capitalizar o Rx para tornar seu c√≥digo mais robusto, lembre-se sempre de que o Rx √© uma convers√£o de dados ao mov√™-lo "ao longo da correia transportadora".</strong>  <strong>Portanto, nunca chame fun√ß√µes que alterem quaisquer vari√°veis ‚Äã‚Äã/ estados fora do pipeline de processamento at√© atingir a fun√ß√£o .listen.</strong> <br>  Em vez de fazer isso: </p><br><pre> <code class="cpp hljs">Observable.fromFuture(getProduct()) .<span class="hljs-built_in"><span class="hljs-built_in">map</span></span>&lt;Product&gt;((jsonString) { var product = Product.fromJson(jsonString); database.save(product); setState((){ _product = product }); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> product; }).listen();</code> </pre> <br><p>  fa√ßa o seguinte: </p><br><pre> <code class="cpp hljs">Observable.fromFuture(getProduct()) .<span class="hljs-built_in"><span class="hljs-built_in">map</span></span>&lt;Product&gt;((jsonString) =&gt; Product.fromJson(jsonString)) .listen( (product) { database.save(product); setState((){ _product = product }); });</code> </pre> <br><p>  O dever do <code>map()</code> √© transformar os dados no fluxo, E NADA MAIS!  Se a fun√ß√£o de exibi√ß√£o passada fizer outra coisa, ela ser√° considerada um efeito colateral, gerando erros em potencial que s√£o dif√≠ceis de detectar ao ler o c√≥digo. </p><br><h2 id="nekotorye-mysli-ob-osvobozhdenii-resursov">  Algumas reflex√µes sobre como liberar recursos </h2><br><p>  Para evitar vazamentos de mem√≥ria, sempre chame <code>cancel()</code> para assinaturas, <code>dispose()</code> para StreamControllers, <code>close()</code> para Assuntos, assim que voc√™ n√£o precisar mais deles. </p><br><h2 id="zaklyuchenie">  Conclus√£o </h2><br><p>  Parab√©ns se voc√™ ficou comigo at√© esse momento.  Agora voc√™ pode n√£o apenas usar o Rx para facilitar sua vida, mas tamb√©m se preparar para as pr√≥ximas postagens nas quais iremos nos aprofundar nos detalhes do <strong>RxVMS</strong> . </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt451292/">https://habr.com/ru/post/pt451292/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt451276/index.html">Como construir uma marca?</a></li>
<li><a href="../pt451278/index.html">An√°lise da Wavelet - Parte 1</a></li>
<li><a href="../pt451280/index.html">Os metais mais interessantes</a></li>
<li><a href="../pt451282/index.html">Buracos negros na an√°lise da Web: quantos dados s√£o perdidos no GA e por que</a></li>
<li><a href="../pt451286/index.html">Roskomnadzor, que merecemos</a></li>
<li><a href="../pt451294/index.html">Como adicionei fun√ß√µes ao carro via CAN, n√£o consigo programar</a></li>
<li><a href="../pt451296/index.html">Anunciado pelo ML.NET 1.0</a></li>
<li><a href="../pt451298/index.html">Como criar um console de jogos com um estojo solicitando uma placa de circuito impresso</a></li>
<li><a href="../pt451302/index.html">Principais empresas de terceiriza√ß√£o de TI</a></li>
<li><a href="../pt451304/index.html">Yandex "tip": como maximizar os lucros em uma assinatura paga</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>