<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üß° üè∫ ü§¨ Optimizaci√≥n de modelos 3D para la escena del juego. üéÜ üë´ üëäüèº</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Este art√≠culo completa una serie de publicaciones del estudio Krasnodar Plarium sobre varios aspectos del trabajo con modelos 3D en Unity. Art√≠culos a...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Optimizaci√≥n de modelos 3D para la escena del juego.</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/plarium/blog/484792/">  Este art√≠culo completa una serie de publicaciones del estudio Krasnodar Plarium sobre varios aspectos del trabajo con modelos 3D en Unity.  Art√≠culos anteriores: <a href="https://habr.com/ru/company/plarium/blog/440690/">"Caracter√≠sticas de trabajar con Mesh in Unity"</a> , <a href="https://habr.com/ru/company/plarium/blog/443870/">"Unity: edici√≥n de procedimientos de Mesh"</a> , <a href="https://habr.com/ru/company/plarium/blog/447820/">"Importaci√≥n de modelos 3D en Unity y escollos"</a> , <a href="https://habr.com/ru/company/plarium/blog/451794/">"Muesca de p√≠xeles en el escaneo de texturas"</a> . <br><br>  Hace casi 2 a√±os escribimos <a href="https://habr.com/ru/company/plarium/blog/348494/">un art√≠culo</a> en el que hablamos sobre la opci√≥n de optimizar la geometr√≠a 3D en una escena con restricciones en el √°ngulo de la c√°mara y la rotaci√≥n de los objetos correspondientes.  No ha fluido mucho desde entonces, pero la oportunidad de mejorar la soluci√≥n, considerar diferentes enfoques y espiar a otros est√° obsesionando las mentes de los desarrolladores.  En este art√≠culo, describiremos una versi√≥n mejorada del algoritmo basado en pintar pol√≠gonos, y hablaremos sobre tratar de transferir parte de este trabajo a un paquete 3D. <br><br><img src="https://habrastorage.org/webt/jl/v-/pz/jlv-pzi5qagnnmqhgkqaddzo1uo.jpeg"><a name="habracut"></a><br><br><h3>  Recortar en la escena </h3><br>  Ya consideramos el principio b√°sico de este algoritmo en el art√≠culo anterior: extinguimos todos los efectos y objetos transparentes, pintamos pol√≠gonos no procesados ‚Äã‚Äãen un color y procesamos los de diferentes colores, renderizamos y extraemos el resultado.  En la versi√≥n anterior, pintaban de modo que todo lo negro fuera redundante, y solo un tri√°ngulo estaba marcado en rojo. <br><br>  <a href="https://habr.com/ru/company/plarium/blog/348494/">En los comentarios</a> a ese art√≠culo, uno de los lectores se√±al√≥ la posibilidad de optimizar el algoritmo estableciendo una correspondencia uno a uno entre el conjunto de pol√≠gonos y alg√∫n conjunto de n√∫meros √∫nicos.  Entonces ser√° posible procesar m√°s de un tri√°ngulo de la misma manera.  Considera esta opci√≥n. <br><br>  En este caso, as√≠ como en la √∫ltima vez, se supone que algunos entrenamientos previos est√°n relacionados con la desactivaci√≥n de todos los objetos silbantes en el escenario y los objetos que se garantiza que no afectar√°n la visibilidad del modelo objetivo.  Las vistas de la c√°mara se procesan casi de forma independiente; est√°n conectadas solo por un b√∫fer de √≠ndice com√∫n de pol√≠gonos visibles.  Adem√°s, se realiza un preprocesamiento de geometr√≠a para cada √°ngulo, durante el cual se giran los pol√≠gonos que se vuelven a la c√°mara ( <b>cara posterior</b> ).  Esto se hace porque en una determinada etapa del algoritmo se crea una malla temporal con un n√∫mero significativamente mayor de v√©rtices que la original.  Este n√∫mero puede superar f√°cilmente el umbral de 65.535, lo que requerir√° gestos adicionales en los c√°lculos y reducir√° el rendimiento.  En cualquier caso, estos pol√≠gonos se eliminar√°n, ya que su color no caer√° en el marco.  Sin embargo, debido al hecho de que cada tri√°ngulo potencialmente da lugar a tres v√©rtices de basura, la eliminaci√≥n anticipada de pol√≠gonos innecesarios facilita la etapa principal del algoritmo y reduce los costos de memoria. <br><br>  Que haya alg√∫n modelo 3D, cuya geometr√≠a est√© representada por una malla.  Para pintar un pol√≠gono espec√≠fico en un color √∫nico, debe pintar todos sus v√©rtices en este color.  Como en el caso general un v√©rtice puede pertenecer a diferentes pol√≠gonos, no ser√° posible resolver el problema de frente.  No importa c√≥mo coloreamos cualquier v√©rtice, al renderizar, su color se arrastrar√° sobre todos los tri√°ngulos que lo poseen, de acuerdo con el algoritmo de interpolaci√≥n en el lado de la tarjeta de video. <br><br><img src="https://habrastorage.org/webt/ay/td/qo/aytdqo0ah1fzsl7pcasymag9rf8.jpeg"><br>  <i>Un ejemplo de interpolaci√≥n de color al mostrar pol√≠gonos con v√©rtices comunes</i> <br><br>  Por lo tanto, es necesario dividir de alguna manera la malla en pol√≠gonos independientes separados, mientras se preserva la topolog√≠a y la geometr√≠a del objeto.  Dictum factum.  Transformamos las matrices de tri√°ngulos y v√©rtices de tal manera que para cada tri√°ngulo se crear√°n 3 v√©rtices √∫nicos, cuya posici√≥n est√° determinada por los v√©rtices correspondientes de la malla original.  Vale la pena se√±alar que, en el caso general, dicha malla tendr√° un n√∫mero significativamente mayor de v√©rtices en comparaci√≥n con el original.  Y si este n√∫mero excedi√≥ 65 535, al crear la malla, debe especificar el formato de indexaci√≥n apropiado. <br><br><div class="spoiler">  <b class="spoiler_title">Convierta la malla original en una malla con v√©rtices √∫nicos para cada pol√≠gono</b> <div class="spoiler_text"><pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Mesh </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetNotSmoothMesh</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Mesh origin</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> oVertices = origin.vertices; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> oTriangles = origin.triangles; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> vertices = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector3[oTriangles.Length]; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> triangles = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[oTriangles.Length]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; triangles.Length; i++) { vertices[i] = oVertices[oTriangles[i]]; triangles[i] = i; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Mesh() { indexFormat = vertices.Length &gt; <span class="hljs-number"><span class="hljs-number">65535</span></span> ? IndexFormat.UInt32 : IndexFormat.UInt16, vertices = vertices, triangles = triangles }; }</code> </pre> <br></div></div><br>  Ahora debe designar los pol√≠gonos de esta malla para que despu√©s de la operaci√≥n de renderizado sea posible determinar cu√°l apareci√≥ en la pantalla.  Como ya se mencion√≥, generamos colores √∫nicos para los pol√≠gonos y pintamos cada uno de los tres v√©rtices en el color correspondiente.  El resultado es una nueva malla, que llamamos <b>Byte-Colored Mesh</b> . <br><br><img src="https://habrastorage.org/webt/jl/l0/co/jll0coliukddunmhl5kizfzwpzq.jpeg"><br>  <i><b>Malla de color byte</b></i> <br><br><div class="spoiler">  <b class="spoiler_title">Color de malla en el que cada v√©rtice pertenece a un solo pol√≠gono</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ColorizePolygons</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Mesh mesh</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> pColors = ColorsOfPolygons(mesh); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> colors = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Color[mesh.vertexCount]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; colors.Length; i++) { colors[i] = pColors[i / <span class="hljs-number"><span class="hljs-number">3</span></span>]; } mesh.colors = colors; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Color[] </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetColorsOfPolygons</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Mesh mesh</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> colors = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Color[mesh.triangles.Length / <span class="hljs-number"><span class="hljs-number">3</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; colors.Length; i++) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> color = Int2Color(i);<span class="hljs-comment"><span class="hljs-comment">//         ,     Color2Int //      ,       int     Color32 colors[i] = color; } return colors; }</span></span></code> </pre> <br></div></div><br>  Recuerda el color.  Es hora de rendir.  Realizamos renderizado 3D para todos los √°ngulos de c√°mara y, al procesar cada uno de ellos, reponemos el b√∫fer de √≠ndices de pol√≠gono √∫nicos cuyos colores se detectaron en el marco.  Para el momento de los c√°lculos de la c√°mara, debe desactivar el suavizado para evitar la aparici√≥n de nuevos colores debido a la interpolaci√≥n de p√≠xeles vecinos. <br><br><div class="spoiler">  <b class="spoiler_title">Lectura y almacenamiento de colores desde diferentes √°ngulos de c√°mara.</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// CameraTransform ‚Äî         //      SetCameraTransform private static HashSet&lt;Color&gt; GetVisibleColors(Camera camera, CameraTransform[] cameraTransforms) { var renderTexture = new RenderTexture(1920, 1080, 24);//for example var rtRect = new Rect(0, 0, renderTexture.width, renderTexture.height); var frame = new Texture2D(renderTexture.width, renderTexture.height, TextureFormat.RGB24, false);//    -  RGB24   ,    RGBA32 var visibleColorsSet = new HashSet&lt;Color&gt;(); foreach (var cameraTransform in cameraTransforms) { SetCameraTransform(camera, cameraTransform); CreateScreenShot(camera, renderTexture, frame, rtRect); visibleColorsSet.UnionWith(GetTextureColors(frame)); } return visibleColorsSet; } public static void SetCameraTransform(Camera camera, CameraTransform camTransform) { camera.transform.position = camTransform.Position; camera.transform.rotation = camTransform.Rotation; camera.fieldOfView = camTransform.FieldOfView; camera.orthographic = camTransform.IsOrthographic; camera.nearClipPlane = camTransform.NearClippingPlane; camera.farClipPlane = camTransform.FarClippingPlane; } private static HashSet&lt;Color&gt; GetTextureColors(Texture2D texture) { return new HashSet&lt;Color&gt;(texture.GetPixels()); } private static void CreateScreenShot(Camera cam, RenderTexture renderTexture, Texture2D screenShot, Rect renderTextureRect) { cam.targetTexture = renderTexture; cam.Render(); RenderTexture.active = cam.targetTexture; screenShot.ReadPixels(renderTextureRect, 0, 0); RenderTexture.active = null; cam.targetTexture = null; } }</span></span></code> </pre> <br></div></div><br>  Vale la pena mencionar que debido a la discretizaci√≥n, es posible que algunos tri√°ngulos no se muestren debido al tama√±o especialmente peque√±o de su proyecci√≥n en la pantalla, y no porque algo se superponga o se gire del lado equivocado.  Hemos implementado una versi√≥n conservadora del algoritmo.  En este caso, se calcula el <b>AABB de la</b> proyecci√≥n del tri√°ngulo en la pantalla, y si al menos uno de sus lados es menor que el lado de texel en la imagen, dicho pol√≠gono se marca como visible.  Este enfoque protege contra los artefactos cuando se ejecuta el algoritmo con una resoluci√≥n inferior a la resoluci√≥n de pantalla del dispositivo de destino.  Si ignora los pol√≠gonos peque√±os, el resultado tambi√©n ser√° aceptable siempre que la resoluci√≥n de la textura renderizada utilizada sea mayor que la resoluci√≥n de las pantallas de los dispositivos previstos. <br><br>  Implementamos este algoritmo de recorte en <b>Unity</b> y lo usamos para optimizar objetos est√°ticos cuyos modelos se encuentran en la escena m√°s de una vez en varias posiciones.  Este es principalmente el escenario: piedras, √°rboles, estatuas, jarrones, etc., que se refiere al prefabricado de uso frecuente.  Nos gustar√≠a optimizar dichos objetos antes, en la etapa de creaci√≥n en un paquete 3D, pero qui√©n sabe en qu√© pose fantasmag√≥rica el dise√±ador de niveles quiere poner su candelabro favorito. <br><br>  Recortar el conjunto de objetos del mismo tipo con una herramienta de este tipo reduce el tama√±o de la escena, ya que durante <b>el procesamiento por lotes est√°tico, los</b> datos de la malla <b>prefabricada</b> com√∫n se copian en la etapa de construcci√≥n tantas veces como los objetos dibujados activos con esta malla se representan en la escena.  Nuestro m√©todo tambi√©n libera espacio en atlas de texturas, como el <b>mapa de luz</b> .  Utilizamos el espacio guardado para aumentar el detalle de las partes de los modelos que sobrevivieron a la limpieza. <br><br><h3>  Recorte 3D </h3><br>  Sin embargo, es mejor si el artista puede cortar todo lo innecesario en su editor, reduciendo as√≠ el n√∫mero de etapas de preparaci√≥n de contenido.  Esto se justifica cuando el modelo se usa en una escena con solo una rotaci√≥n predeterminada en relaci√≥n con la c√°mara.  Anteriormente, los objetos que ser√≠an dirigidos exactamente al usuario por un lado a menudo se simplificaban manualmente antes de la integraci√≥n en el proyecto.  Es importante tener en cuenta que implementar dicha simplificaci√≥n mediante programaci√≥n en <b>Unity es</b> mucho m√°s dif√≠cil debido a la complejidad del desarrollo de los paquetes <b>UV</b> , por lo que la automatizaci√≥n en la etapa de un paquete 3D a veces facilita la vida de un artista. <br><br>  Una de las herramientas para trabajar con modelos 3D en nuestra empresa es <b>Blender</b> .  Nos subimos a ella.  Parece que un software tan "adulto", como <b>Blender</b> , deber√≠a tener una funcionalidad similar.  Sin embargo, result√≥ que no deber√≠a.  Tuve que ver mi propia bicicleta. <br><br>  La primera idea era usar la herramienta de selecci√≥n familiar: b√°sicamente, repetir parte del trabajo manual del artista para un √°ngulo de c√°mara: seleccionar pol√≠gonos visibles, invertir selecci√≥n, eliminar.  El plan era este: mover la c√°mara, determinar la proyecci√≥n <b>AABB</b> del modelo en cada posici√≥n, luego solicitar el resultado de seleccionar los pol√≠gonos del √°rea correspondiente al <b>AABB</b> , obtener la uni√≥n del conjunto de pol√≠gonos de la vista actual con los anteriores y eliminar los pol√≠gonos no seleccionados al final. <br><br>  Sin embargo, durante la implementaci√≥n del script, se encontr√≥ un inconveniente significativo en t√©rminos de la tarea.  Las herramientas de selecci√≥n en <b>Blender (selecci√≥n de rect√°ngulo, selecci√≥n de c√≠rculo)</b> <a href="https://blender.stackexchange.com/questions/43886/why-wont-lasso-or-box-select-select-all-of-the-faces-in-the-region/93482">pierden precisi√≥n</a> al aumentar el n√∫mero de elementos seleccionados por unidad de √°rea de la pantalla (algunos pol√≠gonos permanecen sin seleccionar), lo que hace que su uso en nuestras herramientas de automatizaci√≥n sea imposible.  Dato interesante: en el mismo <b>3ds Max</b> no se observa este problema. <br><br><img src="https://habrastorage.org/webt/ai/rr/bf/airrbf1enz0jfiucjtrhrbzv8bw.jpeg"><br>  <i>Destacando desde lejos en <b>Blender</b></i> <br><br><img src="https://habrastorage.org/webt/gt/vy/mh/gtvymh56yk7vp5lrwsvuav4fjqq.jpeg"><br>  <i>Resultado de seleccion</i> <br><br>  El siguiente intento ten√≠a como objetivo resolver el problema en la frente: enviamos rayos desde la c√°mara a trav√©s de cada p√≠xel de la ventana y observamos qu√© pol√≠gonos fueron los primeros en cruzarse con al menos un rayo.  No esper√°bamos resultados precisos con este enfoque, pero vali√≥ la pena intentarlo.  El resultado es obvio: muy baja productividad al procesar en la <b>CPU</b> o los mismos agujeros con un peque√±o n√∫mero de rayos. <br><br>  Sin embargo, establecimos un punto de apoyo para la implementaci√≥n de un enfoque m√°s avanzado.  La idea era seleccionar un cierto n√∫mero de puntos aleatorios en cada pol√≠gono y luego enviar rayos desde la c√°mara en su direcci√≥n.  Este enfoque funcion√≥ bien, pero tuvimos algunos casos l√≠mite: tambi√©n se cortaron los pol√≠gonos, en los que el √°ngulo entre el haz y su normalidad era aproximadamente igual a œÄ / 2.  Por lo tanto, cuando la c√°mara hace zoom debido a distorsiones de perspectiva, se pueden abrir √°reas recortadas. <br><br>  Este m√©todo fue, en opini√≥n de los artistas, demasiado agresivo, por lo que decidimos centrarnos en <b>recortar</b> solo las <b>caras posteriores</b> . <br><br><h3>  Conclusi√≥n </h3><br>  No es ning√∫n secreto que una actitud cuidadosa con los recursos del dispositivo al crear juegos es el factor m√°s importante que afecta la calidad del producto final.  Esto es especialmente cierto para las plataformas m√≥viles, de mal humor para el uso activo de RAM.  Reducir el n√∫mero de pol√≠gonos le permite llenar de manera m√°s efectiva el espacio de los atlas de textura y reduce ligeramente la carga computacional. <br><br>  Adem√°s, no olvide el costo de las horas hombre y el costo de los errores al usar las herramientas descritas anteriormente, y similares.  El enfoque propuesto supone una tuber√≠a que funcione bien para el trabajo del departamento de arte, especialmente para los empleados involucrados en la integraci√≥n de modelos en el proyecto. <br><br>  Por lo tanto, teniendo las condiciones y herramientas discutidas en este art√≠culo, nos adherimos a las siguientes reglas.  Si se supone que el modelo creado siempre ser√° volteado por un lado para el usuario, y tambi√©n si desde estos √°ngulos la superposici√≥n de algunas partes del modelo por otras es bastante peque√±a, entonces el artista usa nuestra <b>herramienta de</b> recorte de la <b>cara posterior</b> en el editor 3D, verifica la correcci√≥n y contin√∫a con el empaquetado de desarrollo <b>UV</b> .  Si el modelo se usa a menudo en diferentes posiciones o tiene una geometr√≠a m√°s compleja, luego de importarlo al proyecto, ejecutamos el algoritmo descrito en la primera parte del art√≠culo, procesando todos los objetos est√°ticos de la escena con √©l. </div></div><p>Source: <a href="https://habr.com/ru/post/484792/">https://habr.com/ru/post/484792/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../484776/index.html">Eventos digitales en San Petersburgo del 21 al 26 de enero.</a></li>
<li><a href="../484778/index.html">Intel Parallel Studio XE 2020: todo lo mejor para desarrolladores</a></li>
<li><a href="../484782/index.html">Blazor Client Side Online Store: Parte 2 - CI / CD</a></li>
<li><a href="../484788/index.html">M√°s funciones para su sistema: integraci√≥n de telefon√≠a y CRM / ERP / Helpdesk. ¬øQu√©, c√≥mo y por qu√©?</a></li>
<li><a href="../484790/index.html">La historia de c√≥mo, debido a una opci√≥n en el servidor de Windows, nuestros sitios se ralentizaron</a></li>
<li><a href="../484796/index.html">¬øC√≥mo obtuve la certificaci√≥n OSWE?</a></li>
<li><a href="../484798/index.html">¬øPor qu√© la clasificaci√≥n r√°pida es realmente lenta? Nuevo m√©todo de ordenaci√≥n de matriz</a></li>
<li><a href="../484800/index.html">Analizador de c√≥digo fuente de Microsoft Application Inspector</a></li>
<li><a href="../484802/index.html">Modo de autodestrucci√≥n: descomposici√≥n de la c√°psula endosc√≥pica debido a la luz.</a></li>
<li><a href="../484804/index.html">¬øQu√© cifrar en un sistema corporativo? ¬øY por qu√© haces esto?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>