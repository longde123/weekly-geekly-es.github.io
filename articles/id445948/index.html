<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🔪 🤶🏻 🧗🏻 Warisan dalam C ++: pemula, menengah, lanjutan ⛪️ 🕯️ 🕖</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Artikel ini menjelaskan warisan pada tiga tingkat: pemula, menengah, dan lanjutan. Pakar no. Dan tidak sepatah kata pun tentang SOLID. Jujur. 
 Pemula...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Warisan dalam C ++: pemula, menengah, lanjutan</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/445948/"><p> Artikel ini menjelaskan warisan pada tiga tingkat: pemula, menengah, dan lanjutan.  Pakar no.  Dan tidak sepatah kata pun tentang SOLID.  Jujur. </p><br><h1 id="beginner">  Pemula </h1><br><h3 id="chto-takoe-nasledovanie">  Apa itu warisan? </h3><br><p>  Warisan adalah salah satu prinsip dasar OOP.  Menurutnya, sebuah kelas dapat menggunakan variabel dan metode dari kelas lain sebagai miliknya. </p><br><p>  Kelas yang mewarisi data disebut subclass, kelas turunan, atau kelas anak.  Kelas dari mana data atau metode diwarisi disebut kelas super, kelas dasar, atau kelas induk.  Istilah "orang tua" dan "anak" sangat berguna untuk memahami warisan.  Ketika seorang anak menerima karakteristik orang tuanya, kelas turunannya menerima metode dan variabel dari kelas dasar. </p><br><p>  Warisan berguna karena memungkinkan Anda untuk menyusun dan menggunakan kembali kode, yang pada gilirannya <a name="habracut"></a>  secara signifikan dapat mempercepat proses pengembangan.  Meskipun demikian, pewarisan harus digunakan dengan hati-hati, karena sebagian besar perubahan dalam superclass akan mempengaruhi semua subclass, yang dapat menyebabkan konsekuensi yang tidak terduga. </p><br><p> Dalam contoh ini, metode <code>turn_on()</code> dan variabel <code>serial_number</code> tidak dideklarasikan atau didefinisikan dalam subkelas <code>Computer</code> .  Namun, mereka dapat digunakan karena mereka diwarisi dari kelas dasar. </p><br><p>  <em>Catatan Penting</em> : Variabel dan metode pribadi tidak dapat diwariskan. </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;iostream&gt; using namespace std; class Device { public: int serial_number = 12345678; void turn_on() { cout &lt;&lt; "Device is on" &lt;&lt; endl; } private: int pincode = 87654321; }; class Computer: public Device {}; int main() { Computer Computer_instance; Computer_instance.turn_on(); cout &lt;&lt; "Serial number is: " &lt;&lt; Computer_instance.serial_number &lt;&lt; endl; // cout &lt;&lt; "Pin code is: " &lt;&lt; Computer_instance.pincode &lt;&lt; endl; // will cause compile time error return 0; }</span></span></span></span></code> </pre> <br><h3 id="tipy-nasledovaniya">  Jenis-Jenis Warisan </h3><br><p>  Ada beberapa jenis warisan di C ++: </p><br><ul><li>  publik - publik ( <code>public</code> ) dan data yang dilindungi ( <code>protected</code> ) diwariskan tanpa mengubah tingkat aksesnya; </li><li>  dilindungi ( <code>protected</code> ) - semua data yang diwariskan menjadi terlindungi; </li><li>  pribadi - semua data yang diwariskan menjadi pribadi. </li></ul><br><p>  Untuk kelas dasar <code>Device</code> , tingkat akses data tidak berubah, tetapi karena kelas yang diturunkan <code>Computer</code> mewarisi data sebagai pribadi, data menjadi pribadi untuk kelas <code>Computer</code> . </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;iostream&gt; using namespace std; class Device { public: int serial_number = 12345678; void turn_on() { cout &lt;&lt; "Device is on" &lt;&lt; endl; } }; class Computer: private Device { public: void say_hello() { turn_on(); cout &lt;&lt; "Welcome to Windows 95!" &lt;&lt; endl; } }; int main() { Device Device_instance; Computer Computer_instance; cout &lt;&lt; "\t Device" &lt;&lt; endl; cout &lt;&lt; "Serial number is: "&lt;&lt; Device_instance.serial_number &lt;&lt; endl; Device_instance.turn_on(); // cout &lt;&lt; "Serial number is: " &lt;&lt; Computer_instance.serial_number &lt;&lt; endl; // Computer_instance.turn_on(); // will cause compile time error cout &lt;&lt; "\t Computer" &lt;&lt; endl; Computer_instance.say_hello(); return 0; }</span></span></span></span></code> </pre> <br><p>  Kelas <code>Computer</code> sekarang menggunakan metode <code>turn_on()</code> seperti metode pribadi: <code>turn_on()</code> dapat dipanggil dari dalam kelas, tetapi mencoba memanggilnya langsung dari <code>main</code> akan menghasilkan kesalahan pada waktu kompilasi.  Untuk <code>Device</code> kelas dasar, metode <code>turn_on()</code> tetap bersifat publik, dan dapat dipanggil dari <code>main</code> . </p><br><h3 id="konstruktory-i-destruktory">  Konstruktor dan destruktor </h3><br><p>  Dalam C ++, konstruktor dan destruktor tidak diwarisi.  Namun, mereka dipanggil ketika kelas anak menginisialisasi objeknya.  Konstruktor disebut secara hierarkis satu demi satu, dimulai dengan kelas dasar dan diakhiri dengan kelas turunan terakhir.  Destructors disebut dalam urutan terbalik. </p><br><p>  <em>Catatan Penting:</em> Artikel ini tidak mencakup destruktor virtual.  Materi tambahan tentang topik ini dapat ditemukan, misalnya, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dalam artikel ini tentang Habr</a> . </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;iostream&gt; using namespace std; class Device { public: // constructor Device() { cout &lt;&lt; "Device constructor called" &lt;&lt; endl; } // destructor ~Device() { cout &lt;&lt; "Device destructor called" &lt;&lt; endl; } }; class Computer: public Device { public: Computer() { cout &lt;&lt; "Computer constructor called" &lt;&lt; endl; } ~Computer() { cout &lt;&lt; "Computer destructor called" &lt;&lt; endl; } }; class Laptop: public Computer { public: Laptop() { cout &lt;&lt; "Laptop constructor called" &lt;&lt; endl; } ~Laptop() { cout &lt;&lt; "Laptop destructor called" &lt;&lt; endl; } }; int main() { cout &lt;&lt; "\tConstructors" &lt;&lt; endl; Laptop Laptop_instance; cout &lt;&lt; "\tDestructors" &lt;&lt; endl; return 0; }</span></span></span></span></code> </pre> <br><p>  Konstruktor: <code>Device</code> -&gt; <code>Computer</code> -&gt; <code>Laptop</code> . <br>  Destructors: <code>Laptop</code> -&gt; <code>Computer</code> -&gt; <code>Device</code> . </p><br><h3 id="mnozhestvennoe-nasledovanie">  Warisan berganda </h3><br><p>  Warisan berganda terjadi ketika subkelas memiliki dua atau lebih superclasses.  Dalam contoh ini, kelas <code>Laptop</code> mewarisi <code>Monitor</code> dan <code>Computer</code> bersamaan. </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;iostream&gt; using namespace std; class Computer { public: void turn_on() { cout &lt;&lt; "Welcome to Windows 95" &lt;&lt; endl; } }; class Monitor { public: void show_image() { cout &lt;&lt; "Imagine image here" &lt;&lt; endl; } }; class Laptop: public Computer, public Monitor {}; int main() { Laptop Laptop_instance; Laptop_instance.turn_on(); Laptop_instance.show_image(); return 0; }</span></span></span></span></code> </pre> <br><h3 id="problematika-mnozhestvennogo-nasledovaniya">  Berbagai Masalah Warisan </h3><br><p>  Warisan berganda membutuhkan desain yang cermat, karena dapat mengakibatkan konsekuensi yang tidak terduga.  Sebagian besar konsekuensi ini disebabkan oleh ambiguitas dalam warisan.  Dalam contoh ini, <code>Laptop</code> mewarisi metode <code>turn_on()</code> dari kedua orang tua dan tidak jelas metode mana yang harus dipanggil. </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;iostream&gt; using namespace std; class Computer { private: void turn_on() { cout &lt;&lt; "Computer is on." &lt;&lt; endl; } }; class Monitor { public: void turn_on() { cout &lt;&lt; "Monitor is on." &lt;&lt; endl; } }; class Laptop: public Computer, public Monitor {}; int main() { Laptop Laptop_instance; // Laptop_instance.turn_on(); // will cause compile time error return 0; }</span></span></span></span></code> </pre> <br><p>  Terlepas dari kenyataan bahwa data pribadi tidak diwariskan, tidak mungkin untuk menyelesaikan warisan yang ambigu dengan mengubah tingkat akses ke data menjadi pribadi.  Ketika mengkompilasi, pertama pencarian metode atau variabel terjadi, dan setelah itu, memeriksa tingkat akses ke mereka. </p><br><h1 id="intermediate">  Menengah </h1><br><h3 id="problema-romba">  Masalah belah ketupat </h3><br><img align="left" src="https://habrastorage.org/webt/qn/ae/po/qnaepojwdop6urntrubztgdd7x4.png"><br><p>  Masalah berlian adalah masalah klasik dalam bahasa yang mendukung banyak pewarisan.  Masalah ini terjadi ketika kelas <code>B</code> dan <code>C</code> mewarisi <code>A</code> , dan kelas <code>D</code> mewarisi <code>B</code> dan <code>C</code> </p><br><p>  Misalnya, kelas <code>A</code> , <code>B</code> dan <code>C</code> menentukan metode <code>print_letter()</code> .  Jika <code>print_letter()</code> akan dipanggil oleh kelas <code>D</code> , tidak jelas metode mana yang harus disebut - metode kelas <code>A</code> , <code>B</code> atau <code>C</code>  Bahasa yang berbeda memiliki pendekatan yang berbeda untuk menyelesaikan masalah berbentuk berlian.  Dalam C ++, solusi untuk masalah diserahkan kepada kebijaksanaan programmer. <br><br clear="all">  Masalah berbentuk berlian terutama adalah masalah desain, dan harus disediakan pada tahap desain.  Pada tahap pengembangan, dapat diselesaikan sebagai berikut: </p><br><ul><li>  sebut metode superclass tertentu; </li><li>  merujuk ke objek subclass sebagai objek dari superclass tertentu; </li><li>  menimpa metode bermasalah di kelas anak terakhir (dalam kode, <code>turn_on()</code> di subkelas <code>Laptop</code> ). </li></ul><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;iostream&gt; using namespace std; class Device { public: void turn_on() { cout &lt;&lt; "Device is on." &lt;&lt; endl; } }; class Computer: public Device {}; class Monitor: public Device {}; class Laptop: public Computer, public Monitor { /* public: void turn_on() { cout &lt;&lt; "Laptop is on." &lt;&lt; endl; } // uncommenting this function will resolve diamond problem */ }; int main() { Laptop Laptop_instance; // Laptop_instance.turn_on(); // will produce compile time error // if Laptop.turn_on function is commented out // calling method of specific superclass Laptop_instance.Monitor::turn_on(); // treating Laptop instance as Monitor instance via static cast static_cast&lt;Monitor&amp;&gt;( Laptop_instance ).turn_on(); return 0; }</span></span></span></span></code> </pre> <br><p>  Jika metode <code>turn_on()</code> belum diganti di Laptop, memanggil <code>Laptop_instance.turn_on()</code> akan menghasilkan kesalahan kompilasi.  Objek <code>Laptop</code> dapat mengakses dua <code>turn_on()</code> metode <code>turn_on()</code> secara bersamaan: <code>Device:Computer:Laptop.turn_on()</code> dan <code>Device:Monitor:Laptop.turn_on()</code> . </p><br><h3 id="problema-romba-konstruktory-i-destruktory">  Masalah Intan: Konstruktor dan Destruktor </h3><br><p>  Karena dalam C ++, ketika objek kelas anak diinisialisasi, konstruktor dari semua kelas induk dipanggil, masalah lain muncul: konstruktor <code>Device</code> kelas dasar akan dipanggil dua kali. </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;iostream&gt; using namespace std; class Device { public: Device() { cout &lt;&lt; "Device constructor called" &lt;&lt; endl; } }; class Computer: public Device { public: Computer() { cout &lt;&lt; "Computer constructor called" &lt;&lt; endl; } }; class Monitor: public Device { public: Monitor() { cout &lt;&lt; "Monitor constructor called" &lt;&lt; endl; } }; class Laptop: public Computer, public Monitor {}; int main() { Laptop Laptop_instance; return 0; }</span></span></span></span></code> </pre> <br><h3 id="virtualnoe-nasledovanie">  Warisan virtual </h3><br><p>  Warisan virtual mencegah beberapa objek kelas dasar agar tidak muncul dalam hierarki pewarisan.  Jadi, konstruktor <code>Device</code> kelas dasar akan dipanggil hanya sekali, dan mengakses metode <code>turn_on()</code> tanpa <code>turn_on()</code> di kelas anak tidak akan menyebabkan kesalahan kompilasi. </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;iostream&gt; using namespace std; class Device { public: Device() { cout &lt;&lt; "Device constructor called" &lt;&lt; endl; } void turn_on() { cout &lt;&lt; "Device is on." &lt;&lt; endl; } }; class Computer: virtual public Device { public: Computer() { cout &lt;&lt; "Computer constructor called" &lt;&lt; endl; } }; class Monitor: virtual public Device { public: Monitor() { cout &lt;&lt; "Monitor constructor called" &lt;&lt; endl; } }; class Laptop: public Computer, public Monitor {}; int main() { Laptop Laptop_instance; Laptop_instance.turn_on(); return 0; }</span></span></span></span></code> </pre> <br><p>  <em>Catatan</em> : warisan virtual di kelas <code>Computer</code> dan <code>Monitor</code> tidak akan memungkinkan warisan rhomboid jika <code>Laptop</code> kelas anak tidak mewarisi kelas <code>Device</code> virtual ( <code>class Laptop: public Computer, public Monitor, public Device {};</code> ). </p><br><h3 id="abstraktnyy-klass">  Kelas abstrak </h3><br><p>  Dalam C ++, kelas di mana setidaknya ada satu metode virtual murni dianggap abstrak.  Jika metode virtual tidak diganti di kelas anak, kode tidak akan dikompilasi.  Juga, di C ++ tidak mungkin untuk membuat objek dari kelas abstrak - upaya juga akan menyebabkan kesalahan selama kompilasi. </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;iostream&gt; using namespace std; class Device { public: void turn_on() { cout &lt;&lt; "Device is on." &lt;&lt; endl; } virtual void say_hello() = 0; }; class Laptop: public Device { public: void say_hello() { cout &lt;&lt; "Hello world!" &lt;&lt; endl; } }; int main() { Laptop Laptop_instance; Laptop_instance.turn_on(); Laptop_instance.say_hello(); // Device Device_instance; // will cause compile time error return 0; }</span></span></span></span></code> </pre> <br><h3 id="interfeys">  Antarmuka </h3><br><p>  C ++, tidak seperti beberapa bahasa OOP, tidak menyediakan kata kunci terpisah untuk menunjukkan antarmuka.  Namun, implementasi antarmuka dimungkinkan dengan membuat kelas abstrak murni - kelas di mana hanya ada deklarasi metode.  Kelas semacam itu juga sering disebut sebagai Kelas Dasar Abstrak (ABC). </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;iostream&gt; using namespace std; class Device { public: virtual void turn_on() = 0; }; class Laptop: public Device { public: void turn_on() { cout &lt;&lt; "Device is on." &lt;&lt; endl; } }; int main() { Laptop Laptop_instance; Laptop_instance.turn_on(); // Device Device_instance; // will cause compile time error return 0; }</span></span></span></span></code> </pre> <br><h1 id="advanced">  Mahir </h1><br><p>  Meskipun warisan adalah prinsip dasar OOP, itu harus digunakan dengan hati-hati.  Penting untuk berpikir bahwa kode apa pun yang akan digunakan kemungkinan akan diubah dan dapat digunakan dengan cara yang tidak jelas bagi pengembang. </p><br><h3 id="nasledovanie-ot-realizovannogo-ili-chastichno-realizovannogo-klassa">  Warisan dari kelas yang diimplementasikan atau diimplementasikan sebagian </h3><br><p>  Jika warisan tidak datang dari antarmuka (kelas abstrak murni dalam konteks C ++), tetapi dari kelas di mana ada implementasi, perlu dipertimbangkan bahwa ahli waris terhubung ke kelas induk dengan koneksi terdekat yang memungkinkan.  Sebagian besar perubahan pada kelas induk dapat mempengaruhi ahli waris, yang dapat menyebabkan perilaku yang tidak terduga.  Perubahan dalam perilaku ahli waris tidak selalu jelas - kesalahan dapat terjadi dalam kode yang sudah diuji dan bekerja.  Situasi ini diperburuk oleh kehadiran hierarki kelas yang kompleks.  Perlu selalu diingat bahwa kode dapat diubah tidak hanya oleh orang yang menulisnya, dan jalur pewarisan yang jelas bagi penulis mungkin tidak diperhitungkan oleh rekan-rekannya. </p><br><p>  Sebaliknya, perlu dicatat bahwa warisan dari kelas yang diimplementasikan sebagian memiliki keuntungan yang tidak dapat disangkal.  Perpustakaan dan kerangka kerja sering berfungsi sebagai berikut: mereka menyediakan kelas abstrak kepada pengguna dengan beberapa metode virtual dan banyak diimplementasikan.  Dengan demikian, jumlah pekerjaan terbesar telah dilakukan - logika kompleks telah ditulis, dan pengguna hanya dapat menyesuaikan solusi yang sudah jadi agar sesuai dengan kebutuhannya. </p><br><h3 id="interfeys-1">  Antarmuka </h3><br><p>  Warisan dari antarmuka (kelas abstrak murni) menghadirkan warisan sebagai peluang untuk menyusun kode dan melindungi pengguna.  Karena antarmuka menggambarkan pekerjaan yang akan dilakukan oleh kelas implementasi, tetapi tidak menjelaskan caranya, pengguna antarmuka mana pun dilindungi dari perubahan di kelas yang mengimplementasikan antarmuka ini. </p><br><h3 id="interfeys-primer-ispolzovaniya">  Antarmuka: Contoh Penggunaan </h3><br><p>  Pertama-tama, perlu dicatat bahwa contoh tersebut terkait erat dengan konsep polimorfisme, tetapi akan dipertimbangkan dalam konteks pewarisan dari kelas abstrak murni. </p><br><p>  Aplikasi yang menjalankan logika bisnis abstrak harus dikonfigurasikan dari file konfigurasi terpisah.  Pada tahap awal pengembangan, format file konfigurasi ini tidak sepenuhnya terbentuk.  Melewati file parsing di belakang antarmuka memberikan beberapa keuntungan. </p><br><p>  Kurangnya kejelasan tentang format file konfigurasi tidak memperlambat proses pengembangan program utama.  Dua pengembang dapat bekerja secara paralel - satu di logika bisnis, dan yang lain di parser.  Karena mereka berinteraksi melalui antarmuka ini, masing-masing dapat bekerja secara independen.  Pendekatan ini membuatnya lebih mudah untuk menguji unit test dengan kode, karena tes yang diperlukan dapat ditulis menggunakan tiruan untuk antarmuka ini. </p><br><p>  Juga, ketika mengubah format file konfigurasi, logika bisnis aplikasi tidak terpengaruh.  Satu-satunya hal yang memerlukan transisi lengkap dari satu format ke format lainnya adalah menulis implementasi baru dari kelas abstrak yang sudah ada (kelas parser).  Lebih jauh, kembali ke format file asli membutuhkan kerja minimal - mengganti satu parser yang ada dengan yang lain. </p><br><h1 id="zaklyuchenie">  Kesimpulan </h1><br><p>  Warisan memberikan banyak manfaat, tetapi harus dirancang dengan cermat untuk menghindari masalah yang dihadirkannya kesempatan.  Dalam konteks pewarisan, C ++ menyediakan berbagai alat yang membuka banyak kemungkinan bagi programmer. </p><br><p>  Dan SOLID bagus. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id445948/">https://habr.com/ru/post/id445948/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id445928/index.html">Bagaimana Kami Meningkatkan Tensorflow Melayani Produktivitas hingga 70%</a></li>
<li><a href="../id445932/index.html">Keamanan Aplikasi Klien: Kiat Praktis untuk Pengembang Front-End</a></li>
<li><a href="../id445936/index.html">Pengembangan elektronik. Tentang mikrokontroler di jari</a></li>
<li><a href="../id445940/index.html">AMA dengan Habr, v 7.0. Lemon, Donat, dan Berita</a></li>
<li><a href="../id445946/index.html">MWC: petunjuk penggunaan</a></li>
<li><a href="../id445952/index.html">Satu triliun lajang</a></li>
<li><a href="../id445954/index.html">Akselerator AI dari HSE, MTS dan Rostelecom</a></li>
<li><a href="../id445958/index.html">SPDS GraphiCS - sistem fasad dan atap</a></li>
<li><a href="../id445962/index.html">Magang di TI: pandangan manajer</a></li>
<li><a href="../id445964/index.html">MEPhI akan menyelenggarakan Olimpiade Keamanan Informasi Mahasiswa: cara berpartisipasi dan apa yang diberikannya</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>