<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üìö ‚ö™Ô∏è üö© Dongle-Authentifizierung f√ºr Linux-Ger√§tehardware auf Systemen der h√∂chsten Ebene üåÆ üèæ üõçÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Industrial IoT ist die √úberwachung, Planung und Automatisierung von Engineering-Systemen f√ºr Industrieanlagen, Geb√§ude und Gesch√§ftsgeb√§ude. Sensoren ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Dongle-Authentifizierung f√ºr Linux-Ger√§tehardware auf Systemen der h√∂chsten Ebene</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/oleg-bunin/blog/476304/">  Industrial IoT ist die √úberwachung, Planung und Automatisierung von Engineering-Systemen f√ºr Industrieanlagen, Geb√§ude und Gesch√§ftsgeb√§ude.  Sensoren verschiedener Parameter, Z√§hler und Regler erfassen Daten von diesen Objekten, z. B. Temperatur und Luftfeuchtigkeit im Serverraum, Wasserz√§hler in Mehrfamilienh√§usern, Kohlendioxidgehalt in den R√§umen.  Controller verarbeiten diese Informationen und senden alles an die "Cloud". <br><br>  Wiren Board stellt Linux-Controller f√ºr industrielles IoT her.  Ger√§te sammeln Daten aus √ñlquellen und Bankfilialen, √ºberwachen das Mikroklima in Servern und Superm√§rkten.  Controller integrieren sich in √ºbergeordnete Systeme von Unternehmenspartnern.  Systeme authentifizieren Ger√§te - sie verstehen, dass sie mit ihrem Sensor und nicht mit dem eines anderen sprechen, und autorisieren dann.  In dieser Phase tritt ein Problem auf: Es gibt Tausende von Controllern, Hunderte von Kunden, aber kein einziges Integrationssystem.  Einfache traditionelle Methoden wie Anmelde- / Kennwortpaare sind anf√§llig f√ºr Angriffe und unpraktisch in der Bereitstellung. <br><br><img src="https://habrastorage.org/webt/sk/xm/mt/skxmmtcf6uhcrlm0xkcqilqwjuo.jpeg"><br><br>  Daher entwickelte das Unternehmen die Authentifizierung in Top-Level-Systemen mithilfe von Hardwareschl√ºsseln - basierend auf einer standardm√§√üigen asymmetrischen Kryptografie unter Verwendung eines hardwaregesch√ºtzten Elements zum Speichern von Schl√ºsseln.  Jetzt wird kein einheitliches Integrationssystem ben√∂tigt - Authentifizierung und Autorisierung sind gesch√ºtzt und funktionieren sofort.  <b>Evgeny Boger</b> erkl√§rt Ihnen, wie das geht: Wie sie den ‚ÄûKrypto-Chip‚Äú ausgew√§hlt haben, wie sie ihn mit Hardware und Linux verschraubt haben, wie gemeinsame Bibliotheken und Software dazu gebracht wurden, sich damit anzufreunden.  Besonderes Augenmerk auf die Bereitstellung: die Einf√ºhrung der Ger√§teinitialisierung in der Produktion, die Einf√ºhrung der Unterst√ºtzung f√ºr verschiedene Top-Level-Software, auch in fremden und geschlossenen Systemen. <br><a name="habracut"></a><br>  <b>√úber den Sprecher:</b> <b>Eugene Boger</b> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link">evgeny_boger</a> ) - CTO und Mitbegr√ºnder von Wiren Board.  Engagiert in eingebetteten Systemen und insbesondere in eingebettetem Linux. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/tbXmNAs5IrM" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><h2>  Die Probleme </h2><br>  Zun√§chst einmal, was wir tun und woher dieses Problem kommt.  Wir von Wiren Board entwerfen und fertigen Ger√§te in Russland.  Fr√ºher hie√ü es M2M, heute jedoch - industrielles IoT.  Dies ist die Automatisierung von geb√§udetechnischen Systemen, √úberwachung und Planung.  Kurz gesagt sieht die gesamte Arbeit so aus: Sensoren verschiedener Parameter, Aktoren, Z√§hler und Steuerungen (Edge-Computing oder IoT-Gateway) erfassen unterschiedliche Daten von Objekten, verarbeiten sie, f√ºhren lokale Logik aus und sammeln sie dann in einem gro√üen Versand-, √úberwachungs- oder Steuerungssystem . <br><br><img src="https://habrastorage.org/webt/ns/fh/xa/nsfhxa9qezcmcuuc9y8kijenyhw.jpeg"><br><br>  Wir haben im Gegensatz zu einigen Wettbewerbern kein ganzes √ñkosystem.  Wir stellen Ger√§te her, die sich in mehrere Spitzensysteme unserer Partner integrieren lassen.  Es gibt viele Partnerunternehmen, die sich die Verantwortung teilen.  Ohne gute technische Mittel wird die Integration nicht funktionieren - sie kann einfach nicht ausgehandelt werden. <br><br>  Es gibt zwei einfache L√∂sungen, um diese Probleme zu l√∂sen.  Der erste besteht <b>darin, dem Kunden den Benutzernamen / das Passwort zu geben</b> , wie es jeder tut, und der zweite besteht darin <b>, das "Geheimnis" am Arbeitsplatz</b> zu <b>erzeugen und zu vern√§hen</b> .  Beide Optionen passten nicht zu uns - ich werde Ihnen sagen, warum. <br><br><h2>  Einfache l√∂sungen </h2><br>  <b>Die erste L√∂sung besteht darin, dem Client einen Benutzernamen und ein Kennwort zuzuweisen</b> .  Wir alle tun dies bis vor kurzem. <br><br>  Um ein Ger√§t zu authentifizieren, das Daten an ein bestimmtes System sendet, k√∂nnen Sie einen geheimen Schl√ºssel erstellen - mit bedingtem Login / Passwort ("geheim").  Dies ist auf Controllern und auf einem Top-Level-System √ºblich, das Daten von mehreren Controllern sammelt. <br><br>  Ein paar Benutzernamen / Passw√∂rter (ein allgemeines "Geheimnis") m√ºssen dem Kunden irgendwie mitgeteilt werden - der Firma oder der Person.  Jemand muss ein geheimes Paar generieren, es per E-Mail senden und den Kunden anhand seiner Kontonummer authentifizieren.  Dies ist das Standardverfahren - niedrige Technologie. <br><br>  <b>Problem</b> .  Es gibt viele solcher Systeme.  Unser Kunde und er k√∂nnen Daten an das System unseres Partners senden.  Dies ist eine komplexe Interaktion zwischen allen Beteiligten. <br><br>  Neben dem Problem vieler Systeme gibt es noch andere. <br><br><ul><li>  <b>Schlechte Lieferung und Lieferung an den Kunden</b> . <br></li><li>  <b>Logins und Passw√∂rter werden auf dem Server gespeichert</b> .  Wenn wir auch Hashes speichern, sch√ºtzt uns dies ein wenig vor Lecks.  Trotzdem entsteht ein unangenehmes Gef√ºhl, wenn geheime Schl√ºssel f√ºr alle Client-Controller auf dem Server gespeichert werden.  Einige von ihnen k√∂nnen sich mit kritischen Aufgaben befassen: Au√üenbeleuchtung, √úberwachung von √ñlplattformen. <br></li><li>  <b>Synchronisation zwischen Diensten</b> . <br></li><li>  <b>Verlustwiederherstellung</b> .  Es ist nicht klar, was im Falle eines Verlusts zu tun ist, wenn der Client den Speicher des Controllers gel√∂scht hat - in welchen Speicher soll ich schreiben?  Sie m√ºssen es noch einmal wiederholen. <br></li><li>  <b>Schutz gegen das Kopieren von Details</b> .  Es gibt kostenpflichtige √úberwachungssysteme, die dem Kunden einen Service bieten und Abonnementgeb√ºhren erheben.  Ich m√∂chte nicht, dass der Endkunde das System durch uns umgehen kann - zahlen Sie nur einmal, sondern nutzen Sie zwei. <br></li></ul><br>  <b>Die zweite L√∂sung besteht darin, ein ‚ÄûGeheimnis‚Äú in der Produktion zu erzeugen und zu n√§hen</b> .  Dies ist eine Verbesserung gegen√ºber der vorherigen L√∂sung. <br><br>  Das Schema lautet: Wir als Hersteller von Controllern generieren Benutzernamen und Passw√∂rter f√ºr alle, n√§hen sie in unser System und geben sie in Ger√§te ein.  Logins und Passw√∂rter der Ger√§te k√∂nnen weder gelesen noch ge√§ndert werden.  Dies ist besser als die vorherige Option, da keine Interaktion zwischen Personen erforderlich ist. <br><br>  <b>Die Probleme</b> .  Bis auf das erste bleiben alle Probleme bestehen, aber das Hauptproblem ist die <b>Synchronisation zwischen Diensten und dem Intranet</b> .  Es gibt viele Dienste und es ist nicht klar, wie sie synchronisiert werden sollen. Aus diesem Grund konnten wir die zweite L√∂sung nicht implementieren.  Wir haben Kunden, die Ger√§te in geschlossenen Netzwerken einsetzen.  Wir haben einen neuen Controller herausgebracht, ihn an einen Kunden verkauft und sein System ist geschlossen.  Es ist eingerichtet, es funktioniert einmal und es ist schwierig, die "Geheimnisse" weiterzugeben.  Chargenweise melden?  In Organisationen ist alles kompliziert, obwohl technisch einfach. <br><br>  Beide L√∂sungen passten nicht zu uns.  Deshalb haben wir uns f√ºr einen anderen Weg entschieden.  Vorher beschlossen sie jedoch, gemeinsame Ziele und Vorgaben zu skizzieren. <br><br><h2>  Aufgaben und Ziele </h2><br>  Erste gemeinsame Aufgaben. <br><br>  <b>Authentifizierung</b>  Auf diese Weise k√∂nnen Sie verstehen, wer mit dem √ºbergeordneten System spricht und wer genau mit dem Versandsystem verbunden ist. <br><br><blockquote>  Bei der Authentifizierung werden keine Zugriffsrechte gew√§hrt oder eingeschr√§nkt, sondern es wird eine Art und Weise verstanden, wer mit uns spricht. </blockquote><br>  <b>Die Aufgabe, Daten zu senden</b> .  Unsere Controller sind Linux-Computer, die f√ºr eine spezielle Aufgabe entwickelt wurden.  Wir brauchen sie, um Daten an Top-Level-Systeme zu senden und eine VPN-Verbindung herzustellen.  Gleichzeitig m√∂chten wir, dass der Versand ‚Äûout of the box‚Äú funktioniert - ohne die Einstellungen und die Interaktion unserer Kunden und Endbenutzer des Systems mit uns und mit Kunden. <br><br>  <b>Andere Aufgaben</b> .  Dies ist eine zuverl√§ssige Verbindung, Datenkanalverschl√ºsselung, aber ein separates Problem ist die <b>Autorisierung</b> .  Die Berechtigungsaufgabe ist mit externen Services verbunden und gliedert sich in drei Teile. <br><br><ul><li>  <b>Kostenloser Herstellerservice</b> .  Stellen Sie den Zugriff √ºber die Seriennummer des Ger√§ts bereit. <br></li><li>  <b>Wei√üe Listen mit Seriennummern</b> f√ºr den Service unserer Partner - verkn√ºpfen Sie Eink√§ufe und Zugriffe auf das Kundenkonto. <br></li><li>  <b>Lizenzen</b>  Gestatten oder verweigern Sie den Zugriff basierend auf den im Zertifikat angegebenen Optionen. <br></li></ul><br>  Ziele wollen wir erreichen, wenn wir Probleme l√∂sen. <br><br>  <b>Ausstellung und Lieferung an den Kunden</b> .  Ohne die Beteiligung von Menschen - Informationen werden von Robotern in der Produktion vern√§ht. <br><br>  <b>Verlustwiederherstellung</b> .  Wir wollen, dass keine geheimen Details verloren gehen. <br><br>  <b>Lieferung von der Produktion bis zum Service</b> .  Wir wollen darauf verzichten, damit Sie den Diensten nichts liefern m√ºssen.  Beim Start neuer Ger√§te m√∂chten wir nicht die Datenbanken aller Dienste aktualisieren, die diese Ger√§te authentifizieren sollen. <br><br>  <b>Speicherung auf dem Server</b> .  Es ist ratsam, dort √ºberhaupt nichts aufzubewahren. <br><br>  <b>Synchronisation zwischen Diensten und Intranet</b> .  Es ist auch ratsam, nichts zu synchronisieren, da wir nichts speichern. <br><br>  <b>Schutz gegen das Kopieren von Details</b> .  Wir wollen etwas Geheimnisvolles, wof√ºr das Geld genommen wird, es war unm√∂glich zu kopieren und kostenlos zu erhalten. <br><br><h2>  Die digitale Signatur eilt zur Rettung </h2><br><blockquote>  Die elektronische digitale Signatur (EDS) ist eine Technologie, um die sich bei uns alles dreht. </blockquote><br>  Es ist wie eine gew√∂hnliche Signatur, nur digital.  EDS ist leicht zu verifizieren, aber schwer zu f√§lschen.  Die bekannten Wahrheiten der Kryptographie, die Jahrzehnte alt sind. <br><br>  Eine elektronische Signatur kann von einer Nachricht gez√§hlt werden, wenn Sie den geheimen privaten Schl√ºssel (Private Key) kennen.  Wenn Sie den √∂ffentlichen Schl√ºssel (public key) kennen, k√∂nnen Sie leicht √ºberpr√ºfen, ob die elektronische Signatur f√ºr die Nachricht korrekt ist.  Der Name ist klar - die √ñffentlichkeit informiert gew√∂hnlich alle, und das Geheimnis ist nur f√ºr den, der unterschreibt. <br><br><blockquote>  Alle Unterschriften und Schl√ºssel sind nur Zahlen. </blockquote><br>  In unserem Fall sind dies 32 Byte Daten, was mit mathematischer ‚ÄûMagie‚Äú funktioniert.  Math stellt sicher, dass die Signatur leicht zu √ºberpr√ºfen, aber schwer zu f√§lschen ist. <br><br>  Wir verwenden die Signatur ECDSA-256 + SHA-256: <br><br><ul><li> <code>e = HASH(m)</code> - die kryptografische Hash-Funktion konvertiert die Nachricht m irreversibel in die Zahl e; <br></li><li>  <code>private key (dA)</code> - Zufallszahl; <br></li><li>  <code>public key (QA)</code> - generiert aus einem privaten Schl√ºssel, aber nicht umgekehrt; <br></li><li>  <code>signature (r,s) = sign(private key, e)</code> - Signatur; <br></li><li>  <code>verify(public key, signature, e)</code> - √úberpr√ºfung der Signatur. <br></li></ul><br><h3>  EDS-Authentifizierung.  Erster Versuch </h3><br>  Was kann f√ºr unsere Aufgabe mit diesem kniffligen Mechanismus getan werden, der in die eine Richtung einfach und in die andere schwierig funktioniert? <br><br>  <b>Ausstellung und Lieferung an den Kunden</b> .  Wir generieren einen zuf√§lligen privaten Schl√ºssel f√ºr jedes Ger√§t in der Produktion.  Wir sagen es niemandem, weil wir ihn nicht einmal kennen und wir schreiben an das Ger√§t. <br><br>  <b>Lieferung von der Produktion bis zum Service</b> .  Als N√§chstes verwenden wir nur den √∂ffentlichen Schl√ºssel dieses Ger√§ts f√ºr die Authentifizierung bei Diensten.  Bei Diensten speichern wir nur eine Liste √∂ffentlicher Schl√ºssel anstelle von Passw√∂rtern. <br><br>  Standardgesundheits√ºberpr√ºfungsalgorithmus: <br><br><ul><li>  der Dienst sendet eine zuf√§llige Nachricht <code>m</code> an die Steuerung; <br></li><li>  Controller: <code>sign(private key, m)</code> ; <br></li><li>  der Controller sendet eine Signatur an den Dienst; <br></li><li>  Dienst: <code>verify(public key, signature, m)</code> . <br></li></ul><br>  Das einzige, was wir auf diese Weise entschieden haben, ist, dass wir <b>keine gemeinsamen "Geheimnisse" mehr</b> in offener oder zwischengespeicherter Form <b>in unseren Diensten speichern</b> .  Das wollen wir nicht. <br><br><h3>  EDS-Authentifizierung.  Zweiter Versuch </h3><br>  Wir wollen nichts bei Diensten speichern.  Um dies zu erreichen, k√∂nnen wir unsere Ger√§te zwingen, ihre √∂ffentlichen Schl√ºssel an den Dienst zu senden. <br><br>  In der letzten Phase haben wir zwei Probleme gel√∂st.  Die erste - wir haben <b>√ºberpr√ºft, ob sie den Schl√ºssel f√ºr den Service gegeben haben</b> .  Wir haben einen √∂ffentlichen Schl√ºssel, das hei√üt, wir haben auch einen privaten Schl√ºssel erstellt.  Das zweite - wir haben daf√ºr gesorgt, dass das <b>Ger√§t einen privaten Schl√ºssel besitzt</b> , der sich irgendwo auf dem USB-Stick befindet.  Wenn das Ger√§t etwas signieren konnte, verf√ºgt es √ºber einen privaten Schl√ºssel. <br><br>  Das Ger√§t sendet nun auch den √∂ffentlichen Schl√ºssel an den Dienst.  Wie kann man √ºberpr√ºfen, ob ihn niemand abgefangen hat, ob er nicht gef√§lscht hat und ob alles funktioniert? <br><br>  <b>√úberpr√ºfen des √∂ffentlichen Schl√ºssels</b>  Wir erstellen uns einen weiteren √∂ffentlichen Schl√ºssel.  Er wird unser Schl√ºssel als Hersteller sein.  Dies ist der Stammschl√ºssel "privater Stammschl√ºssel + √∂ffentlicher Schl√ºssel".  Mit diesem geheimen Stammschl√ºssel in der Produktion signieren wir den √∂ffentlichen Schl√ºssel des Ger√§ts und speichern diese Signatur auf dem Ger√§t.  Das Ger√§t muss seinen √∂ffentlichen Schl√ºssel und die Signatur seines √∂ffentlichen Schl√ºssels an den Dienst senden.  Jetzt kann der Dienst den √∂ffentlichen Schl√ºssel des Ger√§ts √ºberpr√ºfen.  Wenn es mit dem privaten Root-Schl√ºssel signiert ist, haben wir diesen Schl√ºssel ausgegeben. <br><br><blockquote>  Nur der Hersteller - wir k√∂nnen eine Signatur auf dem Ger√§t erstellen und speichern, aber alles √ºberpr√ºfen. </blockquote>  Wir ver√∂ffentlichen den √∂ffentlichen Schl√ºssel auf der Website im Bereich "Kontakte".  Jeder kann es nehmen und den √∂ffentlichen Schl√ºssel des Ger√§ts √ºberpr√ºfen, das das Ger√§t an den Dienst gesendet hat.  Anschlie√üend k√∂nnen Sie √ºberpr√ºfen, ob das Ger√§t selbst √ºber einen eigenen privaten Schl√ºssel verf√ºgt. <br><br>  Der allgemeine Algorithmus sieht so aus. <br><br><ul><li>  <code>(once) random root private key</code> ; <br></li><li>  <code>factory: random device private key</code> ; <br></li><li>  <code>factory: sign(root private key, device public key) = signature_1</code> ; <br></li><li>  <code>device-&gt;service:  device public key + signature_1</code> . <br></li><li> <code>service: verify(root public key, signature_1, device public key)?</code> <br> </li></ul><br><h3>  Ergebnis des zweiten Versuchs </h3><br>  Wir haben das Problem mit der <b>Lieferung</b> an den Kunden gel√∂st - die Informationen werden am Produktionsstandort zusammengen√§ht und <b>es muss nichts wiederhergestellt werden</b> . <br><br>  Es ist wichtig, dass wir das Problem der <b>Weitergabe von "Geheimnissen" an Top-Level-Dienste</b> gel√∂st <b>haben</b> , da auf dem Dienst nur der √∂ffentliche Schl√ºssel des Herstellers gespeichert werden muss.  Der gesamte Schl√ºssel ist 33 Bytes.  Mit ihrer Hilfe und mathematischen Magie k√∂nnen Sie weiterhin eine Handshake-Verbindung herstellen und sicherstellen, dass das Ger√§t √ºber den entsprechenden privaten Schl√ºssel verf√ºgt. <br><br>  <b>Auf dem Server</b> speichern wir nur den Herstellerschl√ºssel (root public key). <br><br>  Wir haben keine <b>Synchronisation zwischen Diensten und dem Intranet</b> , √ºber das wir bereits gesprochen haben.  Auch haben wir keinen <b>Schutz gegen das Kopieren von Details</b> . <br><br>  Das einzige, was wir vergessen haben, ist die <b>Authentifizierung</b> .  Das Ger√§t hat einen privaten Schl√ºssel gesendet, und wir haben √ºberpr√ºft, ob wir ihn ausgef√ºhrt und ausgestellt haben, und haben √ºberpr√ºft, ob das Ger√§t Eigent√ºmer des Schl√ºssels ist.  Wir wissen jedoch nicht, um was f√ºr ein Ger√§t es sich handelt, und stellen Tausende davon her. <br><br>  Deshalb haben wir einen Trick namens "Zertifikat" angewendet. <br><br><h2>  Authentifizierung und Zertifikate </h2><br>  In diesem Schritt f√ºgen wir in der ganzen mathematischen Magie mit Signaturen und ihren √úberpr√ºfungen <b>zus√§tzliche Informationen hinzu - ein Zertifikat</b> .  Dazu signieren wir im Werk nicht nur den √∂ffentlichen Schl√ºssel (Device Public Key), sondern den Schl√ºssel mit zus√§tzlichen Informationen. <br><br>  Zus√§tzliche Informationen in unserem Fall. <br><br><ul><li>  Herstellungsdatum und Hersteller. <br></li><li>  Modell- und Hardwarekonfiguration. <br></li><li>  Die Seriennummer, mit der das Ger√§t authentifiziert werden kann. <br></li><li>  Optionen: Hardware und Software.  Die verschiedenen Konfigurationen unterscheiden sich m√∂glicherweise physisch nicht voneinander, das Zertifikat enth√§lt jedoch Informationen dar√ºber, wof√ºr der Kunde bezahlt hat. <br></li><li>  Kundenname und Kontonummer. <br></li></ul><br>  Wir werden alle diese Informationen zusammen mit dem √∂ffentlichen Schl√ºssel mit unserem Herstellerschl√ºssel - root public key - signieren.  Danach gehen die Informationen zu den Diensten und sie k√∂nnen sicherstellen, dass sie korrekt sind.  Da dies unsere und die Dienste unserer Partner sind, vertrauen sie uns. <br><br><h3>  Zielstatus </h3><br>  Informationen werden ebenfalls in der Fabrik gen√§ht, und eine <b>Lieferung</b> an die Dienste ist nicht erforderlich.  <b>Auf dem Server</b> speichern <b>wir</b> nur den Herstellerschl√ºssel. <br><br>  <b>Verlustwiederherstellung</b> .  Wir n√§hen alle Informationen aus den Zertifikaten in den Flash-Speicher des Ger√§ts.  Theoretisch kann es versehentlich oder absichtlich gel√∂scht werden, aber diese Informationen im Zertifikat enthalten kein Geheimnis.  Auch die Signatur selbst ist nicht geheim - es gibt einen √∂ffentlichen Schl√ºssel und die Signatur mit unserem Schl√ºssel.  Das einzige Geheimnis im Zertifikat ist das Verkaufsvolumen von Ger√§ten mit unterschiedlichen Optionen. <br><br>  Das Zertifikat kann im Werk gespeichert und an den Kunden gesendet werden, wenn er es verloren hat.  Clients l√∂schen selten speziell den Servicebereich des Speichers.  In der Regel geschieht dies w√§hrend der Wiederherstellung des Ger√§ts: Das Ger√§t ist vom Client angekommen, wird vollst√§ndig initialisiert, alles wird gel√∂scht, es wird erneut heruntergeladen und das Zertifikat wird aus der werkseitigen Datenbank kopiert. <br><br>  Wir bieten keine <b>Wiederherstellung nach Datenverlust</b> , keinen Kopierschutz und keine <b>Synchronisierung zwischen Diensten</b> . <br><br>  <b>Bei der Authentifizierung</b> erhalten und √ºberpr√ºfen wir das Zertifikat.  Wir verstehen, um was f√ºr ein Ger√§t es sich handelt - wir kennen Hersteller, Modell und Seriennummer, was er kann und was nicht. <br><br><h3>  Einloggen </h3><br>  Mit dem Zertifikat k√∂nnen Sie Informationen zur Autorisierung speichern. <br><br>  <b>Kostenloser Herstellerservice</b> .  Wenn Sie die Seriennummer des Ger√§ts kennen, k√∂nnen Sie jedem Zugriff gew√§hren.  In unseren Dienstleistungen geben wir Zugang zu allen unseren Stammkunden. <br><br>  <b>Wei√üe Listen mit Seriennummern</b> .  F√ºr den Service unserer Partner k√∂nnen Sie eine Tabelle mit einer wei√üen Liste von Seriennummern erstellen: "Kunde Vasily hat bei uns zwei Controller mit solchen Seriennummern gekauft, die mit seinem Konto verkn√ºpft sind." <br><br>  <b>Lizenzen</b>  Sie k√∂nnen etwas im Voraus verkaufen und dann den Zugriff <b>basierend auf den</b> im Zertifikat angegebenen <b>Optionen</b> zulassen oder verweigern - einem Controller mit einer Lizenz f√ºr System X. <br><br>  Es gibt keine gemeinsame Basis zwischen Dienstleistern, Herstellern oder Systemherstellern.  Alles funktioniert ausschlie√ülich mit Informationen des Controllers, die von uns als Hersteller bei der Authentifizierung im System signiert werden. <br><br><h2>  Zwischenzertifikat </h2><br>  Ein weiteres technisches Problem, das wir unterwegs gel√∂st haben.  In dem Schema, √ºber das ich gerade gesprochen habe, gibt es ein Stammzertifikat des Herstellers - root private key.  Es wird physisch jedes Mal ben√∂tigt, wenn Sie ein Ger√§t erstellen.  Wenn es jedoch viele Ger√§te gibt, muss dieser Schl√ºssel f√ºr einen begrenzten Personenkreis st√§ndig zug√§nglich sein.  Das ist schlecht, denn wenn Sie es verlieren, m√ºssen Sie die √∂ffentlichen Schl√ºssel aller Dienste aktualisieren, und es sollte nicht zu Angreifern kommen.  Dies sind gro√üe organisatorische Probleme.  Aber es gibt eine L√∂sung. <br><br><blockquote>  Wir f√ºhren Zwischenschl√ºssel f√ºr eine Reihe von Ger√§ten ein, deren Verlust nicht so unheimlich ist. </blockquote><br>  Wir haben das gleiche gemacht, nur die Kette ist l√§nger. <br><br><img src="https://habrastorage.org/webt/x-/mb/s3/x-mbs3xfmihxr-qjdmpm7f5buey.jpeg"><br><br>  Mit einem Herstellerzertifikat signieren wir den Zwischenschl√ºssel.  Physikalisch handelt es sich um ein "Flash-Laufwerk", das dem Vorarbeiter im Werk f√ºr einen Tag √ºbergeben wird.  Hardware begrenzt die Anzahl der Ger√§te, die ein Schl√ºssel signieren kann.  In der Mitte des Schemas haben wir ein Zwischenzertifikat hinzugef√ºgt, ansonsten hat sich nichts ge√§ndert. <br><br><h2>  Sicherer Schl√ºsselspeicher </h2><br>  In all dem haben wir nicht genug <b>Schutz f√ºr den privaten Schl√ºssel des Ger√§ts</b> - dies ist immer noch eine Datei, die sich auf einem USB-Flash-Laufwerk befindet.  Ein Angreifer kann es kopieren, verliert es jedoch h√∂chstwahrscheinlich oder √∂ffnet versehentlich den Zugriff. <br><br>  Im Idealfall w√§re es sch√∂n, den privaten Schl√ºssel des Ger√§ts vor dem Kopieren zu sch√ºtzen - legen Sie ihn in eine Blackbox. <br><br>  Die Blackbox f√ºhrt 4 Operationen aus: <br><br><ul><li>  in sich selbst erzeugt ein Schl√ºssel auf Anfrage, gibt aber nicht; <br></li><li>  gibt den √∂ffentlichen Schl√ºssel; <br></li><li>  Unterzeichnet eine Nachricht <br></li><li>  √ºberpr√ºft die Signatur. <br></li></ul><br><img src="https://habrastorage.org/webt/by/ck/zf/byckzfred-odhrigx-ayq2gkytk.jpeg"><br>  <i>Zum √úberpr√ºfen der Signatur ben√∂tigen Sie nur einen √∂ffentlichen Schl√ºssel, sodass drei Vorg√§nge ausreichen.</i> <br><br>  Nach meinem Verst√§ndnis sollte dies eine Hardwarel√∂sung sein, die vorzugsweise vom Prozessor getrennt ist.  Es gibt verschiedene Optionen, von denen die beste ein <b>spezieller Kryptoprozessor im SoC</b> oder ein separater Chip ist. <br><br>  Die erste Black-Box-Option, die wir gepr√ºft haben, ist das <b>CAAM-Modul</b> in den von uns verwendeten NXP i.mx 6, 7, 8-Prozessoren.  Das Problem ist, dass es programmgesteuert im Boot-ROM des Prozessors implementiert ist. <br><br>  Es kann Fehler enthalten, die durch andere Prozessorfunktionen gefunden und sogar ausgenutzt werden k√∂nnen.  Vor einigen Jahren wurde in diesem Modul eine L√ºcke gefunden, die es erm√∂glichte, die Signatur√ºberpr√ºfung beim Herunterladen von Firmware zu umgehen.  Dies ist nicht die Funktionalit√§t, die wir ben√∂tigen, aber das Sediment bleibt erhalten.  Ein weiteres Problem ist, dass es schwierig ist, Prozessoren mit diesem Modul nach Russland zu importieren. <br><br>  Deshalb haben wir einen separaten Chip genommen.  Ich gebe ehrlich zu, ich habe damit gerechnet, dass wir uns etwas einfallen lassen, wenn wir es nicht nach Russland bringen k√∂nnen. Der Chip ist klein und kostet 1 US-Dollar.  Aber alles ist gut <b>gelaufen</b> - sie haben den <b>Microchip ATECC-</b> Chip gefunden, der bereits alle Papiere hat. <br><br><h2>  Mikrochip ATECC608A </h2><br>  Dies ist ein separater kleiner Chip, der einen Cent kostet.  Der Chip wird √ºber I2C angeschlossen - zwei ‚ÄûBeine‚Äú des Prozessors, die Sie auch mit anderen Peripherieger√§ten teilen k√∂nnen.  Der Chip hat eine Standard-Pinbelegung.  Wir haben den Chip in den ersten Versionen des Ger√§ts verwendet und ihn einfach mit demselben Protokoll und derselben Pinbelegung auf einen anderen Chip gel√∂tet, da er Standard ist. <br><br>  Der Chip kann mit einem solchen Chip das tun, was wir brauchen: Signaturen lesen, Schl√ºssel speichern und vieles mehr. <br><br><img src="https://habrastorage.org/webt/_h/sb/jb/_hsbjbw9dyvjo2ta5emvp_wuqk4.jpeg"><br><br>  Eigenschaften <br><br><ul><li>  16 Schl√ºsselschlitze; <br></li><li>  kann ECSDSA-Signaturen, Hashes, MACs lesen und AES verschl√ºsseln, kann DH; <br></li><li>  hat einen Zufallszahlengenerator und kryptografische Z√§hler; <br></li><li>  Geh√§use: SOIC-8, DFN6; <br></li><li>  Protokolle: I2C, Single Wire; <br></li><li>  ~0.7$@1000pcs. <br></li></ul><br><h3>  Wie man mit einer Mikroschaltung arbeitet </h3><br>  Es gibt eine anst√§ndige <b>Dokumentation daf√ºr</b> , aber unter der NDA.  Wenn Sie sofort an gamma.spb.ru schreiben, wird es Ihnen in 2 Wochen mitgeteilt.  Wenn in einem anderen Unternehmen - nach 3 Monaten.  Wir haben zwei Unternehmen angeschrieben, und als wir alles erledigt hatten, antwortete uns ein anderer Microchip-H√§ndler. <br><br>  <b>Es gibt nur wenige Appnotes</b> und sie sind schlechter als der Durchschnitt.  Es gibt <b>Software</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">auf GitHub</a> - eine Bibliothek mit HAL.  Es ist lustig - die Dokumentation steht unter der NDA und die Software, die darauf geschrieben ist, ist auf GitHub.  Die Software unterst√ºtzt kein Linux, aber Raspberry Pi und Atmel MK - das ist etwas anders.  Die Entwickler glauben, dass es auf allen Ger√§ten nur einen I2C-Bus gibt, zum Beispiel hei√üen die Beine wie beim Raspberry Pi. <br><br>  Es gibt eine <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Integration</a> mit <b>OpenSSL</b> - es funktioniert nicht gut, aber es funktioniert.  <b>Es gibt keine Beispiele unter Linux</b> und keine Arbeit mit <b>Personalisierung</b> . <br><br><h3>  Chip-Anpassung </h3><br><blockquote>  Personalisierung ist das gr√∂√üte Problem mit dem Chip. </blockquote><br>  Das Problem ist, dass der Chip viele Dinge kann.  Es verf√ºgt √ºber 16 Steckpl√§tze, in denen 16 Schl√ºssel gespeichert sind: Benutzerdaten oder √∂ffentliche Schl√ºssel oder tempor√§rer Speicher f√ºr andere Steckpl√§tze - es gibt viele Optionen. <br><br>  Sie m√ºssen den Zugriff auf die Slots irgendwie einschr√§nken, und es gibt auch viele Konfigurationsoptionen: Einschr√§nken nach Kennwort, Authentifizierung in einem anderen Slot, Zugriffszeit auf die Fabriken. <br><br><img src="https://habrastorage.org/webt/-a/du/mm/-adumml8w8ijipo3nbep8jz5nry.jpeg"><br>  <i>In der Tabelle, die Art des Schl√ºssels, Lese- und Schreibzugriff, die Beziehung zwischen den Slots - SlotConfig, KeyConfig.</i> <br><br>  In der Bitmaske (16 Bit) jedes von uns verwendeten Schl√ºssels gibt es √ºberall unterschiedliche Zahlen. <br><br>  Das Traurigste ist, dass die Konfigurationszone einmalig ist, wodurch die Funktionen der Slots festgelegt werden.  Wir haben 50 Chips durcheinander gebracht, bevor wir alles richtig gemacht haben.  Der Chip funktioniert erst <b>nach dem Sperren der Konfiguration</b> .  Separat gibt es eine <b>Sperre f√ºr einzelne Steckpl√§tze</b> <br><br>  Es gibt keine Dokumentation in den Beispielen oder in der Software.  Es gibt Dokumentation f√ºr einzelne Bits, aber dort ist alles kompliziert.  In allen Beispielen von Microchip hei√üt es: "Laden Sie einen solchen Block herunter, und er funktioniert irgendwie f√ºr Sie, wie im Beispiel des Sendens von Daten an Amazon." <br><br>  Es hat viel Zeit in Anspruch genommen, aber dabei haben sie ein cooles Dienstprogramm gemacht. <br><br><h3>  Dienstprogramm Atecc-util </h3><br>  Dies ist ein Konsolendienstprogramm, mit dem Sie die meisten Funktionen des Chips ausf√ºhren und ein wenig einfacher arbeiten k√∂nnen.  Es ist <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">auf GitHub</a> unter einer MIT-Lizenz verf√ºgbar. <br><br>  Das Dienstprogramm verwendet CryptoAuthLib.  Sie wei√ü, wie man freundlicher mit der Konfigurationszone umgeht, sie wei√ü, wie man mit SHA, MAC, ECDSA, DH umgeht.  Die Benutzeroberfl√§che ist batch-freundlich, da wir das Dienstprogramm urspr√ºnglich f√ºr die Verwendung in Skripten erstellt haben.  Die Tatsache, dass eine Person dies verursachen kann, ist ein Nebeneffekt.  Das Dienstprogramm kann eine Liste mit Befehlen erstellen: "Personalisieren Sie zuerst diese Zone, und notieren Sie sich dann einen solchen Schl√ºssel." <br><br>  Ein Beispiel f√ºr den Aufruf eines Dienstprogramms kann von Menschen gelesen werden. <br><br><pre> <code class="plaintext hljs">atecc - b 10 - c 'serial' - c 'read-config /tmp/config.dump'</code> </pre> <br>  Das Dienstprogramm wurde unter Linux und unter AMD64 erstellt - es ist im Debian-Paket enthalten. <br><br><img src="https://habrastorage.org/webt/lc/yr/bs/lcyrbsjcuggnfwuzetwwjy3auxg.jpeg"><br><br><h3>  Andere Personalisierungstools </h3><br>  Wir haben eine Excel-Platte, um die Bits zu lesen.  Wenn Sie uns einen NDA-Scan mit Microchip zeigen, geben wir ihn Ihnen. <br><br><img src="https://habrastorage.org/webt/gs/j5/r9/gsj5r9tr6ngrcascp8tqxdq6dla.jpeg"><br><br>  Wir haben alles mit Tests abgedeckt, da es viele Optionen gibt, bei denen Sie ein Bit vergessen k√∂nnen und ein Servicebefehl Ihren privaten Schl√ºssel liest.  Tests testen das reale Ger√§t.  Sie wenden sich an den Mikrokreis und √ºberpr√ºfen die korrekte Konfiguration des Ger√§ts: Kann dieser Steckplatz gelesen werden, kann eine solche Signatur erstellt werden? <br><br>  Parallel zu den Bits haben wir eine Liste von Garantien erstellt, die dieses Ger√§t erf√ºllen sollte, und √ºberpr√ºft, wie alles funktioniert.  Wir verwenden das <b>Fledermaus-Framework</b> - eine sehr interessante Sache.  Es sieht so aus. <br><br><img src="https://habrastorage.org/webt/wr/kd/op/wrkdopidmf6zn2ko70ue36p7fxc.jpeg"><br>  <i>Liste der Tests f√ºr ein Beispiel.</i>  <i>Die oberen werden bestanden, die unteren nicht.</i> <br><br><h3>  Einstellungen in Ger√§ten </h3><br>  <b>F√ºr</b> die Aufgabe, √ºber die ich spreche <b>, verwenden wir nur zwei Slots</b> .  In beiden speichern wir den privaten Schl√ºssel des Ger√§tes.  Der Unterschied besteht darin, dass Ersteres mit einem <b>permanenten Zertifikat verbunden ist</b> , das 1970 f√ºr 200 Jahre ausgestellt wurde. <br><br>  Dies liegt an der Tatsache, dass die Zeit im IoT nicht immer synchronisiert ist.  Bei der Zertifikatinfrastruktur wird die G√ºltigkeit eines Zertifikats √ºberpr√ºft.  Wenn die Synchronisierung auf den Ger√§ten unterbrochen ist, kann ein wichtiger Dienst fehlschlagen, z. B. VPN. <br><br>  <b>Ein Slot ist also unendlich - permanent</b> .  Sie wird einmal generiert und √§ndert sich w√§hrend der gesamten Lebensdauer des Ger√§ts nicht.  F√ºr diesen Schl√ºssel wird ein Zertifikat f√ºr 200 Jahre erstellt - f√ºr geschlossene Netzwerke. <br><br>  Ein anderer Slot wird gerade aktualisiert.  Die maximale Lebensdauer des Zertifikats betr√§gt ein Jahr.  Dies geschieht nur f√ºr den Fall, dass etwas kompromittiert wird.  Ein privater aktualisierbarer Ger√§teschl√ºssel wird generiert, wenn die G√ºltigkeitsdauer des Ger√§tezertifikats abl√§uft.  Wird f√ºr die Authentifizierung in offenen Netzwerken verwendet und mindestens einmal im Monat zusammen mit einem Zertifikat aktualisiert. <br><br>  <b>F√ºr Benutzer haben wir verschiedene Kombinationen generiert</b> , darunter mehrere Steckpl√§tze f√ºr private ECDSA-Schl√ºssel.  Benutzer k√∂nnen ihren Schl√ºssel in einem separaten Slot generieren, wenn sie unserem privaten Schl√ºssel nicht vertrauen.  Daf√ºr m√ºssen Sie nur Microchip vertrauen.  Benutzer k√∂nnen Signaturen lesen, verschl√ºsseln - wir haben alles gegeben, was der Chip kann. <br><br>  Bisher hat leider niemand davon Gebrauch gemacht, aber wir hoffen es. <br><br><h3>  Infrastruktur: Zwischenschl√ºssel </h3><br>  Ich habe bereits gesagt, dass wir irgendwann Zwischenzertifikate implementiert haben, um nicht mit einem Stammzertifikat zu gl√§nzen, das nicht verloren gehen sollte.  Er erscheint nie in einer Fabrik. <br><br><img src="https://habrastorage.org/webt/uh/m0/dl/uhm0dl6mdkegvzwl2avlsqpe7kc.jpeg"><br><br>  Physikalisch mittlere Zertifikate sind ein ATECC508A-Chip.  Es unterscheidet sich geringf√ºgig von 608, aber in 508 gibt es Funktionen, die sich f√ºr Schl√ºssel als n√ºtzlich erwiesen haben, aber in 608 ist es nicht mehr vorhanden. <br><br>  Der Chip wird √ºber einen USB-I2C-Adapter angeschlossen.  Dies ist USBISP mit winziger USB-i2c-Firmware - ein Programmierer, der in eine USB-I2C-Bridge geflasht werden kann.  Zwischenzertifikate signieren Ger√§tezertifikate mit ihrem privaten Schl√ºssel. <br><br>  Zwei Merkmale der Mikroschaltung haben sich f√ºr uns als n√ºtzlich erwiesen. <br><br>  <b>Steckplatz f√ºr Hardware-Passwortschutz</b> .  Der Chip kann nur dann zum Lesen der Signatur programmiert werden, wenn zwei Bedingungen erf√ºllt sind: <br><br><ul><li>  wenn das Ger√§t in einem Computer steckt; <br></li><li>  Passwort eingegeben. <br></li></ul><br>  Wir geben dem Vorarbeiter f√ºr die Produktion einen Zwischenschl√ºssel und ein Passwort f√ºr eine Reihe von Controllern.  Dementsprechend m√ºssen Sie sowohl den Schl√ºssel als auch das Passwort stehlen, um Zugriff zu erhalten.  Wir haben diese M√∂glichkeit kostenlos, aber sie erh√∂ht die Sicherheit des Systems. <br><br>  <b>Hardware-Limit f√ºr die Anzahl der Verwendungen</b> .  Der kryptografische Z√§hler im Inneren kann sich nur erh√∂hen.  Wenn es einmal eine vorbestimmte Grenze erreicht, signiert die Mikroschaltung nichts anderes. <br><br><img src="https://habrastorage.org/webt/tm/qv/4-/tmqv4-eakpcudfupub3oy6nt9bw.jpeg"><br><br><h2>  OpenSSL auf dem Client </h2><br>  Betrachten wir, wie alles auf dem Client funktioniert.  Wir haben OpenSSL auf dem Controller.  Wir haben nichts erfunden - das ist gew√∂hnliches TLS, gew√∂hnliche PKI.  Wir brauchten zus√§tzlich eine Kundenbibliothek.  In der √ºberwiegenden Mehrheit der Linux-Software wird es f√ºr eine sichere Verbindung verwendet. <br><br>  Wir haben den Code von Microchip genommen, ein wenig hinzugef√ºgt und das neue OpenSSL unterst√ºtzt <br>  1.1.  Infolgedessen wei√ü er, wie man mit einem Hardwareschl√ºssel arbeitet - Hardware unterst√ºtzt Passw√∂rter f√ºr private Schl√ºssel. <br><br>  Es sieht ungef√§hr so ‚Äã‚Äãaus. <br><br><pre> <code class="plaintext hljs">openssl req -new -engine ateccx08 -keyform engine -key ATECCx08:00:04:C0:00 -subj "/CN=wirenboard-AP6V5MDG" -out device AP6V5MDG.csr</code> </pre> <br>  Dies ist ein Aufruf an regul√§res OpenSSL und eine Anweisung zur Verwendung des entsprechenden Engine-Moduls.  Hier wird der Schl√ºssel festgelegt: Adresse, Modell und die letzten beiden Bytes geben die Nummer des verwendeten Steckplatzes an.  Alles wird √ºbertragen, als w√§re es eine Schl√ºsseldatei, aber es ist keine Datei - Sie m√ºssen in das Ger√§t gehen. <br><br><h2>  SSL auf dem Server </h2><br>  Jedes SSL funktioniert auf dem Server, einschlie√ülich OpenSSL.  Es sind keine √Ñnderungen und benutzerdefinierten Builds auf der Serverseite erforderlich.  Auf dem Server muss lediglich <b>die Kette der Zertifikate</b> (Ger√§tezertifikat + Zwischenzertifikat) √ºberpr√ºft und <b>unser</b> auf der Website ver√∂ffentlichter <b>√∂ffentlicher Schl√ºssel</b> - Wiren Board ROOT CA - gespeichert werden. <br><br>  Standard-TLS besagt, dass sich beide Parteien gegenseitig authentifizieren m√ºssen.  Theoretisch authentifiziert der Client - unser Controller - den Server.    ‚Äî    handshake. <br><br>         :    .    ,         .   letsencrypt    SSL,   ,      . <br><br>       ,    ‚Äî MQTT. <br><br><h2> MQTT: mosquitto   </h2><br>          IBM.               . <br><br> Mosquitto ‚Äî       ,   ,  Linux.    ,   OpenSSL engine (  )    ¬´keyfile¬ª,     . <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="></a>   ,  20 . <br><br>     bundle. <br><br><img src="https://habrastorage.org/webt/ea/ju/ge/eajugei4pidm4h7ramzyhh-vpkq.jpeg"><br><br>             . <br><br><pre> <code class="plaintext hljs">mosquitto_sub -h mqtt.wirenboard.com -p 8884 -cert /etc/ssl/device/device_bundle.crt.pem --key 'engine:ateccx08:ATECCx08:00:04:C0:00' --capath /etc/ssl/certs/ -t /# -v</code> </pre> <br>     .     ‚Äî    <code>-cert</code> .   bundle- ‚Äî .      <code>--key</code> .       . <br><br>  ,    <code>--capath</code> ,    .       SSL-,     letsencrypt. <br><br>   <b> </b> . <br><br><pre> <code class="plaintext hljs">root@wirenboard-AXXVJI62:~# cat /etc/mosquitto/conf.d/bridge-hw.conf connection wb_devices_cloud.wirenboard-AXXVJI62 address contactless.ru:8884 bridge_capath /etc/ssl/certs/ bridge_certfile /etc/ssl/device/device_bundle.crt.pem bridge_keyfile engine:ateccx08:ATECCx08:00:04:C0:00 notifications true notification_topic /client/wirenboard-AXXVJI62/bridge_status topic/# both 1 ""/dient/wirenboard-AXXVJI62</code> </pre> <br> Mosquito-     . <br><br> <b>   Mosquitto</b> ‚Äî    . <br><br><pre> <code class="plaintext hljs">per _listener_settings true listener 8884 0.0.0.0 cafile/etc/mosquitto/certs/WirenBoard_Root_CA.crt certfile /etc/letsencrypt/live/contactless.ru/fullchain.pem keyfile/etc/letsencrypt/live/contactless.ru/privkey.pem require.certificate true use_identity_as_username true password_file /etc/mosquitto/passwd.conf allow_anonymous false acl_file /etc/mosquitto/ad.conf :~$ cat /etc/mosquitto/acl.conf pattern write /client/%u/# pattern read /client/%u/#</code> </pre> <br>   ‚Äî  . <br><br><ul><li>  Root CA  letsencrypt-   ‚Äî   .     . <br></li><li>    Mosquitto.           <code>username</code>      MQTT. <br></li><li>  ,     , ,   (CN) wirenboard-AXXVJI62,   ,      . <br></li><li> <code>per_listener_settings:</code>   ,      / (&gt;1.5.5). <br></li></ul><br>    MQTT-  Wiren Board IoT Cloud Platform. <br><br><h2>  Openvpn </h2><br> OpenVPN  ,      ,     .   ,                . <br><br>  OpenVPN <b> </b>   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="></a> ,   .       ,   : bundle,  , engine. <br><br><pre> <code class="plaintext hljs">openvpn --capath /etc/ssl/certs/ --cert /etc/ssl/device/device_bundle.crt.pem --key engine:ateccx08:ATECCx08:00:04:C0:00</code> </pre> <br> <b> </b>    letsencrypt. <br><br><pre> <code class="plaintext hljs">ca /etc/openvpn/WirenBoard_Root_CA.crt cert /etc/letsencrypt/live/vpn1.wirenboard.com/fullchain.pem key /etc/letsencrypt/live/vpn1.wirenboard.com/privkey.pem</code> </pre> <br>     ‚Äî       .      -  . <br><br><h2>  Nginx </h2><br>   . Nginx   ,    ,        , SSL.      nginx     web-,  reverse-proxy.   ‚Äî      nginx. <br><br> nginx   ,  HTTP-,       .   ,       : Common Name,      ,        .   ,   400. <br><br><pre> <code class="plaintext hljs">ssl_client_certificate WirenBoard_Root_CA.crt; ssl_verify_client on;</code> </pre> <br> <b>nginx  </b> .     ‚Äî ,     HTTP.  Linux-   nginx  ,        SSL,   ,   OpenSSL. <br><br>    wget  , bash    ,   HTTP-  TLS   .    10 . <br><br><pre> <code class="plaintext hljs">server { listen 8080; location / { proxy_pass https://example.com; proxy_ssl_name example.com; proxy_ssl_server_name on; proxy_ssl_certificate/etc/ssl/device/device_bundle.crt.pem; proxy_ssl_certificate_key engine:ateccx08;ATECCx08:00:04:C0:00; } }</code> </pre> <br><h2>   </h2><br>      <b>Wiren Board 6</b> ,     .     ,       . <br><br>         web-   cloud.wirenboard.com  OpenVPN  .     Grafana  InfluxDB,      MQTT.     saymon.info ‚Äî    (MQTT)  . <br><br>      ,  -  ,     , Grafana, MQTT-,   ,  , .   ‚Äî . <br><br>  ,    ,   : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="> </a> ‚Äî  OpenSSL    ,  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="> </a> ‚Äî  .  ! <br><br><blockquote>           <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">InoThings Conf 2019</a> .   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">YouTube-</a>       2019 .    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="></a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="></a>  Telegram.     ,  ,       IoT. </blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de476304/">https://habr.com/ru/post/de476304/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de476292/index.html">SVG oder Leinwand?</a></li>
<li><a href="../de476294/index.html">Distributed Gaming Network als Alternative zu GFN: Wie und warum kann es abheben, wo es in der Russischen F√∂deration bereits funktioniert</a></li>
<li><a href="../de476296/index.html">21. November, Product Engineering MeetUp: Wer ist ein Produktingenieur?</a></li>
<li><a href="../de476298/index.html">Machen Sie sich mit dem Fahrrad vertraut, Teil 1: Lernen Sie die Grundlagen zum Anpassen des Visual Studio-Debuggers mithilfe von Plugins</a></li>
<li><a href="../de476300/index.html">Das Tram-Magazin ist ein hell erleuchteter und schnell verblassender Star der russischen Kinderavantgarde</a></li>
<li><a href="../de476306/index.html">TelegramBot-Anweisungen zum Erstellen grundlegender Funktionen f√ºr den Bot. (Teil 1)</a></li>
<li><a href="../de476308/index.html">Die f√ºnf wichtigsten Methoden zur Softwareentwicklung, die im Jahr 2020 befolgt werden m√ºssen</a></li>
<li><a href="../de476310/index.html">Menschliches Gesicht CRM</a></li>
<li><a href="../de476312/index.html">Reagieren oder Angular oder Vue.js - was soll man w√§hlen?</a></li>
<li><a href="../de476316/index.html">Vue Storefront: F√ºllen Sie Daten in ES</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>