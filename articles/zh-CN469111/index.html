<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩‍👩‍👧‍👧 💰 👼🏿 用var替换Object：可能出什么问题？ 🍸 🕤 🍮</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="我最近遇到了一种情况，在Java 10程序中用var替换Object会在运行时引发异常。 我对实现这种效果的几种不同方法感兴趣，并向社区提出了这个问题： 



 事实证明，您可以通过不同的方式实现效果。 尽管它们都有些复杂，但以这样的任务为例来回顾语言的各种细微之处是很有趣的。 让我们看看找到了什...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>用var替换Object：可能出什么问题？</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/469111/"><p>我最近遇到了一种情况，在Java 10程序中用var替换Object会在运行时引发异常。 我对实现这种效果的几种不同方法感兴趣，并向社区提出了这个问题： </p><br><div class="oembed"><twitter-widget class="twitter-tweet twitter-tweet-rendered" id="twitter-widget-0" style="position: static; visibility: visible; display: block; transform: rotate(0deg); max-width: 100%; width: 500px; min-width: 220px; margin-top: 10px; margin-bottom: 10px;" data-tweet-id="1174191219620089856"></twitter-widget><script async="" src="https://platform.twitter.com/widgets.js" charset="utf-8"></script></div><br><p> 事实证明，您可以通过不同的方式实现效果。 尽管它们都有些复杂，但以这样的任务为例来回顾语言的各种细微之处是很有趣的。 让我们看看找到了什么方法。 </p><a name="habracut"></a><br><h2 id="uchastniki"> 会员 </h2><br><p> 在受访者中，有很多名人，但不是很多。 这是Sergey <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" class="user_link">bsideup</a> Egorov，Pivotal员工，演讲者，Testcontainers的创建者之一。 这是<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Victor Polishchuk</a> ，以关于血腥企业的报道而闻名。 还注意到Google的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Nikita Artyushov</a> ；  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">德米特里•米哈伊洛夫</a> （ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Dmitry Mikhailov）</a>和<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">麦克西莫（Maccimo）</a> 。 但是我对<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Wouter Coekaerts</a>的到来感到特别高兴。  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">去年</a> ，他以他的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">文章</a>而闻名，在那里他浏览了Java类型系统，并讲述了它多么无希望地被打破了。  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" class="user_link">我</a>和<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" class="user_link">jbaruch的</a>一些文章甚至在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Java Puzzlers</a>的第四版中使用过。 </p><br><h2 id="zadacha-i-resheniya"> 任务和解决方案 </h2><br><p>因此，我们任务的本质是：存在一个Java程序，其中声明了一个变量，形式为<code>Object x = ...</code> （诚​​实的标准<code>java.lang.Object</code> ，没有类型替代）。 该程序将编译，运行并打印类似“确定”的内容。 我们用<code>var</code>替换<code>Object</code> ，要求自动类型推断，此后程序继续编译，但在启动时崩溃，并出现异常。 </p><br><p> 解决方案可以大致分为两组。 首先，用var替换后，变量变为原始变量（也就是说，它最初是自动装箱的）。 第二种类型仍然是object，但是比<code>Object</code>更具体。 在这里，您可以突出显示一个使用泛型的有趣子组。 </p><br><h3 id="boksing"> 装箱 </h3><br><p> 如何区分对象和基元？ 有很多不同的方法。 最简单的方法是检查身份。 该解决方案由Nikita提出： </p><br><pre> <code class="java hljs">Object x = <span class="hljs-number"><span class="hljs-number">1000</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (x == <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Integer(<span class="hljs-number"><span class="hljs-number">1000</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Error(); System.out.println(<span class="hljs-string"><span class="hljs-string">"Ok"</span></span>);</code> </pre> <br><p> 当<code>x</code>是一个对象时，通过引用新对象<code>new Integer(1000)</code>当然不能相等。 并且如果它是原始的，则根据语言的规则， <code>new Integer(1000)</code>立即展开为原始，并将数字作为原始进行比较。 </p><br><p> 另一种方法是重载方法。 您可以编写自己的代码，但Sergey提出了一个更优雅的选择：使用标准库。  <code>List.remove</code>方法是<code>List.remove</code> ，它是重载的，如果传递了原语，则可以<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">按索引</a>删除<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">元素，</a>如果传递对象，则可以<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">按值</a>删除<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">元素</a> 。 如果使用<code>List&lt;Integer&gt;</code>这会反复导致实际程序中的错误。 对于我们的任务，解决方案可能如下所示： </p><br><pre> <code class="java hljs">Object x = <span class="hljs-number"><span class="hljs-number">1000</span></span>; List&lt;?&gt; list = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList&lt;&gt;(); list.remove(x); System.out.println(<span class="hljs-string"><span class="hljs-string">"Ok"</span></span>);</code> </pre> <br><p> 现在，我们尝试从空列表中删除不存在的元素1000，这只是一个无用的操作。 但是，如果将<code>Object</code>替换为<code>var</code> ，我们将调用另一个方法来删除索引为1000的元素。这已经导致<code>IndexOutOfBoundsException</code> 。 </p><br><p> 第三种方法是类型转换运算符。 我们可以成功地将另一个基元转换为基元类型，但是只有在要转换为相同类型的包装器上才会转换对象（然后才会进行装箱）。 实际上，我们需要相反的效果：在原始情况下而不是在对象情况下会发生异常，但是使用try-catch可以轻松实现，Viktor曾使用过： </p><br><pre> <code class="java hljs">Object x = <span class="hljs-number"><span class="hljs-number">40</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Error(<span class="hljs-string"><span class="hljs-string">"Oops :"</span></span> + (<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>)x); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (ClassCastException e) { System.out.println(<span class="hljs-string"><span class="hljs-string">"Ok"</span></span>); }</code> </pre> <br><p> 在这里， <code>ClassCastException</code>是预期的行为，然后程序正常退出。 但是在使用<code>var</code>该异常消失了，我们抛出了其他东西。 我想知道这是否受到血腥企业的真实代码的启发？ </p><br><p>  Wouter提出了另一个类型转换选项。 您可以使用运算符的奇怪逻辑<code>?:</code> 。 没错，它的代码只会给出不同的结果，因此您必须以某种方式对其进行修改，以免出现异常。 因此，在我看来，非常优雅： </p><br><pre> <code class="java hljs">Object x = <span class="hljs-number"><span class="hljs-number">1.0</span></span>; System.out.println(String.valueOf(<span class="hljs-keyword"><span class="hljs-keyword">false</span></span> ? x : <span class="hljs-number"><span class="hljs-number">100000000000L</span></span>).substring(<span class="hljs-number"><span class="hljs-number">12</span></span>) + <span class="hljs-string"><span class="hljs-string">"Ok"</span></span>);</code> </pre> <br><p> 此方法之间的区别是我们不直接使用<code>x</code>的值，而是类型<code>x</code>影响表达式<code>false ? x : 100000000000L</code>的类型<code>false ? x : 100000000000L</code>  <code>false ? x : 100000000000L</code> 。 如果<code>x</code>是一个<code>Object</code> ，则整个表达式的类型为<code>Object</code> ，然后我们只有装箱， <code>String.valueOf()</code>将<code>String.valueOf()</code>字符串<code>100000000000</code> ，其中<code>substring(12)</code>是一个空字符串。 如果使用<code>var</code> ，则类型<code>x</code>变为<code>double</code> ，因此类型为<code>false ? x : 100000000000L</code>  <code>false ? x : 100000000000L</code>也是<code>double</code> ，即<code>100000000000L</code>将变成<code>1.0E11</code> ，该字符少于12个字符，因此调用<code>substring</code>会导致<code>StringIndexOutOfBoundsException</code> 。 </p><br><p> 最后，我们利用了一个事实，即变量在创建后实际上可以更改。 并且在对象变量中，与原始变量不同，您可以放置<code>null</code> 。 将<code>null</code>放入变量很容易；有很多方法。 但是在这里，Wouter还使用了荒谬的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><code>Integer.getInteger</code></a>方法采取了一种创造性的方法： </p><br><pre> <code class="java hljs">Object x = <span class="hljs-number"><span class="hljs-number">1</span></span>; x = Integer.getInteger(<span class="hljs-string"><span class="hljs-string">"moo"</span></span>); System.out.println(<span class="hljs-string"><span class="hljs-string">"Ok"</span></span>);</code> </pre> <br><p> 并非所有人都知道此方法读取一个称为<code>moo</code>的系统属性，如果存在，将尝试将其转换为数字，否则返回<code>null</code> 。 如果没有属性，我们将为对象安静地分配<code>null</code> ，但是在尝试将其分配给原始对象时会从<code>NullPointerException</code>掉落（在那里发生自动装箱）。 当然，它本来可以更容易。 粗糙版本<code>x = null;</code> 它不会爬网-它不会编译，但是编译器现在会吞下它： </p><br><pre> <code class="java hljs">Object x = <span class="hljs-number"><span class="hljs-number">1</span></span>; x = (Integer)<span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; System.out.println(<span class="hljs-string"><span class="hljs-string">"Ok"</span></span>);</code> </pre> <br><h3 id="obektnyy-tip"> 对象类型 </h3><br><p> 假设您不再可以使用基本体。 您还能想到什么？ </p><br><p> 好吧，首先，Dmitry提出了最简单的方法重载方法： </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String[] args)</span></span></span><span class="hljs-function"> </span></span>{ Object x = <span class="hljs-string"><span class="hljs-string">"Ok"</span></span>; sayWhat(x); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sayWhat</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Object x)</span></span></span><span class="hljs-function"> </span></span>{ System.out.println(x); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sayWhat</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String x)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Error(); }</code> </pre> <br><p>  Java中重载方法的链接在编译阶段静态发生。 在<code>sayWhat(Object)</code> sayWhat <code>sayWhat(Object)</code>方法，但是如果我们自动推断类型<code>x</code> ，则将<code>sayWhat(String)</code>出<code>String</code> ，因此将链接更具体的<code>sayWhat(String)</code>方法。 </p><br><p> 在Java中进行歧义调用的另一种方法是使用变量参数（varargs）。 伍特再次想起了这一点： </p><br><pre> <code class="java hljs">Object x = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Object[] {}; Arrays.asList(x).get(<span class="hljs-number"><span class="hljs-number">0</span></span>); System.out.println(<span class="hljs-string"><span class="hljs-string">"Ok"</span></span>);</code> </pre> <br><p> 当变量类型为<code>Object</code> ，编译器认为它是变量参数，并将该数组包装在一个元素的另一个数组中，因此<code>get()</code>成功实现。 如果使用<code>var</code> ， <code>Object[]</code>显示类型为<code>Object[]</code> ，并且不会进行其他包装。 这样，我们得到一个空列表，并且<code>get()</code>调用将失败。 </p><br><p>  Maccimo追求核心：他决定通过MethodHandle API调用<code>println</code> ： </p><br><pre> <code class="java hljs">Object x = <span class="hljs-string"><span class="hljs-string">"Ok"</span></span>; MethodHandles.Lookup lookup = MethodHandles.lookup(); MethodHandle mh = lookup.findVirtual( PrintStream.class, <span class="hljs-string"><span class="hljs-string">"println"</span></span>, MethodType.methodType(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>.class, Object.class)); mh.invokeExact(System.out, x);</code> </pre> <br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><code>invokeExact</code></a>方法和<code>java.lang.invoke</code>中的其他几种方法都具有所谓的“多态签名”。 尽管<code>invokeExact(Object... args)</code>其声明为常用的vararg <code>invokeExact(Object... args)</code>方法，但在标准数组包装中不会发生这种情况。 而是在字节码中生成与实际传递的参数类型匹配的签名。  <code>invokeExact</code>方法<code>invokeExact</code>为方法句柄的超快速调用而设计的，因此它不执行任何标准参数转换，例如强制转换或装箱。 句柄方法类型应与呼叫签名完全匹配。 这是在运行时检查的，就像在<code>var</code>情况下，匹配被破坏一样，我们得到了<code>WrongMethodTypeException</code> 。 </p><br><h3 id="dzheneriki"> 泛型 </h3><br><p> 当然，类型的参数化可以给Java中的任何任务带来麻烦。  Dmitry带来了一个类似于我最初遇到的代码的解决方案。 德米特里（Dmitry）的决定很冗长，因此我将向您展示： </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String[] args)</span></span></span><span class="hljs-function"> </span></span>{ Object x = foo(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StringBuilder()); System.out.println(x); } <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> &lt;T&gt; <span class="hljs-function"><span class="hljs-function">T </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(T x)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (T)<span class="hljs-string"><span class="hljs-string">"Ok"</span></span>; }</code> </pre> <br><p> 类型<code>T</code>输出为<code>StringBuilder</code> ，但在此代码中，不需要编译器在拨号对等点的字节码中插入类型检查。 对他而言，可以将<code>StringBuilder</code>分配给<code>Object</code>就足够了，这意味着一切都很好。 如果将结果分配给<code>Object</code>类型的变量，则没有人反对带有返回值<code>StringBuilder</code>的方法实际上返回了字符串的事实。 编译器诚实地警告您，您进行了未经检查的演员表转换，这意味着他在洗手。 但是，当用<code>var</code>替换<code>x</code>时<code>var</code>类型<code>x</code>也将显示为<code>StringBuilder</code> ，并且没有类型检查将不再可能，因为将其他内容分配给<code>StringBuilder</code>类型变量毫无用处。 结果，在更改为<code>var</code>程序会因<code>ClassCastException</code>安全地崩溃。 </p><br><p>  Wouter使用标准方法建议了此解决方案的一种变体： </p><br><pre> <code class="java hljs">Object o = ((List&lt;String&gt;)(List)List.of(<span class="hljs-number"><span class="hljs-number">1</span></span>)).get(<span class="hljs-number"><span class="hljs-number">0</span></span>); System.out.println(<span class="hljs-string"><span class="hljs-string">"Ok"</span></span>);</code> </pre> <br><p> 最后，Wouter的另一个选择： </p><br><pre> <code class="java hljs">Object x = <span class="hljs-string"><span class="hljs-string">""</span></span>; TreeSet&lt;?&gt; set = Stream.of(x) .collect(toCollection(() -&gt; <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> TreeSet&lt;&gt;((a, b) -&gt; <span class="hljs-number"><span class="hljs-number">0</span></span>))); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (set.contains(<span class="hljs-number"><span class="hljs-number">1</span></span>)) { System.out.println(<span class="hljs-string"><span class="hljs-string">"Ok"</span></span>); }</code> </pre> <br><p> 在此，根据<code>var</code>或<code>Object</code>的使用<code>Object</code>流类型显示为<code>Stream&lt;Object&gt;</code>或<code>Stream&lt;String&gt;</code> 。 因此，将显示<code>TreeSet</code>类型和比较器lambda类型。 在<code>var</code>的情况下，字符串必须到达lambda，因此在生成lambda运行时表示时，将自动插入类型转换，这在尝试将单元转换为字符串时会产生<code>ClassCastException</code> 。 </p><br><p> 通常，结果非常无聊。 如果您可以提出根本不同的方法来破坏<code>var</code> ，请在注释中编写。 </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN469111/">https://habr.com/ru/post/zh-CN469111/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN469095/index.html">ML.NET和模型构建器更新已发布：新增功能</a></li>
<li><a href="../zh-CN469097/index.html">具有php7，node.js和Redis的CentOS 8 Web服务器</a></li>
<li><a href="../zh-CN469099/index.html">在开发人员面试中测试任务-是否有意义？</a></li>
<li><a href="../zh-CN469101/index.html">学习英语：如何学习以英语为母语</a></li>
<li><a href="../zh-CN469109/index.html">木制玩具，第三部分-1989年</a></li>
<li><a href="../zh-CN469115/index.html">Discovery.js指南：快速入门</a></li>
<li><a href="../zh-CN469117/index.html">根据BC 0010于2019年进行编程</a></li>
<li><a href="../zh-CN469119/index.html">RIPE中的IPv4地址已结束。 完全结束...</a></li>
<li><a href="../zh-CN469125/index.html">雷鸟的黑暗主题是运行代码分析器的原因</a></li>
<li><a href="../zh-CN469127/index.html">优化或如何不让自己陷入困境</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>