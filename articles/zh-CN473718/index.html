<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤦🏿 ☝🏻 🗜️ 如何在不编写任何Go代码的情况下将检查添加到NoVerify 💝 ♍️ 🕋</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="杀手级功能已出现在NoVerify静态分析器中：这是一种描述性的描述方式，不需要Go编程和代码编译。 


 为了引起您的兴趣，我将向您介绍一个简单但有用的检查的描述： 


/** @warning duplicated sub-expressions inside boolean express...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>如何在不编写任何Go代码的情况下将检查添加到NoVerify</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/vk/blog/473718/"><p> 杀手级功能已出现在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">NoVerify</a>静态分析器中：这是一种描述性的描述方式，不需要Go编程和代码编译。 </p><br><p> 为了引起您的兴趣，我将向您介绍一个简单但有用的检查的描述： </p><br><pre><code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">/** </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@warning</span></span></span><span class="hljs-comment"> duplicated sub-expressions inside boolean expression */</span></span> $x &amp;&amp; $x;</code> </pre> <br><p> 此检查找到左右操作数相同的所有逻辑<code>&amp;&amp;</code>表达式。 </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">NoVerify</a>是用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Go</a>编写的PHP静态分析器。 您可以在文章“ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">NoVerify：来自VKontakte团队的PHP Linter</a> ”中<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">阅读</a>有关它的信息。 在这篇评论中，我将讨论新功能以及我们如何使用它。 </p><br><p><img src="https://habrastorage.org/webt/gv/ru/74/gvru74yeqcbjdphiuwj4tieehoq.png"></p><a name="habracut"></a><br><h1 id="predposylki"> 背景知识 </h1><br><p> 即使对于一个简单的新支票，您仍然需要在Go上编写几十行代码，您会开始怀疑：是否可能呢？ </p><br><p> 在Go上，我们编写了类型推断，lint的整个管道，元数据缓存以及许多其他重要元素，没有NoVerify，这些元素就无法实现。 这些组件是唯一的，但“禁止调用带有一组参数Y的函数X”之类的任务并非如此。 仅针对此类简单任务，就添加了动态规则机制。 </p><br><p> 动态规则使您可以将复杂的内部结构与解决典型问题分开。 定义文件可以单独存储和版本控制-可以由与NoVerify本身的开发无关的人员进行编辑。 每个规则都执行代码检查（有时称为验证）。 </p><br><p> 是的，如果我们使用一种描述这些规则的语言，则您总是可以编写一个语义上不正确的模板或忽略某些类型限制-这会导致误报。 但是，不会输入通过规则语言进行的数据竞争或对<code>nil</code>指针的取消引用。 </p><br><h1 id="yazyk-opisaniya-shablonov"> 模板描述语言 </h1><br><p> 描述语言在语法上与PHP兼容。 这简化了它的研究，也使使用相同的PhpStorm编辑规则文件成为可能。 </p><br><p> 在rules文件的最开始，建议插入一条指令来缓解您喜欢的IDE： </p><br><pre> <code class="php hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?php</span></span> <span class="hljs-comment"><span class="hljs-comment">/** *      , *        PHP-. * * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@noinspection</span></span></span><span class="hljs-comment"> ALL */</span></span> <span class="hljs-comment"><span class="hljs-comment">// ...  —   .</span></span></code> </pre> <br><p> 我的第一个关于语法和可能的模板过滤器的实验是<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">phpgrep</a> 。 它可能单独有用，但是在NoVerify内部，它变得更加有趣，因为现在它可以访问类型信息。 </p><br><p> 我的一些同事已经在工作中尝试了phpgrep，这是赞成选择这样一种<a href="">语法的</a>另一个论点。 </p><br><p>  Phpgrep本身是针对PHP的gogrep改编版（您可能对<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">cgrep</a>也可能感兴趣）。 使用此程序，您可以通过<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">语法模板</a>搜索代码。 </p><br><p> 一种替代方法是PhpStorm中的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">结构搜索和替换</a> （SSR）语法。 优点是显而易见的-这是一种现有格式，但是我在实现phpgrep之后才发现此功能。 您当然可以提供技术解释：语法与PHP不兼容， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">我们的解析器</a>将无法掌握它，但是这种令人信服的“真实”原因是在编写自行车后发现的。 </p><br><div class="spoiler">  <b class="spoiler_title">实际上，还有另一种选择</b> <div class="spoiler_text"><hr><br><p> 可能需要以几乎一对一的方式显示带有PHP代码的模板，或者采用另一种方式：发明一种新语言，例如使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">S-expressions</a>的语法。 </p><br><pre> <code class="plaintext hljs">PHP-like Lisp-like ----------------------------- $x = $y | (expr = $x $y) fn($x, 1) | (expr call fn $x 1)          : (or (expr == (type string (expr)) (expr)) (expr == (expr) (type string (expr))))</code> </pre> <br><p> 最后，我认为模板的可读性仍然很重要，我们可以通过phpdoc属性添加过滤器。 </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">clang-query</a>是类似想法的一个示例，但是它使用了更传统的语法。 </p><br><hr></div></div><br><h1 id="sozdayom-i-zapuskaem-svoyu-diagnostiku"> 我们创建并运行我们自己的诊断程序！ </h1><br><p> 让我们尝试为分析器实施新的诊断。 </p><br><p> 为此，您需要安装NoVerify。 如果系统中没有Go-toolchain，请采用<a href="">二进制发行版</a> （如果有，则可以从源代码编译所有文件）。 </p><br><div class="scrollable-table"><table><tbody><tr><td> 如果您没有安装NoVerify，则可以继续阅读，但是假装重现列出的步骤并欣赏结果！ <br></td></tr></tbody></table></div><br><h2 id="postanovka-zadachi"> 问题陈述 </h2><br><p>  PHP有许多有趣的功能，其中之一是<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">parse_str</a> 。 她的签名： </p><br><pre> <code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">//   encoded_string,     //   URL,      //   (  ,    result). parse_str ( string $encoded_string [, array &amp;$result ] ) : void</span></span></code> </pre> <br><p> 如果您从文档中查看此示例，您将了解这里出了什么问题： </p><br><pre> <code class="php hljs">$str = <span class="hljs-string"><span class="hljs-string">"first=value&amp;arr[]=foo+bar&amp;arr[]=baz"</span></span>; parse_str($str); <span class="hljs-keyword"><span class="hljs-keyword">echo</span></span> $first; <span class="hljs-comment"><span class="hljs-comment">// value echo $arr[0]; // foo bar echo $arr[1]; // baz</span></span></code> </pre> <br><p> 嗯，来自字符串的参数在当前范围内。 为避免这种情况，我们将在新测试中要求使用函数的第二个参数<code>$result</code> ，以便将结果写入此数组。 </p><br><h2 id="sozdanie-svoey-diagnostiki"> 创建自己的诊断 </h2><br><p> 创建<code>myrules.php</code>文件： </p><br><pre> <code class="php hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?php</span></span> <span class="hljs-comment"><span class="hljs-comment">/** </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@warning</span></span></span><span class="hljs-comment"> parse_str without second argument */</span></span> parse_str($_);</code> </pre> <br><p> 通常，规则文件是顶层表达式的列表，每个表达式都被解释为phpgrep模板。 每个这样的模板都需要一个特殊的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">phpdoc</a>注释。 只需要一个属性-一个带有警告文本的错误类别。 </p><br><p> 现在总共有四个级别： <code>error</code> ， <code>warning</code> ， <code>info</code>甚至。 前两个是关键的：如果至少一个关键规则有效，则linter将在执行后返回非零代码。 在属性本身之后，如果模板被触发，短绒棉将发出警告文本。 </p><br><p> 我们编写的模板使用<code>$_</code>这是一个未命名的模板变量。 我们可以称它为<code>$x</code> ，但是由于我们不对该变量做任何事情，因此可以给它一个“空”名称。 模板变量和PHP变量之间的区别在于，前者与任何表达式都完全一致，而不仅仅是“文字”变量。 这很方便：我们经常需要查找未知表达式，而不是特定变量。 </p><br><h2 id="zapusk-novoy-diagnostiki"> 开始新的诊断 </h2><br><p> 创建一个小的调试文件<code>test.php</code> ： </p><br><pre> <code class="php hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?php</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($x)</span></span></span><span class="hljs-function"> </span></span>{ parse_str($x); <span class="hljs-comment"><span class="hljs-comment">//      }</span></span></code> </pre> <br><p> 接下来，使用此文件的规则运行NoVerify： </p><br><pre> <code class="bash hljs">$ noverify -rules myrules.php test.php</code> </pre> <br><p> 我们的警告将如下所示： </p><br><pre> <code class="plaintext hljs">WARNING myrules.php:4: parse_str without second argument at test.php:4 parse_str($x); ^^^^^^^^^^^^^</code> </pre> <br><p> 默认检查的名称是规则文件的名称以及定义此检查的行。 在我们的例子中，这是<code>myrules.php:4</code> 。 </p><br><p> 您可以使用<code>@name &lt;name&gt;</code>属性设置名称。 </p><br><div class="spoiler">  <b class="spoiler_title">@Name示例</b> <div class="spoiler_text"><hr><br><pre> <code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">/** * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@name</span></span></span><span class="hljs-comment"> parseStrResult * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@warning</span></span></span><span class="hljs-comment"> parse_str without second argument */</span></span> parse_str($_);</code> </pre> <br><pre> <code class="plaintext hljs">WARNING parseStrResult: parse_str without second argument at test.php:4 parse_str($x); ^^^^^^^^^^^^^</code> </pre> <br><p> 命名规则遵循其他诊断法则： </p><br><ul><li> 可以通过<code>-exclude-checks</code>禁用 </li><li> 可以通过<code>-critical</code>重新定义<code>-critical</code>级别 </li></ul><br><hr></div></div><br><h1 id="rabota-s-tipami"> 处理类型 </h1><br><p> 前面的示例对您好世界很有用-但通常我们需要知道表达式的类型以减少诊断操作的次数 </p><br><p> 例如，对于<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">in_array</a>函数<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">，</a>当第一个参数（ <code>$needle</code> ）是字符串类型时<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">，</a>我们要求参数<code>$strict=true</code> 。 </p><br><p> 为此，我们有结果过滤器。 </p><br><p> 一种这样的过滤器是<code>@type &lt;type&gt; &lt;var&gt;</code> 。 它允许您丢弃不适合枚举类型的所有内容。 </p><br><pre> <code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">/** * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@warning</span></span></span><span class="hljs-comment"> 3rd arg of in_array must be true when comparing strings * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@type</span></span></span><span class="hljs-comment"> string $needle */</span></span> in_array($needle, $_);</code> </pre> <br><p> 在这里，我们将第一个参数的名称赋予<code>in_array</code>调用，以将类型过滤器绑定到它。 仅当<code>$needle</code>类型为<code>string</code>时，才会发出警告。 </p><br><p> 过滤器集可以与<code>@or</code>运算符结合使用： </p><br><pre> <code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">/** *     -. * * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@warning</span></span></span><span class="hljs-comment"> strings must be compared using '===' operator * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@type</span></span></span><span class="hljs-comment"> string $x * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@or</span></span></span><span class="hljs-comment"> * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@type</span></span></span><span class="hljs-comment"> string $y */</span></span> $x == $y;</code> </pre> <br><p> 在上面的示例中，模式仅匹配那些<code>==</code>表达式，其中任何操作数的类型均为<code>string</code> 。 可以假设没有<code>@or</code>所有过滤器都通过<code>@and</code>组合，但这无需明确指出。 </p><br><h1 id="ogranichivaem-oblast-deystviya-diagnostiki"> 限制诊断范围 </h1><br><p> 对于每个测试，您可以指定<code>@scope &lt;name&gt;</code> ： </p><br><ul><li>  <code>@scope all</code>默认值，验证无处不在； </li><li>  <code>@scope root</code>仅在顶层启动； </li><li>  <code>@scope local</code>仅在函数和方法内部运行。 </li></ul><br><p> 假设我们要在函数主体外部报告<code>return</code>值。 在PHP中，这有时是有道理的-例如，当从函数连接文件时...但是在本文中，我们对此予以谴责。 </p><br><pre> <code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">/** * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@warning</span></span></span><span class="hljs-comment"> don't use return outside of functions * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@scope</span></span></span><span class="hljs-comment"> root */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> $_;</code> </pre> <br><p> 让我们看看该规则的行为： </p><br><pre> <code class="php hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?php</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"OK"</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"NOT OK"</span></span>; <span class="hljs-comment"><span class="hljs-comment">// Gives a warning class C { public function m() { return "ALSO OK"; } }</span></span></code> </pre> <br><p> 同样，您可以请求使用<code>*_once</code>而不是<code>require</code>和<code>include</code> ： </p><br><pre> <code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">/** * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@maybe</span></span></span><span class="hljs-comment"> prefer require_once over require * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@scope</span></span></span><span class="hljs-comment"> root */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">require</span></span> $_; <span class="hljs-comment"><span class="hljs-comment">/** * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@maybe</span></span></span><span class="hljs-comment"> prefer include_once over include * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@scope</span></span></span><span class="hljs-comment"> root */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">include</span></span> $_;</code> </pre> <br><blockquote> 现在，在匹配模式时，并不会一直考虑括号。 模式<code>(($x))</code>不会找到“括号中的所有表达式”，而只是忽略括号的任何表达式。 但是， <code>$x+$y*$z</code>和<code>($x+$y)*$z</code>按其应有的方式工作。 此功能来自使用令牌<code>(</code>和<code>)</code>的困难，但是有可能在下一个发行版中恢复该顺序。 </blockquote><br><h1 id="gruppirovanie-shablonov"> 分组模板 </h1><br><p> 当模板上出现重复的docdoc注释时，可以组合模板。 </p><br><p> 一个简单的例子来演示： </p><br><div class="scrollable-table"><table><tbody><tr><th> 是 </th><th> 变成了（有分组） </th></tr><tr><td><pre> / ** @也许不使用退出或死亡* /
死（$ _）;<font></font>
<font></font>
 / ** @也许不使用退出或死亡* /
退出（$ _）;
</pre></td><td><pre> / ** @也许不使用退出或死亡* /
 {
  死（$ _）;
  退出（$ _）;
 }
</pre></td></tr></tbody></table></div><br><p> 现在，假设在以下示例中没有此功能的描述规则将是多么不愉快！ </p><br><pre> <code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">/** * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@warning</span></span></span><span class="hljs-comment"> don't compare arrays with numeric types * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@type</span></span></span><span class="hljs-comment"> array $x * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@type</span></span></span><span class="hljs-comment"> int|float $y * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@or</span></span></span><span class="hljs-comment"> * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@type</span></span></span><span class="hljs-comment"> int|float $x * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@type</span></span></span><span class="hljs-comment"> array $y */</span></span> { $x &gt; $y; $x &lt; $y; $x &gt;= $y; $x &lt;= $y; $x == $y; }</code> </pre> <br><p> 本文中指定的记录格式只是建议的选项之一。 如果您想参与选择，那么您将有这样的机会：您需要为那些比其他人更喜欢的报价提供+1。 有关更多详细信息， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">请单击此处</a> 。 </p><br><h1 id="kak-integrirovany-dinamicheskie-pravila"> 动态规则如何整合 </h1><br><p><img src="https://habrastorage.org/webt/1l/hl/x4/1lhlx4vcasmxii4zhwf6fmzlgn8.jpeg"></p><br><p> 在启动时，NoVerify尝试查找<code>rules</code>参数中指定的规则文件。 </p><br><p> 接下来，将此文件解析为常规的PHP脚本，并从生成的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">AST</a>中收集一组绑定了phpgrep模板的规则对象。 </p><br><p> 然后，分析器根据通常的方案开始工作-唯一的区别是，对于某些已检查的代码段，它启动了一组绑定规则。 如果触发了规则，则会显示警告。 </p><br><p> 成功被认为是phpgrep模板与至少一个过滤器集（它们用@或分隔）通过的<code>@or</code> 。 </p><br><p> 在这个阶段，即使有很多动态规则，规则机制也不会显着降低Linter的运行速度。 </p><br><h2 id="algoritm-matchinga"> 匹配算法 </h2><br><p> 使用天真的方法，对于每个AST节点，我们需要应用所有动态规则。 这是一个非常低效的实现，因为大部分工作都是徒劳的：许多模板都有一个特定的前缀，我们可以通过这些前缀对规则进行聚类。 </p><br><p> 这类似于<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">并行匹配</a>的想法，但是我们不会诚实地构建NFA，而只是“并行化”计算的第一步。 </p><br><p> 考虑具有三个规则的示例： </p><br><pre> <code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">/** </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@warning</span></span></span><span class="hljs-comment"> duplicated then/else parts of ternary */</span></span> $_ ? $x : $x; <span class="hljs-comment"><span class="hljs-comment">/** </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@warning</span></span></span><span class="hljs-comment"> don't call explode with delim="" */</span></span> explode(<span class="hljs-string"><span class="hljs-string">""</span></span>, ${<span class="hljs-string"><span class="hljs-string">"*"</span></span>}); <span class="hljs-comment"><span class="hljs-comment">/** </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@maybe</span></span></span><span class="hljs-comment"> suspicious empty body of the if statement */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ($_);</code> </pre> <br><p> 如果我们有N个元素和M条规则，那么采用幼稚的方法，我们将要执行N * M个操作。 从理论上讲，可以将这种复杂度降低为线性并得到<code>O(N)</code> -如果将所有模式组合为一个并按其执行匹配，例如Go的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">regexp</a>包。 </p><br><p> 但是，实际上，到目前为止，我一直专注于这种方法的部分实现。 它将允许将上面文件中的规则分为三类，并为没有规则对应的那些AST元素分配第四个空类别。 因此，每个元素最多执行一条规则。 </p><br><p> 如果我们有成千上万的规则，并且会感觉到速度明显下降，则算法将最终确定。 同时，解决方案的简单性和所带来的加速适合我。 </p><br><h2 id="muki-vybora-ili-nemnogo-o-forme-zapisi-type"> 选择的折磨，或<code>@type</code>形式的一点点 </h2><br><div class="scrollable-table"><table><tbody><tr><td> 任务：为phpdoc注释中的过滤器选择良好的语法。 <br></td></tr></tbody></table></div><br><p> 当前语法复制<code>@var</code>和<code>@var</code> ，但是我们可能需要新的运算符，例如，“ type is not equal”。 想象一下它的外观。 </p><br><p> 我们至少有两个重要优先事项： </p><br><ol><li> 注释的可读性和简洁性。 </li><li>  IDE可以提供最大的支持，而无需额外的努力。 </li></ol><br><p> 对于PhpStorm，有一个<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">php-annotations</a>插件，可添加自动完成功能，过渡到注释类以及使用phpdoc注释的其他实用性。 </p><br><p> 在实践中，优先级（2）意味着您所做的决策与IDE和插件的期望没有矛盾。 例如，您可以使用php-annotations插件可以识别的格式进行注释： </p><br><pre> <code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">/** * Type is a filter that checks that $value * satisfies the given type constraints. * * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@Annotation</span></span></span><span class="hljs-comment"> */</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Filter</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/** Variable name that is being filtered */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> $value; <span class="hljs-comment"><span class="hljs-comment">/** Check that value type is equal to $type */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> $type; <span class="hljs-comment"><span class="hljs-comment">/** Check that value text is equal to $text */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> $text; }</code> </pre> <br><p> 然后将过滤器应用于类型将如下所示： </p><br><pre> <code class="plaintext hljs">@Type($needle, eq=string) @Type($x, not_eq=Foo)</code> </pre> <br><p> 用户可以转到<code>Filter</code>的定义，然后会提示他们一系列可能的参数（类型/文本/等）。 </p><br><p> 替代的录制方法，其中一些是同事建议的： </p><br><pre> <code class="plaintext hljs">@type string $needle @type !Foo $x @type $needle == string @type $x != Foo @type(==) string $needle @type(!=) Foo $x @type($needle) == string @type($x) != Foo @filter type($needle) == string @filter type($x) != Foo</code> </pre> <br><p> 然后我们有点分心，忘了它全部都在phpdoc中，出现了： </p><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">eq</span></span> string (<span class="hljs-name"><span class="hljs-name">typeof</span></span> $needle)) (<span class="hljs-name"><span class="hljs-name">neq</span></span> Foo (<span class="hljs-name"><span class="hljs-name">typeof</span></span> $x))</code> </pre> <br><p> 尽管还播放了带有postfix录制选项的声音。 用于描述类型和值约束的语言可以称为第六种： </p><br><pre> <code class="plaintext hljs">@eval string $needle typeof = @eval Foo $x typeof &lt;&gt;</code> </pre> <br><p> 最佳选择的搜索仍未完成... </p><br><h1 id="sravnenie-rasshiryaemosti-s-phan"> 与Phan的可扩展性比较 </h1><br><p> 作为<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Phan</a>的优势之一，文章“ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">使用PHPStan，Phan和Psalm的示例对PHP代码进行静态分析</a> ”表明了可扩展性。 </p><br><p> 这是在示例插件中实现的： </p><br><blockquote> 我们想评估我们的代码对PHP 7.3的准备程度（特别是确定是否具有不区分大小写的常量）。 我们几乎可以确定没有这样的常数，但是在12年内可能发生任何事情-应该对其进行检查。 并且我们为Phan编写了一个插件，如果在define（）中使用了第三个参数，该插件将发誓。 </blockquote><p> 这是插件代码的外观（格式针对宽度进行了优化）： </p><br><pre> <code class="php hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?php</span></span> <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> <span class="hljs-title"><span class="hljs-title">Phan</span></span>\<span class="hljs-title"><span class="hljs-title">AST</span></span>\<span class="hljs-title"><span class="hljs-title">ContextNode</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> <span class="hljs-title"><span class="hljs-title">Phan</span></span>\<span class="hljs-title"><span class="hljs-title">CodeBase</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> <span class="hljs-title"><span class="hljs-title">Phan</span></span>\<span class="hljs-title"><span class="hljs-title">Language</span></span>\<span class="hljs-title"><span class="hljs-title">Context</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> <span class="hljs-title"><span class="hljs-title">Phan</span></span>\<span class="hljs-title"><span class="hljs-title">Language</span></span>\<span class="hljs-title"><span class="hljs-title">Element</span></span>\<span class="hljs-title"><span class="hljs-title">Func</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> <span class="hljs-title"><span class="hljs-title">Phan</span></span>\<span class="hljs-title"><span class="hljs-title">PluginV2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> <span class="hljs-title"><span class="hljs-title">Phan</span></span>\<span class="hljs-title"><span class="hljs-title">PluginV2</span></span>\<span class="hljs-title"><span class="hljs-title">AnalyzeFunctionCallCapability</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> <span class="hljs-title"><span class="hljs-title">ast</span></span>\<span class="hljs-title"><span class="hljs-title">Node</span></span>; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DefineThirdParamTrue</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PluginV2</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AnalyzeFunctionCallCapability</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getAnalyzeFunctionCallClosures</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(CodeBase $code_base)</span></span></span><span class="hljs-function"> </span></span>{ $def = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(CodeBase $cb, Context $ctx, Func $fn, $args)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (count($args) &lt; <span class="hljs-number"><span class="hljs-number">3</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;emitIssue( $cb, $ctx, <span class="hljs-string"><span class="hljs-string">'PhanDefineCaseInsensitiv'</span></span>, <span class="hljs-string"><span class="hljs-string">'define with 3 arguments'</span></span>, [] ); }; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [<span class="hljs-string"><span class="hljs-string">'define'</span></span> =&gt; $def]; } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> DefineThirdParamTrue();</code> </pre> <br><p> 这是在NoVerify中可以完成的方法： </p><br><pre> <code class="php hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?php</span></span> <span class="hljs-comment"><span class="hljs-comment">/** </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@warning</span></span></span><span class="hljs-comment"> define with 3 arguments */</span></span> define($_, $_, $_);</code> </pre> <br><p> 我们希望获得大致相同的结果-以便尽可能简单地完成琐碎的事情。 </p><br><h1 id="zaklyuchenie"> 结论 </h1><br><ul><li> 在您的项目中尝试<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">NoVerify</a> 。 </li><li> 如果您有任何改进或错误报告的想法，请<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">告诉我们</a> 。 </li><li> 如果您想参与开发， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">欢迎光临</a> ！ </li></ul><br><h1 id="ssylki-poleznye-materialy"> 链接，有用的材料 </h1><br><p> 这里收集了重要的链接，本文中可能已经提到了一些重要的链接，但是为了清楚和方便起见，我将它们收集在一个地方。 </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">关于Habré上的NoVerify的文章</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">有关Habré上phpgrep的文章</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Phpgrep与IT Nights对话视频</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">gogrep-</a>通过语法模式搜索代码 </li><li>  ESLint <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">AST选择器</a>概念类似于语法模板 </li></ul><br><p> 如果您需要更多可以实施的规则示例，则可以浏览<a href="">NoVerify测试</a> 。 </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN473718/">https://habr.com/ru/post/zh-CN473718/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN473706/index.html">Zoia：轻型反应式CMS，可快速开发网站</a></li>
<li><a href="../zh-CN473708/index.html">自制电动车-一切都不是您想的</a></li>
<li><a href="../zh-CN473710/index.html">文档和本地化的原则，或如何以最小的成本获得良好的本地化</a></li>
<li><a href="../zh-CN473714/index.html">我是如何使用F＃编写RISC-V处理器的正式规范的</a></li>
<li><a href="../zh-CN473716/index.html">鼠标驱动的小部件。 在窗口内拖放</a></li>
<li><a href="../zh-CN473720/index.html">进行可靠的单元测试的两种方法</a></li>
<li><a href="../zh-CN473722/index.html">远程隔离，焦虑和抑郁</a></li>
<li><a href="../zh-CN473726/index.html">仅仅知道Mutex，Semaphore和async / await是什么还不够。 您需要了解量子的一切</a></li>
<li><a href="../zh-CN473728/index.html">典型实施监控。 尼古拉·西夫科（Nikolay Sivko）</a></li>
<li><a href="../zh-CN473732/index.html">10亿美元在北极修建电缆网络的欺诈历史</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>