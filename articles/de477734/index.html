<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üèØ ü§∂üèø üö∂üèæ Grundlegendes zum UICollectionViewLayout mit der Photos-App üë®‚Äçüîß üö≠ üë®</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hallo habr Mein Name ist Nikita, ich arbeite bei ABBYY an mobilen SDKs und besch√§ftige mich auch mit der UI-Komponente zum Scannen und bequemen Anzeig...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Grundlegendes zum UICollectionViewLayout mit der Photos-App</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/abbyy/blog/477734/"> Hallo habr  Mein Name ist Nikita, ich arbeite bei ABBYY an mobilen SDKs und besch√§ftige mich auch mit der UI-Komponente zum Scannen und bequemen Anzeigen mehrseitiger Dokumente auf einem Smartphone.  Diese Komponente reduziert die Zeit f√ºr die Entwicklung von Anwendungen, die auf der <a href="http://www.abbyy.com/ru-ru/mobile-capture-sdk/%3Futm_source%3Dhabr%26utm_medium%3Dpost%26utm_campaign%3D%25D0%25BF%25D0%25BE%25D0%25BD%25D0%25B8%25D0%25BC%25D0%25B0%25D0%25B5%25D0%25BC_ui">ABBYY Mobile Capture-Technologie</a> basieren <a href="http://www.abbyy.com/ru-ru/mobile-capture-sdk/%3Futm_source%3Dhabr%26utm_medium%3Dpost%26utm_campaign%3D%25D0%25BF%25D0%25BE%25D0%25BD%25D0%25B8%25D0%25BC%25D0%25B0%25D0%25B5%25D0%25BC_ui">,</a> und besteht aus mehreren Teilen.  Erstens eine Kamera zum Scannen von Dokumenten;  zweitens einen Bearbeitungsbildschirm mit den Aufnahmeergebnissen (dh automatisch aufgenommenen Fotos) und einen Bildschirm zum Korrigieren der R√§nder des Dokuments. <br><br>  Es gen√ºgt dem Entwickler, ein paar Methoden aufzurufen - und jetzt ist in seiner Anwendung bereits eine Kamera verf√ºgbar, die Dokumente automatisch scannt.  Zus√§tzlich zu den konfigurierten Kameras m√ºssen Sie den Kunden jedoch einen bequemen Zugriff auf die Scanergebnisse erm√∂glichen, d. H.  automatisch aufgenommene Fotos.  Und wenn der Kunde den Vertrag oder die Charta scannt, kann es eine Menge solcher Fotos geben. <br><br>  In diesem Beitrag werde ich auf die Schwierigkeiten eingehen, die bei der Implementierung des Editor-Bildschirms mit den Ergebnissen der Dokumentenerfassung aufgetreten sind.  Der Bildschirm selbst ist ein zwei <code>UICollectionView</code> , ich werde sie gro√ü und klein nennen.  Ich werde die M√∂glichkeiten zum manuellen Anpassen der R√§nder des Dokuments und anderer Arbeiten mit dem Dokument weglassen und mich w√§hrend des Bildlaufs auf Animationen und Layoutfunktionen konzentrieren.  Unten auf GIF k√∂nnen Sie sehen, was am Ende passiert ist.  Ein Link zum Repository befindet sich am Ende des Artikels. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/r2/xs/of/r2xsofivnhzdmlxt67ld_2atq-q.gif"></div><br><br>  Als Referenz schaue ich oft auf Apple-Systemanwendungen.  Wenn Sie Animationen und andere Schnittstellenl√∂sungen ihrer Anwendungen sorgf√§ltig betrachten, beginnen Sie, ihre aufmerksame Haltung gegen√ºber verschiedenen Kleinigkeiten zu bewundern.  Als Referenz betrachten wir nun die <i>Fotoanwendung</i> (iOS 12).  Ich werde Ihre Aufmerksamkeit auf die Besonderheiten dieser Anwendung lenken und dann versuchen, diese umzusetzen. <br><a name="habracut"></a><br>  Wir werden die meisten Anpassungsoptionen <code>UICollectionViewFlowLayout</code> , sehen, wie g√§ngige Techniken wie Parallaxe und Karussell implementiert werden, und die mit benutzerdefinierten Animationen verbundenen Probleme beim Einf√ºgen und L√∂schen von Zellen diskutieren. <br><br><h2>  Funktions√ºberpr√ºfung </h2><br>  Um Einzelheiten hinzuzuf√ºgen, beschreibe ich, welche besonderen Kleinigkeiten mir in der Anwendung " <i>Fotos"</i> gefallen haben, und setze sie dann in der entsprechenden Reihenfolge um. <br><br><ol><li>  Parallaxeffekt in einer gro√üen Sammlung </li><li>  Elemente einer kleinen Sammlung sind zentriert. </li><li>  Dynamische Gr√∂√üe von Artikeln in einer kleinen Sammlung </li><li>  Die Logik zum Platzieren der Elemente einer kleinen Zelle h√§ngt nicht nur vom contentOffset ab, sondern auch von Benutzerinteraktionen </li><li>  Benutzerdefinierte Animationen zum Verschieben und L√∂schen </li><li>  Der Index der "aktiven" Zelle geht beim Orientierungswechsel nicht verloren </li></ol><br><h3>  1. Parallaxe </h3><br>  Was ist Parallaxe? <br><blockquote>  Das Parallaxen-Scrollen ist eine Technik in der Computergrafik, bei der sich Hintergrundbilder langsamer an der Kamera vorbeibewegen als Vordergrundbilder, wodurch eine Illusion von Tiefe in einer 2D-Szene erzeugt und das Gef√ºhl des Eintauchens in die virtuelle Erfahrung verst√§rkt wird. </blockquote>  Sie k√∂nnen feststellen, dass sich der Rahmen der Zelle beim Scrollen schneller bewegt als das Bild, das sich darin befindet. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/9u/qc/7j/9uqc7jfa_e81lg-_9h6uleidmdg.gif"></div><div style="text-align:center;"><img src="https://habrastorage.org/webt/oc/jt/nv/ocjtnvvyckaotg52-tooulyfddq.png"></div><br>  Fangen wir an!  Erstellen Sie eine Unterklasse der Zelle, und f√ºgen Sie die UIImageView darin ein. <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PreviewCollectionViewCell</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UICollectionViewCell</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">set</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> imageView = <span class="hljs-type"><span class="hljs-type">UIImageView</span></span>()‚Äã <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">init</span></span>(frame: <span class="hljs-type"><span class="hljs-type">CGRect</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">init</span></span>(frame: frame) addSubview(imageView) clipsToBounds = <span class="hljs-literal"><span class="hljs-literal">true</span></span> imageView.snp.makeConstraints { $<span class="hljs-number"><span class="hljs-number">0</span></span>.edges.equalToSuperview() } } }</code> </pre><br>  Jetzt m√ºssen Sie verstehen, wie Sie die <code>imageView</code> , um einen Parallaxeeffekt zu erzielen.  Dazu m√ºssen Sie das Verhalten der Zellen w√§hrend des Bildlaufs neu definieren.  Apple: <br><blockquote>  Vermeiden Sie die Unterklasse von <code>UICollectionView</code> .  Die Sammlungsansicht hat nur ein geringes oder kein eigenes Erscheinungsbild.  Stattdessen werden alle Ansichten aus Ihrem Datenquellenobjekt und alle layoutbezogenen Informationen aus dem Layoutobjekt abgerufen.  Wenn Sie versuchen, Elemente in drei Dimensionen anzuordnen, m√ºssen Sie ein benutzerdefiniertes Layout implementieren, mit dem die 3D-Transformation f√ºr jede Zelle und Ansicht entsprechend festgelegt wird. </blockquote>  Ok, lassen Sie uns unser <b>Layout-Objekt</b> erstellen.  <code>UICollectionView</code> verf√ºgt √ºber eine Eigenschaft <code>collectionViewLayout</code> , √ºber die Informationen zur Positionierung von Zellen <code>UICollectionView</code> werden.  <code>UICollectionViewFlowLayout</code> ist eine Implementierung des abstrakten <code>UICollectionViewLayout</code> , der Eigenschaft <code>collectionViewLayout</code> . <br><blockquote>  <code>UICollectionViewLayout</code> wartet darauf, dass jemand eine Unterklasse erstellt und den entsprechenden Inhalt bereitstellt.  <code>UICollectionViewFlowLayout</code> ist eine konkrete Klasse von <code>UICollectionViewLayout</code> , in der alle vier <code>UICollectionViewLayout</code> implementiert sind, dass die Zellen in einer Rasteranordnung angeordnet werden. <br></blockquote>  Erstellen Sie eine Unterklasse von <code>UICollectionViewFlowLayout</code> und √ºberschreiben Sie deren <code>layoutAttributesForElements(in:)</code> .  Die Methode gibt ein Array von <code>UICollectionViewLayoutAttributes</code> , das Informationen zum Anzeigen einer bestimmten Zelle enth√§lt. <br><br>  Die Auflistung fordert Attribute jedes Mal an, wenn sich das <code>contentOffset</code> √§ndert, sowie wenn das Layout ung√ºltig ist.  Dar√ºber hinaus erstellen wir benutzerdefinierte Attribute, indem wir die Eigenschaft <code>parallaxValue</code> hinzuf√ºgen, mit der festgelegt wird, um wie viel das Bild gegen√ºber dem Bild der Zelle verz√∂gert wird.  F√ºr Attributunterklassen m√ºssen Sie <code>NSCopiyng</code> f√ºr sie √ºberschreiben.  Apple: <br><blockquote>  Wenn Sie benutzerdefinierte Layoutattribute in Unterklassen unterteilen und implementieren, m√ºssen Sie auch die geerbte Methode isEqual: √ºberschreiben, um die Werte Ihrer Eigenschaften zu vergleichen.  In iOS 7 und h√∂her werden in der Sammlungsansicht keine Layoutattribute angewendet, wenn diese Attribute nicht ge√§ndert wurden.  Sie ermittelt, ob sich die Attribute ge√§ndert haben, indem sie die alten und neuen Attributobjekte mit der Methode isEqual: vergleicht.  Da die Standardimplementierung dieser Methode nur die vorhandenen Eigenschaften dieser Klasse √ºberpr√ºft, m√ºssen Sie Ihre eigene Version der Methode implementieren, um zus√§tzliche Eigenschaften zu vergleichen.  Wenn Ihre benutzerdefinierten Eigenschaften alle gleich sind, rufen Sie <code>super</code> und geben Sie den resultierenden Wert am Ende Ihrer Implementierung zur√ºck. <br></blockquote>  Wie finde ich <code>parallaxValue</code> ?  Lassen Sie uns berechnen, wie viel Sie ben√∂tigen, um die Mitte der Zelle so zu verschieben, dass sie in der Mitte steht.  Wenn dieser Abstand gr√∂√üer als die Breite der Zelle ist, h√§mmern Sie darauf.  Teilen Sie andernfalls diesen Abstand durch die Breite der <b>Zelle</b> .  Je n√§her dieser Abstand an Null ist, desto schw√§cher ist der Parallaxeneffekt. <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ParallaxLayoutAttributes</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UICollectionViewLayoutAttributes</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> parallaxValue: <span class="hljs-type"><span class="hljs-type">CGFloat?</span></span> }‚Äã <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PreviewLayout</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UICollectionViewFlowLayout</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> offsetBetweenCells: <span class="hljs-type"><span class="hljs-type">CGFloat</span></span> = <span class="hljs-number"><span class="hljs-number">44</span></span>‚Äã <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">shouldInvalidateLayout</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(forBoundsChange newBounds: CGRect)</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Bool</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span> }‚Äã <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">var</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">layoutAttributesClass</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AnyClass</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-type"><span class="hljs-type">ParallaxLayoutAttributes</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">self</span></span> }‚Äã <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">layoutAttributesForElements</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">in</span></span></span></span><span class="hljs-function"><span class="hljs-params"> rect: CGRect)</span></span></span></span> -&gt; [<span class="hljs-type"><span class="hljs-type">UICollectionViewLayoutAttributes</span></span>]? { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.layoutAttributesForElements(<span class="hljs-keyword"><span class="hljs-keyword">in</span></span>: rect)? .compactMap { $<span class="hljs-number"><span class="hljs-number">0</span></span>.copy() <span class="hljs-keyword"><span class="hljs-keyword">as</span></span>? <span class="hljs-type"><span class="hljs-type">ParallaxLayoutAttributes</span></span> } .compactMap(prepareAttributes) }‚Äã <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">prepareAttributes</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(attributes: ParallaxLayoutAttributes)</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">ParallaxLayoutAttributes</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">guard</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> collectionView = <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.collectionView <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> attributes }‚Äã <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> width = itemSize.width <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> centerX = width / <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> distanceToCenter = attributes.center.x - collectionView.contentOffset.x <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> relativeDistanceToCenter = (distanceToCenter - centerX) / width‚Äã <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-built_in"><span class="hljs-built_in">abs</span></span>(relativeDistanceToCenter) &gt;= <span class="hljs-number"><span class="hljs-number">1</span></span> { attributes.parallaxValue = <span class="hljs-literal"><span class="hljs-literal">nil</span></span> attributes.transform = .identity } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { attributes.parallaxValue = relativeDistanceToCenter attributes.transform = <span class="hljs-type"><span class="hljs-type">CGAffineTransform</span></span>(translationX: relativeDistanceToCenter * offsetBetweenCells, y: <span class="hljs-number"><span class="hljs-number">0</span></span>) } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> attributes } }</code> </pre> <div style="text-align:center;"><img src="https://habrastorage.org/webt/2u/pw/f3/2upwf3rrqmsjxh-btqrm3zau7tm.png"></div><br><br><img src="https://habrastorage.org/webt/bz/x_/ol/bzx_olvusogre4usqir2uvl3uxm.png" alt="Bild"><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/fx/pi/9z/fxpi9zj22hrlkywk5ptjieqq9ma.png"></div><br>  Wenn die Auflistung die erforderlichen Attribute erh√§lt, <b>wenden</b> die Zellen sie an.  Dieses Verhalten kann in der Unterklasse der Zelle √ºberschrieben werden.  <code>imageView</code> auf den Wert in Abh√§ngigkeit von <code>parallaxValue</code> .  Damit die Verschiebung von Bildern mit <code>contentMode == .aspectFit</code> ordnungsgem√§√ü funktioniert, reicht dies jedoch nicht aus, da der Bilderrahmen nicht mit dem <code>imageView</code> Rahmen √ºbereinstimmt, um den der Inhalt beschnitten wird, wenn <code>clipsToBounds == true</code> .  Setzen Sie eine Maske, die der Gr√∂√üe des Bildes entspricht, mit dem entsprechenden <code>contentMode</code> und wir werden es bei Bedarf aktualisieren.  Jetzt funktioniert alles! <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extension</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PreviewCollectionViewCell</span></span></span><span class="hljs-class"> </span></span>{‚Äã <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">layoutSubviews</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> {‚Äã <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.layoutSubviews() <span class="hljs-keyword"><span class="hljs-keyword">guard</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> imageSize = imageView.image?.size <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> imageRect = <span class="hljs-type"><span class="hljs-type">AVMakeRect</span></span>(aspectRatio: imageSize, insideRect: bounds)‚Äã <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> path = <span class="hljs-type"><span class="hljs-type">UIBezierPath</span></span>(rect: imageRect) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> shapeLayer = <span class="hljs-type"><span class="hljs-type">CAShapeLayer</span></span>() shapeLayer.path = path.cgPath layer.mask = shapeLayer } <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">apply</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">_</span></span></span></span><span class="hljs-function"><span class="hljs-params"> layoutAttributes: UICollectionViewLayoutAttributes)</span></span></span></span> {‚Äã <span class="hljs-keyword"><span class="hljs-keyword">guard</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> attrs = layoutAttributes <span class="hljs-keyword"><span class="hljs-keyword">as</span></span>? <span class="hljs-type"><span class="hljs-type">ParallaxLayoutAttributes</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.apply(layoutAttributes) } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> parallaxValue = attrs.parallaxValue ?? <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> transition = -(bounds.width * <span class="hljs-number"><span class="hljs-number">0.3</span></span> * parallaxValue) imageView.transform = <span class="hljs-type"><span class="hljs-type">CGAffineTransform</span></span>(translationX: transition, y: .zero) } }</code> </pre> <div style="text-align:center;"><img src="https://habrastorage.org/webt/j_/9e/-h/j_9e-hdvix9nueitnhf0elsk80o.png"></div><br><br><h3>  2. Elemente einer kleinen Sammlung sind zentriert </h3><br><img src="https://habrastorage.org/getpro/habr/post_images/6cc/d9e/a78/6ccd9ea78faa45a085233d593c6feddb.gif"><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/c9/ld/ra/c9ldral4qoinyvhoacyfveqbwtm.png"></div><br>  Hier ist alles sehr einfach.  Dieser Effekt kann erzielt werden, indem links und rechts gro√üe <code>inset</code> .  Wenn Sie nach rechts / links scrollen, m√ºssen Sie erst dann mit dem <code>bouncing</code> beginnen <code>bouncing</code> wenn die letzte Zelle den sichtbaren Inhalt verlassen hat.  Das hei√üt, der sichtbare Inhalt sollte der Gr√∂√üe der Zelle entsprechen. <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extension</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ThumbnailFlowLayout</span></span></span><span class="hljs-class"> </span></span>{‚Äã <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> farInset: <span class="hljs-type"><span class="hljs-type">CGFloat</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">guard</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> collection = collectionView <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> .zero } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (collection.bounds.width - itemSize.width) / <span class="hljs-number"><span class="hljs-number">2</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> insets: <span class="hljs-type"><span class="hljs-type">UIEdgeInsets</span></span> { <span class="hljs-type"><span class="hljs-type">UIEdgeInsets</span></span>(top: .zero, <span class="hljs-keyword"><span class="hljs-keyword">left</span></span>: farInset, bottom: .zero, <span class="hljs-keyword"><span class="hljs-keyword">right</span></span>: farInset) }‚Äã <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">prepare</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { collectionView?.contentInset = insets <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.prepare() } }</code> </pre> <div style="text-align:center;"><img src="https://habrastorage.org/webt/vv/me/ty/vvmetyazz7-6mzze8-7knxoasxw.png"></div><br><br><img src="https://habrastorage.org/webt/hr/qa/k6/hrqak6wkoeqsf7nvy8bky_tauym.jpeg" alt="Bild"><div style="text-align:center;"><img src="https://habrastorage.org/webt/he/pk/br/hepkbrq20vpteyatek3hv8pi8mg.png"></div><br><br>  Weitere <code>contentOffset</code> zum Zentrieren: Wenn die Sammlung den Bildlauf abgeschlossen hat, fordert das Layout ein <code>contentOffset</code> an, bei dem <code>contentOffset</code> soll.  √úberschreiben Sie dazu <code>targetContentOffset(forProposedContentOffset:withScrollingVelocity:)</code> .  Apple: <br><blockquote>  Wenn Sie m√∂chten, dass das Bildlaufverhalten an bestimmten Grenzen ausgerichtet wird, k√∂nnen Sie diese Methode √ºberschreiben und den Punkt √§ndern, an dem der Bildlauf angehalten werden soll.  Sie k√∂nnen diese Methode beispielsweise verwenden, um den Bildlauf an einer Grenze zwischen Elementen immer anzuhalten, anstatt in der Mitte eines Elements anzuhalten. <br></blockquote>  Um alles sch√∂n zu machen, halten wir <b>immer</b> in der Mitte der n√§chsten Zelle.  Das Berechnen des Mittelpunkts der n√§chsten Zelle ist eine eher triviale Aufgabe, aber Sie m√ºssen vorsichtig sein und das <code>contentInset</code> . <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">targetContentOffset</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(forProposedContentOffset proposedContentOffset: CGPoint, withScrollingVelocity velocity: CGPoint)</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">CGPoint</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">guard</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> collection = collectionView <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.targetContentOffset(forProposedContentOffset: proposedContentOffset, withScrollingVelocity: velocity) } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> cellWithSpacing = itemSize.width + config.distanceBetween <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> relative = (proposedContentOffset.x + collection.contentInset.<span class="hljs-keyword"><span class="hljs-keyword">left</span></span>) / cellWithSpacing <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> leftIndex = <span class="hljs-built_in"><span class="hljs-built_in">max</span></span>(<span class="hljs-number"><span class="hljs-number">0</span></span>, floor(relative)) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> rightIndex = <span class="hljs-built_in"><span class="hljs-built_in">min</span></span>(ceil(relative), <span class="hljs-type"><span class="hljs-type">CGFloat</span></span>(itemsCount)) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> leftCenter = leftIndex * cellWithSpacing - collection.contentInset.<span class="hljs-keyword"><span class="hljs-keyword">left</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> rightCenter = rightIndex * cellWithSpacing - collection.contentInset.<span class="hljs-keyword"><span class="hljs-keyword">left</span></span>‚Äã <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-built_in"><span class="hljs-built_in">abs</span></span>(leftCenter - proposedContentOffset.x) &lt; <span class="hljs-built_in"><span class="hljs-built_in">abs</span></span>(rightCenter - proposedContentOffset.x) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-type"><span class="hljs-type">CGPoint</span></span>(x: leftCenter, y: proposedContentOffset.y) } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-type"><span class="hljs-type">CGPoint</span></span>(x: rightCenter, y: proposedContentOffset.y) } }</code> </pre> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/n4/dj/ed/n4djedqhgual-kqq4o3vg-mjxay.gif"></div><div style="text-align:center;"><img src="https://habrastorage.org/webt/0x/bj/xn/0xbjxn8vk5gxiuwvjvjklvhfusa.png"></div><br><br><h3>  3. Die dynamische Gr√∂√üe der Elemente einer kleinen Sammlung </h3><br>  Wenn Sie durch eine gro√üe Sammlung <code>contentOffset</code> √§ndert sich das <code>contentOffset</code> f√ºr eine kleine.  Dar√ºber hinaus ist die zentrale Zelle einer kleinen Sammlung nicht so gro√ü wie die anderen.  Seitenzellen haben eine feste Gr√∂√üe und die mittlere f√§llt mit dem Seitenverh√§ltnis des enthaltenen Bildes zusammen. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/6e3/c61/03e/6e3c6103e3602c9a3cbf0b7553a05386.gif"><div style="text-align:center;"><img src="https://habrastorage.org/webt/hw/8q/ma/hw8qma82pik2sus_ul5rbvu8rbm.png"></div><br>  Sie k√∂nnen die gleiche Technik wie bei der Parallaxe anwenden.  Erstellen wir ein benutzerdefiniertes <code>UICollectionViewFlowLayout</code> f√ºr eine kleine Sammlung und definieren <code>prepareAttributes(attributes:</code> neu <code>prepareAttributes(attributes:</code> Da die <code>prepareAttributes(attributes:</code> der kleinen Sammlung weiterhin kompliziert ist, erstellen wir eine separate Entit√§t zum Speichern und Berechnen der Zellgeometrie. <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Cell</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> indexPath: <span class="hljs-type"><span class="hljs-type">IndexPath</span></span>‚Äã <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> dims: <span class="hljs-type"><span class="hljs-type">Dimensions</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> state: <span class="hljs-type"><span class="hljs-type">State</span></span>‚Äã <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">updated</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(new state: State)</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Cell</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-type"><span class="hljs-type">Cell</span></span>(indexPath: indexPath, dims: dims, state: state) } }‚Äã <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extension</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Cell</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Dimensions</span></span></span><span class="hljs-class"> </span></span>{‚Äã <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> defaultSize: <span class="hljs-type"><span class="hljs-type">CGSize</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> aspectRatio: <span class="hljs-type"><span class="hljs-type">CGFloat</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> inset: <span class="hljs-type"><span class="hljs-type">CGFloat</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> insetAsExpanded: <span class="hljs-type"><span class="hljs-type">CGFloat</span></span> }‚Äã <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">State</span></span></span><span class="hljs-class"> </span></span>{‚Äã <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> expanding: <span class="hljs-type"><span class="hljs-type">CGFloat</span></span>‚Äã <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> `<span class="hljs-keyword"><span class="hljs-keyword">default</span></span>`: <span class="hljs-type"><span class="hljs-type">State</span></span> { <span class="hljs-type"><span class="hljs-type">State</span></span>(expanding: .zero) } } }</code> </pre> <div style="text-align:center;"><img src="https://habrastorage.org/webt/0c/ma/im/0cmaim03nqx9dpkohrfumymr11a.png"></div><br>  <code>UICollectionViewFlowLayout</code> verf√ºgt √ºber eine <code>collectionViewContentSize</code> Eigenschaft, die die Gr√∂√üe des Bereichs bestimmt, in dem ein <code>UICollectionViewFlowLayout</code> kann.  Um unser Leben nicht zu verkomplizieren, lassen wir es konstant, unabh√§ngig von der Gr√∂√üe der zentralen Zelle.  F√ºr die richtige Geometrie f√ºr jede Zelle m√ºssen Sie das <code>aspectRatio</code> Bildes und die Entfernung der Mitte der Zelle von <code>contentOffset</code> .  Je n√§her die Zelle ist, <code>size.width / size.height</code> n√§her ist ihre <code>size.width / size.height</code> am <code>aspectRatio</code> .  Verschieben Sie beim <code>affineTransform</code> einer bestimmten Zelle die verbleibenden Zellen (rechts und links davon) mit <code>affineTransform</code> .  Es stellt sich heraus, dass Sie zum Berechnen der Geometrie einer bestimmten Zelle die Attribute der Nachbarn (sichtbar) kennen m√ºssen. <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extension</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Cell</span></span></span><span class="hljs-class"> </span></span>{‚Äã <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">attributes</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(from layout: ThumbnailLayout, with sideCells: [Cell])</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">UICollectionViewLayoutAttributes?</span></span> {‚Äã <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> attributes = layout.layoutAttributesForItem(at: indexPath)‚Äã attributes?.size = size attributes?.center = center‚Äã <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> translate = sideCells.<span class="hljs-built_in"><span class="hljs-built_in">reduce</span></span>(<span class="hljs-number"><span class="hljs-number">0</span></span>) { (current, cell) -&gt; <span class="hljs-type"><span class="hljs-type">CGFloat</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> indexPath &lt; cell.indexPath { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> current - cell.additionalWidth / <span class="hljs-number"><span class="hljs-number">2</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> indexPath &gt; cell.indexPath { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> current + cell.additionalWidth / <span class="hljs-number"><span class="hljs-number">2</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> current } attributes?.transform = <span class="hljs-type"><span class="hljs-type">CGAffineTransform</span></span>(translationX: translate, y: .zero)‚Äã <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> attributes } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> additionalWidth: <span class="hljs-type"><span class="hljs-type">CGFloat</span></span> { (dims.defaultSize.height * dims.aspectRatio - dims.defaultSize.width) * state.expanding } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> size: <span class="hljs-type"><span class="hljs-type">CGSize</span></span> { <span class="hljs-type"><span class="hljs-type">CGSize</span></span>(width: dims.defaultSize.width + additionalWidth, height: dims.defaultSize.height) } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> center: <span class="hljs-type"><span class="hljs-type">CGPoint</span></span> { <span class="hljs-type"><span class="hljs-type">CGPoint</span></span>(x: <span class="hljs-type"><span class="hljs-type">CGFloat</span></span>(indexPath.row) * (dims.defaultSize.width + dims.inset) + dims.defaultSize.width / <span class="hljs-number"><span class="hljs-number">2</span></span>, y: dims.defaultSize.height / <span class="hljs-number"><span class="hljs-number">2</span></span>) } }</code> </pre> <br>  <code>state.expanding</code> wird als fast gleichbedeutend mit <code>parallaxValue</code> . <br><br><pre> <code class="swift hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cell</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">for</span></span></span></span><span class="hljs-function"><span class="hljs-params"> index: IndexPath, offsetX: CGFloat)</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Cell</span></span> {‚Äã <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> cell = <span class="hljs-type"><span class="hljs-type">Cell</span></span>( indexPath: index, dims: <span class="hljs-type"><span class="hljs-type">Cell</span></span>.<span class="hljs-type"><span class="hljs-type">Dimensions</span></span>( defaultSize: itemSize, aspectRatio: dataSource(index.row), inset: config.distanceBetween, insetAsExpanded: config.distanceBetweenFocused), state: .<span class="hljs-keyword"><span class="hljs-keyword">default</span></span>)‚Äã <span class="hljs-keyword"><span class="hljs-keyword">guard</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> attribute = cell.attributes(from: <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, with: []) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> cell }‚Äã <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> cellOffset = attribute.center.x - itemSize.width / <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> widthWithOffset = itemSize.width + config.distanceBetween <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-built_in"><span class="hljs-built_in">abs</span></span>(cellOffset - offsetX) &lt; widthWithOffset { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> expanding = <span class="hljs-number"><span class="hljs-number">1</span></span> - <span class="hljs-built_in"><span class="hljs-built_in">abs</span></span>(cellOffset - offsetX) / widthWithOffset <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> cell.updated(by: .expand(expanding)) } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> cell }‚Äã <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">layoutAttributesForElements</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">in</span></span></span></span><span class="hljs-function"><span class="hljs-params"> rect: CGRect)</span></span></span></span> -&gt; [<span class="hljs-type"><span class="hljs-type">UICollectionViewLayoutAttributes</span></span>]? { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (<span class="hljs-number"><span class="hljs-number">0</span></span> ..&lt; itemsCount) .<span class="hljs-built_in"><span class="hljs-built_in">map</span></span> { <span class="hljs-type"><span class="hljs-type">IndexPath</span></span>(row: $<span class="hljs-number"><span class="hljs-number">0</span></span>, section: <span class="hljs-number"><span class="hljs-number">0</span></span>) } .<span class="hljs-built_in"><span class="hljs-built_in">map</span></span> { cell(<span class="hljs-keyword"><span class="hljs-keyword">for</span></span>: $<span class="hljs-number"><span class="hljs-number">0</span></span>, offsetX: offsetWithoutInsets.x) } .compactMap { $<span class="hljs-number"><span class="hljs-number">0</span></span>.attributes(from: <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, with: cells) } }</code> </pre> <br><br><h3>  4. Die Logik zum Platzieren der Elemente einer kleinen Zelle h√§ngt nicht nur vom contentOffset ab, sondern auch von Benutzerinteraktionen </h3><br>  Wenn ein Benutzer einen Bildlauf durch eine kleine Sammlung durchf√ºhrt, haben alle Zellen dieselbe Gr√∂√üe.  Beim Scrollen einer gro√üen Sammlung ist dies nicht der Fall.  ( <i>siehe GIFs 3 und 5</i> ).  Schreiben wir einen Animator, der die Eigenschaften des <code>ThumbnailLayout</code> Layouts aktualisiert.  Der Animator speichert <code>DisplayLink</code> in sich selbst und ruft den Block 60 Mal pro Sekunde auf, um Zugriff auf den aktuellen Fortschritt zu erhalten.  Es ist einfach, verschiedene <code>easing functions</code> am Animator zu <code>easing functions</code> .  Die Implementierung kann auf dem Github unter dem Link am Ende des Beitrags eingesehen werden. <br><br>  Geben Sie die Eigenschaft <code>ThumbnailLayout</code> in <code>ThumbnailLayout</code> , mit der die <code>expanding</code> aller <code>Cell</code> multipliziert wird.  Es stellt sich heraus, dass die <code>expandingRate</code> <code>aspectRatio</code> , wie stark sich das <code>aspectRatio</code> bestimmten Bildes auf dessen Gr√∂√üe auswirkt, wenn es zentriert wird.  Mit <code>expandingRate == 0</code> alle Zellen dieselbe Gr√∂√üe.  Am Anfang des Bildlaufs einer kleinen Sammlung wird ein Animator ausgef√ºhrt, der die <code>expandingRate</code> auf 0 und am Ende des Bildlaufs umgekehrt auf 1 setzt. Tats√§chlich √§ndern sich beim Aktualisieren des Layouts die Gr√∂√üe der zentralen Zelle und der Seitenzellen.  Kein <code>contentOffset</code> mit <code>contentOffset</code> und <code>contentOffset</code> ! <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ScrollAnimation</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NSObject</span></span></span><span class="hljs-class"> </span></span>{‚Äã <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">enum</span></span></span><span class="hljs-class"> `</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Type</span></span></span><span class="hljs-class">` </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> begin <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> end }‚Äã <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> type: <span class="hljs-type"><span class="hljs-type">Type</span></span>‚Äã <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">run</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(completion: @escaping </span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"><span class="hljs-params">()</span></span></span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Void</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> toValue: <span class="hljs-type"><span class="hljs-type">CGFloat</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.type == .begin ? <span class="hljs-number"><span class="hljs-number">0</span></span> : <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> currentExpanding = thumbnails.config.expandingRate <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> duration = <span class="hljs-type"><span class="hljs-type">TimeInterval</span></span>(<span class="hljs-number"><span class="hljs-number">0.15</span></span> * <span class="hljs-built_in"><span class="hljs-built_in">abs</span></span>(currentExpanding - toValue))‚Äã <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> animator = <span class="hljs-type"><span class="hljs-type">Animator</span></span>(onProgress: { current, <span class="hljs-number"><span class="hljs-number">_</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> rate = currentExpanding + (toValue - currentExpanding) * current <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.thumbnails.config.expandingRate = rate <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.thumbnails.invalidateLayout() }, easing: .easeInOut)‚Äã animator.animate(duration: duration) { <span class="hljs-number"><span class="hljs-number">_</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> completion() } } }</code> </pre> <div style="text-align:center;"><img src="https://habrastorage.org/webt/sy/sz/ff/syszffr_19xmccnvyw-do9lcqhy.png"></div><br><br><pre> <code class="swift hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">scrollViewWillBeginDragging</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">_</span></span></span></span><span class="hljs-function"><span class="hljs-params"> scrollView: UIScrollView)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> scrollView == thumbnails.collectionView { handle(event: .beginScrolling) <span class="hljs-comment"><span class="hljs-comment">// call ScrollAnimation.run(type: .begin) } }‚Äã func scrollViewDidEndDragging(_ scrollView: UIScrollView, willDecelerate decelerate: Bool) { if scrollView == thumbnails.collectionView &amp;&amp; !decelerate { thumbnailEndScrolling() } }‚Äã func scrollViewDidEndDecelerating(_ scrollView: UIScrollView) { if scrollView == thumbnails.collectionView { thumbnailEndScrolling() } }‚Äã func thumbnailEndScrolling() { handle(event: .endScrolling) // call ScrollAnimation.run(type: .end) }</span></span></code> </pre> <div style="text-align:center;"><img src="https://habrastorage.org/webt/nu/v0/x7/nuv0x7phez1lg2osumphtri1wao.png"></div><br><br><h3>  5. Benutzerdefinierte Animationen zum Verschieben und L√∂schen </h3><br>  Es gibt viele Artikel, in denen beschrieben wird, wie benutzerdefinierte Animationen zum Aktualisieren von Zellen erstellt werden. In unserem Fall helfen sie uns jedoch nicht.  In Artikeln und Lernprogrammen wird beschrieben, wie die Attribute einer aktualisierten Zelle √ºberschrieben werden.  In unserem Fall verursacht das √Ñndern des Layouts der gel√∂schten Zelle Nebenwirkungen - die <code>expanding</code> benachbarten Zelle, die w√§hrend der Animation tendenziell die Stelle der gel√∂schten Zelle einnimmt, √§ndert sich. <br><br>  Das Aktualisieren von Inhalten in einem <code>UICollectionViewFlowLayout</code> funktioniert wie folgt.  Nach dem L√∂schen / Hinzuf√ºgen einer Zelle wird die Methode <code>prepare(forCollectionViewUpdates:)</code> . Sie gibt ein Array mit <code>UICollectionViewUpdateItem</code> , das <code>UICollectionViewUpdateItem</code> , welche Zellen an welchen Indizes aktualisiert / gel√∂scht / hinzugef√ºgt wurden.  Als n√§chstes ruft das Layout eine Gruppe von Methoden auf <br><br><pre> <code class="swift hljs">finalLayoutAttributesForDisappearingItem(at:) initialLayoutAttributesForAppearingDecorationElement(ofKind:at:)</code> </pre> <br>  und ihre Freunde f√ºr Dekoration / erg√§nzende Ansichten.  Wenn die Attribute f√ºr die aktualisierten Daten empfangen werden, wird <code>finalizeCollectionViewUpdates</code> aufgerufen.  Apple: <br><blockquote>  Die Sammlungsansicht ruft diese Methode als letzten Schritt auf, bevor √Ñnderungen an der Position animiert werden.  Diese Methode wird innerhalb des Animationsblocks aufgerufen, der zum Ausf√ºhren aller Einf√ºge-, L√∂sch- und Verschiebungsanimationen verwendet wird, sodass Sie bei Bedarf mit dieser Methode zus√§tzliche Animationen erstellen k√∂nnen.  Andernfalls k√∂nnen Sie damit Last-Minute-Aufgaben ausf√ºhren, die mit der Verwaltung der Statusinformationen Ihres Layoutobjekts verbunden sind. <br></blockquote>  Das Problem ist, dass wir Attribute nur f√ºr die <b>aktualisierte</b> Zelle spezialisieren k√∂nnen und sie f√ºr alle Zellen auf unterschiedliche Weise √§ndern m√ºssen.  Die neue mittlere Zelle sollte <code>aspectRatio</code> √§ndern, und die seitlichen Zellen sollten <code>transform</code> . <br><br><img src="https://habrastorage.org/getpro/habr/post_images/223/6ad/9e0/2236ad9e0cff5fac58a4b490570340c4.gif"><div style="text-align:center;"><img src="https://habrastorage.org/webt/1b/wa/pf/1bwapfugwecsrwjnnw3imlnviyk.png"></div><br>  Nachdem untersucht wurde, wie die Standardanimation von Auflistungszellen beim L√∂schen / Einf√ºgen funktioniert, wurde bekannt, dass die <code>CABasicAnimation</code> in den <code>CABasicAnimation</code> enthalten, das dort ge√§ndert werden kann, wenn Sie die Animation f√ºr die verbleibenden Zellen anpassen m√∂chten.  Es wurde noch schlimmer, als die Protokolle zeigten, dass zwischen <code>performBatchUpdates</code> und <code>prepare(forCollectionViewUpdates:)</code> <code>prepareAttributes(attributes:)</code> <code>prepare(forCollectionViewUpdates:)</code> ein Aufruf erfolgt und m√∂glicherweise bereits die falsche Anzahl von Zellen vorhanden ist, obwohl <code>collectionViewUpdates</code> noch nicht gestartet wurden, ist es sehr schwierig, dies zu verwalten und zu verstehen.  Was kann man dagegen tun?  Sie k√∂nnen diese eingebauten Animationen deaktivieren! <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">prepare</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(forCollectionViewUpdates updateItems: [UICollectionViewUpdateItem])</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.prepare(forCollectionViewUpdates: updateItems) <span class="hljs-type"><span class="hljs-type">CATransaction</span></span>.begin() <span class="hljs-type"><span class="hljs-type">CATransaction</span></span>.setDisableActions(<span class="hljs-literal"><span class="hljs-literal">true</span></span>) }‚Äã <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">finalizeCollectionViewUpdates</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-type"><span class="hljs-type">CATransaction</span></span>.commit() }</code> </pre><div style="text-align:center;"><img src="https://habrastorage.org/webt/69/ja/x4/69jax4yhfpsjyr5jej-xxpb6pkc.png"></div><br>  Bewaffnet mit den bereits geschriebenen Animatoren f√ºhren wir alle erforderlichen Animationen auf Anforderung zum L√∂schen durch und starten das <code>dataSource</code> Update am Ende der Animation.  Auf diese Weise vereinfachen wir die Animation der Sammlung beim Aktualisieren, da wir selbst steuern, wann sich die Anzahl der Zellen √§ndert. <br><br><pre> <code class="swift hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">delete</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( at indexPath: IndexPath, dataSourceUpdate: @escaping </span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"><span class="hljs-params">()</span></span></span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Void</span></span>, completion: (() -&gt; <span class="hljs-type"><span class="hljs-type">Void</span></span>)?) {‚Äã <span class="hljs-type"><span class="hljs-type">DeleteAnimation</span></span>(thumbnails: thumbnails, preview: preview, index: indexPath).run { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> previousCount = <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.thumbnails.itemsCount <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> previousCount == indexPath.row + <span class="hljs-number"><span class="hljs-number">1</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.activeIndex = previousCount - <span class="hljs-number"><span class="hljs-number">1</span></span> } dataSourceUpdate() <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.thumbnails.collectionView?.deleteItems(at: [indexPath]) <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.preview.collectionView?.deleteItems(at: [indexPath]) completion?() } }</code> </pre> <br>  Wie funktionieren solche Animationen?  Speichern Sie in <code>ThumbnailLayout</code> optionale Brosch√ºren, mit denen die Geometrie bestimmter Zellen aktualisiert wird. <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ThumbnailLayout</span></span></span><span class="hljs-class"> </span></span>{‚Äã <span class="hljs-keyword"><span class="hljs-keyword">typealias</span></span> <span class="hljs-type"><span class="hljs-type">CellUpdate</span></span> = (<span class="hljs-type"><span class="hljs-type">Cell</span></span>) -&gt; <span class="hljs-type"><span class="hljs-type">Cell</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> updates: [<span class="hljs-type"><span class="hljs-type">IndexPath</span></span>: <span class="hljs-type"><span class="hljs-type">CellUpdate</span></span>] = [:] <span class="hljs-comment"><span class="hljs-comment">// ... override func layoutAttributesForElements(in rect: CGRect) -&gt; [UICollectionViewLayoutAttributes]? {‚Äã let cells = (0 ..&lt; itemsCount) .map { IndexPath(row: $0, section: 0) } .map { cell(for: $0, offsetX: offsetWithoutInsets.x) } .map { cell -&gt; Cell in if let update = self.config.updates[cell.indexPath] { return update(cell) } return cell } return cells.compactMap { $0.attributes(from: self, with: cells) } }</span></span></code> </pre> <br>  Mit einem solchen Werkzeug k√∂nnen Sie alles mit der Geometrie der Zellen machen, w√§hrend der Arbeit des Animators Aktualisierungen ausgeben und diese im Kompliment entfernen.  Es besteht auch die M√∂glichkeit, Updates zu kombinieren. <br><br><pre> <code class="swift hljs">updates[index] = newUpdate(updates[index])</code> </pre><br>  Der <i>L√∂schanimationscode</i> ist ziemlich umst√§ndlich und befindet sich in der Datei <i>DeleteAnimation.swift</i> im Repository.  Die Animation der Fokusumschaltung zwischen Zellen wird auf die gleiche Weise implementiert. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/001/d8d/ca0/001d8dca06df6b68773652760a019bf3.gif"><div style="text-align:center;"><img src="https://habrastorage.org/webt/mi/6q/bs/mi6qbskcng_u5ehyixy1q0xp_ce.png"></div><br><br><h3>  6. Der Index der ‚Äûaktiven‚Äú Zelle geht beim √Ñndern der Ausrichtung nicht verloren </h3><br>  <code>scrollViewDidScroll(_ scrollView:)</code> wird aufgerufen, auch wenn Sie einfach einen Wert in <code>contentOffset</code> und die Ausrichtung √§ndern.  Wenn der Bildlauf zweier Sammlungen synchronisiert wird, k√∂nnen bei der Aktualisierung des Layouts einige Probleme auftreten.  Der folgende Trick hilft: Bei Layout-Aktualisierungen k√∂nnen Sie <code>scrollView.delegate</code> auf <code>nil</code> . <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extension</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ScrollSynchronizer</span></span></span><span class="hljs-class"> </span></span>{‚Äã <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bind</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { preview.collectionView?.delegate = <span class="hljs-keyword"><span class="hljs-keyword">self</span></span> thumbnails.collectionView?.delegate = <span class="hljs-keyword"><span class="hljs-keyword">self</span></span> }‚Äã <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">unbind</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { preview.collectionView?.delegate = <span class="hljs-literal"><span class="hljs-literal">nil</span></span> thumbnails.collectionView?.delegate = <span class="hljs-literal"><span class="hljs-literal">nil</span></span> } }</code> </pre> <br>  Wenn Sie die Zellengr√∂√üe zum Zeitpunkt der √Ñnderung der Ausrichtung aktualisieren, sieht dies folgenderma√üen aus: <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extension</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PhotosViewController</span></span></span><span class="hljs-class"> </span></span>{‚Äã <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">viewWillTransition</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(to size: CGSize, with coordinator: UIViewControllerTransitionCoordinator)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.viewWillTransition(to: size, with: coordinator)‚Äã contentView.synchronizer.unbind() coordinator.animate(alongsideTransition: <span class="hljs-literal"><span class="hljs-literal">nil</span></span>) { [<span class="hljs-keyword"><span class="hljs-keyword">weak</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>] <span class="hljs-number"><span class="hljs-number">_</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>?.contentView.synchronizer.bind() } } }</code> </pre> <br>  Um den gew√ºnschten <code>contentOffset</code> beim √Ñndern der Ausrichtung nicht zu verlieren, k√∂nnen Sie <code>scrollView.delegate</code> in <code>scrollView.delegate</code> .  Wenn Sie die Ausrichtung √§ndern, wird das Layout deaktiviert, wenn Sie <code>shouldInvalidateLayout(forBoundsChange:)</code> .  Wenn Sie <code>bounds</code> √§ndern <code>bounds</code> Layout aufgefordert, <code>contentOffset</code> zu <code>targetContentOffset(forProposedContentOffset:)</code> . <code>targetContentOffset(forProposedContentOffset:)</code> , m√ºssen Sie <code>targetContentOffset(forProposedContentOffset:)</code> neu <code>targetContentOffset(forProposedContentOffset:)</code> .  Apple: <br><blockquote>  W√§hrend Layoutaktualisierungen oder beim √úbergang zwischen Layouts ruft die Sammlungsansicht diese Methode auf, um Ihnen die M√∂glichkeit zu geben, den vorgeschlagenen Inhaltsoffset zu √§ndern, der am Ende der Animation verwendet wird.  Sie k√∂nnen diese Methode √ºberschreiben, wenn die Animationen oder √úberg√§nge dazu f√ºhren, dass Elemente auf eine Weise positioniert werden, die f√ºr Ihr Design nicht optimal ist. <br><br>  Die Auflistungsansicht ruft diese Methode auf, nachdem die Methoden <code>prepare()</code> und <code>collectionViewContentSize</code> aufgerufen wurden. </blockquote><br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">targetContentOffset</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(forProposedContentOffset proposedContentOffset: CGPoint)</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">CGPoint</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> targetOffset = <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.targetContentOffset(forProposedContentOffset: proposedContentOffset) <span class="hljs-keyword"><span class="hljs-keyword">guard</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> layoutHandler = layoutHandler <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> targetOffset } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> offset = <span class="hljs-type"><span class="hljs-type">CGFloat</span></span>(layoutHandler.targetIndex) / <span class="hljs-type"><span class="hljs-type">CGFloat</span></span>(itemsCount) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-type"><span class="hljs-type">CGPoint</span></span>( x: collectionViewContentSize.width * offset - farInset, y: targetOffset.y) }</code> </pre> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/i5/5r/sf/i55rsfdujvblk7om3yq2yerabhu.gif"></div><div style="text-align:center;"><img src="https://habrastorage.org/webt/ng/ls/6w/ngls6wjfkhkajrg3706i_g11lyo.png"></div><br><hr><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Danke f√ºrs Lesen! </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Alle Codes finden Sie unter </font></font><a href="https://github.com/YetAnotherRzmn/PhotosApp"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">github.com/YetAnotherRzmn/PhotosApp</font></font></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de477734/">https://habr.com/ru/post/de477734/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de477722/index.html">Google Style Guide in C ++. Teil 8</a></li>
<li><a href="../de477724/index.html">HR-Marken-Habraseminar: √úber Talente, Jagd und Inhalte</a></li>
<li><a href="../de477728/index.html">Was zu tun ist Teamf√ºhrung, damit das Team nicht ausbrennt</a></li>
<li><a href="../de477730/index.html">ChipWhisperer: Energieangriff auf Magma</a></li>
<li><a href="../de477732/index.html">Falsche Fingerklassifizierung von Unterwassernavigationssystemen</a></li>
<li><a href="../de477736/index.html">Der Weg des Testers: von der ‚ÄûHandbremse‚Äú bis zur Automatisierung</a></li>
<li><a href="../de477738/index.html">iKassa oder wie wir die "digitale Kasse" gez√§hmt haben</a></li>
<li><a href="../de477740/index.html">Und wo kann man mit dem Auge in dieses Teleskop schauen?</a></li>
<li><a href="../de477742/index.html">"Hallo Checkmarx!" Wie schreibe ich eine Anfrage f√ºr Checkmarx SAST und finde coole Schwachstellen</a></li>
<li><a href="../de477746/index.html">Monetarisierungsdesigner: Wer er ist und wie man einer wird</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>