<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏿‍🚀 🕹️ 🙅 Currying und Teilanwendung in C ++ 14 🧗🏿 🛷 🌚</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In diesem Artikel werde ich Ihnen eine der Curry-Optionen und die teilweise Anwendung der Funktionen in C ++ erläutern, die mein persönlicher Favorit ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Currying und Teilanwendung in C ++ 14</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/436488/"><p>  In diesem Artikel werde ich Ihnen eine der Curry-Optionen und die teilweise Anwendung der Funktionen in C ++ erläutern, die mein persönlicher Favorit ist.  Ich werde auch meine eigene Pilotimplementierung dieser Sache zeigen und den Punkt des Curryens ohne komplexe mathematische Formel erklären, was es für Sie wirklich einfach macht.  Wir werden auch sehen, was sich unter der Haube der <a href="" title="kari.hpp">kari.hpp-</a> Bibliothek befindet, die wir für Curry-Funktionen verwenden werden.  Wie auch immer, es gibt viele faszinierende Dinge im Inneren, also willkommen! </p><a name="habracut"></a><br><h2 id="currying">  Currying </h2><br><p>  Also, was ist Curry?  Ich denke, es ist eines dieser Wörter, die Sie ständig von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" title="Haskell">Haskell-</a> Programmierern hören (natürlich nach der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" title="Monade">Monade</a> ).  Im Wesentlichen ist die Definition des Begriffs ziemlich einfach, sodass diejenigen Leser, die bereits über <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" title="ML">ML-</a> Sprachen oder <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" title="Haskell">Haskell geschrieben</a> haben oder von anderswo wissen, was dies bedeutet, diesen Abschnitt gerne überspringen können. </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" title="Currying">Currying</a> - ist die Technik zum Transformieren einer Funktion, die N Argumente in eine Funktion umwandelt, die ein einzelnes Argument verwendet und die Funktion des nächsten Arguments zurückgibt. Sie wird fortgesetzt und eins, bis die Funktion des letzten Arguments zurückgegeben wird, die dargestellt werden soll das Gesamtergebnis.  Ich denke, es hilft, wenn ich Ihnen Beispiele zeige: </p><br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sum2</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> lhs, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> rhs)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> lhs + rhs; }</code> </pre> <br><p>  Hier haben wir eine binäre Additionsfunktion.  Und was ist, wenn wir daraus eine einzelne Variablenfunktion machen wollen?  Es ist eigentlich sehr einfach: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">auto</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">curried_sum2</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> lhs)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [=](<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> rhs) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> sum2(lhs, rhs); }; }</code> </pre> <br><p>  Nein, was haben wir gemacht?  Wir haben einen Wert basierend auf einem einzelnen Argument namens Lambda verwendet, das wiederum das zweite Argument verwendet und die Addition selbst ausführt.  Infolgedessen können wir die Curry-Funktion <strong><code>curried_sum2</code></strong> auf unsere Argumente anwenden: </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// output: 42 std::cout &lt;&lt; sum2(40, 2) &lt;&lt; std::endl; std::cout &lt;&lt; curried_sum2(40)(2) &lt;&lt; std::endl;</span></span></code> </pre> <br><p>  Und das ist eigentlich der springende Punkt beim Curry-Betrieb.  Natürlich ist es möglich, dies mit Funktionen jeder Art zu tun - es wird absolut genauso funktionieren.  Wir werden jedes Mal eine Curry-Funktion von N-1-Argumenten zurückgeben, wenn wir den Wert von einem anderen Argument übernehmen: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">auto</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sum3</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> v1, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> v2, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> v3)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> v1 + v2 + v3; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">auto</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">curried_sum3</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> v1)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [=](<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> v2){ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [=](<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> v3){ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> sum3(v1, v2, v3); }; }; } <span class="hljs-comment"><span class="hljs-comment">// output: 42 std::cout &lt;&lt; sum3(38, 3, 1) &lt;&lt; std::endl; std::cout &lt;&lt; curried_sum3(38)(3)(1) &lt;&lt; std::endl;</span></span></code> </pre> <br><h2 id="partial-application">  Teilanwendung </h2><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" title="Teilanwendung">Teilanwendung</a> - ist eine Möglichkeit, Funktionen von N Argumenten aufzurufen, wenn sie nur einen Teil der Argumente übernehmen und eine andere Funktion der verbleibenden Argumente zurückgeben. </p><br><p>  In diesem Zusammenhang sollte beachtet werden, dass dieser Prozess in Sprachen wie Haskell automatisch hinter dem Rücken eines Programmierers funktioniert.  Wir versuchen hier, es explizit auszuführen, <strong><code>sum3</code></strong> Unsere <strong><code>sum3</code></strong> Funktion wie <strong><code>sum3(38,3)(1)</code></strong> : <strong><code>sum3(38,3)(1)</code></strong> oder vielleicht so: <strong><code>sum3(38)(3,1)</code></strong> .  Wenn eine Funktion eine andere Funktion zurückgibt, die aktuell ist, kann sie darüber hinaus auch über die Liste der Argumente der ersten Funktion aufgerufen werden.  Sehen wir uns das Beispiel an: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">boo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> v1, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> v2)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> v1 + v2; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">auto</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> v1, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> v2)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> kari::curry(boo, v1 + v2); } <span class="hljs-comment"><span class="hljs-comment">// output: 42 std::cout &lt;&lt; kari::curry(foo)(38,3,1) &lt;&lt; std::endl; std::cout &lt;&lt; kari::curry(foo)(38,3)(1) &lt;&lt; std::endl; std::cout &lt;&lt; kari::curry(foo)(38)(3,1) &lt;&lt; std::endl;</span></span></code> </pre> <br><p>  Wir haben hier tatsächlich ein wenig Vorsprung vor uns und zeigen ein Beispiel für <a href="" title="kari.hpp">die</a> Verwendung von <a href="" title="kari.hpp">kari.hpp.</a> Ja, das tut es. </p><br><h2 id="setting-the-goals">  Ziele setzen </h2><br><p>  Bevor wir etwas schreiben, ist es notwendig (oder wünschenswert) zu verstehen, was wir am Ende haben wollen.  Und wir möchten die Möglichkeit haben, jede Funktion, die in C ++ aufgerufen werden kann, zu curry und teilweise anzuwenden.  Welches sind: </p><br><ul><li>  Lambdas (einschließlich generischer) </li><li>  Funktionsobjekte (Funktoren) </li><li>  Funktionen jeder Art (einschließlich Vorlagen) </li><li>  verschiedene Funktionen </li><li>  Methoden einer Klasse </li></ul><br><p>  Variadische Funktionen können durch Angabe einer genauen Anzahl von Argumenten, die wir curry möchten, ausgeführt werden.  Eine Standardinteraktion mit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" title="std :: bind">std :: bind</a> und seinen Ergebnissen ist ebenfalls wünschenswert.  Und natürlich brauchen wir die Möglichkeit, Funktionen mit mehreren Variablen anzuwenden und verschachtelte Funktionen aufzurufen, so dass es den Anschein hat, als hätten wir mit einer Curry-Funktion gearbeitet. </p><br><p>  Und wir dürfen auch die Leistung nicht vergessen.  Wir müssen die Rechenkosten für Wrapper, die Übertragung von Argumenten und deren Speicherung minimieren.  Dies bedeutet, dass wir umziehen müssen, anstatt zu kopieren, nur das speichern, was wir wirklich benötigen, und die Daten (mit weiterer Entfernung) so schnell wie möglich zurückgeben müssen. </p><br><h3 id="author-youve-been-trying-to-invent-stdbind-one-again">  Autor, Sie haben versucht, <strong><code>std::bind</code></strong> one erneut zu erfinden! </h3><br><p>  Ja und nein.  <strong><code>std::bind</code></strong> ist zweifellos ein mächtiges und bewährtes Werkzeug, und ich habe nicht vor, seinen Mörder oder seine Alternative zu schreiben.  Ja, es kann zum Currying und zur expliziten Teilanwendung verwendet werden (wobei genau angegeben wird, welche Argumente wir anwenden, wo und wie viele).  Aber es ist sicher nicht der bequemste Ansatz, ganz zu schweigen davon, dass er nicht immer anwendbar ist, da wir die Funktionsvielfalt kennen und abhängig davon spezifische Bindungen schreiben müssen.  Zum Beispiel: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> v1, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> v2, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> v3, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> v4)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> v1 + v2 + v3 + v4; } <span class="hljs-comment"><span class="hljs-comment">// std::bind auto c0 = std::bind(foo, _1, _2, _3, _4); auto c1 = std::bind(c0, 15, _1, _2, _3); auto c2 = std::bind(c1, 20, 2, _1); auto rr = c2(5); std::cout &lt;&lt; rr &lt;&lt; std::endl; // output: 42 // kari.hpp auto c0 = kari::curry(foo); auto c1 = c0(15); auto c2 = c1(20, 2); auto rr = c2(5); std::cout &lt;&lt; rr &lt;&lt; std::endl; // output: 42</span></span></code> </pre> <br><h2 id="api">  API </h2><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> kari { <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> F, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span>... Args &gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constexpr</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">decltype</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">auto</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">curry</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(F&amp;&amp; f, Args&amp;&amp;... args)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> F, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span>... Args &gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constexpr</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">decltype</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">auto</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">curryV</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(F&amp;&amp; f, Args&amp;&amp;... args)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> N, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> F, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span>... Args &gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constexpr</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">decltype</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">auto</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">curryN</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(F&amp;&amp; f, Args&amp;&amp;... args)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> F &gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">is_curried</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> F &gt; <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> is_curried_v = is_curried&lt;F&gt;::value; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> N, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> F, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span>... Args &gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">curry_t</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span>... As &gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constexpr</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">decltype</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">auto</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">operator</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(As&amp;&amp;... as)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span></span>; }; }</code> </pre> <br><hr><br><p> <strong><code>kari::curry(F&amp;&amp; f, Args&amp;&amp;... args)</code></strong> </p> <br><p>  Gibt ein Funktionsobjekt vom Typ <strong><code>curry_t</code></strong> (eine Curry-Funktion) mit angewendeten optionalen Argumenten <strong><code>args</code></strong> oder mit dem Ergebnis der Anwendung der Argumente auf die angegebene Funktion <strong><code>f</code></strong> (ist die Funktion null oder sind die übertragenen Argumente ausreichend, um sie aufzurufen). </p><br><p>  Wenn der Parameter <strong><code>f</code></strong> die Funktion enthält, die bereits ausgeführt wurde, gibt er seine Kopie mit den angewendeten Argumenten <strong><code>args</code></strong> . </p><br><hr><br><p> <strong><code>kari::curryV(F&amp;&amp; f, Args&amp;&amp;... args)</code></strong> </p> <br><p>  Ermöglicht das Currying von Funktionen mit variabler Anzahl von Argumenten.  Danach können diese Funktionen mit dem Operator <strong><code>()</code></strong> ohne Argumente aufgerufen werden.  Zum Beispiel: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> c0 = kari::curryV(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>, <span class="hljs-string"><span class="hljs-string">"%d + %d = %d"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> c1 = c0(<span class="hljs-number"><span class="hljs-number">37</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> c2 = c1(<span class="hljs-number"><span class="hljs-number">42</span></span>); c2(); <span class="hljs-comment"><span class="hljs-comment">// output: 37 + 5 = 42</span></span></code> </pre> <br><p>  Wenn der Parameter <strong><code>f</code></strong> eine Funktion enthält, die bereits ausgeführt wurde, gibt er seine Kopie mit geändertem Anwendungstyp für die variable Anzahl von Argumenten mit den angewendeten Argumenten <strong><code>args</code></strong> . </p><br><hr><br><p> <strong><code>kari::curryN(F&amp;&amp; f, Args&amp;&amp;... args)</code></strong> </p> <br><p>  Ermöglicht das Curry-Funktionieren mit variabler Anzahl von Argumenten, indem eine genaue Anzahl <strong><code>N</code></strong> von Argumenten angegeben wird, die angewendet werden sollen (mit Ausnahme der in <strong><code>args</code></strong> ).  Zum Beispiel: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">char</span></span> buffer[<span class="hljs-number"><span class="hljs-number">256</span></span>] = {<span class="hljs-string"><span class="hljs-string">'\0'</span></span>}; <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> c = kari::curryN&lt;<span class="hljs-number"><span class="hljs-number">3</span></span>&gt;(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">snprintf</span></span>, buffer, <span class="hljs-number"><span class="hljs-number">256</span></span>, <span class="hljs-string"><span class="hljs-string">"%d + %d = %d"</span></span>); c(<span class="hljs-number"><span class="hljs-number">37</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">42</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; buffer &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; <span class="hljs-comment"><span class="hljs-comment">// output: 37 + 5 = 42</span></span></code> </pre> <br><p>  Wenn der Parameter <strong><code>f</code></strong> eine Funktion enthält, die bereits ausgeführt wurde, gibt er seine Kopie mit geändertem Anwendungstyp für N Argumente mit den angewendeten Argumenten <strong><code>args</code></strong> . </p><br><hr><br><p> <strong><code>kari::is_curried&lt;F&gt;, kari::is_curried_v&lt;F&gt;</code></strong> </p> <br><p>  Einige Hilfsstrukturen zur Überprüfung, ob eine Funktion bereits ausgeführt wurde.  Zum Beispiel: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> l = [](<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> v1, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> v2){ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> v1 + v2; }; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> c = curry(l); <span class="hljs-comment"><span class="hljs-comment">// output: is `l` curried? no std::cout &lt;&lt; "is `l` curried? " &lt;&lt; (is_curried&lt;decltype(l)&gt;::value ? "yes" : "no") &lt;&lt; std::endl; // output: is `c` curried? yes std::cout &lt;&lt; "is `c` curried? " &lt;&lt; (is_curried_v&lt;decltype(c)&gt; ? "yes" : "no") &lt;&lt; std::endl;</span></span></code> </pre> <br><hr><br><p> <strong><code>kari::curry_t::operator()(As&amp;&amp;... as)</code></strong> </p> <br><p>  Der Bediener erlaubt eine vollständige oder teilweise Anwendung einer Curry-Funktion.  Gibt die Curry-Funktion der verbleibenden Argumente der Anfangsfunktion <strong><code>F</code></strong> oder den Wert dieser Funktion zurück, der durch ihre Anwendung auf den Rückstand alter und neuer Argumente <strong><code>as</code></strong> .  Zum Beispiel: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> v1, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> v2, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> v3, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> v4)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> v1 + v2 + v3 + v4; } <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> c0 = kari::curry(foo); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> c1 = c0(<span class="hljs-number"><span class="hljs-number">15</span></span>, <span class="hljs-number"><span class="hljs-number">20</span></span>); <span class="hljs-comment"><span class="hljs-comment">// partial application auto rr = c1(2, 5); // function call - foo(15,20,2,5) std::cout &lt;&lt; rr &lt;&lt; std::endl; // output: 42</span></span></code> </pre> <br><p>  Wenn Sie mit <strong><code>curryV</code></strong> oder <strong><code>curryN</code></strong> eine Curry-Funktion ohne Argumente <strong><code>curryN</code></strong> , wird sie aufgerufen, wenn genügend Argumente vorhanden sind.  Andernfalls wird eine teilweise angewendete Funktion zurückgegeben.  Zum Beispiel: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> c0 = kari::curryV(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>, <span class="hljs-string"><span class="hljs-string">"%d + %d = %d"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> c1 = c0(<span class="hljs-number"><span class="hljs-number">37</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> c2 = c1(<span class="hljs-number"><span class="hljs-number">42</span></span>); <span class="hljs-comment"><span class="hljs-comment">// force call variadic function std::printf c2(); // output: 37 + 5 = 42</span></span></code> </pre> <br><h2 id="details-of-implementation">  Details der Implementierung </h2><br><p>  Wenn ich Ihnen Details zur Implementierung gebe, werde ich C ++ 17 verwenden, um den Text des Artikels kurz zu halten und unnötige Erklärungen und gestapelte <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" title="SFINAE">SFINAE</a> sowie Beispiele für Implementierungen zu <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" title="SFINAE">vermeiden</a> , die ich in C ++ hinzufügen musste 14 Standard.  All dies finden Sie im Projekt- <a href="" title="kari.hpp">Repository</a> , wo Sie es auch zu Ihren Favoriten hinzufügen können :) </p><br><hr><br><p> <strong><code>make_curry(F&amp;&amp; f, std::tuple&lt;Args...&gt;&amp;&amp; args)</code></strong> </p> <br><p>  Eine Hilfsfunktion, die ein Funktionsobjekt <strong><code>curry_t</code></strong> oder die angegebene Funktion <strong><code>f</code></strong> auf die Argumente <strong><code>args</code></strong> anwendet. </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> N, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> F, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span>... Args &gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constexpr</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">auto</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">make_curry</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(F&amp;&amp; f, </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::tuple&lt;Args...&gt;&amp;&amp; args)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">if</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">constexpr</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( N == </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp;&amp; </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::is_invocable_v&lt;F, Args...&gt; )</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::apply(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::forward&lt;F&gt;(f), <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(args)); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">curry_t</span></span>&lt; N, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">decay_t</span></span>&lt;F&gt;, Args... &gt;(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::forward&lt;F&gt;(f), <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(args)); } } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> N, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> F &gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constexpr</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">decltype</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">auto</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">make_curry</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(F&amp;&amp; f)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> make_curry&lt;N&gt;(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::forward&lt;F&gt;(f), <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::make_tuple()); }</code> </pre> <br><p>  Nun gibt es zwei interessante Dinge an dieser Funktion: </p><br><ul><li>  Wir wenden es nur auf die Argumente an, wenn es für diese Argumente aufrufbar ist und der Anwendungszähler <strong><code>N</code></strong> auf Null steht </li><li>  Wenn die Funktion nicht aufrufbar ist, betrachten wir diesen Aufruf als Teilanwendung und erstellen ein Funktionsobjekt <strong><code>curry_t</code></strong> das die Funktion und die Argumente enthält </li></ul><br><hr><br><p> <strong><code>struct curry_t</code></strong> </p> <br><p>  Das Funktionsobjekt, das den Rückstand an Argumenten speichern soll, und die Funktion, die wir beim Anwenden am Ende aufrufen werden.  Dieses Objekt werden wir aufrufen und teilweise anwenden. </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> N, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> F, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span>... Args &gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">curry_t</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> U &gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constexpr</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">curry_t</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(U&amp;&amp; u, </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::tuple&lt;Args...&gt;&amp;&amp; args)</span></span></span><span class="hljs-function"> : </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f_</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::forward&lt;U&gt;(u))</span></span></span><span class="hljs-function"> , </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">args_</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::move(args))</span></span></span><span class="hljs-function"> </span></span>{} <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: F f_; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::tuple&lt;Args...&gt; args_; };</code> </pre> <br><p>  Es gibt eine Reihe von Gründen, warum wir den Rückstand der Argumente <strong><code>args_</code></strong> in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" title="std :: tuple">std ::</a> <strong><code>args_</code></strong> speichern: </p><br><p>  1) Situationen mit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" title="std :: ref">std :: ref</a> werden automatisch behandelt, um Referenzen zu speichern, wenn dies erforderlich ist, standardmäßig basierend auf dem Wert <br>  2) bequeme Anwendung einer Funktion gemäß ihren Argumenten ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" title="std :: bewerben">std :: apply</a> ) <br>  3) es ist fertig gemacht, so dass Sie es nicht von Grund auf neu schreiben müssen :) </p><br><p>  Wir haben das aufgerufene Objekt und die Funktion <strong><code>f_</code></strong> nach ihrem Wert gespeichert und sind vorsichtig, wenn Sie den Typ auswählen, wenn Sie einen erstellen (ich werde dieses Problem weiter unten erläutern) oder ihn verschieben oder kopieren, indem Sie die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" title="universelle Referenzen">universelle Referenz</a> in verwenden der Konstruktor. </p><br><p>  Ein Vorlagenparameter <strong><code>N</code></strong> dient als Anwendungszähler für verschiedene Funktionen. </p><br><hr><br><p> <strong><code>curry_t::operator()(const As&amp;...)</code></strong> </p> <br><p>  Und natürlich das, was alles zum Funktionieren bringt - der Operator, der das Funktionsobjekt aufruft. </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> N, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> F, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span>... Args &gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">curry_t</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-comment"><span class="hljs-comment">// 1 constexpr decltype(auto) operator()() &amp;&amp; { return detail::make_curry&lt;0&gt;( std::move(f_), std::move(args_)); } // 2 template &lt; typename A &gt; constexpr decltype(auto) operator()(A&amp;&amp; a) &amp;&amp; { return detail::make_curry&lt;(N &gt; 0 ? N - 1 : 0)&gt;( std::move(f_), std::tuple_cat( std::move(args_), std::make_tuple(std::forward&lt;A&gt;(a)))); } // 3 template &lt; typename A, typename... As &gt; constexpr decltype(auto) operator()(A&amp;&amp; a, As&amp;&amp;... as) &amp;&amp; { return std::move(*this)(std::forward&lt;A&gt;(a))(std::forward&lt;As&gt;(as)...); } // 4 template &lt; typename... As &gt; constexpr decltype(auto) operator()(As&amp;&amp;... as) const &amp; { auto self_copy = *this; return std::move(self_copy)(std::forward&lt;As&gt;(as)...); } }</span></span></code> </pre> <br><p>  Der aufrufende Operator hat vier Funktionen überladen. </p><br><ol><li><p>  Eine Funktion ohne Parameter, mit der die Variadic-Funktion (erstellt von <strong><code>curryV</code></strong> oder <strong><code>curryN</code></strong> ) <strong><code>curryN</code></strong> .  Hier dekrementieren wir den Anwendungszähler auf Null, um zu verdeutlichen, dass die Funktion zur Anwendung bereit ist, und geben dann alles, was dafür erforderlich ist, an <strong><code>make_curry</code></strong> Funktion <strong><code>make_curry</code></strong> . </p><br></li><li><p>  Eine Funktion eines einzelnen Arguments, die den Anwendungszähler um 1 dekrementiert (wenn er nicht Null ist) und unser neues Argument <strong><code>a</code></strong> in den Rückstand der Argumente <strong><code>args_</code></strong> und all dies an <strong><code>make_curry</code></strong> . </p><br></li><li><p>  Eine variable Funktion, die eigentlich ein Trick für die teilweise Anwendung verschiedener Argumente ist.  Es wendet sie rekursiv nacheinander an.  Es gibt zwei Gründe, warum sie nicht alle auf einmal angewendet werden können: </p><br><ul><li>  Der Anwendungszähler kann auf Null sinken, bevor keine Argumente mehr vorhanden sind </li><li>  Die Funktion <strong><code>f_</code></strong> kann früher aufgerufen werden und eine andere Curry-Funktion zurückgeben, sodass alle nächsten Argumente dafür bestimmt sind </li></ul><br></li><li><p>  Die letzte Funktion fungiert als Brücke zwischen dem Aufruf von <strong><code>curry_t</code></strong> mit <em>lvalue</em> und dem Aufruf von Funktionen mit <em>rvalue</em> . </p><br></li></ol><br><p>  Die Tags von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" title="ref-qualifiziert">ref-qualifizierten</a> Funktionen machen den gesamten Prozess fast magisch.  Um es kurz zu machen, mit ihrer Hilfe erfahren wir, dass ein Objekt mit der <em>rvalue-</em> Referenz aufgerufen wurde, und wir können die Argumente einfach verschieben, anstatt sie in der <strong><code>make_curry</code></strong> .  Andernfalls müssten wir die Argumente kopieren, um diese Funktion weiterhin aufrufen zu können und sicherzustellen, dass die Argumente noch vorhanden sind. </p><br><h2 id="bonuses">  Boni </h2><br><p>  Bevor ich zum Schluss <a href="" title="kari.hpp">komme</a> , möchte ich Ihnen einige Beispiele für den syntaktischen Zucker zeigen, den sie in <a href="" title="kari.hpp">kari.hpp haben und</a> der als Bonus qualifiziert werden kann. </p><br><h3 id="operator-sections">  Bedienerabschnitte </h3><br><p>  Die Programmierer, die bereits mit Haskell gearbeitet haben, sollten mit Operatorabschnitten vertraut sein, die eine kurze Beschreibung der angewendeten Operatoren ermöglichen.  Zum Beispiel generiert die Struktur <strong><code>(*2)</code></strong> eine Einzelargumentfunktion, die das Ergebnis der Multiplikation dieses Arguments mit 2 zurückgibt. Ich wollte also versuchen, so etwas in C ++ zu schreiben.  Kaum gesagt als getan! </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> <span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> kari::underscore; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; v{<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>,<span class="hljs-number"><span class="hljs-number">4</span></span>,<span class="hljs-number"><span class="hljs-number">5</span></span>}; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::accumulate(v.begin(), v.end(), <span class="hljs-number"><span class="hljs-number">0</span></span>, _+_); <span class="hljs-comment"><span class="hljs-comment">// result: 15 std::transform(v.begin(), v.end(), v.begin(), _*2); // v = 2, 3, 6, 8, 10 std::transform(v.begin(), v.end(), v.begin(), -_); // v = -2,-3,-6,-8,-10</span></span></code> </pre> <br><h3 id="function-composition">  Funktionszusammensetzung </h3><br><p>  Und natürlich wäre ich kein Vollidiot, wenn ich nicht versucht hätte, eine <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" title="Funktionszusammensetzung">Funktionskomposition</a> zu schreiben.  Als Kompositionsoperator habe ich den <strong><code>operator *</code></strong> als das Symbol gewählt, das dem Kompositionszeichen in der Mathematik am nächsten kommt.  Ich habe es verwendet, um die resultierende Funktion auch für ein Argument anzuwenden.  Also, das habe ich bekommen: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> <span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> kari::underscore; <span class="hljs-comment"><span class="hljs-comment">// 1 std::cout &lt;&lt; (_*2) * (_+2) * 4 &lt;&lt; std::endl; // output: 12 // 2 std::cout &lt;&lt; 4 * (_*2) * (_+2) &lt;&lt; std::endl; // output: 10</span></span></code> </pre> <br><ol><li>  Die Zusammensetzung der Funktionen <strong><code>(*2)</code></strong> und <strong><code>(+2)</code></strong> wird auf <strong><code>4</code></strong> angewendet. <strong><code>(4 + 2) * 2 = 12</code></strong> </li><li>  Funktion <strong><code>(*2)</code></strong> wird auf <strong><code>4</code></strong> angewendet und dann wenden wir <strong><code>(+2)</code></strong> auf das Ergebnis an. <strong><code>(4 * 2 + 2) = 10</code></strong> </li></ol><br><p>  Auf die gleiche Weise können Sie recht komplexe Kompositionen im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" title="Punktfreier Stil">punktfreien Stil erstellen</a> , aber denken Sie daran, dass nur Haskell-Programmierer diese verstehen werden :) </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// (. (+2)) (*2) $ 10 == 24 // haskell analog std::cout &lt;&lt; (_*(_+2))(_*2) * 10 &lt;&lt; std::endl; // output: 24 // ((+2) .) (*2) $ 10 == 22 // haskell analog std::cout &lt;&lt; ((_+2)*_)(_*2) * 10 &lt;&lt; std::endl; // output: 22</span></span></code> </pre> <br><h2 id="conclusion">  Fazit </h2><br><p>  Ich denke, es war vorher ziemlich klar, dass es nicht nötig ist, diese Techniken in realen Projekten einzusetzen.  Trotzdem muss ich das erwähnen.  Mein Ziel war es schließlich, mich zu beweisen und den neuen C ++ - Standard zu überprüfen.  Würde ich das tun können?  Und würde C ++?  Nun, ich denke, Sie haben gerade gesehen, dass wir beide das irgendwie getan haben.  Und ich bin allen sehr dankbar, die das Ganze gelesen haben. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de436488/">https://habr.com/ru/post/de436488/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de436476/index.html">Cloud für Versicherer</a></li>
<li><a href="../de436480/index.html">Ich habe einen Bot gemacht, der mit Personalvermittlern für mich kommuniziert, und ich mochte</a></li>
<li><a href="../de436482/index.html">Advanced Three.js: Shader-Materialien und Nachbearbeitung</a></li>
<li><a href="../de436484/index.html">Wo finde ich DNS-Einstellungen unter MacOS?</a></li>
<li><a href="../de436486/index.html">Was passiert auf dem Audio-Podcast-Markt?</a></li>
<li><a href="../de436490/index.html">Motorola plant die Einführung der Razr v3-Inkarnation</a></li>
<li><a href="../de436492/index.html">Wir suchen Redner beim 10. DIY Mitap am 17. Februar 2019</a></li>
<li><a href="../de436494/index.html">Ersetzen einer Festplatte unter Beibehaltung der richtigen Nummerierung in CEPH</a></li>
<li><a href="../de436496/index.html">PVS-Studio für Java</a></li>
<li><a href="../de436498/index.html">Software AG: Nicht nur ARIS</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>