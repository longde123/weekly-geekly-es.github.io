<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ’³ ğŸ•§ ğŸš  Mengumpulkan bundel impian dengan Webpack ğŸ›£ï¸ ğŸš† ğŸš–</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Aplikasi JS, situs dan sumber daya lainnya menjadi lebih kompleks dan alat membangun adalah realitas pengembangan web. Bundlers membantu mengemas, men...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Mengumpulkan bundel impian dengan Webpack</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/oleg-bunin/blog/433324/">  Aplikasi JS, situs dan sumber daya lainnya menjadi lebih kompleks dan alat membangun adalah realitas pengembangan web.  Bundlers membantu mengemas, mengompilasi, dan mengatur perpustakaan.  Salah satu alat open source yang kuat dan fleksibel yang dapat dikustomisasi sempurna untuk membangun aplikasi klien adalah Webpack. <br><br>  Maxim Sosnov ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" class="user_link">crazymax11</a> ) - Frontend Lead di N1.RU memperkenalkan Webpack ke beberapa proyek besar yang sebelumnya memiliki custom build sendiri, dan menyumbangkan beberapa proyek untuk itu.  Maxim tahu cara membangun bundel impian dengan Webpack, melakukannya dengan cepat, dan mengonfigurasinya sehingga konfigurasi tetap bersih, terpelihara, dan modular. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/4ClK_0fxsVM" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Interpretasinya berbeda dari laporan - ini adalah versi proflink yang sangat ditingkatkan.  Sepanjang transkrip, telur Paskah tersebar di artikel, plugin, minifiers, opsi, transpiler dan bukti dari kata-kata pembicara, tautan yang tidak dapat dimasukkan ke dalam pidato.  Jika Anda mengumpulkan semuanya, maka level bonus di Webpack terbuka :-) <br><a name="habracut"></a><br><h2>  Integrasi webpack dalam proyek tipikal </h2><br>  Biasanya, prosedur implementasi adalah sebagai berikut: pengembang di suatu tempat membaca artikel tentang Webpack, memutuskan untuk menghubungkannya, mulai membangunnya, entah bagaimana itu berfungsi, semuanya dimulai, dan untuk beberapa waktu webpack-config berfungsi - selama enam bulan, satu tahun, dua.  Secara lokal, semuanya baik-baik saja - matahari, pelangi dan kupu-kupu.  Dan kemudian pengguna nyata datang: <br><br>  <em>- Dari perangkat seluler, situs Anda tidak memuat.</em> <em><br></em>  <em>- Semuanya bekerja untuk kita.</em>  <em>Secara lokal, semuanya baik-baik saja!</em> <br><br>  Untuk berjaga-jaga, pengembang pergi ke profil segalanya dan melihat bahwa untuk perangkat seluler <strong>bundel memiliki berat 7 MB dan membutuhkan waktu 30 detik untuk memuat</strong> .  Ini tidak cocok untuk siapa pun dan pengembang mulai mencari cara mengatasi masalah - ia dapat menghubungkan loader atau menemukan plug-in ajaib yang akan menyelesaikan semua masalah.  Ajaibnya, plugin semacam itu berada.  Pengembang kami pergi ke konfigurasi webpack, mencoba menginstal, tetapi baris kode mengganggu: <br><br><pre><code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (process.env.NODE_ENV === <span class="hljs-string"><span class="hljs-string">'production'</span></span>) { config.module.rules[<span class="hljs-number"><span class="hljs-number">7</span></span>].options.magic = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> <br>  Baris diterjemahkan sebagai berikut: "Jika config sedang dirakit untuk produksi, maka ambil aturan ketujuh dan taruh opsi <code>magic = true</code> sana."  Pengembang tidak tahu apa yang harus dilakukan dengan ini dan bagaimana menyelesaikannya.  Ini adalah situasi di mana Anda membutuhkan seikat mimpi. <br><br><h2>  Bagaimana cara mengumpulkan seikat mimpi? </h2><br>  Pertama, mari kita tentukan apa itu.  Pertama-tama, bundel mimpi memiliki dua karakteristik utama: <br><br><ul><li>  <strong>Beratnya sedikit</strong> .  Semakin sedikit berat - semakin cepat pengguna akan mendapatkan aplikasi yang berfungsi.  Anda tidak ingin situs Anda terbuka selama 15 detik. </li><li>  Pengguna <strong>hanya mengunduh apa yang perlu</strong> diunduh untuk menampilkan halaman situs saat ini, dan tidak lebih dari satu byte! </li></ul><br>  Dan untuk mengurangi ukuran bundel, Anda harus terlebih dahulu mengevaluasi ukurannya. <br><br><h3>  Nilai ukuran bundel </h3><br>  Solusi paling populer adalah plugin <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">WebpackBundleAnalyzer</a> .  Itu mengumpulkan statistik membangun aplikasi dan membuat halaman interaktif di mana Anda dapat melihat lokasi dan berat masing-masing modul. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/27a/803/6b9/27a8036b994a09b7371c567b6df6cd82.png" alt="gambar"><br><br>  Jika ini tidak cukup, Anda bisa membuat <strong>grafik ketergantungan</strong> menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">plugin lain</a> . <br><br><img src="https://habrastorage.org/getpro/habr/post_images/7c3/900/24a/7c390024a9d902ca99e3d00c0d8081b3.png" alt="gambar"><br><br>  Atau <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">diagram lingkaran</a> . <br><br><img src="https://habrastorage.org/getpro/habr/post_images/350/14a/ec4/35014aec45623d06972bca310b3f8edf.png" alt="gambar"><br><br>  Jika ini tidak cukup, dan Anda ingin menjual Webpack ke pemasar, maka Anda dapat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">membangun seluruh alam semesta di</a> mana setiap titik adalah modul, seperti bintang di Semesta. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/45b/a6e/2d2/45ba6e2d2daff144c69df2a43e8ef53a.png" alt="gambar"><br><br>  Ada banyak alat yang mengevaluasi ukuran bundel dan memonitornya.  Ada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">opsi dalam konfigurasi Webpack</a> yang crash perakitan jika bundel terlalu berat, misalnya.  Ada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">plugin duplikat-paket-pemeriksa-webpack-plugin</a> yang akan mencegah Anda <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">membangun</a> bundel jika Anda memiliki paket 2 npm dari versi yang berbeda, misalnya, Lodash 4.15 dan Lodash 4.14. <br><br><h3>  Cara mengurangi bundel </h3><br><ul><li>  Yang paling jelas adalah menyambungkan <strong>UglifyJS</strong> sehingga itu meminimalkan JavaScript. </li><li>  Gunakan <strong>loader dan plugin khusus</strong> yang mengkompres dan mengoptimalkan sumber daya tertentu.  Misalnya, <strong>css-nano</strong> untuk css, atau <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">SVGO</a> , yang mengoptimalkan SVG. </li><li>  Kompres semua file secara langsung ke Webpack melalui <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">plugins gzip / brotli</a> . </li><li>  Alat lainnya. </li></ul><br>  Sekarang kita akan mengerti cara membuang kelebihan dari bundel. <br><br><h3>  Buang kelebihannya </h3><br>  Pertimbangkan ini dalam contoh populer dengan <strong>moment.js</strong> : <code>import moment from 'moment'</code> .  Jika Anda mengambil aplikasi kosong, impor moment.js dan <strong>ReactDOM</strong> ke dalamnya, dan kemudian <strong>kirimkan</strong> melalui <strong>WebpackBundleAnalyzer</strong> , Anda akan melihat gambar berikut. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/105/e0f/833/105e0f8334a83c529077c693fda3d3de.png" alt="gambar"><br><br>  Ternyata ketika Anda menambahkan satu hari, satu jam ke tanggal, atau hanya ingin meletakkan tautan "dalam 15 menit" menggunakan moment.js, Anda menghubungkan <strong>kode 230 Kbytes</strong> !  Mengapa ini terjadi dan bagaimana cara menyelesaikannya? <br><br><h4>  Pemuatan lokal saat ini </h4><br>  Ada fungsi di moment.js yang mengatur lokal: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setLocale</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">locale</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> localePath = <span class="hljs-string"><span class="hljs-string">'locale/'</span></span> + locale + <span class="hljs-string"><span class="hljs-string">'.js'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._currentLocale = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(localePath); }</code> </pre><br>  Dapat dilihat dari kode bahwa lokal dimuat di sepanjang jalur dinamis, yaitu  dihitung dalam runtime.  Webpack bertindak dengan cerdas dan mencoba memastikan bahwa bundel Anda tidak macet selama eksekusi kode: ia menemukan semua kemungkinan lokal dalam proyek, dan bundel mereka.  Oleh karena itu, aplikasi ini sangat berat. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/a03/4cc/b3f/a034ccb3fc36dd03b916b0bc28acb057.png" alt="gambar"><br><br>  Solusinya sangat sederhana - kami mengambil <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">plugin standar</a> dari Webpack dan mengatakan kepadanya: "Jika Anda melihat seseorang ingin mengunduh banyak lokal, karena mereka tidak dapat menentukan yang mana, ambil saja yang Rusia!" <br><br><img src="https://habrastorage.org/getpro/habr/post_images/587/fe6/e38/587fe6e38333e8b482fed615e3c00ee1.png" alt="gambar"><br><br>  Webpack hanya akan mengambil bahasa Rusia, dan WebpackBundleAnalyzer akan menampilkan 54 Kb, yang sudah 200 Kb lebih mudah. <br><br><h3>  Penghapusan kode mati </h3><br>  Optimasi berikutnya yang menarik bagi kami adalah <strong>penghapusan kode mati</strong> .  Pertimbangkan kode berikut. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> cond = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!cond) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; someFunction(<span class="hljs-number"><span class="hljs-number">42</span></span>);</code> </pre><br>  Sebagian besar baris dari kode ini tidak diperlukan dalam bundel akhir - blok dengan kondisi tidak akan dieksekusi, fungsi setelah kembali juga.  Yang perlu Anda tinggalkan adalah <code>return true</code> .  Inilah yang dimaksud dengan penghapusan kode Mati: alat build mendeteksi kode yang tidak dapat dieksekusi dan memotongnya.  Ada fitur bagus yang dapat dilakukan UglifyJS ini. <br><br>  Sekarang mari kita beralih ke penghapusan kode Mati yang lebih maju - <strong>Metode pengocokan pohon</strong> . <br><br><h3>  Pohon bergetar </h3><br>  Katakanlah kita memiliki aplikasi yang menggunakan <strong>Lodash</strong> .  Saya sangat meragukan bahwa ada orang yang menggunakan seluruh Lodash.  Kemungkinan besar, beberapa fungsi seperti <strong>get</strong> , <strong>IsEmpty, unionBy,</strong> atau sejenisnya <strong>dieksploitasi</strong> . <br><br>  Ketika kita melakukan Tree gemetar, kita ingin Webpack untuk "mengguncang" modul yang tidak perlu dan membuangnya, dan kita hanya memiliki yang diperlukan.  Ini Pohon bergetar. <br><br><h4>  Bagaimana Tree shaking bekerja di Webpack </h4><br>  Katakanlah Anda memiliki kode seperti ini: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { a } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'./a.js'</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(a);</code> </pre><br>  Kode ini sangat sederhana: dari beberapa modul, impor variabel a dan output.  Tetapi ada dua variabel dalam modul ini: <strong>a</strong> dan <strong>b</strong> .  Kami tidak membutuhkan variabel <b>b</b> , dan kami ingin menghapusnya. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> a = <span class="hljs-number"><span class="hljs-number">3</span></span> <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> b = <span class="hljs-number"><span class="hljs-number">4</span></span></code> </pre><br>  Ketika Webpack tiba, itu mengonversi kode impor menjadi ini: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> d = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(d[<span class="hljs-string"><span class="hljs-string">"a"</span></span>]);</code> </pre><br>  <code>import</code> kami berubah menjadi <code>require</code> , tetapi <code>console.log</code> belum berubah. <br><br>  Ketergantungan Webpack dikonversi ke kode berikut: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> a = <span class="hljs-number"><span class="hljs-number">3</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">module</span></span>.exports[<span class="hljs-string"><span class="hljs-string">"aÂ«] = a; /* unused harmony export b */ var b = 4;</span></span></code> </pre><br><br>  Webpack meninggalkan ekspor variabel <b>a</b> , dan menghapus ekspor variabel <b>b</b> , tetapi meninggalkan variabel itu sendiri, menandainya dengan komentar khusus.  Dalam kode yang dikonversi, variabel <b>b</b> tidak digunakan, dan UglifyJS dapat menghapusnya. <br><br><blockquote>  Goyang pohon webpack hanya berfungsi jika Anda memiliki semacam minifier kode, seperti UglifyJS atau <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">babel-minify</a></b> . </blockquote><br>  Mari kita pertimbangkan kasus-kasus yang lebih menarik - ketika Tree shaking tidak berfungsi. <br><br><h4>  Ketika Pohon Goyang Tidak Berfungsi </h4><br>  Kasus No. 1. Anda menulis kode: <br><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">module</span></span>.exports.a = <span class="hljs-number"><span class="hljs-number">3</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">module</span></span>.exports.b = <span class="hljs-number"><span class="hljs-number">4</span></span>;</code> </pre><br>  Jalankan kode melalui Webpack, dan tetap sama.  Itu karena bundler mengatur Tree goyang hanya jika Anda menggunakan modul ES6.  Jika Anda menggunakan modul CommonJS, maka Tree shaking tidak akan berfungsi. <br><br>  Kasus No. 2. Anda menulis kode dengan modul ES6 dan bernama ekspor. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> a = <span class="hljs-number"><span class="hljs-number">3</span></span> <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> b = <span class="hljs-number"><span class="hljs-number">4</span></span></code> </pre><br>  Jika kode Anda berjalan melalui Babel dan Anda tidak mengatur opsi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">modul ke false</a> , maka Babel akan membawa modul Anda ke CommonJS, dan Webpack sekali lagi tidak dapat mengeksekusi Tree shaking, karena hanya bekerja dengan modul ES6. <br><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">module</span></span>.exports.a = <span class="hljs-number"><span class="hljs-number">3</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">module</span></span>.exports.b = <span class="hljs-number"><span class="hljs-number">4</span></span>;</code> </pre><br>  Karenanya, kita perlu memastikan bahwa tidak ada seorang pun dalam rencana perakitan kita yang akan mentranskripsi modul ES6. <br><br>  Kasus No. 3. Misalkan kita memiliki kelas yang tidak berguna yang tidak melakukan apa-apa: <code>export class ShakeMe {}</code> .  Apalagi kami masih belum menggunakannya.  Ketika Webpack melewati impor dan ekspor, Babel akan mengubah kelas menjadi suatu fungsi, dan bundler akan mencatat bahwa fungsi tersebut tidak digunakan: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">/* unused harmony e[port b */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> ShakeMe = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ShakeMe</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ babelHelpers.classCallCheck(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, ShakeMe); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ShakeMe; }();</code> </pre><br>  Tampaknya semuanya harus baik-baik saja, tetapi jika kita melihat lebih dekat, kita akan melihat bahwa di dalam fungsi ini ada variabel global <code>babelHelpers</code> , dari mana beberapa fungsi dipanggil.  Ini adalah <b>efek samping</b> : UglifyJS melihat bahwa beberapa fungsi global sedang dipanggil dan tidak akan memotong kode, karena takut sesuatu akan rusak. <br><br>  Ketika Anda menulis kelas dan menjalankannya melalui Babel, mereka tidak pernah terpotong.  Bagaimana ini diperbaiki?  Ada peretasan standar - tambahkan komentar <code>/*#__PURE__*/</code> sebelum fungsi: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">/* unused harmony export b */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> ShakeMe = <span class="hljs-comment"><span class="hljs-comment">/*#__PURE__*/</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ShakeMe</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ babelHelpers.classCallCheck(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, ShakeMe); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ShakeMe; }();</code> </pre><br>  Kemudian UglifyJS akan percaya pada kata bahwa fungsi selanjutnya adalah murni.  Untungnya, <b><a href="">Babel 7</a></b> melakukan ini sekarang, dan dalam Babel 6, sejauh ini tidak ada yang dihapus. <br><br><blockquote>  Aturan: jika Anda memiliki efek samping di suatu tempat, maka UglifyJS tidak akan melakukan apa pun. </blockquote><br>  Untuk meringkas: <br><br><ul><li>  <b>Mengguncang pohon tidak berfungsi untuk sebagian besar perpustakaan dari npm</b> , karena mereka semua dari CommonJS dan dibangun oleh Babel lama. </li><li>  Kemungkinan besar, <b>Tree shaking akan berfungsi secara memadai untuk pustaka yang sudah disiapkan untuk ini</b> , misalnya, Lodash-es, Date-fns dan kode atau pustaka Anda. </li><li>  UglifyJS terlibat dalam perakitan. </li><li>  Modul ES6 yang digunakan. </li><li>  Tidak ada efek samping. </li></ul><br>  Kami menemukan cara untuk mengurangi berat bundel, dan sekarang mari kita ajarkan untuk memuat hanya fungsionalitas yang diperlukan. <br><br><h3>  Kami hanya memuat fungsionalitas yang diperlukan </h3><br>  Kami membagi bagian ini menjadi dua.  Pada bagian pertama, <b>hanya kode yang diperlukan pengguna dimuat</b> : jika pengguna mengunjungi halaman utama situs Anda, ia tidak memuat halaman akun pribadi.  Dalam yang kedua, <b>perubahan kode menyebabkan reload sumber daya sekecil mungkin</b> . <br><br><h4>  Kami hanya memuat kode yang diperlukan </h4><br>  Pertimbangkan struktur aplikasi imajiner.  Itu memiliki: <br><br><ul><li>  Titik masuk - APP. </li><li>  Tiga halaman: rumah, pencarian dan kartu. </li></ul><br><img src="https://habrastorage.org/getpro/habr/post_images/872/142/14e/87214214e5fc6514a1a72cb20f6be4b2.png" alt="gambar"><br><br>  Masalah pertama yang ingin kita pecahkan adalah <b>mengeluarkan kode umum</b> .  Mari kita menunjukkan kode merah sebagai kode umum untuk semua halaman, lingkaran hijau untuk halaman utama dan halaman pencarian.  Sisa angka tidak terlalu penting. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/854/ec8/80f/854ec880feff7813d267ca834209db71.png" alt="gambar"><br><br>  Ketika pengguna datang ke pencarian dari halaman utama, ia akan memuat ulang kotak dan lingkaran untuk kedua kalinya, meskipun ia sudah memilikinya.  Idealnya, kami ingin melihat sesuatu seperti ini. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/b75/290/36d/b7529036de4cf6923a279666d00ca297.png" alt="gambar"><br><br>  Ada baiknya bahwa Webpack 4 sudah memiliki plugin <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">bawaan</a> yang melakukan ini untuk kita - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">SplitChunksPlugin</a> .  Plugin mengeluarkan kode aplikasi atau modul modul simpul, yang digunakan oleh beberapa chunks dalam chunk yang terpisah, sambil memastikan bahwa chunk dengan kode yang umum akan lebih dari 30 Kb, dan untuk memuat halaman yang Anda perlu unduh tidak lebih dari 5 chunks.  Strateginya optimal: memuat potongan terlalu kecil tidak menguntungkan, dan memuat terlalu banyak potongan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=http://engineering.khanacademy.org/posts/js-packaging-">panjang dan tidak seefisien</a> mengunduh lebih sedikit potongan bahkan di http2.  Untuk mengulangi perilaku ini pada 2 atau 3 versi Webpack, saya harus menulis 20-30 baris dengan fitur tidak berdokumen.  Sekarang ini sedang diselesaikan dalam satu baris. <br><br><h4>  CSS Takeaway </h4><br>  Alangkah baiknya jika kita masih mengeluarkan CSS untuk setiap chunk di file terpisah.  Ada solusi siap pakai untuk ini - <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Mini-Css-Extract-Plugin</a></b> .  Plugin hanya muncul di Webpack 4, dan sebelum itu tidak ada solusi yang memadai untuk tugas seperti itu - hanya peretasan, rasa sakit, dan tembakan kaki.  Plugin <b>menghapus CSS dari potongan asinkron</b> dan dibuat <b>khusus untuk tugas ini</b> , yang berfungsi sempurna. <br><br><h4>  Muat ulang sumber daya seminimal mungkin </h4><br>  Kami akan mencari cara untuk memastikan bahwa saat merilis, misalnya, blok promo baru di halaman utama, pengguna <b>akan memuat ulang bagian terkecil dari kode</b> . <br><br>  Jika kami memiliki versi, semuanya akan baik-baik saja.  Di sini kita memiliki halaman utama versi N, dan setelah rilis blok promo - versi N + 1.  Webpack menyediakan mekanisme serupa langsung dari kotak menggunakan hashing.  Setelah Webpack mengumpulkan semua aset, dalam hal ini app.js, ia akan menghitung hash kontennya dan menambahkannya ke nama file untuk mendapatkan aplikasi. [Hash] .js.  Ini adalah <b>versi yang</b> kita butuhkan. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/fd1/3f2/1a9/fd13f21a9daeddd3a1af9083b8134257.png" alt="gambar"><br><br>  Mari kita periksa cara kerjanya.  Nyalakan hash, buat perubahan pada halaman utama, dan lihat apakah kode halaman utama benar-benar telah berubah. Kita akan melihat bahwa dua file telah berubah: main dan app.js. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/2a2/bc0/b44/2a2bc0b447b7baf927ac729e28ace633.png" alt="gambar"><br><br>  Mengapa ini terjadi, karena itu tidak logis?  Untuk memahami alasannya, mari kita <b>lihat app.js.</b>  Ini terdiri dari tiga bagian: <br><br><ul><li>  kode aplikasi </li><li>  runtime webpack; </li><li>  tautan ke bongkahan asinkron. </li></ul><br>  Ketika kami mengubah kode di main, isinya dan hash berubah, yang berarti bahwa <b>tautannya</b> juga berubah di app.  Aplikasi itu sendiri juga akan berubah dan harus di-boot ulang.  Solusi untuk masalah ini adalah dengan <b>membagi</b> app.js menjadi dua potongan: kode aplikasi dan runtime webpack dan tautan ke potongan asinkron.  Webpack 4 melakukan segalanya untuk kami dengan satu opsi <b>runtimeChunk</b> , yang beratnya sangat kecil - kurang dari 2 KB di gzip.  Mem-boot ulang untuk pengguna praktis tidak ada artinya.  RuntimeChunk diaktifkan hanya dengan satu opsi: <br><br><pre> <code class="javascript hljs">optimization: { <span class="hljs-attr"><span class="hljs-attr">runtimeChunk</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span> }</code> </pre><br>  Di Webpack 3 dan 2, kami akan menulis 5-6 baris, bukan satu.  Ini tidak lebih, tetapi masih merupakan ketidaknyamanan yang tidak perlu. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/6e4/125/5d8/6e41255d837ac2a5c4bb8a6e9b74f686.png" alt="gambar"><br><br>  Semuanya bagus, kami belajar membuat tautan dan runtime!  Mari kita menulis modul baru di main, lepaskan, dan - op!  - Sekarang, secara umum, semuanya restart. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/cc7/8f6/a5f/cc78f6a5f6ffcd8b2da956d5463fefc8.png" alt="gambar"><br><br>  Kenapa begitu  Mari kita lihat bagaimana modul bekerja di webpack. <br><br><h4>  Modul Webpack </h4><br>  Misalkan ada kode di mana Anda menambahkan modul <b>a</b> , <b>b</b> , <b>d,</b> dan <b>e</b> : <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> a <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'a'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> b <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'b'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> d <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'d'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> e <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'e'</span></span>;</code> </pre><br>  Webpack mengonversi impor menjadi mengharuskan: <b>a</b> , <b>b</b> , <b>d,</b> dan <b>e</b> diganti dengan mengharuskan (0), mengharuskan (1), membutuhkan (2), dan membutuhkan (3). <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> a = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> b = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> d = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-number"><span class="hljs-number">2</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> e = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-number"><span class="hljs-number">3</span></span>);</code> </pre><br>  Bayangkan sebuah gambar yang sangat sering terjadi: Anda menulis modul baru c <code>import c from 'c';</code>  dan rekatkan di suatu tempat di tengah: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> a <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'a'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> b <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'b'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> c <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'c'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> d <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'d'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> e <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'e'</span></span>;</code> </pre><br>  Ketika Webpack memproses semuanya, itu mengubah impor modul baru menjadi memerlukan (2): <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> a = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> b = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> c = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-number"><span class="hljs-number">2</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> d = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-number"><span class="hljs-number">3</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> e = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-number"><span class="hljs-number">4</span></span>);</code> </pre><br>  Modul <b>d</b> dan <b>e</b> , yang 2 dan 3, akan menerima angka 3 dan 4 - id baru.  Kesimpulan sederhana berikut dari ini: menggunakan nomor seri karena id agak konyol, tetapi Webpack melakukannya. <br><br><blockquote>  Jangan gunakan nomor seri sebagai id unik </blockquote><br>  Untuk memperbaiki masalah, ada solusi Webpack <b>bawaan</b> - <b>HashedModuleIdsPlugin</b> : <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">new</span></span> webpack.HashedModuleIdsPlugin({ <span class="hljs-attr"><span class="hljs-attr">hashFunction</span></span>: <span class="hljs-string"><span class="hljs-string">'md4â€², hashDigest:'</span></span>base64â€², <span class="hljs-attr"><span class="hljs-attr">hashDigestLength</span></span>: <span class="hljs-number"><span class="hljs-number">4</span></span>, }),</code> </pre><br>  Plugin ini menggunakan 4 karakter <b>hash md4</b> bukan id digital dari path absolut ke file.  Dengan itu, kebutuhan kami akan berubah menjadi ini: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> a = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'YmRl'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> b = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'N2Fl'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> c = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'OWE4â€²); var d = require('</span></span>NWQz<span class="hljs-string"><span class="hljs-string">'); var e = require('</span></span>YWVj<span class="hljs-string"><span class="hljs-string">');</span></span></code> </pre><br>  Alih-alih angka, surat muncul.  Tentu saja, ada masalah tersembunyi - ini adalah <b>tabrakan hash</b> .  Kami menemukan sekali dan dapat menyarankan Anda untuk menggunakan 8 karakter, bukan 4. Setelah mengkonfigurasi hash dengan benar, semuanya akan bekerja seperti yang kami inginkan. <br><br>  Kita sekarang tahu bagaimana cara mengumpulkan kumpulan mimpi. <br><br><ul><li>  <b>Minify</b> . </li><li>  <b>Gunakan pemisahan kode</b> . </li><li>  <b>Siapkan hash</b> . </li></ul><br>  Kami belajar mengumpulkan, dan sekarang kami akan bekerja dengan kecepatan. <br><br><h2>  Bagaimana cara merakit bundel impian <b>dengan cepat</b> ? </h2><br>  Di N1.RU kami, aplikasi terbesar terdiri dari 10.000 modul, dan tanpa optimasi, dibutuhkan 28 menit.  Kami dapat mempercepat perakitan menjadi dua menit!  Bagaimana kami melakukannya?  Ada 3 cara untuk mempercepat perhitungan apa pun, dan ketiganya berlaku untuk Webpack. <br><br><h3>  Paralelisasi Majelis </h3><br>  Hal pertama yang kami lakukan adalah <b>memparalelkan majelis</b> .  Untuk ini kami memiliki: <br><br><ul><li>  <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">HappyPackPlugin</a></b> , yang membungkus pemuat Anda dengan pemuat lainnya, dan mengambil semua perhitungan yang terbungkus dalam proses terpisah.  Ini memungkinkan, misalnya, memparalelkan Babel dan node-sass. </li><li>  <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">thread-loader</a></b> .  Melakukan kira-kira sama dengan HappyPackPlugin, hanya menggunakan bukan proses, tetapi kumpulan thread.  Beralih ke utas terpisah adalah operasi yang mahal, gunakan dengan hati-hati, dan hanya jika Anda ingin membungkus operasi yang intensif sumber daya dan berat, seperti babel atau node-sass.  Untuk memuat json, misalnya, paralelisasi tidak diperlukan, karena memuat cepat. </li><li>  Plugin dan pemuat yang Anda gunakan kemungkinan besar sudah memiliki <b>alat paralelisasi bawaan</b> - Anda hanya perlu melihatnya.  Misalnya, opsi ini di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">UglifyJS</a> . </li></ul><br><h3>  Caching membangun hasil </h3><br>  <b>Caching hasil perakitan</b> adalah cara paling efisien untuk mempercepat perakitan Webpack. <br><br>  Solusi pertama yang kami miliki adalah <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">cache-loader</a></b> .  Ini adalah loader yang masuk ke rantai pemuat dan menyimpan ke sistem file hasil dari membangun file tertentu untuk rantai pemuat tertentu.  Pada perakitan bundel berikutnya, jika file ini ada di sistem file dan telah diproses dengan rantai ini, cache-loader akan mengambil hasilnya dan tidak akan memanggil loader yang ada di belakangnya, misalnya, Babel-loader atau node-sass. <br><br>  Grafik menunjukkan waktu perakitan.  Bilah biru - 100% waktu pembuatan, tanpa cache-loader, dan bersamanya - 7% lebih lambat.  Ini karena cache-loader menghabiskan waktu ekstra menyimpan cache ke sistem file.  Sudah di majelis kedua, kami menerima keuntungan nyata - perakitan itu 2 kali lebih cepat. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/6bc/e73/210/6bce732104fda8263464528d91d1a8a1.png" alt="gambar"><br><br>  Solusi kedua lebih <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">canggih</a></b> - <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">HardSourcePlugin</a></b> .  Perbedaan utama: cache-loader hanyalah sebuah loader yang dapat beroperasi hanya dalam rantai loader dengan kode atau file, dan HardSourcePlugin memiliki akses hampir penuh ke ekosistem Webpack, dapat beroperasi dengan plugins dan loader lainnya, dan memperluas ekosistem untuk caching sedikit.  Grafik di atas menunjukkan bahwa pada peluncuran pertama, waktu build meningkat sebesar 37%, tetapi pada peluncuran kedua dengan semua cache, kami mempercepat 5 kali. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/cb6/acf/d36/cb6acfd36adbaaadffd68af19889f960.png" alt="gambar"><br><br>  Bagian terbaiknya adalah Anda dapat menggunakan kedua solusi secara bersamaan, yang kami lakukan di N1.RU.  Hati-hati, karena ada masalah dengan cache, yang akan saya bahas nanti. <br><br>  Plugin / loader yang sudah Anda gunakan mungkin memiliki <b>mekanisme caching bawaan</b> .  Sebagai contoh, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">babel-loader memiliki</a> sistem caching yang sangat efisien, tetapi karena alasan tertentu dimatikan secara default.  Fungsionalitas yang sama ada di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">mengagumkan-typeScript-loader</a> .  Plugin <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">UglifyJS</a> juga memiliki caching, yang sangat bagus.  Dia mempercepat kami beberapa menit. <br><br>  Dan sekarang masalahnya. <br><br><h4>  Masalah caching </h4><br><ul><li>  Cache mungkin <b>tidak divalidasi dengan benar</b> . </li><li>  Solusi yang diterapkan mungkin <b>tidak berfungsi dengan plugin, loader, kode Anda yang terhubung, atau satu sama lain</b> .  Dalam hal ini, cache-loader adalah solusi sederhana dan tidak repot.  Tetapi dengan HardSourcePlugin Anda harus lebih berhati-hati. </li><li>  <b>Sulit untuk debut jika semuanya rusak</b> .  Ketika caching tidak berfungsi dengan benar dan terjadi kesalahan yang tidak dapat dipahami, akan sangat sulit untuk mencari tahu apa masalahnya. </li></ul><br><h3>  Bagaimana cara menghemat produksi? </h3><br>  Cara terakhir untuk mempercepat suatu proses adalah tidak melakukan bagian apa pun dari proses tersebut.  Mari kita pikirkan bagaimana Anda dapat menghemat produksi?  Apa yang tidak bisa kita lakukan?  Jawabannya pendek - <b>kita tidak bisa melakukan apa-apa</b> !  Kami tidak punya hak untuk menolak sesuatu dalam produksi, tetapi kami dapat menghemat banyak dalam <b>dev</b> . <br><br>  Apa yang harus dihemat: <br><br><ul><li>  <b>Jangan kumpulkan peta sumber</b> sampai kami membutuhkannya. </li><li>  <b>Gunakan style-loader</b> alih <b>-</b> alih skema keren dengan penghapusan dan pemrosesan css melalui loader css.  Style-loader itu sendiri sangat cepat, karena mengambil garis css dan mendorongnya ke fungsi yang memasukkan garis itu ke dalam tag gaya. </li><li>  <b>Anda dapat meninggalkan dalam daftar browser hanya browser yang Anda gunakan secara khusus - kemungkinan besar ini adalah chrome terakhir</b> .  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Ini akan sangat mempercepat</a> . </li><li>  <b>Benar-benar meninggalkan segala optimasi sumber daya</b> : dari UglifyJS, css-nano, gzip / brotli. </li></ul><br><blockquote>  Akselerasi build adalah paralelisasi, caching dan penolakan perhitungan.  Dengan mengikuti tiga langkah sederhana ini, Anda dapat mempercepat sangat banyak. </blockquote><br><h2>  Bagaimana cara mengkonfigurasi webpack? </h2><br>  Kami menemukan cara merakit bundel mimpi dan cara merakitnya dengan cepat, dan sekarang kami akan mencari cara mengonfigurasi Webpack sehingga kami tidak menembak diri sendiri setiap kali Anda mengubah konfigurasi. <br><br><h3>  Konfigurasi evolusi dalam proyek </h3><br>  Jalur webpack-config pada proyek dimulai dengan konfigurasi <b>sederhana</b> .  Pada awalnya Anda hanya memasukkan Webpack, Babel-loader, sass-loader dan semuanya baik-baik saja.  Kemudian, tiba-tiba, beberapa <b>kondisi</b> muncul <b>di process.env</b> , dan Anda memasukkan persyaratan.  Satu, kedua, ketiga, lebih dan lebih, sampai suatu kondisi dengan opsi "ajaib" ditambahkan.  Anda mengerti bahwa semuanya sudah sangat buruk, dan lebih baik <b>duplikat konfigurasi</b> untuk dev dan produksi, dan lakukan koreksi dua kali.  Semuanya akan lebih jelas.  Jika Anda memiliki pemikiran: "Apakah ada yang salah di sini?", Maka satu-satunya saran yang bekerja adalah <b>untuk menjaga konfigurasi</b> .  Saya akan memberi tahu Anda bagaimana kami melakukannya. <br><br><h3>  Pertahankan konfigurasi </h3><br>  Kami menggunakan paket <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">webpack-merge</a></b> .  Ini adalah paket npm yang dibuat untuk menggabungkan beberapa konfigurasi menjadi satu.  Jika Anda tidak nyaman dengan strategi penggabungan default, Anda dapat menyesuaikannya. <br><br><h3>     </h3><br>    4  : <br><br><ul><li> Loaders. </li><li> Plugins. </li><li> Presets. </li><li> Parts. </li></ul><br>    . <br><br><h4> Plugin/Loader </h4><br>  ,        ,       API,  ,      . <br><br>  Itu terlihat seperti ini: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">/** *  JSdoc * @param {Object} options * @see    */</span></span> <span class="hljs-built_in"><span class="hljs-built_in">module</span></span>.exports = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createPlugin</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">options</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Plugin(options); };</code> </pre><br>  ,   ,   ,   .    ,       url-loader  : <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">/** * url-loader    file-loader.        * * @example * -   some-image.png.     url-loader,  url-loader    * 1.    ,  url-loader    base64  * 2. , url-loader    outputPath + name     ,     . *    some-image.png,     outputPath/images/some-image.12345678hash.png,  url-loader  * publicPath/images/some-image.12345678hash.png * * @param {string} prefix    * @param {number} limit    ,    * @return {Object} loader   * @see https://www.npmjs.com/package/url-loader */</span></span></code> </pre><br>     ,   ,  , ,    ,   ,     .  ,  ,   ,  ,   url-loader.    : <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">urlLoader</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">prefix = </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">'assets'</span></span></span></span><span class="hljs-function"><span class="hljs-params">, limit = </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">100</span></span></span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { <span class="hljs-attr"><span class="hljs-attr">loader</span></span>: <span class="hljs-string"><span class="hljs-string">'url-loader'</span></span>, <span class="hljs-attr"><span class="hljs-attr">options</span></span>: { limit, <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">`</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${prefix}</span></span></span><span class="hljs-string">/[name].[hash].[ext]`</span></span> } }; };</code> </pre><br>         .    ,   Loader         . <br><br><h4> Preset </h4><br>    webpack.     ,      ,    ,   webpack,    .    â€”  ,  ,    scss-: <br><br><pre> <code class="javascript hljs">{ <span class="hljs-attr"><span class="hljs-attr">test</span></span>: <span class="hljs-regexp"><span class="hljs-regexp">/\.scss$/</span></span>, <span class="hljs-attr"><span class="hljs-attr">use</span></span>: [cssLoader, postCssLoader, scssLoader] }</code> </pre><br>     . <br><br><h4> Part </h4><br>  â€”  ,      .        ,       ,   .  ,       : <br><br><pre> <code class="javascript hljs">entry: { <span class="hljs-attr"><span class="hljs-attr">app</span></span>: <span class="hljs-string"><span class="hljs-string">'./src/Frontend/app.js'</span></span> }, <span class="hljs-attr"><span class="hljs-attr">output</span></span>: { <span class="hljs-attr"><span class="hljs-attr">publicPath</span></span>: <span class="hljs-string"><span class="hljs-string">'/static/cabinet/app/'</span></span>, <span class="hljs-attr"><span class="hljs-attr">path</span></span>: path.resolve(<span class="hljs-string"><span class="hljs-string">'www/static/app'</span></span>) },</code> </pre><br>     : <br><br><ul><li> <b> </b> ,   ,   , json,     , , splitChunks. </li><li> <b>  dev</b> ,  ,    js/css     </li><li> <b>Part</b> ,   output, publicPath, entry-point    , ,    source map. </li></ul><br><img src="https://habrastorage.org/getpro/habr/post_images/7ee/20f/fa6/7ee20ffa6f453c35f11d92e3583d8caf.png" alt="gambar"><br><br> <b>Webpack-merge</b>     .          ,     .  webpack-merge     3-7 ,    Babel-loader,            .    ,   . <br><br><h3>   </h3><br>  . <b>  </b> ,    . <b> </b> ,   webpack       â€”     . <b>  </b> ,  . <br><br>   ,    ! <br><br><blockquote>   â€”     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Frontend Conf</a> . ,    â€”  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="> </a> ,           ,    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Frontend Conf ++</a>  . <br><br>    -      ?    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">FrontenConf ++</a> ,   27  28   . <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="> </a>  27 ,   15          .     â€” ! </blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id433324/">https://habr.com/ru/post/id433324/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id433308/index.html">Mentransfer konfigurasi PBX ke layanan 3CX PBX Express</a></li>
<li><a href="../id433316/index.html">Intisari desain: orientasi, umpan balik, cari ide dan pengambilan keputusan</a></li>
<li><a href="../id433318/index.html">garbage.collect ()</a></li>
<li><a href="../id433320/index.html">Layout Grid sebagai dasar dari layout modern</a></li>
<li><a href="../id433322/index.html">API JSON - kami bekerja sesuai dengan spesifikasi</a></li>
<li><a href="../id433326/index.html">Kualitas kode</a></li>
<li><a href="../id433328/index.html">Lebih baik kehilangan sehari</a></li>
<li><a href="../id433330/index.html">Pecahkan teka-teki silang Jepang dengan SAT Solver</a></li>
<li><a href="../id433332/index.html">Dukungan Python di Fungsi Azure</a></li>
<li><a href="../id433334/index.html">Perilaku XAML untuk WPF sekarang adalah Open Source</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>