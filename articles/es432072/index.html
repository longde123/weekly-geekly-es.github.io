<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üå®Ô∏è üèçÔ∏è üë®üèæ‚Äçü§ù‚Äçüë®üèº Tres tipos de p√©rdidas de memoria üêû üìø üë©üèª‚Äçüé®</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hola colegas 

 Nuestra larga b√∫squeda de los libros m√°s vendidos y atemporales sobre optimizaci√≥n de c√≥digo solo ha dado los primeros resultados, per...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Tres tipos de p√©rdidas de memoria</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/piter/blog/432072/"> Hola colegas <br><br>  Nuestra larga b√∫squeda de los libros m√°s vendidos y atemporales sobre optimizaci√≥n de c√≥digo solo ha dado los primeros resultados, pero estamos listos para complacerle en que la traducci√≥n del legendario libro de Ben Watson " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Escritura de c√≥digo .NET de alto rendimiento</a> " se ha completado literalmente.  En las tiendas, tentativamente en abril, est√© atento a la publicidad. <br><br>  Y hoy le ofrecemos leer un art√≠culo puramente pr√°ctico sobre los tipos m√°s apremiantes de p√©rdidas de memoria, escrito por <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Nelson Ilheidzhe</a> (Strike). <br><a name="habracut"></a><br>  Por lo tanto, tiene un programa que tarda m√°s en completarse, cuanto m√°s tarde.  Probablemente, no ser√° dif√≠cil para usted comprender que este es un signo seguro de una p√©rdida de memoria. <br>  Sin embargo, ¬øqu√© queremos decir exactamente con "p√©rdida de memoria"?  En mi experiencia, las p√©rdidas de memoria expl√≠citas se dividen en tres categor√≠as principales, cada una de las cuales se caracteriza por un comportamiento especial, y para depurar cada una de las categor√≠as se necesitan herramientas y t√©cnicas especiales.  En este art√≠culo quiero describir las tres clases y sugerir c√≥mo reconocer correctamente, con <br>  con qu√© clase est√° tratando y c√≥mo encontrar una fuga. <br><br>  Tipo (1): fragmento de memoria inalcanzable asignado <br><br>  Esta es una p√©rdida de memoria cl√°sica en C / C ++.  Alguien asign√≥ memoria usando <code>new</code> o <code>malloc</code> , y no llam√≥ a <code>free</code> o <code>delete</code> para liberar memoria despu√©s de terminar de trabajar con ella. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">leak_memory</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *leaked = <span class="hljs-built_in"><span class="hljs-built_in">malloc</span></span>(<span class="hljs-number"><span class="hljs-number">4096</span></span>); use_a_buffer(leaked); <span class="hljs-comment"><span class="hljs-comment">/* ,   free() */</span></span> }</code> </pre> <br>  <i>C√≥mo determinar si una fuga pertenece a esta categor√≠a</i> <br><br><ul><li>  Si escribe en C o C ++, especialmente en C ++ sin el uso generalizado de punteros inteligentes para controlar la vida √∫til de los segmentos de memoria, esta es la opci√≥n que estamos considerando primero. </li><li>  Si el programa se ejecuta en un entorno con recolecci√≥n de basura, es posible que una <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">extensi√≥n de c√≥digo nativo</a> provoque una fuga de este tipo, sin embargo, primero se deben eliminar las fugas de los tipos (2) y (3). </li></ul><br>  <i>C√≥mo encontrar una fuga</i> <br><br><ul><li>  Utiliza <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">ASAN</a> .  Utiliza ASAN.  Utiliza ASAN. </li><li>  Usa un detector diferente.  Prob√© las herramientas Valgrind o tcmalloc para trabajar con un grupo, tambi√©n hay otras herramientas en otros entornos. </li><li>  Algunos asignadores de memoria permiten volcar el perfil de almacenamiento din√°mico, que mostrar√° todas las √°reas de memoria no asignadas.  Si tiene una fuga, luego de un tiempo, casi todas las descargas activas fluir√°n de ella, por lo que encontrarla probablemente no sea dif√≠cil. </li><li>  Si todo lo dem√°s falla, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">volcar un volcado de memoria y examinarlo tan meticulosamente como sea posible</a> .  Pero definitivamente no deber√≠a comenzar con esto. </li></ul><br>  <b>Tipo (2): asignaciones de memoria de larga duraci√≥n no planificadas</b> <br><br>  Tales situaciones no son "fugas" en el sentido cl√°sico de la palabra, ya que todav√≠a se conserva un enlace desde alg√∫n lugar a este fragmento de memoria, por lo que al final puede liberarse (si el programa logra llegar all√≠ sin usar toda la memoria). <br>  Las situaciones en esta categor√≠a pueden surgir por muchas razones espec√≠ficas.  Los m√°s comunes son: <br><br><ul><li>  Acumulaci√≥n involuntaria de estado en una estructura global;  por ejemplo, el servidor HTTP escribe en la lista global cada objeto <code>Request</code> recibido. </li><li>  Cach√©s sin una pol√≠tica de obsolescencia bien pensada.  Por ejemplo, un cach√© ORM que almacena en cach√© cada objeto cargado, activo durante la migraci√≥n, en el que todos los registros que est√°n presentes en la tabla se cargan sin excepci√≥n. </li><li>  Estado demasiado voluminoso se captura en el circuito.  Este caso es <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">especialmente com√∫n</a> en Java Script, pero tambi√©n puede ocurrir en otros entornos. </li><li>  En un sentido m√°s amplio, la retenci√≥n involuntaria de cada elemento de una matriz o secuencia, mientras se supon√≠a que estos elementos se procesar√≠an en l√≠nea. </li></ul><br>  <i>C√≥mo determinar si una fuga pertenece a esta categor√≠a</i> <br><br><ul><li>  Si el programa se ejecuta en un entorno con recolecci√≥n de basura, entonces esta es la opci√≥n que estamos considerando primero. </li><li>  Compare el tama√±o de almacenamiento din√°mico que se muestra en las estad√≠sticas del recolector de basura con el tama√±o de la memoria libre generada por el sistema operativo.  Si una fuga entra en esta categor√≠a, los n√∫meros ser√°n comparables y, lo m√°s importante, se seguir√°n con el tiempo. </li></ul><br>  <i>C√≥mo encontrar una fuga</i> <br><br>  Utilice los perfiladores o las herramientas de volcado de almacenamiento din√°mico disponibles en su entorno.  S√© que hay <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">guppy</a> en Python o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">memory_profiler</a> en Ruby, y tambi√©n escrib√≠ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">ObjectSpace</a> directamente en Ruby. <br><br>  <b>Tipo (3): memoria libre pero no utilizada o inutilizable</b> <br><br>  Esta categor√≠a es m√°s dif√≠cil de caracterizar, pero es precisamente la m√°s importante de entender y tener en cuenta. <br><br>  Las fugas de este tipo ocurren en la zona gris, entre la memoria que se considera "libre" desde el punto de vista del asignador dentro de la VM o el entorno de tiempo de ejecuci√≥n, y la memoria que est√° "libre" desde el punto de vista del sistema operativo.  La raz√≥n m√°s com√∫n (pero no la √∫nica) de este fen√≥meno es la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">fragmentaci√≥n del mont√≥n</a> .  Algunos asignadores simplemente toman y no devuelven memoria al sistema operativo despu√©s de que se haya asignado. <br><br>  Un caso de este tipo puede considerarse con un ejemplo de un programa corto escrito en Python: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> sys <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> guppy <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> hpy hp = hpy() <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">rss</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">4096</span></span> * int(open(<span class="hljs-string"><span class="hljs-string">'/proc/self/stat'</span></span>).read().split(<span class="hljs-string"><span class="hljs-string">' '</span></span>)[<span class="hljs-number"><span class="hljs-number">23</span></span>]) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">gcsize</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> hp.heap().size rss0, gc0 = (rss(), gcsize()) buf = [bytearray(<span class="hljs-number"><span class="hljs-number">1024</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">200</span></span>*<span class="hljs-number"><span class="hljs-number">1024</span></span>)] print(<span class="hljs-string"><span class="hljs-string">"start rss={} gcsize={}"</span></span>.format(rss()-rss0, gcsize()-gc0)) buf = buf[::<span class="hljs-number"><span class="hljs-number">2</span></span>] print(<span class="hljs-string"><span class="hljs-string">"end rss={} gcsize={}"</span></span>.format(rss()-rss0, gcsize()-gc0))</code> </pre> <br>  Asignamos 200,000 buffers de 1 kb y luego guardamos cada uno de ellos.  Cada segundo, mostramos el estado de la memoria desde el punto de vista del sistema operativo y desde el punto de vista de nuestro propio recolector de basura Python. <br><br>  En mi computadora port√°til, obtengo algo como esto: <br><br> <code>start rss=232222720 gcsize=11667592 <br> end rss=232222720 gcsize=5769520</code> <br> <br>  Podemos asegurarnos de que Python realmente liber√≥ la mitad de los b√∫feres, porque el nivel de gcsize cay√≥ casi la mitad del valor m√°ximo, pero no pudo devolver un byte de esta memoria al sistema operativo.  La memoria liberada permanece accesible para el mismo proceso de Python, pero no para cualquier otro proceso en esta m√°quina. <br><br>  Tales fragmentos de memoria libres pero no utilizados pueden ser problem√°ticos e inofensivos.  Si un programa Python act√∫a de esta manera y luego asigna un pu√±ado de fragmentos de 1 kb, entonces este espacio simplemente se reutiliza y todo est√° bien. <br><br>  Pero, si hicimos esto durante la configuraci√≥n inicial, y posteriormente asignamos memoria al m√≠nimo, o si todos los fragmentos asignados posteriormente eran 1.5kb cada uno y no cab√≠an en estos b√∫feres dejados de antemano, entonces toda la memoria asignada de esta manera siempre estar√≠a inactiva Ser√≠a desperdiciado. <br><br>  Los problemas de este tipo son especialmente relevantes en un entorno espec√≠fico, a saber, en sistemas de servidores multiproceso para trabajar con lenguajes como Ruby o Python. <br><br>  Digamos que configuramos un sistema en el que: <br><br><ul><li>  En cada servidor, se utilizan N trabajadores de subproceso √∫nico para atender de manera competente las solicitudes.  Tomemos N = 10 para mayor precisi√≥n. </li><li>  Como regla general, cada empleado tiene una cantidad casi constante de memoria.  Para mayor precisi√≥n, tomemos 500MB. </li><li>  Con poca frecuencia, recibimos solicitudes que requieren mucha m√°s memoria que la solicitud mediana.  Para mayor precisi√≥n, supongamos que una vez por minuto recibimos una solicitud, cuyo tiempo de ejecuci√≥n requiere adem√°s 1 GB de memoria adicional, y cuando se procesa la solicitud, esta memoria se libera. </li></ul><br>  Una vez por minuto, llega una solicitud de "cet√°ceo", cuyo procesamiento confiamos a uno de los 10 trabajadores, por ejemplo, al azar: <code>~random</code> .  Idealmente, durante el procesamiento de esta solicitud, este empleado debe asignar 1 GB de RAM y, despu√©s del final del trabajo, devolver esta memoria al sistema operativo para que pueda reutilizarse m√°s tarde.  Para procesar solicitudes de forma ilimitada por este principio, el servidor necesitar√° solo 10 * 500MB + 1GB = 6GB RAM. <br><br>  Sin embargo, supongamos que debido a la fragmentaci√≥n o por alguna otra raz√≥n, la m√°quina virtual nunca podr√° devolver esta memoria al sistema operativo.  Es decir, la cantidad de RAM que requiere del sistema operativo es igual a la mayor cantidad de memoria que tiene que asignar a la vez.  En este caso, cuando un empleado en particular atiende una solicitud de uso intensivo de recursos, el √°rea ocupada por dicho proceso en la memoria aumentar√° para siempre en un gigabyte completo. <br><br>  Cuando inicie el servidor, ver√° que la cantidad de memoria utilizada es 10 * 500MB = 5GB.  Tan pronto como llega la primera solicitud grande, el primer trabajador ocupa 1 GB de memoria y luego no la devuelve.  La cantidad total de memoria utilizada saltar√° a 6GB.  En ocasiones, las siguientes solicitudes entrantes pueden ser redirigidas al proceso que proces√≥ previamente la "ballena", en cuyo caso la cantidad de memoria utilizada no cambiar√°.  Pero a veces una solicitud tan grande se entregar√° a otro empleado, por lo que la memoria se inflar√° por otro 1 GB, y as√≠ sucesivamente hasta que cada empleado tenga la oportunidad de procesar una solicitud tan grande al menos una vez.  En este caso, tomar√° hasta 10 * (500MB + 1GB) = 15GB de RAM con estas operaciones, ¬°lo cual es mucho m√°s que los 6GB ideales!  Adem√°s, si considera c√≥mo se utiliza la flota de servidores a lo largo del tiempo, puede ver c√≥mo la cantidad de memoria utilizada aumenta gradualmente de 5 GB a 15 GB, lo que ser√° muy similar a una fuga "real". <br><br>  <i>C√≥mo determinar si una fuga pertenece a esta categor√≠a</i> <br><br><ul><li>  Compare el tama√±o de almacenamiento din√°mico que se muestra en las estad√≠sticas del recolector de basura con el tama√±o de la memoria libre generada por el sistema operativo.  Si la fuga pertenece a esta (tercera) categor√≠a, los n√∫meros divergir√°n con el tiempo. </li><li>  Me gusta configurar mis servidores de aplicaciones para que ambos n√∫meros se apaguen peri√≥dicamente en mi infraestructura de series temporales, por lo que es conveniente mostrar gr√°ficos en ellos. </li><li>  En Linux, vea el estado del sistema operativo en el campo 24 de <code>/proc/self/stat</code> , y vea el asignador de memoria a trav√©s de un lenguaje o API espec√≠fica de m√°quina virtual. </li></ul><br>  <i>C√≥mo encontrar una fuga</i> <br><br>  Como ya se mencion√≥, esta categor√≠a es un poco m√°s insidiosa que las anteriores, ya que el problema a menudo surge incluso cuando todos los componentes funcionan "seg√∫n lo previsto".  Sin embargo, hay varios trucos √∫tiles para ayudar a mitigar o reducir el impacto de tales "fugas virtuales": <br><br><ul><li>  Reinicie sus procesos con m√°s frecuencia.  Si el problema crece lentamente, quiz√°s no sea dif√≠cil reiniciar todos los procesos de aplicaci√≥n una vez cada 15 minutos o una vez por hora. </li><li>  Un enfoque a√∫n m√°s radical: puede ense√±ar a todos los procesos a reiniciarse de forma independiente, tan pronto como el espacio que ocupan en la memoria exceda un cierto valor umbral o crezca en un valor predeterminado.  Sin embargo, intente prever que toda su flota de servidores no pueda iniciar un reinicio s√≠ncrono espont√°neo. </li><li>  Cambiar el asignador de memoria.  A la larga, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">tcmalloc</a> y <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">jemalloc</a> generalmente <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">manejan la</a> fragmentaci√≥n mucho mejor que el asignador predeterminado, y experimentar con ellos es muy conveniente usando la variable <code>LD_PRELOAD</code> . </li><li>  Averig√ºe si tiene consultas individuales que consumen mucha m√°s memoria que el resto.  En Stripe, nuestros servidores API miden RSS (consumo de memoria constante) antes y despu√©s de atender cada solicitud de API y registran el delta.  Luego, consultamos f√°cilmente nuestros sistemas de agregaci√≥n de registros para determinar si existen tales terminales y usuarios (y patrones) que se pueden usar para cancelar las r√°fagas de consumo de memoria. </li><li>  Ajuste el recolector de basura / asignador de memoria.  Muchos de ellos tienen par√°metros personalizables que le permiten especificar qu√© tan activamente dicho mecanismo devolver√° la memoria al sistema operativo, qu√© tan optimizado est√° para eliminar la fragmentaci√≥n;  Hay otras opciones √∫tiles.  Todo aqu√≠ tambi√©n es bastante complicado: aseg√∫rese de comprender exactamente lo que est√° midiendo y optimizando, y tambi√©n trate de encontrar un experto en la m√°quina virtual adecuada y consulte con √©l. </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es432072/">https://habr.com/ru/post/es432072/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es432060/index.html">Las mejores formas de memorizar palabras en ingl√©s</a></li>
<li><a href="../es432062/index.html">Desarrollo de IA usando el ejemplo del juego Dicey Dungeons</a></li>
<li><a href="../es432064/index.html">C√≥mo escapar de las "liebres". Instrucci√≥n UV</a></li>
<li><a href="../es432068/index.html">C√≥mo facilitar el estudio del ingl√©s: 5 servicios √∫tiles</a></li>
<li><a href="../es432070/index.html">Brevemente sobre los canales redux-saga</a></li>
<li><a href="../es432074/index.html">C√≥mo los jugadores rasgan la tela de realidad Spelunky con escopetas</a></li>
<li><a href="../es432076/index.html">La funci√≥n no reconocida ralentiza el programa 5 veces</a></li>
<li><a href="../es432078/index.html">Tr√°fico al final del t√∫nel o DNS en el pentest</a></li>
<li><a href="../es432080/index.html">Las ideas err√≥neas de los jugadores al evaluar los riesgos. Control del generador de n√∫meros aleatorios en desarrollo.</a></li>
<li><a href="../es432082/index.html">Microsoft AI Chatbot lanza la colecci√≥n de ropa de China</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>