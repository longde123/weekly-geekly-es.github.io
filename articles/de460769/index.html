<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üöµüèΩ üë®üèΩ‚Äç‚öñÔ∏è ü§µüèΩ Konfigurieren eines Servers zum Bereitstellen einer Rails-Anwendung mit Ansible ‚ö±Ô∏è ‚úä üôãüèª</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Vor nicht allzu langer Zeit musste ich mehrere ansible Playbooks schreiben, um den Server auf die Bereitstellung der Rails-Anwendung vorzubereiten. Un...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Konfigurieren eines Servers zum Bereitstellen einer Rails-Anwendung mit Ansible</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/460769/"><p>  Vor nicht allzu langer Zeit musste ich mehrere ansible Playbooks schreiben, um den Server auf die Bereitstellung der Rails-Anwendung vorzubereiten.  Und √ºberraschenderweise fand ich kein einfaches Schritt-f√ºr-Schritt-Handbuch.  Ich wollte nicht das Spielbuch eines anderen kopieren, ohne zu verstehen, was geschah, und musste daher die Dokumentation lesen und alles selbst sammeln.  Vielleicht kann mir jemand helfen, diesen Prozess mit diesem Artikel zu beschleunigen. </p><br><p>  Das erste, was Sie verstehen m√ºssen, ist, dass ansible Ihnen eine praktische Schnittstelle bietet, √ºber die Sie eine vordefinierte Liste von Aktionen auf den Remote-Servern √ºber SSH ausf√ºhren k√∂nnen.  Hier gibt es keine Magie. Sie k√∂nnen das Plugin nicht installieren und aus der Null-Ausfallzeit-Box eine Bereitstellung Ihrer Anwendung mit Docker, √úberwachung und anderen Extras herausholen.  Um ein Spielbuch zu schreiben, m√ºssen Sie genau wissen, was Sie tun m√∂chten und wie es geht.  Daher mag ich keine vorgefertigten Spielb√ºcher aus dem Github oder Artikel wie: "Kopieren und ausf√ºhren, es wird funktionieren." </p><a name="habracut"></a><br><h2 id="chto-nam-nuzhno">  Was brauchen wir </h2><br><p>  Wie gesagt, um ein Spielbuch zu schreiben, muss man wissen, was man machen will und wie man es macht.  Lassen Sie uns entscheiden, was wir brauchen.  F√ºr eine Rails-Anwendung ben√∂tigen wir mehrere Systempakete: nginx, postgresql (redis usw.).  Dar√ºber hinaus ben√∂tigen wir Ruby einer bestimmten Version.  Es ist am besten, es √ºber rbenv (rvm, asdf ...) zu installieren.  Es ist immer eine schlechte Idee, all dies vom Stammverzeichnis des Benutzers aus auszuf√ºhren. Sie m√ºssen daher einen separaten Benutzer erstellen und die Rechte f√ºr ihn konfigurieren.  Danach m√ºssen Sie unseren Code auf den Server hochladen, die Konfigurationen f√ºr Nginx, Postgres usw. kopieren und alle diese Dienste ausf√ºhren. </p><br><p>  <strong>Infolgedessen ist die Reihenfolge der Aktionen wie folgt:</strong> </p><br><ol><li>  Melden Sie sich als root an </li><li>  Installieren Sie Systempakete </li><li>  Erstellen Sie einen neuen Benutzer, konfigurieren Sie die Rechte und den SSH-Schl√ºssel </li><li>  Konfigurieren Sie Systempakete (Nginx usw.) und f√ºhren Sie sie aus </li><li>  Erstellen Sie einen Benutzer in der Datenbank (Sie k√∂nnen sofort eine Datenbank erstellen) </li><li>  Melden Sie sich als neuer Benutzer an </li><li>  Installieren Sie rbenv und ruby </li><li>  Installieren Sie den Bundler </li><li>  Geben Sie den Anwendungscode ein </li><li>  Wir starten den Puma-Server </li></ol><br><p>  Dar√ºber hinaus k√∂nnen die letzten Schritte mit capistrano ausgef√ºhrt werden. Zumindest kann sie den Code aus der Box in Release-Verzeichnisse kopieren, das Release bei einer erfolgreichen Bereitstellung mit einem Symlink wechseln, Konfigurationen aus dem freigegebenen Verzeichnis kopieren, Puma neu starten usw.  All dies kann mit Ansible gemacht werden, aber warum? </p><br><h2 id="faylovaya-struktura">  Dateistruktur </h2><br><p>  Ansible hat eine strenge <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Dateistruktur</a> f√ºr alle Dateien. Bewahren Sie diese daher am besten in einem separaten Verzeichnis auf.  Und es ist nicht so wichtig, ob es in der Schienenanwendung selbst oder separat sein wird.  Sie k√∂nnen Dateien in einem separaten Git-Repository speichern.  Pers√∂nlich war es f√ºr mich am bequemsten, das ansible-Verzeichnis in / config des Rails-Verzeichnisses der Anwendung zu erstellen und alles in einem Repository zu speichern. </p><br><h3 id="simple-playbook">  Einfaches Spielbuch </h3><br><p>  Playbook ist eine yml-Datei, die beschreibt, was und wie ansible mit einer speziellen Syntax tun soll.  Lassen Sie uns das erste Spielbuch erstellen, das nichts tut: </p><br><pre><code class="plaintext hljs">--- - name: Simple playbook hosts: all</code> </pre> <br><p>  Hier sagen wir einfach, dass unser Playbook <code>Simple Playbook</code> und dass sein Inhalt f√ºr alle Hosts ausgef√ºhrt werden sollte.  Wir k√∂nnen es im Verzeichnis / ansible unter dem Namen playbook.yml speichern und versuchen, Folgendes auszuf√ºhren: </p><br><pre> <code class="plaintext hljs">ansible-playbook ./playbook.yml PLAY [Simple Playbook] ************************************************************************************************************************************ skipping: no hosts matched</code> </pre> <br><p>  Ansible sagt, dass es keine Hosts kennt, die mit der Liste aller √ºbereinstimmen.  Sie m√ºssen in einer speziellen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Inventardatei aufgef√ºhrt sein</a> . </p><br><p>  Lassen Sie es uns im selben ansible Verzeichnis erstellen: </p><br><pre> <code class="plaintext hljs">123.123.123.123</code> </pre> <br><p>  Geben Sie einfach den Host an (idealerweise den Host Ihres VPS f√ºr Tests, oder Sie k√∂nnen localhost registrieren) und speichern Sie ihn unter dem <code>inventory</code> . <br>  Sie k√∂nnen versuchen, ansible mit einer Invetory-Datei auszuf√ºhren: </p><br><pre> <code class="plaintext hljs">ansible-playbook ./playbook.yml -i inventory PLAY [Simple Playbook] ************************************************************************************************************************************ TASK [Gathering Facts] ************************************************************************************************************************************ PLAY RECAP ************************************************************************************************************************************</code> </pre> <br><p>  Wenn Sie SSH-Zugriff auf den angegebenen Host haben, stellt ansible eine Verbindung her und sammelt Informationen √ºber das Remote-System.  (Standardaufgabe [Sammeln von Fakten]) Danach wird ein kurzer Fortschrittsbericht (PLAY RECAP) angezeigt. </p><br><p>  Standardm√§√üig wird f√ºr die Verbindung der Benutzername verwendet, unter dem Sie am System angemeldet sind.  Es wird h√∂chstwahrscheinlich nicht auf dem Host sein.  In der Playbook-Datei k√∂nnen Sie mithilfe der Anweisung remote_user angeben, mit welchem ‚Äã‚ÄãBenutzer eine Verbindung hergestellt werden soll.  Au√üerdem sind Informationen zu einem Remote-System f√ºr Sie h√§ufig nicht erforderlich, und Sie sollten keine Zeit damit verschwenden, sie zu sammeln.  Sie k√∂nnen diese Aufgabe auch deaktivieren: </p><br><pre> <code class="plaintext hljs">--- - name: Simple playbook hosts: all remote_user: root become: true gather_facts: no</code> </pre> <br><p>  Versuchen Sie erneut, das Playbook auszuf√ºhren, und stellen Sie sicher, dass die Verbindung funktioniert.  (Wenn Sie das Stammverzeichnis des Benutzers angegeben haben, m√ºssen Sie auch die Anweisung get: true angeben, um erh√∂hte Rechte zu erhalten. Wie in der Dokumentation angegeben: <code>become set to 'true'/'yes' to activate privilege escalation.</code> Es ist jedoch nicht klar, warum) . </p><br><p>  M√∂glicherweise erhalten Sie einen Fehler, der durch den Ansible verursacht wird, den der Python-Interpreter nicht ermitteln kann. Anschlie√üend k√∂nnen Sie ihn manuell angeben: </p><br><pre> <code class="plaintext hljs">ansible_python_interpreter: /usr/bin/python3</code> </pre> <br><p>  Wo Sie Python haben, k√∂nnen Sie mit dem Befehl <code>whereis python</code> . </p><br><h3 id="ustanovka-sistemnyh-paketov">  Installieren Sie Systempakete </h3><br><p>  Ansible enth√§lt viele Module f√ºr die Arbeit mit verschiedenen Systempaketen, sodass wir aus keinem Grund Bash-Skripte schreiben m√ºssen.  Jetzt ben√∂tigen wir eines dieser Module, um das System zu aktualisieren und Systempakete zu installieren.  Ich habe Ubuntu Linux auf VPS, um Pakete zu installieren, benutze ich <code>apt-get</code> und ein <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Modul daf√ºr</a> .  Wenn Sie ein anderes Betriebssystem verwenden, ben√∂tigen Sie m√∂glicherweise ein anderes Modul (denken Sie daran, ich habe zu Beginn gesagt, dass wir im Voraus wissen m√ºssen, was und wie wir tun werden).  Die Syntax ist jedoch wahrscheinlich √§hnlich. </p><br><p>  Wir erg√§nzen unser Spielbuch mit den ersten Aufgaben: </p><br><pre> <code class="plaintext hljs">--- - name: Simple playbook hosts: all remote_user: root become: true gather_facts: no tasks: - name: Update system apt: update_cache=yes - name: Install system dependencies apt: name: git,nginx,redis,postgresql,postgresql-contrib state: present</code> </pre> <br><p>  Aufgabe ist nur die Aufgabe, die ansible auf Remote-Servern ausf√ºhrt.  Wir geben der Aufgabe einen Namen, um ihren Fortschritt im Protokoll zu verfolgen.  Und wir beschreiben anhand der Syntax eines bestimmten Moduls, was es tun muss.  In diesem Fall <code>apt: update_cache=yes</code> - Aktualisierung der Systempakete mithilfe des apt-Moduls.  Das zweite Team ist etwas komplizierter.  Wir √ºbergeben die Liste der Pakete an das apt-Modul und sagen, dass ihr Status <code>present</code> soll, dh wir sagen, dass diese Pakete installiert werden sollen.  Ebenso k√∂nnen wir ihnen mitteilen, dass sie einfach durch √Ñndern des <code>state</code> gel√∂scht oder aktualisiert werden sollen.  Bitte beachten Sie, dass f√ºr die Verwendung von Rails mit Postgresql das derzeit installierte Postgresql-Contrib-Paket erforderlich ist.  Dies muss wieder bekannt und getan werden, ansible allein wird dies nicht tun. </p><br><p>  Versuchen Sie erneut, das Playbook auszuf√ºhren und √ºberpr√ºfen Sie, ob die Pakete installiert sind. </p><br><h3 id="sozdanie-novyh-polzovateley">  Erstellung neuer Benutzer. </h3><br><p>  Um mit Benutzern arbeiten zu k√∂nnen, verf√ºgt Ansible auch √ºber ein Modul - Benutzer.  F√ºgen Sie eine weitere Aufgabe hinzu (ich habe die bereits bekannten Teile des Spielbuchs hinter den Kommentaren versteckt, um sie nicht jedes Mal vollst√§ndig zu kopieren): </p><br><pre> <code class="plaintext hljs">--- - name: Simple playbook # ... tasks: # ... - name: Add a new user user: name: my_user shell: /bin/bash password: "{{ 123qweasd | password_hash('sha512') }}"</code> </pre> <br><p>  Wir erstellen einen neuen Benutzer, setzen ihm eine Schell und ein Passwort.  Und dann stehen wir vor mehreren Problemen.  Was ist, wenn Benutzernamen f√ºr verschiedene Hosts unterschiedlich sein m√ºssen?  Ja, und das Passwort im Playbook offen zu halten, ist eine sehr schlechte Idee.  Zuerst werden wir den Benutzernamen und das Passwort in Variablen eingeben und gegen Ende des Artikels werde ich zeigen, wie das Passwort verschl√ºsselt wird. </p><br><pre> <code class="plaintext hljs">--- - name: Simple playbook # ... tasks: # ... - name: Add a new user user: name: "{{ user }}" shell: /bin/bash password: "{{ user_password | password_hash('sha512') }}"</code> </pre> <br><p>  Variablen werden in Playbooks in doppelten geschweiften Klammern gesetzt. </p><br><p>  Wir werden die Werte der Variablen in der Inventardatei angeben: </p><br><pre> <code class="plaintext hljs">123.123.123.123 [all:vars] user=my_user user_password=123qweasd</code> </pre> <br><p>  Beachten Sie die Direktive <code>[all:vars]</code> - sie besagt, dass der n√§chste Textblock Variablen (vars) sind und f√ºr alle Hosts (all) gelten. </p><br><p>  Interessant <code>"{{ user_password | password_hash('sha512') }}"</code> auch die Konstruktion von <code>"{{ user_password | password_hash('sha512') }}"</code> .  Tatsache ist, dass ansible den Benutzer <code>user_add</code> wie manuell √ºber <code>user_add</code> .  Und es speichert alle Daten direkt, weshalb wir das Passwort auch im Voraus in einen Hash konvertieren m√ºssen, was dieser Befehl tut. </p><br><p>  F√ºgen wir unseren Benutzer der Sudo-Gruppe hinzu.  Vorher m√ºssen Sie jedoch sicherstellen, dass eine solche Gruppe existiert, da dies niemand f√ºr uns tun wird: </p><br><pre> <code class="plaintext hljs">--- - name: Simple playbook # ... tasks: # ... - name: Ensure a 'sudo' group group: name: sudo state: present - name: Add a new user user: name: "{{ user }}" shell: /bin/bash password: "{{ user_password | password_hash('sha512') }}" groups: "sudo"</code> </pre> <br><p>  Es ist einfach genug, wir haben auch ein Gruppenmodul zum Erstellen von Gruppen mit einer Syntax, die apt sehr √§hnlich ist.  Dann reicht es aus, diese Gruppe beim Benutzer zu registrieren ( <code>groups: "sudo"</code> ). <br>  Es ist auch n√ºtzlich, diesem Benutzer einen SSH-Schl√ºssel hinzuzuf√ºgen, damit wir uns ohne Kennwort darunter anmelden k√∂nnen: </p><br><pre> <code class="plaintext hljs">--- - name: Simple playbook # ... tasks: # ... - name: Ensure a 'sudo' group group: name: sudo state: present - name: Add a new user user: name: "{{ user }}" shell: /bin/bash password: "{{ user_password | password_hash('sha512') }}" groups: "sudo" - name: Deploy SSH Key authorized_key: user: "{{ user }}" key: "{{ lookup('file', '~/.ssh/id_rsa.pub') }}" state: present</code> </pre> <br><p>  In diesem Fall ist das Konstrukt <code>"{{ lookup('file', '~/.ssh/id_rsa.pub') }}"</code> interessant - es kopiert den Inhalt der Datei id_rsa.pub (Ihr Name kann abweichen), dh den √∂ffentlichen Teil des ssh-Schl√ºssels und l√§dt es in die Liste der autorisierten Schl√ºssel f√ºr den Benutzer auf dem Server hoch. </p><br><h3 id="roli">  Rollen </h3><br><p>  Alle drei Aufgaben f√ºr die Erstellung k√∂nnen problemlos als eine Aufgabengruppe verwendet werden, und es w√§re sch√∂n, diese Gruppe vom Haupt-Playbook getrennt zu halten, damit sie nicht zu stark w√§chst.  Daf√ºr gibt es in ansible <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Rollen</a> . <br>  Entsprechend der am Anfang angegebenen Dateistruktur m√ºssen die Rollen f√ºr jede Rolle in einem separaten Rollenverzeichnis abgelegt werden - einem separaten Verzeichnis mit demselben Namen innerhalb des Verzeichnisses f√ºr Aufgaben, Dateien, Vorlagen usw. <br>  Erstellen wir die Dateistruktur: <code>./ansible/roles/user/tasks/main.yml</code> (main ist die Hauptdatei, die geladen und ausgef√ºhrt wird, wenn die Rolle mit dem Playbook verbunden ist, andere Rollendateien k√∂nnen darin verbunden werden).  Jetzt k√∂nnen Sie alle Aufgaben, die sich auf den Benutzer beziehen, in diese Datei √ºbertragen: </p><br><pre> <code class="plaintext hljs"># Create user and add him to groups - name: Ensure a 'sudo' group group: name: sudo state: present - name: Add a new user user: name: "{{ user }}" shell: /bin/bash password: "{{ user_password | password_hash('sha512') }}" groups: "sudo" - name: Deploy SSH Key authorized_key: user: "{{ user }}" key: "{{ lookup('file', '~/.ssh/id_rsa.pub') }}" state: present</code> </pre> <br><p>  Im Haupt-Playbook m√ºssen Sie angeben, um die Benutzerrolle zu verwenden: </p><br><pre> <code class="plaintext hljs">--- - name: Simple playbook hosts: all remote_user: root gather_facts: no tasks: - name: Update system apt: update_cache=yes - name: Install system dependencies apt: name: git,nginx,redis,postgresql,postgresql-contrib state: present roles: - user</code> </pre> <br><p>  Es kann auch sinnvoll sein, vor allen anderen Aufgaben ein Systemupdate durchzuf√ºhren. Dazu k√∂nnen Sie den <code>tasks</code> umbenennen, in dem sie in <code>pre_tasks</code> definiert <code>pre_tasks</code> . </p><br><h3 id="nastroyka-nginx">  Nginx-Setup </h3><br><p>  Nginx sollte bereits bei uns installiert sein, Sie m√ºssen es konfigurieren und ausf√ºhren.  Machen wir es gleich in der Rolle.  Erstellen Sie eine Dateistruktur: </p><br><pre> <code class="plaintext hljs">- ansible - roles - nginx - files - tasks - main.yml - templates</code> </pre> <br><p>  Jetzt brauchen wir Dateien und Vorlagen.  Der Unterschied zwischen den beiden besteht darin, dass ansible Dateien so wie sie sind direkt kopiert werden.  Die Vorlagen sollten die Erweiterung j2 haben und k√∂nnen die Werte von Variablen mit denselben doppelten geschweiften Klammern verwenden. </p><br><p>  Nehmen wir nginx in die Datei <code>main.yml</code> .  Daf√ºr haben wir ein systemd-Modul: </p><br><pre> <code class="plaintext hljs"># Copy nginx configs and start it - name: enable service nginx and start systemd: name: nginx state: started enabled: yes</code> </pre> <br><p>  Hier sagen wir nicht nur, dass nginx gestartet werden soll (d. H. Ausf√ºhren soll), sondern sagen sofort, dass es aktiviert werden muss. <br>  Kopieren Sie nun die Konfigurationsdateien: </p><br><pre> <code class="plaintext hljs"># Copy nginx configs and start it - name: enable service nginx and start systemd: name: nginx state: started enabled: yes - name: Copy the nginx.conf copy: src: nginx.conf dest: /etc/nginx/nginx.conf owner: root group: root mode: '0644' backup: yes - name: Copy template my_app.conf template: src: my_app_conf.j2 dest: /etc/nginx/sites-available/my_app.conf owner: root group: root mode: '0644'</code> </pre> <br><p>  Wir erstellen die Haupt-Nginx-Konfigurationsdatei (Sie k√∂nnen sie direkt vom Server √ºbernehmen oder selbst schreiben).  Und auch die Konfigurationsdatei f√ºr unsere Anwendung im Verzeichnis sites_available (dies ist nicht erforderlich, aber n√ºtzlich).  Im ersten Fall verwenden wir das <code>/ansible/roles/nginx/files/nginx.conf</code> zum Kopieren von Dateien (die Datei muss sich in <code>/ansible/roles/nginx/files/nginx.conf</code> ).  Kopieren Sie im zweiten Schritt die Vorlage und ersetzen Sie die Werte der Variablen.  Die Vorlage sollte sich in <code>/ansible/roles/nginx/templates/my_app.j2</code> ) befinden.  Und es k√∂nnte ungef√§hr so ‚Äã‚Äãaussehen: </p><br><pre> <code class="plaintext hljs">upstream {{ app_name }} { server unix:{{ app_path }}/shared/tmp/sockets/puma.sock; } server { listen 80; server_name {{ server_name }} {{ inventory_hostname }}; root {{ app_path }}/current/public; try_files $uri/index.html $uri.html $uri @{{ app_name }}; .... }</code> </pre> <br><p>  <code>{{ app_name }}</code> die Einf√ºgungen <code>{{ app_name }}</code> , <code>{{ app_path }}</code> , <code>{{ server_name }}</code> , <code>{{ inventory_hostname }}</code> - dies sind alles Variablen, deren ansible-Werte vor dem Kopieren in der Vorlage ersetzt werden.  Dies ist n√ºtzlich, wenn Sie das Playbook f√ºr verschiedene Hostgruppen verwenden.  Zum Beispiel k√∂nnen wir unsere Inventardatei erg√§nzen: </p><br><pre> <code class="plaintext hljs">[production] 123.123.123.123 [staging] 231.231.231.231 [all:vars] user=my_user user_password=123qweasd [production:vars] server_name=production app_path=/home/www/my_app app_name=my_app [staging:vars] server_name=staging app_path=/home/www/my_stage app_name=my_stage_app</code> </pre> <br><p>  Wenn wir unser Playbook jetzt ausf√ºhren, werden die angegebenen Aufgaben f√ºr beide Hosts ausgef√ºhrt.  Gleichzeitig unterscheiden sich die Variablen f√ºr den Staging-Host von der Produktion, und zwar nicht nur in Rollen und Playbooks, sondern auch in Nginx-Konfigurationen.  <code>{{ inventory_hostname }}</code> muss nicht in der Inventardatei angegeben werden - dies ist eine <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">spezielle Variable ansible</a> und der Host, f√ºr den das Playbook gerade ausgef√ºhrt wird, wird dort gespeichert. <br>  Wenn Sie eine Inventardatei f√ºr mehrere Hosts haben und nur f√ºr eine Gruppe ausf√ºhren m√∂chten, k√∂nnen Sie dies mit dem folgenden Befehl ausf√ºhren: </p><br><pre> <code class="plaintext hljs">ansible-playbook -i inventory ./playbook.yml -l "staging"</code> </pre> <br><p>  Eine andere M√∂glichkeit besteht darin, separate Inventardateien f√ºr verschiedene Gruppen zu haben.  Oder Sie k√∂nnen zwei Ans√§tze kombinieren, wenn Sie viele verschiedene Hosts haben. </p><br><p>  Kommen wir zur√ºck zur Konfiguration von Nginx.  Nach dem Kopieren der Konfigurationsdateien m√ºssen wir in sitest_enabled auf my_app.conf einen symlink von sites_available erstellen.  Und starten Sie Nginx neu. </p><br><pre> <code class="plaintext hljs">... # old code in mail.yml - name: Create symlink to sites-enabled file: src: /etc/nginx/sites-available/my_app.conf dest: /etc/nginx/sites-enabled/my_app.conf state: link - name: restart nginx service: name: nginx state: restarted</code> </pre> <br><p>  Auch hier ist alles einfach - wieder ansible Module mit ziemlich normaler Syntax.  Aber es gibt einen Punkt.  Ein erneuter Neustart von nginx ist nicht sinnvoll.  Sie haben festgestellt, dass wir keine Befehle des Formulars schreiben: "Mach das so", die Syntax sieht eher so aus wie "Das sollte diesen Zustand haben".  Und meistens funktioniert ansible so.  Wenn die Gruppe bereits vorhanden ist oder das Systempaket bereits installiert ist, √ºberpr√ºft ansible dies und √ºberspringt die Aufgabe.  Au√üerdem werden Dateien nicht kopiert, wenn sie vollst√§ndig mit dem √ºbereinstimmen, was sich bereits auf dem Server befindet.  Wir k√∂nnen dies nutzen und nginx nur neu starten, wenn die Konfigurationsdateien ge√§ndert wurden.  Hierf√ºr gibt es eine Registerrichtlinie: </p><br><pre> <code class="plaintext hljs"># Copy nginx configs and start it - name: enable service nginx and start systemd: name: nginx state: started enabled: yes - name: Copy the nginx.conf copy: src: nginx.conf dest: /etc/nginx/nginx.conf owner: root group: root mode: '0644' backup: yes register: restart_nginx - name: Copy template my_app.conf template: src: my_app_conf.j2 dest: /etc/nginx/sites-available/my_app.conf owner: root group: root mode: '0644' register: restart_nginx - name: Create symlink to sites-enabled file: src: /etc/nginx/sites-available/my_app.conf dest: /etc/nginx/sites-enabled/my_app.conf state: link - name: restart nginx service: name: nginx state: restarted when: restart_nginx.changed</code> </pre> <br><p>  Wenn sich eine der Konfigurationsdateien √§ndert, wird die Kopie ausgef√ºhrt und die Variable <code>restart_nginx</code> registriert.  Und nur wenn diese Variable registriert wurde, wird der Dienst neu gestartet. </p><br><p>  Nat√ºrlich m√ºssen Sie die Nginx-Rolle zum Hauptspielbuch hinzuf√ºgen. </p><br><h3 id="nastroyka-postgresql">  Postgresql-Setup </h3><br><p>  Wir m√ºssen postgresql mit systemd wie mit nginx aktivieren und einen Benutzer erstellen, mit dem wir auf die Datenbank und die Datenbank selbst zugreifen k√∂nnen. <br>  Erstellen Sie die Rolle <code>/ansible/roles/postgresql/tasks/main.yml</code> : </p><br><pre> <code class="plaintext hljs"># Create user in postgresql - name: enable postgresql and start systemd: name: postgresql state: started enabled: yes - name: Create database user become_user: postgres postgresql_user: name: "{{ db_user }}" password: "{{ db_password }}" role_attr_flags: SUPERUSER - name: Create database become_user: postgres postgresql_db: name: "{{ db_name }}" encoding: UTF-8 owner: "{{ db_user }}"</code> </pre> <br><p>  Ich werde nicht beschreiben, wie Variablen zum Inventar hinzugef√ºgt werden. Dies wurde bereits mehrfach durchgef√ºhrt, ebenso wie die Syntax der Module postgresql_db und postgresql_user.  Weitere Daten finden Sie in der Dokumentation.  Die Direktive <code>become_user: postgres</code> am interessantesten.  Tatsache ist, dass standardm√§√üig nur Postgres-Benutzer Zugriff auf die Postgresql-Datenbank haben und nur lokal.  Diese Anweisung erm√∂glicht es uns, Befehle im Namen dieses Benutzers auszuf√ºhren (es sei denn, wir haben nat√ºrlich Zugriff). <br>  M√∂glicherweise m√ºssen Sie auch eine Zeile zu pg_hba.conf hinzuf√ºgen, um einem neuen Benutzer den Zugriff auf die Datenbank zu erm√∂glichen.  Dies kann auf die gleiche Weise erfolgen, wie wir die Nginx-Konfiguration ge√§ndert haben. </p><br><p>  Und nat√ºrlich m√ºssen Sie die Rolle von postgresql zum Hauptspielbuch hinzuf√ºgen. </p><br><h3 id="ustanovka-ruby-cherez-rbenv">  Installieren Sie Ruby durch Rbenv </h3><br><p>  Ansible hat keine Module f√ºr die Arbeit mit rbenv, wird jedoch durch Klonen eines Git-Repositorys installiert.  Daher wird diese Aufgabe zur ungew√∂hnlichsten.  Erstellen wir die Rolle <code>/ansible/roles/ruby_rbenv/main.yml</code> f√ºr sie und f√ºllen sie aus: </p><br><pre> <code class="plaintext hljs"># Install rbenv and ruby - name: Install rbenv become_user: "{{ user }}" git: repo=https://github.com/rbenv/rbenv.git dest=~/.rbenv</code> </pre> <br><p>  Wir verwenden erneut die Direktive werden_benutzer, um unter dem Benutzer zu arbeiten, den wir f√ºr diese Zwecke erstellt haben.  Da rbenv in seinem Home-Verzeichnis installiert ist, nicht global.  Au√üerdem verwenden wir das Git-Modul, um das Repository durch Angabe von repo und dest zu klonen. </p><br><p>  Als n√§chstes m√ºssen wir rbenv init in bashrc registrieren und rbenv an derselben Stelle zu PATH hinzuf√ºgen.  Daf√ºr haben wir das Lineinfile-Modul: </p><br><pre> <code class="plaintext hljs">- name: Add rbenv to PATH become_user: "{{ user }}" lineinfile: path: ~/.bashrc state: present line: 'export PATH="${HOME}/.rbenv/bin:${PATH}"' - name: Add rbenv init to bashrc become_user: "{{ user }}" lineinfile: path: ~/.bashrc state: present line: 'eval "$(rbenv init -)"'</code> </pre> <br><p>  Dann installieren Sie ruby_build: </p><br><pre> <code class="plaintext hljs">- name: Install ruby-build become_user: "{{ user }}" git: repo=https://github.com/rbenv/ruby-build.git dest=~/.rbenv/plugins/ruby-build</code> </pre> <br><p>  Und schlie√ülich Ruby installieren.  Dies erfolgt √ºber rbenv, dh nur einen Bash-Befehl: </p><br><pre> <code class="plaintext hljs">- name: Install ruby become_user: "{{ user }}" shell: | export PATH="${HOME}/.rbenv/bin:${PATH}" eval "$(rbenv init -)" rbenv install {{ ruby_version }} args: executable: /bin/bash</code> </pre> <br><p>  Wir sagen, welches Team wie ausgef√ºhrt werden soll.  Hier sto√üen wir jedoch auf die Tatsache, dass ansible den in bashrc enthaltenen Code nicht ausf√ºhrt, bevor die Befehle ausgef√ºhrt werden.  Daher muss rbenv direkt im selben Skript definiert werden. </p><br><p>  Das n√§chste Problem ist, dass der Shell-Befehl keinen Ansible-Status hat.  Das hei√üt, eine automatische √úberpr√ºfung, ob diese Version von Ruby installiert ist oder nicht, wird nicht.  Wir k√∂nnen es selbst machen: </p><br><pre> <code class="plaintext hljs">- name: Install ruby become_user: "{{ user }}" shell: | export PATH="${HOME}/.rbenv/bin:${PATH}" eval "$(rbenv init -)" if ! rbenv versions | grep -q {{ ruby_version }} then rbenv install {{ ruby_version }} &amp;&amp; rbenv global {{ ruby_version }} fi args: executable: /bin/bash</code> </pre> <br><p>  Und es bleibt Bundler zu installieren: </p><br><pre> <code class="plaintext hljs">- name: Install bundler become_user: "{{ user }}" shell: | export PATH="${HOME}/.rbenv/bin:${PATH}" eval "$(rbenv init -)" gem install bundler</code> </pre> <br><p>  F√ºgen Sie erneut unsere ruby_rbenv-Rolle zum Hauptspielbuch hinzu. </p><br><h3 id="shared-files">  Freigegebene Dateien. </h3><br><p>  Im Allgemeinen kann diese Einstellung abgeschlossen werden.  Dann muss capistrano ausgef√ºhrt werden, und der Code selbst wird kopiert, die erforderlichen Verzeichnisse erstellt und die Anwendung gestartet (sofern alles richtig konfiguriert ist).  Capistrano ben√∂tigt jedoch h√§ufig zus√§tzliche Konfigurationsdateien wie <code>database.yml</code> oder <code>.env</code> k√∂nnen diese wie Dateien und Vorlagen f√ºr nginx kopieren.  Es gibt nur eine Subtilit√§t.  Bevor Sie Dateien kopieren, m√ºssen Sie eine Verzeichnisstruktur f√ºr diese erstellen: </p><br><pre> <code class="plaintext hljs"># Copy shared files for deploy - name: Ensure shared dir become_user: "{{ user }}" file: path: "{{ app_path }}/shared/config" state: directory</code> </pre> <br><p>  Wir geben nur ein Verzeichnis an und ansible erstellt bei Bedarf automatisch das √ºbergeordnete Verzeichnis. </p><br><h2 id="ansible-vault">  Ansible Tresor </h2><br><p>  Wir sind bereits auf die Tatsache gesto√üen, dass geheime Daten wie das Benutzerkennwort in Variablen vorkommen k√∂nnen.  Wenn Sie eine <code>.env</code> Datei f√ºr die Anwendung und <code>database.yml</code> haben, sollten noch mehr solche kritischen Daten vorhanden sein.  Es w√§re sch√∂n, sie vor neugierigen Blicken zu verstecken.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Hierf√ºr wird Ansible Vault</a> verwendet. </p><br><p>  Erstellen wir eine Datei f√ºr die Variablen <code>/ansible/vars/all.yml</code> (hier k√∂nnen Sie verschiedene Dateien f√ºr verschiedene Gruppen von Hosts erstellen, genau wie in der Inventardatei: Production.yml, Staging.yml usw.). <br>  In dieser Datei m√ºssen Sie alle Variablen √ºbertragen, die mit der Standard-Yml-Syntax verschl√ºsselt werden m√ºssen: </p><br><pre> <code class="plaintext hljs"># System vars user_password: 123qweasd db_password: 123qweasd # ENV vars aws_access_key_id: xxxxx aws_secret_access_key: xxxxxx aws_bucket: bucket_name rails_secret_key_base: very_secret_key_base</code> </pre> <br><p>  Dann kann diese Datei mit dem folgenden Befehl verschl√ºsselt werden: </p><br><pre> <code class="plaintext hljs">ansible-vault encrypt ./vars/all.yml</code> </pre> <br><p>  W√§hrend der Verschl√ºsselung muss nat√ºrlich ein Passwort f√ºr die Entschl√ºsselung festgelegt werden.  Sie k√∂nnen sehen, was in der Datei angezeigt wird, nachdem Sie diesen Befehl aufgerufen haben. </p><br><p>  Mit <code>ansible-vault decrypt</code> Datei entschl√ºsselt, ge√§ndert und anschlie√üend erneut verschl√ºsselt werden. </p><br><p>  Zum Arbeiten ist das Entschl√ºsseln der Datei nicht erforderlich.  Sie speichern es in verschl√ºsselter Form und f√ºhren das Playbook mit dem Argument <code>--ask-vault-pass</code> .  Ansible fragt nach einem Passwort, ruft die Variablen ab und erledigt die Aufgaben.  Alle Daten bleiben verschl√ºsselt. </p><br><p>  Ein vollst√§ndiger Befehl f√ºr mehrere Hostgruppen und einen ansible Tresor w√ºrde ungef√§hr so ‚Äã‚Äãaussehen: </p><br><pre> <code class="plaintext hljs">ansible-playbook -i inventory ./playbook.yml -l "staging" --ask-vault-pass</code> </pre> <br><p>  Und ich werde Ihnen nicht den vollst√§ndigen Text von Spielb√ºchern und Rollen geben, sondern selbst schreiben.  Denn das Ansible ist: Wenn Sie nicht verstehen, was zu tun ist, wird er es nicht tun. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de460769/">https://habr.com/ru/post/de460769/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de460743/index.html">Flutter Anf√§ngerleitfaden</a></li>
<li><a href="../de460745/index.html">Erfahrung in der Verwendung eines GSM-Moduls in der Hausautomation</a></li>
<li><a href="../de460747/index.html">Nach Gewinnen suchen oder Muttern festziehen: Spotify arbeitet nicht mehr direkt mit Autoren zusammen - was bedeutet das?</a></li>
<li><a href="../de460751/index.html">Wie wir Roboter im kleinen Tschernobyl gestartet haben. Teil 1</a></li>
<li><a href="../de460755/index.html">ROS Trolley Robot - Teil 1: Eisen</a></li>
<li><a href="../de460773/index.html">Implementieren des Mustervergleichs in Java</a></li>
<li><a href="../de460777/index.html">Dies ist die Wende: Warum Apple die Anforderungen f√ºr Anwendungsentwickler ge√§ndert hat</a></li>
<li><a href="../de460779/index.html">Erweitertes Debug</a></li>
<li><a href="../de460783/index.html">Konsens √ºber die Reputation des Knotens. Ist es notwendig</a></li>
<li><a href="../de460785/index.html">Anwendungen f√ºr E-Books auf dem Android-Betriebssystem. Teil 1. Einf√ºhrung und Office-Anwendungen</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>