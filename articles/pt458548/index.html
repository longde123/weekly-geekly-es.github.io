<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🌓 ⛹🏻 🍱 Crie sua própria biblioteca de estilos do Spring Data Repository com Dynamic Proxy e Spring IoC 👨🏽‍🤝‍👨🏻 🔁 🥘</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Mas e se você pudesse criar uma interface, por exemplo, assim: 


@Service public interface GoogleSearchApi { /** * @return http status code for Googl...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Crie sua própria biblioteca de estilos do Spring Data Repository com Dynamic Proxy e Spring IoC</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/458548/"><p> Mas e se você pudesse criar uma interface, por exemplo, assim: </p><br><pre><code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Service</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">GoogleSearchApi</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/** * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@return</span></span></span><span class="hljs-comment"> http status code for Google main page */</span></span> <span class="hljs-meta"><span class="hljs-meta">@Uri</span></span>(<span class="hljs-string"><span class="hljs-string">"https://www.google.com"</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mainPageStatus</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; }</code> </pre> <br><p>  E então apenas injete e chame seus métodos: </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@SpringBootApplication</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">App</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CommandLineRunner</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Logger LOG = LoggerFactory.getLogger(App.class); <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> GoogleSearchApi api; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">App</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(GoogleSearchApi api)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.api = api; } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">run</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String... args)</span></span></span><span class="hljs-function"> </span></span>{ LOG.info(<span class="hljs-string"><span class="hljs-string">"Main page status: "</span></span> + api.mainPageStatus()); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String[] args)</span></span></span><span class="hljs-function"> </span></span>{ SpringApplication.run(App.class, args); } }</code> </pre> <br><p>  Isso é bem possível de implementar (e não muito difícil).  A seguir, mostrarei como e por que fazê-lo. </p><a name="habracut"></a><br><p>  Recentemente, tive a tarefa de simplificar a interação dos desenvolvedores com uma das estruturas usadas.  Era necessário dar a eles uma maneira ainda mais simples e conveniente de trabalhar com ele do que a que já havia sido implementada. </p><br><p>  Propriedades que eu queria obter com essa solução: </p><br><ul><li>  descrição declarativa da ação desejada </li><li>  quantidade mínima de código necessária </li><li>  integração com a estrutura de injeção de dependência usada (no nosso caso, Spring) </li></ul><br><p>  Isso é implementado nas bibliotecas <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Spring Data Repository</a> e <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Retrofit</a> .  Neles, o usuário descreve a interação desejada na forma de uma interface java, complementada por anotações.  O usuário não precisa escrever a implementação pessoalmente - a biblioteca a gera em tempo de execução com base nas assinaturas de métodos, anotações e tipos. </p><br><p>  Quando estudei o tópico, tive muitas perguntas, cujas respostas estavam espalhadas pela Internet.  Naquele momento, um artigo como esse não me machucaria.  Portanto, aqui tentei coletar todas as informações e minha experiência em um só lugar. </p><br><p>  Neste post, mostrarei como você pode implementar essa ideia, usando o exemplo de um wrapper para um cliente http.  Um exemplo de brinquedo, projetado não para uso real, mas para demonstrar a abordagem.  O código <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://bitbucket.org/bachkovsky/dynamic-proxy-">fonte</a> do projeto pode ser estudado no <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://bitbucket.org/bachkovsky/dynamic-proxy-">bitbucket</a> . </p><br><h3 id="kak-eto-vyglyadit-dlya-polzovatelya">  Como é a aparência do usuário </h3><br><p>  O usuário descreve o serviço que ele precisa na forma de uma interface.  Por exemplo, para executar solicitações http no google: </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">/** * Some Google requests */</span></span> <span class="hljs-meta"><span class="hljs-meta">@Service</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">GoogleSearchApi</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/** * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@return</span></span></span><span class="hljs-comment"> http status code for Google main page */</span></span> <span class="hljs-meta"><span class="hljs-meta">@Uri</span></span>(<span class="hljs-string"><span class="hljs-string">"https://www.google.com"</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mainPageStatus</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-comment"><span class="hljs-comment">/** * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@return</span></span></span><span class="hljs-comment"> request object for Google main page */</span></span> <span class="hljs-meta"><span class="hljs-meta">@Uri</span></span>(<span class="hljs-string"><span class="hljs-string">"https://www.google.com"</span></span>) <span class="hljs-function"><span class="hljs-function">HttpGet </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mainPageRequest</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-comment"><span class="hljs-comment">/** * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@param</span></span></span><span class="hljs-comment"> query search query * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@return</span></span></span><span class="hljs-comment"> result of search request execution */</span></span> <span class="hljs-meta"><span class="hljs-meta">@Uri</span></span>(<span class="hljs-string"><span class="hljs-string">"https://www.google.com/search?q={query}"</span></span>) <span class="hljs-function"><span class="hljs-function">CloseableHttpResponse </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">searchSomething</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String query)</span></span></span></span>; <span class="hljs-comment"><span class="hljs-comment">/** * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@param</span></span></span><span class="hljs-comment"> query doodle search query * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@param</span></span></span><span class="hljs-comment"> language doodle search language * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@return</span></span></span><span class="hljs-comment"> http status code for doodle search result */</span></span> <span class="hljs-meta"><span class="hljs-meta">@Uri</span></span>(<span class="hljs-string"><span class="hljs-string">"https://www.google.com/doodles/?q={query}&amp;hl={language}"</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">searchDoodleStatus</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String query, String language)</span></span></span></span>; }</code> </pre> <br><p>  O que a implementação dessa interface fará, em última análise, é determinado pela assinatura.  Se o tipo de retorno for int, uma solicitação http será executada e o status será retornado como um código de resultado.  Se o tipo de retorno for CloseableHttpResponse, a resposta inteira será retornada e assim por diante.  Onde a solicitação será feita, tiraremos o Uri da anotação, substituindo os mesmos valores transferidos em vez de espaços reservados em seu conteúdo. </p><br><p>  Neste exemplo, me limitei a oferecer suporte a três tipos de retorno e uma anotação.  Você também pode usar nomes de métodos, tipos de parâmetros para escolher uma implementação, usar todos os tipos de combinações deles, mas não vou abrir este tópico neste post. </p><br><p>  Quando um usuário deseja usar essa interface, ele a incorpora em seu código usando o Spring: </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@SpringBootApplication</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">App</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CommandLineRunner</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Logger LOG = LoggerFactory.getLogger(App.class); <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> GoogleSearchApi api; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">App</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(GoogleSearchApi api)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.api = api; } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-meta"><span class="hljs-meta">@SneakyThrows</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">run</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String... args)</span></span></span><span class="hljs-function"> </span></span>{ LOG.info(<span class="hljs-string"><span class="hljs-string">"Main page status: "</span></span> + api.mainPageStatus()); LOG.info(<span class="hljs-string"><span class="hljs-string">"Main page request: "</span></span> + api.mainPageRequest()); LOG.info(<span class="hljs-string"><span class="hljs-string">"Doodle search status: "</span></span> + api.searchDoodleStatus(<span class="hljs-string"><span class="hljs-string">"tesla"</span></span>, <span class="hljs-string"><span class="hljs-string">"en"</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> (CloseableHttpResponse response = api.searchSomething(<span class="hljs-string"><span class="hljs-string">"qweqwe"</span></span>)) { LOG.info(<span class="hljs-string"><span class="hljs-string">"Search result "</span></span> + response); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String[] args)</span></span></span><span class="hljs-function"> </span></span>{ SpringApplication.run(App.class, args); } }</code> </pre> <br><p>  A integração com o Spring era necessária no meu projeto de trabalho, mas, é claro, não é o único possível.  Se você não usar a injeção de dependência, poderá obter a implementação, por exemplo, através do método estático de fábrica.  Mas neste artigo vou considerar a primavera. </p><br><p>  Essa abordagem é muito conveniente: basta marcar sua interface como um componente do Spring (neste caso, anotação de serviço) e ela está pronta para implementação e uso. </p><br><h3 id="kak-zastavit-spring-podderzhivat-etu-magiyu">  Como obter o Spring para apoiar essa mágica </h3><br><p>  Um aplicativo Spring típico varre o caminho de classe na inicialização e procura todos os componentes marcados com anotações especiais.  Para eles, ele registra BeanDefinitions, receitas pelas quais esses componentes serão criados.  Mas se, no caso de classes concretas, o Spring sabe como criá-las, quais construtores chamar e o que passar nelas, então, para classes e interfaces abstratas, ela não possui essas informações.  Portanto, para o GoogleSearchApi Spring, não será criado o BeanDefinition.  Nisto, ele precisará de ajuda de nós. </p><br><p>  Para concluir a lógica do processamento de BeanDefinitions, há uma interface BeanDefinitionRegistryPostProcessor na primavera.  Com ele, podemos adicionar ao BeanDefinitionRegistry qualquer definição de beans que desejarmos. </p><br><p>  Infelizmente, não encontrei uma maneira de integrar a lógica Spring da verificação do caminho de classe para processar os beans comuns e nossas interfaces em uma única passagem.  Portanto, criei e usei o descendente da classe ClassPathScanningCandidateComponentProvider para encontrar todas as interfaces marcadas com a anotação Service: </p><br><p>  Código completo de verificação do pacote e registro do BeanDefinitions: </p><br><div class="spoiler">  <b class="spoiler_title">DynamicProxyBeanDefinitionRegistryPostProcessor</b> <div class="spoiler_text"><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Component</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DynamicProxyBeanDefinitionRegistryPostProcessor</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BeanDefinitionRegistryPostProcessor</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// ,     private static final String[] SCAN_PACKAGES = {"com"}; private final InterfaceScanner classpathScanner; public DynamicProxyBeanDefinitionRegistryPostProcessor() { classpathScanner = new InterfaceScanner(); //   .      Service classpathScanner.addIncludeFilter(new AnnotationTypeFilter(Service.class)); } @Override public void postProcessBeanDefinitionRegistry(BeanDefinitionRegistry registry) throws BeansException { for (String basePackage : SCAN_PACKAGES) { createRepositoryProxies(basePackage, registry); } } @SneakyThrows private void createRepositoryProxies(String basePackage, BeanDefinitionRegistry registry) { for (BeanDefinition beanDefinition : classpathScanner.findCandidateComponents(basePackage)) { Class&lt;?&gt; clazz = Class.forName(beanDefinition.getBeanClassName()); //      bean definition BeanDefinitionBuilder builder = BeanDefinitionBuilder.genericBeanDefinition(clazz); builder.addConstructorArgValue(clazz); //,          builder.setFactoryMethodOnBean( "createDynamicProxyBean", DynamicProxyBeanFactory.DYNAMIC_PROXY_BEAN_FACTORY ); registry.registerBeanDefinition(ClassUtils.getShortNameAsProperty(clazz), builder.getBeanDefinition()); } } @Override public void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) throws BeansException { } private static class InterfaceScanner extends ClassPathScanningCandidateComponentProvider { InterfaceScanner() { super(false); } @Override protected boolean isCandidateComponent(AnnotatedBeanDefinition beanDefinition) { return beanDefinition.getMetadata().isInterface(); } } }</span></span></code> </pre> </div></div><br><p>  Feito!  No início do aplicativo, o Spring executará esse código e registrará todas as interfaces necessárias, como beans. </p><br><p>  A criação de uma implementação dos beans encontrados é delegada a um componente separado do DynamicProxyBeanFactory: </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Component</span></span>(DYNAMIC_PROXY_BEAN_FACTORY) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DynamicProxyBeanFactory</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> String DYNAMIC_PROXY_BEAN_FACTORY = <span class="hljs-string"><span class="hljs-string">"repositoryProxyBeanFactory"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> DynamicProxyInvocationHandlerDispatcher proxy; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DynamicProxyBeanFactory</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(DynamicProxyInvocationHandlerDispatcher proxy)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.proxy = proxy; } <span class="hljs-meta"><span class="hljs-meta">@SuppressWarnings</span></span>(<span class="hljs-string"><span class="hljs-string">"unused"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> &lt;T&gt; <span class="hljs-function"><span class="hljs-function">T </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createDynamicProxyBean</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Class&lt;T&gt; beanClass)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//noinspection unchecked return (T) Proxy.newProxyInstance(beanClass.getClassLoader(), new Class[]{beanClass}, proxy); } }</span></span></code> </pre> <br><p>  Para criar a implementação, o bom e velho mecanismo de Proxy Dinâmico é usado.  Uma implementação é criada dinamicamente usando o método Proxy.newProxyInstance.  Muitos artigos já foram escritos sobre ele, então não vou me deter aqui em detalhes. </p><br><h3 id="poisk-nuzhnogo-obrabotchika-i-obrabotka-vyzova">  Localizando o manipulador certo e o processamento de chamadas </h3><br><p>  Como você pode ver, DynamicProxyBeanFactory redireciona o processamento do método para DynamicProxyInvocationHandlerDispatcher.  Como temos potencialmente muitas implementações de manipuladores (para cada anotação, para cada tipo retornado etc.), é lógico estabelecer um local central para o armazenamento e a pesquisa. </p><br><p>  Para determinar se o manipulador é adequado para processar o método chamado, expandi a interface InvocationHandler padrão com um novo método </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">HandlerMatcher</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/** * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@return</span></span></span><span class="hljs-comment"> {</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@code</span></span></span><span class="hljs-comment"> true} if handler is able to handle given method, {</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@code</span></span></span><span class="hljs-comment"> false} othervise */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">canHandle</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Method method)</span></span></span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ProxyInvocationHandler</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">InvocationHandler</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">HandlerMatcher</span></span></span><span class="hljs-class"> </span></span>{ }</code> </pre> <br><p>  O resultado é a interface ProxyInvocationHandler, cujas implementações serão nossos manipuladores.  Além disso, as implementações do manipulador serão marcadas como Component, para que o Spring possa coletá-las para nós em uma grande lista no DynamicProxyInvocationHandlerDispatcher: </p><br><div class="spoiler">  <b class="spoiler_title">DynamicProxyInvocationHandlerDispatcher</b> <div class="spoiler_text"><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> com.bachkovsky.dynproxy.lib.proxy; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> lombok.SneakyThrows; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> org.springframework.stereotype.Component; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.lang.reflect.InvocationHandler; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.lang.reflect.Method; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.util.List; <span class="hljs-comment"><span class="hljs-comment">/** * Top level dynamic proxy invocation handler, which finds correct implementation based and uses it for method * invocation */</span></span> <span class="hljs-meta"><span class="hljs-meta">@Component</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DynamicProxyInvocationHandlerDispatcher</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">InvocationHandler</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> List&lt;ProxyInvocationHandler&gt; proxyHandlers; <span class="hljs-comment"><span class="hljs-comment">/** * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@param</span></span></span><span class="hljs-comment"> proxyHandlers all dynamic proxy handlers found in app context */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DynamicProxyInvocationHandlerDispatcher</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(List&lt;ProxyInvocationHandler&gt; proxyHandlers)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.proxyHandlers = proxyHandlers; } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Object </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">invoke</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Object proxy, Method method, Object[] args)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (method.getName()) { <span class="hljs-comment"><span class="hljs-comment">// three Object class methods don't have default implementation after creation with Proxy::newProxyInstance case "hashCode": return System.identityHashCode(proxy); case "toString": return proxy.getClass() + "@" + System.identityHashCode(proxy); case "equals": return proxy == args[0]; default: return doInvoke(proxy, method, args); } } @SneakyThrows private Object doInvoke(Object proxy, Method method, Object[] args) { return findHandler(method).invoke(proxy, method, args); } private ProxyInvocationHandler findHandler(Method method) { return proxyHandlers.stream() .filter(h -&gt; h.canHandle(method)) .findAny() .orElseThrow(() -&gt; new IllegalStateException("No handler was found for method: " + method)); } }</span></span></code> </pre> </div></div><br><p>  No método findHandler, examinamos todos os manipuladores e retornamos o primeiro que pode manipular o método passado.  Esse mecanismo de pesquisa pode não ser muito eficaz quando há muitas implementações de manipulador.  Talvez você precise pensar em alguma estrutura mais adequada para armazená-las do que em uma lista. </p><br><h3 id="realizaciya-obrabotchikov">  Implementação do manipulador </h3><br><p>  As tarefas dos manipuladores incluem a leitura de informações sobre o método chamado da interface e o processamento da própria chamada. </p><br><p>  O que o manipulador deve fazer neste caso: </p><br><ol><li>  Leia a anotação Uri, obtenha seu conteúdo </li><li>  Substitua os espaços reservados de Uri na string por valores reais </li><li>  Tipo de retorno do método de leitura </li><li>  Se o tipo de retorno for adequado, processe o método e retorne o resultado. </li></ol><br><p>  Os três primeiros pontos são necessários para todos os tipos retornados, então eu coloquei o código geral em uma superclasse abstrata <br>  HttpInvocationHandler: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">abstract</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">HttpInvocationHandler</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ProxyInvocationHandler</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> HttpClient client; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> UriHandler uriHandler; HttpInvocationHandler(HttpClient client, UriHandler uriHandler) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.client = client; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.uriHandler = uriHandler; } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">canHandle</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Method method)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> uriHandler.canHandle(method); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">final</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getUri</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Method method, Object[] args)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> uriHandler.getUriString(method, args); } }</code> </pre> <br><p>  A classe auxiliar UriHandler implementa o trabalho com a anotação Uri: lendo valores, substituindo espaços reservados.  Eu não vou dar o código aqui, porque  é bastante utilitário. <br>  Mas é importante notar que, para ler os nomes dos parâmetros na assinatura do método java, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">é necessário adicionar a opção "-parameters" ao compilar</a> . <br>  HttpClient - um wrapper sobre o Apachevsky CloseableHttpClient, é um back-end para esta biblioteca. </p><br><p>  Como exemplo de um manipulador específico, darei um manipulador que retorna um código de resposta de status: </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Component</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">HttpCodeInvocationHandler</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">HttpInvocationHandler</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">HttpCodeInvocationHandler</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(HttpClient client, UriHandler uriHandler)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>(client, uriHandler); } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-meta"><span class="hljs-meta">@SneakyThrows</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Integer </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">invoke</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Object proxy, Method method, Object[] args)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> (CloseableHttpResponse resp = client.execute(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HttpGet(getUri(method, args)))) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> resp.getStatusLine().getStatusCode(); } } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">canHandle</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Method method)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.canHandle(method) &amp;&amp; method.getReturnType().equals(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>.class); } }</code> </pre> <br><p>  Outros manipuladores são feitos de maneira semelhante.  Adicionar novos manipuladores é simples e não requer modificação do código existente - basta criar um novo manipulador e marcá-lo como um componente Spring. </p><br><p>  Isso é tudo.  O código está escrito e pronto para ser usado. </p><br><h3 id="zaklyuchenie">  Conclusão </h3><br><p>  Quanto mais eu penso sobre esse design, mais vejo falhas nele.  Fraquezas que vejo: </p><br><ul><li>  Digite Safety, que não é.  Defina a anotação incorretamente - antes de encontrar o RuntimeException.  Utilizou a combinação incorreta de tipo de retorno e anotação - a mesma coisa. </li><li>  Suporte fraco do IDE.  Falta de preenchimento automático.  O usuário não pode ver quais ações estão disponíveis para ele em sua situação (como se ele colocasse um "ponto" após o objeto e visse uma lista de métodos disponíveis) </li><li>  Existem poucas possibilidades de aplicação.  O cliente http já mencionado vem à mente e o cliente vai para o banco de dados.  Mas por que mais isso pode ser aplicado? </li></ul><br><p>  No entanto, no meu rascunho de trabalho, a abordagem criou raízes e é popular.  As vantagens que eu já mencionei - simplicidade, uma pequena quantidade de código, declaratividade, permitem que os desenvolvedores se concentrem em escrever códigos mais importantes. </p><br><p>  O que você acha dessa abordagem?  Vale a pena o esforço?  Que problemas você vê nessa abordagem?  Enquanto eu ainda estou tentando entender, enquanto está sendo produzido em nossa produção, eu gostaria de ouvir o que as outras pessoas pensam sobre isso.  Espero que este material tenha sido útil para alguém. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt458548/">https://habr.com/ru/post/pt458548/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt458524/index.html">VC palavra nuvem no joelho</a></li>
<li><a href="../pt458530/index.html">Zabbix, séries temporais e TimescaleDB</a></li>
<li><a href="../pt458532/index.html">Pioneiros de novas tecnologias: Vadim Artsev contou como deixou de ser cego</a></li>
<li><a href="../pt458536/index.html">Python + Pyside2 ou simplesmente "Calculadora"</a></li>
<li><a href="../pt458546/index.html">Dia da Automação, ou como construímos a camada de autotestes</a></li>
<li><a href="../pt458550/index.html">Biblioteca GOST de símbolos para DipTrace</a></li>
<li><a href="../pt458552/index.html">Sobre a comparação de formatos de armazenamento no Hadoop: vamos começar com o ORC</a></li>
<li><a href="../pt458556/index.html">Desenvolva a extensão do Chrome com a CLI angular</a></li>
<li><a href="../pt458558/index.html">Apresentações com Magento Meetup Kharkiv - Vídeos e Apresentações</a></li>
<li><a href="../pt458560/index.html">Treinamento Cisco 200-125 CCNA v3.0. Dia 12. VLAN avançada</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>