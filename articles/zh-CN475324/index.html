<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🌝 👨🏽‍🤝‍👨🏻 ✌🏽 从EcmaScript角度进行功能编程。 组成，咖喱，部分涂抹 👩🏾‍🔧 👥 👮</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="哈Ha！ 

 今天，我们继续在EcmaScript上下文中进行函数式编程的研究，EcmaScript的规范基于JavaScript。 在上一篇文章中，我们研究了基本概念：纯函数，lambda和免疫性概念。 今天，我们将讨论稍微复杂一些的FP技术：合成，currying和纯函数。 该文章以“伪cod...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>从EcmaScript角度进行功能编程。 组成，咖喱，部分涂抹</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/475324/">哈Ha！ <br><br> 今天，我们继续在EcmaScript上下文中进行函数式编程的研究，EcmaScript的规范基于JavaScript。 在上一篇文章中，我们研究了基本概念：纯函数，lambda和免疫性概念。 今天，我们将讨论稍微复杂一些的FP技术：合成，currying和纯函数。 该文章以“伪codreview”样式编写，即 我们将在研究相变和重构代码的过程中解决一个实际问题，以使后者近似于相变的理想状态。 <br><br> 因此，让我们开始吧！ <br><br> 假设我们有一个任务：创建一套用于处理回文的工具。 <br><blockquote> 回文 <br> 男性性别 <br> 从左到右和从右到左以相同方式读取的单词或短语。 <br>  “ P.  “我用法官的剑去” <br></blockquote> 该任务的可能实现之一可能是这样的： <br><br><pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getPalindrom</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">str</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> regexp = <span class="hljs-regexp"><span class="hljs-regexp">/[\.,\/#!$%\^&amp;\*;:{}=\-_`~()?\s]/g</span></span>; str = str.replace(regexp, <span class="hljs-string"><span class="hljs-string">''</span></span>).toLowerCase().split(<span class="hljs-string"><span class="hljs-string">''</span></span>).reverse().join(<span class="hljs-string"><span class="hljs-string">''</span></span>); <span class="hljs-comment"><span class="hljs-comment">// -       ,       return str; } function isPalindrom (str) { const regexp = /[\.,\/#!$%\^&amp;\*;:{}=\-_`~()?\s]/g; str = str.replace(regexp, '').toLowerCase(); return str === str.split('').reverse().join(''); }</span></span></code> </pre> <a name="habracut"></a><br> 当然，此实现有效。 我们可以预期，如果api返回正确的数据，则getPalindrom将正常工作。 调用isPalindrom（“我将与剑士同行”）将返回true，而调用isPalindrom（“ not a palindrome”）将返回false。 就函数式编程的理想而言，此实现是否良好？ 绝对不好！ <br><br> 根据<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">本文</a>纯函数的定义： <br><blockquote> 纯函数（PF）-始终返回预测结果。 <br>  PF特性： <br><br>  PF执行的结果仅取决于传递的参数和实现PF的算法 <br> 不要使用全局值 <br> 不要修改外部值或传递的参数 <br> 不要将数据写入文件，数据库或其他任何地方 <br></blockquote> 我们在回文示例中看到了什么？ <br><br> 首先，有重复的代码，即 违反了<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">DRY</a>的原理。 其次，getPalindrom函数访问数据库。 第三，函数修改其参数。 总计，我们的功能并不干净。 <br><br> 回顾一下定义：函数式编程是通过编译一组函数来编写代码的方式。 <br><br> 我们为此任务组合了一组功能： <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> allNotWordSymbolsRegexpGlobal = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> /[\.,\/#!$%\^&amp;\*;:{}=\-_~<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">?\</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">s</span></span></span><span class="hljs-function">]/</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">g</span></span></span><span class="hljs-function">;//(</span><span class="hljs-params"><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">1</span></span></span></span></span><span class="hljs-function">) </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">const</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">replace</span></span></span><span class="hljs-function"> = (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">regexp, replacement, str</span></span></span><span class="hljs-function">) =&gt;</span></span> str.replace(regexp, replacement);<span class="hljs-comment"><span class="hljs-comment">//(2) const toLowerCase = str =&gt; str.toLowerCase();//(3) const stringReverse = str =&gt; str.split('').reverse().join('');//(4) const isStringsEqual = (strA, strB) =&gt; strA === strB;//(5)</span></span></code> </pre><br> 在第1行中，我们以函数形式声明了正则表达式常量。  FP中经常使用这种描述常数的方法。 在第2行中，我们将String.prototype.replace方法封装在功能替换抽象中，以便它（替换调用）符合功能编程约定。 在第3行上，以相同的方式创建了String.prototype.toLowerCase的抽象。 在第4种方法中，他们实现了一个函数，该函数从传递的字符串中创建一个新的扩展字符串。 第五次检查字符串是否相等。 <br><br> 请注意，我们的功能非常干净！ 在上<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">一篇文章中，</a>我们讨论了纯函数的好处。 <br><br> 现在，我们需要执行检查以查看字符串是否是回文。 功能组合将对我们有所帮助。 <br><br>  <b>函数的组成</b>是将两个或多个函数合并为某个所得函数，该函数实现了按所需算法序列组合的函数的行为。 <br><br> 该定义可能看起来很复杂，但是从实际的角度来看，这是公平的。 <br><br> 我们可以这样做： <br><br><pre> <code class="javascript hljs">isStringsEqual(toLowerCase(replace(allNotWordSymbolsRegexpGlobal(), <span class="hljs-string"><span class="hljs-string">''</span></span>, <span class="hljs-string"><span class="hljs-string">'    '</span></span>)), stringReverse(toLowerCase(replace(allNotWordSymbolsRegexpGlobal(), <span class="hljs-string"><span class="hljs-string">''</span></span>, <span class="hljs-string"><span class="hljs-string">'    '</span></span>))));</code> </pre><br> 或像这样： <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> strA = toLowerCase(replace(allNotWordSymbolsRegexpGlobal(), <span class="hljs-string"><span class="hljs-string">''</span></span>, <span class="hljs-string"><span class="hljs-string">'    '</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> strB = stringReverse(toLowerCase(replace(allNotWordSymbolsRegexpGlobal(), <span class="hljs-string"><span class="hljs-string">''</span></span>, <span class="hljs-string"><span class="hljs-string">'    '</span></span>))); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(isStringsEqual(strA, strB));</code> </pre><br> 或为已实施算法的每个步骤输入另一堆说明变量。 此类代码通常可以在项目上看到，这是组合的典型示例-将对一个函数的调用作为对另一个函数的参数传递。 但是，正如我们所看到的，在存在许多功能的情况下，这种方法是不好的，因为 此代码不可读！ 那现在呢？ 好吧，它的功能编程，我们不同意吗？ <br><br> 实际上，就像函数编程中通常那样，我们只需要编写另一个函数即可。 <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> compose = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">...fns</span></span></span><span class="hljs-function">) =&gt;</span></span> x =&gt; fns.reduce(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">acc, fn</span></span></span><span class="hljs-function">) =&gt;</span></span> fn(acc), x);</code> </pre><br>  compose函数将可执行函数的列表作为参数，将它们转换为数组，将其存储在闭包中，并返回需要初始值的函数。 传递初始值后，将开始顺序执行fns数组中的所有功能。 第一个函数的参数将是传递的初始值x，所有后续函数的参数将是前一个参数的结果。 因此，我们可以创建任何数量的功能的组合。 <br><br> 创建功能组合时，监视输入参数的类型和每个函数的返回值非常重要，这样就不会出现意外错误，因为 我们将前一个函数的结果传递给下一个。 <br><br> 但是，现在我们已经看到将合成技术应用于代码的问题，因为该函数： <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> replace = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">regexp, replacement, str</span></span></span><span class="hljs-function">) =&gt;</span></span> str.replace(regexp, replacement);</code> </pre><br> 期望接受3个输入参数，而我们仅发送一个输入参数。 另一种FP技术Currying将帮助我们解决此问题。 <br><br>  <b>固化</b>是将一个函数从多个参数转换为一个函数从一个参数转换。 <br><br> 还记得我们第一篇文章中的add函数吗？ <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> add = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">x,y</span></span></span><span class="hljs-function">) =&gt;</span></span> x+y;</code> </pre><br> 可以这样处理： <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> add = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">x</span></span></span><span class="hljs-function"> =&gt;</span></span> y =&gt; x+y;</code> </pre><br> 该函数采用x并返回期望y的lambda并执行操作。 <br><br> 咖喱的好处： <br><br><ul><li> 代码看起来更好； </li><li> 咖喱函数总是干净的。 </li></ul><br> 现在，我们对替换函数进行转换，以使其仅接受一个参数。 由于我们需要用以前已知的正则表达式替换字符串中字符的函数，因此我们可以创建部分应用的函数。 <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> replaceAllNotWordSymbolsGlobal = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">replacement</span></span></span><span class="hljs-function"> =&gt;</span></span> str =&gt; replace(allNotWordSymbolsRegexpGlobal(), replacement, str);</code> </pre><br> 如您所见，我们用一个常数修复其中一个参数。 这是由于以下事实：咖喱实际上是部分使用的特殊情况。 <br><br>  <b>一个部分应用程序</b>使用一个包装器包装一个函数，该包装器接受的参数少于该函数本身；包装器应返回一个接受其余参数的函数。 <br><br> 在我们的例子中，我们创建了replaceAllNotWordSymbolsGlobal函数，这是部分应用的替换选项。 它接受替换，将其存储在一个闭包中，并期望有一个输入行被调用replace，并且我们使用常量进行正则表达式。 <br><br> 回到回文。 为回文计时创建功能组合： <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> processFormPalindrom = compose( replaceAllNotWordSymbolsGlobal(<span class="hljs-string"><span class="hljs-string">''</span></span>), toLowerCase, stringReverse );</code> </pre><br> 以及我们将用来比较潜在回文的那条线的功能组成： <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> processFormTestString = compose( replaceAllNotWordSymbolsGlobal(<span class="hljs-string"><span class="hljs-string">''</span></span>), toLowerCase, );</code> </pre><br> 现在，请记住我们上面说的话： <br><blockquote> 一个典型的合成示例是将对一个函数的调用作为对另一个函数的参数传递 </blockquote> 并写： <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> testString = <span class="hljs-string"><span class="hljs-string">'    '</span></span>;<span class="hljs-comment"><span class="hljs-comment">//          , .. ,    ,  ,   -   ,    const isPalindrom = isStringsEqual(processFormPalindrom(testString), processFormTestString(testString));</span></span></code> </pre><br> 在这里，我们有一个可行且美观的解决方案： <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> allNotWordSymbolsRegexpGlobal = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> /[\.,\/#!$%\^&amp;\*;:{}=\-_~<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">?\</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">s</span></span></span><span class="hljs-function">]/</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">g</span></span></span><span class="hljs-function">; </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">const</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">replace</span></span></span><span class="hljs-function"> = (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">regexp, replacement, str</span></span></span><span class="hljs-function">) =&gt;</span></span> str.replace(regexp, replacement); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> toLowerCase = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">str</span></span></span><span class="hljs-function"> =&gt;</span></span> str.toLowerCase(); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> stringReverse = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">str</span></span></span><span class="hljs-function"> =&gt;</span></span> str.split(<span class="hljs-string"><span class="hljs-string">''</span></span>).reverse().join(<span class="hljs-string"><span class="hljs-string">''</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> isStringsEqual = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">strA, strB</span></span></span><span class="hljs-function">) =&gt;</span></span> strA === strB; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> replaceAllNotWordSymbolsGlobal = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">replacement</span></span></span><span class="hljs-function"> =&gt;</span></span> str =&gt; replace(allNotWordSymbolsRegexpGlobal(), replacement, str); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> compose = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">...fns</span></span></span><span class="hljs-function">) =&gt;</span></span> x =&gt; fns.reduce(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">acc, fn</span></span></span><span class="hljs-function">) =&gt;</span></span> fn(acc), x); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> processFormPalindrom = compose( replaceAllNotWordSymbolsGlobal(<span class="hljs-string"><span class="hljs-string">''</span></span>), toLowerCase, stringReverse ); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> processFormTestString = compose( replaceAllNotWordSymbolsGlobal(<span class="hljs-string"><span class="hljs-string">''</span></span>), toLowerCase, ); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> testString = <span class="hljs-string"><span class="hljs-string">'    '</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> isPalindrom = isStringsEqual(processFormPalindrom(testString), processFormTestString(testString));</code> </pre><br> 但是，我们不希望每次都花钱，也不想用手创建部分应用的函数。 当然我们不想要，程序员是懒惰的人。 因此，正如在FP中通常会发生的那样，我们将编写另外两个函数： <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> curry = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">fn</span></span></span><span class="hljs-function"> =&gt;</span></span> (...args) =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (fn.length &gt; args.length) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> f = fn.bind(<span class="hljs-literal"><span class="hljs-literal">null</span></span>, ...args); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> curry(f); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> fn(...args) } }</code> </pre><br> 咖喱函数接受一个要咖喱的函数，将其存储在一个闭包中，并返回一个lambda。  lambda期望该函数的其余参数。 每次收到参数时，它都会检查是否接受了所有已声明的参数。 如果被接受，则调用该函数并返回其结果。 如果不是，则再次调用该函数。 <br><br> 我们还可以创建部分应用的函数，以用空字符串替换所需的正则表达式： <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> replaceAllNotWordSymbolsToEmpltyGlobal = curry(replace)(allNotWordSymbolsRegexpGlobal(), <span class="hljs-string"><span class="hljs-string">''</span></span>);</code> </pre><br> 一切似乎都很好，但是我们是完美主义者，我们不希望括号太多，我们希望更好，所以我们将编写另一个或两个函数： <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> party = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">fn, x</span></span></span><span class="hljs-function">) =&gt;</span></span> (...args) =&gt; fn(x, ...args);</code> </pre><br> 这是用于创建部分应用功能的抽象实现。 它使用一个函数和第一个参数，返回一个需要其余部分的lambda并执行该函数。 <br><br> 现在我们重写party，以便我们可以创建一个包含多个参数的部分应用函数： <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> party = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">fn, ...args</span></span></span><span class="hljs-function">) =&gt;</span></span> (...rest) =&gt; fn(...args.concat(rest));</code> </pre><br> 值得一提的是，可以用少于声明的数量（fn.length）的任意数量的参数调用以这种方式咖喱的函数。 <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> sum = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">a,b,c,d</span></span></span><span class="hljs-function">) =&gt;</span></span> a+b+c+d; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> fn = curry(sum); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> r1 = fn(<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>,<span class="hljs-number"><span class="hljs-number">4</span></span>);<span class="hljs-comment"><span class="hljs-comment">//,   const r2 = fn(1, 2, 3)(4);//       const r3 = fn(1, 2)(3)(4); const r4 = fn(1)(2)(3)(4); const r5 = fn(1)(2, 3, 4); const r6 = fn(1)(2)(3, 4); const r7 = fn(1, 2)(3, 4);</span></span></code> </pre><br> 让我们回到我们的回文。 我们可以重写我们的replaceAllNotWordSymbolsToEmpltyGlobal，而无需使用多余的括号： <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> replaceAllNotWordSymbolsToEmpltyGlobal = party(replace,allNotWordSymbolsRegexpGlobal(), <span class="hljs-string"><span class="hljs-string">''</span></span>);</code> </pre><br> 让我们看一下整个代码： <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//    -       const allNotWordSymbolsRegexpGlobal = () =&gt; /[\.,\/#!$%\^&amp;\*;:{}=\-_~()?\s]/g; const replace = (regexp, replacement, str) =&gt; str.replace(regexp, replacement); const toLowerCase = str =&gt; str.toLowerCase(); const stringReverse = str =&gt; str.split('').reverse().join(''); const isStringsEqual = (strA, strB) =&gt; strA === strB; //       const testString = '    '; //           -    rambda.js const compose = (...fns) =&gt; x =&gt; fns.reduce((acc, fn) =&gt; fn(acc), x); const curry = fn =&gt; (...args) =&gt; { if (fn.length &gt; args.length) { const f = fn.bind(null, ...args); return curry(f); } else { return fn(...args) } } const party = (fn, ...args) =&gt; (...rest) =&gt; fn(...args.concat(rest)); //       const replaceAllNotWordSymbolsToEmpltyGlobal = party(replace,allNotWordSymbolsRegexpGlobal(), ''); const processFormPalindrom = compose( replaceAllNotWordSymbolsToEmpltyGlobal, toLowerCase, stringReverse ); const processFormTestString = compose( replaceAllNotWordSymbolsToEmpltyGlobal, toLowerCase, ); const checkPalindrom = testString =&gt; isStringsEqual(processFormPalindrom(testString), processFormTestString(testString));</span></span></code> </pre><br> 看起来不错，但是如果不是我们想要的字符串，而是数组，该怎么办？ 因此，我们添加了另一个功能： <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> map = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">fn</span></span></span><span class="hljs-function"> =&gt;</span></span> (...args) =&gt; args.map(fn);</code> </pre><br> 现在，如果我们具有用于测试回文序列的数组，则： <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> palindroms = [<span class="hljs-string"><span class="hljs-string">'    '</span></span>,<span class="hljs-string"><span class="hljs-string">'   '</span></span>,<span class="hljs-string"><span class="hljs-string">'   '</span></span>. <span class="hljs-string"><span class="hljs-string">' '</span></span>] map(checkPalindrom )(...palindroms ); <span class="hljs-comment"><span class="hljs-comment">// [true, true, true, false]  </span></span></code> </pre><br> 这就是我们通过编写功能集解决任务的方式。 注意编写代码的毫无意义的风格-这是对功能纯度的试金石。 <br><br> 现在多一点理论。 使用currying时请不要忘记每次使用一个函数都会创建一个新的函数，即 为此选择一个存储单元。 对此进行监视以避免泄漏很重要。 <br><br> 诸如ramda.js之类的功能库具有compose和pipe函数。  compose从右到左实现合成算法，从左到右实现管道。 我们的compose函数类似于ramda的管道。 库中有两个不同的合成函数，因为 从右到左和从左到右的组合是功能编程的两个不同契约。 如果其中一位读者找到描述FP所有现有合同的文章，然后在评论中分享它，我将很高兴阅读并在评论中加上一个加号！ <br><br> 函数的形式参数的数量称为<b>arity</b> 。 从相变理论的角度来看，这也是一个重要的定义。 <br><br><h2> 结论 </h2><br> 在本文的框架中，我们研究了功能编程技术，例如合成，计算和部分应用。 当然，在实际项目中，您将使用具有这些工具的现成库，但作为本文的一部分，我在本机JS上实现了所有功能，以便对FP经验不多的读者可以了解这些技术是如何工作的。 <br><br> 为了说明我在代码中实现功能纯净的逻辑，我还特意选择了叙述方法-伪codreview。 <br><br> 顺便说一句，您可以继续开发与回文校验模块的模块并开发其思想，例如，通过api下载行，转换为字母集并将其发送到服务器，回文行将由回文校验管生成，以及更多...您可以自行决定。 <br><br> 在这些行的过程中消除重复也将是一件好事： <br><br><pre> <code class="javascript hljs"> replaceAllNotWordSymbolsToEmpltyGlobal, toLowerCase,</code> </pre><br> 通常，有可能并且有必要不断改进代码！ <br><br> 直到以后的文章。 </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN475324/">https://habr.com/ru/post/zh-CN475324/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN475304/index.html">SSD简介。 第1部分。历史</a></li>
<li><a href="../zh-CN475306/index.html">西装：历史与前景</a></li>
<li><a href="../zh-CN475308/index.html">如何通过优秀的程序员</a></li>
<li><a href="../zh-CN475314/index.html">保护地球的生态幻想</a></li>
<li><a href="../zh-CN475322/index.html">下一代骨声音-Aftershokz Aeropex评测</a></li>
<li><a href="../zh-CN475326/index.html">骗子如何做到这一点。 作弊工具</a></li>
<li><a href="../zh-CN475328/index.html">操作TA505，第四部分。 双胞胎</a></li>
<li><a href="../zh-CN475332/index.html">3.极限交换机上的企业网络设计</a></li>
<li><a href="../zh-CN475336/index.html">如何正确退出（说明）</a></li>
<li><a href="../zh-CN475338/index.html">如果您没有Python，但是有Keras模型和Java</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>