<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚ò™Ô∏è üê¨ üßîüèΩ So lassen Sie Ihre Webanwendungen offline arbeiten ‚è≥ ‚úã üï¥üèæ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Die Leistungsf√§higkeit von JavaScript und der Browser-API 

 Die Welt wird immer vernetzter - die Zahl der Menschen mit Internetzugang ist auf 4,5 Mil...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>So lassen Sie Ihre Webanwendungen offline arbeiten</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/edison/blog/474374/">  <i>Die Leistungsf√§higkeit von JavaScript und der Browser-API</i> <br><br>  Die Welt wird immer vernetzter - die Zahl der Menschen mit Internetzugang ist auf <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">4,5 Milliarden</a> gestiegen. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a7a/c94/c74/a7ac94c74325a245837ec6e11fde02e0.png" alt="Bild"></div><br>  Diese Daten geben jedoch nicht die Anzahl der Personen wieder, die eine langsame oder unterbrochene Internetverbindung haben.  Selbst in den USA k√∂nnen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">4,9 Millionen Haushalte</a> nicht mit einer Geschwindigkeit von √ºber 3 Megabit pro Sekunde auf den kabelgebundenen Internetzugang zugreifen. <br><br>  Der Rest der Welt - diejenigen mit zuverl√§ssigem Internetzugang - neigt immer noch dazu, die Konnektivit√§t zu verlieren.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Einige Faktoren</a> , die die Qualit√§t Ihrer Netzwerkverbindung beeinflussen k√∂nnen, sind: <br><br><ul><li>  Schlechte Abdeckung durch den Anbieter. </li><li>  Extreme Wetterbedingungen. </li><li>  Stromausf√§lle. </li><li>  Benutzer, die in tote Zonen fallen, z. B. Geb√§ude, die ihre Netzwerkverbindungen blockieren. </li><li>  Zugfahrt und Tunnelfahrt. </li><li>  Verbindungen, die von Dritten gesteuert werden und zeitlich begrenzt sind. </li><li>  Kulturelle Praktiken, die zu bestimmten Zeiten oder Tagen einen eingeschr√§nkten oder keinen Internetzugang erfordern. </li></ul><br>  Angesichts dessen ist es klar, dass wir bei der Entwicklung und Erstellung von Anwendungen autonome Erfahrungen ber√ºcksichtigen m√ºssen. <br><a name="habracut"></a><br><blockquote> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" title="EDISON Software - Webentwicklung"><img align="left" width="153" height="75" src="https://habrastorage.org/webt/w0/zl/to/w0zltoxvysbr0yeinstkfvw1wbg.png" alt="EDISON Software - Webentwicklung"></a> <br clear="right">  Dieser Artikel wurde mit Unterst√ºtzung von EDISON Software √ºbersetzt, einem Unternehmen, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">das hervorragende Auftr√§ge aus S√ºdchina ausf√ºhrt</a> und auch <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Webanwendungen und Websites entwickelt</a> . </blockquote>  Ich hatte k√ºrzlich die M√∂glichkeit, einer vorhandenen Anwendung mithilfe von Servicemitarbeitern, Cache-Speicher und IndexedDB Autonomie hinzuzuf√ºgen.  Die technische Arbeit, die erforderlich ist, damit die Anwendung offline funktioniert, wurde auf vier separate Aufgaben reduziert, auf die ich in diesem Beitrag eingehen werde. <br><br><h3>  Service-Arbeiter </h3><br>  Anwendungen, die f√ºr die Offline-Verwendung erstellt wurden, sollten nicht stark netzwerkabh√§ngig sein.  Konzeptionell ist dies nur m√∂glich, wenn im Fehlerfall Sicherungsoptionen vorhanden sind. <br><br>  Wenn die Webanwendung nicht geladen werden kann, m√ºssen wir die Ressourcen f√ºr den Browser irgendwo (HTML / CSS / JavaScript) verwenden.  Woher kommen diese Ressourcen, wenn nicht von einer Netzwerkanforderung?  Wie w√§re es mit einem Cache.  Die meisten Menschen w√ºrden zustimmen, dass es besser ist, eine m√∂glicherweise veraltete Benutzeroberfl√§che bereitzustellen als eine leere Seite. <br><br>  Der Browser fragt st√§ndig Daten ab.  Der Daten-Caching-Dienst als Fallback erfordert weiterhin, dass wir Browseranforderungen abfangen und Caching-Regeln schreiben.  Hier kommen Servicemitarbeiter ins Spiel - betrachten Sie sie als Vermittler. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/a7a/c94/c74/a7ac94c74325a245837ec6e11fde02e0.png" alt="Bild"><br><br>  Service Worker ist nur eine JavaScript-Datei, in der wir Ereignisse abonnieren und unsere eigenen Regeln f√ºr das Zwischenspeichern und Behandeln von Netzwerkfehlern schreiben k√∂nnen. <br>  Fangen wir an. <br><br>  <b>Bitte beachten Sie: unsere Demo-Anwendung</b> <br><br>  In diesem Beitrag werden wir der Demo-Anwendung eigenst√§ndige Funktionen hinzuf√ºgen.  Die Demo-Anwendung ist eine einfache Seite zum Aufnehmen / Ausleihen von B√ºchern in der Bibliothek.  Der Fortschritt wird als eine Reihe von GIFs und die Verwendung von Offline-Chrome DevTools-Simulationen dargestellt. <br><br>  Hier ist der Ausgangszustand: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/757/978/c5b/757978c5bc485412b8037790878d0e08.gif" alt="Bild"><br><br><h3>  Aufgabe 1 - Zwischenspeichern statischer Ressourcen </h3><br>  Statische Ressourcen sind Ressourcen, die sich nicht h√§ufig √§ndern.  HTML, CSS, JavaScript und Bilder k√∂nnen in diese Kategorie fallen.  Der Browser versucht, statische Ressourcen mithilfe von Anforderungen zu laden, die vom Servicemitarbeiter abgefangen werden k√∂nnen. <br><br>  Beginnen wir mit der Registrierung unseres Servicemitarbeiters. <br><br><pre><code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-string"><span class="hljs-string">'serviceWorker'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> navigator) { <span class="hljs-built_in"><span class="hljs-built_in">window</span></span>.addEventListener(<span class="hljs-string"><span class="hljs-string">'load'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ navigator.serviceWorker.register(<span class="hljs-string"><span class="hljs-string">'/sw.js'</span></span>); }); }</code> </pre> <br>  Servicemitarbeiter sind <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Web-Worker</a> unter der Haube und m√ºssen daher aus einer separaten JavaScript-Datei importiert werden.  Die Registrierung erfolgt nach dem Laden der Site mit der <code>register</code> . <br>  Nachdem wir einen Servicemitarbeiter geladen haben, lassen Sie uns unsere statischen Ressourcen zwischenspeichern. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> CACHE_NAME = <span class="hljs-string"><span class="hljs-string">'my-offline-cache'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> urlsToCache = [ <span class="hljs-string"><span class="hljs-string">'/'</span></span>, <span class="hljs-string"><span class="hljs-string">'/static/css/main.c9699bb9.css'</span></span>, <span class="hljs-string"><span class="hljs-string">'/static/js/main.99348925.js'</span></span> ]; self.addEventListener(<span class="hljs-string"><span class="hljs-string">'install'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">event</span></span></span><span class="hljs-function">) </span></span>{ event.waitUntil( caches.open(CACHE_NAME) .then(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">cache</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> cache.addAll(urlsToCache); }) ); });</code> </pre> <br>  Da wir die URLs statischer Ressourcen steuern, k√∂nnen wir sie unmittelbar nach der Initialisierung des Servicemitarbeiters mithilfe von <code>Cache Storage</code> . <br><br><img src="https://habrastorage.org/getpro/habr/post_images/48a/7fb/43b/48a7fb43b94154ceab8353d80fbd4a02.png" alt="Bild"><br><br>  Nachdem unser Cache nun mit den zuletzt angeforderten statischen Ressourcen gef√ºllt ist, laden wir diese Ressourcen im Falle eines Anforderungsfehlers aus dem Cache. <br><br><pre> <code class="javascript hljs">self.addEventListener(<span class="hljs-string"><span class="hljs-string">'fetch'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">event</span></span></span><span class="hljs-function">) </span></span>{ event.respondWith( fetch(event.request).catch(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ caches.match(event.request).then(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">response</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> response; } ); ); });</code> </pre> <br>  Das <code>fetch</code> wird jedes Mal ausgel√∂st, wenn der Browser eine Anforderung stellt.  Unser neuer <code>fetch</code> verf√ºgt jetzt √ºber eine zus√§tzliche Logik f√ºr die R√ºckgabe zwischengespeicherter Antworten bei Netzwerkausf√§llen. <br><br><h3>  Demo Nummer 1 </h3><br><img src="https://habrastorage.org/getpro/habr/post_images/7c3/a2c/94c/7c3a2c94c111c6ad57dae86cabdd67ae.gif" alt="Bild"><br><br>  Unsere Demo-Anwendung kann jetzt statische Ressourcen offline bereitstellen!  Aber wo sind unsere Daten? <br><br><h3>  Aufgabe 2 - Zwischenspeichern dynamischer Ressourcen </h3><br>  Single-Page-Anwendungen (SPA) fordern normalerweise nach dem ersten Laden der Seite schrittweise Daten an, und unsere Demo-Anwendung ist keine Ausnahme - die Liste der B√ºcher wird nicht sofort geladen.  Diese Daten stammen normalerweise aus XHR-Anforderungen, die Antworten zur√ºckgeben, die sich h√§ufig √§ndern, um einen neuen Status f√ºr die Anwendung bereitzustellen - daher sind sie dynamisch. <br><br>  Das Zwischenspeichern dynamischer Ressourcen ist dem Zwischenspeichern statischer Ressourcen sehr √§hnlich. Der Hauptunterschied besteht darin, dass der Cache h√§ufiger aktualisiert werden muss.  Das Generieren einer vollst√§ndigen Liste aller m√∂glichen dynamischen XHR-Anforderungen ist ebenfalls recht schwierig. Daher werden sie bei ihrem Eintreffen zwischengespeichert und haben keine vordefinierte Liste, wie wir es f√ºr statische Ressourcen getan haben. <br><br>  Schauen Sie sich unseren <code>fetch</code> Handler an: <br><br><pre> <code class="javascript hljs">self.addEventListener(<span class="hljs-string"><span class="hljs-string">'fetch'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">event</span></span></span><span class="hljs-function">) </span></span>{ event.respondWith( fetch(event.request).catch(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ caches.match(event.request).then(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">response</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> response; } ); ); });</code> </pre> <br>  Wir k√∂nnen diese Implementierung anpassen, indem wir Code hinzuf√ºgen, der erfolgreiche Anforderungen und Antworten zwischenspeichert.  Dies stellt sicher, dass wir st√§ndig neue Anforderungen zu unserem Cache hinzuf√ºgen und die zwischengespeicherten Daten st√§ndig aktualisieren. <br><br><pre> <code class="javascript hljs">self.addEventListener(<span class="hljs-string"><span class="hljs-string">'fetch'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">event</span></span></span><span class="hljs-function">) </span></span>{ event.respondWith( fetch(event.request) .then(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">response</span></span></span><span class="hljs-function">) </span></span>{ caches.open(CACHE_NAME).then(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">cache</span></span></span><span class="hljs-function">) </span></span>{ cache.put(event.request, response); }); }) .catch(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ caches.match(event.request).then(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">response</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> response; } ); ); });</code> </pre> <br>  Unser <code>Cache Storage</code> derzeit mehrere Eintr√§ge. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/fae/6b5/8a2/fae6b58a2d7dbcff00c036182d20bb3e.png" alt="Bild"><br><br><h3>  Demo Nummer 2 </h3><br><img src="https://habrastorage.org/getpro/habr/post_images/c38/9a1/4f6/c389a14f6631a2b359d4bb7e6c2de1f1.gif" alt="Bild"><br><br>  Unsere Demo sieht jetzt beim Booten gleich aus, unabh√§ngig von unserem Netzwerkstatus! <br><br>  Gro√üartig.  Versuchen wir nun, unsere Anwendung zu verwenden. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/197/3ea/e18/1973eae1897feadc56cf65a86986b3b0.gif" alt="Bild"><br><br>  Leider gibt es √ºberall Fehlermeldungen.  Es scheint, dass alle unsere Interaktionen mit der Schnittstelle nicht funktionieren.  Ich kann das Buch nicht ausw√§hlen oder √ºbergeben!  Was muss behoben werden? <br><br><h3>  Aufgabe 3 - Erstellen einer optimistischen Benutzeroberfl√§che </h3><br>  Derzeit besteht das Problem bei unserer Anwendung darin, dass unsere Datenerfassungslogik immer noch stark von Netzwerkantworten abh√§ngt.  Die Aktion zum Ein- und Auschecken sendet eine Anforderung an den Server und erwartet eine erfolgreiche Antwort.  Dies ist gut f√ºr die Datenkonsistenz, aber schlecht f√ºr unsere Standalone-Erfahrung. <br><br>  Damit diese Interaktionen offline funktionieren, m√ºssen wir unsere Anwendung <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">optimistischer gestalten</a> .  Optimistische Interaktionen erfordern keine Antwort vom Server und zeigen bereitwillig eine aktualisierte Ansicht der Daten an.  Der √ºbliche optimistische Vorgang in den meisten Webanwendungen ist das <code>delete</code> Geben Sie dem Benutzer sofort Feedback, wenn wir bereits √ºber alle erforderlichen Informationen verf√ºgen. <br><br>  Das Trennen unserer Anwendung vom Netzwerk mithilfe eines optimistischen Ansatzes ist relativ einfach zu implementieren. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">case</span></span> CHECK_OUT_SUCCESS: <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> CHECK_OUT_FAILURE: list = [...state.list]; list.push(action.payload); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { ...state, list, }; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> CHECK_IN_SUCCESS: <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> CHECK_IN_FAILURE; list = [...state.list]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; list.length; i++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (list[i].id === action.payload.id) { list.splice(i, <span class="hljs-number"><span class="hljs-number">1</span></span>, action.payload); } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { ...state, list, };</code> </pre> <br>  Der Schl√ºssel besteht darin, Benutzeraktionen auf dieselbe Weise zu behandeln - unabh√§ngig davon, ob die Netzwerkanforderung erfolgreich ist oder nicht.  Das obige Code-Snippet stammt aus dem Redux-Reduzierer unserer Anwendung. <code>SUCCESS</code> und <code>FAILURE</code> abh√§ngig von der Verf√ºgbarkeit des Netzwerks gestartet.  Unabh√§ngig davon, wie die Netzwerkanforderung abgeschlossen ist, werden wir unsere B√ºcherliste aktualisieren. <br><br><h3>  Demo Nummer 3 </h3><br><img src="https://habrastorage.org/getpro/habr/post_images/815/892/dd9/815892dd9fc0bbcb431c147f187c528e.gif" alt="Bild"><br><br>  Die Benutzerinteraktion erfolgt jetzt online (nicht w√∂rtlich).  Die Schaltfl√§chen "Einchecken" und "Auschecken" aktualisieren die Benutzeroberfl√§che entsprechend, obwohl die roten Meldungen der Konsole anzeigen, dass Netzwerkanforderungen nicht ausgef√ºhrt werden. <br><br>  Gut!  Es gibt nur ein kleines Problem mit optimistischem Offline-Rendering ... <br><br>  Verlieren wir nicht unser Wechselgeld? <br><br><img src="https://habrastorage.org/getpro/habr/post_images/843/120/624/843120624bca4393f215511f3402a767.png" alt="Bild"><br><br><h3>  Aufgabe 4 - Benutzeraktionen f√ºr die Synchronisierung in die Warteschlange stellen </h3><br>  Wir m√ºssen die Aktionen verfolgen, die der Benutzer ausgef√ºhrt hat, als er offline war, damit wir sie mit unserem Server synchronisieren k√∂nnen, wenn der Benutzer zum Netzwerk zur√ºckkehrt.  Es gibt verschiedene Speichermechanismen im Browser, die als Warteschlange f√ºr Aktionen fungieren k√∂nnen, und wir werden IndexedDB verwenden.  IndexedDB bietet einige Dinge, die Sie von LocalStorage nicht erhalten: <br><br><ul><li>  Asynchrone nicht blockierende Operationen </li><li>  Deutlich h√∂here Lagergrenzen </li><li>  Transaktionsmanagement </li></ul><br>  Schauen Sie sich unseren alten Reduziercode an: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">case</span></span> CHECK_OUT_SUCCESS: <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> CHECK_OUT_FAILURE: list = [...state.list]; list.push(action.payload); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { ...state, list, }; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> CHECK_IN_SUCCESS: <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> CHECK_IN_FAILURE; list = [...state.list]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; list.length; i++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (list[i].id === action.payload.id) { list.splice(i, <span class="hljs-number"><span class="hljs-number">1</span></span>, action.payload); } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { ...state, list, };</code> </pre> <br>  Lassen Sie es uns √§ndern, um die Check-In- und Check-Out-Ereignisse w√§hrend des <code>FAILURE</code> -Ereignisses in IndexedDB zu speichern. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">case</span></span> CHECK_OUT_FAILURE: list = [...state.list]; list.push(action.payload); addToDB(action); <span class="hljs-comment"><span class="hljs-comment">// QUEUE IT UP return { ...state, list, }; case CHECK_IN_FAILURE; list = [...state.list]; for (let i = 0; i &lt; list.length; i++) { if (list[i].id === action.payload.id) { list.splice(i, 1, action.payload); addToDB(action); // QUEUE IT UP } } return { ...state, list, };</span></span></code> </pre> <br>  Hier ist die Implementierung des Erstellens von IndexedDB zusammen mit dem addToDB- <code>addToDB</code> . <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> db = indexedDB.open(<span class="hljs-string"><span class="hljs-string">'actions'</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>); db.onupgradeneeded = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">event</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> db = event.target.result; db.createObjectStore(<span class="hljs-string"><span class="hljs-string">'requests'</span></span>, { <span class="hljs-attr"><span class="hljs-attr">autoIncrement</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span> }); }; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> addToDB = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">action</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> db = indexedDB.open(<span class="hljs-string"><span class="hljs-string">'actions'</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>); db.onsuccess = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">event</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> db = event.target.result; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> objStore = db .transaction([<span class="hljs-string"><span class="hljs-string">'requests'</span></span>], <span class="hljs-string"><span class="hljs-string">'readwrite'</span></span>) .objectStore(<span class="hljs-string"><span class="hljs-string">'requests'</span></span>); objStore.add(action); }; };</code> </pre> <br>  Nachdem alle unsere Offline-Benutzeraktionen im Speicher des Browsers gespeichert sind, k√∂nnen wir den Ereignis-Listener des <code>online</code> Browsers verwenden, um Daten zu synchronisieren, wenn die Verbindung wiederhergestellt wird. <br><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">window</span></span>.addEventListener(<span class="hljs-string"><span class="hljs-string">'online'</span></span>, () =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> db = indexedDB.open(<span class="hljs-string"><span class="hljs-string">'actions'</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>); db.onsuccess = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">event</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> db = event.target.result; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> objStore = db .transaction([<span class="hljs-string"><span class="hljs-string">'requests'</span></span>], <span class="hljs-string"><span class="hljs-string">'readwrite'</span></span>) .objectStore(<span class="hljs-string"><span class="hljs-string">'requests'</span></span>); objStore.getAll().onsuccess = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">event</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> requests = event.target.result; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> request <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> requests) { send(request); <span class="hljs-comment"><span class="hljs-comment">// sync with the server } }; }; });</span></span></code> </pre> <br>  In dieser Phase k√∂nnen wir die Warteschlange von allen Anforderungen l√∂schen, die wir erfolgreich an den Server gesendet haben. <br><br><h3>  Demo Nummer 4 </h3><br>  Die endg√ºltige Demo sieht etwas komplizierter aus.  Rechts im dunklen Terminalfenster werden alle API-Aktivit√§ten protokolliert.  Die Demo beinhaltet das Offline-Gehen, das Ausw√§hlen mehrerer B√ºcher und das Online-Zur√ºckkehren. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ebc/3a2/29d/ebc3a229d1507a5e59bb35fcca475241.gif" alt="Bild"><br><br>  Es ist klar, dass offline gestellte Anforderungen sofort in die Warteschlange gestellt und gesendet wurden, wenn der Benutzer online zur√ºckkehrt. <br><br>  Dieser "Spiel" -Ansatz ist ein bisschen naiv - zum Beispiel m√ºssen wir wahrscheinlich nicht zwei Anfragen stellen, wenn wir dasselbe Buch annehmen und zur√ºckgeben.  Es funktioniert auch nicht, wenn mehrere Personen dieselbe Anwendung verwenden. <br><br><h3>  Das ist alles </h3><br>  Gehen Sie raus und machen Sie Ihre Webanwendungen offline!  Dieser Beitrag zeigt einige der vielen Dinge, die Sie tun k√∂nnen, um Ihren Anwendungen eigenst√§ndige Funktionen hinzuzuf√ºgen, und ist definitiv nicht vollst√§ndig. <br>  Weitere Informationen finden Sie unter <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Google Web Fundamentals</a> .  Schauen Sie sich <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">diesen Vortrag an</a> , um eine weitere Offline-Implementierung zu sehen. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img align="right" width="404" height="150" src="https://habrastorage.org/webt/2b/9i/gm/2b9igmgpbxunecpetjj6hhqsa9m.png"></a> <br clear="left"><h4>  Lesen Sie auch den Blog <br>  EDISON Unternehmen: </h4><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><b>20 Bibliotheken f√ºr</b></a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><b><br></b></a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><b>spektakul√§re iOS-Anwendung</b></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de474374/">https://habr.com/ru/post/de474374/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de474364/index.html">Elektronikentwicklung. Eine subjektive √úberpr√ºfung der n√ºtzlichsten integrierten Sensoren</a></li>
<li><a href="../de474366/index.html">Digitale Veranstaltungen in Moskau vom 4. bis 10. November</a></li>
<li><a href="../de474368/index.html">Synopsis zum maschinellen Lernen. Wahrscheinlichkeitstheorie. Bayes-Formel</a></li>
<li><a href="../de474370/index.html">Die Verdauung von frischen Materialien aus der Welt des Frontends f√ºr die letzte Woche Nr. 387 (28. Oktober - 3. November 2019)</a></li>
<li><a href="../de474372/index.html">Digitale Waage</a></li>
<li><a href="../de474378/index.html">Nicht blockf√∂rmiges Zeichnen und Aktualisieren von Diagrammen mit Bokeh</a></li>
<li><a href="../de474380/index.html">PHP Digest Nr. 167 (22. Oktober - 4. November 2019)</a></li>
<li><a href="../de474382/index.html">Der Film "Projekt 'Kolibri'" in Bezug auf Geschichte, Technologie und Finanzen</a></li>
<li><a href="../de474386/index.html">Microsoft-Experimente zur Reduzierung der Arbeitswoche auf 4 Tage f√ºhrten zu einer Steigerung der Produktivit√§t um 40%</a></li>
<li><a href="../de474388/index.html">Jeder brennt mit Effizienz</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>