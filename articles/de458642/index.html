<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>✌🏼 👵🏻 👊🏼 Theorie statt Heuristik: Als Frontend-Entwickler besser werden 🥦 👸🏼 🔹</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ein besserer Front-End-Entwickler werden, der Grundlagen anstelle von Heuristiken verwendet 

 Unsere Erfahrung zeigt, dass nichttechnische Pädagogen ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Theorie statt Heuristik: Als Frontend-Entwickler besser werden</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/nix/blog/458642/"><img src="https://habrastorage.org/getpro/habr/post_images/424/ed0/eec/424ed0eec08450f6be205e19896298a7.png"><br><br>  <i><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Ein besserer Front-End-Entwickler werden, der Grundlagen anstelle von Heuristiken verwendet</a></i> <br><br>  Unsere Erfahrung zeigt, dass nichttechnische Pädagogen und Autodidakten häufig nicht auf theoretischen Prinzipien, sondern auf heuristischen Methoden beruhen. <br><br>  Heuristiken - Muster und bewährte Regeln, die ein Entwickler aus der Praxis gelernt hat.  Sie können unvollkommen oder in begrenztem Umfang, jedoch in ausreichendem Maße, arbeiten und erfordern keine ernsthaften Überlegungen.  Hier einige Beispiele für Heuristiken: <br><br><ul><li> "Verwenden Sie <code>$(document).ready(function(){})</code> , um Code auf jQuery-Sites zu initialisieren." </li><li>  "Das <code>var self = this</code> Konstrukt wird benötigt, um eine Methode in einer Rückruffunktion aufzurufen." </li><li>  "Pfeilfunktionen haben keine <code>return</code> " <br></li></ul><br>  Gleichzeitig kann das theoretische Prinzip verwendet werden, um Lösungen für andere Probleme zu finden.  Er ist ausnahmslos treu und bestimmt oft das Gerät des einen oder anderen Elements.  Zu den theoretischen Prinzipien gehören zum Beispiel: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Die offizielle Syntax für Pfeilfunktionen</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Lodash API-Dokumentation</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Nutzungsregeln und Funktionen vertikal ausrichten</a> <br></li></ul><br>  Bitte beachten Sie: Wir haben nur heuristische Beispiele angeführt, um den handwerklichen Charakter der Heuristik im Vergleich zur Strenge der theoretischen Grundlagen hervorzuheben.  Keines der heuristischen Beispiele ist für alle Fälle universell, aber sie funktionieren in einer ausreichenden Anzahl von Situationen, sodass die Entwickler, die sie verwenden, Arbeitscode erhalten, ohne dessen Funktionsweise vollständig zu verstehen. <br><a name="habracut"></a><br><h2>  Argumente für einen theoretischen Ansatz </h2><br>  Wir sind oft auf die Tatsache gestoßen, dass Entwickler ohne technische Ausbildung nicht dazu neigen, Probleme mit theoretischen Prinzipien zu lösen.  Dies erklärt sich in der Regel dadurch, dass sie zu Beginn ihrer Karriere keine Gelegenheit hatten, sie zu lernen, und da heuristische Methoden zufriedenstellend funktionieren, setzen sie sie weiterhin ein. <br><br>  Trotz der offensichtlichen Komplexität kann das Erlernen einer Theorie sehr nützlich sein.  Warum?  Mit dieser Theorie können Sie sicher sein, dass Ihre Lösung funktioniert, und unabhängig Antworten auf neue Fragen anzeigen, ohne nach Lösungen anderer suchen zu müssen.  Kurzfristig mögen heuristische Algorithmen wie eine einfache und schnelle Lösung erscheinen, aber sie führen oft - wenn überhaupt - zu unvollständigen Lösungen. <br><br>  Wenn Sie sich auf heuristische Methoden verlassen, werden Sie außerdem nie lernen, Probleme wirklich zu lösen.  Möglicherweise schaffen Sie es oft, eine funktionierende Lösung zu finden, aber früher oder später kommen Sie zum Stillstand, von dem Sie keinen Ausweg sehen.  C &amp; P-Programmierer verlassen sich bei ihrer Arbeit auf Heuristiken. <br><br><h2>  Kriterien für die Fähigkeitsstufe von Entwicklern </h2><br>  Bei der Befragung von Frontend-Entwicklern legen wir eine Programmieraufgabe für sie fest und sagen, dass sie alle Quellen verwenden können, sei es Google oder Stack Overflow.  Auf diese Weise kann leicht festgestellt werden, ob der Entwickler an Heuristiken oder Theorien festhält. <br><br>  Ersteres kopiert ausnahmslos Code aus mehr oder weniger geeigneten Beispielen mit Stack Overflow.  Erst wenn der Code nicht wie geplant funktioniert, haben sie begonnen, ihn selbst zu optimieren.  Oft scheitern sie. <br><br>  Letztere neigen dazu, in der API-Dokumentation nach Antworten zu suchen.  Dort finden sie Informationen darüber, wie viele Parameter eine bestimmte Funktion annimmt oder welche Syntax die erweiterte Form der gewünschten CSS-Eigenschaft enthält. <br><br>  Bereits in den ersten fünf Minuten des Interviews können Sie genau bestimmen, zu welcher Art von Programmierern der Kandidat gehört. <br><br><h2>  Beispiel </h2><br>  Nehmen Sie Bill als Beispiel.  Er absolvierte mehrere Schulungen, löste eine Reihe von Aufgaben in JavaScript und schrieb in seiner Freizeit Websites, lernte JavaScript jedoch nicht wirklich. <br><br>  Sobald Bill auf ein Objekt wie dieses stößt: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> usersById = { <span class="hljs-string"><span class="hljs-string">"5"</span></span>: { <span class="hljs-string"><span class="hljs-string">"id"</span></span>: <span class="hljs-string"><span class="hljs-string">"5"</span></span>, <span class="hljs-string"><span class="hljs-string">"name"</span></span>: <span class="hljs-string"><span class="hljs-string">"Adam"</span></span>, <span class="hljs-string"><span class="hljs-string">"registered"</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span> }, <span class="hljs-string"><span class="hljs-string">"27"</span></span>: { <span class="hljs-string"><span class="hljs-string">"id"</span></span>: <span class="hljs-string"><span class="hljs-string">"27"</span></span>, <span class="hljs-string"><span class="hljs-string">"name"</span></span>: <span class="hljs-string"><span class="hljs-string">"Bobby"</span></span>, <span class="hljs-string"><span class="hljs-string">"registered"</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span> }, <span class="hljs-string"><span class="hljs-string">"32"</span></span>: { <span class="hljs-string"><span class="hljs-string">"id"</span></span>: <span class="hljs-string"><span class="hljs-string">"32"</span></span>, <span class="hljs-string"><span class="hljs-string">"name"</span></span>: <span class="hljs-string"><span class="hljs-string">"Clarence"</span></span>, <span class="hljs-string"><span class="hljs-string">"registered"</span></span>: <span class="hljs-literal"><span class="hljs-literal">false</span></span> }, <span class="hljs-string"><span class="hljs-string">"39"</span></span>: { <span class="hljs-string"><span class="hljs-string">"id"</span></span>: <span class="hljs-string"><span class="hljs-string">"39"</span></span>, <span class="hljs-string"><span class="hljs-string">"name"</span></span>: <span class="hljs-string"><span class="hljs-string">"Danielle"</span></span>, <span class="hljs-string"><span class="hljs-string">"registered"</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span> }, <span class="hljs-string"><span class="hljs-string">"42"</span></span>: { <span class="hljs-string"><span class="hljs-string">"id"</span></span>: <span class="hljs-string"><span class="hljs-string">"42"</span></span>, <span class="hljs-string"><span class="hljs-string">"name"</span></span>: <span class="hljs-string"><span class="hljs-string">"Ekaterina"</span></span>, <span class="hljs-string"><span class="hljs-string">"registered"</span></span>: <span class="hljs-literal"><span class="hljs-literal">false</span></span> } }</code> </pre><br>  Ein solches Objekt kann eine Liste von Benutzern anzeigen und angeben, ob sie sich für ein bestimmtes Ereignis registriert haben. <br><br>  Angenommen, Bill muss eine Liste der registrierten Benutzer abrufen.  Mit anderen Worten, filtern Sie sie heraus.  Er stieß auf Code, in dem die <code>.filter()</code> -Methode zum Filtern der Liste verwendet wurde.  Also versucht er so etwas wie: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> attendees = usersById.filter(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">user</span></span></span><span class="hljs-function"> =&gt;</span></span> user.registered);</code> </pre> <br>  Und hier ist was er bekommt: <br><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">TypeError</span></span>: usersById.filter is not a <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span></span></code> </pre> <br>  "Etwas Unsinniges", denkt Bill, weil er den Code gesehen hat, in dem <code>.filter()</code> als Filter fungierte. <br><br>  Das Problem ist, dass Bill sich auf die heuristische Methode stützte.  Er versteht nicht, dass <code>filter</code> eine in Arrays definierte Methode ist, während <code>usersById</code> ein reguläres Objekt ist, das keine <code>filter</code> . <br><br>  Der verwirrte Bill googelt den " <i>Javascript-Filter</i> ".  Er findet viele Verweise auf Arrays und erkennt, dass er <code>usersById</code> in ein Array verwandeln <code>usersById</code> .  <code>Object.keys()</code> er dann " <i>Javascript</i> bittet <i>, ein Objekt in ein Array</i> <code>Object.keys()</code> ", findet er Beispiele mit <code>Object.keys()</code> bei Stack Overflow.  Danach versucht er: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> attendees = <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.keys(usersById).filter(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">user</span></span></span><span class="hljs-function"> =&gt;</span></span> user.registered);</code> </pre> <br>  Diesmal wird der Fehler nicht angezeigt, aber zu Bills Überraschung bleibt das <code>attendees</code> leer. <br><br>  Tatsache ist, dass <code>Object.keys()</code> die Schlüssel des Objekts zurückgibt, jedoch nicht dessen Wert.  Tatsächlich ist der Name der <code>user</code> leicht irreführend, da es sich nicht um ein <code>user</code> , sondern um einen Bezeichner, dh eine Zeichenfolge.  Da das <code>registered</code> Attribut nicht für Zeichenfolgen definiert ist, behandelt der <code>filter</code> jeden Eintrag als falsch und das Array bleibt leer. <br><br>  Bill sieht sich die Antworten zum Stapelüberlauf genauer an und nimmt folgende Änderungen vor: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> attendees = <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.keys(usersById).filter(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">id</span></span></span><span class="hljs-function"> =&gt;</span></span> usersById[id].registered);</code> </pre> <br>  Diesmal ist das Ergebnis besser: <code>["5", "27", "39"]</code> .  Aber Bill wollte Besucherobjekte bekommen, nicht deren Ausweis. <br><br>  Um zu verstehen, wie Besucher gefiltert werden, sucht Bill verärgert nach einem „ <i>Javascript-Objektfilter</i> “, untersucht die Suchergebnisse auf Stapelüberlauf und findet <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">diese Antwort</a> mit dem folgenden Code: <br><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.filter = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">obj, predicate</span></span></span><span class="hljs-function">) =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.keys(obj) .filter( <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">key</span></span></span><span class="hljs-function"> =&gt;</span></span> predicate(obj[key]) ) .reduce( <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">res, key</span></span></span><span class="hljs-function">) =&gt;</span></span> (res[key] = obj[key], res), {} );</code> </pre> <br>  Bill kopiert diese Zeilen und versucht: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> attendees = <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.filter(usersById, user =&gt; user.registered);</code> </pre> <br>  Alles funktioniert - obwohl nicht klar ist, warum.  Bill versteht nicht, warum <code>reduce</code> erforderlich ist und wie es verwendet wird.  Darüber hinaus versteht Bill nicht, dass er gerade eine neue nicht standardmäßige Methode für das globale <code>Object</code> . <br><br>  Aber Bill ist das egal - es funktioniert!  Die Folgen interessieren ihn noch nicht. <br><br><h2>  Was hat Bill falsch gemacht? </h2><br>  Bill versuchte eine heuristische Methode, um das Problem zu lösen, und stieß auf folgende Probleme: <br><br><ol><li>  Mit <code>.filter()</code> für eine Variable erhielt Bill einen <code>TypeError</code> .  Er hat nicht verstanden, dass <code>filter</code> für gewöhnliche Objekte nicht definiert sind. <br></li><li>  Er benutzte <code>Object.keys()</code> um „das Objekt in ein Array zu verwandeln“, aber dies allein brachte keine Ergebnisse.  Er musste ein Array von Objektwerten erstellen. </li><li>  Selbst nachdem er die Werte empfangen und als Bedingung für die Filterung verwendet hatte, erhielt er nur Bezeichner anstelle der diesen Bezeichnern zugeordneten Benutzerobjekte.  Dies liegt daran, dass das gefilterte Array eine ID enthielt, keine Benutzerobjekte. </li><li>  Im Laufe der Zeit gab Bill diesen Ansatz auf und fand eine funktionierende Lösung im Internet.  Trotzdem verstand er immer noch nicht, wie es funktioniert - und wird keine Zeit damit verschwenden, es zu klären, weil er andere Dinge zu tun hat. <br></li></ol><br>  Dies ist ein künstliches Beispiel, aber wir sind oft auf Entwickler gestoßen, die Probleme auf die gleiche Weise lösen.  Um sie effektiv zu lösen, müssen Sie sich von heuristischen Methoden entfernen und die Theorie studieren. <br><br><h2>  Kommen wir zu den Grundlagen </h2><br>  Wenn Bill ein Befürworter eines theoretischen Ansatzes wäre, würde der Prozess folgendermaßen aussehen: <br><br><ol><li>  Um die angegebenen Eingabedaten zu identifizieren und die gewünschte Ausgabe zu bestimmen - im Sinne ihrer Eigenschaften: <i>„Ich habe ein Objekt, dessen Schlüssel Zeichenfolgen sind, die ID darstellen, und Werte sind Objekte, die Benutzer darstellen.</i>  <i>Ich möchte ein Array erhalten, dessen Werte Benutzerobjekte sind - aber nur Objekte registrierter Benutzer. “</i> </li><li>  So verstehen Sie die Suche in einem Objekt: <i>„Ich weiß, dass ich durch Aufrufen von <code>Object.keys()</code> ein Array von Schlüsseln in einem Objekt <code>Object.keys()</code> .</i>  <i>Ich möchte ein Array erhalten, da Arrays die Aufzählung unterstützen</i> . <i>"</i> </li><li>  Um zu erkennen, dass diese Methode beim Abrufen der Schlüssel hilfreich ist und Sie die Schlüssel in Werte umwandeln und sich an <code>map</code> erinnern müssen - eine offensichtliche Methode zum Erstellen eines neuen Arrays durch Transformieren der Werte eines anderen Arrays: <br><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.keys(usersById).map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">id</span></span></span><span class="hljs-function"> =&gt;</span></span> usersById[id])</code> </pre> </li><li>  So sehen Sie, dass Sie jetzt über ein Array von Benutzerobjekten verfügen, die gefiltert werden können und echte Werte enthalten, die Sie filtern möchten: <br><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.keys(usersById).map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">id</span></span></span><span class="hljs-function"> =&gt;</span></span> usersById[id]).filter(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">user</span></span></span><span class="hljs-function"> =&gt;</span></span> user.registered)</code> </pre> </li></ol><br>  Gehen Sie Bill auf diese Weise, er könnte für uns arbeiten. <br><br><h2>  Warum greifen die Leute nicht öfter auf die Theorie zurück? </h2><br>  Manchmal kennen sie sie einfach nicht.  Meistens sind sie zu beschäftigt und finden keine Zeit, um diese Art der Problemlösung zu lernen - sie brauchen einfach alles, um zu arbeiten.  Sie riskieren, diesen Ansatz zu einer Gewohnheit zu machen, die ein Hindernis für die Entwicklung ihrer Fähigkeiten darstellt. <br><br>  Beginnen Sie immer mit einer Theorie, um solche Fehler zu vermeiden.  Überlegen Sie sich in jeder Phase des Prozesses, mit welcher Art von Daten Sie es zu tun haben.  Betrachten Sie primitive Datentypen: Array, Objekt, Zeichenfolge usw., anstatt sich ständig auf vertraute Muster zu verlassen.  Wenn Sie eine Funktion oder Methode verwenden, lesen Sie in der Dokumentation nach, welche Datentypen sie unterstützen, welche Argumente sie verwenden und was das Ergebnis ist. <br><br>  Mit diesem Ansatz finden Sie beim ersten Versuch eine funktionierende Lösung.  Sie können sich der Richtigkeit sicher sein, da Sie Ihre Aktionen speziell anhand der angegebenen Eingabe und der gewünschten Ausgabe ausgewählt haben.  Gehen Sie tief in die Grundlagen jeder Operation (Datentypen und Rückgabewerte) ein und nicht in unscharfe Geschäftsformulierungen (wie "registrierte Benutzer"). </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de458642/">https://habr.com/ru/post/de458642/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de458632/index.html">Wirklich tippen vue</a></li>
<li><a href="../de458634/index.html">"Sei nicht böse" oder was Facebook vor uns verbirgt</a></li>
<li><a href="../de458636/index.html">Videobänder von mitap DevLeads aus dem Büro von Tutu.ru.</a></li>
<li><a href="../de458638/index.html">Intel oneAPI Project: viele Architekturen, eine API</a></li>
<li><a href="../de458640/index.html">Einen langen Strich finden</a></li>
<li><a href="../de458646/index.html">Atomic Swaps auf den Punkt gebracht</a></li>
<li><a href="../de458648/index.html">CI / CD mit AWS und Bambus</a></li>
<li><a href="../de458650/index.html">Cyber ​​Challenge. Ein neues Level. Online-Wettbewerb von Rostelecom Solar</a></li>
<li><a href="../de458652/index.html">RamblerFront & Meetup # 7</a></li>
<li><a href="../de458654/index.html">Das Lurk-Virus hat Banken gehackt, während es von gewöhnlichen Angestellten geschrieben wurde</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>