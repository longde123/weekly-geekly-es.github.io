<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🌛 🏄 👊🏿 肮脏的汇编程序黑客6502 🏩 ☀️ 👩‍🎨</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="本文列出了参加我的小型Commodore 64编程竞赛的参与者的一些技巧。 竞赛的规则很简单：创建一个可执行文件C64（PRG），该文件绘制两行以形成下面的图像。 文件较小的那个赢得了。 


 比赛参赛作品以公开鸣叫和私人消息发布，其中仅包含PRG文件的字节和MD5哈希。 

 与源代码链接的参与...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>肮脏的汇编程序黑客6502</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/464377/"> 本文列出了参加我的小型<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Commodore 64编程竞赛的</a>参与者的一些技巧。 竞赛的规则很简单：创建一个可执行文件C64（PRG），该文件绘制两行以形成下面的图像。 文件较小的那个赢得了。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3f4/5d1/afc/3f45d1afc9817c6530b6b34c44dd0497.png"></div><br> 比赛参赛作品以公开鸣叫和私人消息发布，其中仅包含PRG文件的字节和MD5哈希。 <br><a name="habracut"></a><br> 与源代码链接的参与者列表： <br><br><ul><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Philip Heron</a> （ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">代码</a> -34个字节，获胜者） <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Geir Straume</a> （ <a href="">代码</a> -34字节） <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Petri Hakkinen</a> （ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">代码</a> -37字节） <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Matlev Raksenblatts</a> （ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">代码</a> -38字节） <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Jan Ahrenius</a> （ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">代码</a> -48字节） <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">杰米·富勒</a> （ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">代码</a> -50字节） <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">David A.Gershman</a> （ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">代码</a> -53字节） <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Janne Hellsten</a> （ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">代码</a> -56字节） </li></ul><br>  （如果我想念某人，请让我知道，我将更新列表）。 <br><br> 本文的其余部分专门介绍了在比赛中使用的一些组装技巧。 <br><br><h1> 基础知识 </h1><br> 图形C64默认情况下在40x25字符编码模式下工作。  RAM中的帧缓冲区分为两个数组： <br><br><ul><li> <code>$0400</code> （屏幕RAM，40x25字节） <br></li><li>  <code>$d800</code> （彩色RAM，40x25字节） </li></ul><br> 若要设置一个字符，请将字节保存到屏幕RAM中，为<code>$0400</code> （例如， <code>$0400+y*40+x</code> ）。 默认情况下，颜色RAM由浅蓝色初始化（颜色14）：这是我们用于线条的颜色，也就是说，颜色RAM可以保持不接触的状态。 <br><br> 您可以使用<code>$d020</code> （边框）和<code>$d021</code> （背景）中的内存I / O寄存器控制边框和背景的颜色。 <br><br> 如果直接编程固定线的斜率，则绘制两条线非常容易。 这是一个C实现，它绘制线条并将屏幕内容刷新到stdout（ <code>malloc()</code>用于使代码在PC上工作）： <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;stdint.h&gt; #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; void dump(const uint8_t* screen) { const uint8_t* s = screen; for (int y = 0; y &lt; 25; y++) { for (int x = 0; x &lt; 40; x++, s++) { printf("%c", *s == 0xa0 ? '#' : '.'); } printf("\n"); } } void setreg(uintptr_t dst, uint8_t v) { // *((uint8_t *)dst) = v; } int main() { // uint8_t* screenRAM = (uint_8*)0x0400; uint8_t* screenRAM = (uint8_t *)calloc(40*25, 0x20); setreg(0xd020, 0); // Set border color setreg(0xd021, 0); // Set background color int yslope = (25&lt;&lt;8)/40; int yf = yslope/2; for (int x = 0; x &lt; 40; x++) { int yi = yf &gt;&gt; 8; // First line screenRAM[x + yi*40] = 0xa0; // Second line (X-mirrored) screenRAM[(39-x) + yi*40] = 0xa0; yf += yslope; } dump(screenRAM); }</span></span></span></span></code> </pre> <br> 上面的屏幕代码是<code>$20</code> （空白）和<code>$a0</code> （填充8×8块）。 如果运行，将看到两行的ASCII图片： <br><br><pre>  ## .................................... ##
 ..＃..................................＃..
 ... ## .............................. ## ...
 .....＃............................＃.....
 ...... ## ........................ ## ......
 ........ ## .................... ## ........
 ..........＃..................＃＃.......
 ........... ## .............. ## ...........
 .............＃............＃.............
 .............. ## ........ ## ..............
 ................ ## .... ## ................
 ..................＃..＃..................
 ................... ## ...................
 ..................＃..＃..................
 ................ ## .... ## ................
 .............. ## ........ ## ..............
 .............＃............＃.............
 ........... ## .............. ## ...........
 ..........＃..................＃＃.......
 ........ ## .................... ## ........
 ...... ## ........................ ## ......
 .....＃............................＃.....
 ... ## .............................. ## ...
 ..＃..................................＃..
 ## .................................... ## </pre><br> 这在汇编器中很容易实现： <br><br><pre> <code class="plaintext hljs">!include "c64.asm" +c64::basic_start(entry) entry: { lda #0 ; black color sta $d020 ; set border to 0 sta $d021 ; set background to 0 ; clear the screen ldx #0 lda #$20 clrscr: !for i in [0, $100, $200, $300] { sta $0400 + i, x } inx bne clrscr ; line drawing, completely unrolled ; with assembly pseudos lda #$a0 !for i in range(40) { !let y0 = Math.floor(25/40*(i+0.5)) sta $0400 + y0*40 + i sta $0400 + (24-y0)*40 + i } inf: jmp inf ; halt }</code> </pre> <br> 事实证明PRG相当大，只有286个字节。 <br><br> 在进行优化之前，我们进行一些观察。 <br><br> 首先，我们使用适当的ROM例程来处理C64。 有很多有用的例程。 例如，使用<code>JSR $E544</code>清除屏幕。 <br><br> 其次，在8位处理器（例如6502）上进行地址计算可能很麻烦，并且占用大量字节。 该处理器也没有乘法器，因此像<code>y*40+i</code>这样的计算通常包括一堆逻辑移位或一个也占用字节的查找表。 为避免乘以40，最好逐步增加屏幕光标： <br><br><pre> <code class="plaintext hljs"> int yslope = (25&lt;&lt;8)/40; int yf = yslope/2; uint8_t* dst = screenRAM; for (int x = 0; x &lt; 40; x++) { dst[x] = 0xa0; dst[(39-x)] = 0xa0; yf += yslope; if (yf &amp; 256) { // Carry set? dst += 40; yf &amp;= 255; } }</code> </pre> <br> 我们继续将直线的斜率加到固定计数器<code>yf</code> ，当8位加法设置进位标志时，加40。 <br><br> 这是一种增量汇编程序方法： <br><br><pre> <code class="plaintext hljs">!include "c64.asm" +c64::basic_start(entry) !let screenptr = $20 !let x0 = $40 !let x1 = $41 !let yf = $60 entry: { lda #0 sta x0 sta $d020 sta $d021 ; kernal clear screen jsr $e544 ; set screenptr = $0400 lda #&lt;$0400 sta screenptr+0 lda #&gt;$0400 sta screenptr+1 lda #80 sta yf lda #39 sta x1 xloop: lda #$a0 ldy x0 ; screenRAM[x] = 0xA0 sta (screenptr), y ldy x1 ; screenRAM[39-x] = 0xA0 sta (screenptr), y clc lda #160 ; line slope adc yf sta yf bcc no_add ; advance screen ptr by 40 clc lda screenptr adc #40 sta screenptr lda screenptr+1 adc #0 sta screenptr+1 no_add: inc x0 dec x1 bpl xloop inf: jmp inf }</code> </pre> <br> 它有82个字节，仍然很大。 一个明显的问题是16位地址计算。 设置用于间接<code>screenptr</code>的<code>screenptr</code>值： <br><br><pre> <code class="plaintext hljs"> ; set screenptr = $0400 lda #&lt;$0400 sta screenptr+0 lda #&gt;$0400 sta screenptr+1</code> </pre> <br> 我们通过添加40将<code>screenptr</code>转换为下一行： <br><br><pre> <code class="plaintext hljs"> ; advance screen ptr by 40 clc lda screenptr adc #40 sta screenptr lda screenptr+1 adc #0 sta screenptr+1</code> </pre> <br> 当然，可以优化此代码，但是如果您完全摆脱了16位地址该怎么办？ 让我们来看看如何做。 <br><br><h1> 把戏1.滚动！ </h1><br> 我们没有在屏幕上的RAM中建立一行，而是仅在最后一条屏幕上绘制Y = 24，然后向上滚动整个屏幕，并使用<code>JSR $E8EA</code>调用ROM滚动功能！ <br><br> 这是优化xloop的方法： <br><br><pre> <code class="plaintext hljs"> lda #0 sta x0 lda #39 sta x1 xloop: lda #$a0 ldx x0 ; hardcoded absolute address to last screen line sta $0400 + 24*40, x ldx x1 sta $0400 + 24*40, x adc yf sta yf bcc no_scroll ; scroll screen up! jsr $e8ea no_scroll: inc x0 dec x1 bpl xloop</code> </pre> <br> 这是渲染的外观： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/63f/081/6a6/63f0816a6728ec839de0197b6e0a3179.gif"></div><br><br> 这是该程序中我最喜欢的技巧之一。 几乎所有参赛者都是自己找到它的。 <br><br><h1> 技巧2。自修改代码 </h1><br> 存储像素值的代码如下所示： <br><br><pre> <code class="plaintext hljs"> ldx x1 ; hardcoded absolute address to last screen line sta $0400 + 24*40, x ldx x0 sta $0400 + 24*40, x inc x0 dec x1</code> </pre> <br> 它按以下14个字节的顺序编码： <br><br><pre> <code class="plaintext hljs">0803: A6 22 LDX $22 0805: 9D C0 07 STA $07C0,X 0808: A6 20 LDX $20 080A: 9D C0 07 STA $07C0,X 080D: E6 22 INC $22 080F: C6 20 DEC $20</code> </pre> <br> 使用自修改代码（SMC），可以更紧凑地编写此代码： <br><br><pre> <code class="plaintext hljs"> ldx x1 sta $0400 + 24*40, x addr0: sta $0400 + 24*40 ; advance the second x-coord with SMC inc addr0+1 dec x1</code> </pre> <br>  ...以13个字节编码： <br><br><pre> <code class="plaintext hljs">0803: A6 22 LDX $22 0805: 9D C0 07 STA $07C0,X 0808: 8D C0 07 STA $07C0 080B: EE 09 08 INC $0809 080E: C6 22 DEC $22</code> </pre> <br><h1> 窍门3.操作状态“开机” </h1><br> 在比赛中对工作环境做出疯狂的假设被认为是正常的。 例如，画线是在打开C64电源后首先开始的事情，并且不需要将输出干净地输出回BASIC命令行。 因此，您在进入PRG时在初始环境中找到的所有内容都可以并且应该被利用以发挥您的优势： <br><br><ul><li> 寄存器A，X，Y为零 <br></li><li> 清除所有CPU标志 <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">零页</a>内容（地址<code>$00</code> <code>$ff</code> ） </li></ul><br> 同样，在调用某些KERNAL ROM过程时，您可以充分利用任何副作用：返回的CPU标志，临时零页值等。 <br><br> 经过最初的优化之后，让我们在机器内存中寻找一些有趣的东西： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0df/43f/93c/0df43f93c58a142911607d3ba5ba44dd.png"></div><br><br> 零页确实包含一些有用的值，以达到我们的目的： <br><br><ul><li>  <code>$d5</code> ：39 / $ 27 ==行长-1 <br></li><li>  <code>$22</code> 22：64 / $ 40 ==线斜率计数器的初始值 </li></ul><br> 这将在初始化期间节省一些字节。 例如： <br><br><pre> <code class="plaintext hljs">!let x0 = $20 lda #39 ; 0801: A9 27 LDA #$27 sta x0 ; 0803: 85 20 STA $20 xloop: dec x0 ; 0805: C6 20 DEC $20 bpl xloop ; 0807: 10 FC BPL $0805</code> </pre> <br> 由于<code>$d5</code>包含值39，因此可以将其指示给计数器<code>x0</code> ，以摆脱LDA / STA对： <br><br><pre> <code class="plaintext hljs">!let x0 = $d5 ; nothing here! xloop: dec x0 ; 0801: C6 D5 DEC $D5 bpl xloop ; 0803: 10 FC BPL $0801</code> </pre> <br> 比赛的获胜者菲利普将<a href="">其代码</a>做到极致。 调用字符串<code>$07C0</code> （== <code>$0400+24*40</code> ）的最后一个字符的地址。 在初始化期间，该值在零页中不存在。 但是，作为ROM滚动例程如何使用临时零页值的副作用，该函数输出处的地址<code>$D1-$D2</code>将包含值<code>$07C0</code> 。 因此，为了存储一个像素，可以使用较短的间接索引寻址<code>STA ($D1),y</code>代替<code>STA $07C0,x</code> 。 <br><br><h1> 绝招4.下载优化 </h1><br> 典型的C64 PRG二进制文件包含以下内容： <br><br><ul><li> 前2个字节：下载地址（通常<code>$0801</code> ） <br></li><li>  BASIC引导序列的12个字节 </li></ul><br> 主启动顺序如下所示（地址<code>$801-$80C</code> ）： <br><br><pre> <code class="plaintext hljs">0801: 0B 08 0A 00 9E 32 30 36 31 00 00 00 080D: 8D 20 D0 STA $D020</code> </pre> <br> 在不涉及有关<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">BASIC标记化内存布局的</a>细节的情况下，此序列或多或少地对应于“ 10 SYS 2061”。 当BASIC解释器执行SYS命令时，我们的实际机器代码程序将在地址<code>2061</code> （ <code>$080D</code> ）处运行。 <br><br> 似乎14个字节太多了。 菲利普（Philip），马特列夫（Matlev）和盖尔（Geir）使用了几项棘手的技巧完全摆脱了主线。 这需要用PRINT <code>LOAD"*",8,1</code>加载PRG，因为<code>LOAD"*",8</code>忽略PRG加载地址（前两个字节），并且始终以<code>$0801</code>加载。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/911/d07/fdb/911d07fdb2c0e2e13b07e360bb16d03c.png"></div><br><br> 这里使用了两种方法： <br><br><ul><li> 堆叠技巧 <br></li><li> 基本热重置技巧 </li></ul><br><h3> 堆叠技巧 </h3><br> 诀窍是在<code>$01F8</code>处理器堆栈， <code>$01F8</code>值指示我们想要的入口点。 这是通过创建一个以16位指针开头的PRG并将PRG加载到<code>$01F8</code> ： <br><br><pre> <code class="plaintext hljs"> * = $01F8 !word scroll - 1 ; overwrite stack scroll: jsr $E8EA</code> </pre> <br> 一旦BASIC加载程序（请参见<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">拆卸后</a>的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">代码</a> ）完成加载并希望使用<code>RTS</code>返回到调用对象，它将直接返回到我们的PRG。 <br><br><h3> 基本热重置技巧 </h3><br> 只需在拆卸后查看PRG，就可以轻松解释这一点。 <br><br><pre> <code class="plaintext hljs">02E6: 20 EA E8 JSR $E8EA 02E9: A4 D5 LDY $D5 02EB: A9 A0 LDA #$A0 02ED: 99 20 D0 STA $D020,Y 02F0: 91 D1 STA ($D1),Y 02F2: 9D B5 07 STA $07B5,X 02F5: E6 D6 INC $D6 02F7: 65 90 ADC $90 02F9: 85 90 STA $90 02FB: C6 D5 DEC $D5 02FD: 30 FE BMI $02FD 02FF: 90 E7 BCC $02E8 0301: 4C E6 02 JMP $02E6</code> </pre> <br> 注意最后一行（ <code>JMP $02E6</code> ）。  JMP指令从<code>$0301</code>开始，跳转地址为<code>$0302-$0303</code> 。 <br><br> 当此代码从地址<code>$02E6</code>开始加载到内存中时，值<code>$02E6</code>写入地址<code>$0302-$0303</code> 。 好吧，该位置具有特殊含义：它包含一个指向“ BASIC等待周期”的指针（有关更多详细信息，请参见<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">C64存储卡</a> ）。 下载PRG会用<code>$02E6</code>覆盖它，因此，当热复位后BASIC解释器试图进入等待循环时，它永远不会进入此循环，而是进入渲染程序！ <br><br><h3> 推出BASIC的其他技巧 </h3><br>  Petri发现<a href="">了另一个BASIC启动技巧</a> ，使您可以在零页中输入自己的常量。 用这种方法，您可以手动创建自己的标记化BASIC起始序列，并在BASIC程序的行号中编码常量。 在输入处，BASIC行号ahem，即常量将存储在地址<code>$39-$3A</code> 。 很聪明！ <br><br><h1> 技巧5。自定义控制流程 </h1><br> 这是x循环的稍微简化的版本，它只打印一行，然后停止执行： <br><br><pre> <code class="plaintext hljs"> lda #39 sta x1 xloop: lda #$a0 ldx x1 sta $0400 + 24*40, x adc yf sta yf bcc no_scroll ; scroll screen up! jsr $e8ea no_scroll: dec x1 bpl xloop ; intentionally halt at the end inf: jmp inf</code> </pre> <br> 但是有一个错误。 绘制最后一个像素时，我们无法再滚动屏幕。 因此，在记录最后一个像素后，需要其他分支来停止滚动： <br><br><pre> <code class="plaintext hljs"> lda #39 sta x1 xloop: lda #$a0 ldx x1 sta $0400 + 24*40, x dec x1 ; skip scrolling if last pixel bmi done adc yf sta yf bcc no_scroll ; scroll screen up! jsr $e8ea no_scroll: jmp xloop done: ; intentionally halt at the end inf: jmp inf</code> </pre> <br> 控制流程与C编译器将从结构化程序中生成的内容非常相似。 跳过最后滚动的代码引入了一个新的<code>JMP abs</code>指令，该指令占用3个字节。 条件跳转的长度只有两个字节，因为它们使用具有直接寻址功能的相对8位操作数对跳转地址进行编码。 <br><br> 通过将滚动调用移至循环的顶部并略微更改控制流结构，可以避免JMP“跳过最后一个滚动”。  Philip的实现方式如下： <br><br><pre> <code class="plaintext hljs"> lda #39 sta x1 scroll: jsr $e8ea xloop: lda #$a0 ldx x1 sta $0400 + 24*40, x adc yf sta yf dec x1 ; doesn't set carry! inf: bmi inf ; hang here if last pixel! bcc xloop ; next pixel if no scroll bcs scroll ; scroll up and continue</code> </pre> <br> 这完全消除了一个三字节的JMP，并将另一个JMP转换为两个字节的条件分支，总共节省了4个字节。 <br><br><h1> 把戏6。行与位压缩 </h1><br> 一些元素不使用线斜率计数器，而是将这些位压缩为8位常量。 这种封装基于以下事实：像素沿线的位置对应于重复的8像素图案： <br><br><pre> <code class="plaintext hljs">int mask = 0xB6; // 10110110 uint8_t* dst = screenRAM; for (int x = 0; x &lt; 40; x++) { dst[x] = 0xA0; if (mask &amp; (1 &lt;&lt; (x&amp;7))) { dst += 40; // go down a row } }</code> </pre> <br> 这转化为相当紧凑的汇编程序。 但是，倾斜计数器选项通常更小。 <br><br><h3> 优胜者 </h3><br> 这<a href="">是</a> Philip <a href="">的34字节竞赛获奖程序</a> 。 上述大多数技巧都可以在他的代码中很好地发挥作用： <br><br><pre> <code class="plaintext hljs">ov = $22 ; == $40, initial value for the overflow counter ct = $D5 ; == $27 / 39, number of passes. Decrementing, finished at -1 lp = $D1 ; == $07C0, pointer to bottom line. Set by the kernal scroller ; Overwrite the return address of the kernal loader on the stack ; with a pointer to our own code * = $01F8 .word scroll - 1 scroll: jsr $E8EA ; Kernal scroll up, also sets lp pointer to $07C0 loop: ldy ct ; Load the decrementing counter into Y (39 &gt; -1) lda #$A0 ; Load the PETSCII block / black col / ov step value sta $D020, y ; On the last two passes, sets the background black p1: sta $07C0 ; Draw first block (left &gt; right line) sta (lp), y ; Draw second block (right &gt; left line) inc p1 + 1 ; Increment pointer for the left &gt; right line adc ov ; Add step value $A0 to ov sta ov dec ct ; Decrement the Y counter bmi * ; If it goes negative, we're finished bcc loop ; Repeat. If ov didn't overflow, don't scroll bcs scroll ; Repeat. If ov overflowed, scroll</code> </pre> <br><h3> 但是为什么要停留在34个字节上呢？ </h3><br> 竞赛结束后，每个人都分享了他们的代码和注释-并就如何进一步改进进行了一系列热烈的讨论。 在截止日期之后，提出了更多选择： <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">菲利普-33字节</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">菲利普-32字节</a> <br></li><li>  <a href="">Petri-31个字节</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">菲利普-29个字节</a> </li></ul><br> 一定要看-有几颗真珍珠。 <br><br><hr><br> 感谢您的阅读。 还要特别感谢Matlev，Phil，Geir，Petri，Jamie，Ian和David的参与（我希望我不会错过任何一个人-在Twitter上追踪所有提及确实很困难！） <br><br>  PS Petri称我的比赛为“年度”，所以，嗯，可能明年见。 </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN464377/">https://habr.com/ru/post/zh-CN464377/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN464367/index.html">和另一个Steam Windows客户端本地特权升级0天</a></li>
<li><a href="../zh-CN464369/index.html">您使用哪种阻滞剂？ 结果</a></li>
<li><a href="../zh-CN464371/index.html">/etc/resolv.conf，用于Kubernetes Pod，ndots：5个选项，因为这可能会对应用程序性能产生不利影响</a></li>
<li><a href="../zh-CN464373/index.html">Android上的边缘到边缘：做到正确</a></li>
<li><a href="../zh-CN464375/index.html">搜索引擎如何工作</a></li>
<li><a href="../zh-CN464381/index.html">通过目击者的眼睛前往阿拉斯加或KDD'19</a></li>
<li><a href="../zh-CN464383/index.html">我如何在一个有直接手森林（tslint，更漂亮的设置等）的项目中将事物整理好</a></li>
<li><a href="../zh-CN464385/index.html">Python是C ++的终极案例。 第1/2部分</a></li>
<li><a href="../zh-CN464387/index.html">斯堪的纳维亚传奇中的俄罗斯足迹</a></li>
<li><a href="../zh-CN464391/index.html">来自黑客大会的10篇有趣的报道</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>