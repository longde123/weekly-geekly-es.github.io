<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üêæ üë®üèø‚Äçüè´ üêÉ T√©cnica para evitar comportamientos indefinidos al acceder a un singleton üöº üå©Ô∏è üë©üèæ‚Äçü§ù‚Äçüë©üèΩ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="El art√≠culo analiza las causas y los m√©todos para evitar un comportamiento indefinido al acceder a un singleton en c ++ moderno. Se proporcionan ejemp...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>T√©cnica para evitar comportamientos indefinidos al acceder a un singleton</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/455848/">  El art√≠culo analiza las causas y los m√©todos para evitar un comportamiento indefinido al acceder a un singleton en c ++ moderno.  Se proporcionan ejemplos de c√≥digo de subproceso √∫nico.  Nada espec√≠fico del compilador, todo de acuerdo con el est√°ndar. <br><a name="habracut"></a><br><h3>  Introduccion </h3><br>  Para comenzar, le recomiendo que lea otros art√≠culos sobre singleton en Habr√©: <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Tres edades del patr√≥n Singleton</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Singleton e instancias comunes</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">3 maneras de romper el principio de responsabilidad √∫nica</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Singleton: ¬øpatr√≥n o antipatr√≥n?</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Usando el patr√≥n singleton</a> <br><br>  Y, finalmente, un art√≠culo que toc√≥ el mismo tema, pero se desliz√≥ (aunque solo sea porque no se consideraron las desventajas y limitaciones): <br>  objetos marcados (es decir, objetos <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Singleton y vida √∫til del objeto</a> <br><br>  Siguiente: <br><br><ul><li>  Este <b>no</b> es un art√≠culo sobre las propiedades arquitect√≥nicas de Singleton; </li><li>  este <b>no</b> es un art√≠culo "c√≥mo hacer un singleton blanco y esponjoso de un singleton terrible y terrible"; </li><li>  Esta <b>no</b> es <b>una</b> campa√±a √∫nica; </li><li>  no es una cruzada contra singleton; </li><li>  Este <b>no</b> es <b>un</b> art√≠culo final feliz. </li></ul><br>  Este art√≠culo trata sobre un aspecto muy importante, pero a√∫n t√©cnico, del uso de singleton en C ++ moderno.  La atenci√≥n principal en el art√≠culo se presta al momento de la destrucci√≥n del singleton, como  En la mayor√≠a de las fuentes, el tema de la destrucci√≥n est√° poco divulgado.  Por lo general, el √©nfasis est√° en el momento en que se cre√≥ el singleton, y sobre la destrucci√≥n, en el mejor de los casos, dice algo as√≠ como "destruido en el orden inverso". <br><br>  <b>Le pedir√© que siga el alcance del art√≠culo en los comentarios, especialmente para no organizar el holivar "patr√≥n singleton versus antipatr√≥n singleton".</b> <br><br>  Entonces vamos. <br><br><h3>  Lo que dice el est√°ndar </h3><br>  Las citas son del borrador final C ++ 14 N3936, como  los borradores disponibles de C ++ 17 no est√°n marcados como "final". <br>  Doy la secci√≥n m√°s importante en su totalidad.  Lugares importantes son destacados por m√≠. <br><br><blockquote>  3.6.3 Terminaci√≥n [basic.start.term] <br><br>  1. Los destructores (12.4) para objetos inicializados (es decir, objetos cuya vida √∫til (3.8) ha comenzado) con una duraci√≥n de almacenamiento est√°tico se invocan como resultado de regresar de main y como resultado de llamar a std :: exit (18.5).  Los destructores para objetos inicializados con una duraci√≥n de almacenamiento de subprocesos dentro de un subproceso dado se invocan como resultado de regresar de la funci√≥n inicial de ese subproceso y como resultado de que ese subproceso llame a std :: exit.  <b>Las terminaciones de los destructores para todos los objetos inicializados con duraci√≥n de almacenamiento de subprocesos dentro de ese subproceso se secuencian antes del inicio de los destructores de cualquier objeto con duraci√≥n de almacenamiento est√°tico.</b>  <b>Si la finalizaci√≥n del constructor o la inicializaci√≥n din√°mica de un objeto con duraci√≥n de almacenamiento de subprocesos se secuencia antes que la de otro, la finalizaci√≥n del destructor del segundo se secuencia antes del inicio del destructor del primero.</b>  <b>Si la finalizaci√≥n del constructor o la inicializaci√≥n din√°mica de un objeto con una duraci√≥n de almacenamiento est√°tico se secuencia antes que la de otro, la finalizaci√≥n del destructor del segundo se secuencia antes del inicio del destructor del primero.</b>  [Nota: esta definici√≥n permite la destrucci√≥n concurrente.  ‚ÄìNota final] Si un objeto se inicializa est√°ticamente, el objeto se destruye en el mismo orden que si el objeto se inicializara din√°micamente.  Para un objeto de tipo matriz o clase, todos los subobjetos de ese objeto se destruyen antes de que se destruya cualquier objeto de alcance de bloque con una duraci√≥n de almacenamiento est√°tico inicializado durante la construcci√≥n de los subobjetos.  Si la destrucci√≥n de un objeto con una duraci√≥n de almacenamiento est√°tica o de subprocesos sale a trav√©s de una excepci√≥n, se llama std :: terminate (15.5.1). <br><br>  2. <b>Si una funci√≥n contiene un objeto de alcance de bloque de duraci√≥n de almacenamiento est√°tico o de subprocesos que se ha destruido y se llama a la funci√≥n durante la destrucci√≥n de un objeto con duraci√≥n de almacenamiento est√°tico o de subprocesos, el programa tiene un comportamiento indefinido si el flujo de control pasa a trav√©s de la definici√≥n del objeto de blockcope previamente destruido.</b>  Del mismo modo, el comportamiento no est√° definido si el objeto de alcance de bloque se usa indirectamente (es decir, a trav√©s de un puntero) despu√©s de su destrucci√≥n. <br><br>  <b>3. Si la finalizaci√≥n de la inicializaci√≥n de un objeto con una duraci√≥n de almacenamiento est√°tico se secuencia antes de una llamada a std :: atexit (consulte "cstdlib", 18.5), la llamada a la funci√≥n pasada a std :: atexit se secuencia antes de la llamada al destructor para el objeto.</b>  <b>Si una llamada a std :: atexit se secuencia antes de completar la inicializaci√≥n de un objeto con duraci√≥n de almacenamiento est√°tico, la llamada al destructor para el objeto se secuencia antes de que la llamada a la funci√≥n pase a std :: atexit.</b>  <b>Si una llamada a std :: atexit se secuencia antes de otra llamada a std :: atexit, la llamada a la funci√≥n pasada a la segunda llamada std :: atexit se secuencia antes de que la llamada a la funci√≥n pase a la primera llamada std :: atexit .</b> <br><br>  4. Si no se permite el uso de un objeto o funci√≥n de biblioteca est√°ndar dentro de los controladores de se√±al (18.10) que no ocurre antes (1.10) de la destrucci√≥n de objetos con una duraci√≥n de almacenamiento est√°tico y la ejecuci√≥n de funciones registradas std :: atexit (18.5 ), el programa tiene un comportamiento indefinido.  [Nota: Si hay un uso de un objeto con una duraci√≥n de almacenamiento est√°tico que no ocurre antes de la destrucci√≥n del objeto, el programa tiene un comportamiento indefinido.  Terminar cada subproceso antes de una llamada a std :: exit o la salida de main es suficiente, pero no necesario, para satisfacer estos requisitos.  Estos requisitos permiten a los administradores de subprocesos como objetos de duraci√≥n de almacenamiento est√°tico.  ‚ÄîNota final] <br><br>  5. Llamar a la funci√≥n std :: abort () declarada en "cstdlib" finaliza el programa sin ejecutar ning√∫n destructor y sin llamar a las funciones pasadas a std :: atexit () o std :: at_quick_exit (). </blockquote>  Interpretaci√≥n: <br><br><ul><li>  la destrucci√≥n de objetos con duraci√≥n de almacenamiento de subprocesos se realiza en el orden inverso de su creaci√≥n; </li><li>  estrictamente despu√©s de eso, los objetos con una duraci√≥n de almacenamiento est√°tico se destruyen y se realizan llamadas a las funciones registradas con std :: atexit en el orden inverso de crear dichos objetos y registrar dichas funciones; </li><li>  Un intento de acceder a un objeto destruido con una duraci√≥n de almacenamiento de subprocesos o una duraci√≥n de almacenamiento est√°tico contiene un comportamiento indefinido.  No se proporciona la reinicializaci√≥n de dichos objetos. </li></ul><br>  Nota: las variables globales en el est√°ndar se denominan "variables no locales con duraci√≥n de almacenamiento est√°tico".  Como resultado, resulta que todas las variables globales, todos los singletones (estad√≠sticas locales) y todas las llamadas a std :: atexit caen en una sola cola LIFO a medida que se crean / registran. <br><br>  La informaci√≥n √∫til para el art√≠culo tambi√©n est√° contenida en la secci√≥n <b>3.6.2 Inicializaci√≥n de variables no locales [basic.start.init]</b> .  Traigo solo lo m√°s importante: <br><blockquote>  La inicializaci√≥n din√°mica de una variable no local con duraci√≥n de almacenamiento est√°tico est√° ordenada o desordenada.  [...] Las variables con inicializaci√≥n ordenada definida dentro de una √∫nica unidad de traducci√≥n se inicializar√°n en el orden de sus definiciones en la unidad de traducci√≥n. </blockquote>  Interpretaci√≥n (teniendo en cuenta el texto completo de la secci√≥n): las variables globales dentro de una unidad de traducci√≥n se inicializan en el orden de declaraci√≥n. <br><br><h3>  ¬øQu√© habr√° en el c√≥digo? </h3><br>  Todos los ejemplos de c√≥digo proporcionados en el art√≠culo se publican en el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">github</a> . <br><br>  El c√≥digo consta de tres capas, como si estuviera escrito por diferentes personas: <br><br><ul><li>  singleton; </li><li>  utilidad (clase usando singleton); </li><li>  usuario (variables globales y principales). </li></ul><br>  Singleton y la utilidad son como una biblioteca de terceros, y el usuario es el usuario. <br>  La capa de utilidad est√° dise√±ada para aislar la capa de usuario de la capa singleton.  En los ejemplos, el usuario tiene la oportunidad de acceder al singleton, pero actuaremos como si fuera imposible. <br><br>  El usuario primero hace todo bien, y luego con un movimiento de mu√±eca todo se rompe.  Primero intentamos arreglarlo en la capa de utilidad, y si no funciona, entonces en la capa singleton. <br><br>  En el c√≥digo, caminaremos constantemente a lo largo del borde, ahora en el lado claro, luego en la oscuridad.  Para facilitar el cambio al lado oscuro, se eligi√≥ el caso m√°s dif√≠cil: acceder a un singleton desde el destructor de la utilidad. <br><br>  <b>¬øPor qu√© es el caso de llamar desde el destructor el m√°s dif√≠cil?</b>  Debido a que se puede llamar al destructor de la utilidad en el proceso de minimizar la aplicaci√≥n, cuando la pregunta "¬øse ha destruido el singleton o a√∫n no?" Se vuelve relevante. <br><br>  <b>El caso es alg√∫n tipo de sint√©tico.</b>  <b>En la pr√°ctica, no se necesitan llamadas a un singleton desde el destructor.</b>  Incluso seg√∫n sea necesario.  Por ejemplo, para registrar la destrucci√≥n de objetos. <br><br>  Se utilizan tres clases de singleton: <br><br><ul><li>  SingletonClassic: sin punteros inteligentes.  De hecho, no es directamente bastante cl√°sico, pero definitivamente es el m√°s cl√°sico entre los tres considerados; </li><li>  SingletonShared - con std :: shared_ptr; </li><li>  SingletonWeak - con std :: weak_ptr. </li></ul><br>  Todos los singletones son plantillas.  El par√°metro de plantilla se usa para heredar de √©l.  En la mayor√≠a de los ejemplos, est√°n parametrizados por la clase Payload, que proporciona una funci√≥n p√∫blica para agregar datos a std :: set. <br><br>  El destructor de utilidades en la mayor√≠a de los ejemplos intenta completar cien valores all√≠.  La salida de diagn√≥stico a la consola tambi√©n se usa desde el constructor singleton, el destructor singleton y la instancia (). <br><br>  <b>¬øPor qu√© tan dif√≠cil?</b>  Para que sea m√°s f√°cil entender que estamos en el lado oscuro.  Apelar al singleton destruido es un comportamiento indefinido, pero no puede manifestarse de ninguna manera externa.  Los valores de relleno en el std :: set destruido tampoco garantizan manifestaciones externas, pero no hay una forma m√°s confiable (de hecho, en GCC bajo Linux en ejemplos incorrectos con el singleton cl√°sico, el std :: set destruido se rellena con √©xito y en MSVS bajo Windows - se cuelga).  Con un comportamiento indefinido, la salida a la consola puede <b>no</b> ocurrir.  Entonces, en los ejemplos correctos, esperamos la ausencia de acceso a la instancia () despu√©s del destructor, as√≠ como la ausencia de un bloqueo y la ausencia de un bloqueo, y en los incorrectos, ya sea la presencia de tal apelaci√≥n, o un bloqueo, o un bloqueo, o todo a la vez en cualquier combinaci√≥n, o lo que sea. <br><br><h3>  Singleton cl√°sico </h3><br><div class="spoiler">  <b class="spoiler_title">Carga √∫til.h</b> <div class="spoiler_text"><pre><code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> once #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;set&gt; class Payload { public: Payload() = default; ~Payload() = default; Payload(const Payload &amp;) = delete; Payload(Payload &amp;&amp;) = delete; Payload&amp; operator=(const Payload &amp;) = delete; Payload&amp; operator=(Payload &amp;&amp;) = delete; void add(int value) { m_data.emplace(value); } private: std::set&lt;int&gt; m_data; };</span></span></span></span></code> </pre> <br></div></div><br><div class="spoiler">  <b class="spoiler_title">SingletonClassic.h</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> once #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;iostream&gt; template&lt;typename T&gt; class SingletonClassic : public T { public: ~SingletonClassic() { std::cout &lt;&lt; "~SingletonClassic()" &lt;&lt; std::endl; } SingletonClassic(const SingletonClassic &amp;) = delete; SingletonClassic(SingletonClassic &amp;&amp;) = delete; SingletonClassic&amp; operator=(const SingletonClassic &amp;) = delete; SingletonClassic&amp; operator=(SingletonClassic &amp;&amp;) = delete; static SingletonClassic&amp; instance() { std::cout &lt;&lt; "instance()" &lt;&lt; std::endl; static SingletonClassic inst; return inst; } private: SingletonClassic() { std::cout &lt;&lt; "SingletonClassic()" &lt;&lt; std::endl; } };</span></span></span></span></code> </pre><br></div></div><br><h3>  SingletonClassic ejemplo 1 </h3><br><div class="spoiler">  <b class="spoiler_title">Classic_Example1_correct.cpp</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"SingletonClassic.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"Payload.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;memory&gt; class ClassicSingleThreadedUtility { public: ClassicSingleThreadedUtility() { // To ensure that singleton will be constucted before utility SingletonClassic&lt;Payload&gt;::instance(); } ~ClassicSingleThreadedUtility() { auto &amp;instance = SingletonClassic&lt;Payload&gt;::instance(); for ( int i = 0; i &lt; 100; ++i ) instance.add(i); } }; // 1. Create an empty unique_ptr // 2. Create singleton (because of modified ClassicSingleThreadedUtility c-tor) // 3. Create utility std::unique_ptr&lt;ClassicSingleThreadedUtility&gt; emptyUnique; auto utilityUnique = std::make_unique&lt;ClassicSingleThreadedUtility&gt;(); // This guarantee destruction in order: // - utilityUnique; // - singleton; // - emptyUnique. // This order is correct int main() { return 0; }</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">Salida de la consola</b> <div class="spoiler_text">  instancia () <br>  SingletonClassic () <br>  instancia () <br>  ~ SingletonClassic () <br></div></div><br>  La utilidad llama al singleton en el constructor para garantizar que se cree el singleton antes de que se cree la utilidad. <br><br>  El usuario crea dos std :: unique_ptr: uno vac√≠o, el segundo contiene la utilidad. <br><br>  El orden de la creaci√≥n: <br><br>  - std vac√≠o :: unique_ptr. <br>  - singleton <br>  - utilidad. <br><br>  Y en consecuencia, el orden de destrucci√≥n: <br><br>  - utilidad; <br>  - singleton <br>  - std vac√≠o :: unique_ptr. <br><br>  La llamada del destructor de la utilidad al singleton es correcta. <br><br><h3>  SingletonClassic ejemplo 2 </h3><br>  Todo es igual, pero el usuario lo tom√≥ y lo arruin√≥ todo con una sola l√≠nea. <br><br><div class="spoiler">  <b class="spoiler_title">Classic_Example2_incorrect.cpp</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"SingletonClassic.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"Payload.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;memory&gt; class ClassicSingleThreadedUtility { public: ClassicSingleThreadedUtility() { // To ensure that singleton will be constucted before utility SingletonClassic&lt;Payload&gt;::instance(); } ~ClassicSingleThreadedUtility() { auto &amp;instance = SingletonClassic&lt;Payload&gt;::instance(); for ( int i = 0; i &lt; 100; ++i ) instance.add(i); } }; // 1. Create an empty unique_ptr // 2. Create singleton (because of modified ClassicSingleThreadedUtility c-tor) // 3. Create utility std::unique_ptr&lt;ClassicSingleThreadedUtility&gt; emptyUnique; auto utilityUnique = std::make_unique&lt;ClassicSingleThreadedUtility&gt;(); // This guarantee destruction in order: // - utilityUnique; // - singleton; // - emptyUnique. // This order seems to be correct ... int main() { // ... but user swaps unique_ptrs emptyUnique.swap(utilityUnique); // Guaranteed destruction order is still the same: // - utilityUnique; // - singleton; // - emptyUnique, // but now utilityUnique is empty, and emptyUnique is filled, // so destruction order is incorrect return 0; }</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">Salida de la consola</b> <div class="spoiler_text">  instancia () <br>  SingletonClassic () <br>  ~ SingletonClassic () <br>  instancia () <br></div></div><br>  Se preserva el orden de creaci√≥n y destrucci√≥n.  Parece que todo est√° quieto.  Pero no  Al invocar emptyUnique.swap (utilityUnique), el usuario cometi√≥ un comportamiento indefinido. <br><br>  <b>¬øPor qu√© el usuario hizo cosas tan est√∫pidas?</b>  Porque no sabe nada sobre la estructura interna de la biblioteca, que le proporcion√≥ un singleton y utilidad. <br><br>  <b>¬øY si conoces la estructura interna de la biblioteca?</b>  ... de todos modos, en c√≥digo real es muy f√°cil involucrarse.  Y tienes que salir por dolorosa discusi√≥n, porque  entender qu√© sucedi√≥ exactamente no ser√° f√°cil. <br><br>  <b>¬øPor qu√© no requiere que la biblioteca se use correctamente?</b>  <b>Bueno, hay todo tipo de muelles para escribir, ejemplos ...</b> ¬øY por qu√© no hacer una biblioteca que no sea tan f√°cil de estropear? <br><br><h3>  SingletonClassic ejemplo 3 </h3><br>  En el curso de la preparaci√≥n del art√≠culo durante varios d√≠as, cre√≠ que era imposible eliminar el comportamiento indefinido del ejemplo anterior en la capa de utilidad, y la soluci√≥n solo estaba disponible en la capa singleton.  Pero con el tiempo, sin embargo, surgi√≥ una soluci√≥n. <br><br>  Antes de abrir los spoilers con el c√≥digo y la explicaci√≥n, sugiero al lector que intente encontrar una salida a la situaci√≥n por su cuenta (¬°solo en la capa de utilidad!).  No excluyo que haya mejores soluciones. <br><br><div class="spoiler">  <b class="spoiler_title">Classic_Example3_correct.cpp</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"SingletonClassic.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"Payload.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;memory&gt; #include &lt;iostream&gt; class ClassicSingleThreadedUtility { public: ClassicSingleThreadedUtility() { thread_local auto flag_strong = std::make_shared&lt;char&gt;(0); m_flag_weak = flag_strong; SingletonClassic&lt;Payload&gt;::instance(); } ~ClassicSingleThreadedUtility() { if ( !m_flag_weak.expired() ) { auto &amp;instance = SingletonClassic&lt;Payload&gt;::instance(); for ( int i = 0; i &lt; 100; ++i ) instance.add(i); } } private: std::weak_ptr&lt;char&gt; m_flag_weak; }; // 1. Create an empty unique_ptr // 2. Create singleton (because of modified ClassicSingleThreadedUtility c-tor) // 3. Create utility std::unique_ptr&lt;ClassicSingleThreadedUtility&gt; emptyUnique; auto utilityUnique = std::make_unique&lt;ClassicSingleThreadedUtility&gt;(); // This guarantee destruction in order: // - utilityUnique; // - singleton; // - emptyUnique. // This order seems to be correct ... int main() { // ... but user swaps unique_ptrs emptyUnique.swap(utilityUnique); { // To demonstrate normal processing before application ends auto utility = ClassicSingleThreadedUtility(); } // Guaranteed destruction order is still the same: // - utilityUnique; // - singleton; // - emptyUnique, // but now utilityUnique is empty, and emptyUnique is filled, // so destruction order is incorrect ... // ... but utility uses a variable with thread storage duration to detect thread termination. return 0; }</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">Salida de la consola</b> <div class="spoiler_text">  instancia () <br>  SingletonClassic () <br>  instancia () <br>  instancia () <br>  ~ SingletonClassic () <br></div></div><br><div class="spoiler">  <b class="spoiler_title">Explicaci√≥n</b> <div class="spoiler_text">  El problema solo ocurre al minimizar la aplicaci√≥n.  El comportamiento indefinido puede eliminarse ense√±ando a la utilidad a reconocer cu√°ndo se minimiza la aplicaci√≥n.  Para hacer esto, utilizamos una variable flag_strong del tipo std :: shared_ptr, que tiene un calificador de duraci√≥n de almacenamiento de subprocesos (ver extractos del est√°ndar en el art√≠culo anterior): esto es como una est√°tica, pero solo se destruye cuando el subproceso actual termina <b>antes de que se destruya cualquiera de las estad√≠sticas</b> , incluso antes de la destrucci√≥n Singleton  La variable flag_strong es una para todo el flujo, y cada instancia de la utilidad almacena su copia d√©bil. <br><br>  En un sentido estricto, la soluci√≥n se puede llamar un truco, porque  es indirecto y no obvio.  Adem√°s, advierte demasiado pronto y, a veces (en una aplicaci√≥n multiproceso) generalmente advierte falso.  Pero en un sentido amplio, esto no es un truco, sino una soluci√≥n completamente definida por las propiedades est√°ndar, tanto desventajas como ventajas. <br></div></div><br><h3>  Singletonshared </h3><br>  Pasemos a un singleton modificado basado en std :: shared_ptr. <br><br><div class="spoiler">  <b class="spoiler_title">SingletonShared.h</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> once #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;memory&gt; #include &lt;iostream&gt; template&lt;typename T&gt; class SingletonShared : public T { public: ~SingletonShared() { std::cout &lt;&lt; "~SingletonShared()" &lt;&lt; std::endl; } SingletonShared(const SingletonShared &amp;) = delete; SingletonShared(SingletonShared &amp;&amp;) = delete; SingletonShared&amp; operator=(const SingletonShared &amp;) = delete; SingletonShared&amp; operator=(SingletonShared &amp;&amp;) = delete; static std::shared_ptr&lt;SingletonShared&gt; instance() { std::cout &lt;&lt; "instance()" &lt;&lt; std::endl; // "new" and no std::make_shared because of private c-tor static auto inst = std::shared_ptr&lt;SingletonShared&gt;(new SingletonShared); return inst; } private: SingletonShared() { std::cout &lt;&lt; "SingletonShared()" &lt;&lt; std::endl; } };</span></span></span></span></code> </pre><br></div></div><br>  <b>Ay-ah-ah, el nuevo operador no debe usarse en c√≥digo moderno, ¬°en cambio se necesita std :: make_shared!</b>  Y esto es evitado por el constructor privado del singleton. <br><br>  <b>Ja!</b>  <b>¬°Yo tambi√©n tengo un problema!</b>  <b>Declare std :: make_shared un singleton freind!</b>  ... y obtenga una variaci√≥n del antipatr√≥n PublicMorozov: usando el mismo std :: make_shared, ser√° posible crear instancias adicionales del singleton que no son provistas por la arquitectura. <br><br><h3>  SingletonShared Ejemplos 1 y 2 </h3><br>  Corresponde totalmente a los ejemplos No. 1 y 2 para la versi√≥n cl√°sica.  Se hicieron cambios significativos solo en la capa singleton, la utilidad esencialmente permaneci√≥ igual.  Al igual que en los ejemplos con el singleton cl√°sico, el ejemplo 1 es correcto y el ejemplo 2 muestra un comportamiento indefinido. <br><br><div class="spoiler">  <b class="spoiler_title">Shared_Example1_correct.cpp</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"SingletonShared.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;Payload.h&gt; #include &lt;memory&gt; class SharedSingleThreadedUtility { public: SharedSingleThreadedUtility() { // To ensure that singleton will be constucted before utility SingletonShared&lt;Payload&gt;::instance(); } ~SharedSingleThreadedUtility() { if ( auto instance = SingletonShared&lt;Payload&gt;::instance() ) for ( int i = 0; i &lt; 100; ++i ) instance-&gt;add(i); } }; // 1. Create an empty unique_ptr // 2. Create singleton (because of modified SharedSingleThreadedUtility c-tor) // 3. Create utility std::unique_ptr&lt;SharedSingleThreadedUtility&gt; emptyUnique; auto utilityUnique = std::make_unique&lt;SharedSingleThreadedUtility&gt;(); // This guarantee destruction in order: // - utilityUnique; // - singleton; // - emptyUnique. // This order is correct int main() { return 0; }</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">Salida de la consola</b> <div class="spoiler_text">  instancia () <br>  SingletonShared () <br>  instancia () <br>  ~ SingletonShared () <br></div></div><br><div class="spoiler">  <b class="spoiler_title">Shared_Example2_incorrect.cpp</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"SingletonShared.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"Payload.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;memory&gt; class SharedSingleThreadedUtility { public: SharedSingleThreadedUtility() { // To ensure that singleton will be constucted before utility SingletonShared&lt;Payload&gt;::instance(); } ~SharedSingleThreadedUtility() { // Sometimes this check may result as "false" even for destroyed singleton // preventing from visual effects of undefined behaviour ... //if ( auto instance = SingletonShared::instance() ) // for ( int i = 0; i &lt; 100; ++i ) // instance-&gt;add(i); // ... so this code will demonstrate UB in colour auto instance = SingletonShared&lt;Payload&gt;::instance(); for ( int i = 0; i &lt; 100; ++i ) instance-&gt;add(i); } }; // 1. Create an empty unique_ptr // 2. Create singleton (because of modified SharedSingleThreadedUtility c-tor) // 3. Create utility std::unique_ptr&lt;SharedSingleThreadedUtility&gt; emptyUnique; auto utilityUnique = std::make_unique&lt;SharedSingleThreadedUtility&gt;(); // This guarantee destruction in order: // - utilityUnique; // - singleton; // - emptyUnique. // This order seems to be correct ... int main() { // ... but user swaps unique_ptrs emptyUnique.swap(utilityUnique); // Guaranteed destruction order is the same: // - utilityUnique; // - singleton; // - emptyUnique, // but now utilityUnique is empty, and emptyUnique is filled, // so destruction order is incorrect return 0; }</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">Salida de la consola</b> <div class="spoiler_text">  instancia () <br>  SingletonShared () <br>  ~ SingletonShared () <br>  instancia () <br></div></div><br><h3>  SingletonShared ejemplo 3 </h3><br>  Y ahora intentaremos solucionar este problema mejor que en el ejemplo n√∫mero 3 de los cl√°sicos. <br>  La soluci√≥n es obvia: solo necesita extender la vida √∫til del singleton almacenando una copia de std :: shared_ptr devuelta por el singleton en la utilidad.  Y esta soluci√≥n, completa con SingletonShared, ha sido ampliamente replicada en c√≥digo abierto. <br><br><div class="spoiler">  <b class="spoiler_title">Shared_Example3_correct.cpp</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"SingletonShared.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"Payload.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;memory&gt; class SharedSingleThreadedUtility { public: SharedSingleThreadedUtility() // To ensure that singleton will be constucted before utility : m_singleton(SingletonShared&lt;Payload&gt;::instance()) { } ~SharedSingleThreadedUtility() { // Sometimes this check may result as "false" even for destroyed singleton // preventing from visual effects of undefined behaviour ... //if ( m_singleton ) // for ( int i = 0; i &lt; 100; ++i ) // m_singleton-&gt;add(i); // ... so this code will allow to demonstrate UB in colour for ( int i = 0; i &lt; 100; ++i ) m_singleton-&gt;add(i); } private: // A copy of smart pointer, not a reference std::shared_ptr&lt;SingletonShared&lt;Payload&gt;&gt; m_singleton; }; // 1. Create an empty unique_ptr // 2. Create singleton (because of SharedSingleThreadedUtility c-tor) // 3. Create utility std::unique_ptr&lt;SharedSingleThreadedUtility&gt; emptyUnique; auto utilityUnique = std::make_unique&lt;SharedSingleThreadedUtility&gt;(); int main() { // This guarantee destruction in order: // - utilityUnique; // - singleton; // - emptyUnique. // This order is correct ... // ... but user swaps unique_ptrs emptyUnique.swap(utilityUnique); // Guaranteed destruction order is the same: // - utilityUnique; // - singleton; // - emptyUnique, // but now utilityUnique is empty, and emptyUnique is filled, // so destruction order is incorrect... // ... but utility have made a copy of shared_ptr when it was available, // so it's correct again. return 0; }</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">Salida de la consola</b> <div class="spoiler_text">  instancia () <br>  SingletonShared () <br>  ~ SingletonShared () <br></div></div><br>  Y ahora, atenci√≥n, la pregunta es: <b>¬ørealmente quer√≠as extender la vida de un singleton?</b> <br>  ¬øO deseaba deshacerse del comportamiento indefinido y elegir la extensi√≥n de la vida como una forma de permanecer en la superficie? <br><br>  La incorrecci√≥n te√≥rica en forma de sustituci√≥n de objetivos por medio conduce al riesgo de punto muerto (o referencia c√≠clica: ll√°melo como quiera). <br><br>  <b>S√≠ nuuuuuu, as√≠ es como tienes que esforzarte tanto?</b>  <b>Tendr√°s que pensar en tanto tiempo, ¬°y ciertamente no lo har√°s por accidente!</b> <br><br><div class="spoiler">  <b class="spoiler_title">CallbackPayload.h</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> once #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;functional&gt; class CallbackPayload { public: CallbackPayload() = default; ~CallbackPayload() = default; CallbackPayload(const CallbackPayload &amp;) = delete; CallbackPayload(CallbackPayload &amp;&amp;) = delete; CallbackPayload&amp; operator=(const CallbackPayload &amp;) = delete; CallbackPayload&amp; operator=(CallbackPayload &amp;&amp;) = delete; void setCallback(std::function&lt;void()&gt; &amp;&amp;fn) { m_callbackFn = std::move(fn); } private: std::function&lt;void()&gt; m_callbackFn; };</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">SomethingWithVeryImportantDestructor.h</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> once #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;iostream&gt; class SomethingWithVeryImportantDestructor { public: SomethingWithVeryImportantDestructor() { std::cout &lt;&lt; "SomethingWithVeryImportantDestructor()" &lt;&lt; std::endl; } ~SomethingWithVeryImportantDestructor() { std::cout &lt;&lt; "~SomethingWithVeryImportantDestructor()" &lt;&lt; std::endl; } SomethingWithVeryImportantDestructor(const SomethingWithVeryImportantDestructor &amp;) = delete; SomethingWithVeryImportantDestructor(SomethingWithVeryImportantDestructor &amp;&amp;) = delete; SomethingWithVeryImportantDestructor&amp; operator=(const SomethingWithVeryImportantDestructor &amp;) = delete; SomethingWithVeryImportantDestructor&amp; operator=(SomethingWithVeryImportantDestructor &amp;&amp;) = delete; };</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">Shared_Example4_incorrect.cpp</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"SingletonShared.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"CallbackPayload.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"SomethingWithVeryImportantDestructor.h"</span></span></span><span class="hljs-meta"> class SharedSingleThreadedUtility { public: SharedSingleThreadedUtility() </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// To ensure that singleton will be constucted before utility : m_singleton(SingletonShared&lt;CallbackPayload&gt;::instance()) { std::cout &lt;&lt; "SharedSingleThreadedUtility()" &lt;&lt; std::endl; } ~SharedSingleThreadedUtility() { std::cout &lt;&lt; "~SharedSingleThreadedUtility()" &lt;&lt; std::endl; } void setCallback(std::function&lt;void()&gt; &amp;&amp;fn) { if ( m_singleton ) m_singleton-&gt;setCallback(std::move(fn)); } private: // A copy of smart pointer, not a reference std::shared_ptr&lt;SingletonShared&lt;CallbackPayload&gt;&gt; m_singleton; }; int main() { auto utility = std::make_shared&lt;SharedSingleThreadedUtility&gt;(); auto something = std::make_shared&lt;SomethingWithVeryImportantDestructor&gt;(); // lambda with "utility" and "something" captured utility-&gt;setCallback( [utility, something](){} ); return 0; }</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">Salida de la consola</b> <div class="spoiler_text">  instancia () <br>  SingletonShared () <br>  SharedSingleThreadedUtility () <br>  SomethingWithVeryImportantDestructor () <br></div></div><br>  Se cre√≥ un singleton. <br><br>  Se ha creado una utilidad. <br><br>  <b>Se cre√≥ algo S-Very-Important-Destructor</b> (agregu√© esto para intimidar, porque en Internet hay publicaciones como "bueno, el destructor de singleton no se llamar√°, as√≠ que qu√© pasa, debe existir todo el tiempo programas "). <br><br>  ¬°Pero no se llam√≥ a ning√∫n destructor para ninguno de estos objetos! <br><br>  ¬øPor qu√©?  Debido a la sustituci√≥n de goles por medios. <br><br><h3>  Singletonweak </h3><br><div class="spoiler">  <b class="spoiler_title">SingletonWeak.h</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> once #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;memory&gt; #include &lt;iostream&gt; template&lt;typename T&gt; class SingletonWeak : public T { public: ~SingletonWeak() { std::cout &lt;&lt; "~SingletonWeak()" &lt;&lt; std::endl; } SingletonWeak(const SingletonWeak &amp;) = delete; SingletonWeak(SingletonWeak &amp;&amp;) = delete; SingletonWeak&amp; operator=(const SingletonWeak &amp;) = delete; SingletonWeak&amp; operator=(SingletonWeak &amp;&amp;) = delete; static std::weak_ptr&lt;SingletonWeak&gt; instance() { std::cout &lt;&lt; "instance()" &lt;&lt; std::endl; // "new" and no std::make_shared because of private c-tor static auto inst = std::shared_ptr&lt;SingletonWeak&gt;(new SingletonWeak); return inst; } private: SingletonWeak() { std::cout &lt;&lt; "SingletonWeak()" &lt;&lt; std::endl; } };</span></span></span></span></code> </pre><br></div></div><br>  Tal modificaci√≥n del singleton en fuentes abiertas, si se da, ciertamente no es frecuente.  Encontr√© algunas variantes extra√±as al rev√©s con un std :: weak_ptr, que parece ser usado, que, al parecer, ofrece a la utilidad nada m√°s que prolongar la vida de un singleton: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Singletons usando std :: weak_ptr</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">¬øEs la manera correcta de crear la clase sinlgeton por weak_ptr</a> </li></ul><br>  La opci√≥n que propongo, cuando se aplica correctamente en capas singleton y de utilidad: <br><br><ul><li>  protege contra acciones en la capa de usuario descrita en los ejemplos anteriores, incluida la prevenci√≥n de puntos muertos; </li><li>  determina el momento de plegado de la aplicaci√≥n con mayor precisi√≥n que la aplicaci√≥n thread_local en Classic_Example3_correct, es decir  le permite acercarse al borde; </li><li>  No sufro el problema te√≥rico de sustituir objetivos con medios (no s√© si puede surgir algo tangible que no sea un punto muerto a partir de este problema te√≥rico). </li></ul><br>  Sin embargo, hay un inconveniente: extender la vida √∫til de un singleton <b>a√∫n</b> puede permitir que <b>se</b> acerque <b>a√∫n m√°s</b> al borde. <br><br><h3>  SingletonWeak ejemplo 1 </h3><br>  Similar a Shared_Example3_correct.cpp. <br><br><div class="spoiler">  <b class="spoiler_title">Weak_Example1_correct.cpp</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"SingletonWeak.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"Payload.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;memory&gt; class WeakSingleThreadedUtility { public: WeakSingleThreadedUtility() // To ensure that singleton will be constucted before utility : m_weak(SingletonWeak&lt;Payload&gt;::instance()) { } ~WeakSingleThreadedUtility() { // Sometimes this check may result as "false" even in case of incorrect usage, // and there's no way to guarantee a demonstration of undefined behaviour in colour if ( auto strong = m_weak.lock() ) for ( int i = 0; i &lt; 100; ++i ) strong-&gt;add(i); } private: // A weak copy of smart pointer, not a reference std::weak_ptr&lt;SingletonWeak&lt;Payload&gt;&gt; m_weak; }; // 1. Create an empty unique_ptr // 2. Create singleton (because of WeakSingleThreadedUtility c-tor) // 3. Create utility std::unique_ptr&lt;WeakSingleThreadedUtility&gt; emptyUnique; auto utilityUnique = std::make_unique&lt;WeakSingleThreadedUtility&gt;(); int main() { // This guarantee destruction in order: // - utilityUnique; // - singleton; // - emptyUnique. // This order is correct ... // ... but user swaps unique_ptrs emptyUnique.swap(utilityUnique); // Guaranteed destruction order is the same: // - utilityUnique; // - singleton; // - emptyUnique, // but now utilityUnique is empty, and emptyUnique is filled, // so destruction order is incorrect... // ... but utility have made a weak copy of shared_ptr when it was available, // so it's correct again. return 0; }</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">Salida de la consola</b> <div class="spoiler_text">  instancia () <br>  SingletonWeak () <br>  ~ SingletonWeak () <br></div></div><br>  <b>¬øPor qu√© necesitamos SingletonWeak, porque nadie molesta a la utilidad para usar SingletonShared como SingletonWeak?</b>  S√≠, nadie se molesta.  E incluso nadie molesta la utilidad de usar SingletonWeak como SingletonShared.  Pero usarlos para los fines previstos es un poco m√°s f√°cil que usarlos para otros fines. <br><br><h3>  SingletonWeak ejemplo 2 </h3><br>  Similar a Shared_Example4_incorrect, pero solo no se produce un punto muerto en este caso. <br><br><div class="spoiler">  <b class="spoiler_title">Weak_Example2_correct.cpp</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"SingletonWeak.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"CallbackPayload.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"SomethingWithVeryImportantDestructor.h"</span></span></span><span class="hljs-meta"> class WeakSingleThreadedUtility { public: WeakSingleThreadedUtility() </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// To ensure that singleton will be constucted before utility : m_weak(SingletonWeak&lt;CallbackPayload&gt;::instance()) { std::cout &lt;&lt; "WeakSingleThreadedUtility()" &lt;&lt; std::endl; } ~WeakSingleThreadedUtility() { std::cout &lt;&lt; "~WeakSingleThreadedUtility()" &lt;&lt; std::endl; } void setCallback(std::function&lt;void()&gt; &amp;&amp;fn) { if ( auto strong = m_weak.lock() ) strong-&gt;setCallback(std::move(fn)); } private: // A weak copy of smart pointer, not a reference std::weak_ptr&lt;SingletonWeak&lt;CallbackPayload&gt;&gt; m_weak; }; int main() { auto utility = std::make_shared&lt;WeakSingleThreadedUtility&gt;(); auto something = std::make_shared&lt;SomethingWithVeryImportantDestructor&gt;(); // lambda with "utility" and "something" captured utility-&gt;setCallback( [utility, something](){} ); return 0; }</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">Salida de la consola</b> <div class="spoiler_text">  instancia () <br>  SingletonWeak () <br>  WeakSingleThreadedUtility () <br>  SomethingWithVeryImportantDestructor () <br>  ~ SingletonWeak () <br>  ~ SomethingWithVeryImportantDestructor () <br>  ~ WeakSingleThreadedUtility () <br></div></div><br><h3>  En lugar de una conclusi√≥n </h3><br>  <b>¬øY qu√©, tal modificaci√≥n de un singleton eliminar√° el comportamiento indefinido?</b>  Promet√≠ que no habr√≠a un final feliz.  Los siguientes ejemplos muestran que las acciones de sabotaje habilidosas en la capa de usuario pueden destruir incluso la biblioteca pensada correcta con un singleton (pero debemos admitir que <b>esto</b> dif√≠cilmente se puede hacer por accidente). <br><br><div class="spoiler">  <b class="spoiler_title">Shared_Example5_incorrect.cpp</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"SingletonShared.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"Payload.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;memory&gt; #include &lt;cstdlib&gt; class SharedSingleThreadedUtility { public: SharedSingleThreadedUtility() // To ensure that singleton will be constucted before utility : m_singleton(SingletonShared&lt;Payload&gt;::instance()) { } ~SharedSingleThreadedUtility() { // Sometimes this check may result as "false" even for destroyed singleton // preventing from visual effects of undefined behaviour ... //if ( m_singleton ) // for ( int i = 0; i &lt; 100; ++i ) // m_singleton-&gt;add(i); // ... so this code will allow to demonstrate UB in colour for ( int i = 0; i &lt; 100; ++i ) m_singleton-&gt;add(i); } private: // A copy of smart pointer, not a reference std::shared_ptr&lt;SingletonShared&lt;Payload&gt;&gt; m_singleton; }; void cracker() { SharedSingleThreadedUtility(); } // 1. Register cracker() using std::atexit // 2. Create singleton // 3. Create utility auto reg = [](){ std::atexit(&amp;cracker); return 0; }(); auto utility = SharedSingleThreadedUtility(); // This guarantee destruction in order: // - utility; // - singleton. // This order is correct. // Additionally, there's a copy of shared_ptr in the class instance... // ... but there was std::atexit registered before singleton, // so cracker() will be invoked after destruction of utility and singleton. // There's second try to create a singleton - and it's incorrect. int main() { return 0; }</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">Salida de la consola</b> <div class="spoiler_text">  instancia () <br>  SingletonShared () <br>  ~ SingletonShared () <br>  instancia () <br></div></div><br><div class="spoiler">  <b class="spoiler_title">Weak_Example3_incorrect.cpp</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"SingletonWeak.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"Payload.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;memory&gt; #include &lt;cstdlib&gt; class WeakSingleThreadedUtility { public: WeakSingleThreadedUtility() // To ensure that singleton will be constucted before utility : m_weak(SingletonWeak&lt;Payload&gt;::instance()) { } ~WeakSingleThreadedUtility() { // Sometimes this check may result as "false" even in case of incorrect usage, // and there's no way to guarantee a demonstration of undefined behaviour in colour if ( auto strong = m_weak.lock() ) for ( int i = 0; i &lt; 100; ++i ) strong-&gt;add(i); } private: // A weak copy of smart pointer, not a reference std::weak_ptr&lt;SingletonWeak&lt;Payload&gt;&gt; m_weak; }; void cracker() { WeakSingleThreadedUtility(); } // 1. Register cracker() using std::atexit // 2. Create singleton // 3. Create utility auto reg = [](){ std::atexit(&amp;cracker); return 0; }(); auto utility = WeakSingleThreadedUtility(); // This guarantee destruction in order: // - utility; // - singleton. // This order is correct. // Additionally, there's a copy of shared_ptr in the class instance... // ... but there was std::atexit registered before singleton, // so cracker() will be invoked after destruction of utility and singleton. // There's second try to create a singleton - and it's incorrect. int main() { return 0; }</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">Salida de la consola</b> <div class="spoiler_text">  instancia () <br>  SingletonWeak () <br>  ~ SingletonWeak () <br>  instancia () <br></div></div></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/455848/">https://habr.com/ru/post/455848/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../455832/index.html">Historia de una sola investigaci√≥n SQL</a></li>
<li><a href="../455834/index.html">Benchmarks para servidores Linux: 5 herramientas abiertas</a></li>
<li><a href="../455840/index.html">C√≥mo trabajar con m√∫ltiples consultas. Composici√≥n, Reductor, FP</a></li>
<li><a href="../455842/index.html">Difundir una lista vinculada individualmente. Edici√≥n r√°pida</a></li>
<li><a href="../455844/index.html">Creaci√≥n de un analizador Roslyn utilizando pruebas de encapsulaci√≥n como ejemplo</a></li>
<li><a href="../455850/index.html">Caja de herramientas para investigadores - Tercera edici√≥n: Encontrar y trabajar con fuentes</a></li>
<li><a href="../455852/index.html">Levantamiento de senos e implantaci√≥n simult√°nea</a></li>
<li><a href="../455854/index.html">C√≥mo implementar men√∫s contextuales en iOS 13</a></li>
<li><a href="../455856/index.html">Sensor inal√°mbrico de temperatura, humedad y presi√≥n atmosf√©rica en nRF52832</a></li>
<li><a href="../455858/index.html">Redes de TV por cable para los m√°s peque√±os. Parte 9: cabecera</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>