<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üëÉüèª ‚ú≥Ô∏è üßîüèª Convertendo modelos poligonais em representa√ß√£o de limites: exemplos de algoritmos e c√≥digos üòß üëá ü§≤üèΩ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Na maioria dos sistemas de design (CAD), a representa√ß√£o principal do objeto simulado √© a representa√ß√£o de limite da geometria ou B-rep (representa√ß√£o...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Convertendo modelos poligonais em representa√ß√£o de limites: exemplos de algoritmos e c√≥digos</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/465869/"> Na maioria dos sistemas de design (CAD), a representa√ß√£o principal do objeto simulado √© a representa√ß√£o de limite da geometria ou B-rep (representa√ß√£o de limite).  Por√©m, cada vez mais, os usu√°rios de CAD precisam lidar com modelos de pol√≠gonos, por exemplo, obtidos como resultado da digitaliza√ß√£o em 3D ou emprestados de cat√°logos on-line. <br>  Para torn√°-los adequados para trabalhos futuros, voc√™ precisa converter a malha de pol√≠gono em um modelo B-rep.  E isso n√£o √© nada f√°cil. <br>  Desenvolvemos o componente de software C3D B-Shaper, que √© integrado ao sistema de design e converte modelos poligonais em uma representa√ß√£o de fronteira.  Neste post, mostraremos o algoritmo de convers√£o e exemplos de implementa√ß√£o em C ++. <br><br><img src="https://habrastorage.org/webt/df/p5/gz/dfp5gzfpczrbjte9f0gy-e-i0x0.png" alt="imagem"><br><a name="habracut"></a><br><br>  Qual √© o principal problema dos modelos poligonais em termos de CAD?  As ferramentas tradicionais n√£o podem ser aplicadas a elas - para executar opera√ß√µes booleanas, construir chanfros e filetes, obter proje√ß√µes e se√ß√µes.  Se o uso do modelo B-rep para construir sua representa√ß√£o poligonal √© bastante f√°cil (isso √© feito usando triangula√ß√£o), a transforma√ß√£o inversa √© muito mais dif√≠cil.  Surgem v√°rios problemas - o reconhecimento de superf√≠cies de v√°rios tipos (incluindo superf√≠cies de forma livre), a presen√ßa de ru√≠do, caracter√≠sticos, por exemplo, dos resultados da digitaliza√ß√£o em 3D. <br><br>  No novo SDK, implementamos um mecanismo de tr√™s est√°gios para converter o modelo poligonal em B-rep: segmenta√ß√£o, reconstru√ß√£o de superf√≠cie, constru√ß√£o do modelo B-rep.  Em geral, o processo √© considerado iterativo: se por algum motivo o usu√°rio n√£o estiver satisfeito com o resultado, ele poder√° fazer as altera√ß√µes corretivas necess√°rias nos est√°gios de segmenta√ß√£o e reconstru√ß√£o de superf√≠cies. <br><br><img src="https://habrastorage.org/webt/pq/me/vz/pqmevzxv9fib3_wju48vzznszci.png" alt="imagem"><br>  <i>O esquema para converter uma representa√ß√£o poligonal em um limite</i> <br><br>  Antes de iniciar o processo de convers√£o em B-rep, √© necess√°rio, em alguns casos, melhorar a qualidade da malha poligonal original: coordenar as dire√ß√µes das normais nos pol√≠gonos vizinhos, eliminar ‚Äúburacos‚Äù, aplicar algoritmos de suaviza√ß√£o na presen√ßa de ru√≠do na malha original. <br><br><h1>  <font color="#00B2FF">Segmenta√ß√£o de pol√≠gono</font> </h1><br>  No primeiro est√°gio, o conjunto inicial de pol√≠gonos de malha √© classificado em subconjuntos (segmentos).  As informa√ß√µes sobre os normais nos v√©rtices da malha permitem a segmenta√ß√£o de primeira ordem e, assim, garantem a parti√ß√£o inicial da malha, al√©m de classificar √°reas planas ou fortemente curvas. <br><br>  A malha inicial √© baseada na defini√ß√£o das chamadas arestas "agudas" - arestas entre dois pol√≠gonos triangulares cujo √¢ngulo entre as normais m√©dias excede um determinado valor predeterminado. <br><br>  A segmenta√ß√£o de segunda ordem analisa a grade de acordo com suas principais curvaturas, o que fornece uma base suficiente para a classifica√ß√£o de superf√≠cies elementares.  Para calcular as curvaturas nos v√©rtices da grade, usamos os resultados de Mayer (Mark Meyer, Mathieu Desbrun, Peter Schroder e Alan H. Barr, Operadores de Geometria Diferencial Discreta para 2-Manifolds Triangulares, Visualiza√ß√£o e Matem√°tica III, 2003) para determinar o diferencial discreto operador para regi√µes trianguladas: para cada v√©rtice da malha original, consideramos um conjunto de v√©rtices vizinhos associados a um determinado v√©rtice atrav√©s de uma aresta.  Ent√£o, um operador discreto <i>K √©</i> calculado para um determinado v√©rtice, com base no qual a curvatura normal normal, m√©dia <i>K <sub>H</sub></i> e Gaussiana <i>K <sub>G</sub></i> no v√©rtice da grade s√£o determinadas. <br><br><img src="https://habrastorage.org/webt/rz/ni/kf/rznikfmo-7jumijuvqo4pjgmurs.png" alt="imagem"><br>  <i>Sobre a defini√ß√£o de um operador diferencial discreto para dom√≠nios triangulados</i> <br><br>  Assim, √© calculado o tensor de curvatura para cada v√©rtice da grade, cujos autovalores s√£o as curvaturas principais desejadas <i>K1</i> e <i>K2</i> e os autovetores s√£o as principais dire√ß√µes da mudan√ßa de curvatura. <br><br>  Em seguida, os v√©rtices da malha s√£o classificados de acordo com os valores das principais curvaturas <i>K <sub>1</sub></i> e <i>K <sub>2</sub></i> calculadas neles.  O algoritmo de classifica√ß√£o de v√©rtices √© baseado no m√©todo k-means, isto √©, na minimiza√ß√£o do desvio quadr√°tico total dos pontos de agrupamento em rela√ß√£o aos centros desses agrupamentos.  Como resultado, na sa√≠da do algoritmo, cada v√©rtice da grade √© associado a um determinado cluster <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-1-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>C</mi><mi>i</mi></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="2.569ex" height="2.057ex" viewBox="0 -780.1 1106 885.9" role="img" focusable="false" style="vertical-align: -0.246ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/465869/&amp;usg=ALkJrhgWyDkpsW8QKkQHaiHDNaJ1PsQwZA#MJMATHI-43" x="0" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/465869/&amp;usg=ALkJrhgWyDkpsW8QKkQHaiHDNaJ1PsQwZA#MJMATHI-69" x="760" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>C</mi><mi>i</mi></math></span></span><script type="math/tex" id="MathJax-Element-1"> Ci </script>  e um par de curvaturas (centro do cluster) (L. Guillaume, "Segmenta√ß√£o de malha triangular baseada em tensor de curvatura com retifica√ß√£o de limites", Proceedings Computer Graphics International (CGI), 2004). <br><br><img src="https://habrastorage.org/webt/rr/sf/zg/rrsfzgnpnkdjbk6tkaj2huigmno.png" alt="imagem"><br>  <i>Classifica√ß√£o dos v√©rtices de uma malha poligonal no espa√ßo das curvaturas</i> <br><br>  Depois de classificar os v√©rtices da malha poligonal, √© necess√°rio classificar os pol√≠gonos.  No in√≠cio deste procedimento, um pol√≠gono triangular √© selecionado para o qual a curvatura pode ser considerada completamente definida (todos os tr√™s v√©rtices pertencem a um cluster ou dois v√©rtices ficam em uma aresta aguda).  Esse pol√≠gono √© declarado um novo segmento, e o procedimento recursivo para expandir o segmento come√ßa a partir dele: para cada pol√≠gono triangular, os pol√≠gonos adjacentes a ele s√£o considerados, desde que a borda entre eles n√£o seja "n√≠tida". <br><br>  Se o v√©rtice de um pol√≠gono vizinho, oposto √† aresta comum, estiver em uma aresta aguda ou pertencer ao mesmo cluster, esse pol√≠gono ser√° adicionado ao segmento.  O processo √© repetido at√© que todos os pol√≠gonos dessa grade sejam visualizados.  Veja como √© o mecanismo de segmenta√ß√£o de malha implementado. <br><br><img src="https://habrastorage.org/webt/dm/19/to/dm19tosiw5tu-_p97ufs380khyy.png" alt="imagem"><br>  <i>Mecanismo de segmenta√ß√£o de malha poligonal</i> <br><br>  No final do procedimento de forma√ß√£o de segmento, um algoritmo especial para costurar segmentos adjacentes √© realizado para eliminar a segmenta√ß√£o excessiva da malha em quest√£o. <br><br><h1>  <font color="#00B2FF">Reconhecimento de superf√≠cie</font> </h1><br>  No segundo est√°gio, cada um dos segmentos deve estar associado a uma determinada superf√≠cie que se aproxima de sua forma com uma determinada precis√£o.  Em primeiro lugar, os valores das principais curvaturas desse segmento determinam a possibilidade de descrever a forma do segmento por uma superf√≠cie elementar: <br><ul><li>  plano: <i>k <sub>1</sub></i> = <i>k <sub>2</sub></i> = 0 </li><li>  esfera: <i>k <sub>1</sub></i> = <i>k <sub>2</sub></i> = <i>K</i> &gt; 0 </li><li>  cilindro: <i>k <sub>1</sub></i> = <i>K</i> &gt; 0, <i>k <sub>2</sub></i> = 0 </li><li>  cone: <i>k <sub>1</sub></i> ‚àà [ <i>a</i> , <i>b</i> ], <i>k <sub>2</sub></i> = 0 </li><li>  toro: <i>k <sub>1</sub></i> = <i>K</i> , <i>k <sub>2</sub></i> ‚àà [ <i>a</i> , <i>b</i> ] </li></ul><br><br>  Se nenhuma das superf√≠cies elementares for adequada para descrever um segmento, o algoritmo tentar√° reconhecer a superf√≠cie de extrus√£o ou rota√ß√£o.  Por fim, se n√£o fosse poss√≠vel selecionar uma superf√≠cie anal√≠tica para descrever a forma do segmento, uma superf√≠cie NURBS ser√° constru√≠da para ele. <br><br>  As superf√≠cies elementares s√£o constru√≠das usando m√©todos para ajustar objetos geom√©tricos simples em um conjunto de pontos.  Portanto, para ajustar o c√≠rculo e a esfera, o m√©todo dos m√≠nimos quadrados √© usado, para ajustar o plano - o m√©todo do componente principal.  Cada superf√≠cie reconstru√≠da √© verificada quanto √† conformidade com um segmento para uma determinada precis√£o de reconhecimento. <br><br>  Para maior clareza, pintamos as superf√≠cies reconhecidas em cores diferentes: planos - azul, cilindros - vermelho, esferas - verde, cones - amarelo, tori - roxo. <br><br><img src="https://habrastorage.org/webt/az/z_/jh/azz_jhkz6xkn0ffe8z95dhrfzum.png" alt="imagem"><br>  <i>Malha de pol√≠gono original (esquerda) e malha segmentada (direita) com superf√≠cies reconhecidas em segmentos</i> <br><br><h1>  <font color="#00B2FF">Construindo um modelo B-rep</font> </h1><br>  O est√°gio final da transforma√ß√£o √© a constru√ß√£o de um modelo B-rep com base na segmenta√ß√£o das superf√≠cies reconhecidas.  Nesta abordagem, um gr√°fico de regi√µes adjacentes √© constru√≠do com base em regi√µes segmentadas, o que reflete a topologia do modelo e serve como base para a constru√ß√£o do modelo final de rep-B. <br><br>  Ao contr√°rio dos est√°gios anteriores de convers√£o, o conjunto B-rep √© realizado de modo totalmente autom√°tico: as linhas de interse√ß√£o de superf√≠cies reconstru√≠das adjacentes s√£o encontradas, as bordas das faces s√£o constru√≠das sobre elas, as pr√≥prias faces e, finalmente, o casco B-rep √© montado. <br><br><img src="https://habrastorage.org/webt/om/i7/zw/omi7zwcrrc3qzdvyfkvzphvsyra.png" alt="imagem"><br><br><img src="https://habrastorage.org/webt/is/zt/nw/isztnwvohh4t9nzgj4pusg9awek.png" alt="imagem"><br>  <i>Malha de pol√≠gono original (esquerda) e modelo B-rep (direita)</i> <br><br>  No entanto, nem sempre √© poss√≠vel construir um shell topologicamente correto.  Como exemplo de tal situa√ß√£o, suponha que durante a reconstru√ß√£o de superf√≠cies tenhamos duas superf√≠cies - um cilindro e um plano, e sua posi√ß√£o no espa√ßo seja pr√≥xima da tangente.  Devido a erros na reconstru√ß√£o das superf√≠cies de sua interse√ß√£o, pode n√£o haver nenhum.  Nesses casos, o shell pode ser constru√≠do com alguns defeitos que o usu√°rio pode corrigir ajustando adequadamente os par√¢metros da superf√≠cie. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/PQ3z2Rjdpdc" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><br><h1>  <font color="#00B2FF">Tipos de modelos poligonais e a escolha do modo de convers√£o</font> </h1><br>  Hoje, existem v√°rias fontes principais de modelos na representa√ß√£o poligonal: <br><ul><li>  cat√°logos on-line, bancos de dados de modelos 3D em formato de pol√≠gono (STL, VRML, OBJ), por exemplo, Armaz√©m 3D, Cultos 3D, etc. </li><li>  Resultados da digitaliza√ß√£o em 3D </li><li>  resultados da otimiza√ß√£o do modelo topol√≥gico por algoritmos CAE. </li></ul><br><br>  Os modelos poligonais dessas fontes podem ser divididos em dois grupos: o primeiro inclui modelos que s√£o triangula√ß√µes de objetos B-rep e o segundo - todos os outros.  As diferen√ßas caracter√≠sticas do primeiro grupo s√£o a aus√™ncia de ru√≠do na malha poligonal e a predomin√¢ncia de superf√≠cies analiticamente definidas.  Assim, a convers√£o para os modelos B-rep do primeiro grupo ocorrer√° no modo totalmente autom√°tico ou com interven√ß√£o m√≠nima do usu√°rio. <br><br>  As grades poligonais dos modelos do segundo grupo implicam uma intera√ß√£o interativa mais densa com o usu√°rio.  Portanto, inicialmente estabelecemos dois modos de opera√ß√£o no C3D B-Shaper - totalmente autom√°ticos e interativos. <br><br>  A escolha de um modo espec√≠fico tamb√©m depende do objetivo da transforma√ß√£o: em alguns casos, a conectividade topol√≥gica dos elementos do shell resultante, bem como sua corre√ß√£o, pode ser negligenciada.  Essa abordagem √© aceit√°vel, por exemplo, para otimizar a renderiza√ß√£o em um aplicativo BIM, quando o usu√°rio pode adicionar itens internos arbitr√°rios ao modelo atual da sala.  Por outro lado, para problemas de engenharia reversa, √© necess√°rio obter a c√≥pia mais precisa do modelo original, por exemplo, preservar o alinhamento dos cilindros com uma determinada precis√£o, garantir a localiza√ß√£o tangente de um par de superf√≠cies e, como resultado, obter a topologia correta do modelo - nesse caso, voc√™ n√£o pode fazer sem a interven√ß√£o do usu√°rio. processo de convers√£o. <br><br>  A interface de convers√£o autom√°tica do C3D B-Shaper √© representada pelas seguintes fun√ß√µes, que aceitam a grade de entrada e as configura√ß√µes de convers√£o como entrada: <br><br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">MbResultType </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ConvertMeshToShell</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( MbMesh &amp; mesh, MbFaceShell *&amp; shell, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> MbMeshProcessorValues &amp; params )</span></span></span></span>; <span class="hljs-function"><span class="hljs-function">MbResultType </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ConvertCollectionToShell</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( MbCollection &amp; collection, MbFaceShell *&amp; shell, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> MbMeshProcessorValues &amp; params )</span></span></span></span>;</code> </pre> <br><br>  As configura√ß√µes de convers√£o incluem o valor da precis√£o do reconhecimento, ou seja,  a dist√¢ncia m√°xima permitida dos v√©rtices da malha poligonal dentro dos limites desse segmento at√© a superf√≠cie reconhecida.  Essa precis√£o pode ser absoluta ou relativa: ao usar a precis√£o relativa, o desvio das faces do corpo da grade √© verificado em rela√ß√£o ao tamanho do modelo. <br><br>  Al√©m disso, o usu√°rio tem a op√ß√£o de alternar os modos de reconhecimento, o que permite controlar os tipos de superf√≠cies durante a reconstru√ß√£o. <br>  Recursos avan√ßados para gerenciar processos de segmenta√ß√£o e reconhecimento de superf√≠cie s√£o fornecidos pela interface da classe MbMeshProcessor: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MbMeshProcessor</span></span></span><span class="hljs-class"> {</span></span> .. <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-comment"><span class="hljs-comment">// ‚Äú‚Äù . void SetUseMeshSmoothing( bool useSmoothing ); //   . const MbCollection &amp; GetSegmentedMesh(); MbResultType SegmentMesh( bool createSurfaces = true ); void ResetSegmentation(); void UniteSegments( size_t firstSegmentIdx, size_t secondSegmentIdx ); MbResultType SegmentMeshBySeparators( const std::vector&lt;std::vector&lt;uint&gt;&gt; &amp; sep ); //   . void FitSurfaceToSegment( size_t idxSegment ); void FitSurfaceToSegment( size_t idxSegment, MbeSpaceType surfaceType ); const MbSurface * GetSegmentSurface( size_t idxSegment ) const; //  B-rep . MbResultType CreateBRepShell( MbFaceShell *&amp; pShell ); .. }</span></span></code> </pre> <br><br>  Por exemplo, para corrigir os resultados da segmenta√ß√£o autom√°tica, s√£o fornecidas ferramentas para combinar segmentos, separ√°-los etc.  O usu√°rio pode inserir uma superf√≠cie de um determinado tipo em um segmento, bem como alterar os par√¢metros para uma superf√≠cie j√° reconhecida. <br><br><h1>  <font color="#00B2FF">O que est√° acontecendo agora</font> </h1><br>  Em julho, lan√ßamos a primeira vers√£o do componente e agora continuamos a desenvolver em v√°rias √°reas: algoritmos de segmenta√ß√£o autom√°tica, ferramentas de edi√ß√£o de segmenta√ß√£o, constru√ß√£o de superf√≠cies de forma livre (NURBS) com base em um segmento e melhoria da qualidade de constru√ß√£o de shells de rep-B. <br><br>  Os desenvolvedores interessados ‚Äã‚Äãpodem testar o C3D B-Shaper.  O componente √© fornecido gratuitamente por tr√™s meses, mediante <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">solicita√ß√£o</a> em nosso site. <br><br> <a href=""><img src="https://habrastorage.org/webt/k8/za/vg/k8zavgo-xihodwssql3y-aqlmam.jpeg"></a>  Autor - Andrey Tumanin, Ph.D., programador matem√°tico do C3D Labs </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt465869/">https://habr.com/ru/post/pt465869/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt465857/index.html">Anti-googlers: os usu√°rios da Web tomam medidas radicais para proteger seus dados</a></li>
<li><a href="../pt465859/index.html">Tradu√ß√£o autom√°tica neural sustent√°vel</a></li>
<li><a href="../pt465861/index.html">"Nuvem" confidencial. Estamos procurando uma alternativa para abrir solu√ß√µes</a></li>
<li><a href="../pt465863/index.html">Como usar o MIDI para web em resumo</a></li>
<li><a href="../pt465867/index.html">Reprogramamos o caixa e imprimimos nele Keanu Reeves</a></li>
<li><a href="../pt465873/index.html">O problema que voc√™ resolve √© mais importante que o c√≥digo que voc√™ escreve</a></li>
<li><a href="../pt465877/index.html">Seguran√ßa da informa√ß√£o na nuvem: como a plataforma de servi√ßos de seguran√ßa cibern√©tica unificada funciona</a></li>
<li><a href="../pt465879/index.html">E os ber√ßos?</a></li>
<li><a href="../pt465885/index.html">Como se tornar um l√≠der em Scrum Master e agitar a equipe?</a></li>
<li><a href="../pt465889/index.html">Como abordamos a efici√™ncia energ√©tica</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>