<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üéÖüèø üë©üèΩ‚Äçüöí üëåüèæ Simplifique seu c√≥digo com a Rocket Science: Operador da nave espacial C ++ 20 üê§ üî≤ üõÄüèæ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="O C ++ 20 adiciona um novo operador, carinhosamente chamado de operador "nave espacial": <=> . H√° algum tempo, postamos por nosso pr√≥prio Simon Brand ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Simplifique seu c√≥digo com a Rocket Science: Operador da nave espacial C ++ 20</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/microsoft/blog/458248/"> O C ++ 20 adiciona um novo operador, carinhosamente chamado de operador "nave espacial": <code>&lt;=&gt;</code> .  H√° algum tempo, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">postamos</a> por nosso pr√≥prio <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Simon Brand</a> detalhando algumas informa√ß√µes sobre esse novo operador, al√©m de algumas informa√ß√µes conceituais sobre o que √© e o que faz.  O objetivo deste post √© explorar algumas aplica√ß√µes concretas desse novo operador estranho e de sua contraparte associada, o <code>operator==</code> (sim, foi alterado, para melhor!), Ao mesmo tempo em que fornece algumas diretrizes para seu uso no c√≥digo cotidiano. <br><br><img src="https://habrastorage.org/webt/ny/pa/bp/nypabpd9lxsd9ifx_f7_zitj7ti.png"><a name="habracut"></a><br><br><h2>  Compara√ß√µes </h2><br>  N√£o √© incomum ver c√≥digo como o seguinte: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IntWrapper</span></span></span><span class="hljs-class"> {</span></span>  <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> value;  <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constexpr</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IntWrapper</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> value)</span></span></span><span class="hljs-function">: value</span></span>{value} { }  <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>==(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> IntWrapper&amp; rhs) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> value == rhs.value; }  <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>!=(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> IntWrapper&amp; rhs) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> !(*<span class="hljs-keyword"><span class="hljs-keyword">this</span></span> == rhs);    }  <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>&lt;(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> IntWrapper&amp; rhs)  <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> value &lt; rhs.value;  }  <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>&lt;=(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> IntWrapper&amp; rhs) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> !(rhs &lt; *<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>);    }  <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>&gt;(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> IntWrapper&amp; rhs)  <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> rhs &lt; *<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>;        }  <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>&gt;=(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> IntWrapper&amp; rhs) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> !(*<span class="hljs-keyword"><span class="hljs-keyword">this</span></span> &lt; rhs);    } };</code> </pre> <br>  <i>Nota: os leitores de olhos de √°guia perceber√£o que isso √© realmente menos detalhado do que deveria ser no c√≥digo pr√©-C ++ 20, porque essas fun√ß√µes devem ser todas amigas de n√£o-membros, mais sobre isso mais tarde.</i> <br><br>  Isso √© muito c√≥digo clich√™ para escrever apenas para garantir que meu tipo seja compar√°vel a algo do mesmo tipo.  Bem, OK, lidamos com isso por um tempo.  Ent√£o vem algu√©m que escreve isso: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constexpr</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">is_lt</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> IntWrapper&amp; a, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> IntWrapper&amp; b)</span></span></span><span class="hljs-function"> </span></span>{  <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a &lt; b; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{  <span class="hljs-keyword"><span class="hljs-keyword">static_assert</span></span>(is_lt(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>)); }</code> </pre> <br>  A primeira coisa que voc√™ notar√° √© que este programa n√£o ser√° compilado. <br><br> <code>error C3615: constexpr function 'is_lt' cannot result in a constant expression</code> <br> <br>  Ah!  O problema √© que esquecemos o <code>constexpr</code> em nossa fun√ß√£o de compara√ß√£o, drat!  Ent√£o, adicionamos <code>constexpr</code> a todos os operadores de compara√ß√£o.  Alguns dias depois, algu√©m adiciona um ajudante <code>is_gt</code> mas percebe que todos os operadores de compara√ß√£o n√£o t√™m uma especifica√ß√£o de exce√ß√£o e passa pelo mesmo processo tedioso de adicionar <code>noexcept</code> a cada uma das 5 sobrecargas. <br><br>  √â aqui que o novo operador de espa√ßonave do C ++ 20 entra em cena para nos ajudar.  Vamos ver como o <code>IntWrapper</code> original pode ser escrito em um mundo C ++ 20: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;compare&gt; struct IntWrapper {  int value;  constexpr IntWrapper(int value): value{value} { }  auto operator&lt;=&gt;(const IntWrapper&amp;) const = default; };</span></span></span></span></code> </pre> <br>  A primeira diferen√ßa que voc√™ pode notar √© a nova inclus√£o de <code>&lt;compare&gt;</code> .  O cabe√ßalho <code>&lt;compare&gt;</code> √© respons√°vel por preencher o compilador com todos os tipos de categorias de compara√ß√£o necess√°rios para o operador da nave espacial retornar um tipo apropriado para nossa fun√ß√£o padr√£o.  No snippet acima, o tipo de retorno <code>auto</code> ser√° deduzido para <code>std::strong_ordering</code> . <br><br>  N√£o apenas removemos 5 linhas sup√©rfluas, mas nem precisamos definir nada, o compilador faz isso por n√≥s!  Nosso <code>is_lt</code> permanece inalterado e apenas funciona enquanto ainda est√° sendo <code>constexpr</code> , embora n√£o tenhamos explicitamente especificado isso em nosso <code>operator&lt;=&gt;</code> padr√£o <code>operator&lt;=&gt;</code> .  Isso √© bom e bom, mas algumas pessoas podem estar co√ßando a cabe√ßa por que o <code>is_lt</code> ainda pode compilar, mesmo que nem sequer use o operador da nave espacial.  Vamos explorar a resposta a esta pergunta. <br><br><h2>  Reescrevendo express√µes </h2><br>  No C ++ 20, o compilador √© apresentado a um novo conceito chamado de express√µes "reescritas".  O operador da nave espacial, juntamente com o <code>operator==</code> , est√£o entre os dois primeiros candidatos sujeitos a express√µes reescritas.  Para um exemplo mais concreto de reescrita de express√£o, vamos <code>is_lt</code> o exemplo fornecido em <code>is_lt</code> . <br><br>  Durante a resolu√ß√£o de sobrecarga, o compilador selecionar√° dentre um conjunto de candidatos vi√°veis, que correspondem ao operador que estamos procurando.  O processo de coleta de candidatos √© alterado levemente para o caso de opera√ß√µes relacionais e de equival√™ncia em que o compilador tamb√©m deve reunir candidatos especiais reescritos e sintetizados ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">[over.match.oper] /3.4</a> ). <br><br>  Para nossa express√£o <code>a &lt; b</code> o padr√£o declara que podemos procurar o tipo de a para um <code>operator&lt;=&gt;</code> ou um <code>operator&lt;=&gt;</code> fun√ß√£o de escopo de espa√ßo de nome <code>operator&lt;=&gt;</code> que aceite seu tipo.  Portanto, o compilador faz e descobre que, de fato, o tipo de a <code>IntWrapper::operator&lt;=&gt;</code> .  O compilador pode ent√£o usar esse operador e reescrever a express√£o <code>a &lt; b</code> como <code>(a &lt;=&gt; b) &lt; 0</code> .  Essa express√£o reescrita √© usada como candidata √† resolu√ß√£o normal de sobrecarga. <br><br>  Voc√™ pode se perguntar por que essa express√£o reescrita √© v√°lida e correta.  A corre√ß√£o da express√£o na verdade decorre da sem√¢ntica que o operador da nave espacial fornece.  A <code>&lt;=&gt;</code> √© uma compara√ß√£o de tr√™s vias que implica que voc√™ obt√©m n√£o apenas um resultado bin√°rio, mas uma ordem (na maioria dos casos) e, se voc√™ tiver uma ordem, poder√° express√°-la em termos de quaisquer opera√ß√µes relacionais.  Um exemplo r√°pido, a express√£o 4 &lt;=&gt; 5 em C ++ 20 retornar√° o resultado <code>std::strong_ordering::less</code> .  O resultado <code>std::strong_ordering::less</code> implica que <code>4</code> n√£o √© apenas diferente de <code>5</code> mas √© estritamente menor que esse valor, isso torna a aplica√ß√£o da opera√ß√£o <code>(4 &lt;=&gt; 5) &lt; 0</code> correta e exata para descrever nosso resultado. <br><br>  Usando as informa√ß√µes acima, o compilador pode pegar qualquer operador relacional generalizado (por exemplo, <code>&lt;</code> , <code>&gt;</code> , etc.) e reescrev√™-lo em termos do operador da nave espacial.  No padr√£o, a express√£o reescrita √© frequentemente referida como <code>(a &lt;=&gt; b) @ 0</code> onde <code>@</code> representa qualquer opera√ß√£o relacional. <br><br><h2>  Sintetizando express√µes </h2><br>  Os leitores podem ter notado a men√ß√£o sutil das express√µes "sintetizadas" acima e tamb√©m desempenham um papel nesse processo de reescrita do operador.  Considere uma fun√ß√£o de predicado diferente: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constexpr</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">is_gt_42</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> IntWrapper&amp; a)</span></span></span><span class="hljs-function"> </span></span>{  <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">42</span></span> &lt; a; }</code> </pre> <br>  Se usarmos nossa defini√ß√£o original para o <code>IntWrapper</code> esse c√≥digo n√£o ser√° compilado. <br><br> <code>error C2677: binary '&lt;': no global operator found which takes type 'const IntWrapper' (or there is no acceptable conversion)</code> <br> <br>  Isso faz sentido em terrenos pr√©-C ++ 20, e a maneira de resolver esse problema seria adicionar algumas fun√ß√µes de <code>friend</code> extras ao <code>IntWrapper</code> que ficam do lado esquerdo do <code>int</code> .  Se voc√™ tentar criar esse exemplo com um compilador C ++ 20 e nossa defini√ß√£o de <code>IntWrapper</code> C ++ 20, poder√° notar que, novamente, ‚Äúsimplesmente funciona‚Äù - outro arranhador de cabe√ßa.  Vamos examinar por que o c√≥digo acima ainda pode compilar no C ++ 20. <br><br>  Durante a resolu√ß√£o de sobrecarga, o compilador tamb√©m reunir√° o que o padr√£o se refere como candidatos "sintetizados" ou uma express√£o reescrita com a ordem dos par√¢metros revertidos.  No exemplo acima, o compilador tentar√° usar a express√£o reescrita <code>(42 &lt;=&gt; a) &lt; 0</code> mas descobrir√° que n√£o h√° convers√£o do <code>IntWrapper</code> para <code>int</code> para satisfazer o lado esquerdo, para que a express√£o reescrita seja descartada.  O compilador tamb√©m evoca a express√£o "sintetizada" <code>0 &lt; (a &lt;=&gt; 42)</code> e descobre que h√° uma convers√£o de <code>int</code> para <code>IntWrapper</code> por meio de seu construtor de convers√£o, para que esse candidato seja usado. <br><br>  O objetivo das express√µes sintetizadas √© evitar a bagun√ßa de precisar escrever o clich√™ das fun√ß√µes de <code>friend</code> para preencher as lacunas nas quais seu objeto pode ser convertido de outros tipos.  Express√µes sintetizadas s√£o generalizadas para <code>0 @ (b &lt;=&gt; a)</code> . <br><br><h2>  Tipos mais complexos </h2><br>  O operador de nave espacial gerado pelo compilador n√£o para em membros √∫nicos de classes; ele gera um conjunto correto de compara√ß√µes para todos os subobjetos de seus tipos: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Basics</span></span></span><span class="hljs-class"> {</span></span>  <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i;  <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> c;  <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> f;  <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> d;  <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>&lt;=&gt;(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Basics&amp;) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Arrays</span></span></span><span class="hljs-class"> {</span></span>  <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> ai[<span class="hljs-number"><span class="hljs-number">1</span></span>];  <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> ac[<span class="hljs-number"><span class="hljs-number">2</span></span>];  <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> af[<span class="hljs-number"><span class="hljs-number">3</span></span>];  <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> ad[<span class="hljs-number"><span class="hljs-number">2</span></span>][<span class="hljs-number"><span class="hljs-number">2</span></span>];  <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>&lt;=&gt;(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Arrays&amp;) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Bases</span></span></span><span class="hljs-class"> :</span></span> Basics, Arrays {  <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>&lt;=&gt;(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Bases&amp;) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{  <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> Bases a = { { <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-string"><span class="hljs-string">'c'</span></span>, <span class="hljs-number"><span class="hljs-number">1.f</span></span>, <span class="hljs-number"><span class="hljs-number">1.</span></span> },                        { { <span class="hljs-number"><span class="hljs-number">1</span></span> }, { <span class="hljs-string"><span class="hljs-string">'a'</span></span>, <span class="hljs-string"><span class="hljs-string">'b'</span></span> }, { <span class="hljs-number"><span class="hljs-number">1.f</span></span>, <span class="hljs-number"><span class="hljs-number">2.f</span></span>, <span class="hljs-number"><span class="hljs-number">3.f</span></span> }, { { <span class="hljs-number"><span class="hljs-number">1.</span></span>, <span class="hljs-number"><span class="hljs-number">2.</span></span> }, { <span class="hljs-number"><span class="hljs-number">3.</span></span>, <span class="hljs-number"><span class="hljs-number">4.</span></span> } } } };  <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> Bases b = { { <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-string"><span class="hljs-string">'c'</span></span>, <span class="hljs-number"><span class="hljs-number">1.f</span></span>, <span class="hljs-number"><span class="hljs-number">1.</span></span> },                        { { <span class="hljs-number"><span class="hljs-number">1</span></span> }, { <span class="hljs-string"><span class="hljs-string">'a'</span></span>, <span class="hljs-string"><span class="hljs-string">'b'</span></span> }, { <span class="hljs-number"><span class="hljs-number">1.f</span></span>, <span class="hljs-number"><span class="hljs-number">2.f</span></span>, <span class="hljs-number"><span class="hljs-number">3.f</span></span> }, { { <span class="hljs-number"><span class="hljs-number">1.</span></span>, <span class="hljs-number"><span class="hljs-number">2.</span></span> }, { <span class="hljs-number"><span class="hljs-number">3.</span></span>, <span class="hljs-number"><span class="hljs-number">4.</span></span> } } } };  <span class="hljs-keyword"><span class="hljs-keyword">static_assert</span></span>(a == b);  <span class="hljs-keyword"><span class="hljs-keyword">static_assert</span></span>(!(a != b));  <span class="hljs-keyword"><span class="hljs-keyword">static_assert</span></span>(!(a &lt; b));  <span class="hljs-keyword"><span class="hljs-keyword">static_assert</span></span>(a &lt;= b);  <span class="hljs-keyword"><span class="hljs-keyword">static_assert</span></span>(!(a &gt; b));  <span class="hljs-keyword"><span class="hljs-keyword">static_assert</span></span>(a &gt;= b); }</code> </pre> <br>  O compilador sabe como expandir membros de classes que s√£o matrizes em suas listas de subobjetos e compar√°-los recursivamente.  Obviamente, se voc√™ quiser escrever os corpos dessas fun√ß√µes, ainda ter√° o benef√≠cio das express√µes de reescrita do compilador para voc√™. <br><br><h2>  Parece um pato, nada como um pato e Quacks como <code>operator==</code> </h2><br>  Algumas pessoas muito inteligentes do comit√™ de padroniza√ß√£o perceberam que o operador da nave espacial sempre far√° uma compara√ß√£o lexicogr√°fica de elementos, n√£o importa o qu√™.  Executar compara√ß√µes lexicogr√°ficas incondicionalmente pode levar a um c√≥digo gerado ineficiente com o operador de igualdade em particular. <br><br>  O exemplo can√¥nico est√° comparando duas strings.  Se voc√™ tiver a string <code>"foobar"</code> e compar√°-la com a string <code>"foo"</code> usando ==, seria de esperar que a opera√ß√£o fosse quase constante.  O algoritmo eficiente de compara√ß√£o de strings √© assim: <br><br><ul><li>  Primeiro compare o tamanho das duas strings, se os tamanhos diferirem retornam <code>false</code> , caso contr√°rio </li><li>  percorra cada elemento das duas seq√º√™ncias em un√≠ssono e compare at√© que uma seja diferente ou que o fim seja alcan√ßado, retorne o resultado. </li></ul><br>  Sob as regras do operador de espa√ßonave, precisamos come√ßar pela compara√ß√£o profunda de cada elemento primeiro at√© encontrarmos o que √© diferente.  No nosso exemplo de <code>"foobar"</code> e <code>"foo"</code> somente ao comparar <code>'b'</code> a <code>'\0'</code> , voc√™ finalmente retorna <code>false</code> . <br><br>  Para combater isso, havia um documento, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">P1185R2</a> , que detalha uma maneira de o compilador reescrever e gerar o <code>operator==</code> independentemente do operador da nave espacial.  Nosso <code>IntWrapper</code> pode ser escrito da seguinte maneira: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;compare&gt; struct IntWrapper {  int value;  constexpr IntWrapper(int value): value{value} { }  auto operator&lt;=&gt;(const IntWrapper&amp;) const = default;  bool operator==(const IntWrapper&amp;) const = default; };</span></span></span></span></code> </pre> <br>  Apenas mais um passo ... no entanto, h√° boas not√≠cias;  voc√™ realmente n√£o precisa escrever o c√≥digo acima, porque simplesmente escrever o <code>auto operator&lt;=&gt;(const IntWrapper&amp;) const = default</code> √© suficiente para que o compilador gere implicitamente o <code>operator==</code> separado - e mais eficiente - para voc√™! <br><br>  O compilador aplica uma regra de "reescrita" ligeiramente alterada, espec√≠fica para <code>==</code> e <code>!=</code> Onde esses operadores s√£o reescritos em termos de <code>operator==</code> e n√£o <code>operator&lt;=&gt;</code> .  Isso significa que <code>!=</code> Tamb√©m se beneficia da otimiza√ß√£o. <br><br><h2>  O c√≥digo antigo n√£o quebra </h2><br>  Nesse ponto, voc√™ deve estar pensando: OK, se o compilador tiver permiss√£o para executar esse neg√≥cio de reescrita do operador, o que acontece quando tento ser mais esperto que o compilador: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IntWrapper</span></span></span><span class="hljs-class"> {</span></span>  <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> value;  <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constexpr</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IntWrapper</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> value)</span></span></span><span class="hljs-function">: value</span></span>{value} { }  <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>&lt;=&gt;(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> IntWrapper&amp;) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>;  <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>&lt;(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> IntWrapper&amp; rhs) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> value &lt; rhs.value; } }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constexpr</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">is_lt</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> IntWrapper&amp; a, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> IntWrapper&amp; b)</span></span></span><span class="hljs-function"> </span></span>{  <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a &lt; b; }</code> </pre> <br>  A resposta aqui √© que voc√™ n√£o fez.  O modelo de resolu√ß√£o de sobrecarga em C ++ tem essa arena em que todos os candidatos batalham, e nessa batalha espec√≠fica, temos 3 candidatos: <br><br><ul><li> <code>IntWrapper::operator&lt;(const IntWrapper&amp; a, const IntWrapper&amp; b)</code> </li> <li> <code>IntWrapper::operator&lt;=&gt;(const IntWrapper&amp; a, const IntWrapper&amp; b)</code> </li> </ul><br>  (reescrito) <br><br><ul><li> <code>IntWrapper::operator&lt;=&gt;(const IntWrapper&amp; b, const IntWrapper&amp; a)</code> </li> </ul><br>  (sintetizado) <br><br>  Se aceit√°ssemos as regras de resolu√ß√£o de sobrecarga no C ++ 17, o resultado dessa chamada teria sido amb√≠guo, mas as regras de resolu√ß√£o de sobrecarga do C ++ 20 foram alteradas para permitir que o compilador resolva essa situa√ß√£o com a sobrecarga mais l√≥gica. <br><br>  H√° uma fase de resolu√ß√£o de sobrecarga em que o compilador deve executar uma s√©rie de desempatadores.  No C ++ 20, existe um novo desempatador que afirma que devemos preferir sobrecargas que n√£o s√£o reescritas ou sintetizadas, isso torna nosso sobrecarga <code>IntWrapper::operator&lt;</code> o melhor candidato e resolve a ambiguidade.  Esse mesmo mecanismo impede que os candidatos sintetizados pisem em express√µes regulares reescritas. <br><br><h2>  Pensamentos finais </h2><br>  O operador de nave espacial √© uma adi√ß√£o bem-vinda ao C ++ e √© um dos recursos que simplificar√° e ajudar√° voc√™ a escrever <i>menos</i> c√≥digo e, √†s vezes, menos √© mais.  Ent√£o aperte o cinto com o operador de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">nave espacial</a> C ++ 20! <br><br>  Pedimos que voc√™ experimente o operador da nave espacial, que est√° dispon√≠vel no <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Visual Studio 2019</a> em <code>/std:c++latest</code> !  Como uma observa√ß√£o, as altera√ß√µes introduzidas pelo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">P1185R2</a> estar√£o dispon√≠veis no Visual Studio 2019 vers√£o 16.2.  Lembre-se de que o operador da nave espacial faz parte do C ++ 20 e est√° sujeito a algumas altera√ß√µes at√© que o C ++ 20 seja finalizado. <br><br>  Como sempre, agradecemos seus coment√°rios.  Sinta-se √† vontade para enviar qualquer coment√°rio por email para <a href="">visualcpp@microsoft.com</a> , pelo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Twitter @visualc</a> ou pelo Facebook no <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Microsoft Visual Cpp</a> .  Al√©m disso, sinta-se √† vontade para me seguir no Twitter <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">@starfreakclone</a> . <br><br>  Se voc√™ encontrar outros problemas com o MSVC no VS 2019, informe-nos atrav√©s da op√ß√£o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Relatar um problema</a> , do instalador ou do pr√≥prio Visual Studio IDE.  Para sugest√µes ou relat√≥rios de erros, informe-nos pelo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">DevComm.</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt458248/">https://habr.com/ru/post/pt458248/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt458230/index.html">Como IA, drones e c√¢meras mant√™m nossas estradas e pontes seguras</a></li>
<li><a href="../pt458240/index.html">Como intelig√™ncia artificial, drones e c√¢meras garantem a seguran√ßa de estradas e pontes</a></li>
<li><a href="../pt458242/index.html">O novo operador de nave espacial em C ++ 20</a></li>
<li><a href="../pt458244/index.html">Uma lista intermin√°vel e rid√≠cula do que voc√™ precisa saber para usar com seguran√ßa redes Wi-Fi p√∫blicas</a></li>
<li><a href="../pt458246/index.html">Coincid√™ncias aleat√≥rias na vida ou como voc√™ recebeu um bolo em uma f√°brica de tratores</a></li>
<li><a href="../pt458250/index.html">BTRFS para o menor</a></li>
<li><a href="../pt458252/index.html">Modelo matem√°tico de um radiotelesc√≥pio super longo</a></li>
<li><a href="../pt458256/index.html">N√£o √© hora de fazer lavagem cerebral?</a></li>
<li><a href="../pt458260/index.html">Outra maneira de otimizar imagens do docker para aplicativos Java</a></li>
<li><a href="../pt458262/index.html">Designer on-line da sala de reuni√µes - sele√ß√£o da solu√ß√£o ideal para a videoconfer√™ncia</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>