<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🦄 🖐🏼 👌🏻 Richard Hamming: Bab 10. Teori Pengkodean - I ✂️ 🧖🏻 🕶️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content=""Tujuan kursus ini adalah untuk mempersiapkan Anda untuk masa depan teknis Anda." 
 Hai, Habr. Ingat artikel yang luar biasa "Anda dan Pekerjaan Anda"...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Richard Hamming: Bab 10. Teori Pengkodean - I</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/417109/"><blockquote>  "Tujuan kursus ini adalah untuk mempersiapkan Anda untuk masa depan teknis Anda." </blockquote><br><img src="https://habrastorage.org/getpro/habr/post_images/d67/6ff/9ea/d676ff9eadd2a38b0948de76bbf27fd4.jpg" alt="gambar" align="right">  Hai, Habr.  Ingat artikel yang luar biasa <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">"Anda dan Pekerjaan Anda"</a> (+219, 2442 bookmark, 394k dibaca)? <br><br>  Jadi Hamming (ya, ya, memeriksa sendiri dan memperbaiki <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">kode Hamming</a> ) memiliki seluruh <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">buku yang</a> ditulis berdasarkan ceramahnya.  Kami menerjemahkannya, karena lelaki itu berbicara bisnis. <br><br>  Buku ini bukan hanya tentang IT, itu adalah buku tentang gaya berpikir orang yang sangat keren.  <i>“Ini bukan hanya muatan pemikiran positif;</i>  <i>itu menggambarkan kondisi yang meningkatkan peluang melakukan pekerjaan dengan baik. ”</i> <br><br>  Kami telah menerjemahkan 28 (dari 30) bab.  Dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">kami sedang mengerjakan</a> edisi kertas. <br><br><h3>  Teori Pengkodean - I </h3><br>  Setelah mempertimbangkan komputer dan prinsip kerja mereka, kami sekarang akan mempertimbangkan masalah informasi: bagaimana komputer mewakili informasi yang ingin kami proses.  Makna karakter apa pun mungkin tergantung pada bagaimana ia diproses, mesin tidak memiliki arti khusus untuk bit yang digunakan.  Ketika membahas sejarah perangkat lunak, Bab 4, kami mempertimbangkan beberapa bahasa pemrograman sintetis, di mana kode instruksi istirahat bertepatan dengan kode instruksi lainnya.  Situasi ini tipikal untuk sebagian besar bahasa, makna instruksi ditentukan oleh program yang sesuai. <br><br>  Untuk menyederhanakan masalah penyajian informasi, kami mempertimbangkan masalah pengiriman informasi dari titik ke titik.  Pertanyaan ini terkait dengan masalah informasi konservasi.  Masalah dalam mengirimkan informasi dalam ruang dan waktu adalah identik.  Gambar 10.1 menunjukkan model standar untuk mengirimkan informasi. <br><br><img src="https://habrastorage.org/webt/ba/-h/xi/ba-hxivlgh-iaa6jippqrpar6lm.jpeg" alt="gambar"><br><br>  <i>Gambar 10.1</i> <br><a name="habracut"></a><br>  Di sebelah kiri dalam gambar 10.1 adalah sumber informasi.  Saat mempertimbangkan model, kami tidak peduli tentang sifat sumbernya.  Ini dapat berupa seperangkat simbol alfabet, angka, rumus matematika, not musik, simbol yang dengannya kita dapat mewakili gerakan dansa - sifat sumber dan makna simbol yang tersimpan di dalamnya bukan bagian dari model transmisi.  Kami hanya mempertimbangkan sumber informasi, dengan batasan seperti itu kami memperoleh teori umum yang kuat yang dapat diperluas ke banyak bidang.  Ini adalah abstraksi dari banyak aplikasi. <br><br>  Ketika Shannon menciptakan teori informasi pada akhir 1940-an, diyakini bahwa itu harus disebut teori komunikasi, tetapi ia bersikeras pada istilah informasi.  Istilah ini telah menjadi penyebab konstan dari meningkatnya minat dan kekecewaan terus menerus dalam teori.  Penyelidik ingin membangun "teori informasi" keseluruhan, mereka merosot menjadi teori serangkaian karakter.  Kembali ke model transmisi, kami memiliki sumber data yang perlu dikodekan untuk transmisi. <br><br>  Encoder terdiri dari dua bagian, bagian pertama disebut source encoder, nama yang tepat tergantung pada jenis sumber.  Sumber dari berbagai jenis data berhubungan dengan berbagai jenis penyandi. <br><br>  Bagian kedua dari proses pengkodean disebut pengkodean saluran dan tergantung pada jenis saluran untuk mentransmisikan data.  Dengan demikian, bagian kedua dari proses pengkodean konsisten dengan jenis saluran transmisi.  Jadi, ketika menggunakan antarmuka standar, data dari sumber awalnya disandikan sesuai dengan persyaratan antarmuka, dan kemudian sesuai dengan persyaratan saluran data yang digunakan. <br><br>  Menurut model, pada Gambar 10.1, saluran data terkena "noise acak tambahan".  Semua kebisingan dalam sistem digabungkan pada saat ini.  Diasumsikan bahwa encoder menerima semua karakter tanpa distorsi, dan decoder menjalankan fungsinya tanpa kesalahan.  Ini adalah beberapa idealisasi, tetapi untuk banyak tujuan praktis itu dekat dengan kenyataan. <br><br>  Tahap decoding juga terdiri dari dua tahap: saluran - standar, standar - penerima data.  Pada akhir transfer data ditransmisikan ke konsumen.  Dan lagi, kami tidak mempertimbangkan bagaimana konsumen menginterpretasikan data ini. <br><br>  Seperti disebutkan sebelumnya, sistem transmisi data, misalnya, pesan telepon, radio, program TV, menyajikan data dalam bentuk sekumpulan angka dalam register komputer.  Saya ulangi lagi, transmisi dalam ruang tidak berbeda dengan transmisi dalam waktu atau menyimpan informasi.  Apakah Anda memiliki informasi yang akan diperlukan setelah beberapa saat, maka harus dikodekan dan disimpan pada sumber penyimpanan data.  Jika perlu, informasi diterjemahkan.  Jika sistem pengkodean dan penguraiannya sama, kami mengirimkan data melalui saluran transmisi tanpa perubahan. <br><br>  Perbedaan mendasar antara teori yang disajikan dan teori biasa dalam fisika adalah asumsi bahwa tidak ada noise pada sumber dan penerima.  Bahkan, kesalahan terjadi pada peralatan apa pun.  Dalam mekanika kuantum, kebisingan terjadi pada setiap tahap sesuai dengan prinsip ketidakpastian, dan bukan sebagai kondisi awal;  dalam kasus apa pun, konsep kebisingan dalam teori informasi tidak setara dengan konsep serupa dalam mekanika kuantum. <br>  Untuk definiteness, kami akan mempertimbangkan bentuk biner dari representasi data dalam sistem.  Formulir lain diproses dengan cara yang sama, untuk kesederhanaan kami tidak akan mempertimbangkannya. <br><br>  Kita mulai dengan pertimbangan sistem dengan karakter yang dikodekan dengan panjang variabel, seperti dalam kode titik dan garis Morse klasik, di mana karakter yang sering muncul pendek dan jarang ada yang panjang.  Pendekatan ini memungkinkan Anda untuk mencapai efisiensi kode tinggi, tetapi perlu dicatat bahwa kode Morse adalah ternary, bukan biner, karena berisi ruang antara titik dan garis.  Jika semua karakter dalam kode memiliki panjang yang sama, maka kode tersebut disebut kode blok. <br><br>  Properti pertama yang diperlukan dari kode adalah kemampuan untuk secara unik men-decode pesan tanpa adanya noise, setidaknya ini tampaknya properti yang diinginkan, walaupun dalam beberapa situasi persyaratan ini dapat diabaikan.  Data dari saluran transmisi untuk penerima terlihat seperti aliran karakter dari nol dan satu. <br><br>  Kami akan memanggil dua karakter yang berdekatan ekstensi ganda, tiga karakter yang berdekatan ekstensi tiga, dan dalam kasus umum, jika kita meneruskan karakter N, penerima melihat penambahan pada kode dasar karakter N.  Penerima, yang tidak mengetahui nilai N, harus membagi aliran menjadi blok siaran.  Atau, dengan kata lain, penerima harus dapat menguraikan aliran secara unik untuk mengembalikan pesan aslinya. <br><br>  Pertimbangkan alfabet dari sejumlah kecil karakter, biasanya huruf jauh lebih besar.  Abjad bahasa mulai dari 16 hingga 36 karakter, termasuk karakter huruf besar dan kecil, tanda angka, tanda baca.  Misalnya, dalam tabel ASCII 128 = 2 ^ 7 karakter. <br>  Pertimbangkan kode khusus yang terdiri dari 4 karakter s1, s2, s3, s4 <br><br>  <b>s1 = 0;</b>  <b>s2 = 00;</b>  <b>s3 = 01;</b>  <b>s4 = 11.</b> <br><br>  Bagaimana seharusnya penerima menerjemahkan ungkapan yang diterima berikutnya <br><br>  <b>0011</b> ? <br><br>  Bagaimana <b>s1s1s4</b> atau bagaimana <b>s2s4</b> ? <br><br>  Anda tidak dapat memberikan jawaban yang jelas untuk pertanyaan ini, kode ini pasti tidak diterjemahkan, oleh karena itu, tidak memuaskan.  Kode, di sisi lain <br><br>  <b>s1 = 0;</b>  <b>s2 = 10;</b>  <b>s3 = 110;</b>  <b>s4 = 111</b> <br><br>  menerjemahkan pesan dengan cara yang unik.  Ambil string acak dan pertimbangkan bagaimana penerima akan menerjemahkannya.  Anda perlu membangun pohon decoding Menurut formulir pada Gambar 10.II.  Tali <br><br>  <b>1101000010011011100010100110</b> ... <br><br>  dapat dipecah menjadi blok-blok karakter <br><br>  <b>110, 10, 0, 10, 0, 110, 111, 0, 0, 0, 10, 10, 0, 110,</b> ... <br><br>  sesuai dengan aturan berikut untuk membangun pohon decoding: <br><br><blockquote>  Jika Anda berada di atas pohon, baca karakter berikutnya.  Saat Anda mencapai daun pohon, Anda mengonversi urutan ke karakter dan kembali ke awal. </blockquote><br>  Alasan keberadaan pohon seperti itu adalah bahwa tidak ada karakter yang merupakan awalan dari yang lain, jadi Anda selalu tahu kapan Anda harus kembali ke awal pohon decoding. <br><br>  Perlu memperhatikan hal-hal berikut.  Pertama, decoding adalah proses aliran ketat, di mana setiap bit diperiksa hanya sekali.  Kedua, protokol biasanya menyertakan karakter yang merupakan penanda akhir dari proses decoding dan diperlukan untuk menunjukkan akhir pesan. <br><br>  Kegagalan menggunakan karakter trailing adalah kesalahan umum dalam desain kode.  Tentu saja, Anda dapat memberikan mode decoding konstan, dalam hal ini karakter trailing tidak diperlukan. <br><br><img src="https://habrastorage.org/webt/jx/zn/py/jxznpy6gu3tgjcqw_kcicihl49w.jpeg" alt="gambar"><br><br>  <i>Gambar 10.II</i> <br><br>  Pertanyaan selanjutnya adalah kode untuk stream (instan) decoding.  Pertimbangkan kode yang diperoleh dari yang sebelumnya dengan menampilkan karakter <br><br>  <b>s1 = 0;</b>  <b>s2 = 01;</b>  <b>s3 = 011;</b>  <b>s4 = 111.</b> <br><br>  Misalkan kita mendapatkan urutan <b>011111 ... 111</b> .  Satu-satunya cara Anda dapat mendekode teks pesan adalah dengan mengelompokkan bit dari akhir 3 ke dalam grup dan memilih grup dengan nol di depannya, setelah itu Anda dapat mendekode.  Kode semacam itu diterjemahkan dengan cara yang unik, tetapi tidak secara instan!  Untuk decoding, Anda harus menunggu akhir transfer!  Dalam prakteknya, pendekatan ini menghilangkan laju decoding (teorema Macmillan), oleh karena itu, perlu untuk mencari metode decoding instan. <br><br>  Pertimbangkan dua cara untuk menyandikan karakter yang sama, Si: <br><br>  <b>s1 = 0;</b>  <b>s2 = 10;</b>  <b>s3 = 110;</b>  <b>s4 = 1110, s5 = 1111,</b> <br><br>  Pohon decoding dari metode ini ditunjukkan pada Gambar 10.III. <br><br><img src="https://habrastorage.org/webt/ox/bv/on/oxbvonl2ljgm0bgliqfgdy-qxsi.jpeg" alt="gambar"><br><br>  <i>Gambar 10.III</i> <br><br>  Cara kedua <br><br>  <b>s1 = 00;</b>  <b>s2 = 01;</b>  <b>s3 = 100;</b>  <b>s4 = 110, s5 = 111</b> , <br><br>  Pohon decoding dari perawatan ini ditunjukkan pada Gambar 10.IV. <br><br>  Cara paling jelas untuk mengukur kualitas kode adalah panjang rata-rata untuk satu set pesan.  Untuk ini, perlu untuk menghitung panjang kode setiap karakter dikalikan dengan probabilitas kemunculan pi yang sesuai.  Dengan demikian, panjang seluruh kode diperoleh.  Rumus untuk panjang rata-rata L dari kode untuk alfabet karakter q adalah sebagai berikut <br><br><img src="https://habrastorage.org/webt/o9/t8/hp/o9t8hprkvogq4j7tapnejfcqi5e.jpeg" alt="gambar"><br><br>  di mana pi adalah probabilitas kemunculan simbol si, li adalah panjang yang sesuai dari simbol yang dikodekan.  Untuk kode efisien, nilai L harus sekecil mungkin.  Jika P1 = 1/2, p2 = 1/4, p3 = 1/8, p4 = 1/16 dan p5 = 1/16, maka untuk kode # 1 kita mendapatkan nilai panjang kode <br><br><img src="https://habrastorage.org/webt/gm/dh/mm/gmdhmmak1wygwdg2bzrhpwjw5ek.jpeg" alt="gambar"><br><br>  Dan untuk kode # 2 <br><br><img src="https://habrastorage.org/webt/wl/gx/w_/wlgxw_sxrvguf4x7zxy5ppsjdeg.jpeg" alt="gambar"><br><br>  Nilai yang diperoleh menunjukkan preferensi kode pertama. <br>  Jika semua kata dalam alfabet memiliki probabilitas kejadian yang sama, maka kode kedua akan lebih disukai.  Misalnya, dengan pi = 1/5, panjang kode # 1 <br><br><img src="https://habrastorage.org/webt/fq/m_/5e/fqm_5ew-iiumvzfzhfa-dzqrvp0.jpeg" alt="gambar"><br><br>  dan panjang kode # 2 <br><br><img src="https://habrastorage.org/webt/so/h4/8h/soh48hms46bmymyvq2zfdjvhum0.jpeg" alt="gambar"><br><br>  hasil ini menunjukkan preferensi untuk 2 kode.  Jadi, ketika mengembangkan kode "baik", perlu untuk mempertimbangkan kemungkinan kemunculan karakter. <br><br><img src="https://habrastorage.org/webt/fl/z0/ta/flz0taltdxjpeh7d83nylufdezi.jpeg" alt="gambar"><br><br>  <i>Gambar 10.IV</i> <br><br><img src="https://habrastorage.org/webt/ub/0r/oc/ub0roc6s1bd8_tbjmbbi5knnmsy.jpeg" alt="gambar"><br><br>  <i>Gambar 10.V</i> <br><br>  Pertimbangkan ketidaksetaraan Kraft, yang menentukan nilai batas panjang kode simbol li.  Dalam basis 2, ketidaksetaraan direpresentasikan sebagai <br><br><img src="https://habrastorage.org/webt/uf/fm/3x/uffm3x64fdcwpfqm0t59-58ojm8.jpeg" alt="gambar"><br><br>  Ketidaksetaraan ini menunjukkan bahwa alfabet tidak dapat memiliki terlalu banyak karakter pendek, jika tidak, jumlahnya akan cukup besar. <br><br>  Untuk membuktikan ketidaksetaraan Kraft untuk setiap kode pendek unik yang didekodekan, kami membuat pohon pendekodean dan menerapkan metode induksi matematika.  Jika pohon memiliki satu atau dua daun, seperti yang ditunjukkan pada Gambar 10.V, maka ketidaksetaraan itu benar.  Selanjutnya, jika pohon itu memiliki lebih dari dua daun, maka kita membelah pohon panjang m menjadi dua sub pohon.  Menurut prinsip induksi, kita mengasumsikan bahwa ketidaksetaraan berlaku untuk setiap cabang dengan tinggi m -1 atau kurang.  Menurut prinsip induksi, menerapkan ketimpangan untuk setiap cabang.  Nyatakan panjang kode cabang K 'dan K' '.  Ketika menggabungkan dua cabang pohon, panjang masing-masing bertambah sebesar 1, oleh karena itu, panjang kode terdiri dari jumlah K '/ 2 dan K' '/ 2, <br><br><img src="https://habrastorage.org/webt/g9/-s/vv/g9-svvn75bjqfxxcuzrxf-vz_h0.jpeg" alt="gambar"><br><br>  teorema terbukti. <br><br>  Pertimbangkan bukti teorema Macmillan.  Kami menerapkan ketidaksetaraan Kraft ke kode decode tanpa thread.  Buktinya didasarkan pada fakta bahwa untuk bilangan K&gt; 1, kekuatan n dari bilangan jelas lebih dari fungsi linier n, di mana n adalah bilangan yang agak besar.  Kami meningkatkan ketimpangan Kraft ke kekuatan ke-n dan menyajikan ekspresi sebagai jumlah <br><br><img src="https://habrastorage.org/webt/zv/kx/lm/zvkxlmytcctyyvabj5iwh8x2nui.jpeg" alt="gambar"><br><br>  di mana Nk adalah jumlah karakter dari panjang k, penjumlahan dimulai dengan panjang minimum dari representasi n dari karakter dan berakhir dengan panjang maksimum nl, di mana l adalah panjang maksimum dari karakter yang dikodekan.  Dari persyaratan unik decoding maka ikuti itu.  Jumlahnya disajikan sebagai <br><br><img src="https://habrastorage.org/webt/2b/pj/pe/2bpjpe5u9p6epynv-sfxvfym2ji.jpeg" alt="gambar"><br><br>  Jika K&gt; 1, maka perlu untuk menetapkan n cukup besar agar ketidaksetaraan menjadi salah.  Oleh karena itu, k &lt;= 1;  Teorema Macmillan terbukti. <br><br>  Perhatikan beberapa contoh penerapan ketidaksetaraan Kraft.  Bisakah kode yang diterjemahkan secara unik ada dengan panjang 1, 3, 3, 3?  Ya sejak itu <br><br><img src="https://habrastorage.org/webt/wc/y3/gp/wcy3gpqx-cl-e60fb3-im8ec6n4.jpeg" alt="gambar"><br><br>  Bagaimana dengan panjang 1, 2, 2, 3?  Hitung sesuai dengan rumus <br><br><img src="https://habrastorage.org/webt/ix/aa/qz/ixaaqzsj_qvuc0ug-nys8ezqexe.jpeg" alt="gambar"><br><br>  Ketimpangan dilanggar!  Terlalu banyak karakter pendek dalam kode ini. <br><br>  Kode koma adalah kode yang terdiri dari karakter 1, diakhiri dengan karakter 0, dengan pengecualian karakter terakhir yang terdiri dari semua.  Salah satu kasus khusus adalah kode. <br><br>  <b>s1 = 0;</b>  <b>s2 = 10;</b>  <b>s3 = 110;</b>  <b>s4 = 1110;</b>  <b>s5 = 11111.</b> <br><br>  Untuk kode ini, kami memperoleh ekspresi untuk ketidaksetaraan Kraft <br><br><img src="https://habrastorage.org/webt/dv/x5/pj/dvx5pjumdoxckpby4xczhlf8yso.jpeg" alt="gambar"><br><br>  Dalam hal ini, kami mencapai kesetaraan.  Sangat mudah untuk melihat bahwa untuk kode titik, ketimpangan Kraft merosot menjadi kesetaraan. <br><br>  Saat membuat kode, Anda harus memperhatikan jumlah Kraft.  Jika jumlah Kraft mulai melebihi 1, maka ini merupakan sinyal tentang perlunya memasukkan karakter dengan panjang yang berbeda untuk mengurangi panjang kode rata-rata. <br><br>  Perlu dicatat bahwa ketidaksetaraan Kraft tidak berarti bahwa kode ini dapat didekodekan secara unik, tetapi ada kode dengan karakter dengan panjang sedemikian yang secara unik diterjemahkan.  Untuk membangun kode dekode yang unik, Anda dapat menetapkan panjang terkait dalam bit li dengan nomor biner.  Misalnya, untuk panjang 2, 2, 3, 3, 4, 4, 4, 4, kita memperoleh ketimpangan Kraft <br><br><img src="https://habrastorage.org/webt/dz/mf/ce/dzmfcev61jjvbppxsaqxblyetn4.jpeg" alt="gambar"><br><br>  Oleh karena itu, kode aliran yang diterjemahkan seperti itu mungkin ada. <br><br>  <b>s1 = 00;</b>  <b>s2 = 01;</b>  <b>s3 = 100;</b>  <b>s4 = 101;</b> <b><br><br></b>  <b>s5 = 1100;</b>  <b>s6 = 1101;</b>  <b>s7 = 1110;</b>  <b>s8 = 1111;</b> <br><br>  Saya ingin memperhatikan apa yang sebenarnya terjadi ketika kita bertukar ide.  Sebagai contoh, pada saat ini saya ingin mentransfer ide dari kepala saya ke milik Anda.  Saya mengucapkan beberapa kata yang melaluinya, seperti yang saya yakini, Anda dapat memahami (mendapatkan) ide ini. <br><br>  Tetapi ketika sedikit kemudian Anda ingin menyampaikan ide ini kepada teman Anda, Anda hampir pasti akan mengucapkan kata-kata yang sama sekali berbeda.  Faktanya, makna atau makna tidak tertutup dalam kata-kata tertentu.  Saya menggunakan beberapa kata, dan Anda dapat menggunakan kata-kata yang sangat berbeda untuk menyampaikan gagasan yang sama.  Dengan demikian, kata-kata yang berbeda dapat menyampaikan informasi yang sama.  Tetapi, segera setelah Anda memberi tahu lawan bicara Anda bahwa Anda tidak memahami pesan tersebut, maka sebagai patokan lawan bicara akan memilih serangkaian kata yang berbeda, yang kedua atau bahkan yang ketiga, untuk menyampaikan artinya.  Dengan demikian, informasi tersebut tidak dilampirkan dalam serangkaian kata-kata tertentu.  Segera setelah Anda menerima kata-kata ini atau itu, maka Anda melakukan banyak pekerjaan ketika menerjemahkan kata-kata itu ke dalam gagasan yang ingin disampaikan lawan bicara kepada Anda. <br><br>  Kami belajar memilih kata-kata untuk beradaptasi dengan lawan bicara.  Dalam arti tertentu, kami memilih kata-kata yang sesuai dengan pemikiran kami dan tingkat kebisingan di saluran, meskipun perbandingan seperti itu tidak secara akurat mencerminkan model yang saya gunakan untuk mewakili suara dalam proses pengodean ulang.  Dalam organisasi besar, masalah serius adalah ketidakmampuan lawan bicara untuk mendengar apa yang dikatakan orang lain.  Di posisi senior, karyawan mendengar apa yang "ingin mereka dengar".  Dalam beberapa kasus, Anda perlu mengingat ini ketika Anda naik tangga karier.  Penyajian informasi dalam bentuk formal adalah refleksi parsial dari proses dari kehidupan kita dan telah menemukan aplikasi luas jauh melampaui batas-batas aturan formal dalam aplikasi komputer. <br><br>  <i>Dilanjutkan ...</i> <br><br>  <i>Siapa yang ingin membantu dengan terjemahan, tata letak, dan penerbitan buku - tulis dalam email pribadi atau email magisterludi2016@yandex.ru</i> <br><br>  Ngomong-ngomong, kami juga meluncurkan terjemahan buku keren lainnya - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">“Mesin Impian: Sejarah Revolusi Komputer”</a> ) <br><br><div class="spoiler">  <b class="spoiler_title">Isi Buku dan Bab yang Diterjemahkan</b> <div class="spoiler_text">  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Kata Pengantar</a> <br><ol><li>  Pengantar Seni Melakukan Sains dan Teknik: Belajar untuk Belajar (28 Maret 1995) <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Terjemahan: Bab 1</a> </li><li>  "Yayasan Revolusi Digital (Terpisah)" (30 Maret 1995) <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bab 2. Dasar-Dasar Revolusi Digital (Terpisah)</a> </li><li>  "Sejarah Komputer - Perangkat Keras" (31 Maret 1995) <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bab 3.</a> Sejarah Komputer - Perangkat Keras </li><li>  "Sejarah Komputer - Perangkat Lunak" (4 April 1995) <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bab 4. Sejarah Komputer - Perangkat Lunak</a> </li><li>  Sejarah Komputer - Aplikasi (6 April 1995) <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bab 5. Sejarah Komputer - Aplikasi Praktis</a> </li><li>  "Kecerdasan Buatan - Bagian I" (7 April 1995) <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bab 6. Kecerdasan Buatan - 1</a> </li><li>  "Kecerdasan Buatan - Bagian II" (11 April 1995) <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bab 7. Kecerdasan Buatan - II</a> </li><li>  "Kecerdasan Buatan III" (13 April 1995) <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bab 8. Kecerdasan Buatan-III</a> </li><li>  "Ruang N-Dimensi" (14 April 1995) <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bab 9. Ruang N-Dimensi</a> </li><li>  "Teori Pengkodean - Representasi Informasi, Bagian I" (18 April 1995) <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bab 10. Teori Pengkodean - I</a> </li><li>  "Teori Pengkodean - Representasi Informasi, Bagian II" (20 April 1995) <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bab 11. Teori Pengkodean - II</a> </li><li>  “Kode Koreksi Kesalahan” (21 April 1995) <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bab 12. Kode Koreksi Kesalahan</a> </li><li>  "Teori Informasi" (25 April 1995) <i>(penerjemah menghilang: (())</i> </li><li>  Filter Digital, Bagian I (27 April 1995) <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bab 14. Filter Digital - 1</a> </li><li>  Filter Digital, Bagian II (28 April 1995) <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bab 15. Filter Digital - 2</a> </li><li>  Filter Digital, Bagian III (2 Mei 1995) <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bab 16. Filter Digital - 3</a> </li><li>  Filter Digital, Bagian IV (4 Mei 1995) <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bab 17. Filter Digital - IV</a> </li><li>  “Simulasi, Bagian I” (5 Mei 1995) <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bab 18. Pemodelan - I</a> </li><li>  "Simulasi, Bagian II" (9 Mei 1995) <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bab 19. Pemodelan - II</a> </li><li>  "Simulasi, Bagian III" (11 Mei 1995) </li><li>  Serat Optik (12 Mei 1995) <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bab 21. Serat Optik</a> </li><li>  “Computer Aided Instruction” (16 Mei 1995) <i>(penerjemah menghilang: (())</i> </li><li>  Matematika (18 Mei 1995) <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bab 23. Matematika</a> </li><li>  Mekanika Kuantum (19 Mei 1995) <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bab 24. Mekanika Kuantum</a> </li><li>  Kreativitas (23 Mei 1995).  Terjemahan: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bab 25. Kreativitas</a> </li><li>  "Pakar" (25 Mei 1995) <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bab 26. Pakar</a> </li><li>  “Data Tidak Dapat Diandalkan” (26 Mei 1995) <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bab 27. Data Tidak Valid</a> </li><li>  Rekayasa Sistem (30 Mei 1995) <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bab 28. Rekayasa Sistem</a> </li><li>  “Anda Mendapatkan Apa yang Anda Ukur” (1 Juni 1995) <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bab 29.</a> Anda Mendapatkan Apa yang Anda Ukur </li><li>  "Bagaimana Kita Tahu Apa yang Kita Ketahui" (2 Juni 1995) <i>penerjemah menghilang: (((</i> </li><li>  Hamming, “Anda dan Penelitian Anda” (6 Juni 1995).  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Terjemahan: Anda dan Pekerjaan Anda</a> </li></ol><br>     ,     —       magisterludi2016@yandex.ru <br><br></div></div></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id417109/">https://habr.com/ru/post/id417109/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id417099/index.html">Bagaimana saya menulis library C ++ 11 standar atau mengapa boost sangat menakutkan. Bab 2</a></li>
<li><a href="../id417101/index.html">Definisi Ready - Yang Kami Lupa Memberitahu Tentang</a></li>
<li><a href="../id417103/index.html">Spark SQL. Sedikit tentang pengoptimal permintaan</a></li>
<li><a href="../id417105/index.html">Mencetak pada printer 3D. Pengalaman Rahasia 3Dtool</a></li>
<li><a href="../id417107/index.html">Pembuat game sementara True: learn () tentang pemrograman gamedev, masalah VR, dan simulasi ML</a></li>
<li><a href="../id417111/index.html">Konferensi online: streaming vs webinar</a></li>
<li><a href="../id417113/index.html">Printer Italia 3D di Rusia: Raise3D N1 Dual - modelling dan prototyping</a></li>
<li><a href="../id417115/index.html">Untuk mengubur atau membakar Flutter.io?</a></li>
<li><a href="../id417117/index.html">Membalikkan rekayasa emulator NES dalam game untuk GameCube</a></li>
<li><a href="../id417119/index.html">Pagination di Vue.js</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>