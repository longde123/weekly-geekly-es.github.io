<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ‘¨ğŸ»â€ğŸ¤ ğŸ¤¹ğŸ½ ğŸ§‘ğŸ¿â€ğŸ¤â€ğŸ§‘ğŸ¾ Labyrinthes: classification, gÃ©nÃ©ration, recherche de solutions ğŸ”» ğŸï¸ ğŸŒ¯</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Cet article classique dÃ©taille les faÃ§ons les plus populaires de crÃ©er et de parcourir des labyrinthes. L'article est divisÃ© en quatre parties: classi...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Labyrinthes: classification, gÃ©nÃ©ration, recherche de solutions</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/445378/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/50c/8cc/ddc/50c8ccddc7242a00cf9dd62fba696ed2.gif"></div><br>  <i>Cet article classique dÃ©taille les faÃ§ons les plus populaires de crÃ©er et de parcourir des labyrinthes.</i>  <i>L'article est divisÃ© en quatre parties: classification, algorithmes de gÃ©nÃ©ration, algorithmes de rÃ©solution de labyrinthes et autres opÃ©rations avec des labyrinthes.</i> <br><br><h2>  Classification du labyrinthe </h2><br>  Les labyrinthes dans leur ensemble (et donc les algorithmes pour les crÃ©er) peuvent Ãªtre divisÃ©s en sept classifications diffÃ©rentes: dimension, hyperdimension, topologie, tessellation, routage, texture et prioritÃ©.  Le labyrinthe peut utiliser un Ã©lÃ©ment de chaque classe dans n'importe quelle combinaison. <a name="habracut"></a><br>  <b>Dimension:</b> la classe de dimension dÃ©termine essentiellement le nombre de dimensions dans l'espace que le labyrinthe remplit.  Les types suivants sont disponibles: <br><br><ul><li><img src="https://habrastorage.org/getpro/habr/post_images/0a7/93f/443/0a793f443fe8f89980ecfd43559ccc81.gif"><br><br>  <b>Deux dimensions</b> <b>: la</b> plupart des labyrinthes, papier et rÃ©el, ont cette dimension, c'est-Ã -dire que nous pouvons toujours afficher le plan du labyrinthe sur une feuille de papier et le dÃ©placer sans traverser d'autres couloirs du labyrinthe. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><b>En trois dimensions</b></a> <b>: le</b> labyrinthe en trois dimensions a plusieurs niveaux;  en elle (au moins dans la version orthogonale), les passages peuvent descendre et monter, en plus des quatre points cardinaux.  Un labyrinthe 3D est souvent visualisÃ© comme un tableau de niveaux 2D avec des escaliers de haut en bas. </li><li><img src="https://habrastorage.org/getpro/habr/post_images/999/897/373/9998973734d2c66d06205a9ade0b501c.gif"><br><br>  <b>Dimensions supÃ©rieures</b> <b>:</b> vous pouvez crÃ©er des labyrinthes Ã  quatre dimensions et encore plus des labyrinthes multidimensionnels.  Parfois, ils sont visualisÃ©s comme des labyrinthes 3D avec des Â«portailsÂ» menant Ã  travers la quatriÃ¨me dimension, par exemple, des portails vers le Â«passÃ©Â» et le Â«futurÂ». </li><li><img src="https://habrastorage.org/getpro/habr/post_images/56a/89a/c01/56a89ac017b5faa694d3e15ab8d3948d.gif"><br><br>  <b>Entrelacement</b> <b>:</b> labyrinthes avec entrelacement - ce sont essentiellement des labyrinthes bidimensionnels (ou plutÃ´t 2,5 dimensions), dans lesquels, cependant, les passages peuvent se chevaucher.  Lors de l'affichage, il est gÃ©nÃ©ralement assez Ã©vident oÃ¹ se trouvent les impasses et comment un passage est au-dessus de l'autre.  Des labyrinthes du monde rÃ©el, dans lesquels se trouvent des ponts reliant une partie du labyrinthe Ã  une autre, s'entrelacent partiellement. </li></ul><br>  <b>Hyperdimension: la</b> classification selon l'hyperdimension correspond Ã  la dimension d'un objet se dÃ©plaÃ§ant dans un labyrinthe, et non au labyrinthe lui-mÃªme.  Les types suivants sont disponibles: <br><br><ul><li><img src="https://habrastorage.org/getpro/habr/post_images/0a7/93f/443/0a793f443fe8f89980ecfd43559ccc81.gif"><br><br>  <b>Non-hyperlabyrinthes</b> <b>:</b> presque tous les labyrinthes, mÃªme ceux crÃ©Ã©s en haute dimensionnalitÃ© ou avec des rÃ¨gles spÃ©ciales, sont gÃ©nÃ©ralement des non-hyperlabyrinthes.  En eux, nous travaillons avec un point ou un petit objet, par exemple, une balle ou le joueur lui-mÃªme, qui se dÃ©place d'un point Ã  un autre, et l'itinÃ©raire pavÃ© forme une ligne.  Ã€ chaque point, il existe un nombre de choix facilement dÃ©nombrable. </li><li>  <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Hyperlabyrinthes: les</a></b> hyperlabyrinthes sont des labyrinthes dans lesquels l'objet Ã  rÃ©soudre n'est pas seulement un point.  Un hyperlabyrinthe standard (ou hyperlabyrinthe de premier ordre) consiste en une ligne qui forme une surface lors du dÃ©placement le long d'un chemin.  L'hyperlabyrinthe ne peut exister qu'en 3D ou dans un milieu de plus grande dimension, et l'entrÃ©e de l'hyperlabyrinthe n'est souvent pas un point, mais une ligne.  L'hyperlabyrinthe est fondamentalement diffÃ©rent, car il est nÃ©cessaire de prendre en compte et de travailler simultanÃ©ment avec plusieurs parties le long de la ligne, et Ã  tout moment, il existe un nombre presque infini d'Ã©tats et d'options pour ce qui peut Ãªtre fait avec la ligne.  La ligne de solution est infinie, ou ses extrÃ©mitÃ©s sont en dehors de l'hyperlabyrinthe pour Ã©viter que la ligne ne soit compressÃ©e en un point, car dans ce cas, elle peut Ãªtre considÃ©rÃ©e comme non hyperlabyrinthe. </li><li>  <b>Hyper-hyperlabyrinthe: les</b> hyperlabyrinthes peuvent avoir une dimension arbitrairement Ã©levÃ©e.  L'hyper-hyperlabyrinthe (ou hyperlabyrinthe de second ordre) augmente Ã  nouveau la dimension de l'objet Ã  rÃ©soudre.  Ici, l'objet Ã  rÃ©soudre est un plan qui, en se dÃ©plaÃ§ant le long du chemin, forme une figure tridimensionnelle.  L'hyper-hyperlabyrinthe ne peut exister que dans un environnement dimensionnel 4D ou supÃ©rieur. </li></ul><br>  <b>Topologie: la</b> classe de topologie dÃ©crit la gÃ©omÃ©trie de l'espace du labyrinthe dans lequel il existe dans son ensemble.  Les types suivants sont disponibles: <br><br><ul><li><img src="https://habrastorage.org/getpro/habr/post_images/0a7/93f/443/0a793f443fe8f89980ecfd43559ccc81.gif"><br><br>  <b>Normal</b> <b>:</b> il s'agit du labyrinthe standard dans l'espace euclidien. </li><li><img src="https://habrastorage.org/getpro/habr/post_images/ff3/d52/35d/ff3d5235d49cbe3a9d2a562033d73202.gif"><br><br>  <b>Planair</b> <b>: Le</b> terme Â«planairÂ» dÃ©crit tout labyrinthe avec une topologie inhabituelle.  Cela signifie gÃ©nÃ©ralement que les bords du labyrinthe sont connectÃ©s de maniÃ¨re intÃ©ressante.  Exemples: labyrinthes Ã  la surface d'un cube, labyrinthes Ã  la surface d'une bande Mobius et labyrinthes Ã©quivalents Ã  ceux d'un tore oÃ¹ les cÃ´tÃ©s gauche et droit, supÃ©rieur et infÃ©rieur sont reliÃ©s par paires. </li></ul><br>  <b>Tessellation: une</b> classification de la gÃ©omÃ©trie des cellules individuelles qui composent le labyrinthe.  Types existants: <br><br><ul><li><img src="https://habrastorage.org/getpro/habr/post_images/0a7/93f/443/0a793f443fe8f89980ecfd43559ccc81.gif"><br><br>  <b>Orthogonale</b> <b>:</b> Il s'agit d'une grille rectangulaire standard dans laquelle les cellules ont des passages qui se coupent Ã  angle droit.  Dans le contexte de la tessellation, ils peuvent Ã©galement Ãªtre appelÃ©s labyrinthes gamma. </li><li><img src="https://habrastorage.org/getpro/habr/post_images/488/88c/28f/48888c28fd1c5ad3601c0dbb4e3716f6.gif"><br><br>  <b>Delta</b> <b>:</b> les labyrinthes Delta se composent de triangles connectÃ©s, et chaque cellule peut avoir jusqu'Ã  trois passages qui lui sont connectÃ©s. </li><li><img src="https://habrastorage.org/getpro/habr/post_images/650/dcd/b76/650dcdb76582619209847e3111cb0ad4.gif"><br><br>  <b>Sigma</b> <b>: les</b> labyrinthes Sigma sont constituÃ©s d'hexagones connectÃ©s;  chaque cellule peut avoir jusqu'Ã  six passes. </li><li><img src="https://habrastorage.org/getpro/habr/post_images/b12/0eb/9da/b120eb9da20a99a3985e76a644b4e740.gif"><br><br>  <b>ThÃªta</b> <b>: les</b> labyrinthes thÃªta sont constituÃ©s de cercles concentriques de passages dont le dÃ©but ou la fin est au centre et l'autre sur le bord extÃ©rieur.  Les cellules ont gÃ©nÃ©ralement quatre chemins de connexion possibles, mais il peut y en avoir plus en raison du plus grand nombre de cellules dans les anneaux externes des passages. </li><li><img src="https://habrastorage.org/getpro/habr/post_images/283/751/2a5/2837512a58f5ad292e93b65a832e80fa.gif"><br><br>  <b>Epsilon</b> <b>: les</b> labyrinthes d'Epsilon sont constituÃ©s d'octogones ou de carrÃ©s connectÃ©s, chaque cellule en eux peut avoir jusqu'Ã  huit ou quatre passes. </li><li><img src="https://habrastorage.org/getpro/habr/post_images/bba/929/e12/bba929e1276ce4be65f121f20bf101c0.gif"><br><br>  <b>Zeta</b> <b>: Le</b> labyrinthe zeta est situÃ© sur une grille rectangulaire, seulement en plus des passages horizontaux et verticaux, les passages diagonaux sont autorisÃ©s Ã  un angle de 45 degrÃ©s. </li><li><img src="https://habrastorage.org/getpro/habr/post_images/488/88c/28f/48888c28fd1c5ad3601c0dbb4e3716f6.gif"><br><br>  <b>OmÃ©ga</b> <b>: le</b> terme omÃ©ga fait rÃ©fÃ©rence Ã  presque tous les labyrinthes Ã  pavage constant non orthogonal.  Les labyrinthes delta, sigma, thÃªta et ipsilon sont de ce type, comme de nombreux autres schÃ©mas auxquels vous pouvez penser, par exemple, un labyrinthe composÃ© de paires de triangles rectangles. </li><li><img src="https://habrastorage.org/getpro/habr/post_images/47f/d14/6db/47fd146dba649e214e28a18207a7da89.gif"><br><br>  <b>Fissure</b> <b>: Un</b> labyrinthe de fissures est un labyrinthe amorphe sans pavage constant, dans lequel les murs et les allÃ©es sont situÃ©s Ã  des angles alÃ©atoires. </li><li><img src="https://habrastorage.org/getpro/habr/post_images/538/fe4/b6e/538fe4b6e758b139f1e9b1b258a5bc25.gif"><br><br>  <b>Fractale</b> <b>: Un</b> labyrinthe fractal est un labyrinthe composÃ© de labyrinthes plus petits.  Un labyrinthe fractal Ã  partir de cellules imbriquÃ©es est un labyrinthe dans chaque cellule dont d'autres labyrinthes sont placÃ©s, et ce processus peut Ãªtre rÃ©pÃ©tÃ© plusieurs fois.  Un labyrinthe fractal infiniment rÃ©cursif est une vÃ©ritable fractale dans laquelle le contenu du labyrinthe se rÃ©plique, crÃ©ant un labyrinthe essentiellement infiniment grand. </li></ul><br>  <b>Routage: La</b> classification par routage est probablement l'aspect le plus intÃ©ressant dans la gÃ©nÃ©ration de labyrinthes.  From est associÃ© Ã  des types de passes dans la gÃ©omÃ©trie dÃ©finie dans les catÃ©gories dÃ©crites ci-dessus. <br><br><ul><li><img src="https://habrastorage.org/getpro/habr/post_images/0a7/93f/443/0a793f443fe8f89980ecfd43559ccc81.gif"><br><br>  <b>IdÃ©al</b> <b>:</b> Â«idÃ©alÂ» est un labyrinthe sans boucles ni circuits fermÃ©s et sans zones inaccessibles.  Il est Ã©galement appelÃ© un labyrinthe simplement connectÃ©.  De chaque point, il y a exactement un chemin vers tout autre point.  Labyrinth n'a qu'une seule solution.  Du point de vue de la programmation, un tel labyrinthe peut Ãªtre dÃ©crit comme un arbre, un ensemble de connexion de cellules ou de sommets. </li><li><img src="https://habrastorage.org/getpro/habr/post_images/47a/0e8/60b/47a0e860b7ea1df363248e3348616cd7.gif"><br><br>  <b>TressÃ©</b> <b>:</b> tressÃ© signifie qu'il n'y a pas d'impasse dans le labyrinthe.  Il est Ã©galement appelÃ© le labyrinthe de labyrinthe purement connectÃ©.  Dans un tel labyrinthe, on utilise des passages fermÃ©s et revenant les uns aux autres (d'oÃ¹ le nom Â«osierÂ»), ils leur font passer plus de temps Ã  tourner en rond au lieu de se retrouver dans des impasses.  Un labyrinthe tissÃ© de qualitÃ© peut Ãªtre beaucoup plus compliquÃ© qu'un labyrinthe idÃ©al de la mÃªme taille. </li><li><img src="https://habrastorage.org/getpro/habr/post_images/21d/cca/63c/21dcca63cf5cfd7d0b36e6bdff94da1f.gif"><br><br>  <b>Single-route (Unicursal)</b> <b>:</b> single- <b>route</b> signifie un labyrinthe sans fourches.  Le labyrinthe Ã  sens unique contient un long passage sinueux qui change de direction dans tout le labyrinthe.  Ce n'est pas trÃ¨s compliquÃ©, seulement si vous ne faites pas accidentellement demi-tour et ne revenez pas au dÃ©but. </li><li> <b><img src="https://habrastorage.org/getpro/habr/post_images/add/a2c/cb6/adda2ccb6c09bd76428e17a395f8fd3e.gif"><br><br></b>  <b>ClairsemÃ©: un</b> labyrinthe clairsemÃ© ne traverse pas chaque cellule, c'est-Ã -dire que certains d'entre eux ne sont pas crÃ©Ã©s.  Cela implique la prÃ©sence de zones inaccessibles, c'est-Ã -dire en quelque sorte l'opposÃ© du labyrinthe en osier.  Un concept similaire peut Ãªtre appliquÃ© lors de l'ajout de murs, de sorte que vous pouvez obtenir un labyrinthe inÃ©gal avec de larges allÃ©es et des piÃ¨ces. </li><li>  <b>Partiellement en osier:</b> Labyrinthe partiellement en osier est un labyrinthe mixte qui a Ã  la fois des boucles et des impasses.  Le mot Â«osierÂ» peut Ãªtre utilisÃ© pour une Ã©valuation quantitative, c'est-Ã -dire qu'un Â«labyrinthe solideÂ» est un labyrinthe avec de nombreuses boucles ou des murs rÃ©tractÃ©s, et il n'y en a que quelques-uns dans le Â«labyrinthe faiblement tissÃ©Â». </li></ul><br>  <b>Texture: la</b> classification de la <b>texture</b> dÃ©crit le style des passes avec un routage et une gÃ©omÃ©trie diffÃ©rents.  La texture n'est pas seulement des paramÃ¨tres qui peuvent Ãªtre activÃ©s ou dÃ©sactivÃ©s.  Voici quelques exemples de variables: <br><br><ul><li><img src="https://habrastorage.org/getpro/habr/post_images/96d/730/eb5/96d730eb5f18e0c65786b410e5cb77cd.gif"><br><br>  <b>Biais</b> <b>:</b> dans un labyrinthe avec des passages dÃ©calÃ©s, les passages droits ont tendance Ã  aller plus dans un sens que dans les autres.  Par exemple, dans un labyrinthe Ã  fort dÃ©placement horizontal, nous aurons de longs passages de gauche Ã  droite, et seulement de courts passages de haut en bas les reliant.  Un tel labyrinthe est gÃ©nÃ©ralement plus difficile Ã  passer Â«Ã  travers les fibresÂ». </li><li><img src="https://habrastorage.org/getpro/habr/post_images/264/855/d73/264855d73cffcf3937c7497f8e021ae1.gif"><br><br>  <b>Overflight</b> <b>: la</b> mÃ©trique <b>Overflight</b> dÃ©termine combien de temps les couloirs prendront avant que les virages forcÃ©s n'apparaissent.  Dans un labyrinthe de faible envergure, il n'y aura pas de passages rectilignes de plus de trois ou quatre cellules, et cela aura l'air trÃ¨s alÃ©atoire.  Dans un labyrinthe Ã  grande portÃ©e, le labyrinthe aura un grand pourcentage de passes longues, ce qui lui donnera l'apparence d'une micropuce. </li><li> <b><img src="https://habrastorage.org/getpro/habr/post_images/923/8dd/bac/9238ddbac833a6b351ddbec6aef9eee0.gif"><br><br></b>  <b>Ã‰litisme:</b> l'indicateur Â«Ã©liteÂ» du labyrinthe dÃ©termine la longueur de la solution par rapport Ã  la taille du labyrinthe.  Les labyrinthes d'Ã©lite ont gÃ©nÃ©ralement une solution courte et directe, et dans les labyrinthes non Ã©lites, la solution passe sur une grande partie de la zone du labyrinthe.  Un labyrinthe d'Ã©lite de haute qualitÃ© peut Ãªtre beaucoup plus compliquÃ© qu'un labyrinthe non d'Ã©lite. </li><li><img src="https://habrastorage.org/getpro/habr/post_images/471/8e1/c13/4718e1c13d43140bd41c40081eaf0b4c.gif"><br><br>  <b>SymÃ©trie</b> <b>: un</b> labyrinthe symÃ©trique a des passages symÃ©triques, par exemple, dans la symÃ©trie de rotation par rapport au centre, ou rÃ©flÃ©chi le long des axes horizontal ou vertical.  Le labyrinthe peut Ãªtre partiellement ou complÃ¨tement symÃ©trique et peut rÃ©pÃ©ter le motif un certain nombre de fois. </li><li> <b><img src="https://habrastorage.org/getpro/habr/post_images/8a9/d2b/0c6/8a9d2b0c60f1c65e96bac07fd947c565.gif"><br><br></b>  <b>HomogÃ©nÃ©itÃ©: un</b> algorithme homogÃ¨ne gÃ©nÃ¨re tous les labyrinthes possibles avec une probabilitÃ© Ã©gale.  Un labyrinthe peut Ãªtre qualifiÃ© de texture homogÃ¨ne s'il ressemble Ã  un labyrinthe typique gÃ©nÃ©rÃ© par un algorithme homogÃ¨ne.  Un algorithme hÃ©tÃ©rogÃ¨ne peut thÃ©oriquement Ã©galement gÃ©nÃ©rer tous les labyrinthes possibles dans n'importe quel espace, mais pas avec une probabilitÃ© Ã©gale.  L'hÃ©tÃ©rogÃ©nÃ©itÃ© peut aller encore plus loin - il peut y avoir des labyrinthes que l'algorithme ne gÃ©nÃ©rera jamais. </li><li>  <b>DÃ©bit de la riviÃ¨re: La</b> caractÃ©ristique de Â«dÃ©bitÂ» signifie que lors de la crÃ©ation d'un labyrinthe, l'algorithme recherchera et nettoiera les cellules (ou parois) voisines de la cellule actuelle, c'est-Ã -dire qu'il coulera (d'oÃ¹ le terme de Â«fluiditÃ©Â») dans les parties encore non crÃ©Ã©es du labyrinthe, comme l'eau.  Dans un labyrinthe idÃ©al avec un dÃ©bit plus faible, il y aura gÃ©nÃ©ralement de nombreuses impasses courtes, et dans un labyrinthe plus Â«fluideÂ», il y aura moins d'impasses, mais elles seront plus longues. </li></ul><br>  <b>PrioritÃ©:</b> cette classification montre que les processus de crÃ©ation de labyrinthes peuvent Ãªtre divisÃ©s en deux types principaux: l'ajout de murs et la sculpture de passages.  Habituellement, lors de la gÃ©nÃ©ration de cela, cela se rÃ©sume uniquement Ã  la diffÃ©rence dans les algorithmes, et non Ã  des diffÃ©rences notables dans les labyrinthes, mais il est toujours utile d'en tenir compte.  Le mÃªme labyrinthe est souvent gÃ©nÃ©rÃ© dans les deux sens: <br><br><ul><li>  <b>Ajout de murs: les</b> algorithmes pour lesquels les murs sont prioritaires commencent par une zone vide (ou une bordure externe), ajoutant des murs dans le processus.  Dans le monde rÃ©el, de vrais labyrinthes composÃ©s de haies, de plafonds ou de murs en bois ajoutent dÃ©finitivement des murs. </li><li>  <b>Couper les allÃ©es: les</b> algorithmes dont la prioritÃ© est aux allÃ©es commencent par un bloc solide et coupent des passages dans celui-ci au cours du processus.  Dans le monde rÃ©el, ces labyrinthes sont des tunnels miniers ou des labyrinthes Ã  l'intÃ©rieur des tuyaux. </li><li> <b><img src="https://habrastorage.org/getpro/habr/post_images/788/7d3/94f/7887d394fd2acf973c1dcfd4616dc09f.gif"><br><br></b>  <b>ModÃ¨le:</b> bien sÃ»r, les labyrinthes peuvent simultanÃ©ment couper des passages et ajouter des murs;  certains algorithmes informatiques le font.  Un modÃ¨le de labyrinthe est une image graphique qui n'est pas un labyrinthe qui, au moindre nombre d'Ã©tapes, se transforme en vÃ©ritable labyrinthe, mais conserve la texture du modÃ¨le graphique d'origine.  Les styles de labyrinthe complexes, tels que les spirales qui se croisent, sont plus faciles Ã  implÃ©menter en tant que modÃ¨les dans un ordinateur, plutÃ´t que d'essayer de crÃ©er le bon labyrinthe tout en prÃ©servant son style. </li></ul><br>  <b>Autre: ce qui</b> prÃ©cÃ¨de n'est en aucun cas une liste exhaustive de toutes les classes ou Ã©lÃ©ments possibles au sein de chaque classe.  Ce ne sont que ces types de labyrinthes que j'ai crÃ©Ã©s moi-mÃªme.  Notez que presque tous les types de labyrinthe, y compris les labyrinthes avec des rÃ¨gles spÃ©ciales, peuvent Ãªtre exprimÃ©s sous forme de graphique dirigÃ© dans lequel il y aura un nombre fini d'Ã©tats et un nombre fini de choix dans chaque Ã©tat, et cela s'appelle l' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><b>Ã©quivalence des labyrinthes</b></a> .  Voici quelques autres classifications et types de labyrinthes: <br><br><ul><li><img src="https://habrastorage.org/getpro/habr/post_images/d19/d0e/264/d19d0e264db5d3d8521fbe62037c1b07.gif"><br><br>  <b>Orientation</b> <b>:</b> sur certains passages, vous ne pouvez vous dÃ©placer que dans une seule direction.  Du point de vue de la programmation, un tel labyrinthe sera dÃ©crit par un graphe orientÃ©, contrairement Ã  un graphe non orientÃ© dÃ©crivant tous les autres types. </li><li><img src="https://habrastorage.org/getpro/habr/post_images/43e/596/214/43e596214c1af1f52950a1223d111c3e.gif"><br><br>  <b>Segmentation</b> <b>: le</b> labyrinthe peut avoir diffÃ©rentes parties correspondant Ã  diffÃ©rentes classes. </li><li> <b><img src="https://habrastorage.org/getpro/habr/post_images/099/aee/262/099aee262a4d50e33bb92ab5b82946c6.gif"><br><br></b>  <b>Labyrinthes de longueur infinie:</b> nous pouvons crÃ©er un labyrinthe infiniment long (un nombre fini de colonnes et un nombre quelconque de lignes), mais en mÃªme temps ne stocker qu'une partie du labyrinthe en mÃ©moire, "faire dÃ©filer" d'une extrÃ©mitÃ© Ã  l'autre et dÃ©truire les lignes prÃ©cÃ©dentes lors de la crÃ©ation de la suivante.  Un exemple est une version modifiÃ©e de l'algorithme Hunt and Kill.  On peut imaginer un labyrinthe potentiellement sans fin sous la forme d'un long film composÃ© d'images individuelles.  Seules deux trames consÃ©cutives sont stockÃ©es en mÃ©moire Ã  la fois.  ExÃ©cutons l'algorithme Hunt and Kill, bien qu'il crÃ©e un biais sujet au cadre supÃ©rieur, il se termine donc en premier.  Une fois terminÃ©, le cadre n'est plus nÃ©cessaire, vous pouvez l'imprimer ou faire autre chose avec.  Quoi qu'il en soit, jetez-le, faites du cadre infÃ©rieur partiellement crÃ©Ã© un nouveau cadre supÃ©rieur et effacez le nouveau cadre infÃ©rieur.  RÃ©pÃ©tez le processus jusqu'Ã  ce que nous dÃ©cidions d'arrÃªter, puis attendez que Hunt And Kill termine les deux images.  La seule limitation est que le labyrinthe n'aura jamais de chemin se ramifiant vers l'entrÃ©e sur une longueur de plus de deux images.  La faÃ§on la plus simple de crÃ©er un labyrinthe sans fin est l'algorithme Eller ou l'algorithme Sidewinder, car ils crÃ©ent dÃ©jÃ  des labyrinthes une ligne Ã  la fois, vous pouvez donc simplement les laisser ajouter sans cesse des lignes au labyrinthe. </li><li> <b><img src="https://habrastorage.org/getpro/habr/post_images/8e1/677/f0f/8e1677f0fc6dbdfb99739ed66ec8d534.png" alt="image"><br><br></b>  <b>Labyrinthes fractals</b> virtuels <b>: le</b> virtuel est un labyrinthe dans lequel tout le labyrinthe n'est pas stockÃ© en mÃ©moire en mÃªme temps.  Par exemple, il ne peut stocker qu'une partie des passages 100x100 prÃ¨s de votre emplacement dans une simulation oÃ¹ vous vous promenez dans un grand labyrinthe.  L'extension des labyrinthes fractals imbriquÃ©s peut Ãªtre utilisÃ©e pour crÃ©er d'Ã©normes labyrinthes virtuels, par exemple, un milliard par milliard de passes.  Si nous construisions une vÃ©ritable copie du labyrinthe d'un milliard par milliard de passes (avec une distance de six pieds entre les passages), cela remplirait la surface de la Terre plus de 6 000 fois!  ConsidÃ©rez un labyrinthe de 10 <sup>9</sup> Ã  10 <sup>9</sup> passes, ou un labyrinthe fermÃ© avec seulement 9 niveaux.  Si nous voulons avoir au moins une partie 100x100 autour de nous, alors il nous suffit de crÃ©er au niveau le plus bas un sous-labyrinthe de 100x100 passes et sept labyrinthes 10x10 dans lesquels il est intÃ©grÃ© afin de savoir exactement oÃ¹ se trouvent les murs dans la partie 100x100.  (En fait, il vaut mieux avoir quatre piÃ¨ces adjacentes de 100 x 100, formant un carrÃ© au cas oÃ¹ vous seriez prÃ¨s du bord ou du coin de la piÃ¨ce, mais le mÃªme concept s'applique ici.) Pour garantir que le labyrinthe est constant et inchangÃ© lors du dÃ©placement, nous avons une formule, dÃ©finir un nombre de graines alÃ©atoire pour chaque coordonnÃ©e Ã  chaque niveau d'imbrication.  Les labyrinthes fractals virtuels sont similaires Ã  la fractale Mandelbrot, dont les images existent virtuellement, et nous devons visiter une certaine coordonnÃ©e Ã  un grossissement assez Ã©levÃ©.  pour qu'il apparaisse. </li></ul><br><h2>  Algorithmes de labyrinthe </h2><br>  Voici une liste d'algorithmes gÃ©nÃ©ralisÃ©s pour crÃ©er les diffÃ©rentes classes de labyrinthes dÃ©crites ci-dessus: <br><br><ul><li><img src="https://habrastorage.org/getpro/habr/post_images/0a7/93f/443/0a793f443fe8f89980ecfd43559ccc81.gif"><br><br>  <b>IdÃ©al</b> <b>:</b> pour crÃ©er un labyrinthe idÃ©al standard, il est gÃ©nÃ©ralement nÃ©cessaire de le Â«cultiverÂ», en garantissant l'absence de boucles et de zones isolÃ©es.  Nous partons du mur extÃ©rieur et ajoutons au hasard un fragment du mur qui le touche.  Nous continuons d'ajouter au hasard des segments de mur au labyrinthe, mais vÃ©rifions que chaque nouveau segment touche une extrÃ©mitÃ© du mur existant et que son autre extrÃ©mitÃ© se trouve dans la partie non crÃ©Ã©e du labyrinthe.  Si vous ajoutez un segment de mur, dont les deux extrÃ©mitÃ©s sont sÃ©parÃ©es du reste du labyrinthe, cela crÃ©era un mur non connectÃ© avec une boucle autour de lui, et si vous ajoutez un segment, dont les deux extrÃ©mitÃ©s touchent le labyrinthe, cela crÃ©era une zone inaccessible.  Il s'agit d'une mÃ©thode pour ajouter des murs;  elle est presque analogue Ã  la dÃ©coupe de passages, dans lesquels des parties des passages sont coupÃ©es de sorte qu'une seule extrÃ©mitÃ© touche la passe existante. </li><li><img src="https://habrastorage.org/getpro/habr/post_images/47a/0e8/60b/47a0e860b7ea1df363248e3348616cd7.gif"><br><br> <b></b> <b>:</b>               ,   ,          .      : (1)    , (2)       ,    ,          -Â«Â», (3)        ,   ,     , (4)        ,       ,      (3)   ,     ,        . </li><li><img src="https://habrastorage.org/getpro/habr/post_images/21d/cca/63c/21dcca63cf5cfd7d0b36e6bdff94da1f.gif"><br><br> <b></b> <b>:</b>        â€”   ,  ,     ,    ,      .      U- ,      ,       ,       ,       .           .    ,           :          ,      ,       ,   .      ,             .     ,          . </li><li> <b><img src="https://habrastorage.org/getpro/habr/post_images/ce1/9b2/36c/ce19b236c5dd3f766d0c817aeb551bdc.gif"><br><br> :</b>         ,     .              ,      ,     .  -       ,       ,            ,  ,    . </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><b>3D</b></a> <b>:</b>           ,     ,          ,      . -         . </li><li><img src="https://habrastorage.org/getpro/habr/post_images/56a/89a/c01/56a89ac017b5faa694d3e15ab8d3948d.gif"><br><br> <b></b> <b>:</b>           ,          ,               .             (        ):     ,      ,       ,         .           ,  .    ,   ;    ,     .           ,      ,    . </li><li><img src="https://habrastorage.org/getpro/habr/post_images/47f/d14/6db/47fd146dba649e214e28a18207a7da89.gif"><br><br> <b>Crack</b> <b>:</b> Crack-         ,      ,     .  ,     ,     ,  Â«Â»        .   ,      ,    .  ,  -       . ,           ,             ;      .        ,       . </li><li><img src="https://habrastorage.org/getpro/habr/post_images/488/88c/28f/48888c28fd1c5ad3601c0dbb4e3716f6.gif"><br><br> <b></b> <b>:</b>     Â«Â»    ,           ,   . ,   -    : (1)  ,           . (2)     ,      ,    ,         ,    ,      (..      ). (3)     ,  ,     .            ,            . </li><li><img src="https://habrastorage.org/getpro/habr/post_images/7d0/844/5f9/7d08445f9ee145b6db8b844d70f9d21c.gif"><br><br> <b></b> <b>:</b>  â€”  3D-,       -,      ,  .   3D-       ,       ,    .           ,             ,         .         ,         .         ,     (   ),          ,          ,    . </li><li><img src="https://habrastorage.org/getpro/habr/post_images/ff3/d52/35d/ff3d5235d49cbe3a9d2a562033d73202.gif"><br><br> <b>Planair</b> <b>:</b> Planair-               ,         .     â€”       .      ,          . </li><li> <b><img src="https://habrastorage.org/getpro/habr/post_images/788/7d3/94f/7887d394fd2acf973c1dcfd4616dc09f.gif"><br><br> :</b> ,   , ,    -,      ,    ,     ,   .     ,     . ,   ,         ,    ,    ,          . </li></ul><br><h2>     </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Il existe de nombreuses faÃ§ons de crÃ©er des labyrinthes parfaits, et chacun d'eux a ses propres caractÃ©ristiques. </font><font style="vertical-align: inherit;">Voici une liste d'algorithmes spÃ©cifiques. </font><font style="vertical-align: inherit;">Tous dÃ©crivent la crÃ©ation d'un labyrinthe en dÃ©coupant des passages, cependant, sauf indication contraire, chacun peut Ã©galement Ãªtre mis en Å“uvre en ajoutant des murs:</font></font><br><br><ul><li><img src="https://habrastorage.org/getpro/habr/post_images/128/314/7ba/1283147bad2733851cdba5fb965b7530.gif"><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Backtracker rÃ©cursif </font></font></b> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font></b>   -      recursive backtracker,   ,       .       ,       ,       .  ,      ,     .        ,      .  ,       .         ,  ,   ,        .      ,       . Recursive backtracking      ,       ,    ,          . </li><li><img src="https://habrastorage.org/getpro/habr/post_images/7c3/316/387/7c3316387d28cf3b3ebdcd9caacef988.gif"><br><br> <b> </b> <b>:</b>  ,    .  ,     Â«Â»   ,          ,           .      ,   ,               (          ).     ,        .           ,             ,     .          ,      - ,    ,    .        ,    ,    .          ,            . ,             - (union-find algorithm):      ,    .       .        ,    -      . </li><li><img src="https://habrastorage.org/getpro/habr/post_images/7c3/316/387/7c3316387d28cf3b3ebdcd9caacef988.gif"><br><br>  <b>Algorithme de Prim (vrai)</b> <b>:</b> cet algorithme crÃ©e un arbre couvrant minimal en traitant des poids de bord alÃ©atoires uniques.  La quantitÃ© de mÃ©moire requise est proportionnelle Ã  la taille du labyrinthe.  Nous partons de n'importe quel sommet (le labyrinthe fini sera le mÃªme, peu importe le sommet que nous commenÃ§ons).  Nous sÃ©lectionnons le bord du passage avec le plus petit poids reliant le labyrinthe Ã  un point qui n'y est pas dÃ©jÃ , puis le fixons au labyrinthe.  Le labyrinthe est terminÃ© lorsque les bords en question ne sont plus laissÃ©s.  Pour sÃ©lectionner efficacement le bord suivant, vous avez besoin d'une file d'attente prioritaire (gÃ©nÃ©ralement implÃ©mentÃ©e Ã  l'aide d'un segment) qui stocke tous les bords de la bordure.  Cependant, cet algorithme est plutÃ´t lent car il faut du temps Ã  log (n) pour sÃ©lectionner des Ã©lÃ©ments dans le tas.  Par consÃ©quent, il est prÃ©fÃ©rable de prÃ©fÃ©rer l'algorithme Kraskal, qui crÃ©e Ã©galement un arbre couvrant minimal, car il est plus rapide et crÃ©e des labyrinthes avec une structure identique.  En fait, avec la mÃªme graine alÃ©atoire, les algorithmes Prima et Kraskal peuvent crÃ©er les mÃªmes labyrinthes. </li><li><img src="https://habrastorage.org/getpro/habr/post_images/fe7/700/d75/fe7700d7554d3456bb9f7c185b16dec1.gif"><br><br>  <b>Algorithme de Prim (simplifiÃ©)</b> <b>:</b> cet algorithme de Prim crÃ©e un arbre couvrant minimal.  Il est simplifiÃ© de telle sorte que tous les poids des bords sont les mÃªmes.  Il nÃ©cessite une capacitÃ© mÃ©moire proportionnelle Ã  la taille du labyrinthe.  Nous partons d'un pic alÃ©atoire.  Nous sÃ©lectionnons au hasard le bord du passage reliant le labyrinthe Ã  un point qui n'y est pas encore, puis nous le fixons au labyrinthe.  Le labyrinthe est terminÃ© lorsque les bords en question ne sont plus laissÃ©s.  Ã‰tant donnÃ© que les bords sont en apesanteur et non ordonnÃ©s, ils peuvent Ãªtre stockÃ©s sous forme de liste simple, c'est-Ã -dire que la sÃ©lection des Ã©lÃ©ments de la liste sera trÃ¨s rapide et prend un temps constant.  Par consÃ©quent, il est beaucoup plus rapide que le vÃ©ritable algorithme Prim avec des poids de bord alÃ©atoires.  La texture de labyrinthe crÃ©Ã©e aura un dÃ©bit plus faible et une solution plus simple que la vraie mÃ©thode Prim, car elle se propage uniformÃ©ment Ã  partir du point de dÃ©part, comme le sirop renversÃ©, et ne contourne pas les fragments de cÃ´tes avec un poids plus Ã©levÃ©, qui sont pris en compte plus tard. </li><li><img src="https://habrastorage.org/getpro/habr/post_images/95d/7bf/e0a/95d7bfe0ad94b47045e086ff12847b94.gif"><br><br>  <b>Algorithme de Prim (modifiÃ©)</b> <b>:</b> cet algorithme de Prim crÃ©e un arbre couvrant minimal, modifiÃ© de sorte que tous les poids des bords soient les mÃªmes.  Cependant, il est implÃ©mentÃ© de telle sorte qu'au lieu de bords, il regarde les cellules.  La quantitÃ© de mÃ©moire est proportionnelle Ã  la taille du labyrinthe.  Dans le processus de crÃ©ation, chaque cellule peut avoir l'un des trois types suivants: (1) Â«interneÂ»: la cellule fait partie du labyrinthe et y est dÃ©jÃ  dÃ©coupÃ©e, (2) Â«limiteÂ»: la cellule ne fait pas partie du labyrinthe et n'y a pas encore Ã©tÃ© dÃ©coupÃ©e, mais est situÃ©e Ã  cÃ´tÃ© de la cellule qui est dÃ©jÃ  "interne", et (3) "externe": la cellule ne fait pas encore partie du labyrinthe, et aucun de ses voisins n'est Ã©galement la cellule "interne".  Nous commenÃ§ons par choisir une cellule, la rendons Â«interneÂ», et pour tous ses voisins, nous dÃ©finissons le type sur Â«limiteÂ».  Nous sÃ©lectionnons au hasard la cellule Â«limiteÂ» et y coupons un passage d'une des cellules Â«internesÂ» voisines.  Nous changeons l'Ã©tat de cette cellule Â«limiteÂ» en Â«interneÂ» et changeons le type de tous ses voisins de Â«externeÂ» en Â«frontiÃ¨reÂ».  Le labyrinthe est achevÃ© lorsqu'il ne reste plus de cellules Â«limitesÂ» (c'est-Ã -dire qu'il n'y a plus de cellules Â«externesÂ», ce qui signifie que tout le monde est devenu Â«interneÂ»).  Cet algorithme crÃ©e des labyrinthes avec un indice de rendement trÃ¨s faible, a de nombreux blocages courts et une solution plutÃ´t simple.  Le labyrinthe rÃ©sultant est trÃ¨s similaire au rÃ©sultat de la mÃ©thode simplifiÃ©e de Prim, avec une lÃ©gÃ¨re diffÃ©rence: les vides dans l'arbre couvrant ne sont remplis que si une cellule limite est sÃ©lectionnÃ©e au hasard, contrairement Ã  la triple probabilitÃ© de remplir cette cellule par l'une des cellules limites qui y mÃ¨nent.  De plus, l'algorithme est trÃ¨s rapide, plus rapide que l'algorithme Prim simplifiÃ©, car il n'a pas besoin de compiler et de traiter la liste des arÃªtes. </li><li><img src="https://habrastorage.org/getpro/habr/post_images/8a9/d2b/0c6/8a9d2b0c60f1c65e96bac07fd947c565.gif"><br><br>  Algorithme d' <b>Aldous-Broder</b> : ce qui est intÃ©ressant dans cet algorithme, c'est qu'il est homogÃ¨ne, c'est-Ã -dire qu'il crÃ©e avec une probabilitÃ© Ã©gale tous les labyrinthes possibles d'une taille donnÃ©e.  De plus, il ne nÃ©cessite ni mÃ©moire supplÃ©mentaire ni pile.  Nous sÃ©lectionnons un point et nous nous dÃ©plaÃ§ons au hasard vers une cellule voisine.  Si nous entrons dans une cellule non coupÃ©e, dÃ©coupez ensuite le passage de la cellule prÃ©cÃ©dente.  Nous continuons Ã  nous dÃ©placer vers les cellules voisines jusqu'Ã  ce que nous coupions les passages Ã  toutes les cellules.  Cet algorithme crÃ©e des labyrinthes avec un faible dÃ©bit, seulement lÃ©gÃ¨rement supÃ©rieur Ã  l'algorithme de Kraskal.  (Cela signifie que pour un Ã©change donnÃ©, il y a plus de labyrinthes avec un indice de rendement faible qu'avec des indices Ã©levÃ©s, car le labyrinthe avec une probabilitÃ© moyenne est Ã©galement faible.) La mauvaise chose Ã  propos de cet algorithme est qu'il est trÃ¨s lent car il n'effectue pas de recherche intellectuelle pour ce dernier cellules, c'est-Ã -dire, en fait, n'a pas de garanties d'achÃ¨vement.  Cependant, en raison de sa simplicitÃ©, il peut rapidement parcourir de nombreuses cellules, il se termine donc plus rapidement que vous ne le pensez.  En moyenne, cela prend sept fois plus de temps que les algorithmes standard, bien que dans les mauvais cas, cela puisse Ãªtre beaucoup plus long si le gÃ©nÃ©rateur de nombres alÃ©atoires Ã©vite constamment les derniÃ¨res cellules.  Il peut Ãªtre implÃ©mentÃ© comme l'ajout de murs, si le mur de bordure est considÃ©rÃ© comme un seul sommet, c'est-Ã -dire, par exemple, si le mouvement nous dÃ©place vers le mur de frontiÃ¨re, nous nous tÃ©lÃ©portons Ã  un point alÃ©atoire le long de la frontiÃ¨re, et ensuite nous continuons Ã  bouger.  Dans le cas de l'ajout de murs, cela fonctionne presque deux fois plus vite, car la tÃ©lÃ©portation le long du mur frontalier permet un accÃ¨s plus rapide aux parties Ã©loignÃ©es du labyrinthe. </li><li><img src="https://habrastorage.org/getpro/habr/post_images/8a9/d2b/0c6/8a9d2b0c60f1c65e96bac07fd947c565.gif"><br><br>  <b>Algorithme de Wilson</b> <b>:</b> il s'agit d'une version amÃ©liorÃ©e de l'algorithme Aldous-Broder, il crÃ©e des labyrinthes avec exactement la mÃªme texture (les algorithmes sont homogÃ¨nes, c'est-Ã -dire que tous les labyrinthes possibles sont gÃ©nÃ©rÃ©s avec une probabilitÃ© Ã©gale), mais l'algorithme Wilson est beaucoup plus rapide.  Il prend de la mÃ©moire jusqu'Ã  la taille du labyrinthe.  Nous commenÃ§ons avec une cellule de labyrinthe initiale choisie au hasard.  Nous sÃ©lectionnons une cellule alÃ©atoire qui ne fait pas encore partie du labyrinthe et effectuons une marche alÃ©atoire jusqu'Ã  ce que nous trouvions une cellule qui appartient dÃ©jÃ  au labyrinthe.  DÃ¨s que nous tombons sur la partie dÃ©jÃ  crÃ©Ã©e du labyrinthe, nous retournons Ã  la cellule alÃ©atoire sÃ©lectionnÃ©e et coupons tout le chemin effectuÃ© en ajoutant ces cellules au labyrinthe.  Plus prÃ©cisÃ©ment, lorsque nous revenons le long du chemin, nous coupons dans chaque cellule dans la direction dans laquelle la marche alÃ©atoire a eu lieu la derniÃ¨re fois que nous avons quittÃ© la cellule.  Cela Ã©vite l'apparition de boucles le long du chemin de retour, de sorte qu'un long passage rejoint le labyrinthe.  Le labyrinthe est terminÃ© lorsque toutes les cellules y sont attachÃ©es.  L'algorithme a les mÃªmes problÃ¨mes de vitesse que Aldous-Broder, car il peut prendre beaucoup de temps pour trouver le premier chemin alÃ©atoire vers la cellule initiale, mais aprÃ¨s avoir placÃ© plusieurs chemins, le reste du labyrinthe est dÃ©coupÃ© assez rapidement.  En moyenne, il fonctionne cinq fois plus vite qu'Aldous-Broder, et moins de deux fois plus lentement que les meilleurs algorithmes.  Il convient de noter que dans le cas de l'ajout de murs, cela fonctionne deux fois plus vite, car tout le mur de bordure fait initialement partie du labyrinthe, de sorte que les premiers murs se rejoignent beaucoup plus rapidement. </li><li><img src="https://habrastorage.org/getpro/habr/post_images/912/5a5/0b6/9125a50b62f3da5c999aa65dc144bc4a.gif"><br><br>  Algorithme de <b>chasse et de destruction</b> <b>:</b> cet algorithme est pratique car il ne nÃ©cessite pas de mÃ©moire supplÃ©mentaire ou une pile, et convient donc Ã  la crÃ©ation d'Ã©normes labyrinthes ou labyrinthes sur des ordinateurs faibles en raison de l'impossibilitÃ© de manquer de mÃ©moire.  Comme il n'a pas de rÃ¨gles Ã  suivre en permanence, il est Ã©galement plus facile de modifier et de crÃ©er des labyrinthes avec diffÃ©rentes textures en l'utilisant.  Il est presque similaire Ã  un backtracker rÃ©cursif, mais il n'y a pas de cellule non crÃ©Ã©e prÃ¨s de la position actuelle.  On passe en mode Â«chasseÂ» et on scrute systÃ©matiquement le labyrinthe jusqu'Ã  trouver une cellule non crÃ©Ã©e Ã  cÃ´tÃ© de la cellule dÃ©jÃ  coupÃ©e.  Ã€ ce stade, nous recommenÃ§ons Ã  couper dans ce nouvel emplacement.  Le labyrinthe est terminÃ© quand en mode Â«chasseÂ» toutes les cellules sont scannÃ©es.  Cet algorithme a tendance Ã  crÃ©er des labyrinthes avec un dÃ©bit Ã©levÃ©, mais pas aussi Ã©levÃ© que le backtracker rÃ©cursif.  Vous pouvez le forcer Ã  gÃ©nÃ©rer des labyrinthes avec un dÃ©bit plus faible, en entrant plus souvent en mode "chasse".  Il s'exÃ©cute plus lentement en raison du temps passÃ© Ã  rechercher les derniÃ¨res cellules, mais pas beaucoup plus lentement que l'algorithme de Kraskal.  Il peut Ãªtre implÃ©mentÃ© selon le principe de l'ajout de murs, si vous vous tÃ©lÃ©portez occasionnellement au hasard pour Ã©viter les problÃ¨mes inhÃ©rents Ã  un backtracker rÃ©cursif. </li><li><img src="https://habrastorage.org/getpro/habr/post_images/823/3be/623/8233be62330af193c9f7a6ff63841cca.gif"><br><br>  <b>Algorithme croissant</b> <b><br></b>  <b>arbre (algorithme d'arbre en croissance)</b> <b>:</b> il s'agit d'un algorithme gÃ©nÃ©ralisÃ© qui peut crÃ©er des labyrinthes avec diffÃ©rentes textures.  La mÃ©moire requise peut atteindre la taille du labyrinthe.  Chaque fois qu'une cellule est coupÃ©e, nous l'ajoutons Ã  la liste.  SÃ©lectionnez une cellule dans la liste et dÃ©coupez le passage vers la cellule non crÃ©Ã©e Ã  cÃ´tÃ© d'elle.  S'il n'y a pas de cellules non crÃ©Ã©es Ã  proximitÃ© de la cellule actuelle, supprimez la cellule actuelle de la liste.  Le labyrinthe est terminÃ© lorsqu'il n'y a rien d'autre dans la liste.  La chose intÃ©ressante Ã  propos de l'algorithme est que, selon la faÃ§on dont vous sÃ©lectionnez une cellule dans la liste, vous pouvez crÃ©er de nombreuses textures diffÃ©rentes.  Par exemple, si vous sÃ©lectionnez toujours la derniÃ¨re cellule ajoutÃ©e, cet algorithme se transforme en backtracker rÃ©cursif.  Si vous sÃ©lectionnez toujours des cellules au hasard, il se comporte de la mÃªme maniÃ¨re, mais pas de maniÃ¨re identique Ã  l'algorithme Prim.  Si vous sÃ©lectionnez toujours les cellules les plus anciennes ajoutÃ©es Ã  la liste, nous crÃ©erons un labyrinthe avec l'indice de rendement le plus bas possible, mÃªme infÃ©rieur Ã  celui de l'algorithme Prim.  Si vous choisissez gÃ©nÃ©ralement la toute derniÃ¨re cellule, mais que vous choisissez parfois une cellule alÃ©atoire, le labyrinthe aura un dÃ©bit Ã©levÃ©, mais une solution courte et directe.  Si l'une des cellules les plus rÃ©centes est sÃ©lectionnÃ©e au hasard, le labyrinthe aura un faible dÃ©bit, mais une solution longue et sinueuse. </li><li><img src="https://habrastorage.org/getpro/habr/post_images/3ee/6d6/3d0/3ee6d63d01f5e26e2f1c8b4a0f1e10e2.gif"><br><br>  <b>Algorithme de forÃªt en croissance</b> <b>:</b> il s'agit d'un algorithme plus gÃ©nÃ©ralisÃ© combinant des types basÃ©s sur des arbres et des ensembles.  Il s'agit d'une extension de l'algorithme de croissance arborescente, qui comprend essentiellement plusieurs instances se dÃ©veloppant simultanÃ©ment.  Nous commenÃ§ons avec toutes les cellules triÃ©es alÃ©atoirement dans une liste de "nouvelles";  en outre, chaque cellule a son propre ensemble, comme au dÃ©but de l'algorithme Kruskal.  SÃ©lectionnez d'abord une ou plusieurs cellules en les dÃ©plaÃ§ant de la liste des Â«nouvellesÂ» vers la liste des Â«activesÂ».  SÃ©lectionnez une cellule dans la liste "active" et dÃ©coupez le passage Ã  la cellule non crÃ©Ã©e suivante dans la liste "nouvelle", en ajoutant une nouvelle cellule Ã  la liste des "actifs" et en combinant les ensembles de deux cellules.  Si une tentative est faite pour couper dans la partie existante du labyrinthe, activez-la si les cellules sont dans des ensembles diffÃ©rents et combinez les cellules, comme cela se fait dans l'algorithme de Kraskal.  S'il n'y a pas de Â«nouvellesÂ» cellules prÃ¨s de la cellule actuelle, dÃ©placez la cellule actuelle vers la liste des cellules Â«terminÃ©esÂ».  Le labyrinthe est terminÃ© lorsque la liste des "actifs" devient vide.  Ã€ la fin, nous combinons tous les ensembles restants, comme dans l'algorithme de Kruskal.  PÃ©riodiquement, vous pouvez crÃ©er de nouveaux arbres en dÃ©plaÃ§ant une ou plusieurs cellules de la liste des "nouveaux" vers la liste des "actifs", comme cela a Ã©tÃ© fait au dÃ©but.  En contrÃ´lant le nombre d'arbres d'origine et les parts des arbres nouvellement crÃ©Ã©s, vous pouvez gÃ©nÃ©rer de nombreuses textures uniques qui se combinent avec les paramÃ¨tres dÃ©jÃ  flexibles de l'algorithme de croissance des arbres. </li><li><img src="https://habrastorage.org/getpro/habr/post_images/0df/4b2/2af/0df4b22af0d9c528721505c5863baa81.gif"><br><br>  <b>Algorithme d'Eller</b> <b>:</b> il s'agit d'un algorithme spÃ©cial, car il est non seulement plus rapide que tout le monde, mais n'a pas non plus de biais ou de lacunes Ã©vidents;  en outre, lors de sa crÃ©ation, la mÃ©moire est utilisÃ©e plus efficacement.  Il ne nÃ©cessite mÃªme pas que tout le labyrinthe soit en mÃ©moire, il utilise un volume proportionnel Ã  la taille de la ligne.  Il crÃ©e un labyrinthe ligne par ligne, une fois la gÃ©nÃ©ration de la chaÃ®ne terminÃ©e, l'algorithme n'en tient plus compte.  Chaque cellule d'une rangÃ©e est contenue dans un ensemble;  deux cellules appartiennent au mÃªme ensemble s'il y a un chemin entre elles le long du labyrinthe dÃ©jÃ  crÃ©Ã©.  Ces informations vous permettent de dÃ©couper des passages dans la ligne actuelle sans crÃ©er de boucles ou de zones isolÃ©es.  En fait, il est assez similaire Ã  l'algorithme de Kraskal, seulement ici il est formÃ© une ligne Ã  la fois, tandis que Kraskal regarde Ã  travers tout le labyrinthe.  La crÃ©ation d'une ligne se compose de deux parties: connectez de maniÃ¨re alÃ©atoire les cellules adjacentes de la ligne, c'est-Ã -dire  nous coupons les passages horizontaux, puis connectons au hasard les cellules entre la ligne actuelle et la ligne suivante, c'est-Ã -dire  dÃ©coupez les passages verticaux.  Lors de la dÃ©coupe de passages horizontaux, nous ne connectons pas les cellules qui sont dÃ©jÃ  dans le mÃªme ensemble (car une boucle sera crÃ©Ã©e autrement), et lors de la dÃ©coupe de passages verticaux, nous devons connecter une cellule si elle a une taille d'unitÃ© (car si vous la laissez, cela crÃ©era une zone isolÃ©e).  Lors de la dÃ©coupe de passages horizontaux, nous connectons les cellules si elles sont dans le mÃªme ensemble (car maintenant il y a un chemin entre elles), et lors de la dÃ©coupe des passages verticaux lorsque nous ne nous connectons pas avec la cellule, nous le mettons dans un ensemble sÃ©parÃ© (car maintenant il est sÃ©parÃ© du reste du labyrinthe) )  La crÃ©ation commence par le fait qu'avant de connecter les cellules de la premiÃ¨re ligne, chaque cellule a son propre ensemble.  La crÃ©ation est terminÃ©e une fois les cellules connectÃ©es dans la derniÃ¨re ligne.  Il existe une rÃ¨gle spÃ©ciale d'achÃ¨vement: au moment de l'achÃ¨vement, chaque cellule doit Ãªtre dans le mÃªme ensemble afin d'Ã©viter les zones isolÃ©es.  (La derniÃ¨re ligne est crÃ©Ã©e en combinant chacune des paires de cellules voisines qui ne sont pas encore dans le mÃªme ensemble.) Il est prÃ©fÃ©rable d'implÃ©menter l'ensemble en utilisant une liste cyclique de cellules doublement liÃ©es (qui peut Ãªtre juste un tableau qui lie des cellules Ã  des paires de cellules des deux cÃ´tÃ©s du mÃªme ensemble), permettant effectuer l'insertion, la suppression et la vÃ©rification de la prÃ©sence de cellules voisines dans un ensemble pendant un temps constant.  Le problÃ¨me avec cet algorithme est le dÃ©sÃ©quilibre dans le traitement des diffÃ©rents bords du labyrinthe;  Pour Ã©viter les taches dans les textures, vous devez connecter et ignorer les cellules de connexion dans les bonnes proportions. </li><li> <b><img src="https://habrastorage.org/getpro/habr/post_images/50c/8cc/ddc/50c8ccddc7242a00cf9dd62fba696ed2.gif"><br><br></b>  <b>Division rÃ©cursive:</b> cet algorithme est quelque peu similaire au backtracking rÃ©cursif, car ils utilisent tous deux des piles, seulement il ne fonctionne pas avec les allÃ©es, mais avec les murs.  Nous commenÃ§ons par crÃ©er un mur horizontal ou vertical alÃ©atoire qui intersecte une zone accessible dans une ligne ou une colonne alÃ©atoire, et placons au hasard des espaces vides le long de celle-ci.  Ensuite, nous rÃ©pÃ©tons rÃ©cursivement le processus pour les deux sous-rÃ©gions gÃ©nÃ©rÃ©es par le mur de sÃ©paration.  Pour de meilleurs rÃ©sultats, vous devez ajouter une dÃ©viation dans le choix de l'horizontale ou de la verticale en fonction des proportions de la zone, par exemple, une zone dont la largeur est le double de la hauteur doit Ãªtre plus souvent divisÃ©e par des murs verticaux.  C'est l'algorithme le plus rapide sans dÃ©viation de direction, et souvent il peut mÃªme rivaliser avec des labyrinthes basÃ©s sur des arbres binaires, car il crÃ©e plusieurs cellules en mÃªme temps, bien qu'il prÃ©sente un inconvÃ©nient Ã©vident sous la forme de longues parois coupant l'intÃ©rieur du labyrinthe.  Cet algorithme est une sorte de labyrinthe fractal intÃ©grÃ©, mais au lieu de crÃ©er constamment des labyrinthes de cellules de taille fixe avec des labyrinthes de mÃªme taille Ã  l'intÃ©rieur de chaque cellule, il divise au hasard une zone donnÃ©e en un labyrinthe de taille alÃ©atoire: 1x2 ou 2x1.  La division rÃ©cursive ne peut pas Ãªtre utilisÃ©e pour dÃ©couper des passages, car cela conduit Ã  la crÃ©ation d'une solution Ã©vidente qui suit le long du bord extÃ©rieur ou intersecte directement l'intÃ©rieur. </li><li><img src="https://habrastorage.org/getpro/habr/post_images/d01/81f/8a0/d0181f8a04730302dbe6d88d0dc91431.gif"><br><br>  <b>Labyrinthes basÃ©s sur des arbres binaires</b> <b>:</b> en fait, ce sont les algorithmes les plus simples et les plus rapides possibles, cependant, les labyrinthes crÃ©Ã©s ont une texture avec un biais trÃ¨s Ã©levÃ©.  Pour chaque cellule, nous coupons un passage vers le haut ou vers la gauche, mais jamais dans les deux sens.  Dans la version avec ajout de murs, un segment de mur est ajoutÃ© pour chaque sommet menant vers le bas ou vers la droite, mais pas dans les deux directions.  Chaque cellule est indÃ©pendante de toutes les autres cellules, car nous n'avons pas besoin de vÃ©rifier l'Ã©tat de certaines autres cellules lors de sa crÃ©ation.  Il s'agit donc d'un vÃ©ritable algorithme de gÃ©nÃ©ration de labyrinthes sans mÃ©moire, non limitÃ© par la taille des labyrinthes crÃ©Ã©s.  En fait, il s'agit d'un arbre binaire, si nous considÃ©rons le coin supÃ©rieur gauche comme une racine, et chaque nÅ“ud ou cellule a un nÅ“ud parent unique, qui est une cellule au-dessus ou Ã  gauche de celui-ci.  Les labyrinthes basÃ©s sur des arbres binaires sont diffÃ©rents des labyrinthes idÃ©aux standard, car plus de la moitiÃ© des types de cellules ne peuvent pas exister en eux.  Par exemple, il n'y aura jamais d'intersections et toutes les impasses ont des passages menant vers le haut ou vers la gauche, et ne menant jamais vers le bas ou vers la droite.  Les labyrinthes ont tendance Ã  avoir des passages menant en diagonale du coin supÃ©rieur gauche au coin infÃ©rieur droit, et il est beaucoup plus facile de se dÃ©placer du coin infÃ©rieur droit au coin supÃ©rieur gauche.  Vous pouvez toujours vous dÃ©placer vers le haut ou vers la gauche, mais jamais simultanÃ©ment dans les deux sens, vous pouvez donc toujours vous dÃ©placer de maniÃ¨re dÃ©terministe en diagonale vers le haut et vers la gauche, sans rencontrer d'obstacles.  Vous aurez la possibilitÃ© de choisir et de tomber dans des impasses en vous dÃ©plaÃ§ant vers le bas et vers la droite. ,            ,  ,        . </li><li> <b><img src="https://habrastorage.org/getpro/habr/post_images/f3f/f8c/58c/f3ff8c58c53fce1c8d57401f7f41c924.gif"><br><br>  Sidewinder:</b>         ,    .       :      ,    ,  .    ,   ,      ,       ,  ,   .           ,     (    ,      ).                ,  sidewinder     .              ,    sidewinder        .     ,  sidewinder        ,          ,  .   sidewinder            ,   Â«    Â».   ,       sidewinder â€”      ,      ,   ,  ,    .  sidewinder     ,       ,         ,   . </li></ul><br><table><tbody><tr><td> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Algorithme</font></font></b> </td><td> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">% impasses</font></font></b> </td><td> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tapez</font></font></b> </td><td> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PrioritÃ©</font></font></b> </td><td> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pas de parti pris?</font></font></b> </td><td> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">HomogÃ¨ne?</font></font></b> </td><td> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La mÃ©moire</font></font></b> </td><td> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le temps</font></font></b> </td><td> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">% solution</font></font></b> </td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ItinÃ©raire unique </font></font></td><td>  0 </td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Arbre </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Les murs </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Oui </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Jamais </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> N ^ 2 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 379 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 100,0 </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Backtracker rÃ©cursif </font></font></td><td>  10 </td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Arbre </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Passerelles </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Oui </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Jamais </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> N ^ 2 </font></font></td><td>  27 </td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 19,0 </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Chasser et tuer </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 11 (21) </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Arbre </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Passerelles </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Oui </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Jamais </font></font></td><td>  0 </td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 100 (143) </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 9,5 (3,9) </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Division rÃ©cursive </font></font></td><td>  23 </td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Arbre </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Les murs </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Oui </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Jamais </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> N * </font></font></td><td>  10 </td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 7.2 </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Arbre binaire </font></font></td><td>  25 </td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Beaucoup </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Les deux </font></font></td><td>  Non </td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Jamais </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0 * </font></font></td><td>  10 </td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 2.0 </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Sidewinder </font></font></td><td>  27 </td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Beaucoup </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Les deux </font></font></td><td>  Non </td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Jamais </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0 * </font></font></td><td>  12 </td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 2.6 </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Algorithme Eller </font></font></td><td>  28 </td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Beaucoup </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Les deux </font></font></td><td>  Non </td><td>  Non </td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> N * </font></font></td><td>  20 </td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 4,2 (3,2) </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Algorithme de Wilson </font></font></td><td>  29 </td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Arbre </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Les deux </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Oui </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Oui </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> N ^ 2 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 48 (25) </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 4.5 </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Algorithme Aldous-Broder </font></font></td><td>  29 </td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Arbre </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Les deux </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Oui </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Oui </font></font></td><td>  0 </td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 279 (208) </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 4.5 </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Algorithme de Kraskal </font></font></td><td>  30 </td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Beaucoup </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Les deux </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Oui </font></font></td><td>  Non </td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> N ^ 2 </font></font></td><td>  33 </td><td>  4.1 </td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Algorithme Prima (vrai) </font></font></td><td>  30 </td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Arbre </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Les deux </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Oui </font></font></td><td>  Non </td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> N ^ 2 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 160 </font></font></td><td>  4.1 </td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Algorithme Prima (simplifiÃ©) </font></font></td><td>  32 </td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Arbre </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Les deux </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Oui </font></font></td><td>  Non </td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> N ^ 2 </font></font></td><td>  59 </td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 2.3 </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Algorithme Prima (modifiÃ©) </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 36 (31) </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Arbre </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Les deux </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Oui </font></font></td><td>  Non </td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> N ^ 2 </font></font></td><td>  30 </td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 2.3 </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> La croissance des arbres </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 49 (39) </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Arbre </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Les deux </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Oui </font></font></td><td>  Non </td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> N ^ 2 </font></font></td><td>  48 </td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 11,0 </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Croissance des forÃªts </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 49 (39) </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Les deux </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Les deux </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Oui </font></font></td><td>  Non </td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> N ^ 2 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 76 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 11,0 </font></font></td></tr></tbody></table><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ce tableau rÃ©sume les caractÃ©ristiques des algorithmes de crÃ©ation de labyrinthes idÃ©aux dÃ©crits ci-dessus. </font><font style="vertical-align: inherit;">Ã€ titre de comparaison, un algorithme de labyrinthe Ã  itinÃ©raire unique a Ã©tÃ© ajoutÃ© (thÃ©oriquement, les labyrinthes Ã  itinÃ©raire unique sont idÃ©aux). </font><font style="vertical-align: inherit;">Explication de la colonne:</font></font><br><br><ul><li> <b>:</b>    ,    ,     ,    2D-.       .       ,     ,     ,        .           10% (     )  49% (    ).        Recursive Backtracker    1%.           66%:              . </li><li> <b>:</b>       :        ,    ,           .       ,   ,   ,    ,           .  ,    ,    . </li><li> <b>:</b>        ,    .          .       ,           ,       . Recursive Backtracker     ,          ,    ,          . ,        ,       .  , Hunt and Kill          ,        ,            . </li><li> <b> :</b>          ,          .     ,           . Sidewinder  ,           .      ,      .  Hunt and Kill  ,      ,     ,       . </li><li> <b>:</b>         . Â«Â» ,    . Â«Â» ,            ,     . Â«Â» ,    ,      . ,           . </li><li> <b>:</b>     ,    .        ,        ,    (N),     (N^2).          ,        (   ).        ,     ,        .  Sidewinder       ,           .          ,         . </li><li> <b>:</b>      ,          ,   ,    .      ,       (     10),          .         100x100    Daedalus.         ,     ,     ,       . </li><li> <b>:</b>    ,        ,  .  ,     100x100 .        .     Â«Â»  .     ,       .      ,                  .        ,    ,     ,         . </li></ul><br><h2>    </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Il existe de nombreuses faÃ§ons de rÃ©soudre des labyrinthes, et chacun d'eux a ses propres caractÃ©ristiques. </font><font style="vertical-align: inherit;">Voici une liste d'algorithmes spÃ©cifiques:</font></font><br><br><ul><li><img src="https://habrastorage.org/getpro/habr/post_images/62b/7f0/7c6/62b7f07c68ae7a9544c6ad481577e816.gif"><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Suivre le long des murs (suiveur de mur) </font></font></b> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font></b>     .        (Â«Â»),         .            (  ).        ,      ( )           .         ,  .       ,    ,   .      ,     ,           ,             .     3D-    ,  3D-  2D-, .. ,          -,      -,        . </li><li><img src="https://habrastorage.org/getpro/habr/post_images/d5b/25c/4de/d5b25c4de2e848708f6f9ba70a47957f.gif"><br><br> <b> </b> <b>:</b>      ,    Â«Â»    ,      .          2D-    ,       , ..    .           ,        ,         .            .   ,    ,        .  ,         ,    .       ,             ,   .        , ,   â€”  -1,    â€”  1.            ,      , ..     360   ,        Â«Â».  ,         Â«Â»,      ,        ,      ,      ,         .  ,             ,           .      ,    â€”    ,              . </li><li><img src="https://habrastorage.org/getpro/habr/post_images/885/45e/39a/88545e39a856cc77b791086ebc958e0c.gif"><br><br> <b> </b> <b>:</b>   (Chain algorithm)  ,        (  )     .        ,         ,   .       ,    .  ,      ,      .      ,              .      (     )    ,      .         .     ,      ,    .      Â«Â»      ,   .          ,     ,       ,      .       ,    .          ,         . </li><li> <b><img src="https://habrastorage.org/getpro/habr/post_images/402/cba/ed2/402cbaed27df8e2319b04647f963dc2e.gif"><br><br> Recursive backtracker:</b>    ,     .       ,              .   :      (    ),   Â«Â», ,     ,  Â«Â», ,       .  ,         ,    Â«Â»;    Â«Â»       .    (backtracking)       ,      ,    .  ,       .     ,   ,      . </li><li> <b><img src="https://habrastorage.org/getpro/habr/post_images/965/84c/528/96584c52805bc66d81e23eeae05b2057.gif"><br><br>   (TrÃ©maux's algorithm):</b>          .    recursive backtracker      :         ,   .           ,  .   ,     ,     .          ,   ,         ,  . (     ,           .)    ,     (..  ),    ,     ,   ,       (.. ,    ).     ,       ,   ,        ,   ,             .     ,            .     ,     ,      . </li><li><img src="https://habrastorage.org/getpro/habr/post_images/949/1f9/5b9/9491f95b97951ee9f10551bb24187e94.gif"><br><br> <b>  (Dead end filler)</b> <b>:</b>     .     ,         .        ,       ,    .         ,        .       ,   ,      .         ,         ,           . </li><li><img src="https://habrastorage.org/getpro/habr/post_images/af6/640/839/af6640839e35705adb99b781278d56a9.gif"><br><br> <b>Cul-de-sac filler</b> <b>:</b>         ,     ,         .    dead end filler,    ,        .        (  â€”   ,           ,      )  ,       .    dead end filler.     ,    ,       ,     ,       .       ,   ,     ,   dead end filler. </li><li><img src="https://habrastorage.org/getpro/habr/post_images/a01/d27/475/a01d27475d474454f478264e022e0383.gif"><br><br> <b>Blind alley filler</b> <b>:</b>      ,    ,     .   ,    .   â€”   ,      ,             .     ,    ,    cul-de-sac filler,      .       .    ,    , ,  ,  .            ,   ,  ,          (           ).   ,             ,          .      ,   cul-de-sac filler  - ,     collision solver    ,      - . </li><li><img src="https://habrastorage.org/getpro/habr/post_images/105/ade/5a7/105ade5a7dd7cbce67bcbd57d3ba3b7e.gif"><br><br> <b>Blind alley sealer</b> <b>:</b>     blind alley filler ,       ,     .                 .               .     ,   ,  blind alley filler,     .         .   ,    ,     ,        ,        .  ,      ,     .          ,     .      ,          ,   .  ,               ,    . </li><li> <b><img src="https://habrastorage.org/getpro/habr/post_images/5e2/562/508/5e25625080da8af3396476127a2cc9ed.gif"><br><br>    (Shortest path finder):</b>     ,     ,        .        ,           ,   .   collision solver, ,  ,   Â«Â» ,          (      ),   Â«Â»  , ,     .      Â«Â»,       ,     .        ,             -    ,    .  ,  ,  ,    A*  ,       . </li><li><img src="https://habrastorage.org/getpro/habr/post_images/396/221/e2e/396221e2ed8b51be85c22fc94f5610db.gif"><br><br> <b>   (Shortest paths finder)</b> <b>:</b>       ,     .     ,        ,     ,   ,   ,       ,    ,     -     ,    .  ,     ,     ,   Â«Â» ,         ,     ,      .         ,   ,       ,      ,    .         ,                  . </li><li> <b>Collision solver:</b>   "amoeba" solver.      .        ,                        .    Â«Â» ,          (  ).   Â« Â»       (   ),       ,   .      Â«Â»,     ,       ,   ,     . ( ,    Â«Â»,     .   ,      ,         ,    .)  ,   shortest paths finder,     (           )    (         ). </li><li> <b>Random mouse:</b>       ,       , ..            ,      .       180 ,     .    ,       ,    .         ,           ,          . </li></ul><br><table><tbody><tr><td> <b></b> </td><td> <b></b> </td><td> <b>?</b> </td><td> <b></b> </td><td> <b> ?</b> </td><td> <b>  ?</b> </td><td> <b>  ?</b> </td><td> <b>?</b> </td></tr><tr><td> Random Mouse </td><td>  1 </td><td>  Non </td><td>  Tu es </td><td>  /  </td><td>  Non </td><td>  </td><td>  Non </td></tr><tr><td> Wall Follower </td><td>  1 </td><td>  Non </td><td>  Tu es </td><td>  /  </td><td>  </td><td>  </td><td>  </td></tr><tr><td>   </td><td>  1 </td><td>  Non </td><td>  Tu es </td><td>  /  </td><td>  </td><td>  </td><td>  </td></tr><tr><td>   </td><td>  1 </td><td>  </td><td> + </td><td>  Non </td><td>  </td><td>  Non </td><td>  </td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Backtracker rÃ©cursif </font></font></td><td>  1 </td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Oui </font></font></td><td>  Tu es </td><td>  Non </td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Oui </font></font></td><td>  Non </td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Oui </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Algorithme Tremo </font></font></td><td>  1 </td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Oui </font></font></td><td>  Tu es </td><td> Ã€ l'intÃ©rieur / sur </td><td>  Non </td><td>  Non </td><td>  Oui </td></tr><tr><td>  Remplisseur de cul-de-sac </td><td>  Tous + </td><td>  Non </td><td>  Labyrinthe </td><td>  Plus </td><td>  Non </td><td>  Oui </td><td>  Oui </td></tr><tr><td>  Remplisseuse cul-de-sac </td><td>  Tous + </td><td>  Non </td><td>  Labyrinthe </td><td>  Plus </td><td>  Non </td><td>  Oui </td><td>  Oui </td></tr><tr><td>  Scellant pour allÃ©es aveugles </td><td>  Tous + </td><td>  Oui </td><td>  Labyrinthe </td><td>  Non </td><td>  Non </td><td>  Non </td><td>  Oui </td></tr><tr><td>  Remplisseur de ruelle aveugle </td><td>  Tous </td><td>  Oui </td><td>  Labyrinthe </td><td>  Plus </td><td>  Non </td><td>  Oui </td><td>  Non </td></tr><tr><td>  Solveur de collision </td><td>  Tout court </td><td>  Oui </td><td>  Vous + </td><td>  Non </td><td>  Non </td><td>  Non </td><td>  Oui </td></tr><tr><td>  Rechercher les chemins les plus courts </td><td>  Tout court </td><td>  Oui </td><td>  Vous + </td><td>  Non </td><td>  Oui </td><td>  Non </td><td>  Oui </td></tr><tr><td>  Rechercher le chemin le plus court </td><td>  1 plus court </td><td>  Oui </td><td>  Vous + </td><td>  Non </td><td>  Oui </td><td>  Non </td><td>  Oui </td></tr></tbody></table><br>  Ce tableau rÃ©pertorie briÃ¨vement les caractÃ©ristiques des algorithmes de rÃ©solution de labyrinthe dÃ©crits ci-dessus.  Selon ces critÃ¨res, il est possible de classer et d'Ã©valuer des algorithmes de rÃ©solution de labyrinthes.  Explications des colonnes: <br><br><ul><li>  <b>Solutions:</b> dÃ©crit les solutions trouvÃ©es par l'algorithme et les actions de l'algorithme, s'il y en a plusieurs.  L'algorithme peut choisir une solution ou en laisser plusieurs.  De plus, la ou les solutions peuvent Ãªtre n'importe quel chemin ou le chemin le plus court.  Le remplissage en cul-de-sac et le cul-de-sac (ainsi que le scellant pour allÃ©e aveugle lors du traitement de ses zones inaccessibles) laissent toutes les solutions, mais ils peuvent Ã©galement laisser des passages qui ne se trouvent dans aucun des chemins de solution, je les ai donc marquÃ©s comme Â«Tous + ". </li><li>  <b>Garantie:</b> L'algorithme est-il garanti pour trouver au moins une solution?  Pour la souris alÃ©atoire, Â«nonÂ» est indiquÃ©, car son achÃ¨vement n'est pas garanti, et pour le suiveur de mur et l'algorithme du CollÃ¨ge, Â«nonÂ» est indiquÃ©, car ils ne pourront pas trouver de solution si la cible est Ã  l'intÃ©rieur de l'Ã®le.  Â«DeadÂ» est indiquÃ© pour les enduits sans issue et les enduits en cul-de-sac, car dans les labyrinthes en osier, ils peuvent ne pas trouver de solution. </li><li>  <b>PrioritÃ©:</b> Il existe deux types d'algorithmes pour rÃ©soudre le labyrinthe: donner la prioritÃ© Ã  Â«vousÂ» (situÃ© dans le labyrinthe) ou donner la prioritÃ© au labyrinthe.  Si la prioritÃ© vous est donnÃ©e, alors nous avons un point (Â«VousÂ» est indiquÃ© dans le tableau) ou plusieurs points (Â«Vous +Â») et l'algorithme essaie de les dessiner du dÃ©but Ã  la fin du labyrinthe.  Si la prioritÃ© est donnÃ©e au labyrinthe, alors nous examinons le labyrinthe dans son ensemble et Ã©liminons les passages inutiles. </li><li>  <b>Disponible pour l'homme:</b> un homme peut-il utiliser l'algorithme pour rÃ©soudre le labyrinthe, soit dans le vrai labyrinthe, soit en regardant la carte d'en haut.  Certains des algorithmes qui donnent la prioritÃ© Ã  Â«vousÂ» peuvent Ãªtre implÃ©mentÃ©s en tant que personne Ã  l'intÃ©rieur du labyrinthe (ou au-dessus), et certains qui donnent la prioritÃ© au labyrinthe peuvent Ãªtre implÃ©mentÃ©s en tant que personne, mais uniquement au-dessus du labyrinthe.  D'autres algorithmes sont trop complexes et leur implÃ©mentation fiable n'est possible que sur ordinateur. </li><li>  <b>Pass indÃ©pendant:</b> l'algorithme peut-il s'exÃ©cuter n'importe oÃ¹.  Certains algorithmes exigent que le labyrinthe ait des passages Ã©vidents ou, en parlant dans la terminologie des graphiques, des bords nets entre les sommets individuels, ou des passages d'un pixel lorsqu'il est implÃ©mentÃ© sur un ordinateur.  Le suiveur de mur, l'algorithme Pledge et l'algorithme de circuit nÃ©cessitent un mur uniquement sur un cÃ´tÃ© de vous.  Le backtracker rÃ©cursif et le plus court localisateur de chemin acheminent le leur Ã  travers des espaces ouverts. </li><li>  <b>Aucune mÃ©moire requise:</b> avez-vous besoin de mÃ©moire supplÃ©mentaire ou d'une pile pour implÃ©menter l'algorithme.  Les algorithmes efficaces ne nÃ©cessitent qu'une image bitmap du labyrinthe lui-mÃªme et ils n'ont pas besoin d'ajouter de marqueurs au labyrinthe dans le processus de rÃ©solution. </li><li>  <b>Rapide:</b> le processus de dÃ©cision est-il considÃ©rÃ© comme rapide?  Les algorithmes les plus efficaces suffisent Ã  ne regarder chaque cellule du labyrinthe qu'une seule fois, ou ils peuvent en ignorer complÃ¨tement certaines parties.  Le temps d'exÃ©cution doit Ãªtre proportionnel Ã  la taille du labyrinthe, ou O (n ^ 2), oÃ¹ n est le nombre de cellules le long d'un cÃ´tÃ©.  La souris alÃ©atoire est lente car son achÃ¨vement n'est pas garanti, et le remplissage en allÃ©e aveugle rÃ©sout potentiellement le labyrinthe de chaque fourche. </li></ul><br><h2>  Autres opÃ©rations avec des labyrinthes </h2><br>  En plus de crÃ©er et de rÃ©soudre des labyrinthes, vous pouvez effectuer d'autres opÃ©rations avec eux: <br><br><ul><li> <b><img src="https://habrastorage.org/getpro/habr/post_images/6f7/fee/d6d/6f7feed6d3542670945c7601c6d17656.gif"><br><br></b>  <b>Fill:</b> c'est une fonction Â«rapide et saleÂ», mais nÃ©anmoins utile qui peut Ãªtre implÃ©mentÃ©e en un seul appel Ã  la procÃ©dure de bibliothÃ¨que graphique Fill ou FloodFill.  Nous effectuons le FloodFill du passage au dÃ©but, et si la fin n'est pas inondÃ©e, alors le labyrinthe n'a pas de solution.  Dans les labyrinthes, dont l'entrÃ©e et la sortie sont sur les bords, nous effectuons le FloodFill d'un mur, et les bords restants marquent la solution.  Dans les labyrinthes oÃ¹ le dÃ©but et la fin sont Ã  l'intÃ©rieur, nous exÃ©cutons le FloodFill du mur d'enceinte, et si le mur de sortie n'a pas Ã©tÃ© supprimÃ©, ce labyrinthe ne peut pas Ãªtre rÃ©solu en suivant le long des murs.  De nombreuses mÃ©thodes de crÃ©ation de labyrinthes et d'autres fonctions utilisent le "remplissage" du labyrinthe Ã  certains points. </li><li> <b><img src="https://habrastorage.org/getpro/habr/post_images/f09/223/2e3/f092232e3f56154a43c81d5b71eee6c2.gif"><br><br></b>  <b>Dissolvant d'isolement:</b> changez le labyrinthe afin qu'il ne comporte pas de parties avec des passages inaccessibles depuis le reste du labyrinthe.  Il est rÃ©alisÃ© en enlevant les murs reliant ces parties avec le reste du labyrinthe.  Nous commenÃ§ons par une copie du labyrinthe, puis remplissons le passage vers le dÃ©but.  Nous scannons le labyrinthe (de prÃ©fÃ©rence dans un ordre alÃ©atoire, mais avec une visite Ã  toutes les cellules possibles) pour la prÃ©sence de cellules non remplies adjacentes Ã  la cellule remplie.  Nous supprimons le segment de mur Ã  ce point dans le labyrinthe d'origine, remplissons le labyrinthe Ã  ce nouveau point et rÃ©pÃ©tons jusqu'Ã  ce que toutes les piÃ¨ces soient remplies.  Cette fonction est utilisÃ©e pour crÃ©er des labyrinthes tissÃ©s et Ã  motifs. </li><li> <b><img src="https://habrastorage.org/getpro/habr/post_images/e02/4fb/283/e024fb2832bd8e5d855b80393a75cf67.gif"><br><br></b>  <b>Suppression des boucles:</b> modifiez le labyrinthe afin qu'il n'y ait pas de boucles et de murs qui ne soient connectÃ©s Ã  rien, et que chaque partie du labyrinthe soit accessible Ã  partir de n'importe quel point d'une seule maniÃ¨re.  La mise en Å“uvre de cette fonction est presque similaire Ã  la suppression des zones isolÃ©es, seulement nous percevons les murs comme des passages, et vice versa.  Nous commenÃ§ons par une copie du labyrinthe, puis remplissons les murs extÃ©rieurs.  Nous scannons le labyrinthe (de prÃ©fÃ©rence dans un ordre alÃ©atoire, mais avec une visite Ã  tous les sommets de murs possibles) pour la prÃ©sence de murs non remplis Ã  cÃ´tÃ© de ceux remplis.  Ajoutez un segment de mur reliant les deux parties des murs au labyrinthe d'origine Ã  ce stade, remplissez le labyrinthe Ã  ce nouveau point et rÃ©pÃ©tez jusqu'Ã  ce que toutes les parties soient remplies.  Cette fonction est utilisÃ©e pour crÃ©er des labyrinthes modÃ¨les et peut Ãªtre utilisÃ©e pour convertir des labyrinthes en osier Ã  des labyrinthes idÃ©aux, qui restent nÃ©anmoins similaires aux originaux. </li><li><img src="https://habrastorage.org/getpro/habr/post_images/ea4/f95/188/ea4f951888f580d0a1446246e20e0ea1.gif"><br><br>  <b>Rechercher les goulots d'Ã©tranglement</b> <b>:</b> Rechercher dans le dÃ©dale de passages ou de points d'intersection par lesquels passent toutes les solutions de ce dÃ©dale.  Pour ce faire, commencez Ã  suivre le long des murs avec la mÃ©thode de la main gauche pour obtenir la solution de gauche et commencez Ã  suivre le long des murs avec la mÃ©thode de la main droite pour obtenir la bonne solution.  Les endroits oÃ¹ les deux solutions sont communes sont des goulots d'Ã©tranglement.  Cependant, cette technique ne fonctionne que pour les labyrinthes, qui peuvent Ãªtre rÃ©solus avec succÃ¨s en suivant le long des murs.  Dans d'autres labyrinthes, pour trouver des goulots d'Ã©tranglement, vous devez trouver n'importe quelle solution, ainsi que exÃ©cuter un scellant pour allÃ©e aveugle (cela peut rendre le labyrinthe insoluble s'il perÃ§oit l'entrÃ©e ou la sortie Ã  l'intÃ©rieur du labyrinthe comme une grande impasse).  Des parties du chemin de solution passant par des passages fermÃ©s sont des goulots d'Ã©tranglement. </li></ul><br><h2>  ImplÃ©mentations d'algorithmes </h2><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><b>Daedalus</b></a> <b>:</b> tous les algorithmes de crÃ©ation et de rÃ©solution de labyrinthes dÃ©crits ci-dessus sont implÃ©mentÃ©s dans Daedalus, un programme Windows gratuit et tÃ©lÃ©chargeable.  Complet avec Daedalus il y a un code source complet. </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr445378/">https://habr.com/ru/post/fr445378/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr445362/index.html">Le livre "Distributed Systems. ModÃ¨les de conception</a></li>
<li><a href="../fr445366/index.html">Comment accÃ©lÃ©rer le cryptage selon GOST 28147-89 sur le processeur Baikal-T1 en raison du bloc SIMD</a></li>
<li><a href="../fr445368/index.html">Test de charge d'un jeu avec quelques centaines de milliers d'utilisateurs virtuels</a></li>
<li><a href="../fr445370/index.html">Analyse TSDB dans PromÃ©thÃ©e 2</a></li>
<li><a href="../fr445372/index.html">Vision industrielle vs intuition humaine: algorithmes pour perturber le fonctionnement des programmes de reconnaissance d'objets</a></li>
<li><a href="../fr445380/index.html">Le PHP moderne est beau et productif</a></li>
<li><a href="../fr445384/index.html">Mission Chang'e-4 - Ã©quipement scientifique sur le module d'atterrissage et le satellite rÃ©pÃ©teur</a></li>
<li><a href="../fr445390/index.html">IDE d'une personne normale ou pourquoi nous avons choisi Monaco</a></li>
<li><a href="../fr445392/index.html">Remarketing dynamique MyTarget: recommandations de produits non personnels</a></li>
<li><a href="../fr445394/index.html">Modifications du protocole 3D Secure: rencontrez 3-D Secure 2.0</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>