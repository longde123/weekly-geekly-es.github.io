<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨🏻‍🎤 🤹🏽 🧑🏿‍🤝‍🧑🏾 Labyrinthes: classification, génération, recherche de solutions 🔻 🏍️ 🌯</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Cet article classique détaille les façons les plus populaires de créer et de parcourir des labyrinthes. L'article est divisé en quatre parties: classi...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Labyrinthes: classification, génération, recherche de solutions</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/445378/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/50c/8cc/ddc/50c8ccddc7242a00cf9dd62fba696ed2.gif"></div><br>  <i>Cet article classique détaille les façons les plus populaires de créer et de parcourir des labyrinthes.</i>  <i>L'article est divisé en quatre parties: classification, algorithmes de génération, algorithmes de résolution de labyrinthes et autres opérations avec des labyrinthes.</i> <br><br><h2>  Classification du labyrinthe </h2><br>  Les labyrinthes dans leur ensemble (et donc les algorithmes pour les créer) peuvent être divisés en sept classifications différentes: dimension, hyperdimension, topologie, tessellation, routage, texture et priorité.  Le labyrinthe peut utiliser un élément de chaque classe dans n'importe quelle combinaison. <a name="habracut"></a><br>  <b>Dimension:</b> la classe de dimension détermine essentiellement le nombre de dimensions dans l'espace que le labyrinthe remplit.  Les types suivants sont disponibles: <br><br><ul><li><img src="https://habrastorage.org/getpro/habr/post_images/0a7/93f/443/0a793f443fe8f89980ecfd43559ccc81.gif"><br><br>  <b>Deux dimensions</b> <b>: la</b> plupart des labyrinthes, papier et réel, ont cette dimension, c'est-à-dire que nous pouvons toujours afficher le plan du labyrinthe sur une feuille de papier et le déplacer sans traverser d'autres couloirs du labyrinthe. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><b>En trois dimensions</b></a> <b>: le</b> labyrinthe en trois dimensions a plusieurs niveaux;  en elle (au moins dans la version orthogonale), les passages peuvent descendre et monter, en plus des quatre points cardinaux.  Un labyrinthe 3D est souvent visualisé comme un tableau de niveaux 2D avec des escaliers de haut en bas. </li><li><img src="https://habrastorage.org/getpro/habr/post_images/999/897/373/9998973734d2c66d06205a9ade0b501c.gif"><br><br>  <b>Dimensions supérieures</b> <b>:</b> vous pouvez créer des labyrinthes à quatre dimensions et encore plus des labyrinthes multidimensionnels.  Parfois, ils sont visualisés comme des labyrinthes 3D avec des «portails» menant à travers la quatrième dimension, par exemple, des portails vers le «passé» et le «futur». </li><li><img src="https://habrastorage.org/getpro/habr/post_images/56a/89a/c01/56a89ac017b5faa694d3e15ab8d3948d.gif"><br><br>  <b>Entrelacement</b> <b>:</b> labyrinthes avec entrelacement - ce sont essentiellement des labyrinthes bidimensionnels (ou plutôt 2,5 dimensions), dans lesquels, cependant, les passages peuvent se chevaucher.  Lors de l'affichage, il est généralement assez évident où se trouvent les impasses et comment un passage est au-dessus de l'autre.  Des labyrinthes du monde réel, dans lesquels se trouvent des ponts reliant une partie du labyrinthe à une autre, s'entrelacent partiellement. </li></ul><br>  <b>Hyperdimension: la</b> classification selon l'hyperdimension correspond à la dimension d'un objet se déplaçant dans un labyrinthe, et non au labyrinthe lui-même.  Les types suivants sont disponibles: <br><br><ul><li><img src="https://habrastorage.org/getpro/habr/post_images/0a7/93f/443/0a793f443fe8f89980ecfd43559ccc81.gif"><br><br>  <b>Non-hyperlabyrinthes</b> <b>:</b> presque tous les labyrinthes, même ceux créés en haute dimensionnalité ou avec des règles spéciales, sont généralement des non-hyperlabyrinthes.  En eux, nous travaillons avec un point ou un petit objet, par exemple, une balle ou le joueur lui-même, qui se déplace d'un point à un autre, et l'itinéraire pavé forme une ligne.  À chaque point, il existe un nombre de choix facilement dénombrable. </li><li>  <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Hyperlabyrinthes: les</a></b> hyperlabyrinthes sont des labyrinthes dans lesquels l'objet à résoudre n'est pas seulement un point.  Un hyperlabyrinthe standard (ou hyperlabyrinthe de premier ordre) consiste en une ligne qui forme une surface lors du déplacement le long d'un chemin.  L'hyperlabyrinthe ne peut exister qu'en 3D ou dans un milieu de plus grande dimension, et l'entrée de l'hyperlabyrinthe n'est souvent pas un point, mais une ligne.  L'hyperlabyrinthe est fondamentalement différent, car il est nécessaire de prendre en compte et de travailler simultanément avec plusieurs parties le long de la ligne, et à tout moment, il existe un nombre presque infini d'états et d'options pour ce qui peut être fait avec la ligne.  La ligne de solution est infinie, ou ses extrémités sont en dehors de l'hyperlabyrinthe pour éviter que la ligne ne soit compressée en un point, car dans ce cas, elle peut être considérée comme non hyperlabyrinthe. </li><li>  <b>Hyper-hyperlabyrinthe: les</b> hyperlabyrinthes peuvent avoir une dimension arbitrairement élevée.  L'hyper-hyperlabyrinthe (ou hyperlabyrinthe de second ordre) augmente à nouveau la dimension de l'objet à résoudre.  Ici, l'objet à résoudre est un plan qui, en se déplaçant le long du chemin, forme une figure tridimensionnelle.  L'hyper-hyperlabyrinthe ne peut exister que dans un environnement dimensionnel 4D ou supérieur. </li></ul><br>  <b>Topologie: la</b> classe de topologie décrit la géométrie de l'espace du labyrinthe dans lequel il existe dans son ensemble.  Les types suivants sont disponibles: <br><br><ul><li><img src="https://habrastorage.org/getpro/habr/post_images/0a7/93f/443/0a793f443fe8f89980ecfd43559ccc81.gif"><br><br>  <b>Normal</b> <b>:</b> il s'agit du labyrinthe standard dans l'espace euclidien. </li><li><img src="https://habrastorage.org/getpro/habr/post_images/ff3/d52/35d/ff3d5235d49cbe3a9d2a562033d73202.gif"><br><br>  <b>Planair</b> <b>: Le</b> terme «planair» décrit tout labyrinthe avec une topologie inhabituelle.  Cela signifie généralement que les bords du labyrinthe sont connectés de manière intéressante.  Exemples: labyrinthes à la surface d'un cube, labyrinthes à la surface d'une bande Mobius et labyrinthes équivalents à ceux d'un tore où les côtés gauche et droit, supérieur et inférieur sont reliés par paires. </li></ul><br>  <b>Tessellation: une</b> classification de la géométrie des cellules individuelles qui composent le labyrinthe.  Types existants: <br><br><ul><li><img src="https://habrastorage.org/getpro/habr/post_images/0a7/93f/443/0a793f443fe8f89980ecfd43559ccc81.gif"><br><br>  <b>Orthogonale</b> <b>:</b> Il s'agit d'une grille rectangulaire standard dans laquelle les cellules ont des passages qui se coupent à angle droit.  Dans le contexte de la tessellation, ils peuvent également être appelés labyrinthes gamma. </li><li><img src="https://habrastorage.org/getpro/habr/post_images/488/88c/28f/48888c28fd1c5ad3601c0dbb4e3716f6.gif"><br><br>  <b>Delta</b> <b>:</b> les labyrinthes Delta se composent de triangles connectés, et chaque cellule peut avoir jusqu'à trois passages qui lui sont connectés. </li><li><img src="https://habrastorage.org/getpro/habr/post_images/650/dcd/b76/650dcdb76582619209847e3111cb0ad4.gif"><br><br>  <b>Sigma</b> <b>: les</b> labyrinthes Sigma sont constitués d'hexagones connectés;  chaque cellule peut avoir jusqu'à six passes. </li><li><img src="https://habrastorage.org/getpro/habr/post_images/b12/0eb/9da/b120eb9da20a99a3985e76a644b4e740.gif"><br><br>  <b>Thêta</b> <b>: les</b> labyrinthes thêta sont constitués de cercles concentriques de passages dont le début ou la fin est au centre et l'autre sur le bord extérieur.  Les cellules ont généralement quatre chemins de connexion possibles, mais il peut y en avoir plus en raison du plus grand nombre de cellules dans les anneaux externes des passages. </li><li><img src="https://habrastorage.org/getpro/habr/post_images/283/751/2a5/2837512a58f5ad292e93b65a832e80fa.gif"><br><br>  <b>Epsilon</b> <b>: les</b> labyrinthes d'Epsilon sont constitués d'octogones ou de carrés connectés, chaque cellule en eux peut avoir jusqu'à huit ou quatre passes. </li><li><img src="https://habrastorage.org/getpro/habr/post_images/bba/929/e12/bba929e1276ce4be65f121f20bf101c0.gif"><br><br>  <b>Zeta</b> <b>: Le</b> labyrinthe zeta est situé sur une grille rectangulaire, seulement en plus des passages horizontaux et verticaux, les passages diagonaux sont autorisés à un angle de 45 degrés. </li><li><img src="https://habrastorage.org/getpro/habr/post_images/488/88c/28f/48888c28fd1c5ad3601c0dbb4e3716f6.gif"><br><br>  <b>Oméga</b> <b>: le</b> terme oméga fait référence à presque tous les labyrinthes à pavage constant non orthogonal.  Les labyrinthes delta, sigma, thêta et ipsilon sont de ce type, comme de nombreux autres schémas auxquels vous pouvez penser, par exemple, un labyrinthe composé de paires de triangles rectangles. </li><li><img src="https://habrastorage.org/getpro/habr/post_images/47f/d14/6db/47fd146dba649e214e28a18207a7da89.gif"><br><br>  <b>Fissure</b> <b>: Un</b> labyrinthe de fissures est un labyrinthe amorphe sans pavage constant, dans lequel les murs et les allées sont situés à des angles aléatoires. </li><li><img src="https://habrastorage.org/getpro/habr/post_images/538/fe4/b6e/538fe4b6e758b139f1e9b1b258a5bc25.gif"><br><br>  <b>Fractale</b> <b>: Un</b> labyrinthe fractal est un labyrinthe composé de labyrinthes plus petits.  Un labyrinthe fractal à partir de cellules imbriquées est un labyrinthe dans chaque cellule dont d'autres labyrinthes sont placés, et ce processus peut être répété plusieurs fois.  Un labyrinthe fractal infiniment récursif est une véritable fractale dans laquelle le contenu du labyrinthe se réplique, créant un labyrinthe essentiellement infiniment grand. </li></ul><br>  <b>Routage: La</b> classification par routage est probablement l'aspect le plus intéressant dans la génération de labyrinthes.  From est associé à des types de passes dans la géométrie définie dans les catégories décrites ci-dessus. <br><br><ul><li><img src="https://habrastorage.org/getpro/habr/post_images/0a7/93f/443/0a793f443fe8f89980ecfd43559ccc81.gif"><br><br>  <b>Idéal</b> <b>:</b> «idéal» est un labyrinthe sans boucles ni circuits fermés et sans zones inaccessibles.  Il est également appelé un labyrinthe simplement connecté.  De chaque point, il y a exactement un chemin vers tout autre point.  Labyrinth n'a qu'une seule solution.  Du point de vue de la programmation, un tel labyrinthe peut être décrit comme un arbre, un ensemble de connexion de cellules ou de sommets. </li><li><img src="https://habrastorage.org/getpro/habr/post_images/47a/0e8/60b/47a0e860b7ea1df363248e3348616cd7.gif"><br><br>  <b>Tressé</b> <b>:</b> tressé signifie qu'il n'y a pas d'impasse dans le labyrinthe.  Il est également appelé le labyrinthe de labyrinthe purement connecté.  Dans un tel labyrinthe, on utilise des passages fermés et revenant les uns aux autres (d'où le nom «osier»), ils leur font passer plus de temps à tourner en rond au lieu de se retrouver dans des impasses.  Un labyrinthe tissé de qualité peut être beaucoup plus compliqué qu'un labyrinthe idéal de la même taille. </li><li><img src="https://habrastorage.org/getpro/habr/post_images/21d/cca/63c/21dcca63cf5cfd7d0b36e6bdff94da1f.gif"><br><br>  <b>Single-route (Unicursal)</b> <b>:</b> single- <b>route</b> signifie un labyrinthe sans fourches.  Le labyrinthe à sens unique contient un long passage sinueux qui change de direction dans tout le labyrinthe.  Ce n'est pas très compliqué, seulement si vous ne faites pas accidentellement demi-tour et ne revenez pas au début. </li><li> <b><img src="https://habrastorage.org/getpro/habr/post_images/add/a2c/cb6/adda2ccb6c09bd76428e17a395f8fd3e.gif"><br><br></b>  <b>Clairsemé: un</b> labyrinthe clairsemé ne traverse pas chaque cellule, c'est-à-dire que certains d'entre eux ne sont pas créés.  Cela implique la présence de zones inaccessibles, c'est-à-dire en quelque sorte l'opposé du labyrinthe en osier.  Un concept similaire peut être appliqué lors de l'ajout de murs, de sorte que vous pouvez obtenir un labyrinthe inégal avec de larges allées et des pièces. </li><li>  <b>Partiellement en osier:</b> Labyrinthe partiellement en osier est un labyrinthe mixte qui a à la fois des boucles et des impasses.  Le mot «osier» peut être utilisé pour une évaluation quantitative, c'est-à-dire qu'un «labyrinthe solide» est un labyrinthe avec de nombreuses boucles ou des murs rétractés, et il n'y en a que quelques-uns dans le «labyrinthe faiblement tissé». </li></ul><br>  <b>Texture: la</b> classification de la <b>texture</b> décrit le style des passes avec un routage et une géométrie différents.  La texture n'est pas seulement des paramètres qui peuvent être activés ou désactivés.  Voici quelques exemples de variables: <br><br><ul><li><img src="https://habrastorage.org/getpro/habr/post_images/96d/730/eb5/96d730eb5f18e0c65786b410e5cb77cd.gif"><br><br>  <b>Biais</b> <b>:</b> dans un labyrinthe avec des passages décalés, les passages droits ont tendance à aller plus dans un sens que dans les autres.  Par exemple, dans un labyrinthe à fort déplacement horizontal, nous aurons de longs passages de gauche à droite, et seulement de courts passages de haut en bas les reliant.  Un tel labyrinthe est généralement plus difficile à passer «à travers les fibres». </li><li><img src="https://habrastorage.org/getpro/habr/post_images/264/855/d73/264855d73cffcf3937c7497f8e021ae1.gif"><br><br>  <b>Overflight</b> <b>: la</b> métrique <b>Overflight</b> détermine combien de temps les couloirs prendront avant que les virages forcés n'apparaissent.  Dans un labyrinthe de faible envergure, il n'y aura pas de passages rectilignes de plus de trois ou quatre cellules, et cela aura l'air très aléatoire.  Dans un labyrinthe à grande portée, le labyrinthe aura un grand pourcentage de passes longues, ce qui lui donnera l'apparence d'une micropuce. </li><li> <b><img src="https://habrastorage.org/getpro/habr/post_images/923/8dd/bac/9238ddbac833a6b351ddbec6aef9eee0.gif"><br><br></b>  <b>Élitisme:</b> l'indicateur «élite» du labyrinthe détermine la longueur de la solution par rapport à la taille du labyrinthe.  Les labyrinthes d'élite ont généralement une solution courte et directe, et dans les labyrinthes non élites, la solution passe sur une grande partie de la zone du labyrinthe.  Un labyrinthe d'élite de haute qualité peut être beaucoup plus compliqué qu'un labyrinthe non d'élite. </li><li><img src="https://habrastorage.org/getpro/habr/post_images/471/8e1/c13/4718e1c13d43140bd41c40081eaf0b4c.gif"><br><br>  <b>Symétrie</b> <b>: un</b> labyrinthe symétrique a des passages symétriques, par exemple, dans la symétrie de rotation par rapport au centre, ou réfléchi le long des axes horizontal ou vertical.  Le labyrinthe peut être partiellement ou complètement symétrique et peut répéter le motif un certain nombre de fois. </li><li> <b><img src="https://habrastorage.org/getpro/habr/post_images/8a9/d2b/0c6/8a9d2b0c60f1c65e96bac07fd947c565.gif"><br><br></b>  <b>Homogénéité: un</b> algorithme homogène génère tous les labyrinthes possibles avec une probabilité égale.  Un labyrinthe peut être qualifié de texture homogène s'il ressemble à un labyrinthe typique généré par un algorithme homogène.  Un algorithme hétérogène peut théoriquement également générer tous les labyrinthes possibles dans n'importe quel espace, mais pas avec une probabilité égale.  L'hétérogénéité peut aller encore plus loin - il peut y avoir des labyrinthes que l'algorithme ne générera jamais. </li><li>  <b>Débit de la rivière: La</b> caractéristique de «débit» signifie que lors de la création d'un labyrinthe, l'algorithme recherchera et nettoiera les cellules (ou parois) voisines de la cellule actuelle, c'est-à-dire qu'il coulera (d'où le terme de «fluidité») dans les parties encore non créées du labyrinthe, comme l'eau.  Dans un labyrinthe idéal avec un débit plus faible, il y aura généralement de nombreuses impasses courtes, et dans un labyrinthe plus «fluide», il y aura moins d'impasses, mais elles seront plus longues. </li></ul><br>  <b>Priorité:</b> cette classification montre que les processus de création de labyrinthes peuvent être divisés en deux types principaux: l'ajout de murs et la sculpture de passages.  Habituellement, lors de la génération de cela, cela se résume uniquement à la différence dans les algorithmes, et non à des différences notables dans les labyrinthes, mais il est toujours utile d'en tenir compte.  Le même labyrinthe est souvent généré dans les deux sens: <br><br><ul><li>  <b>Ajout de murs: les</b> algorithmes pour lesquels les murs sont prioritaires commencent par une zone vide (ou une bordure externe), ajoutant des murs dans le processus.  Dans le monde réel, de vrais labyrinthes composés de haies, de plafonds ou de murs en bois ajoutent définitivement des murs. </li><li>  <b>Couper les allées: les</b> algorithmes dont la priorité est aux allées commencent par un bloc solide et coupent des passages dans celui-ci au cours du processus.  Dans le monde réel, ces labyrinthes sont des tunnels miniers ou des labyrinthes à l'intérieur des tuyaux. </li><li> <b><img src="https://habrastorage.org/getpro/habr/post_images/788/7d3/94f/7887d394fd2acf973c1dcfd4616dc09f.gif"><br><br></b>  <b>Modèle:</b> bien sûr, les labyrinthes peuvent simultanément couper des passages et ajouter des murs;  certains algorithmes informatiques le font.  Un modèle de labyrinthe est une image graphique qui n'est pas un labyrinthe qui, au moindre nombre d'étapes, se transforme en véritable labyrinthe, mais conserve la texture du modèle graphique d'origine.  Les styles de labyrinthe complexes, tels que les spirales qui se croisent, sont plus faciles à implémenter en tant que modèles dans un ordinateur, plutôt que d'essayer de créer le bon labyrinthe tout en préservant son style. </li></ul><br>  <b>Autre: ce qui</b> précède n'est en aucun cas une liste exhaustive de toutes les classes ou éléments possibles au sein de chaque classe.  Ce ne sont que ces types de labyrinthes que j'ai créés moi-même.  Notez que presque tous les types de labyrinthe, y compris les labyrinthes avec des règles spéciales, peuvent être exprimés sous forme de graphique dirigé dans lequel il y aura un nombre fini d'états et un nombre fini de choix dans chaque état, et cela s'appelle l' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><b>équivalence des labyrinthes</b></a> .  Voici quelques autres classifications et types de labyrinthes: <br><br><ul><li><img src="https://habrastorage.org/getpro/habr/post_images/d19/d0e/264/d19d0e264db5d3d8521fbe62037c1b07.gif"><br><br>  <b>Orientation</b> <b>:</b> sur certains passages, vous ne pouvez vous déplacer que dans une seule direction.  Du point de vue de la programmation, un tel labyrinthe sera décrit par un graphe orienté, contrairement à un graphe non orienté décrivant tous les autres types. </li><li><img src="https://habrastorage.org/getpro/habr/post_images/43e/596/214/43e596214c1af1f52950a1223d111c3e.gif"><br><br>  <b>Segmentation</b> <b>: le</b> labyrinthe peut avoir différentes parties correspondant à différentes classes. </li><li> <b><img src="https://habrastorage.org/getpro/habr/post_images/099/aee/262/099aee262a4d50e33bb92ab5b82946c6.gif"><br><br></b>  <b>Labyrinthes de longueur infinie:</b> nous pouvons créer un labyrinthe infiniment long (un nombre fini de colonnes et un nombre quelconque de lignes), mais en même temps ne stocker qu'une partie du labyrinthe en mémoire, "faire défiler" d'une extrémité à l'autre et détruire les lignes précédentes lors de la création de la suivante.  Un exemple est une version modifiée de l'algorithme Hunt and Kill.  On peut imaginer un labyrinthe potentiellement sans fin sous la forme d'un long film composé d'images individuelles.  Seules deux trames consécutives sont stockées en mémoire à la fois.  Exécutons l'algorithme Hunt and Kill, bien qu'il crée un biais sujet au cadre supérieur, il se termine donc en premier.  Une fois terminé, le cadre n'est plus nécessaire, vous pouvez l'imprimer ou faire autre chose avec.  Quoi qu'il en soit, jetez-le, faites du cadre inférieur partiellement créé un nouveau cadre supérieur et effacez le nouveau cadre inférieur.  Répétez le processus jusqu'à ce que nous décidions d'arrêter, puis attendez que Hunt And Kill termine les deux images.  La seule limitation est que le labyrinthe n'aura jamais de chemin se ramifiant vers l'entrée sur une longueur de plus de deux images.  La façon la plus simple de créer un labyrinthe sans fin est l'algorithme Eller ou l'algorithme Sidewinder, car ils créent déjà des labyrinthes une ligne à la fois, vous pouvez donc simplement les laisser ajouter sans cesse des lignes au labyrinthe. </li><li> <b><img src="https://habrastorage.org/getpro/habr/post_images/8e1/677/f0f/8e1677f0fc6dbdfb99739ed66ec8d534.png" alt="image"><br><br></b>  <b>Labyrinthes fractals</b> virtuels <b>: le</b> virtuel est un labyrinthe dans lequel tout le labyrinthe n'est pas stocké en mémoire en même temps.  Par exemple, il ne peut stocker qu'une partie des passages 100x100 près de votre emplacement dans une simulation où vous vous promenez dans un grand labyrinthe.  L'extension des labyrinthes fractals imbriqués peut être utilisée pour créer d'énormes labyrinthes virtuels, par exemple, un milliard par milliard de passes.  Si nous construisions une véritable copie du labyrinthe d'un milliard par milliard de passes (avec une distance de six pieds entre les passages), cela remplirait la surface de la Terre plus de 6 000 fois!  Considérez un labyrinthe de 10 <sup>9</sup> à 10 <sup>9</sup> passes, ou un labyrinthe fermé avec seulement 9 niveaux.  Si nous voulons avoir au moins une partie 100x100 autour de nous, alors il nous suffit de créer au niveau le plus bas un sous-labyrinthe de 100x100 passes et sept labyrinthes 10x10 dans lesquels il est intégré afin de savoir exactement où se trouvent les murs dans la partie 100x100.  (En fait, il vaut mieux avoir quatre pièces adjacentes de 100 x 100, formant un carré au cas où vous seriez près du bord ou du coin de la pièce, mais le même concept s'applique ici.) Pour garantir que le labyrinthe est constant et inchangé lors du déplacement, nous avons une formule, définir un nombre de graines aléatoire pour chaque coordonnée à chaque niveau d'imbrication.  Les labyrinthes fractals virtuels sont similaires à la fractale Mandelbrot, dont les images existent virtuellement, et nous devons visiter une certaine coordonnée à un grossissement assez élevé.  pour qu'il apparaisse. </li></ul><br><h2>  Algorithmes de labyrinthe </h2><br>  Voici une liste d'algorithmes généralisés pour créer les différentes classes de labyrinthes décrites ci-dessus: <br><br><ul><li><img src="https://habrastorage.org/getpro/habr/post_images/0a7/93f/443/0a793f443fe8f89980ecfd43559ccc81.gif"><br><br>  <b>Idéal</b> <b>:</b> pour créer un labyrinthe idéal standard, il est généralement nécessaire de le «cultiver», en garantissant l'absence de boucles et de zones isolées.  Nous partons du mur extérieur et ajoutons au hasard un fragment du mur qui le touche.  Nous continuons d'ajouter au hasard des segments de mur au labyrinthe, mais vérifions que chaque nouveau segment touche une extrémité du mur existant et que son autre extrémité se trouve dans la partie non créée du labyrinthe.  Si vous ajoutez un segment de mur, dont les deux extrémités sont séparées du reste du labyrinthe, cela créera un mur non connecté avec une boucle autour de lui, et si vous ajoutez un segment, dont les deux extrémités touchent le labyrinthe, cela créera une zone inaccessible.  Il s'agit d'une méthode pour ajouter des murs;  elle est presque analogue à la découpe de passages, dans lesquels des parties des passages sont coupées de sorte qu'une seule extrémité touche la passe existante. </li><li><img src="https://habrastorage.org/getpro/habr/post_images/47a/0e8/60b/47a0e860b7ea1df363248e3348616cd7.gif"><br><br> <b></b> <b>:</b>               ,   ,          .      : (1)    , (2)       ,    ,          -«», (3)        ,   ,     , (4)        ,       ,      (3)   ,     ,        . </li><li><img src="https://habrastorage.org/getpro/habr/post_images/21d/cca/63c/21dcca63cf5cfd7d0b36e6bdff94da1f.gif"><br><br> <b></b> <b>:</b>        —   ,  ,     ,    ,      .      U- ,      ,       ,       ,       .           .    ,           :          ,      ,       ,   .      ,             .     ,          . </li><li> <b><img src="https://habrastorage.org/getpro/habr/post_images/ce1/9b2/36c/ce19b236c5dd3f766d0c817aeb551bdc.gif"><br><br> :</b>         ,     .              ,      ,     .  -       ,       ,            ,  ,    . </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><b>3D</b></a> <b>:</b>           ,     ,          ,      . -         . </li><li><img src="https://habrastorage.org/getpro/habr/post_images/56a/89a/c01/56a89ac017b5faa694d3e15ab8d3948d.gif"><br><br> <b></b> <b>:</b>           ,          ,               .             (        ):     ,      ,       ,         .           ,  .    ,   ;    ,     .           ,      ,    . </li><li><img src="https://habrastorage.org/getpro/habr/post_images/47f/d14/6db/47fd146dba649e214e28a18207a7da89.gif"><br><br> <b>Crack</b> <b>:</b> Crack-         ,      ,     .  ,     ,     ,  «»        .   ,      ,    .  ,  -       . ,           ,             ;      .        ,       . </li><li><img src="https://habrastorage.org/getpro/habr/post_images/488/88c/28f/48888c28fd1c5ad3601c0dbb4e3716f6.gif"><br><br> <b></b> <b>:</b>     «»    ,           ,   . ,   -    : (1)  ,           . (2)     ,      ,    ,         ,    ,      (..      ). (3)     ,  ,     .            ,            . </li><li><img src="https://habrastorage.org/getpro/habr/post_images/7d0/844/5f9/7d08445f9ee145b6db8b844d70f9d21c.gif"><br><br> <b></b> <b>:</b>  —  3D-,       -,      ,  .   3D-       ,       ,    .           ,             ,         .         ,         .         ,     (   ),          ,          ,    . </li><li><img src="https://habrastorage.org/getpro/habr/post_images/ff3/d52/35d/ff3d5235d49cbe3a9d2a562033d73202.gif"><br><br> <b>Planair</b> <b>:</b> Planair-               ,         .     —       .      ,          . </li><li> <b><img src="https://habrastorage.org/getpro/habr/post_images/788/7d3/94f/7887d394fd2acf973c1dcfd4616dc09f.gif"><br><br> :</b> ,   , ,    -,      ,    ,     ,   .     ,     . ,   ,         ,    ,    ,          . </li></ul><br><h2>     </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Il existe de nombreuses façons de créer des labyrinthes parfaits, et chacun d'eux a ses propres caractéristiques. </font><font style="vertical-align: inherit;">Voici une liste d'algorithmes spécifiques. </font><font style="vertical-align: inherit;">Tous décrivent la création d'un labyrinthe en découpant des passages, cependant, sauf indication contraire, chacun peut également être mis en œuvre en ajoutant des murs:</font></font><br><br><ul><li><img src="https://habrastorage.org/getpro/habr/post_images/128/314/7ba/1283147bad2733851cdba5fb965b7530.gif"><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Backtracker récursif </font></font></b> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font></b>   -      recursive backtracker,   ,       .       ,       ,       .  ,      ,     .        ,      .  ,       .         ,  ,   ,        .      ,       . Recursive backtracking      ,       ,    ,          . </li><li><img src="https://habrastorage.org/getpro/habr/post_images/7c3/316/387/7c3316387d28cf3b3ebdcd9caacef988.gif"><br><br> <b> </b> <b>:</b>  ,    .  ,     «»   ,          ,           .      ,   ,               (          ).     ,        .           ,             ,     .          ,      - ,    ,    .        ,    ,    .          ,            . ,             - (union-find algorithm):      ,    .       .        ,    -      . </li><li><img src="https://habrastorage.org/getpro/habr/post_images/7c3/316/387/7c3316387d28cf3b3ebdcd9caacef988.gif"><br><br>  <b>Algorithme de Prim (vrai)</b> <b>:</b> cet algorithme crée un arbre couvrant minimal en traitant des poids de bord aléatoires uniques.  La quantité de mémoire requise est proportionnelle à la taille du labyrinthe.  Nous partons de n'importe quel sommet (le labyrinthe fini sera le même, peu importe le sommet que nous commençons).  Nous sélectionnons le bord du passage avec le plus petit poids reliant le labyrinthe à un point qui n'y est pas déjà, puis le fixons au labyrinthe.  Le labyrinthe est terminé lorsque les bords en question ne sont plus laissés.  Pour sélectionner efficacement le bord suivant, vous avez besoin d'une file d'attente prioritaire (généralement implémentée à l'aide d'un segment) qui stocke tous les bords de la bordure.  Cependant, cet algorithme est plutôt lent car il faut du temps à log (n) pour sélectionner des éléments dans le tas.  Par conséquent, il est préférable de préférer l'algorithme Kraskal, qui crée également un arbre couvrant minimal, car il est plus rapide et crée des labyrinthes avec une structure identique.  En fait, avec la même graine aléatoire, les algorithmes Prima et Kraskal peuvent créer les mêmes labyrinthes. </li><li><img src="https://habrastorage.org/getpro/habr/post_images/fe7/700/d75/fe7700d7554d3456bb9f7c185b16dec1.gif"><br><br>  <b>Algorithme de Prim (simplifié)</b> <b>:</b> cet algorithme de Prim crée un arbre couvrant minimal.  Il est simplifié de telle sorte que tous les poids des bords sont les mêmes.  Il nécessite une capacité mémoire proportionnelle à la taille du labyrinthe.  Nous partons d'un pic aléatoire.  Nous sélectionnons au hasard le bord du passage reliant le labyrinthe à un point qui n'y est pas encore, puis nous le fixons au labyrinthe.  Le labyrinthe est terminé lorsque les bords en question ne sont plus laissés.  Étant donné que les bords sont en apesanteur et non ordonnés, ils peuvent être stockés sous forme de liste simple, c'est-à-dire que la sélection des éléments de la liste sera très rapide et prend un temps constant.  Par conséquent, il est beaucoup plus rapide que le véritable algorithme Prim avec des poids de bord aléatoires.  La texture de labyrinthe créée aura un débit plus faible et une solution plus simple que la vraie méthode Prim, car elle se propage uniformément à partir du point de départ, comme le sirop renversé, et ne contourne pas les fragments de côtes avec un poids plus élevé, qui sont pris en compte plus tard. </li><li><img src="https://habrastorage.org/getpro/habr/post_images/95d/7bf/e0a/95d7bfe0ad94b47045e086ff12847b94.gif"><br><br>  <b>Algorithme de Prim (modifié)</b> <b>:</b> cet algorithme de Prim crée un arbre couvrant minimal, modifié de sorte que tous les poids des bords soient les mêmes.  Cependant, il est implémenté de telle sorte qu'au lieu de bords, il regarde les cellules.  La quantité de mémoire est proportionnelle à la taille du labyrinthe.  Dans le processus de création, chaque cellule peut avoir l'un des trois types suivants: (1) «interne»: la cellule fait partie du labyrinthe et y est déjà découpée, (2) «limite»: la cellule ne fait pas partie du labyrinthe et n'y a pas encore été découpée, mais est située à côté de la cellule qui est déjà "interne", et (3) "externe": la cellule ne fait pas encore partie du labyrinthe, et aucun de ses voisins n'est également la cellule "interne".  Nous commençons par choisir une cellule, la rendons «interne», et pour tous ses voisins, nous définissons le type sur «limite».  Nous sélectionnons au hasard la cellule «limite» et y coupons un passage d'une des cellules «internes» voisines.  Nous changeons l'état de cette cellule «limite» en «interne» et changeons le type de tous ses voisins de «externe» en «frontière».  Le labyrinthe est achevé lorsqu'il ne reste plus de cellules «limites» (c'est-à-dire qu'il n'y a plus de cellules «externes», ce qui signifie que tout le monde est devenu «interne»).  Cet algorithme crée des labyrinthes avec un indice de rendement très faible, a de nombreux blocages courts et une solution plutôt simple.  Le labyrinthe résultant est très similaire au résultat de la méthode simplifiée de Prim, avec une légère différence: les vides dans l'arbre couvrant ne sont remplis que si une cellule limite est sélectionnée au hasard, contrairement à la triple probabilité de remplir cette cellule par l'une des cellules limites qui y mènent.  De plus, l'algorithme est très rapide, plus rapide que l'algorithme Prim simplifié, car il n'a pas besoin de compiler et de traiter la liste des arêtes. </li><li><img src="https://habrastorage.org/getpro/habr/post_images/8a9/d2b/0c6/8a9d2b0c60f1c65e96bac07fd947c565.gif"><br><br>  Algorithme d' <b>Aldous-Broder</b> : ce qui est intéressant dans cet algorithme, c'est qu'il est homogène, c'est-à-dire qu'il crée avec une probabilité égale tous les labyrinthes possibles d'une taille donnée.  De plus, il ne nécessite ni mémoire supplémentaire ni pile.  Nous sélectionnons un point et nous nous déplaçons au hasard vers une cellule voisine.  Si nous entrons dans une cellule non coupée, découpez ensuite le passage de la cellule précédente.  Nous continuons à nous déplacer vers les cellules voisines jusqu'à ce que nous coupions les passages à toutes les cellules.  Cet algorithme crée des labyrinthes avec un faible débit, seulement légèrement supérieur à l'algorithme de Kraskal.  (Cela signifie que pour un échange donné, il y a plus de labyrinthes avec un indice de rendement faible qu'avec des indices élevés, car le labyrinthe avec une probabilité moyenne est également faible.) La mauvaise chose à propos de cet algorithme est qu'il est très lent car il n'effectue pas de recherche intellectuelle pour ce dernier cellules, c'est-à-dire, en fait, n'a pas de garanties d'achèvement.  Cependant, en raison de sa simplicité, il peut rapidement parcourir de nombreuses cellules, il se termine donc plus rapidement que vous ne le pensez.  En moyenne, cela prend sept fois plus de temps que les algorithmes standard, bien que dans les mauvais cas, cela puisse être beaucoup plus long si le générateur de nombres aléatoires évite constamment les dernières cellules.  Il peut être implémenté comme l'ajout de murs, si le mur de bordure est considéré comme un seul sommet, c'est-à-dire, par exemple, si le mouvement nous déplace vers le mur de frontière, nous nous téléportons à un point aléatoire le long de la frontière, et ensuite nous continuons à bouger.  Dans le cas de l'ajout de murs, cela fonctionne presque deux fois plus vite, car la téléportation le long du mur frontalier permet un accès plus rapide aux parties éloignées du labyrinthe. </li><li><img src="https://habrastorage.org/getpro/habr/post_images/8a9/d2b/0c6/8a9d2b0c60f1c65e96bac07fd947c565.gif"><br><br>  <b>Algorithme de Wilson</b> <b>:</b> il s'agit d'une version améliorée de l'algorithme Aldous-Broder, il crée des labyrinthes avec exactement la même texture (les algorithmes sont homogènes, c'est-à-dire que tous les labyrinthes possibles sont générés avec une probabilité égale), mais l'algorithme Wilson est beaucoup plus rapide.  Il prend de la mémoire jusqu'à la taille du labyrinthe.  Nous commençons avec une cellule de labyrinthe initiale choisie au hasard.  Nous sélectionnons une cellule aléatoire qui ne fait pas encore partie du labyrinthe et effectuons une marche aléatoire jusqu'à ce que nous trouvions une cellule qui appartient déjà au labyrinthe.  Dès que nous tombons sur la partie déjà créée du labyrinthe, nous retournons à la cellule aléatoire sélectionnée et coupons tout le chemin effectué en ajoutant ces cellules au labyrinthe.  Plus précisément, lorsque nous revenons le long du chemin, nous coupons dans chaque cellule dans la direction dans laquelle la marche aléatoire a eu lieu la dernière fois que nous avons quitté la cellule.  Cela évite l'apparition de boucles le long du chemin de retour, de sorte qu'un long passage rejoint le labyrinthe.  Le labyrinthe est terminé lorsque toutes les cellules y sont attachées.  L'algorithme a les mêmes problèmes de vitesse que Aldous-Broder, car il peut prendre beaucoup de temps pour trouver le premier chemin aléatoire vers la cellule initiale, mais après avoir placé plusieurs chemins, le reste du labyrinthe est découpé assez rapidement.  En moyenne, il fonctionne cinq fois plus vite qu'Aldous-Broder, et moins de deux fois plus lentement que les meilleurs algorithmes.  Il convient de noter que dans le cas de l'ajout de murs, cela fonctionne deux fois plus vite, car tout le mur de bordure fait initialement partie du labyrinthe, de sorte que les premiers murs se rejoignent beaucoup plus rapidement. </li><li><img src="https://habrastorage.org/getpro/habr/post_images/912/5a5/0b6/9125a50b62f3da5c999aa65dc144bc4a.gif"><br><br>  Algorithme de <b>chasse et de destruction</b> <b>:</b> cet algorithme est pratique car il ne nécessite pas de mémoire supplémentaire ou une pile, et convient donc à la création d'énormes labyrinthes ou labyrinthes sur des ordinateurs faibles en raison de l'impossibilité de manquer de mémoire.  Comme il n'a pas de règles à suivre en permanence, il est également plus facile de modifier et de créer des labyrinthes avec différentes textures en l'utilisant.  Il est presque similaire à un backtracker récursif, mais il n'y a pas de cellule non créée près de la position actuelle.  On passe en mode «chasse» et on scrute systématiquement le labyrinthe jusqu'à trouver une cellule non créée à côté de la cellule déjà coupée.  À ce stade, nous recommençons à couper dans ce nouvel emplacement.  Le labyrinthe est terminé quand en mode «chasse» toutes les cellules sont scannées.  Cet algorithme a tendance à créer des labyrinthes avec un débit élevé, mais pas aussi élevé que le backtracker récursif.  Vous pouvez le forcer à générer des labyrinthes avec un débit plus faible, en entrant plus souvent en mode "chasse".  Il s'exécute plus lentement en raison du temps passé à rechercher les dernières cellules, mais pas beaucoup plus lentement que l'algorithme de Kraskal.  Il peut être implémenté selon le principe de l'ajout de murs, si vous vous téléportez occasionnellement au hasard pour éviter les problèmes inhérents à un backtracker récursif. </li><li><img src="https://habrastorage.org/getpro/habr/post_images/823/3be/623/8233be62330af193c9f7a6ff63841cca.gif"><br><br>  <b>Algorithme croissant</b> <b><br></b>  <b>arbre (algorithme d'arbre en croissance)</b> <b>:</b> il s'agit d'un algorithme généralisé qui peut créer des labyrinthes avec différentes textures.  La mémoire requise peut atteindre la taille du labyrinthe.  Chaque fois qu'une cellule est coupée, nous l'ajoutons à la liste.  Sélectionnez une cellule dans la liste et découpez le passage vers la cellule non créée à côté d'elle.  S'il n'y a pas de cellules non créées à proximité de la cellule actuelle, supprimez la cellule actuelle de la liste.  Le labyrinthe est terminé lorsqu'il n'y a rien d'autre dans la liste.  La chose intéressante à propos de l'algorithme est que, selon la façon dont vous sélectionnez une cellule dans la liste, vous pouvez créer de nombreuses textures différentes.  Par exemple, si vous sélectionnez toujours la dernière cellule ajoutée, cet algorithme se transforme en backtracker récursif.  Si vous sélectionnez toujours des cellules au hasard, il se comporte de la même manière, mais pas de manière identique à l'algorithme Prim.  Si vous sélectionnez toujours les cellules les plus anciennes ajoutées à la liste, nous créerons un labyrinthe avec l'indice de rendement le plus bas possible, même inférieur à celui de l'algorithme Prim.  Si vous choisissez généralement la toute dernière cellule, mais que vous choisissez parfois une cellule aléatoire, le labyrinthe aura un débit élevé, mais une solution courte et directe.  Si l'une des cellules les plus récentes est sélectionnée au hasard, le labyrinthe aura un faible débit, mais une solution longue et sinueuse. </li><li><img src="https://habrastorage.org/getpro/habr/post_images/3ee/6d6/3d0/3ee6d63d01f5e26e2f1c8b4a0f1e10e2.gif"><br><br>  <b>Algorithme de forêt en croissance</b> <b>:</b> il s'agit d'un algorithme plus généralisé combinant des types basés sur des arbres et des ensembles.  Il s'agit d'une extension de l'algorithme de croissance arborescente, qui comprend essentiellement plusieurs instances se développant simultanément.  Nous commençons avec toutes les cellules triées aléatoirement dans une liste de "nouvelles";  en outre, chaque cellule a son propre ensemble, comme au début de l'algorithme Kruskal.  Sélectionnez d'abord une ou plusieurs cellules en les déplaçant de la liste des «nouvelles» vers la liste des «actives».  Sélectionnez une cellule dans la liste "active" et découpez le passage à la cellule non créée suivante dans la liste "nouvelle", en ajoutant une nouvelle cellule à la liste des "actifs" et en combinant les ensembles de deux cellules.  Si une tentative est faite pour couper dans la partie existante du labyrinthe, activez-la si les cellules sont dans des ensembles différents et combinez les cellules, comme cela se fait dans l'algorithme de Kraskal.  S'il n'y a pas de «nouvelles» cellules près de la cellule actuelle, déplacez la cellule actuelle vers la liste des cellules «terminées».  Le labyrinthe est terminé lorsque la liste des "actifs" devient vide.  À la fin, nous combinons tous les ensembles restants, comme dans l'algorithme de Kruskal.  Périodiquement, vous pouvez créer de nouveaux arbres en déplaçant une ou plusieurs cellules de la liste des "nouveaux" vers la liste des "actifs", comme cela a été fait au début.  En contrôlant le nombre d'arbres d'origine et les parts des arbres nouvellement créés, vous pouvez générer de nombreuses textures uniques qui se combinent avec les paramètres déjà flexibles de l'algorithme de croissance des arbres. </li><li><img src="https://habrastorage.org/getpro/habr/post_images/0df/4b2/2af/0df4b22af0d9c528721505c5863baa81.gif"><br><br>  <b>Algorithme d'Eller</b> <b>:</b> il s'agit d'un algorithme spécial, car il est non seulement plus rapide que tout le monde, mais n'a pas non plus de biais ou de lacunes évidents;  en outre, lors de sa création, la mémoire est utilisée plus efficacement.  Il ne nécessite même pas que tout le labyrinthe soit en mémoire, il utilise un volume proportionnel à la taille de la ligne.  Il crée un labyrinthe ligne par ligne, une fois la génération de la chaîne terminée, l'algorithme n'en tient plus compte.  Chaque cellule d'une rangée est contenue dans un ensemble;  deux cellules appartiennent au même ensemble s'il y a un chemin entre elles le long du labyrinthe déjà créé.  Ces informations vous permettent de découper des passages dans la ligne actuelle sans créer de boucles ou de zones isolées.  En fait, il est assez similaire à l'algorithme de Kraskal, seulement ici il est formé une ligne à la fois, tandis que Kraskal regarde à travers tout le labyrinthe.  La création d'une ligne se compose de deux parties: connectez de manière aléatoire les cellules adjacentes de la ligne, c'est-à-dire  nous coupons les passages horizontaux, puis connectons au hasard les cellules entre la ligne actuelle et la ligne suivante, c'est-à-dire  découpez les passages verticaux.  Lors de la découpe de passages horizontaux, nous ne connectons pas les cellules qui sont déjà dans le même ensemble (car une boucle sera créée autrement), et lors de la découpe de passages verticaux, nous devons connecter une cellule si elle a une taille d'unité (car si vous la laissez, cela créera une zone isolée).  Lors de la découpe de passages horizontaux, nous connectons les cellules si elles sont dans le même ensemble (car maintenant il y a un chemin entre elles), et lors de la découpe des passages verticaux lorsque nous ne nous connectons pas avec la cellule, nous le mettons dans un ensemble séparé (car maintenant il est séparé du reste du labyrinthe) )  La création commence par le fait qu'avant de connecter les cellules de la première ligne, chaque cellule a son propre ensemble.  La création est terminée une fois les cellules connectées dans la dernière ligne.  Il existe une règle spéciale d'achèvement: au moment de l'achèvement, chaque cellule doit être dans le même ensemble afin d'éviter les zones isolées.  (La dernière ligne est créée en combinant chacune des paires de cellules voisines qui ne sont pas encore dans le même ensemble.) Il est préférable d'implémenter l'ensemble en utilisant une liste cyclique de cellules doublement liées (qui peut être juste un tableau qui lie des cellules à des paires de cellules des deux côtés du même ensemble), permettant effectuer l'insertion, la suppression et la vérification de la présence de cellules voisines dans un ensemble pendant un temps constant.  Le problème avec cet algorithme est le déséquilibre dans le traitement des différents bords du labyrinthe;  Pour éviter les taches dans les textures, vous devez connecter et ignorer les cellules de connexion dans les bonnes proportions. </li><li> <b><img src="https://habrastorage.org/getpro/habr/post_images/50c/8cc/ddc/50c8ccddc7242a00cf9dd62fba696ed2.gif"><br><br></b>  <b>Division récursive:</b> cet algorithme est quelque peu similaire au backtracking récursif, car ils utilisent tous deux des piles, seulement il ne fonctionne pas avec les allées, mais avec les murs.  Nous commençons par créer un mur horizontal ou vertical aléatoire qui intersecte une zone accessible dans une ligne ou une colonne aléatoire, et placons au hasard des espaces vides le long de celle-ci.  Ensuite, nous répétons récursivement le processus pour les deux sous-régions générées par le mur de séparation.  Pour de meilleurs résultats, vous devez ajouter une déviation dans le choix de l'horizontale ou de la verticale en fonction des proportions de la zone, par exemple, une zone dont la largeur est le double de la hauteur doit être plus souvent divisée par des murs verticaux.  C'est l'algorithme le plus rapide sans déviation de direction, et souvent il peut même rivaliser avec des labyrinthes basés sur des arbres binaires, car il crée plusieurs cellules en même temps, bien qu'il présente un inconvénient évident sous la forme de longues parois coupant l'intérieur du labyrinthe.  Cet algorithme est une sorte de labyrinthe fractal intégré, mais au lieu de créer constamment des labyrinthes de cellules de taille fixe avec des labyrinthes de même taille à l'intérieur de chaque cellule, il divise au hasard une zone donnée en un labyrinthe de taille aléatoire: 1x2 ou 2x1.  La division récursive ne peut pas être utilisée pour découper des passages, car cela conduit à la création d'une solution évidente qui suit le long du bord extérieur ou intersecte directement l'intérieur. </li><li><img src="https://habrastorage.org/getpro/habr/post_images/d01/81f/8a0/d0181f8a04730302dbe6d88d0dc91431.gif"><br><br>  <b>Labyrinthes basés sur des arbres binaires</b> <b>:</b> en fait, ce sont les algorithmes les plus simples et les plus rapides possibles, cependant, les labyrinthes créés ont une texture avec un biais très élevé.  Pour chaque cellule, nous coupons un passage vers le haut ou vers la gauche, mais jamais dans les deux sens.  Dans la version avec ajout de murs, un segment de mur est ajouté pour chaque sommet menant vers le bas ou vers la droite, mais pas dans les deux directions.  Chaque cellule est indépendante de toutes les autres cellules, car nous n'avons pas besoin de vérifier l'état de certaines autres cellules lors de sa création.  Il s'agit donc d'un véritable algorithme de génération de labyrinthes sans mémoire, non limité par la taille des labyrinthes créés.  En fait, il s'agit d'un arbre binaire, si nous considérons le coin supérieur gauche comme une racine, et chaque nœud ou cellule a un nœud parent unique, qui est une cellule au-dessus ou à gauche de celui-ci.  Les labyrinthes basés sur des arbres binaires sont différents des labyrinthes idéaux standard, car plus de la moitié des types de cellules ne peuvent pas exister en eux.  Par exemple, il n'y aura jamais d'intersections et toutes les impasses ont des passages menant vers le haut ou vers la gauche, et ne menant jamais vers le bas ou vers la droite.  Les labyrinthes ont tendance à avoir des passages menant en diagonale du coin supérieur gauche au coin inférieur droit, et il est beaucoup plus facile de se déplacer du coin inférieur droit au coin supérieur gauche.  Vous pouvez toujours vous déplacer vers le haut ou vers la gauche, mais jamais simultanément dans les deux sens, vous pouvez donc toujours vous déplacer de manière déterministe en diagonale vers le haut et vers la gauche, sans rencontrer d'obstacles.  Vous aurez la possibilité de choisir et de tomber dans des impasses en vous déplaçant vers le bas et vers la droite. ,            ,  ,        . </li><li> <b><img src="https://habrastorage.org/getpro/habr/post_images/f3f/f8c/58c/f3ff8c58c53fce1c8d57401f7f41c924.gif"><br><br>  Sidewinder:</b>         ,    .       :      ,    ,  .    ,   ,      ,       ,  ,   .           ,     (    ,      ).                ,  sidewinder     .              ,    sidewinder        .     ,  sidewinder        ,          ,  .   sidewinder            ,   «    ».   ,       sidewinder —      ,      ,   ,  ,    .  sidewinder     ,       ,         ,   . </li></ul><br><table><tbody><tr><td> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Algorithme</font></font></b> </td><td> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">% impasses</font></font></b> </td><td> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tapez</font></font></b> </td><td> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Priorité</font></font></b> </td><td> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pas de parti pris?</font></font></b> </td><td> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Homogène?</font></font></b> </td><td> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La mémoire</font></font></b> </td><td> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le temps</font></font></b> </td><td> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">% solution</font></font></b> </td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Itinéraire unique </font></font></td><td>  0 </td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Arbre </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Les murs </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Oui </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Jamais </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> N ^ 2 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 379 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 100,0 </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Backtracker récursif </font></font></td><td>  10 </td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Arbre </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Passerelles </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Oui </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Jamais </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> N ^ 2 </font></font></td><td>  27 </td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 19,0 </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Chasser et tuer </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 11 (21) </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Arbre </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Passerelles </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Oui </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Jamais </font></font></td><td>  0 </td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 100 (143) </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 9,5 (3,9) </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Division récursive </font></font></td><td>  23 </td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Arbre </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Les murs </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Oui </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Jamais </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> N * </font></font></td><td>  10 </td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 7.2 </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Arbre binaire </font></font></td><td>  25 </td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Beaucoup </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Les deux </font></font></td><td>  Non </td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Jamais </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0 * </font></font></td><td>  10 </td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 2.0 </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Sidewinder </font></font></td><td>  27 </td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Beaucoup </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Les deux </font></font></td><td>  Non </td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Jamais </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0 * </font></font></td><td>  12 </td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 2.6 </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Algorithme Eller </font></font></td><td>  28 </td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Beaucoup </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Les deux </font></font></td><td>  Non </td><td>  Non </td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> N * </font></font></td><td>  20 </td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 4,2 (3,2) </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Algorithme de Wilson </font></font></td><td>  29 </td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Arbre </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Les deux </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Oui </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Oui </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> N ^ 2 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 48 (25) </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 4.5 </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Algorithme Aldous-Broder </font></font></td><td>  29 </td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Arbre </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Les deux </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Oui </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Oui </font></font></td><td>  0 </td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 279 (208) </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 4.5 </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Algorithme de Kraskal </font></font></td><td>  30 </td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Beaucoup </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Les deux </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Oui </font></font></td><td>  Non </td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> N ^ 2 </font></font></td><td>  33 </td><td>  4.1 </td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Algorithme Prima (vrai) </font></font></td><td>  30 </td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Arbre </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Les deux </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Oui </font></font></td><td>  Non </td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> N ^ 2 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 160 </font></font></td><td>  4.1 </td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Algorithme Prima (simplifié) </font></font></td><td>  32 </td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Arbre </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Les deux </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Oui </font></font></td><td>  Non </td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> N ^ 2 </font></font></td><td>  59 </td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 2.3 </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Algorithme Prima (modifié) </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 36 (31) </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Arbre </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Les deux </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Oui </font></font></td><td>  Non </td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> N ^ 2 </font></font></td><td>  30 </td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 2.3 </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> La croissance des arbres </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 49 (39) </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Arbre </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Les deux </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Oui </font></font></td><td>  Non </td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> N ^ 2 </font></font></td><td>  48 </td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 11,0 </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Croissance des forêts </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 49 (39) </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Les deux </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Les deux </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Oui </font></font></td><td>  Non </td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> N ^ 2 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 76 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 11,0 </font></font></td></tr></tbody></table><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ce tableau résume les caractéristiques des algorithmes de création de labyrinthes idéaux décrits ci-dessus. </font><font style="vertical-align: inherit;">À titre de comparaison, un algorithme de labyrinthe à itinéraire unique a été ajouté (théoriquement, les labyrinthes à itinéraire unique sont idéaux). </font><font style="vertical-align: inherit;">Explication de la colonne:</font></font><br><br><ul><li> <b>:</b>    ,    ,     ,    2D-.       .       ,     ,     ,        .           10% (     )  49% (    ).        Recursive Backtracker    1%.           66%:              . </li><li> <b>:</b>       :        ,    ,           .       ,   ,   ,    ,           .  ,    ,    . </li><li> <b>:</b>        ,    .          .       ,           ,       . Recursive Backtracker     ,          ,    ,          . ,        ,       .  , Hunt and Kill          ,        ,            . </li><li> <b> :</b>          ,          .     ,           . Sidewinder  ,           .      ,      .  Hunt and Kill  ,      ,     ,       . </li><li> <b>:</b>         . «» ,    . «» ,            ,     . «» ,    ,      . ,           . </li><li> <b>:</b>     ,    .        ,        ,    (N),     (N^2).          ,        (   ).        ,     ,        .  Sidewinder       ,           .          ,         . </li><li> <b>:</b>      ,          ,   ,    .      ,       (     10),          .         100x100    Daedalus.         ,     ,     ,       . </li><li> <b>:</b>    ,        ,  .  ,     100x100 .        .     «»  .     ,       .      ,                  .        ,    ,     ,         . </li></ul><br><h2>    </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Il existe de nombreuses façons de résoudre des labyrinthes, et chacun d'eux a ses propres caractéristiques. </font><font style="vertical-align: inherit;">Voici une liste d'algorithmes spécifiques:</font></font><br><br><ul><li><img src="https://habrastorage.org/getpro/habr/post_images/62b/7f0/7c6/62b7f07c68ae7a9544c6ad481577e816.gif"><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Suivre le long des murs (suiveur de mur) </font></font></b> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font></b>     .        («»),         .            (  ).        ,      ( )           .         ,  .       ,    ,   .      ,     ,           ,             .     3D-    ,  3D-  2D-, .. ,          -,      -,        . </li><li><img src="https://habrastorage.org/getpro/habr/post_images/d5b/25c/4de/d5b25c4de2e848708f6f9ba70a47957f.gif"><br><br> <b> </b> <b>:</b>      ,    «»    ,      .          2D-    ,       , ..    .           ,        ,         .            .   ,    ,        .  ,         ,    .       ,             ,   .        , ,   —  -1,    —  1.            ,      , ..     360   ,        «».  ,         «»,      ,        ,      ,      ,         .  ,             ,           .      ,    —    ,              . </li><li><img src="https://habrastorage.org/getpro/habr/post_images/885/45e/39a/88545e39a856cc77b791086ebc958e0c.gif"><br><br> <b> </b> <b>:</b>   (Chain algorithm)  ,        (  )     .        ,         ,   .       ,    .  ,      ,      .      ,              .      (     )    ,      .         .     ,      ,    .      «»      ,   .          ,     ,       ,      .       ,    .          ,         . </li><li> <b><img src="https://habrastorage.org/getpro/habr/post_images/402/cba/ed2/402cbaed27df8e2319b04647f963dc2e.gif"><br><br> Recursive backtracker:</b>    ,     .       ,              .   :      (    ),   «», ,     ,  «», ,       .  ,         ,    «»;    «»       .    (backtracking)       ,      ,    .  ,       .     ,   ,      . </li><li> <b><img src="https://habrastorage.org/getpro/habr/post_images/965/84c/528/96584c52805bc66d81e23eeae05b2057.gif"><br><br>   (Trémaux's algorithm):</b>          .    recursive backtracker      :         ,   .           ,  .   ,     ,     .          ,   ,         ,  . (     ,           .)    ,     (..  ),    ,     ,   ,       (.. ,    ).     ,       ,   ,        ,   ,             .     ,            .     ,     ,      . </li><li><img src="https://habrastorage.org/getpro/habr/post_images/949/1f9/5b9/9491f95b97951ee9f10551bb24187e94.gif"><br><br> <b>  (Dead end filler)</b> <b>:</b>     .     ,         .        ,       ,    .         ,        .       ,   ,      .         ,         ,           . </li><li><img src="https://habrastorage.org/getpro/habr/post_images/af6/640/839/af6640839e35705adb99b781278d56a9.gif"><br><br> <b>Cul-de-sac filler</b> <b>:</b>         ,     ,         .    dead end filler,    ,        .        (  —   ,           ,      )  ,       .    dead end filler.     ,    ,       ,     ,       .       ,   ,     ,   dead end filler. </li><li><img src="https://habrastorage.org/getpro/habr/post_images/a01/d27/475/a01d27475d474454f478264e022e0383.gif"><br><br> <b>Blind alley filler</b> <b>:</b>      ,    ,     .   ,    .   —   ,      ,             .     ,    ,    cul-de-sac filler,      .       .    ,    , ,  ,  .            ,   ,  ,          (           ).   ,             ,          .      ,   cul-de-sac filler  - ,     collision solver    ,      - . </li><li><img src="https://habrastorage.org/getpro/habr/post_images/105/ade/5a7/105ade5a7dd7cbce67bcbd57d3ba3b7e.gif"><br><br> <b>Blind alley sealer</b> <b>:</b>     blind alley filler ,       ,     .                 .               .     ,   ,  blind alley filler,     .         .   ,    ,     ,        ,        .  ,      ,     .          ,     .      ,          ,   .  ,               ,    . </li><li> <b><img src="https://habrastorage.org/getpro/habr/post_images/5e2/562/508/5e25625080da8af3396476127a2cc9ed.gif"><br><br>    (Shortest path finder):</b>     ,     ,        .        ,           ,   .   collision solver, ,  ,   «» ,          (      ),   «»  , ,     .      «»,       ,     .        ,             -    ,    .  ,  ,  ,    A*  ,       . </li><li><img src="https://habrastorage.org/getpro/habr/post_images/396/221/e2e/396221e2ed8b51be85c22fc94f5610db.gif"><br><br> <b>   (Shortest paths finder)</b> <b>:</b>       ,     .     ,        ,     ,   ,   ,       ,    ,     -     ,    .  ,     ,     ,   «» ,         ,     ,      .         ,   ,       ,      ,    .         ,                  . </li><li> <b>Collision solver:</b>   "amoeba" solver.      .        ,                        .    «» ,          (  ).   « »       (   ),       ,   .      «»,     ,       ,   ,     . ( ,    «»,     .   ,      ,         ,    .)  ,   shortest paths finder,     (           )    (         ). </li><li> <b>Random mouse:</b>       ,       , ..            ,      .       180 ,     .    ,       ,    .         ,           ,          . </li></ul><br><table><tbody><tr><td> <b></b> </td><td> <b></b> </td><td> <b>?</b> </td><td> <b></b> </td><td> <b> ?</b> </td><td> <b>  ?</b> </td><td> <b>  ?</b> </td><td> <b>?</b> </td></tr><tr><td> Random Mouse </td><td>  1 </td><td>  Non </td><td>  Tu es </td><td>  /  </td><td>  Non </td><td>  </td><td>  Non </td></tr><tr><td> Wall Follower </td><td>  1 </td><td>  Non </td><td>  Tu es </td><td>  /  </td><td>  </td><td>  </td><td>  </td></tr><tr><td>   </td><td>  1 </td><td>  Non </td><td>  Tu es </td><td>  /  </td><td>  </td><td>  </td><td>  </td></tr><tr><td>   </td><td>  1 </td><td>  </td><td> + </td><td>  Non </td><td>  </td><td>  Non </td><td>  </td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Backtracker récursif </font></font></td><td>  1 </td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Oui </font></font></td><td>  Tu es </td><td>  Non </td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Oui </font></font></td><td>  Non </td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Oui </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Algorithme Tremo </font></font></td><td>  1 </td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Oui </font></font></td><td>  Tu es </td><td> À l'intérieur / sur </td><td>  Non </td><td>  Non </td><td>  Oui </td></tr><tr><td>  Remplisseur de cul-de-sac </td><td>  Tous + </td><td>  Non </td><td>  Labyrinthe </td><td>  Plus </td><td>  Non </td><td>  Oui </td><td>  Oui </td></tr><tr><td>  Remplisseuse cul-de-sac </td><td>  Tous + </td><td>  Non </td><td>  Labyrinthe </td><td>  Plus </td><td>  Non </td><td>  Oui </td><td>  Oui </td></tr><tr><td>  Scellant pour allées aveugles </td><td>  Tous + </td><td>  Oui </td><td>  Labyrinthe </td><td>  Non </td><td>  Non </td><td>  Non </td><td>  Oui </td></tr><tr><td>  Remplisseur de ruelle aveugle </td><td>  Tous </td><td>  Oui </td><td>  Labyrinthe </td><td>  Plus </td><td>  Non </td><td>  Oui </td><td>  Non </td></tr><tr><td>  Solveur de collision </td><td>  Tout court </td><td>  Oui </td><td>  Vous + </td><td>  Non </td><td>  Non </td><td>  Non </td><td>  Oui </td></tr><tr><td>  Rechercher les chemins les plus courts </td><td>  Tout court </td><td>  Oui </td><td>  Vous + </td><td>  Non </td><td>  Oui </td><td>  Non </td><td>  Oui </td></tr><tr><td>  Rechercher le chemin le plus court </td><td>  1 plus court </td><td>  Oui </td><td>  Vous + </td><td>  Non </td><td>  Oui </td><td>  Non </td><td>  Oui </td></tr></tbody></table><br>  Ce tableau répertorie brièvement les caractéristiques des algorithmes de résolution de labyrinthe décrits ci-dessus.  Selon ces critères, il est possible de classer et d'évaluer des algorithmes de résolution de labyrinthes.  Explications des colonnes: <br><br><ul><li>  <b>Solutions:</b> décrit les solutions trouvées par l'algorithme et les actions de l'algorithme, s'il y en a plusieurs.  L'algorithme peut choisir une solution ou en laisser plusieurs.  De plus, la ou les solutions peuvent être n'importe quel chemin ou le chemin le plus court.  Le remplissage en cul-de-sac et le cul-de-sac (ainsi que le scellant pour allée aveugle lors du traitement de ses zones inaccessibles) laissent toutes les solutions, mais ils peuvent également laisser des passages qui ne se trouvent dans aucun des chemins de solution, je les ai donc marqués comme «Tous + ". </li><li>  <b>Garantie:</b> L'algorithme est-il garanti pour trouver au moins une solution?  Pour la souris aléatoire, «non» est indiqué, car son achèvement n'est pas garanti, et pour le suiveur de mur et l'algorithme du Collège, «non» est indiqué, car ils ne pourront pas trouver de solution si la cible est à l'intérieur de l'île.  «Dead» est indiqué pour les enduits sans issue et les enduits en cul-de-sac, car dans les labyrinthes en osier, ils peuvent ne pas trouver de solution. </li><li>  <b>Priorité:</b> Il existe deux types d'algorithmes pour résoudre le labyrinthe: donner la priorité à «vous» (situé dans le labyrinthe) ou donner la priorité au labyrinthe.  Si la priorité vous est donnée, alors nous avons un point («Vous» est indiqué dans le tableau) ou plusieurs points («Vous +») et l'algorithme essaie de les dessiner du début à la fin du labyrinthe.  Si la priorité est donnée au labyrinthe, alors nous examinons le labyrinthe dans son ensemble et éliminons les passages inutiles. </li><li>  <b>Disponible pour l'homme:</b> un homme peut-il utiliser l'algorithme pour résoudre le labyrinthe, soit dans le vrai labyrinthe, soit en regardant la carte d'en haut.  Certains des algorithmes qui donnent la priorité à «vous» peuvent être implémentés en tant que personne à l'intérieur du labyrinthe (ou au-dessus), et certains qui donnent la priorité au labyrinthe peuvent être implémentés en tant que personne, mais uniquement au-dessus du labyrinthe.  D'autres algorithmes sont trop complexes et leur implémentation fiable n'est possible que sur ordinateur. </li><li>  <b>Pass indépendant:</b> l'algorithme peut-il s'exécuter n'importe où.  Certains algorithmes exigent que le labyrinthe ait des passages évidents ou, en parlant dans la terminologie des graphiques, des bords nets entre les sommets individuels, ou des passages d'un pixel lorsqu'il est implémenté sur un ordinateur.  Le suiveur de mur, l'algorithme Pledge et l'algorithme de circuit nécessitent un mur uniquement sur un côté de vous.  Le backtracker récursif et le plus court localisateur de chemin acheminent le leur à travers des espaces ouverts. </li><li>  <b>Aucune mémoire requise:</b> avez-vous besoin de mémoire supplémentaire ou d'une pile pour implémenter l'algorithme.  Les algorithmes efficaces ne nécessitent qu'une image bitmap du labyrinthe lui-même et ils n'ont pas besoin d'ajouter de marqueurs au labyrinthe dans le processus de résolution. </li><li>  <b>Rapide:</b> le processus de décision est-il considéré comme rapide?  Les algorithmes les plus efficaces suffisent à ne regarder chaque cellule du labyrinthe qu'une seule fois, ou ils peuvent en ignorer complètement certaines parties.  Le temps d'exécution doit être proportionnel à la taille du labyrinthe, ou O (n ^ 2), où n est le nombre de cellules le long d'un côté.  La souris aléatoire est lente car son achèvement n'est pas garanti, et le remplissage en allée aveugle résout potentiellement le labyrinthe de chaque fourche. </li></ul><br><h2>  Autres opérations avec des labyrinthes </h2><br>  En plus de créer et de résoudre des labyrinthes, vous pouvez effectuer d'autres opérations avec eux: <br><br><ul><li> <b><img src="https://habrastorage.org/getpro/habr/post_images/6f7/fee/d6d/6f7feed6d3542670945c7601c6d17656.gif"><br><br></b>  <b>Fill:</b> c'est une fonction «rapide et sale», mais néanmoins utile qui peut être implémentée en un seul appel à la procédure de bibliothèque graphique Fill ou FloodFill.  Nous effectuons le FloodFill du passage au début, et si la fin n'est pas inondée, alors le labyrinthe n'a pas de solution.  Dans les labyrinthes, dont l'entrée et la sortie sont sur les bords, nous effectuons le FloodFill d'un mur, et les bords restants marquent la solution.  Dans les labyrinthes où le début et la fin sont à l'intérieur, nous exécutons le FloodFill du mur d'enceinte, et si le mur de sortie n'a pas été supprimé, ce labyrinthe ne peut pas être résolu en suivant le long des murs.  De nombreuses méthodes de création de labyrinthes et d'autres fonctions utilisent le "remplissage" du labyrinthe à certains points. </li><li> <b><img src="https://habrastorage.org/getpro/habr/post_images/f09/223/2e3/f092232e3f56154a43c81d5b71eee6c2.gif"><br><br></b>  <b>Dissolvant d'isolement:</b> changez le labyrinthe afin qu'il ne comporte pas de parties avec des passages inaccessibles depuis le reste du labyrinthe.  Il est réalisé en enlevant les murs reliant ces parties avec le reste du labyrinthe.  Nous commençons par une copie du labyrinthe, puis remplissons le passage vers le début.  Nous scannons le labyrinthe (de préférence dans un ordre aléatoire, mais avec une visite à toutes les cellules possibles) pour la présence de cellules non remplies adjacentes à la cellule remplie.  Nous supprimons le segment de mur à ce point dans le labyrinthe d'origine, remplissons le labyrinthe à ce nouveau point et répétons jusqu'à ce que toutes les pièces soient remplies.  Cette fonction est utilisée pour créer des labyrinthes tissés et à motifs. </li><li> <b><img src="https://habrastorage.org/getpro/habr/post_images/e02/4fb/283/e024fb2832bd8e5d855b80393a75cf67.gif"><br><br></b>  <b>Suppression des boucles:</b> modifiez le labyrinthe afin qu'il n'y ait pas de boucles et de murs qui ne soient connectés à rien, et que chaque partie du labyrinthe soit accessible à partir de n'importe quel point d'une seule manière.  La mise en œuvre de cette fonction est presque similaire à la suppression des zones isolées, seulement nous percevons les murs comme des passages, et vice versa.  Nous commençons par une copie du labyrinthe, puis remplissons les murs extérieurs.  Nous scannons le labyrinthe (de préférence dans un ordre aléatoire, mais avec une visite à tous les sommets de murs possibles) pour la présence de murs non remplis à côté de ceux remplis.  Ajoutez un segment de mur reliant les deux parties des murs au labyrinthe d'origine à ce stade, remplissez le labyrinthe à ce nouveau point et répétez jusqu'à ce que toutes les parties soient remplies.  Cette fonction est utilisée pour créer des labyrinthes modèles et peut être utilisée pour convertir des labyrinthes en osier à des labyrinthes idéaux, qui restent néanmoins similaires aux originaux. </li><li><img src="https://habrastorage.org/getpro/habr/post_images/ea4/f95/188/ea4f951888f580d0a1446246e20e0ea1.gif"><br><br>  <b>Rechercher les goulots d'étranglement</b> <b>:</b> Rechercher dans le dédale de passages ou de points d'intersection par lesquels passent toutes les solutions de ce dédale.  Pour ce faire, commencez à suivre le long des murs avec la méthode de la main gauche pour obtenir la solution de gauche et commencez à suivre le long des murs avec la méthode de la main droite pour obtenir la bonne solution.  Les endroits où les deux solutions sont communes sont des goulots d'étranglement.  Cependant, cette technique ne fonctionne que pour les labyrinthes, qui peuvent être résolus avec succès en suivant le long des murs.  Dans d'autres labyrinthes, pour trouver des goulots d'étranglement, vous devez trouver n'importe quelle solution, ainsi que exécuter un scellant pour allée aveugle (cela peut rendre le labyrinthe insoluble s'il perçoit l'entrée ou la sortie à l'intérieur du labyrinthe comme une grande impasse).  Des parties du chemin de solution passant par des passages fermés sont des goulots d'étranglement. </li></ul><br><h2>  Implémentations d'algorithmes </h2><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><b>Daedalus</b></a> <b>:</b> tous les algorithmes de création et de résolution de labyrinthes décrits ci-dessus sont implémentés dans Daedalus, un programme Windows gratuit et téléchargeable.  Complet avec Daedalus il y a un code source complet. </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr445378/">https://habr.com/ru/post/fr445378/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr445362/index.html">Le livre "Distributed Systems. Modèles de conception</a></li>
<li><a href="../fr445366/index.html">Comment accélérer le cryptage selon GOST 28147-89 sur le processeur Baikal-T1 en raison du bloc SIMD</a></li>
<li><a href="../fr445368/index.html">Test de charge d'un jeu avec quelques centaines de milliers d'utilisateurs virtuels</a></li>
<li><a href="../fr445370/index.html">Analyse TSDB dans Prométhée 2</a></li>
<li><a href="../fr445372/index.html">Vision industrielle vs intuition humaine: algorithmes pour perturber le fonctionnement des programmes de reconnaissance d'objets</a></li>
<li><a href="../fr445380/index.html">Le PHP moderne est beau et productif</a></li>
<li><a href="../fr445384/index.html">Mission Chang'e-4 - équipement scientifique sur le module d'atterrissage et le satellite répéteur</a></li>
<li><a href="../fr445390/index.html">IDE d'une personne normale ou pourquoi nous avons choisi Monaco</a></li>
<li><a href="../fr445392/index.html">Remarketing dynamique MyTarget: recommandations de produits non personnels</a></li>
<li><a href="../fr445394/index.html">Modifications du protocole 3D Secure: rencontrez 3-D Secure 2.0</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>