<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë®üèø‚Äç‚úàÔ∏è üòá ü§úüèæ Python und schnelle HTTP-Clients üëò üóÇÔ∏è üî•</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Wenn Sie heutzutage eine Art Python-Anwendung schreiben, m√ºssen Sie diese h√∂chstwahrscheinlich mit der Funktionalit√§t eines HTTP-Clients ausstatten, d...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Python und schnelle HTTP-Clients</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/472858/">  Wenn Sie heutzutage eine Art Python-Anwendung schreiben, m√ºssen Sie diese h√∂chstwahrscheinlich mit der Funktionalit√§t eines HTTP-Clients ausstatten, der mit HTTP-Servern kommunizieren kann.  Die Allgegenwart der REST-API hat HTTP-Tools zu einer angesehenen Funktion in unz√§hligen Softwareprojekten gemacht.  Aus diesem Grund muss jeder Programmierer Muster besitzen, um die optimale Arbeit mit HTTP-Verbindungen zu organisieren. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/webt/fv/ix/xt/fvixxt-a-wwkrs5vivurfucn5pe.jpeg"></a> <br><br>  Es gibt viele HTTP-Clients f√ºr Python.  Die h√§ufigste unter ihnen und au√üerdem die, mit der man leicht arbeiten kann, kann als <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Anfrage bezeichnet werden</a> .  Heute ist dieser Kunde der De-facto-Standard. <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">Permanente Verbindungen</font> </h2><br>  Die erste Optimierung, die bei der Arbeit mit HTTP ber√ºcksichtigt werden muss, ist die Verwendung dauerhafter Verbindungen zu Webservern.  Permanente Verbindungen sind seit HTTP 1.1 zum Standard geworden, werden jedoch von vielen Anwendungen immer noch nicht verwendet.  Dieser Mangel ist leicht zu erkl√§ren, da bei Verwendung der <code>requests</code> im einfachen Modus (z. B. mithilfe der <code>get</code> Methode) die Verbindung zum Server nach Erhalt einer Antwort von diesem Server geschlossen wird.  Um dies zu vermeiden, muss die Anwendung das <code>Session</code> Objekt verwenden, mit dem offene Verbindungen wiederverwendet werden k√∂nnen: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> requests session = requests.Session() session.get(<span class="hljs-string"><span class="hljs-string">"http://example.com"</span></span>) <span class="hljs-comment"><span class="hljs-comment">#    session.get("http://example.com")</span></span></code> </pre> <br>  Verbindungen werden im Verbindungspool gespeichert (standardm√§√üig werden 10 Verbindungen verwendet).  Die Poolgr√∂√üe kann angepasst werden: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> requests session = requests.Session() adapter = requests.adapters.HTTPAdapter(    pool_connections=<span class="hljs-number"><span class="hljs-number">100</span></span>,    pool_maxsize=<span class="hljs-number"><span class="hljs-number">100</span></span>) session.mount(<span class="hljs-string"><span class="hljs-string">'http://'</span></span>, adapter) response = session.get(<span class="hljs-string"><span class="hljs-string">"http://example.org"</span></span>)</code> </pre> <br>  Die Wiederverwendung einer TCP-Verbindung zum Senden mehrerer HTTP-Anforderungen bietet der Anwendung viele Leistungsvorteile: <br><br><ul><li>  Reduzierung der Prozessorlast und Reduzierung des RAM-Bedarfs (aufgrund der Tatsache, dass weniger Verbindungen gleichzeitig ge√∂ffnet sind). </li><li>  Reduzieren von Verz√∂gerungen bei der Ausf√ºhrung von Anforderungen, die nacheinander eingehen (es gibt keine TCP-Handshake-Prozedur). </li><li>  Ausnahmen k√∂nnen ohne zus√§tzliche Zeit ausgel√∂st werden, um die TCP-Verbindung zu schlie√üen. </li></ul><br>  HTTP 1.1 unterst√ºtzt auch das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Pipelining</a> von Anforderungen.  Auf diese Weise k√∂nnen Sie mehrere Anforderungen innerhalb derselben Verbindung senden, ohne auf Antworten auf zuvor gesendete Anforderungen zu warten (dh Anforderungen in "Paketen" zu senden).  Leider unterst√ºtzt die <code>requests</code> diese Funktion nicht.  Pipelining-Anforderungen sind jedoch m√∂glicherweise nicht so schnell wie die parallele Verarbeitung.  Au√üerdem ist es angebracht, darauf zu achten: Antworten auf "Paket" -Anfragen sollten vom Server in derselben Reihenfolge gesendet werden, in der er diese Anfragen erhalten hat.  Das Ergebnis ist nicht das effizienteste Anforderungsverarbeitungsschema nach dem FIFO-Prinzip (‚Äûfirst in, first out‚Äú - ‚Äûfirst come, first Leave‚Äú). <br><br><h2>  <font color="#3AC1EF">Parallele Abfrageverarbeitung</font> </h2><br>  <code>requests</code> auch einen weiteren schwerwiegenden Nachteil.  Dies ist eine synchrone Bibliothek.  Ein Methodenaufruf wie <code>requests.get("http://example.org")</code> blockiert das Programm, bis eine vollst√§ndige HTTP-Serverantwort empfangen wird.  Die Tatsache, dass die Anwendung warten und nichts tun muss, kann als Minus dieses Organisationsschemas f√ºr die Interaktion mit dem Server angesehen werden.  Ist es m√∂glich, das Programm dazu zu bringen, etwas N√ºtzliches zu tun, anstatt nur zu warten? <br><br>  Eine intelligent gestaltete Anwendung kann dieses Problem durch die Verwendung eines Thread-Pools verringern, der dem von <code>concurrent.futures</code> bereitgestellten √§hnelt.  Auf diese Weise k√∂nnen Sie HTTP-Anforderungen schnell parallelisieren: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> concurrent <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> futures <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> requests <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> futures.ThreadPoolExecutor(max_workers=<span class="hljs-number"><span class="hljs-number">4</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> executor:    futures = [        executor.submit(            <span class="hljs-keyword"><span class="hljs-keyword">lambda</span></span>: requests.get(<span class="hljs-string"><span class="hljs-string">"http://example.org"</span></span>))        <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _ <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">8</span></span>)    ] results = [    f.result().status_code    <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> f <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> futures ] print(<span class="hljs-string"><span class="hljs-string">"Results: %s"</span></span> % results)</code> </pre> <br>  Dieses sehr n√ºtzliche Muster ist in der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Request-Futures-</a> Bibliothek implementiert.  Die Verwendung von <code>Session</code> ist jedoch f√ºr den Entwickler transparent: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> requests_futures <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> sessions session = sessions.FuturesSession() futures = [    session.get(<span class="hljs-string"><span class="hljs-string">"http://example.org"</span></span>)    <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _ <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">8</span></span>) ] results = [    f.result().status_code    <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> f <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> futures ] print(<span class="hljs-string"><span class="hljs-string">"Results: %s"</span></span> % results)</code> </pre> <br>  Standardm√§√üig wird ein Worker mit zwei Threads erstellt. Das Programm kann diesen Wert jedoch einfach festlegen, indem das Argument <code>FuturSession</code> oder sogar sein eigener Executor an das <code>FuturSession</code> Objekt √ºbergeben wird.  Zum Beispiel k√∂nnte es so aussehen: <br><br><pre> <code class="python hljs">FuturesSession(executor=ThreadPoolExecutor(max_workers=<span class="hljs-number"><span class="hljs-number">10</span></span>))</code> </pre> <br><h2>  <font color="#3AC1EF">Asynchrone Arbeit mit Anfragen</font> </h2><br>  Wie bereits erw√§hnt, ist die <code>requests</code> vollst√§ndig synchron.  Dies f√ºhrt dazu, dass Anwendungen blockiert werden, w√§hrend auf eine Antwort vom Server gewartet wird, was sich negativ auf die Leistung auswirkt.  Eine L√∂sung f√ºr dieses Problem besteht darin, HTTP-Anforderungen in separaten Threads auszuf√ºhren.  Die Verwendung von Threads ist jedoch eine zus√§tzliche Belastung f√ºr das System.  Dar√ºber hinaus bedeutet dies die Einf√ºhrung eines parallelen Datenverarbeitungsschemas in das Programm, das nicht f√ºr jeden geeignet ist. <br><br>  Ab Python 3.5 geh√∂ren zu den Standardsprachenfunktionen die asynchrone Programmierung mit <code>asyncio</code> .  Die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://aio">aiohttp-</a> Bibliothek bietet dem Entwickler einen asynchronen HTTP-Client, der auf <code>asyncio</code> basiert.  Mit dieser Bibliothek kann die Anwendung eine Reihe von Anforderungen senden und weiterarbeiten.  Um eine weitere Anfrage zu senden, m√ºssen Sie nicht auf eine Antwort auf eine zuvor gesendete Anfrage warten.  Im Gegensatz zum Pipelining von HTTP-Anforderungen sendet <code>aiohttp</code> Anforderungen parallel √ºber mehrere Verbindungen.  Dies vermeidet das oben beschriebene "FIFO-Problem".  So sieht die Verwendung von <code>aiohttp</code> aus: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> aiohttp <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> asyncio <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(url)</span></span></span><span class="hljs-function">:</span></span>    <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> aiohttp.ClientSession() <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> session:        <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> session.get(url) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> response:            <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> response loop = asyncio.get_event_loop() coroutines = [get(<span class="hljs-string"><span class="hljs-string">"http://example.com"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _ <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">8</span></span>)] results = loop.run_until_complete(asyncio.gather(*coroutines)) print(<span class="hljs-string"><span class="hljs-string">"Results: %s"</span></span> % results)</code> </pre> <br>  Alle oben beschriebenen Ans√§tze (mit <code>Session</code> , Streams, <code>concurrent.futures</code> oder <code>asyncio</code> ) bieten verschiedene M√∂glichkeiten, um HTTP-Clients zu beschleunigen. <br><br><h2>  <font color="#3AC1EF">Leistung</font> </h2><br>  Der folgende Code ist ein Beispiel, in dem der HTTP-Client Anforderungen an den <code>httpbin.org</code> Server sendet.  Der Server unterst√ºtzt eine API, die unter anderem ein System simulieren kann, dessen Beantwortung einer Anfrage lange dauert (in diesem Fall 1 Sekunde).  Hier werden alle oben diskutierten Techniken implementiert und ihre Leistung gemessen: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> contextlib <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> time <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> aiohttp <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> asyncio <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> requests <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> requests_futures <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> sessions URL = <span class="hljs-string"><span class="hljs-string">"http://httpbin.org/delay/1"</span></span> TRIES = <span class="hljs-number"><span class="hljs-number">10</span></span> @contextlib.contextmanager <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">report_time</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(test)</span></span></span><span class="hljs-function">:</span></span>    t0 = time.time()    <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span>    print(<span class="hljs-string"><span class="hljs-string">"Time needed for `%s' called: %.2fs"</span></span>          % (test, time.time() - t0)) <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> report_time(<span class="hljs-string"><span class="hljs-string">"serialized"</span></span>):    <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(TRIES):        requests.get(URL) session = requests.Session() <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> report_time(<span class="hljs-string"><span class="hljs-string">"Session"</span></span>):    <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(TRIES):        session.get(URL) session = sessions.FuturesSession(max_workers=<span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> report_time(<span class="hljs-string"><span class="hljs-string">"FuturesSession w/ 2 workers"</span></span>):    futures = [session.get(URL)               <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(TRIES)]    <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> f <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> futures:        f.result() session = sessions.FuturesSession(max_workers=TRIES) <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> report_time(<span class="hljs-string"><span class="hljs-string">"FuturesSession w/ max workers"</span></span>):    futures = [session.get(URL)               <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(TRIES)]    <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> f <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> futures:        f.result() <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(url)</span></span></span><span class="hljs-function">:</span></span>    <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> aiohttp.ClientSession() <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> session:        <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> session.get(url) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> response:            <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> response.read() loop = asyncio.get_event_loop() <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> report_time(<span class="hljs-string"><span class="hljs-string">"aiohttp"</span></span>):    loop.run_until_complete(        asyncio.gather(*[get(URL)                         <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(TRIES)]))</code> </pre> <br>  Hier sind die Ergebnisse, die nach dem Start dieses Programms erzielt wurden: <br><br><pre> <code class="python hljs">Time needed <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> `serialized<span class="hljs-string"><span class="hljs-string">' called: 12.12s Time needed for `Session'</span></span> called: <span class="hljs-number"><span class="hljs-number">11.22</span></span>s Time needed <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> `FuturesSession w/ <span class="hljs-number"><span class="hljs-number">2</span></span> workers<span class="hljs-string"><span class="hljs-string">' called: 5.65s Time needed for `FuturesSession w/ max workers'</span></span> called: <span class="hljs-number"><span class="hljs-number">1.25</span></span>s Time needed <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> `aiohttp<span class="hljs-string"><span class="hljs-string">' called: 1.19s</span></span></code> </pre> <br>  Hier ist eine Tabelle der Ergebnisse. <br><img src="https://habrastorage.org/getpro/habr/post_images/c84/655/e65/c84655e655fc6d400a4ffd2d932aaa61.png"><br>  <i><font color="#999999">Die Ergebnisse einer Studie zur Leistung verschiedener Methoden zum Erstellen von HTTP-Anforderungen</font></i> <br><br>  Es ist nicht √ºberraschend, dass sich das einfachste Ausf√ºhrungsschema f√ºr synchrone Abfragen als das langsamste herausstellte.  Der Punkt hier ist, dass hier die Abfragen einzeln ausgef√ºhrt werden, ohne die Verbindung wiederzuverwenden.  Daher dauert es 12 Sekunden, um 10 Abfragen abzuschlie√üen. <br><br>  Durch die Verwendung des <code>Session</code> und die Wiederverwendung von Verbindungen werden 8% der Zeit gespart.  Das ist schon sehr gut und das zu erreichen ist sehr einfach.  Jeder, der sich um die Leistung k√ºmmert, sollte mindestens das <code>Session</code> Objekt verwenden. <br><br>  Wenn Ihr System und Ihr Programm es Ihnen erm√∂glichen, mit Threads zu arbeiten, ist dies ein guter Grund, √ºber die Verwendung von Threads zum Parallelisieren von Anforderungen nachzudenken.  Streams verursachen jedoch eine zus√§tzliche Belastung des Systems, sie sind sozusagen nicht ‚Äûfrei‚Äú.  Sie m√ºssen erstellt und ausgef√ºhrt werden. Sie m√ºssen auf den Abschluss ihrer Arbeit warten. <br><br>  Wenn Sie den schnellen asynchronen HTTP-Client verwenden m√∂chten und nicht auf √§lteren Python-Versionen schreiben, sollten Sie <code>aiohttp</code> die gr√∂√üte Aufmerksamkeit <code>aiohttp</code> .  Dies ist die schnellste und am besten skalierbare L√∂sung.  Es ist in der Lage, Hunderte von gleichzeitigen Anforderungen zu verarbeiten. <br><br>  Eine Alternative zu <code>aiohttp</code> , keine besonders gute Alternative, besteht darin, Hunderte von Threads parallel zu verwalten. <br><br><h2>  <font color="#3AC1EF">Datenverarbeitung streamen</font> </h2><br>  Eine weitere Optimierung der Arbeit mit Netzwerkressourcen, die zur Verbesserung der Anwendungsleistung hilfreich sein kann, ist die Verwendung von Streaming-Daten.  Das Standard-Anforderungsverarbeitungsschema sieht folgenderma√üen aus: Die Anwendung sendet eine Anforderung, wonach der Hauptteil dieser Anforderung auf einmal geladen wird.  Mit dem <code>stream</code> Parameter, der die <code>requests</code> sowie das <code>content</code> der <code>aiohttp</code> Bibliothek unterst√ºtzt, k√∂nnen Sie sich von diesem Schema entfernen. <br><br>  So sieht die Organisation der Streaming-Datenverarbeitung mithilfe von <code>requests</code> aus: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> requests <span class="hljs-comment"><span class="hljs-comment">#  `with`          #     . with requests.get('http://example.org', stream=True) as r:    print(list(r.iter_content()))</span></span></code> </pre> <br>  So streamen Sie Daten mit <code>aiohttp</code> : <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> aiohttp <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> asyncio <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(url)</span></span></span><span class="hljs-function">:</span></span>    <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> aiohttp.ClientSession() <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> session:        <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> session.get(url) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> response:            <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> response.content.read() loop = asyncio.get_event_loop() tasks = [asyncio.ensure_future(get(<span class="hljs-string"><span class="hljs-string">"http://example.com"</span></span>))] loop.run_until_complete(asyncio.wait(tasks)) print(<span class="hljs-string"><span class="hljs-string">"Results: %s"</span></span> % [task.result() <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> task <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> tasks])</code> </pre> <br>  In F√§llen, in denen Sie die potenzielle M√∂glichkeit einer nutzlosen Zuweisung von Hunderten von Megabyte Speicher verhindern m√ºssen, ist es wichtig, dass der vollst√§ndige Antwortinhalt nicht sofort geladen werden muss.  Wenn das Programm keinen Zugriff auf die Antwort als Ganzes ben√∂tigt und mit einzelnen Fragmenten der Antwort arbeiten kann, ist es wahrscheinlich am besten, auf Streaming-Methoden mit Anfragen zur√ºckzugreifen.  Wenn Sie beispielsweise Daten aus der Antwort des Servers auf eine Datei speichern m√∂chten, ist das Lesen und Schreiben in Teilen in Bezug auf die Speichernutzung viel effizienter als das Lesen des gesamten Antwortk√∂rpers, das Zuweisen einer gro√üen Menge an Speicher und das anschlie√üende Schreiben aller Daten auf die Festplatte. <br><br><h2>  <font color="#3AC1EF">Zusammenfassung</font> </h2><br>  Ich hoffe, dass meine Geschichte √ºber verschiedene M√∂glichkeiten zur Optimierung des Betriebs von HTTP-Clients Ihnen bei der Auswahl der f√ºr Ihre Python-Anwendung am besten geeigneten Methode hilft. <br><br>  <b>Liebe Leser!</b>  Wenn Sie noch andere M√∂glichkeiten zur Optimierung der Arbeit mit HTTP-Anforderungen in Python-Anwendungen kennen, teilen Sie diese bitte mit. <br><br><div style="text-align:center;"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/webt/-o/2e/tu/-o2etuqogwhmdnmysb9_vivc9v4.png"></a> </div><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de472858/">https://habr.com/ru/post/de472858/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de472840/index.html">Software Defined Storage oder was hat die Dinosaurier get√∂tet?</a></li>
<li><a href="../de472848/index.html">√úberlegungen zu einer Karriere in der IT</a></li>
<li><a href="../de472850/index.html">Beruf oder Leben: Gewinnen Sie einen Netologiekurs, wenn Sie keine Angst haben</a></li>
<li><a href="../de472852/index.html">GitLab nimmt √Ñnderungen f√ºr Benutzer von Cloud- und kommerziellen Produkten vor</a></li>
<li><a href="../de472854/index.html">Unity UI Profiling: Wer verdirbt meine Stapelverarbeitung?</a></li>
<li><a href="../de472860/index.html">Kaskadierende Cache-Ung√ºltigmachung. Teil 1</a></li>
<li><a href="../de472862/index.html">Kaskadierende Cache-Ung√ºltigmachung. Teil 2</a></li>
<li><a href="../de472864/index.html">Pr√ºfpunkt: CPU- und RAM-Optimierung</a></li>
<li><a href="../de472868/index.html">Verwaltung des Telefonservers: RUVDS Mobile Client</a></li>
<li><a href="../de472870/index.html">Warum Agile zum Stillstand kommt, ohne Architektur und Entwicklungstools zu ver√§ndern - Konferenzpr√§sentation</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>