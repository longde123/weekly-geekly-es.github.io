<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨🏿‍✈️ 😇 🤜🏾 Python und schnelle HTTP-Clients 👘 🗂️ 🔥</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Wenn Sie heutzutage eine Art Python-Anwendung schreiben, müssen Sie diese höchstwahrscheinlich mit der Funktionalität eines HTTP-Clients ausstatten, d...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Python und schnelle HTTP-Clients</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/472858/">  Wenn Sie heutzutage eine Art Python-Anwendung schreiben, müssen Sie diese höchstwahrscheinlich mit der Funktionalität eines HTTP-Clients ausstatten, der mit HTTP-Servern kommunizieren kann.  Die Allgegenwart der REST-API hat HTTP-Tools zu einer angesehenen Funktion in unzähligen Softwareprojekten gemacht.  Aus diesem Grund muss jeder Programmierer Muster besitzen, um die optimale Arbeit mit HTTP-Verbindungen zu organisieren. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/webt/fv/ix/xt/fvixxt-a-wwkrs5vivurfucn5pe.jpeg"></a> <br><br>  Es gibt viele HTTP-Clients für Python.  Die häufigste unter ihnen und außerdem die, mit der man leicht arbeiten kann, kann als <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Anfrage bezeichnet werden</a> .  Heute ist dieser Kunde der De-facto-Standard. <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">Permanente Verbindungen</font> </h2><br>  Die erste Optimierung, die bei der Arbeit mit HTTP berücksichtigt werden muss, ist die Verwendung dauerhafter Verbindungen zu Webservern.  Permanente Verbindungen sind seit HTTP 1.1 zum Standard geworden, werden jedoch von vielen Anwendungen immer noch nicht verwendet.  Dieser Mangel ist leicht zu erklären, da bei Verwendung der <code>requests</code> im einfachen Modus (z. B. mithilfe der <code>get</code> Methode) die Verbindung zum Server nach Erhalt einer Antwort von diesem Server geschlossen wird.  Um dies zu vermeiden, muss die Anwendung das <code>Session</code> Objekt verwenden, mit dem offene Verbindungen wiederverwendet werden können: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> requests session = requests.Session() session.get(<span class="hljs-string"><span class="hljs-string">"http://example.com"</span></span>) <span class="hljs-comment"><span class="hljs-comment">#    session.get("http://example.com")</span></span></code> </pre> <br>  Verbindungen werden im Verbindungspool gespeichert (standardmäßig werden 10 Verbindungen verwendet).  Die Poolgröße kann angepasst werden: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> requests session = requests.Session() adapter = requests.adapters.HTTPAdapter(    pool_connections=<span class="hljs-number"><span class="hljs-number">100</span></span>,    pool_maxsize=<span class="hljs-number"><span class="hljs-number">100</span></span>) session.mount(<span class="hljs-string"><span class="hljs-string">'http://'</span></span>, adapter) response = session.get(<span class="hljs-string"><span class="hljs-string">"http://example.org"</span></span>)</code> </pre> <br>  Die Wiederverwendung einer TCP-Verbindung zum Senden mehrerer HTTP-Anforderungen bietet der Anwendung viele Leistungsvorteile: <br><br><ul><li>  Reduzierung der Prozessorlast und Reduzierung des RAM-Bedarfs (aufgrund der Tatsache, dass weniger Verbindungen gleichzeitig geöffnet sind). </li><li>  Reduzieren von Verzögerungen bei der Ausführung von Anforderungen, die nacheinander eingehen (es gibt keine TCP-Handshake-Prozedur). </li><li>  Ausnahmen können ohne zusätzliche Zeit ausgelöst werden, um die TCP-Verbindung zu schließen. </li></ul><br>  HTTP 1.1 unterstützt auch das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Pipelining</a> von Anforderungen.  Auf diese Weise können Sie mehrere Anforderungen innerhalb derselben Verbindung senden, ohne auf Antworten auf zuvor gesendete Anforderungen zu warten (dh Anforderungen in "Paketen" zu senden).  Leider unterstützt die <code>requests</code> diese Funktion nicht.  Pipelining-Anforderungen sind jedoch möglicherweise nicht so schnell wie die parallele Verarbeitung.  Außerdem ist es angebracht, darauf zu achten: Antworten auf "Paket" -Anfragen sollten vom Server in derselben Reihenfolge gesendet werden, in der er diese Anfragen erhalten hat.  Das Ergebnis ist nicht das effizienteste Anforderungsverarbeitungsschema nach dem FIFO-Prinzip („first in, first out“ - „first come, first Leave“). <br><br><h2>  <font color="#3AC1EF">Parallele Abfrageverarbeitung</font> </h2><br>  <code>requests</code> auch einen weiteren schwerwiegenden Nachteil.  Dies ist eine synchrone Bibliothek.  Ein Methodenaufruf wie <code>requests.get("http://example.org")</code> blockiert das Programm, bis eine vollständige HTTP-Serverantwort empfangen wird.  Die Tatsache, dass die Anwendung warten und nichts tun muss, kann als Minus dieses Organisationsschemas für die Interaktion mit dem Server angesehen werden.  Ist es möglich, das Programm dazu zu bringen, etwas Nützliches zu tun, anstatt nur zu warten? <br><br>  Eine intelligent gestaltete Anwendung kann dieses Problem durch die Verwendung eines Thread-Pools verringern, der dem von <code>concurrent.futures</code> bereitgestellten ähnelt.  Auf diese Weise können Sie HTTP-Anforderungen schnell parallelisieren: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> concurrent <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> futures <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> requests <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> futures.ThreadPoolExecutor(max_workers=<span class="hljs-number"><span class="hljs-number">4</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> executor:    futures = [        executor.submit(            <span class="hljs-keyword"><span class="hljs-keyword">lambda</span></span>: requests.get(<span class="hljs-string"><span class="hljs-string">"http://example.org"</span></span>))        <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _ <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">8</span></span>)    ] results = [    f.result().status_code    <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> f <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> futures ] print(<span class="hljs-string"><span class="hljs-string">"Results: %s"</span></span> % results)</code> </pre> <br>  Dieses sehr nützliche Muster ist in der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Request-Futures-</a> Bibliothek implementiert.  Die Verwendung von <code>Session</code> ist jedoch für den Entwickler transparent: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> requests_futures <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> sessions session = sessions.FuturesSession() futures = [    session.get(<span class="hljs-string"><span class="hljs-string">"http://example.org"</span></span>)    <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _ <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">8</span></span>) ] results = [    f.result().status_code    <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> f <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> futures ] print(<span class="hljs-string"><span class="hljs-string">"Results: %s"</span></span> % results)</code> </pre> <br>  Standardmäßig wird ein Worker mit zwei Threads erstellt. Das Programm kann diesen Wert jedoch einfach festlegen, indem das Argument <code>FuturSession</code> oder sogar sein eigener Executor an das <code>FuturSession</code> Objekt übergeben wird.  Zum Beispiel könnte es so aussehen: <br><br><pre> <code class="python hljs">FuturesSession(executor=ThreadPoolExecutor(max_workers=<span class="hljs-number"><span class="hljs-number">10</span></span>))</code> </pre> <br><h2>  <font color="#3AC1EF">Asynchrone Arbeit mit Anfragen</font> </h2><br>  Wie bereits erwähnt, ist die <code>requests</code> vollständig synchron.  Dies führt dazu, dass Anwendungen blockiert werden, während auf eine Antwort vom Server gewartet wird, was sich negativ auf die Leistung auswirkt.  Eine Lösung für dieses Problem besteht darin, HTTP-Anforderungen in separaten Threads auszuführen.  Die Verwendung von Threads ist jedoch eine zusätzliche Belastung für das System.  Darüber hinaus bedeutet dies die Einführung eines parallelen Datenverarbeitungsschemas in das Programm, das nicht für jeden geeignet ist. <br><br>  Ab Python 3.5 gehören zu den Standardsprachenfunktionen die asynchrone Programmierung mit <code>asyncio</code> .  Die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://aio">aiohttp-</a> Bibliothek bietet dem Entwickler einen asynchronen HTTP-Client, der auf <code>asyncio</code> basiert.  Mit dieser Bibliothek kann die Anwendung eine Reihe von Anforderungen senden und weiterarbeiten.  Um eine weitere Anfrage zu senden, müssen Sie nicht auf eine Antwort auf eine zuvor gesendete Anfrage warten.  Im Gegensatz zum Pipelining von HTTP-Anforderungen sendet <code>aiohttp</code> Anforderungen parallel über mehrere Verbindungen.  Dies vermeidet das oben beschriebene "FIFO-Problem".  So sieht die Verwendung von <code>aiohttp</code> aus: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> aiohttp <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> asyncio <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(url)</span></span></span><span class="hljs-function">:</span></span>    <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> aiohttp.ClientSession() <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> session:        <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> session.get(url) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> response:            <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> response loop = asyncio.get_event_loop() coroutines = [get(<span class="hljs-string"><span class="hljs-string">"http://example.com"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _ <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">8</span></span>)] results = loop.run_until_complete(asyncio.gather(*coroutines)) print(<span class="hljs-string"><span class="hljs-string">"Results: %s"</span></span> % results)</code> </pre> <br>  Alle oben beschriebenen Ansätze (mit <code>Session</code> , Streams, <code>concurrent.futures</code> oder <code>asyncio</code> ) bieten verschiedene Möglichkeiten, um HTTP-Clients zu beschleunigen. <br><br><h2>  <font color="#3AC1EF">Leistung</font> </h2><br>  Der folgende Code ist ein Beispiel, in dem der HTTP-Client Anforderungen an den <code>httpbin.org</code> Server sendet.  Der Server unterstützt eine API, die unter anderem ein System simulieren kann, dessen Beantwortung einer Anfrage lange dauert (in diesem Fall 1 Sekunde).  Hier werden alle oben diskutierten Techniken implementiert und ihre Leistung gemessen: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> contextlib <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> time <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> aiohttp <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> asyncio <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> requests <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> requests_futures <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> sessions URL = <span class="hljs-string"><span class="hljs-string">"http://httpbin.org/delay/1"</span></span> TRIES = <span class="hljs-number"><span class="hljs-number">10</span></span> @contextlib.contextmanager <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">report_time</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(test)</span></span></span><span class="hljs-function">:</span></span>    t0 = time.time()    <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span>    print(<span class="hljs-string"><span class="hljs-string">"Time needed for `%s' called: %.2fs"</span></span>          % (test, time.time() - t0)) <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> report_time(<span class="hljs-string"><span class="hljs-string">"serialized"</span></span>):    <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(TRIES):        requests.get(URL) session = requests.Session() <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> report_time(<span class="hljs-string"><span class="hljs-string">"Session"</span></span>):    <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(TRIES):        session.get(URL) session = sessions.FuturesSession(max_workers=<span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> report_time(<span class="hljs-string"><span class="hljs-string">"FuturesSession w/ 2 workers"</span></span>):    futures = [session.get(URL)               <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(TRIES)]    <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> f <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> futures:        f.result() session = sessions.FuturesSession(max_workers=TRIES) <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> report_time(<span class="hljs-string"><span class="hljs-string">"FuturesSession w/ max workers"</span></span>):    futures = [session.get(URL)               <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(TRIES)]    <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> f <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> futures:        f.result() <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(url)</span></span></span><span class="hljs-function">:</span></span>    <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> aiohttp.ClientSession() <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> session:        <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> session.get(url) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> response:            <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> response.read() loop = asyncio.get_event_loop() <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> report_time(<span class="hljs-string"><span class="hljs-string">"aiohttp"</span></span>):    loop.run_until_complete(        asyncio.gather(*[get(URL)                         <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(TRIES)]))</code> </pre> <br>  Hier sind die Ergebnisse, die nach dem Start dieses Programms erzielt wurden: <br><br><pre> <code class="python hljs">Time needed <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> `serialized<span class="hljs-string"><span class="hljs-string">' called: 12.12s Time needed for `Session'</span></span> called: <span class="hljs-number"><span class="hljs-number">11.22</span></span>s Time needed <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> `FuturesSession w/ <span class="hljs-number"><span class="hljs-number">2</span></span> workers<span class="hljs-string"><span class="hljs-string">' called: 5.65s Time needed for `FuturesSession w/ max workers'</span></span> called: <span class="hljs-number"><span class="hljs-number">1.25</span></span>s Time needed <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> `aiohttp<span class="hljs-string"><span class="hljs-string">' called: 1.19s</span></span></code> </pre> <br>  Hier ist eine Tabelle der Ergebnisse. <br><img src="https://habrastorage.org/getpro/habr/post_images/c84/655/e65/c84655e655fc6d400a4ffd2d932aaa61.png"><br>  <i><font color="#999999">Die Ergebnisse einer Studie zur Leistung verschiedener Methoden zum Erstellen von HTTP-Anforderungen</font></i> <br><br>  Es ist nicht überraschend, dass sich das einfachste Ausführungsschema für synchrone Abfragen als das langsamste herausstellte.  Der Punkt hier ist, dass hier die Abfragen einzeln ausgeführt werden, ohne die Verbindung wiederzuverwenden.  Daher dauert es 12 Sekunden, um 10 Abfragen abzuschließen. <br><br>  Durch die Verwendung des <code>Session</code> und die Wiederverwendung von Verbindungen werden 8% der Zeit gespart.  Das ist schon sehr gut und das zu erreichen ist sehr einfach.  Jeder, der sich um die Leistung kümmert, sollte mindestens das <code>Session</code> Objekt verwenden. <br><br>  Wenn Ihr System und Ihr Programm es Ihnen ermöglichen, mit Threads zu arbeiten, ist dies ein guter Grund, über die Verwendung von Threads zum Parallelisieren von Anforderungen nachzudenken.  Streams verursachen jedoch eine zusätzliche Belastung des Systems, sie sind sozusagen nicht „frei“.  Sie müssen erstellt und ausgeführt werden. Sie müssen auf den Abschluss ihrer Arbeit warten. <br><br>  Wenn Sie den schnellen asynchronen HTTP-Client verwenden möchten und nicht auf älteren Python-Versionen schreiben, sollten Sie <code>aiohttp</code> die größte Aufmerksamkeit <code>aiohttp</code> .  Dies ist die schnellste und am besten skalierbare Lösung.  Es ist in der Lage, Hunderte von gleichzeitigen Anforderungen zu verarbeiten. <br><br>  Eine Alternative zu <code>aiohttp</code> , keine besonders gute Alternative, besteht darin, Hunderte von Threads parallel zu verwalten. <br><br><h2>  <font color="#3AC1EF">Datenverarbeitung streamen</font> </h2><br>  Eine weitere Optimierung der Arbeit mit Netzwerkressourcen, die zur Verbesserung der Anwendungsleistung hilfreich sein kann, ist die Verwendung von Streaming-Daten.  Das Standard-Anforderungsverarbeitungsschema sieht folgendermaßen aus: Die Anwendung sendet eine Anforderung, wonach der Hauptteil dieser Anforderung auf einmal geladen wird.  Mit dem <code>stream</code> Parameter, der die <code>requests</code> sowie das <code>content</code> der <code>aiohttp</code> Bibliothek unterstützt, können Sie sich von diesem Schema entfernen. <br><br>  So sieht die Organisation der Streaming-Datenverarbeitung mithilfe von <code>requests</code> aus: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> requests <span class="hljs-comment"><span class="hljs-comment">#  `with`          #     . with requests.get('http://example.org', stream=True) as r:    print(list(r.iter_content()))</span></span></code> </pre> <br>  So streamen Sie Daten mit <code>aiohttp</code> : <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> aiohttp <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> asyncio <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(url)</span></span></span><span class="hljs-function">:</span></span>    <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> aiohttp.ClientSession() <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> session:        <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> session.get(url) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> response:            <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> response.content.read() loop = asyncio.get_event_loop() tasks = [asyncio.ensure_future(get(<span class="hljs-string"><span class="hljs-string">"http://example.com"</span></span>))] loop.run_until_complete(asyncio.wait(tasks)) print(<span class="hljs-string"><span class="hljs-string">"Results: %s"</span></span> % [task.result() <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> task <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> tasks])</code> </pre> <br>  In Fällen, in denen Sie die potenzielle Möglichkeit einer nutzlosen Zuweisung von Hunderten von Megabyte Speicher verhindern müssen, ist es wichtig, dass der vollständige Antwortinhalt nicht sofort geladen werden muss.  Wenn das Programm keinen Zugriff auf die Antwort als Ganzes benötigt und mit einzelnen Fragmenten der Antwort arbeiten kann, ist es wahrscheinlich am besten, auf Streaming-Methoden mit Anfragen zurückzugreifen.  Wenn Sie beispielsweise Daten aus der Antwort des Servers auf eine Datei speichern möchten, ist das Lesen und Schreiben in Teilen in Bezug auf die Speichernutzung viel effizienter als das Lesen des gesamten Antwortkörpers, das Zuweisen einer großen Menge an Speicher und das anschließende Schreiben aller Daten auf die Festplatte. <br><br><h2>  <font color="#3AC1EF">Zusammenfassung</font> </h2><br>  Ich hoffe, dass meine Geschichte über verschiedene Möglichkeiten zur Optimierung des Betriebs von HTTP-Clients Ihnen bei der Auswahl der für Ihre Python-Anwendung am besten geeigneten Methode hilft. <br><br>  <b>Liebe Leser!</b>  Wenn Sie noch andere Möglichkeiten zur Optimierung der Arbeit mit HTTP-Anforderungen in Python-Anwendungen kennen, teilen Sie diese bitte mit. <br><br><div style="text-align:center;"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/webt/-o/2e/tu/-o2etuqogwhmdnmysb9_vivc9v4.png"></a> </div><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de472858/">https://habr.com/ru/post/de472858/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de472840/index.html">Software Defined Storage oder was hat die Dinosaurier getötet?</a></li>
<li><a href="../de472848/index.html">Überlegungen zu einer Karriere in der IT</a></li>
<li><a href="../de472850/index.html">Beruf oder Leben: Gewinnen Sie einen Netologiekurs, wenn Sie keine Angst haben</a></li>
<li><a href="../de472852/index.html">GitLab nimmt Änderungen für Benutzer von Cloud- und kommerziellen Produkten vor</a></li>
<li><a href="../de472854/index.html">Unity UI Profiling: Wer verdirbt meine Stapelverarbeitung?</a></li>
<li><a href="../de472860/index.html">Kaskadierende Cache-Ungültigmachung. Teil 1</a></li>
<li><a href="../de472862/index.html">Kaskadierende Cache-Ungültigmachung. Teil 2</a></li>
<li><a href="../de472864/index.html">Prüfpunkt: CPU- und RAM-Optimierung</a></li>
<li><a href="../de472868/index.html">Verwaltung des Telefonservers: RUVDS Mobile Client</a></li>
<li><a href="../de472870/index.html">Warum Agile zum Stillstand kommt, ohne Architektur und Entwicklungstools zu verändern - Konferenzpräsentation</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>