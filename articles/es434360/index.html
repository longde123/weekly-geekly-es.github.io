<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üëèüèΩ üë®üèº‚Äçüíª ü§æüèº Charla explicada sobre programaci√≥n asincr√≥nica en Javascript ü§üüèø üêè ü•™</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hola a todos! 

 Como recordar√°n, en octubre est√°bamos traduciendo un art√≠culo interesante sobre el uso de temporizadores en Javascript. Caus√≥ una gra...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Charla explicada sobre programaci√≥n asincr√≥nica en Javascript</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/piter/blog/434360/"> Hola a todos! <br><br>  Como recordar√°n, en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">octubre</a> est√°bamos traduciendo un art√≠culo interesante sobre el uso de temporizadores en Javascript.  Caus√≥ una gran discusi√≥n, de acuerdo con los resultados de los cuales siempre hemos querido volver a este tema y ofrecerle un an√°lisis detallado de la programaci√≥n asincr√≥nica en este lenguaje.  Estamos contentos de haber logrado encontrar material decente y publicarlo antes de fin de a√±o.  Que tengas una buena lectura! <br><a name="habracut"></a><br>  La programaci√≥n asincr√≥nica en Javascript ha pasado por una evoluci√≥n de varias etapas: desde devoluciones de llamada a promesas y m√°s all√° a generadores, y pronto a <code>async/await</code> .  En cada etapa, la programaci√≥n asincr√≥nica en Javascript se simplific√≥ un poco para aquellos que ya se hab√≠an arrodillado en este lenguaje, pero para los principiantes se volvi√≥ solo m√°s aterrador, ya que era necesario comprender los matices de cada paradigma, dominar la aplicaci√≥n de cada uno y, no menos importante, comprender, c√≥mo funciona todo <br><br>  En este art√≠culo, decidimos recordar brevemente c√≥mo usar las devoluciones de llamada y las promesas, dar una breve introducci√≥n a los generadores y luego ayudarlo a comprender intuitivamente c√≥mo est√° organizada la programaci√≥n asincr√≥nica "bajo el cap√≥" con generadores y async / wait.  Esperamos que de esta manera pueda aplicar con confianza los diversos paradigmas exactamente donde sean apropiados. <br><br>  Se supone que el lector ya ha utilizado devoluciones de llamada, promesas y generadores para la programaci√≥n asincr√≥nica, y tambi√©n est√° bastante familiarizado con los cierres y curr√≠culum en Javascript. <br><br>  <b>Callback hell</b> <br><br>  Inicialmente, hubo devoluciones de llamadas.  No hay E / S sincr√≥nica en Javascript (en lo sucesivo, E / S) y el bloqueo no es compatible en absoluto.  Entonces, para organizar cualquier E / S o para diferir cualquier acci√≥n, se eligi√≥ una estrategia de este tipo: el c√≥digo que deb√≠a ejecutarse de forma asincr√≥nica se pas√≥ a la funci√≥n con ejecuci√≥n diferida, que se lanz√≥ en alg√∫n lugar debajo del bucle de eventos.  Una devoluci√≥n de llamada no es tan mala, pero el c√≥digo crece y las devoluciones de llamada generalmente generan nuevas devoluciones de llamada.  El resultado es algo como esto: <br><br><pre> <code class="javascript hljs">getUserData(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">doStuff</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">e, a</span></span></span><span class="hljs-function">) </span></span>{ getMoreUserData(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">doMoreStuff</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">e, b</span></span></span><span class="hljs-function">) </span></span>{ getEvenMoreUserData(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">doEvenMoreStuff</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">e, c</span></span></span><span class="hljs-function">) </span></span>{ getYetMoreUserData(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">doYetMoreStuff</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">e, c</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'Welcome to callback hell!'</span></span>); }); }); }); })</code> </pre> <br>  Adem√°s de la piel de gallina al ver un c√≥digo fractal de este tipo, hay un problema m√°s: ahora hemos delegado el control de nuestra l√≥gica <code>do*Stuff</code> a otras funciones ( <code>get*UserData()</code> ), para lo cual es posible que no tenga el c√≥digo fuente, y es posible que no est√© Seguro si est√°n realizando su devoluci√≥n de llamada.  Genial, ¬øno es as√≠? <br><br>  <b>Promesas</b> <br><br>  Las promesas invierten la inversi√≥n de control proporcionada por las devoluciones de llamada y ayudan a desentra√±ar una mara√±a de devoluciones de llamada en una cadena suave. <br>  Ahora el ejemplo anterior se puede convertir en algo como esto: <br><br><pre> <code class="javascript hljs">getUserData() .then(getUserData) .then(doMoreStuff) .then(getEvenMoreUserData) .then(doEvenMoreStuff) .then(getYetMoreUserData) .then(doYetMoreStuff);</code> </pre><br>  Ya no es tan feo, ¬øeh? <br><br>  Pero d√©jame !!!  Veamos un ejemplo de devoluci√≥n de llamada m√°s vital (pero a√∫n en gran medida artificial): <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// ,     fetchJson(),   GET   , //    :         ,     ‚Äì   // . function fetchJson(url, callback) { ... } fetchJson('/api/user/self', function(e, user) { fetchJson('/api/interests?userId=' + user.id, function(e, interests) { var recommendations = []; interests.forEach(function () { fetchJson('/api/recommendations?topic=' + interest, function(e, recommendation) { recommendations.push(recommendation); if (recommendations.length == interests.length) { render(profile, interests, recommendations); } }); }); }); });</span></span></code> </pre><br>  Entonces, seleccionamos el perfil del usuario, luego sus intereses, luego, en funci√≥n de sus intereses, seleccionamos recomendaciones y, finalmente, despu√©s de haber recopilado todas las recomendaciones, mostramos la p√°gina.  Tal conjunto de devoluciones de llamada, de las cuales, probablemente, puede estar orgulloso, pero, sin embargo, de alguna manera es peludo.  Nada, aplique promesas aqu√≠, y todo saldr√° bien.  Derecho? <br><br>  Cambiemos nuestro m√©todo <code>fetchJson()</code> para que devuelva una promesa en lugar de aceptar una devoluci√≥n de llamada.  Una promesa se resuelve mediante un cuerpo de respuesta analizado en formato JSON. <br><br><pre> <code class="javascript hljs">fetchJson(<span class="hljs-string"><span class="hljs-string">'/api/user/self'</span></span>) .then(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">user</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> fetchJson(<span class="hljs-string"><span class="hljs-string">'/api/user/interests?userId='</span></span> + self.id); }) .then(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">interests</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>.all[interests.map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">i</span></span></span><span class="hljs-function"> =&gt;</span></span> fetchJson(<span class="hljs-string"><span class="hljs-string">'/api/recommendations?topic='</span></span> + i))]; }) .then(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">recommendations</span></span></span><span class="hljs-function">) </span></span>{ render(user, interests, recommendations); });</code> </pre> <br>  Bien, verdad?  ¬øQu√© hay de malo con este c√≥digo ahora? <br><br>  ... ¬°Uy! .. <br>  ¬øNo tenemos acceso al perfil o intereses en la √∫ltima funci√≥n de esta cadena?  ¬°Entonces nada funciona!  Que hacer  Probemos las promesas anidadas: <br><br><pre> <code class="javascript hljs">fetchJson(<span class="hljs-string"><span class="hljs-string">'/api/user/self'</span></span>) .then(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">user</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> fetchJson(<span class="hljs-string"><span class="hljs-string">'/api/user/interests?userId='</span></span> + self.id) .then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">interests</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-attr"><span class="hljs-attr">user</span></span>: user, <span class="hljs-attr"><span class="hljs-attr">interests</span></span>: interests }); }) .then(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">blob</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>.all[blob.interests.map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">i</span></span></span><span class="hljs-function"> =&gt;</span></span> fetchJson(<span class="hljs-string"><span class="hljs-string">'/api/recommendations?topic='</span></span> + i))] .then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">recommendations</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-attr"><span class="hljs-attr">user</span></span>: blob.user, <span class="hljs-attr"><span class="hljs-attr">interests</span></span>: blob.interests, <span class="hljs-attr"><span class="hljs-attr">recommendations</span></span>: recommendations }); }) .then(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">bigBlob</span></span></span><span class="hljs-function">) </span></span>{ render(bigBlob.user, bigBlob.interests, bigBlob.recommendations); });</code> </pre> <br>  S√≠ ... ahora se ve mucho m√°s torpe de lo que esper√°bamos.  ¬øEs debido a esas mu√±ecas de anidaci√≥n tan locas que nosotros, por √∫ltimo pero no menos importante, tratamos de escapar del infierno de las devoluciones de llamadas?  Que hacer ahora <br><br>  El c√≥digo se puede peinar un poco, apoy√°ndose en los cierres: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//   ,     var user, interests; fetchJson('/api/user/self') .then(function (fetchedUser) { user = fetchedUser; return fetchJson('/api/user/interests?userId=' + self.id); }) .then(function (fetchedInterests) { interests = fetchedInterests; return Promise.all(interests.map(i =&gt; fetchJson('/api/recommendations?topic=' + i))); }) .then(function (recomendations) { render(user, interests, recommendations); }) .then(function () { console.log('We are done!'); });</span></span></code> </pre> <br>  S√≠, ahora todo es pr√°cticamente como quer√≠amos, pero con una peculiaridad.  Observe c√≥mo llamamos argumentos dentro de las devoluciones de llamada en las <code>fetchedInterests</code> <code>fetchedUser</code> y <code>fetchedInterests</code> , en lugar de <code>user</code> e <code>interests</code> .  Si es as√≠, ¬°entonces eres muy observador! <br><br>  La falla de este enfoque es la siguiente: debe tener mucho cuidado de no nombrar nada en las funciones internas, as√≠ como las variables de la memoria cach√© que va a utilizar en su cierre.  Incluso si tiene la habilidad de evitar el sombreado, hacer referencia a una variable tan alta en el cierre todav√≠a parece bastante peligroso, y eso definitivamente no es bueno. <br><br>  <b>Generadores asincr√≥nicos</b> <br><br>  Los generadores ayudar√°n!  Si usa generadores, entonces toda la emoci√≥n desaparece.  Solo magia.  La verdad es que  Echa un vistazo solamente: <br><br><pre> <code class="javascript hljs">co(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">* (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> user = <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> fetchJson(<span class="hljs-string"><span class="hljs-string">'/api/user/self'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> interests = <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> fetchJson(<span class="hljs-string"><span class="hljs-string">'/api/user/interests?userId='</span></span> + self.id); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> recommendations = <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>.all( interests.map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">i</span></span></span><span class="hljs-function"> =&gt;</span></span> fetchJson(<span class="hljs-string"><span class="hljs-string">'/api/recommendations?topic='</span></span> + i))); render(user, interests, recommendations); });</code> </pre> <br>  Eso es todo  Funcionar√°  No rompes una l√°grima cuando ves lo hermosos que son los generadores, ¬øte arrepientes de haber sido tan miope y comenzaste a aprender Javascript incluso antes de que aparecieran los generadores?  Lo admito, tal idea una vez me visit√≥. <br>  Pero ... ¬øc√≥mo funciona todo esto?  ¬øRealmente m√°gico? <br><br>  ¬°Por supuesto! .. No.  Pasamos a la exposici√≥n. <br><br>  <b>Generadores</b> <br><br>  En nuestro ejemplo, parece que los generadores son f√°ciles de usar, pero en realidad est√°n sucediendo muchas cosas.  Para obtener m√°s informaci√≥n sobre los generadores asincr√≥nicos, debe comprender mejor c√≥mo funcionan los generadores y c√≥mo proporcionan una ejecuci√≥n asincr√≥nica, que parece s√≠ncrona. <br><br>  Como su nombre lo indica, el generador hace los valores: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">counts</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">start</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> start + <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> start + <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> start + <span class="hljs-number"><span class="hljs-number">3</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> start + <span class="hljs-number"><span class="hljs-number">4</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> counter = counts(<span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(counter.next()); <span class="hljs-comment"><span class="hljs-comment">// {value: 1, done: false} console.log(counter.next()); // {value: 2, done: false} console.log(counter.next()); // {value: 3, done: false} console.log(counter.next()); // {value: 4, done: true} console.log(counter.next()); // {value: undefined, done: true}</span></span></code> </pre><br>  Es bastante simple, pero de todos modos, hablemos de lo que est√° sucediendo aqu√≠: <br><br><ol><li> <code>const counter = counts();</code>  - Inicialice el generador y gu√°rdelo en el contador variable.  El generador est√° en el limbo; todav√≠a no se ha ejecutado ning√∫n c√≥digo en el cuerpo del generador. </li><li> <code>console.log(counter.next());</code>  - Interpretaci√≥n de la salida ( <code>yield</code> ) 1, despu√©s de lo cual 1 se devuelve como <code>value</code> y se <code>done</code> <code>false</code> , ya que la salida no termina all√≠ </li><li> <code>console.log(counter.next());</code>  - Ahora 2! </li><li> <code>console.log(counter.next());</code>  - Ahora 3!  Terminado  ¬øEst√° todo bien?  No  La ejecuci√≥n se detiene en el paso <code>yield 3;</code>  Para completar, debe llamar a next () nuevamente. </li><li> <code>console.log(counter.next());</code>  - Ahora 4, y regresa, pero no se emite, as√≠ que ahora salimos de la funci√≥n y todo est√° listo. </li><li> <code>console.log(counter.next());</code>  - ¬°El generador ha terminado el trabajo!  No tiene nada que informar, excepto que "todo est√° hecho". </li></ol><br>  ¬°As√≠ que descubrimos c√≥mo funcionan los generadores!  Pero espera, qu√© verdad tan impactante: ¬°los generadores no solo pueden arrojar valores, sino tambi√©n devorarlos! <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">printer</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"We are starting!"</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-keyword"><span class="hljs-keyword">yield</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-keyword"><span class="hljs-keyword">yield</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-keyword"><span class="hljs-keyword">yield</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"We are done!"</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> counter = printer(); counter.next(<span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-comment"><span class="hljs-comment">// ! counter.next(2); // 2 counter.next(3); // 3 counter.next(4); // 4\n ! counter.next(5); //   </span></span></code> </pre><br>  ¬°Uf, qu√©?  Un generador consume valores, en lugar de generarlos.  ¬øC√≥mo es esto posible? <br><br>  El secreto est√° en la <code>next</code> funci√≥n.  No solo devuelve valores del generador, sino que tambi√©n puede devolverlos al generador.  Si le dice a <code>next()</code> argumento, entonces la operaci√≥n de <code>yield</code> , que el generador est√° esperando actualmente, en realidad da como resultado el argumento.  Es por eso que el primer <code>counter.next(1)</code> registra como <code>undefined</code> .  Simplemente no hay extradici√≥n que pueda resolverse. <br><br>  Es como si el generador permitiera que el c√≥digo de llamada (procedimiento) y el c√≥digo del generador (procedimiento) se asociaran entre s√≠ para que se transmitan valores mientras se ejecutan y esperen el uno al otro.  La situaci√≥n es pr√°cticamente la misma, como si se hubiera pensado en los generadores de Javascript la posibilidad de implementar procedimientos cooperativos de ejecuci√≥n competitiva, tambi√©n son "corutinas".  En realidad, m√°s o menos como <code>co()</code> , ¬øverdad? <br><br>  Pero no nos apuremos, de lo contrario nos burlaremos de nosotros mismos.  En este caso, es importante que el lector capte intuitivamente la esencia de los generadores y la programaci√≥n asincr√≥nica, y la mejor manera de hacerlo es ensamblar el generador usted mismo.  No escriba una funci√≥n de generador y no use la funci√≥n terminada, sino que recree el interior de la funci√≥n de generador usted mismo. <br><br>  <b>El dispositivo interno del generador: generamos generadores</b> <br><br>  Bien, realmente no s√© c√≥mo se ven exactamente los componentes internos del generador en diferentes tiempos de ejecuci√≥n de JS.  Pero esto no es tan importante.  Los generadores corresponden a la interfaz.  Un "constructor" para crear instancias de un generador, el <code>next(value? : any)</code> m√©todo <code>next(value? : any)</code> , con el que le ordenamos al generador que contin√∫e funcionando y le proporcione valores, otro m√©todo de <code>throw(error)</code> en caso de que <code>throw(error)</code> genere un <code>throw(error)</code> lugar de un valor, y finalmente, un m√©todo <code>return()</code> , que a√∫n est√° en silencio.  Si se logra el cumplimiento de la interfaz, entonces todo est√° bien. <br><br>  Entonces, intentemos construir el generador de <code>counts()</code> mencionado anteriormente en ES5 puro, sin la <code>function*</code> palabra clave <code>function*</code> .  Por ahora, puede ignorar <code>throw()</code> y pasar el valor a <code>next()</code> , ya que el m√©todo no acepta ninguna entrada.  Como hacerlo <br><br>  Pero en Javascript, hay otro mecanismo para pausar y reanudar la ejecuci√≥n del programa: ¬°cierres!  ¬øTe parece familiar? <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">makeCounter</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> count = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> count++; } } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> counter = makeCounter(); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(counter()); <span class="hljs-comment"><span class="hljs-comment">// 1 console.log(counter()); // 2 console.log(counter()); // 3</span></span></code> </pre> <br>  Si utiliz√≥ cierres antes, estoy seguro de que ya escribi√≥ algo as√≠.  La funci√≥n devuelta por makeCounter puede generar una secuencia infinita de n√∫meros, al igual que un generador. <br><br>  Sin embargo, esta funci√≥n no corresponde a la interfaz del generador y no se puede aplicar directamente en nuestro ejemplo con <code>counts()</code> , que devuelve 4 valores y sale.  ¬øQu√© se necesita para un enfoque universal para escribir funciones tipo generador? <br><br>  ¬°Cierres, m√°quinas de estado y trabajos forzados! <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">counts</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">start</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> state = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> done = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">go</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> result; <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (state) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>: result = start + <span class="hljs-number"><span class="hljs-number">1</span></span>; state = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>: result = start + <span class="hljs-number"><span class="hljs-number">2</span></span>; state = <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>: result = start + <span class="hljs-number"><span class="hljs-number">3</span></span>; state = <span class="hljs-number"><span class="hljs-number">3</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span>: result = start + <span class="hljs-number"><span class="hljs-number">4</span></span>; done = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; state = <span class="hljs-number"><span class="hljs-number">-1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> {<span class="hljs-attr"><span class="hljs-attr">done</span></span>: done, <span class="hljs-attr"><span class="hljs-attr">value</span></span>: result}; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { <span class="hljs-attr"><span class="hljs-attr">next</span></span>: go } } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> counter = counts(<span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(counter.next()); <span class="hljs-comment"><span class="hljs-comment">// {value: 1, done: false} console.log(counter.next()); // {value: 2, done: false} console.log(counter.next()); // {value: 3, done: false} console.log(counter.next()); // {value: 4, done: true} console.log(counter.next()); // {value: undefined, done: true}</span></span></code> </pre> <br>  Al ejecutar este c√≥digo, ver√° los mismos resultados que en la versi√≥n con el generador.  Bien, verdad? <br>  Entonces, resolvimos el lado generador del generador;  vamos a analizar el consumo? <br>  De hecho, no hay muchas diferencias. <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">printer</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">start</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> state = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> done = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">go</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">input</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> result; <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (state) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"We are starting!"</span></span>); state = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(input); state = <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(input); state = <span class="hljs-number"><span class="hljs-number">3</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(input); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"We are done!"</span></span>); done = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; state = <span class="hljs-number"><span class="hljs-number">-1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> {<span class="hljs-attr"><span class="hljs-attr">done</span></span>: done, <span class="hljs-attr"><span class="hljs-attr">value</span></span>: result}; } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { <span class="hljs-attr"><span class="hljs-attr">next</span></span>: go } } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> counter = printer(); counter.next(<span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-comment"><span class="hljs-comment">// ! counter.next(2); // 2 counter.next(3); // 3 counter.next(4); // 4 counter.next(5); // !</span></span></code> </pre> <br>  Todo lo que se necesita es agregar una <code>input</code> como argumento <code>go</code> , y los valores se canalizan.  Parece magia otra vez?  ¬øCasi como generadores? <br><br>  ¬°Hurra!  As√≠ que recreamos el generador como proveedor y como consumidor.  ¬øPor qu√© no intentar combinar estas funciones en √©l?  Aqu√≠ hay otro ejemplo bastante artificial de un generador: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">adder</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">initialValue</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> sum = initialValue; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-literal"><span class="hljs-literal">true</span></span>) { sum += <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> sum; } }</code> </pre> <br>  Como todos somos especialistas en generadores, entendemos que este generador agrega el valor dado en <code>next(value)</code> a <code>sum</code> , y luego devuelve sum.  Funciona exactamente como esper√°bamos: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> add = adder(<span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(add.next()); <span class="hljs-comment"><span class="hljs-comment">// 0 console.log(add.next(1)); // 1 console.log(add.next(2)); // 3 console.log(add.next(3)); // 6</span></span></code> </pre><br>  Genial  ¬°Ahora escribamos esta interfaz como una funci√≥n normal! <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">adder</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">initialValue</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> state = <span class="hljs-string"><span class="hljs-string">'initial'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> done = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> sum = initialValue; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">go</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">input</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> result; <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (state) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">'initial'</span></span>: result = initialValue; state = <span class="hljs-string"><span class="hljs-string">'loop'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">'loop'</span></span>: sum += input; result = sum; state = <span class="hljs-string"><span class="hljs-string">'loop'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> {<span class="hljs-attr"><span class="hljs-attr">done</span></span>: done, <span class="hljs-attr"><span class="hljs-attr">value</span></span>: result}; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { <span class="hljs-attr"><span class="hljs-attr">next</span></span>: go } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">runner</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> add = adder(<span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(add.next()); <span class="hljs-comment"><span class="hljs-comment">// 0 console.log(add.next(1)); // 1 console.log(add.next(2)); // 3 console.log(add.next(3)); // 6 } runner();</span></span></code> </pre> <br>  Wow, hemos implementado una corutina completa. <br><br>  Todav√≠a hay algo que discutir sobre el funcionamiento de los generadores.  ¬øC√≥mo funcionan las excepciones?  Con las excepciones que ocurren dentro de los generadores, todo es simple: <code>next()</code> har√° que la excepci√≥n llegue a la persona que llama y el generador morir√°.  Pasar una excepci√≥n al generador se realiza en el m√©todo <code>throw()</code> , que omitimos anteriormente. <br><br>  Enriquezcamos nuestro terminador con una nueva caracter√≠stica genial.  Si la persona que llama pasa la excepci√≥n al generador, volver√° al √∫ltimo valor de la suma. <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">adder</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">initialValue</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> sum = initialValue; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> lastSum = initialValue; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> temp; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-literal"><span class="hljs-literal">true</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { temp = sum; sum += <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> sum; lastSum = temp; } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (e) { sum = lastSum; } } } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> add = adder(<span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(add.next()); <span class="hljs-comment"><span class="hljs-comment">// 0 console.log(add.next(1)); // 1 console.log(add.next(2)); // 3 console.log(add.throw(new Error('BOO)!'))); // 1 console.log(add.next(4)); // 5</span></span></code> </pre><br>  <b>Problema de programaci√≥n - Penetraci√≥n de error del generador</b> <br><br>  Camarada, ¬øc√≥mo implementamos throw ()? <br><br>  F√°cil!  El error es solo otro valor.  Podemos pasarlo a <code>go()</code> como el siguiente argumento.  De hecho, se necesita cierta precauci√≥n aqu√≠.  Cuando <code>throw(e)</code> llama <code>throw(e)</code> , la <code>yield</code> funcionar√° como si hubi√©ramos escrito throw e.  Esto significa que debemos verificar si hay errores en cada estado de nuestra m√°quina de estado y bloquear el programa si no podemos manejar el error. <br><br>  Comencemos con la implementaci√≥n anterior del terminador, copiado <br><br>  <a href="">Patr√≥n</a> <br><br>  <a href="">Soluci√≥n</a> <br><br>  Boom!  Hemos implementado un conjunto de corutinas que son capaces de pasar mensajes y excepciones entre s√≠, como un generador real. <br><br>  Pero la situaci√≥n est√° empeorando, ¬øno?  La implementaci√≥n de la m√°quina de estado se aleja cada vez m√°s de la implementaci√≥n del generador.  No solo eso, debido al manejo de errores, el c√≥digo est√° lleno de basura;  el c√≥digo es a√∫n m√°s complicado debido al largo <code>while</code> que tenemos aqu√≠.  Para convertir un <code>while</code> debe "desenredarlo" en estados.  Entonces, nuestro caso 1 en realidad incluye 2.5 iteraciones del <code>while</code> , ya que el <code>yield</code> rompe en el medio.  Finalmente, debe agregar un c√≥digo adicional para enviar las excepciones de la persona que llama y viceversa si no hay un <code>try/catch</code> en el generador para manejar esta excepci√≥n. <br><br>  Lo hiciste !!!  Hemos completado un an√°lisis detallado de posibles alternativas para la implementaci√≥n de generadores y, espero, ya haya entendido mejor c√≥mo funcionan los generadores.  En el residuo seco: <br><br><ul><li>  Un generador puede generar valores, consumir valores o ambos. </li><li>  El estado del generador se puede pausar (estado, m√°quina de estado, captura?) </li><li>  La persona que llama y el generador le permiten formar un conjunto de corutina, interactuando entre s√≠. </li><li>  Las excepciones se env√≠an en cualquier direcci√≥n. </li></ul><br>  Ahora que tenemos una mejor comprensi√≥n de los generadores, propongo una forma potencialmente conveniente de razonar sobre ellos: estas son construcciones sint√°cticas con las que puede escribir procedimientos ejecutados de manera competitiva que se transmiten valores entre s√≠ a trav√©s de un canal que transfiere valores uno a la vez ( <code>yield</code> ).  Esto ser√° √∫til en la siguiente secci√≥n, donde produciremos una implementaci√≥n de <code>co()</code> partir de la rutina. <br><br>  <b>Inversi√≥n de control de corutina</b> <br><br>  Ahora que estamos capacitados para trabajar con generadores, pensemos c√≥mo se pueden usar en la programaci√≥n asincr√≥nica.  Si podemos escribir generadores como tales, esto no significa que las promesas en los generadores se resolver√°n autom√°ticamente.  Pero espere, los generadores no est√°n destinados a funcionar solos.  Deben interactuar con otro programa, el procedimiento principal, el que llama a <code>.next()</code> y <code>.throw()</code> . <br><br>  ¬øQu√© pasa si ponemos nuestra l√≥gica de negocios no en el procedimiento principal, sino en el generador?  Cada vez que se produce un cierto valor asincr√≥nico, como una promesa, para la l√≥gica de negocios, el generador dir√°: "No quiero meterme con estas tonter√≠as, despi√©rtame cuando se resuelva", har√° una pausa y emitir√° una promesa al procedimiento de entrega.  Procedimiento de mantenimiento: "OK, te llamar√© m√°s tarde".  Despu√©s de lo cual registra una devoluci√≥n de llamada con esta promesa, sale y espera hasta que sea posible desencadenar un ciclo de eventos (es decir, cuando la promesa se resuelve).  Cuando esto suceda, el procedimiento anunciar√° "hey, es tu turno" y enviar√° el valor a trav√©s de <code>.next()</code> generador <code>.next()</code> .  Esperar√° a que el generador haga su trabajo, y mientras tanto har√° otras cosas asincr√≥nicas ... y as√≠ sucesivamente.  Escuchaste una triste historia sobre c√≥mo el procedimiento sigue vivo al servicio de un generador. <br><br>  Entonces, volviendo al tema principal.  Ahora que sabemos c√≥mo funcionan los generadores y las promesas, no ser√° dif√≠cil para nosotros crear tal "procedimiento de servicio".  El procedimiento de servicio en s√≠ se ejecutar√° de manera competitiva como una promesa, crear√° una instancia y mantendr√° el generador, y luego regresar√° al resultado final de nuestro procedimiento principal utilizando la devoluci√≥n de llamada <code>.then()</code> . <br><br>  A continuaci√≥n, regresemos al programa co () y analicemos con m√°s detalle.  <code>co()</code> es un procedimiento de servicio que toma mano de obra esclava para que el generador solo pueda trabajar con valores s√≠ncronos.  Ya parece mucho m√°s l√≥gico, ¬øverdad? <br><br><pre> <code class="javascript hljs">co(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">* (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> user = <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> fetchJson(<span class="hljs-string"><span class="hljs-string">'/api/user/self'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> interests = <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> fetchJson(<span class="hljs-string"><span class="hljs-string">'/api/user/interests?userId='</span></span> + self.id); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> recommendations = <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>.all( interests.map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">i</span></span></span><span class="hljs-function"> =&gt;</span></span> fetchJson(<span class="hljs-string"><span class="hljs-string">'/api/recommendations?topic='</span></span> + i))); render(user, interests, recommendations); });</code> </pre> <br> ,     ,   <code>co()</code>      ,  . <br><br> <b>   ‚Äî co() </b> <br><br>  Genial     <code>co()</code> ,   ,      . <code>co()</code>  <br><br><ol><li>    ,    </li><li>   </li><li>  <code>.next()</code>       ,     <code>{done: false, value: [a Promise]}</code> </li><li>      </li><li>    (   ),  <code>.next()</code>  ,         </li><li>  ,    4 </li><li>   -    <code>{done: true, value: ...}</code> ,  ,  <code>co()</code> </li></ol><br>      ,    co(),      : <br><br> <a href=""></a> <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">deferred</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">val</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) =&gt;</span></span> resolve(val)); } co(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">asyncAdds</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">initialValue</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> deferred(initialValue + <span class="hljs-number"><span class="hljs-number">1</span></span>)); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> deferred(initialValue + <span class="hljs-number"><span class="hljs-number">2</span></span>)); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> deferred(initialValue + <span class="hljs-number"><span class="hljs-number">3</span></span>)); }); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">co</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">generator</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-comment"><span class="hljs-comment">//   }); }</span></span></code> </pre><br> <a href=""></a> <br><br>  , ?  - 10         <code>co()</code> ,        .  ,    .    ? <br><br> <b>   ‚Äì    co()</b> <br><br>  ,  , ,  ,  <code>co()</code>     .   ,      <code>.throw()</code>   . <br><br> <a href=""></a> <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">deferred</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">val</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) =&gt;</span></span> resolve(val)); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">deferReject</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">e</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) =&gt;</span></span> reject(e)); } co(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">asyncAdds</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> deferred(<span class="hljs-number"><span class="hljs-number">1</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> deferredError(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>(<span class="hljs-string"><span class="hljs-string">'To fail, or to not fail.'</span></span>))); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (e) { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'To not fail!'</span></span>); } <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> deferred(<span class="hljs-number"><span class="hljs-number">3</span></span>)); }); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">co</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">generator</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-comment"><span class="hljs-comment">//   }); }</span></span></code> </pre> <br> <a href=""></a> <br><br>    .         ,      ,      <code>.next()</code>     <code>onResolve()</code> .      <code>onReject()</code> ,      <code>.throw()</code> .        <code>try/catch</code> ,     ,      <code>try/catch</code>   . <br><br> ,   <code>co()</code> ! ! <code>co()</code>    ,  ,   ,    .     , ? <br><br> <b> : async/await</b> <br><br>         <code>co()</code> .      - ,      async/await?  ‚Äî !       ,       <code>async await</code> . <br><br>     async   ,        <code>await</code> ,          <code>yield</code> . <code>await</code>            ,    <code>async</code> .   <code>async</code> -  . <br><br> ,     <code>async/await</code> ,   , -    <code>co()</code>  <code>async</code>  <code>yield</code>  <code>await</code> ,      <code>*</code> ,     . <br><br><pre> <code class="javascript hljs">co(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">* (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> user = <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> fetchJson(<span class="hljs-string"><span class="hljs-string">'/api/user/self'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> interests = <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> fetchJson(<span class="hljs-string"><span class="hljs-string">'/api/user/interests?userId='</span></span> + self.id); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> recommendations = <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>.all( interests.map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">i</span></span></span><span class="hljs-function"> =&gt;</span></span> fetchJson(<span class="hljs-string"><span class="hljs-string">'/api/recommendations?topic='</span></span> + i))); render(user, interests, recommendations); });</code> </pre> <br> : <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> user = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> fetchJson(<span class="hljs-string"><span class="hljs-string">'/api/user/self'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> interests = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> fetchJson(<span class="hljs-string"><span class="hljs-string">'/api/user/interests?userId='</span></span> + self.id); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> recommendations = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>.all( interests.map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">i</span></span></span><span class="hljs-function"> =&gt;</span></span> fetchJson(<span class="hljs-string"><span class="hljs-string">'/api/recommendations?topic='</span></span> + i))); render(user, interests, recommendations); }();</code> </pre> <br> ,      : <br><br><ul><li> <code>co()</code>     . async  ,        . <code>async</code>    <code>co()</code>   <code>co.wrap()</code> . </li><li>  <code>co()</code>   ( <code>yield</code> ) ,  ,     .  <code>async</code>    ( <code>await</code> ) . </li></ul><br>  <b>El final</b> <br><br>       Javascript   , ,  ¬´ ¬ª     <code>co()</code> ,  ,    ,    <code>async/await</code> . ? . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es434360/">https://habr.com/ru/post/es434360/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es434346/index.html">Curso MIT "Seguridad de sistemas inform√°ticos". Lecci√≥n 22: "MIT de seguridad de la informaci√≥n", parte 3</a></li>
<li><a href="../es434348/index.html">¬øRecuerdas tu contrase√±a en Habr√©?</a></li>
<li><a href="../es434354/index.html">Crear un modelo de reconocimiento facial utilizando el aprendizaje profundo en Python</a></li>
<li><a href="../es434356/index.html">Python Stiller con correo electr√≥nico</a></li>
<li><a href="../es434358/index.html">Sustituci√≥n de importaciones de sistemas operativos. ¬øC√≥mo veo el sistema operativo dom√©stico?</a></li>
<li><a href="../es434362/index.html">NO pronosticado para 2019</a></li>
<li><a href="../es434364/index.html">Hangfire Queue Support</a></li>
<li><a href="../es434368/index.html">Aprendizaje autom√°tico para encontrar errores en el c√≥digo: c√≥mo hice pr√°cticas en JetBrains Research</a></li>
<li><a href="../es434370/index.html">Otro conquistador de la sombra en Phaser, o el uso de bicicletas.</a></li>
<li><a href="../es434374/index.html">Comprobaci√≥n de RBAC en Kubernetes</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>