<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤸🏿 🤾 👩🏿‍💻 iOS应用程序中的组件UI架构 🔙 👩🏼‍🤝‍👨🏽 👩🏻‍🏭</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="哈Ha！ 

 我叫Valera，作为Badoo团队的一员，两年来我一直在开发iOS应用程序。 我们的优先事项之一是易于维护代码。 由于每周都会使用大量新功能，因此我们需要首先考虑应用程序的体系结构，否则很难在不破坏现有功能的情况下向产品添加新功能。 显然，这也适用于用户界面（UI）的实现，而不管这...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>iOS应用程序中的组件UI架构</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/badoo/blog/421559/"><img src="https://habrastorage.org/webt/x8/bs/so/x8bsso8hy3rdfn3ostzyohesvyc.jpeg"><br><br> 哈Ha！ <br><br> 我叫Valera，作为Badoo团队的一员，两年来我一直在开发iOS应用程序。 我们的优先事项之一是易于维护代码。 由于每周都会使用大量新功能，因此我们需要首先考虑应用程序的体系结构，否则很难在不破坏现有功能的情况下向产品添加新功能。 显然，这也适用于用户界面（UI）的实现，而不管这是使用代码，Xcode（XIB）还是混合方法完成的。 在本文中，我将介绍一些UI实现技术，这些技术使我们能够简化用户界面的开发，使其灵活，方便地进行测试。 本文还有<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">英文版</a> 。 <br><br><h2> 开始之前... </h2><br> 我将使用Swift编写的示例应用程序考虑用户界面实现技术。 单击按钮的应用程序将显示一个朋友列表。 <br><br> 它包括三个部分： <br><br><ol><li>  <b>组件</b>是自定义UI组件，即仅与用户界面相关的代码。 </li><li>  <b>演示应用程序</b> -演示视图模型和其他仅具有UI依赖项的用户界面实体。 </li><li>  <b>真正的应用</b>是视图模型和其他可能包含特定依赖关系和逻辑的实体。 </li></ol><br> 为什么会有这样的分离？ 我将在下面回答这个问题，但现在，请查看我们应用程序的用户界面： <br><a name="habracut"></a><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/nr/vt/gl/nrvtglcxbhadi2ag4ohcuazdhqk.gif" height="600"></div><br> 这是一个弹出视图，其内容位于另一个全屏视图的顶部。 一切都很简单。 <br><br> 该项目的完整源代码可在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">GitHub</a>上<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">找到</a> 。 <br><br> 在研究UI代码之前，我想向您介绍这里使用的辅助类Observable。 其界面如下所示： <br><br><pre><code class="hljs swift"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> value: <span class="hljs-type"><span class="hljs-type">T</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">observe</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">_</span></span></span></span><span class="hljs-function"><span class="hljs-params"> closure: @escaping </span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"><span class="hljs-params">(</span></span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-params"><span class="hljs-number">_</span></span></span></span></span><span class="hljs-function"><span class="hljs-params"><span class="hljs-params"> old: T, </span></span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-params"><span class="hljs-number">_</span></span></span></span></span><span class="hljs-function"><span class="hljs-params"><span class="hljs-params"> new: T)</span></span></span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Void</span></span>) -&gt; <span class="hljs-type"><span class="hljs-type">ObserverProtocol</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">observeNewAndCall</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">_</span></span></span></span><span class="hljs-function"><span class="hljs-params"> closure: @escaping </span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"><span class="hljs-params">(</span></span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-params"><span class="hljs-number">_</span></span></span></span></span><span class="hljs-function"><span class="hljs-params"><span class="hljs-params"> new: T)</span></span></span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Void</span></span>) -&gt; <span class="hljs-type"><span class="hljs-type">ObserverProtocol</span></span></code> </pre> <br> 它只是将所有更改通知所有先前签署的观察者，因此这是KVO（键值观察）的一种替代方法，或者，如果您愿意，还可以采用反应式编程。 这是一个用法示例： <br><br><pre> <code class="hljs objectivec"><span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.observers.append(<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.viewModel.items.observe { [<span class="hljs-keyword"><span class="hljs-keyword">weak</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>] (_, newItems) <span class="hljs-keyword"><span class="hljs-keyword">in</span></span>   <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>?.state = newItems.isEmpty ? .zeroCase(type: .empty) : .normal   <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>?.collectionView.reloadSections(IndexSet(integer: <span class="hljs-number"><span class="hljs-number">0</span></span>)) })</code> </pre> <br> 控制器将更改订阅<code>self.viewModel.items</code>属性，并且当更改发生时，处理程序将执行业务逻辑。 例如，它更新视图状态并用新项目重新加载集合视图。 <br><br> 您将在下面看到更多使用示例。 <br><br><h2> 方法论 </h2><br> 在本节中，我将讨论Badoo中使用的四种UI开发技术： <br><br>  1.用代码实现用户界面。 <br><br>  2.使用布局锚点。 <br><br>  3.组成部分-分而治之。 <br><br>  4.用户界面和逻辑的分离。 <br><br><h3>  ＃1：在代码中实现用户界面 </h3><br> 在Badoo中，大多数用户兴趣是通过代码实现的。 我们为什么不使用XIB或情节提要？ 公平的问题。 主要原因是为中型团队维护代码的便利性，即： <br><br><ul><li> 代码中的更改清晰可见，这意味着无需解析XML故事板/ XIB文件即可查找同事所做的更改； <br></li><li> 版本控制系统（例如，Git）比使用“大量” XLM文件更容易使用代码，尤其是在中等冲突时； 还应考虑到，即使界面没有更改，XIB /情节提要文件的内容也会在每次保存时更改（尽管我听说在Xcode 9中该问题已得到解决）； <br></li><li> 在子视图（布局子视图）的重新布局过程中，可能很难在Interface Builder（IB）中修改和维护某些属性，例如CALayer属性，这可能导致视图状态的多个事实来源； <br></li><li>  Interface Builder不是最快的工具，有时直接使用代码会更快。 <br></li></ul><br> 看一下以下控制器（FriendsListViewController）： <br><br><pre> <code class="hljs swift"><span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FriendsListViewController</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UIViewController</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ViewConfig</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> backgroundColor: <span class="hljs-type"><span class="hljs-type">UIColor</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> cornerRadius: <span class="hljs-type"><span class="hljs-type">CGFloat</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> infoView: <span class="hljs-type"><span class="hljs-type">FriendsListView!</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> viewModel: <span class="hljs-type"><span class="hljs-type">FriendsListViewModelProtocol</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> viewConfig: <span class="hljs-type"><span class="hljs-type">ViewConfig</span></span> <span class="hljs-keyword"><span class="hljs-keyword">init</span></span>(viewModel: <span class="hljs-type"><span class="hljs-type">FriendsListViewModelProtocol</span></span>, viewConfig: <span class="hljs-type"><span class="hljs-type">ViewConfig</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.viewModel = viewModel <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.viewConfig = viewConfig <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">init</span></span>(nibName: <span class="hljs-literal"><span class="hljs-literal">nil</span></span>, bundle: <span class="hljs-literal"><span class="hljs-literal">nil</span></span>) } <span class="hljs-keyword"><span class="hljs-keyword">required</span></span> <span class="hljs-keyword"><span class="hljs-keyword">init</span></span>?(coder aDecoder: <span class="hljs-type"><span class="hljs-type">NSCoder</span></span>) { <span class="hljs-built_in"><span class="hljs-built_in">fatalError</span></span>(<span class="hljs-string"><span class="hljs-string">"init(coder:) has not been implemented"</span></span>) } <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">viewDidLoad</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.viewDidLoad() <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.setupContainerView() } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setupContainerView</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.view.backgroundColor = <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.viewConfig.backgroundColor <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> infoView = <span class="hljs-type"><span class="hljs-type">FriendsListView</span></span>( frame: .zero, viewModel: <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.viewModel, viewConfig: .defaultConfig) infoView.backgroundColor = <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.viewConfig.backgroundColor <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.view.addSubview(infoView) <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.infoView = infoView infoView.translatesAutoresizingMaskIntoConstraints = <span class="hljs-literal"><span class="hljs-literal">false</span></span> infoView.leadingAnchor.constraint(equalTo: <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.view.leadingAnchor).isActive = <span class="hljs-literal"><span class="hljs-literal">true</span></span> infoView.trailingAnchor.constraint(equalTo: <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.view.trailingAnchor).isActive = <span class="hljs-literal"><span class="hljs-literal">true</span></span> infoView.topAnchor.constraint(equalTo: <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.view.topAnchor).isActive = <span class="hljs-literal"><span class="hljs-literal">true</span></span> infoView.bottomAnchor.constraint(equalTo: <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.view.bottomAnchor).isActive = <span class="hljs-literal"><span class="hljs-literal">true</span></span> } <span class="hljs-comment"><span class="hljs-comment">// …. }</span></span></code> </pre> <br> 本示例说明您只能通过提供视图模型和视图配置来创建视图控制器。 您可以<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">在此处</a>阅读有关表示模型的更多信息，即MVVM设计模型（Model-View-ViewModel）。 由于视图配置是定义视图的布局和样式（即缩进，大小，颜色，字体等）的简单结构实体，因此我认为提供这样的标准配置是合适的： <br><br><pre> <code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extension</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FriendsListViewController</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ViewConfig</span></span></span><span class="hljs-class"> </span></span>{   <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> defaultConfig: <span class="hljs-type"><span class="hljs-type">FriendsListViewController</span></span>.<span class="hljs-type"><span class="hljs-type">ViewConfig</span></span> {       <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-type"><span class="hljs-type">FriendsListViewController</span></span>.<span class="hljs-type"><span class="hljs-type">ViewConfig</span></span>(backgroundColor: .white,                                                   cornerRadius: <span class="hljs-number"><span class="hljs-number">16</span></span>)   } }</code> </pre> <br> 所有视图初始化都在<code>setupContainerView</code>方法中进行，当已经创建并加载视图但尚未在屏幕上绘制视图时，仅从viewDidLoad调用一次，也就是说，所有必要的元素（子视图）都简单地添加到视图层次结构中，然后应用标记（布局）和样式。 <br><br> 这是视图控制器现在的样子： <br><br><pre> <code class="hljs kotlin"><span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FriendsListPresenter</span></span></span><span class="hljs-class">: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">FriendsListPresenterProtocol {   // …   func presentFriendsList</span></span></span></span>(from presentingViewController: UIViewController) {       let controller = Class.createFriendsListViewController( presentingViewController: presentingViewController,           headerViewModel: self.headerViewModel,           contentViewModel: self.contentViewModel)       controller.modalPresentationStyle = .overCurrentContext       controller.modalTransitionStyle = .crossDissolve       presentingViewController.present(controller, animated: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, completion: nil)   }   <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">func</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">createFriendsListViewController</span></span></span></span>( presentingViewController: UIViewController, headerViewModel: FriendsListHeaderViewModelProtocol,       contentViewModel: FriendsListContentViewModelProtocol) -&gt; FriendsListContainerViewController {      let dismissViewControllerBlock: VoidBlock = { [weak presentingViewController] <span class="hljs-keyword"><span class="hljs-keyword">in</span></span>           presentingViewController?.dismiss(animated: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, completion: nil)       }       let infoViewModel = FriendsListViewModel( headerViewModel: headerViewModel,           contentViewModel: contentViewModel)       let containerViewModel = FriendsListContainerViewModel(onOutsideContentTapAction: dismissViewControllerBlock)       let friendsListViewController = FriendsListViewController( viewModel: infoViewModel, viewConfig: .defaultConfig)       let controller = FriendsListContainerViewController( contentViewController: friendsListViewController,           viewModel: containerViewModel,           viewConfig: .defaultConfig)       <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> controller   } }</code> </pre> <br> 您可以清楚地看到<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">职责分工</a> ，这个概念并不比在故事板上调用segue复杂得多。 <br><br> 鉴于我们拥有模型，因此创建视图控制器非常简单，您可以简单地使用标准视图配置： <br><br><pre> <code class="hljs lisp">let friendsListViewController = FriendsListViewController( <span class="hljs-name"><span class="hljs-name">viewModel</span></span>: infoViewModel, viewConfig: .defaultConfig)</code> </pre><br><h3>  ＃2：使用布局锚点 </h3><br> 这是布局代码： <br><br><pre> <code class="hljs objectivec"><span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.view.addSubview(infoView) <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.infoView = infoView infoView.translatesAutoresizingMaskIntoConstraints = <span class="hljs-literal"><span class="hljs-literal">false</span></span> infoView.leadingAnchor.constraint(equalTo: <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.view.leadingAnchor).isActive = <span class="hljs-literal"><span class="hljs-literal">true</span></span> infoView.trailingAnchor.constraint(equalTo: <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.view.trailingAnchor).isActive = <span class="hljs-literal"><span class="hljs-literal">true</span></span> infoView.topAnchor.constraint(equalTo: <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.view.topAnchor).isActive = <span class="hljs-literal"><span class="hljs-literal">true</span></span> infoView.bottomAnchor.constraint(equalTo: <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.view.bottomAnchor).isActive = <span class="hljs-literal"><span class="hljs-literal">true</span></span></code> </pre><br> 简而言之，此代码将<code>infoView</code>置于父视图（ <code>infoView</code>视图）的内部，相对于<code>infoView</code>视图的原始大小位于坐标（0，0）处。 <br><br> 为什么要使用布局锚点？ 快速简便。 当然，您可以手动设置UIView.frame并即时计算所有位置和大小，但是有时它可能会变得过于混乱和/或代码过于庞大。 <br><br> 您还可以使用文本格式进行标记，如此处所述，但这经常会导致错误，因为您需要严格遵循格式，并且Xcode在编写/编译代码阶段不会检查标记描述文本，并且您不能使用《安全区域布局指南》： <br><br><pre> <code class="hljs perl">NSLayoutConstraint.constraints( withVisualFormat: <span class="hljs-string"><span class="hljs-string">"V:|-(\(topSpace))-[headerView(headerHeight@200)]-[collectionView(collectionViewHeight@990)]|"</span></span>,   options: [],   metrics: metrics,   views: views)</code> </pre><br> 在定义标记的文本字符串中犯错误或错字很容易，对吧？ <br><br><h3>  ＃3：组件-分而治之 </h3><br> 我们的示例用户界面分为多个组件，每个组件仅执行一项特定功能。 <br><br> 例如： <br><br><ol><li>  <code>FriendsListHeaderView</code>显示有关朋友的信息和“关闭”按钮。 </li><li>  <code>FriendsListContentView</code>显示具有可单击单元格的朋友列表，到达列表末尾时将动态加载内容。 </li><li>  <code>FriendsListView</code>先前两个视图的容器。 </li></ol><br> 如前所述，当每个组件负责一个单独的功能时，Badoo我们喜欢<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">唯一负责</a>的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">原则</a> 。 这不仅在错误修复过程中（这可能不是iOS开发人员工作中最有趣的部分）有所帮助，而且在开发新功能期间也有帮助，因为这种方法极大地扩展了将来重用代码的可能性。 <br><br><h3>  ＃4：分离用户界面和逻辑 </h3><br> 最后但同样重要的一点是用户界面和逻辑的分离。 一种可以为您的团队节省时间和神经的技术。 从字面上看：一个用于用户界面的项目和一个用于业务逻辑的项目。 <br><br> 让我们回到我们的例子。 您还记得，演示文稿（presenter）的本质如下所示： <br><br><pre> <code class="hljs swift"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">presentFriendsList</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(from presentingViewController: UIViewController)</span></span></span></span> {   <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> controller = <span class="hljs-type"><span class="hljs-type">Class</span></span>.createFriendsListViewController( presentingViewController: presentingViewController,       headerViewModel: <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.headerViewModel,       contentViewModel: <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.contentViewModel)   controller.modalPresentationStyle = .overCurrentContext   controller.modalTransitionStyle = .crossDissolve   presentingViewController.present(controller, animated: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, completion: <span class="hljs-literal"><span class="hljs-literal">nil</span></span>) }</code> </pre> <br> 您只需要提供标题和内容的视图模型。 其余部分隐藏在UI组件的上述实现中。 <br><br> 标头视图模型协议如下所示： <br><br><pre> <code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">protocol</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FriendsListHeaderViewModelProtocol</span></span></span><span class="hljs-class"> </span></span>{   <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> friendsCountIcon: <span class="hljs-type"><span class="hljs-type">UIImage?</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> }   <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> closeButtonIcon: <span class="hljs-type"><span class="hljs-type">UIImage?</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> }   <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> friendsCount: <span class="hljs-type"><span class="hljs-type">Observable</span></span>&lt;<span class="hljs-type"><span class="hljs-type">String</span></span>&gt; { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> }   <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> onCloseAction: <span class="hljs-type"><span class="hljs-type">VoidBlock?</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> } }</code> </pre> <br> 现在，假设您要为UI添加视觉测试-就像为UI组件传递存根模型一样简单。 <br><br><pre> <code class="hljs swift"><span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FriendsListHeaderDemoViewModel</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FriendsListHeaderViewModelProtocol</span></span></span><span class="hljs-class"> </span></span>{   <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> friendsCountIcon: <span class="hljs-type"><span class="hljs-type">UIImage?</span></span> = <span class="hljs-type"><span class="hljs-type">UIImage</span></span>(named: <span class="hljs-string"><span class="hljs-string">"ic_friends_count"</span></span>)   <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> closeButtonIcon: <span class="hljs-type"><span class="hljs-type">UIImage?</span></span> = <span class="hljs-type"><span class="hljs-type">UIImage</span></span>(named: <span class="hljs-string"><span class="hljs-string">"ic_close_cross"</span></span>)   <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> friendsCount: <span class="hljs-type"><span class="hljs-type">Observable</span></span>&lt;<span class="hljs-type"><span class="hljs-type">String</span></span>&gt;   <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> onCloseAction: <span class="hljs-type"><span class="hljs-type">VoidBlock?</span></span>   <span class="hljs-keyword"><span class="hljs-keyword">init</span></span>() {       <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> friendsCountString = <span class="hljs-string"><span class="hljs-string">"\(Int.random(min: 1, max: 5000))"</span></span>       <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.friendsCount = <span class="hljs-type"><span class="hljs-type">Observable</span></span>(friendsCountString)   } }</code> </pre> <br> 看起来很简单，对吧？ 现在，我们想向应用程序的组件中添加业务逻辑，这可能需要数据提供者，数据模型等： <br><br><pre> <code class="hljs swift"><span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FriendsListHeaderViewModel</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FriendsListHeaderViewModelProtocol</span></span></span><span class="hljs-class"> </span></span>{   <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> friendsCountIcon: <span class="hljs-type"><span class="hljs-type">UIImage?</span></span>   <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> closeButtonIcon: <span class="hljs-type"><span class="hljs-type">UIImage?</span></span>   <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> friendsCount: <span class="hljs-type"><span class="hljs-type">Observable</span></span>&lt;<span class="hljs-type"><span class="hljs-type">String</span></span>&gt; = <span class="hljs-type"><span class="hljs-type">Observable</span></span>(<span class="hljs-string"><span class="hljs-string">"0"</span></span>)   <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> onCloseAction: <span class="hljs-type"><span class="hljs-type">VoidBlock?</span></span>   <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> dataProvider: <span class="hljs-type"><span class="hljs-type">FriendsListDataProviderProtocol</span></span>   <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> observers: [<span class="hljs-type"><span class="hljs-type">ObserverProtocol</span></span>] = []   <span class="hljs-keyword"><span class="hljs-keyword">init</span></span>(dataProvider: <span class="hljs-type"><span class="hljs-type">FriendsListDataProviderProtocol</span></span>,        friendsCountIcon: <span class="hljs-type"><span class="hljs-type">UIImage?</span></span>,        closeButtonIcon: <span class="hljs-type"><span class="hljs-type">UIImage?</span></span>) {       <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.dataProvider = dataProvider       <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.friendsCountIcon = friendsCountIcon       <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.closeButtonIcon = closeButtonIcon       <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.setupDataObservers()   }   <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setupDataObservers</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> {       <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.observers.append(<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.dataProvider.totalItemsCount.observeNewAndCall { [<span class="hljs-keyword"><span class="hljs-keyword">weak</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>] (newCount) <span class="hljs-keyword"><span class="hljs-keyword">in</span></span>           <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>?.friendsCount.value = <span class="hljs-string"><span class="hljs-string">"\(newCount)"</span></span>       })   } }</code> </pre> <br> 有什么会更容易？ 只需实现数据提供程序-那就开始吧！ <br><br> 内容模型的实现看起来有些复杂，但是职责分离仍然大大简化了生活。 这是一个如何在单击按钮时实例化并显示朋友列表的示例： <br><br><pre> <code class="hljs swift"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">presentRealFriendsList</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(sender: </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">Any</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> {   <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> avatarPlaceholderImage = <span class="hljs-type"><span class="hljs-type">UIImage</span></span>(named: <span class="hljs-string"><span class="hljs-string">"avatar-placeholder"</span></span>)   <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> itemFactory = <span class="hljs-type"><span class="hljs-type">FriendsListItemFactory</span></span>(avatarPlaceholderImage: avatarPlaceholderImage)   <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> dataProvider = <span class="hljs-type"><span class="hljs-type">FriendsListDataProvider</span></span>(itemFactory: itemFactory)   <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> viewModelFactory = <span class="hljs-type"><span class="hljs-type">FriendsListViewModelFactory</span></span>(dataProvider: dataProvider)   <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> headerViewModel = viewModelFactory.makeHeaderViewModel()   headerViewModel.onCloseAction = { [<span class="hljs-keyword"><span class="hljs-keyword">weak</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">in</span></span>       <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>?.dismiss(animated: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, completion: <span class="hljs-literal"><span class="hljs-literal">nil</span></span>)   }   <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> contentViewModel = viewModelFactory.makeContentViewModel()   <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> presenter = <span class="hljs-type"><span class="hljs-type">FriendsListPresenter</span></span>( headerViewModel: headerViewModel,       contentViewModel: contentViewModel)   presenter.presentFriendsList(from: <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) }</code> </pre> <br> 此技术有助于将用户界面与业务逻辑隔离。 此外，这使您可以通过可视化测试覆盖整个UI，并将测试数据传递给组件！ 因此，无论是启动产品还是已经完成的产品，用户界面和相关业务逻辑的分离对于项目的成功至关重要。 <br><br><h2> 结论 </h2><br> 当然，这些只是Badoo中使用的一些技术，并不是所有情况下的通用解决方案。 因此，请在评估它们是否适合您和您的项目后使用它们。 <br><br> 还有其他方法，例如使用Interface Builder的XIB可配置UI组件（在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">我们的</a>另<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">一篇文章</a>中进行<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">了介绍</a> ），但是由于各种原因，它们在Badoo中没有使用。 请记住，每个人对全局都有自己的看法和远见，因此，为了开发成功的项目，您应该在团队中达成共识，并选择最适合大多数情况的方法。 <br><br> 愿斯威夫特和你在一起！ <br><br> 资料来源 <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">GitHub上的</a>完整项目代码 <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">本文英文版</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">创建自定义UI组件</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">建筑iOS模板</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Swift中的建模状态</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Swift中的SOLID原理</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">NSLayoutAnchor</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">以编程方式创建约束</a> <br></li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN421559/">https://habr.com/ru/post/zh-CN421559/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN421549/index.html">我们正在编写技术文档：外行指南</a></li>
<li><a href="../zh-CN421551/index.html">精通Vuex-从零到英雄</a></li>
<li><a href="../zh-CN421553/index.html">我们共享技术内容：我们在一个站点上收集了所有材料</a></li>
<li><a href="../zh-CN421555/index.html">WideNES项目-超越NES屏幕的边界</a></li>
<li><a href="../zh-CN421557/index.html">公开课“ Java异步编程”</a></li>
<li><a href="../zh-CN421563/index.html">您可能需要改坐以摆脱背部疼痛。</a></li>
<li><a href="../zh-CN421565/index.html">粗鲁的类人机器人如何欺骗您</a></li>
<li><a href="../zh-CN421567/index.html">讨论：不寻常的便携式音响-跑车，复古收音机和“音响靴”</a></li>
<li><a href="../zh-CN421569/index.html">最重要的是Gamescom 2018-Nvidia RTX，Cyber​​punk 2077，Metro Exodus</a></li>
<li><a href="../zh-CN421571/index.html">基维 Xamarin 反应本机。 三个框架-一个实验（第3部分）</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>