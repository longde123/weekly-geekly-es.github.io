<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>⛑️ 👩🏼‍🏫 👨🏾‍🎤 数据库设计标准 📱 🤰🏽 🐺</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="从一个项目到另一个项目，尽管SQL已经存在了几十年，但不幸的是，我们仍面临缺乏统一的数据库设计标准的问题。 我怀疑原因部分是因为大多数开发人员都不了解数据库的体系结构。 在雇用开发人员的多年工作中，我只遇到过几次可以正确规范化数据库的人员。 老实说，这可能是一项艰巨的任务，但是我采访过的许多开发人员...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>数据库设计标准</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/mailru/blog/484188/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/pa/zj/ej/pazjejv8zvpor7tzaggxr54csd4.jpeg"></div><br> 从一个项目到另一个项目，尽管SQL已经存在了几十年，但不幸的是，我们仍面临缺乏统一的数据库设计标准的问题。 我怀疑原因部分是因为大多数开发人员都不了解数据库的体系结构。 在雇用开发人员的多年工作中，我只遇到过几次可以正确规范化数据库的人员。 老实说，这可能是一项艰巨的任务，但是我采访过的许多开发人员，即使他们精通SQL，也没有数据库设计技能。 <br><br> 本文与数据库规范化无关。 如果您想学习这一点，我<a href="https://youtu.be/y1tcbhWLiUM">在这里</a>简要地介绍了基本知识。 <br><br> 如果您有一个正常工作的数据库，则需要回答以下问题：“可以应用哪些标准来促进该数据库的<i>使用</i> ？”。 如果这些标准被广泛使用，那么您将很容易使用数据库，因为您不必在每次开始使用新数据库时都学习并记住新的标准集。 <br><a name="habracut"></a><br><h1>  CamelCase是命名还是下划线？ </h1><br> 我经常遇到数据库，其中的表以<code>CustomerOrders</code>或<code>customer_orders</code>的样式命名。 哪个更好用？ 也许您想应用一个已经建立的标准，但是如果您要创建一个新的数据库，那么我建议使用下划线来增加可访问性。 短语“低于价值”与“低于价值”相比具有不同的含义，但是带有下划线的第一个将始终为<code>under_value</code> ，第二个将始终为<code>under_value</code> 。 当使用CamelCase时，我们得到<code>UnderValue</code>和<code>UnderValue</code> ，它们在不区分大小写的SQL方面是相同的。 此外，如果您有视力问题，并不断尝试使用头戴式耳机和大头针来强调单词，那么下划线就更容易阅读了。 <br><br> 最后，对于那些英语不是母语的人，很难阅读CamelCase。 <br> 总而言之，这不是严格的建议，而是个人喜好。 <br><br><h1> 表名是复数还是单数？ </h1><br> 数据库理论专家已经争论了很长时间，表应该是单数（客户）还是复数（客户）。 让我不加理论地简单地切入这个Gordian难题，仅借助实用主义即可：复数表名与保留关键字的冲突可能性较小。 <br><br> 您有用户- <code>users</code>吗？  SQL具有<code>user</code>关键字。 您需要约束表吗？  <code>constraint</code>是保留字。  <code>audit</code>一词 <br> 保留，但是您需要<code>audit</code>表吗？ 只需使用名词的<i>复数</i>形式，然后大多数保留字就不会在SQL中打扰您。 甚至具有出色SQL解析器的PostgreSQL，也偶然发现了<code>user</code>表。 <br><br> 仅使用复数，冲突的可能性就会大大降低。 <br><br><h1> 请勿将ID为“ id”的列命名 </h1><br> 这些年来，我本人已经犯了罪。 当我在巴黎与一位客户合作时，当我将<code>id</code>列命名为<code>id</code>时，DBA投诉了我。 我以为他只是个学徒。 实际上，列名<code>customers.id</code>是唯一的，而<code>customers.customer_id</code>是信息的重复。 <br><br> 后来我不得不调试它： <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> thread.* <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> email <span class="hljs-keyword"><span class="hljs-keyword">thread</span></span> <span class="hljs-keyword"><span class="hljs-keyword">JOIN</span></span> email selected <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> selected.id = thread.id <span class="hljs-keyword"><span class="hljs-keyword">JOIN</span></span> <span class="hljs-built_in"><span class="hljs-built_in">character</span></span> recipient <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> recipient.id = thread.recipient_id <span class="hljs-keyword"><span class="hljs-keyword">JOIN</span></span> station_area sa <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> sa.id = recipient.id <span class="hljs-keyword"><span class="hljs-keyword">JOIN</span></span> station st <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> st.id = sa.id <span class="hljs-keyword"><span class="hljs-keyword">JOIN</span></span> star origin <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> origin.id = thread.id <span class="hljs-keyword"><span class="hljs-keyword">JOIN</span></span> star destination <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> destination.id = st.id <span class="hljs-keyword"><span class="hljs-keyword">LEFT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">JOIN</span></span> route <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> ( route.from_id = origin.id <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> route.to_id = destination.id ) <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> selected.id = ? <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> ( thread.sender_id = ? <span class="hljs-keyword"><span class="hljs-keyword">OR</span></span> ( thread.recipient_id = ? <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> ( origin.id = destination.id <span class="hljs-keyword"><span class="hljs-keyword">OR</span></span> ( route.distance <span class="hljs-keyword"><span class="hljs-keyword">IS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">NOT</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> <span class="hljs-keyword"><span class="hljs-keyword">now</span></span>() &gt;= thread.datesent + ( route.distance * <span class="hljs-built_in"><span class="hljs-built_in">interval</span></span> <span class="hljs-string"><span class="hljs-string">'30 seconds'</span></span> ) )))) <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> datesent <span class="hljs-keyword"><span class="hljs-keyword">ASC</span></span>, thread.parent_id <span class="hljs-keyword"><span class="hljs-keyword">ASC</span></span></code> </pre> <br> 注意到问题了吗？ 如果SQL使用完整的id名称，例如<code>email_id</code> ， <code>star_id</code>或<code>star_id</code> ，则这些错误将<i>在我编写此代码时</i>立即<i>消失</i> ，而不会在以后尝试理解错误之处时立即<i>消失</i> 。 <br><br> 帮个忙，并使用全名作为ID。 待会儿谢谢 <br><br><h1> 列名 </h1><br> 为列提供尽可能多的描述性名称。 假设<code>temperature</code>列与此无关： <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">name</span></span>, <span class="hljs-string"><span class="hljs-string">'too cold'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> areas <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> temperature &lt; <span class="hljs-number"><span class="hljs-number">32</span></span>;</code> </pre> <br> 我住在法国，对我们来说32度的温度将“太冷”。 因此，最好将<code>fahrenheit</code>列命名为。 <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">name</span></span>, <span class="hljs-string"><span class="hljs-string">'too cold'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> areas <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> fahrenheit &lt; <span class="hljs-number"><span class="hljs-number">32</span></span>;</code> </pre> <br> 现在一切都完全清楚了。 <br><br> 如果您有外键限制，请尽可能在限制两侧的列中使用相同的名称。 这是一个经过深思熟虑的合理SQL： <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> some_table s <span class="hljs-keyword"><span class="hljs-keyword">JOIN</span></span> some_other_table o <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> o.owner = s.person_id;</code> </pre> <br> 这段代码确实可以。 但是，当您查看表定义时，您会看到<code>some_other_table.owner</code>与<code>companies.company_id</code>具有外键约束。 因此从本质上讲，此SQL是错误的。 必须使用相同的名称： <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> some_table s <span class="hljs-keyword"><span class="hljs-keyword">JOIN</span></span> some_other_table o <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> o.company_id = s.person_id;</code> </pre> <br> 现在，我们可以很清楚地看到我们有一个错误，您只需要检查一行代码，而无需引用表定义。 <br><br> 但是，我要指出，这并非总是可以做到的。 如果您有一个包含源仓库和目的地的表，则可能要比较<code>source_id</code>和<code>destination_id</code>以及<code>source_id</code> 。 在这种情况下，最好提供名称<code>source_warehouse_id</code>和<code>destination_warehouse_id</code> 。 <br><br> 还要注意，在上面的示例中， <code>owner</code>将比<code>company_id</code>更好地描述目的。 如果这让您感到困惑，则可以命名<code>owning_company_id</code>列。 然后，名称将告诉您该列的用途。 <br><br><h1> 避免使用NULL值 </h1><br> 该建议已为许多经验丰富的数据库开发人员所熟知，但是不幸的是，他们讨论的次数不够多：没有充分的理由，不允许在数据库中使用NULL值。 <br> 这是一个重要但相当复杂的话题。 首先，我们讨论该理论，然后讨论其对数据库体系结构的影响，最后，我们将分析一个由于存在NULL值而引起的严重问题的实际示例。 <br><br><h2> 数据库类型 </h2><br> 数据库可以包含不同<i>类型的</i>数据：INTEGER，JSON，DATETIME等。该类型与列相关联，并且添加到该列的任何值都必须与此类型相对应。 <br><br> 但是什么是类型？ 这是一个名称，一组有效值和一组有效操作。 它们帮助我们避免了不良行为。 例如，如果您尝试比较字符串和数字，在Java中会发生什么？ <br><br><pre> <code class="sql hljs">CustomerAccount.java:5: error: bad operand types for binary operator '&gt;' if ( current &gt; threshold ) { ^ first type: String second type: int</code> </pre> <br> 即使您没有注意到<code>current &gt; threshold</code>比较的类型也无法比拟，编译器仍会为您抓住这一点。 <br><br> 具有讽刺意味的是，存储您的数据的数据库（也是您防范数据损坏的最后一道防线）与类型紧密合作！ 真恶心。 例如，如果您的<code>customers</code>表具有代理键，则可以执行以下操作： <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">name</span></span>, birthdate <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> customers <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> customer_id &gt; weight;</code> </pre> <br> 当然，这没有任何意义，实际上，您会遇到编译错误。 许多编程语言使捕获此类类型错误更加容易，但是对于数据库，情况恰恰相反。 <br><br> 这是数据库世界中的正常情况，可能是因为第<a href="https://www.contrib.andrew.cmu.edu/~shadow/sql/sql1992.txt">一个SQL标准于1992年发布</a> 。 在那些年中，计算机运行缓慢，毫无疑问，使实现复杂化的所有因素都降低了数据库的速度。 <br><br> 然后NULL值出现在场景中。  SQL标准仅在<code>IS NULL</code>和<code>IS NOT NULL</code>中的一个位置正确地实现了它们。 由于NULL值在定义上是未知的，因此无法为其设计运算符。 因此，有<code>IS NULL</code>和<code>IS NOT NULL</code>而不是<code>= NULL</code>和<code>!= NULL</code> 。  NULL值的任何比较都会导致出现新的NULL值。 <br><br> 如果您觉得这很奇怪，那么用“ unknown”（而不是NULL）代替NULL会容易得多： <br><br><blockquote> 比较<s>NULL</s>未知值会导致<s>NULL</s>未知值。 </blockquote><br> 是的，现在我明白了！ <br><br><h2> 空值是什么意思？ </h2><br> 武装理论的碎片，我们考虑它的实际后果。 <br><br> 您需要向所有当年薪水超过5万美元的员工支付$ 500的奖金。您可以编写以下代码： <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> employee_number, <span class="hljs-keyword"><span class="hljs-keyword">name</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> employees <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> salary &gt; <span class="hljs-number"><span class="hljs-number">50000</span></span>;</code> </pre> <br> 您刚刚被解雇了，因为您的老板收入超过5万美元，但是他的薪水不在数据库中（在<code>employees.salary</code>列中为NULL），并且比较运算符无法将NULL与5万进行比较。 <br><br> 为什么此列中为NULL？ 也许工资是保密的。 信息可能尚未到达。 也许这是一名顾问，却没有得到报酬。 也许他只有小时工资，而不是工资。 有<i>很多</i>原因可能导致数据丢失。 <br><br> 列中是否存在信息表明该信息取决于<i>其他情况</i> ，而不取决于主键和数据库的非规范化。 因此，其中可能存在NULL值的列是创建新表的良好候选者。 在这种情况下，您可能有<code></code>表，时<code>_</code> ， <code>__</code> <code></code>等。您仍然因盲目组合薪水而老板没有薪水而被解雇。 但是随后您的基地开始向您提供足够的信息，以表明该问题不仅仅是薪水问题。 <br><br> 是的，这是一个愚蠢的例子，但这是最后一根稻草。 <br><br><h2>  NULL值导致逻辑上不可能的情况 </h2><br> 在您看来，我对NULL值很感兴趣。 但是，让我们看另一个更接近现实的例子。 <br><br> 几年前，我在伦敦的一个域名注册商工作，试图理解为什么80行SQL查询返回错误的数据。 在那种情况下，肯定应该返回信息，但是这没有发生。 我很ham愧地承认，但是花了我一天的时间才知道原因是这样的综合条件： <br><br><ul><li> 我用了OUTER JOIN。 <br></li><li> 他们可以轻松生成NULL值。 <br></li><li>  NULL值可能导致SQL给出错误的答案。 <br></li></ul><br> 许多开发人员都不了解后者。因此，让我们看一看《 <a href="https://www.amazon.com/Database-Depth-Relational-Theory-Practitioners/dp/0596100124/">数据库中的深度</a> 》一书中的示例。 两个表的简单图： <br><br> <code>suppliers</code> <br> <div class="scrollable-table"><table><tbody><tr><td>  Supplier_id <br></td><td> 城市 <br></td></tr><tr><td>  s1 <br></td><td> 伦敦的 <br></td></tr></tbody></table></div><br> <code>parts</code> <br> <br><div class="scrollable-table"><table><tbody><tr><td>  part_id <br></td><td> 城市 <br></td></tr><tr><td>  1 <br></td><td> 空值 <br></td></tr></tbody></table></div><br> 很难找到一个更简单的例子。 <br><br> 此代码返回<code>p1</code> 。 <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> part_id <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> parts;</code> </pre> <br> 该代码将做什么？ <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> part_id <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> parts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> city = city;</code> </pre> <br> 它不会返回任何内容，因为即使是另一个NULL或相同的NULL，也无法比较NULL值。 看起来很奇怪，因为即使我们不知道，每条线上的城市也应该相同，对吗？ 那么什么将返回以下代码？ 在进一步阅读之前，请尝试理解此内容。 <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> s.supplier_id, p.part_id <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> suppliers s, parts p <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> p.city &lt;&gt; s.city <span class="hljs-keyword"><span class="hljs-keyword">OR</span></span> p.city &lt;&gt; <span class="hljs-string"><span class="hljs-string">'Paris'</span></span>;</code> </pre> <br> 我们没有得到一个响应字符串，因为我们无法比较city <code>NULL</code> （ <code>p.city</code> ），因此<code>WHERE</code>任何分支都不会导致<code>true</code> 。 <br><br> 但是，我们知道未知的城市要么是巴黎，要么不是巴黎。 如果是巴黎，则第一个条件为true（ <code>&lt;&gt; 'London'</code> ）。 如果不是巴黎，则第二个条件为true（ <code>&lt;&gt; 'Paris'</code> ）。 因此， <code>WHERE</code>必须为<code>true</code> ，但不是，因此，SQL生成逻辑上不可能的结果。 <br><br> 这是我在伦敦遇到的一个错误。 每次编写可生成或包含NULL值的SQL时，都有冒错误结果的风险。 这种情况很少发生，但是很难识别。 <br><br><h1> 总结 </h1><br><ul><li> 使用<code>__</code>代替<code>CamelCase</code> 。 <br></li><li> 表名必须为复数形式。 <br></li><li> 给具有标识符的字段扩展名称（ <code>item_id</code>而不是<code>id</code> ）。 <br></li><li> 避免使用不明确的列名。 <br></li><li> 如果可能，请使用与外键相同的名称为其命名。 <br></li><li> 尽可能将NOT NULL添加到所有列定义中。 <br></li><li> 尽可能避免编写可生成NULL值的SQL。 <br></li></ul><br> 尽管并不完美，但该数据库设计指南将使您的生活更轻松。 </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN484188/">https://habr.com/ru/post/zh-CN484188/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN484176/index.html">在Unity中实现状态模板</a></li>
<li><a href="../zh-CN484178/index.html">用于地球的智能以太网交换机</a></li>
<li><a href="../zh-CN484180/index.html">Rostelecom虚拟PBX：可以通过API进行哪些操作以及如何完成</a></li>
<li><a href="../zh-CN484182/index.html">Xenobots：来自青蛙细胞的活的纳米机器人</a></li>
<li><a href="../zh-CN484186/index.html">LDAP-“身份验证”是一种反模式</a></li>
<li><a href="../zh-CN484192/index.html">在Tar​​antool墨盒上轻松部署应用程序（第2部分）</a></li>
<li><a href="../zh-CN484194/index.html">Kubernetes翻译成儿童</a></li>
<li><a href="../zh-CN484196/index.html">记录来自麦克风的JS声音或语音注释</a></li>
<li><a href="../zh-CN484198/index.html">硬币的反面：谁在特斯拉股票的增长上赢了输</a></li>
<li><a href="../zh-CN484202/index.html">机器学习中静态分析程序源代码</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>