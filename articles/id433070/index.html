<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ§œğŸ½ ğŸ‘¨â€ğŸ‘©â€ğŸ‘§â€ğŸ‘§ ğŸ§‘â€ğŸ¤â€ğŸ§‘ Bagaimana membedakan sampo dari sampanye, dan tusuk sate dari sampanye ... Elasticsearch - mencari produk di database toko ğŸ“… ğŸ˜­ ğŸ‘§ğŸ½</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Tantangan 


 Salah satu tugas besar aplikasi untuk menyimpan dan menganalisis pembelian adalah untuk mencari produk yang identik atau sangat dekat da...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Bagaimana membedakan sampo dari sampanye, dan tusuk sate dari sampanye ... Elasticsearch - mencari produk di database toko</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/433070/"><h1 id="zadacha">  Tantangan </h1><br><p> Salah satu tugas besar aplikasi untuk menyimpan dan menganalisis pembelian adalah untuk mencari produk yang identik atau sangat dekat dalam database, yang berisi nama produk yang bervariasi dan tidak dapat dipahami yang diperoleh dari tanda terima.  Ada dua jenis permintaan input: </p><br><ol><li>  Nama spesifik dengan singkatan, yang hanya dapat dipahami oleh kasir di supermarket lokal, atau pembeli yang keranjingan. </li><li>  Kueri bahasa alami yang dimasukkan oleh pengguna dalam string pencarian. </li></ol><br><p>  Permintaan jenis pertama, sebagai aturan, berasal dari produk dalam cek itu sendiri, ketika pengguna perlu menemukan produk yang lebih murah.  Tugas kami adalah memilih analog produk yang paling mirip dari cek di toko-toko lain di dekatnya.  Penting untuk memilih merek produk yang paling tepat dan, jika mungkin, volume. </p><br><p><img src="https://habrastorage.org/webt/yp/_d/ny/yp_dnyvhrlrrrr6v0pa_6sz_ibk.jpeg"></p><a name="habracut"></a><br><p>  Jenis permintaan kedua adalah permintaan pengguna sederhana untuk mencari produk tertentu di toko terdekat.  Permintaan dapat berupa deskripsi produk yang sangat umum dan tidak unik.  Mungkin ada sedikit penyimpangan dari permintaan.  Misalnya, jika pengguna mencari susu 3,2%, dan dalam database kami hanya 2,5% susu, maka kami masih ingin menunjukkan setidaknya hasil ini. </p><br><p><img src="https://habrastorage.org/webt/ar/0-/03/ar0-03doeo4rgkrbni26iz9rek4.jpeg"></p><br><h1 id="osobennosti-dataseta--problemy-dlya-resheniya">  Fitur dataset - masalah yang harus dipecahkan </h1><br><p>  Informasi dalam tanda terima produk jauh dari ideal.  Ini memiliki banyak singkatan tidak selalu jelas, kesalahan tata bahasa, kesalahan ketik, berbagai terjemahan, huruf Latin di tengah-tengah alfabet Cyrillic dan set karakter yang masuk akal hanya untuk organisasi internal di toko tertentu. <br>  Misalnya, pure bayi apel-pisang dengan keju cottage dapat dengan mudah ditulis pada cek seperti ini: </p><br><p><img src="https://habrastorage.org/webt/kv/gg/23/kvgg23lcyv2h5gulck5k_9x1a-s.jpeg"></p><cut></cut><br><h1 id="o-tehnologii">  Tentang teknologi </h1><br><p>  Elasticsearch adalah teknologi yang cukup populer dan terjangkau untuk mengimplementasikan pencarian.  Ini adalah mesin pencari API JSON REST menggunakan Lucene dan ditulis dalam Java.  Keunggulan utama Elastic adalah kecepatan, skalabilitas, dan toleransi kesalahan.  Mesin serupa digunakan untuk pencarian kompleks dalam basis data dokumen.  Misalnya, pencarian dengan mempertimbangkan morfologi bahasa atau pencarian berdasarkan koordinat geografis. </p><br><h1 id="napravleniya-dlya-eksperimentov-i-uluchsheniy">  Petunjuk untuk eksperimen dan peningkatan </h1><br><p>  Untuk memahami bagaimana Anda dapat meningkatkan pencarian Anda, Anda perlu mengurai sistem pencarian menjadi komponen khusus komponennya.  Untuk kasus kami, struktur sistem terlihat seperti ini. </p><br><ol><li>  String input untuk pencarian melewati analyzer, yang dengan cara tertentu memecah string menjadi token - unit pencarian yang mencari di antara data yang juga disimpan sebagai token. </li><li>  Lalu ada pencarian langsung untuk token ini untuk setiap dokumen di database yang ada.  Setelah menemukan token dalam dokumen tertentu (yang juga disajikan dalam database sebagai satu set token), relevansinya dihitung menurut model Kesamaan yang dipilih (kami akan menyebutnya Model Relevansi).  Ini bisa berupa <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">TF / IDF</a> sederhana (Frekuensi Istilah - Frekuensi Dokumen Balik), atau bisa juga model yang lebih kompleks atau spesifik lainnya. </li><li>  Pada tahap berikutnya, jumlah poin yang dicetak oleh masing-masing token individu dikumpulkan dengan cara tertentu.  Parameter agregasi diatur oleh semantik kueri.  Contoh agregasi tersebut dapat berupa bobot tambahan untuk token tertentu (nilai tambah), ketentuan untuk keberadaan token wajib, dll.  Hasil dari tahap ini adalah Skor - penilaian akhir dari relevansi dokumen tertentu dari database relatif terhadap permintaan awal. </li></ol><br><p><img src="https://habrastorage.org/webt/_u/yg/zp/_uygzp1ohyyhtksrfuwbfvmi3r0.jpeg"></p><br><p>  Tiga komponen yang dapat dikonfigurasi secara terpisah dapat dibedakan dari perangkat pencarian, di mana masing-masingnya Anda dapat menyoroti cara dan metode peningkatan Anda sendiri. </p><br><ol><li>  Analisis </li><li>  Model kesamaan </li><li>  Peningkatan waktu permintaan </li></ol><br><p>  Selanjutnya, kami akan mempertimbangkan setiap komponen secara individual dan menganalisis pengaturan parameter khusus yang membantu meningkatkan pencarian dalam hal nama produk. </p><br><h3 id="query-time-uluchsheniya">  Peningkatan waktu permintaan </h3><br><p>  Untuk memahami apa yang dapat kami tingkatkan dalam permintaan, kami memberikan contoh permintaan awal. </p><br><pre><code class="sql hljs">{ "query": { "multi_match": { "query": "  105", "type": "most_fields", "fields": ["name"], "minimum_should_match": "70%" } }, â€œsizeâ€: 100, â€œmin_scoreâ€: 15 }</code> </pre> <br><p>  Kami menggunakan tipe kueri most_fields, karena kami memperkirakan perlunya kombinasi beberapa analis untuk bidang "nama produk".  Jenis kueri ini memungkinkan Anda untuk menggabungkan hasil pencarian untuk atribut yang berbeda dari objek yang berisi teks yang sama, dianalisis dengan cara yang berbeda.  Alternatif untuk pendekatan ini adalah dengan menggunakan kueri best_fields atau cross_fields, tetapi mereka tidak cocok untuk kasus kami, karena pencarian dihitung di antara berbagai atribut objek (misalnya: nama dan deskripsi).  Kita dihadapkan dengan tugas memperhitungkan berbagai aspek dari satu atribut - nama produk. </p><br><p>  Apa yang bisa dikonfigurasi: </p><br><ul><li>  Kombinasi tertimbang dari berbagai analisis. <br>  Awalnya, semua elemen pencarian memiliki bobot yang sama - dan karenanya, memiliki kepentingan yang sama.  Ini dapat diubah dengan menambahkan parameter 'boost', yang mengambil nilai numerik.  Jika parameter lebih besar dari 1, elemen pencarian akan memiliki dampak yang lebih besar pada hasil, masing-masing, kurang dari 1 - kurang. </li><li>  Pemisahan analisis menjadi 'harus' dan 'harus'. <br>  Yaitu, analisis tertentu harus sesuai, dan beberapa bersifat opsional, yaitu tidak cukup.  Dalam kasus kami, penganalisis angka dapat menjadi contoh manfaat pemisahan semacam itu.  Jika hanya nomor yang cocok dengan nama produk dalam permintaan dan nama produk dalam database, maka ini bukan kondisi yang cukup untuk kesetaraannya.  Kami tidak ingin melihat produk seperti itu sebagai hasilnya.  Pada saat yang sama, jika permintaannya adalah "krim 10%", maka kami ingin semua krim dengan lemak 10% memiliki keunggulan besar dibandingkan krim dengan lemak 20%. </li><li>  Parameter minimum_should_match.  Berapa banyak token yang harus cocok dengan permintaan dan dokumen dari database?  Parameter ini bekerja bersama dengan jenis permintaan kami (most_fields) dan memeriksa jumlah minimum token yang cocok untuk setiap bidang (dalam kasus kami, untuk setiap penganalisa). </li><li>  Parameter Min_score.  Dokumen penyaringan ambang batas dengan poin yang tidak mencukupi.  Tangkapannya adalah tidak ada kecepatan maksimum yang diketahui.  Skor yang dihasilkan tergantung pada permintaan spesifik dan pada basis data dokumen tertentu.  Kadang-kadang bisa 150, dan kadang-kadang 2, tetapi kedua nilai ini akan berarti bahwa objek dari database relevan dengan permintaan.  Kami tidak dapat membandingkan skor hasil kueri yang berbeda. <br><ul><li>  Konstan <br>  Setelah pemantauan yang cukup dari nilai akhir kecepatan untuk permintaan yang berbeda, Anda dapat mengidentifikasi batas perkiraan, setelah itu untuk sebagian besar permintaan hasilnya menjadi tidak pantas.  Ini adalah keputusan yang paling mudah, tetapi juga yang paling bodoh, yang mengarah pada pencarian berkualitas rendah. </li><li>  Cobalah untuk menganalisis skor yang diperoleh untuk permintaan tertentu setelah melakukan pencarian dengan minimum atau nol min_score. <br>  Idenya adalah bahwa setelah beberapa saat, Anda dapat mengamati lompatan tajam ke arah penurunan kecepatan.  Tetap hanya untuk menentukan lompatan ini agar berhenti tepat waktu.  Pendekatan semacam itu akan bekerja dengan baik pada pertanyaan serupa: <br><img src="https://habrastorage.org/webt/9z/qo/-u/9zqo-uovb_75ytduyti4byhmeyo.png"><br>  Lompatan ini dapat ditemukan dengan metode statistik.  Namun, sayangnya, tidak dalam semua permintaan lompatan ini ada dan mudah diidentifikasi. </li><li>  Hitung kecepatan ideal dan atur min_score sebagai fraksi tertentu dari ideal, yang dapat dilakukan dengan dua cara: <br><ul><li>  Dari uraian terperinci dari perhitungan yang disediakan oleh Elastis sendiri ketika mengatur menjelaskan: parameter benar.  Ini adalah tugas yang sulit, membutuhkan pemahaman menyeluruh tentang arsitektur permintaan dan algoritma komputasi yang digunakan oleh Elastic. </li><li>  Dengan sedikit trik.  Kami menerima permintaan, menambahkan produk baru ke database kami dengan nama yang sama, melakukan pencarian dan mendapatkan kecepatan maksimum.  Karena akan ada kecocokan 100% dalam nama, nilai yang dihasilkan akan ideal.  Pendekatan inilah yang kami gunakan dalam sistem kami, karena kekhawatiran tentang tingginya biaya operasi ini sehubungan dengan waktu belum dikonfirmasi. </li></ul></li></ul></li><li>  Ubah algoritma penilaian, yang bertanggung jawab atas nilai relevansi akhir.  Ini mungkin mempertimbangkan jarak ke toko (memberi lebih banyak poin ke produk yang lebih dekat), harga produk (memberikan lebih banyak poin ke produk dengan harga yang paling memungkinkan), dll. </li></ul><br><h3 id="analizatory">  Analisis </h3><br><p>  Penganalisa menganalisis string input dalam tiga tahap dan token output pada output - unit pencarian: </p><br><p><img src="https://habrastorage.org/webt/cd/vc/u8/cdvcu8tw-9wsrgelal2ii0waeio.jpeg"></p><br><p>  Pertama, perubahan terjadi pada level karakter string.  Ini bisa mengganti, menghapus, atau menambahkan karakter ke string.  Kemudian tokenizer mulai digunakan, yang dirancang untuk membagi string menjadi token.  Token standar membagi string menjadi token sesuai dengan tanda baca.  Pada langkah terakhir, token yang diterima difilter dan diproses. </p><br><p>  Pertimbangkan variasi langkah apa yang bermanfaat dalam kasus kami. </p><br><h5 id="char-filters">  Filter Char </h5><br><ul><li>  Menurut spesifikasi bahasa Rusia, akan berguna untuk memproses karakter seperti th dan e dan menggantinya dengan dan dan e, masing-masing. </li><li>  Lakukan transliterasi - transfer karakter satu tulisan dengan karakter tulisan lain.  Dalam kasus kami, ini adalah pemrosesan nama yang ditulis dalam bahasa Latin atau dicampur dengan kedua huruf.  Transliterasi dapat diimplementasikan menggunakan plug-in ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ICU Analysis Plugin</a> ) sebagai filter token (yaitu, ia memproses bukan string asli, tetapi token terakhir).  Kami memutuskan untuk menulis transliterasi kami, karena kami tidak cukup senang dengan algoritma di plugin.  Idenya adalah untuk menggantikan kejadian set empat karakter (misalnya, "SHCH =&gt; u"), kemudian kejadian tiga karakter, dll. Urutan di mana filter simbol digunakan adalah penting karena hasilnya akan tergantung pada urutan. </li><li>  Ganti bahasa Latin c, dikelilingi oleh bahasa Cyrillic, dengan huruf Rusia.  Kebutuhan untuk ini diidentifikasi setelah menganalisis nama-nama dalam database - sangat banyak nama dalam Cyrillic termasuk Latin c, yang berarti cyrillic c.  Ketika seolah-olah nama tersebut sepenuhnya dalam bahasa Latin, maka Latin C berarti Cyrillic k atau c.  Oleh karena itu, sebelum transliterasi, perlu untuk mengganti karakter c. </li><li>  Menghapus angka terlalu besar dari nama.  Terkadang dalam nama produk ada nomor identifikasi internal (mis. 3387522 K.T. Maslo podsoln.raf. 0.9l), yang tidak memiliki arti dalam kasus umum. </li><li>  Mengganti koma dengan titik.  Mengapa ini dibutuhkan?  Sehingga angka-angkanya, misalnya, kandungan lemak susu 3.2 dan 3.2, adalah setara </li></ul><br><h5 id="tokenizer">  Tokenizer </h5><br><ul><li>  Tokenizer standar - memisahkan garis sesuai dengan ruang dan tanda baca (misalnya, "twix extra 2" -&gt; "twix", "extra", "2") </li><li>  EdgeNGram tokenizer - membagi setiap kata menjadi token dengan panjang tertentu (biasanya rentang angka), dimulai dengan karakter pertama (misalnya, untuk N = [3, 6]: "twix extra 2" -&gt; "twee", "tweak", "Twix", "ex", "ext", "ext", "extra") </li><li>  Tokenizer untuk angka - memilih hanya angka dari string dengan mencari ekspresi reguler (mis., â€œTwix extra 2 4.5â€ -&gt; â€œ2â€, â€œ4.5â€) </li></ul><br><h5 id="token-filter">  Filter tanda </h5><br><ul><li>  Filter huruf kecil </li><li>  Filter Stamming - melakukan algoritma stamming untuk setiap token.  Berasal adalah untuk menentukan bentuk awal kata (misalnya, "beras" -&gt; "beras") </li><li>  Analisis fonetik.  Hal ini diperlukan untuk meminimalkan pengaruh kesalahan ketik dan berbagai cara penulisan kata yang sama pada hasil pencarian.  Tabel menunjukkan berbagai algoritma yang tersedia untuk analisis fonetik dan hasil kerjanya dalam kasus-kasus bermasalah.  Dalam kasus pertama (Shampoo / champagne / champignon / champignon) kesuksesan ditentukan oleh generasi pengkodean yang berbeda, sisanya - sama. </li></ul><br><p><img src="https://habrastorage.org/webt/gi/oi/x6/gioix68jytjyfxexdt3pvjpatze.png"></p><br><h3 id="similarity-model">  Model kesamaan </h3><br><p>  Model relevansi diperlukan untuk menentukan sejauh mana kebetulan satu token mempengaruhi relevansi objek dari database sehubungan dengan permintaan.  Misalkan jika token dalam permintaan dan produk dari database cocok - ini tentu saja tidak buruk, tetapi ia mengatakan sedikit tentang kesesuaian produk dengan permintaan.  Dengan demikian, kebetulan dari token yang berbeda membawa nilai yang berbeda.  Untuk mempertimbangkan hal ini, diperlukan suatu model relevansi.  Elastis menyediakan banyak model berbeda.  Jika Anda benar-benar memahaminya, maka Anda dapat memilih model yang sangat spesifik dan cocok untuk kasus tertentu.  Pilihannya dapat didasarkan pada jumlah kata yang sering digunakan (seperti token yang sama untuk), penilaian tentang pentingnya token panjang (lebih lama berarti lebih baik? Lebih buruk? Tidak masalah?), Hasil apa yang ingin kita lihat di bagian akhir, dll.  Contoh model yang diusulkan dalam Elastic dapat berupa TF-IDF (model paling sederhana dan paling mudah dipahami), <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Okapi BM25</a> (TF-IDF yang disempurnakan, model default), Divergensi dari keacakan, Divergensi dari independensi, dll.  Setiap model juga memiliki opsi yang dapat disesuaikan.  Setelah beberapa percobaan dengan model, model default Okapi BM25 menunjukkan hasil terbaik, tetapi dengan parameter yang berbeda dari yang telah ditentukan. </p><br><h1 id="ispolzovanie-kategoriy">  Menggunakan kategori </h1><br><p>  Selama bekerja dengan pencarian, informasi tambahan yang sangat penting tentang produk - kategorinya - menjadi tersedia.  Anda dapat membaca lebih lanjut tentang bagaimana kami menerapkan kategorisasi dalam artikel tersebut. <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Seperti yang saya pahami, saya makan banyak permen, atau klasifikasi barang dengan memeriksa aplikasi</a> .  Sampai saat itu, kami mendasarkan pencarian kami hanya pada perbandingan nama produk, sekarang menjadi mungkin untuk membandingkan kategori permintaan dan produk dalam database. <br>  Opsi yang memungkinkan untuk menggunakan informasi ini adalah kecocokan wajib dalam bidang kategori (diformat sebagai filter hasil), keuntungan tambahan dalam bentuk poin untuk barang dengan kategori yang sama (seperti dalam kasus angka) dan menyortir hasil berdasarkan kategori (pencocokan pertama, lalu yang lainnya).  Untuk kasus kami, opsi terakhir bekerja paling baik.  Ini karena algoritma kategorisasi kami terlalu bagus untuk menggunakan metode kedua, dan tidak cukup baik untuk menggunakan metode pertama.  Kami cukup percaya diri dalam algoritme dan menginginkan pencocokan kategori menjadi keuntungan besar.  Dalam hal menambahkan poin tambahan ke kecepatan (metode kedua), barang dengan kategori yang sama akan naik daftar, tetapi masih akan kehilangan beberapa barang yang lebih cocok dengan nama.  Namun, metode pertama juga tidak cocok untuk kita, karena kesalahan dalam kategorisasi masih dimungkinkan.  Terkadang permintaan mungkin mengandung informasi yang tidak cukup untuk menentukan kategori dengan benar, atau ada terlalu sedikit produk dalam kategori ini dalam radius langsung dari pengguna.  Dalam hal ini, kami masih ingin menampilkan hasil dengan kategori yang berbeda, tetapi masih relevan dengan nama produk. <br>  Metode kedua juga baik karena tidak "merusak" kecepatan produk sebagai hasil pencarian, dan memungkinkan Anda untuk terus menggunakan kecepatan minimum yang dihitung tanpa hambatan. <br>  Implementasi spesifik dari pengurutan dapat dilihat dalam permintaan akhir. </p><br><h1 id="finalnaya-model">  Model akhir </h1><br><p>  Pemilihan model pencarian akhir termasuk generasi berbagai mesin pencari, penilaian dan perbandingan mereka.  Paling sering, perbandingan didasarkan pada salah satu parameter.  Misalkan dalam satu kasus tertentu kita perlu menghitung ukuran terbaik untuk tokenizer edgeNgram (yaitu, memilih rentang N yang paling efektif).  Untuk melakukan ini, kami membuat mesin pencari yang sama dengan hanya satu perbedaan ukuran kisaran ini.  Setelah itu, dimungkinkan untuk menentukan nilai terbaik untuk parameter ini. <br>  Model dievaluasi menggunakan metrik nDCG (normalized discounted kumulative gain), metrik untuk menilai kualitas peringkat.  Kueri yang telah ditentukan dikirim ke setiap model pencarian, setelah itu nDCG metrik dihitung berdasarkan hasil pencarian yang diterima. <br>  Analisis yang memasuki model akhir: </p><br><p><img src="https://habrastorage.org/webt/nb/-m/ti/nb-mtitufklquryy-5o3m2trrl4.jpeg"></p><br><p><img src="https://habrastorage.org/webt/5n/y3/6g/5ny36gkpfblbdtr5xvu8b4fx_r4.jpeg"></p><br><p><img src="https://habrastorage.org/webt/2r/er/zv/2rerzvbqvsdgezshkhpfeds2mc0.jpeg"></p><br><p><img src="https://habrastorage.org/webt/5h/tv/69/5htv691pabkoks90jq08h6nmdxo.jpeg"></p><br><p>  Model default (Okapi - BM25) dengan parameter b = 0,5 dipilih sebagai model relevansi.  Nilai standarnya adalah 0,75.  Parameter ini menunjukkan sejauh mana panjang nama produk menormalkan variabel tf (frekuensi).  Jumlah yang lebih kecil dalam kasus kami berfungsi lebih baik, karena nama panjang sangat sering tidak memengaruhi signifikansi satu kata.  Artinya, kata "cokelat" dalam nama "cokelat dengan hazelnut hancur dalam paket 25 buah" tidak kehilangan nilainya dari kenyataan bahwa nama itu cukup panjang. </p><br><p>  Kueri akhir terlihat seperti ini: </p><br><p><img src="https://habrastorage.org/webt/ol/9y/5n/ol9y5nfbppfwyxhqaskziiypuru.jpeg"></p><br><p>  Secara eksperimental, kombinasi terbaik dari analisis dan bobot terungkap. </p><br><p>  Sebagai hasil penyortiran, produk dengan kategori yang sama pergi ke awal hasil, dan kemudian semua yang lain.  Penyortiran berdasarkan jumlah titik (kecepatan) disimpan dalam setiap subset. </p><br><p>  Untuk kesederhanaan, ambang batas untuk kecepatan diatur ke 15 dalam permintaan ini, meskipun dalam sistem kami, kami menggunakan parameter terhitung yang dijelaskan sebelumnya. </p><br><h1 id="v-buduschem">  Di masa depan </h1><br><p>  Ada pemikiran untuk meningkatkan pencarian dengan memecahkan salah satu masalah paling memalukan dalam algoritma kami, yaitu adanya sejuta dan satu cara berbeda untuk mempersingkat kata 5 huruf.  Ini bisa diselesaikan dengan pemrosesan awal nama untuk mengungkapkan singkatan.  Salah satu cara untuk mengatasinya adalah dengan mencoba membandingkan nama yang disingkat dari basis data kami dengan salah satu nama dari basis data dengan nama lengkap yang "benar".  Keputusan ini memenuhi hambatan yang pasti, tetapi tampaknya perubahan yang menjanjikan. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id433070/">https://habr.com/ru/post/id433070/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id433058/index.html">Quintet sebagai entitas dasar untuk menggambarkan area subjek</a></li>
<li><a href="../id433060/index.html">Kenapa saya tidak percaya microbenchmark</a></li>
<li><a href="../id433062/index.html">AXIS P1367 vs IDIS DC-B3303X: Bandingkan Kamera CCTV</a></li>
<li><a href="../id433064/index.html">Manajemen insiden: "Anda tidak bisa menyerah" atau seni menempatkan koma</a></li>
<li><a href="../id433066/index.html">HighLoad Cup # 2. Kejuaraan untuk pengembang backend kembali beroperasi</a></li>
<li><a href="../id433072/index.html">Cara meretas perlindungan salinan konsol Sega Dreamcast</a></li>
<li><a href="../id433074/index.html">Beralih ke Kotlin dalam proyek Android: Kiat dan Trik</a></li>
<li><a href="../id433076/index.html">Bagaimana kami membuat pustaka Galeri Android kami untuk melihat konten media</a></li>
<li><a href="../id433078/index.html">Kami menulis robot perdagangan menggunakan kerangka kerja grafis StockSharp. Bagian 2</a></li>
<li><a href="../id433082/index.html">Memompa akun orang lain telah menjadi pelanggaran pidana di Korea Selatan</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>