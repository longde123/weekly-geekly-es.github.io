<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👴🏽 🙅🏽 👩🏻‍🤝‍👨🏿 建议：try-内置错误检查功能 🕐 👩🏻‍🤝‍👨🏾 👧</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="总结 


提出了一个新的try构造，该构造专门设计用于消除if表达式通常与Go中的错误处理相关联。 这是唯一的语言更改。 作者支持使用defer和标准库函数来丰富或包装错误。 这个小的扩展几乎适用于大多数情况，而无需使语言复杂化。 


 try构造易于解释，易于实现，该功能与其他语言构造正交且完...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>建议：try-内置错误检查功能</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/472758/"><h2 id="kratkoe-soderzhanie"> 总结 </h2><br><p>提出了一个新的<code>try</code>构造，该构造专门设计用于消除<code>if</code>表达式通常与Go中的错误处理相关联。 这是唯一的语言更改。 作者支持使用<code>defer</code>和标准库函数来丰富或包装错误。 这个小的扩展几乎适用于大多数情况，而无需使语言复杂化。 </p><br><p>  <code>try</code>构造易于解释，易于实现，该功能与其他语言构造正交且完全向后兼容。 如果将来需要，它也可以扩展。 </p><br><p> 本文档的其余部分安排如下：在简要介绍之后，我们给出了内置函数的定义并解释了其在实践中的用法。 讨论部分回顾了替代建议和当前设计。 最后，将给出结论和实施计划，并附有示例以及一部分问题和答案。 </p><a name="habracut"></a><br><h2 id="vvedenie"> 引言 </h2><br><p> 在上一次在丹佛举行的Gophercon会议上，Go团队成员（Russ Cox，Marcel van Lohuizen）提出了一些有关如何减少Go（ <a href="">设计草案</a> ）中的手动错误处理的乏味的新想法。 从那以后，我们收到了大量反馈。 </p><br><p> 正如Russ Cox在<a href="">对问题的评论中所</a>解释的那样，我们的目标是通过减少专门用于错误检查的代码量来使错误处理更加轻巧。 我们还希望使编写错误处理代码更加方便，从而增加开发人员仍将时间花费在纠正错误处理上的可能性。 同时，我们希望使错误处理代码在程序代码中清晰可见。 </p><br><p> 草案中讨论的思想集中在新的一元<code>check</code>语句周围，该语句简化了对从某些表达式（通常是函数调用）中获得的错误值的显式验证，以及错误处理程序的声明和连接这两种新语言结构的一组规则。 </p><br><p> 我们收到的大多数反馈都集中在<code>handle</code>设计的细节和复杂性上，而<code>check</code>操作员的想法却变得更具吸引力。 实际上，社区中的一些成员采用了<code>check</code>操作员的想法并加以扩展。 以下是一些与我们提供的服务最相似的帖子： </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">PeterRK</a>在他的帖子中提出了第一个书面建议（对我们来说是众所周知的），它使用<code>check</code>构造代替运算符，这是<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">错误处理的关键部分</a> </li><li> 不久前， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Markus</a>提出了两个新关键字， <code>guard</code>和<code>must</code>以及使用<code>defer</code>来包装<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">＃31442中的</a>错误。 </li><li> 另外<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">pjebs</a>在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">＃32219中</a>建议<code>must</code>构造 </li></ul><br><p> 当前的提案尽管在细节上有所不同，但是基于这三个方面，并且总体上基于对去年提出的设计草案的反馈。 </p><br><p> 为了使图片更完整，我们要注意的是，可以在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">此Wiki页面</a>上找到更多错误处理建议。 还值得注意的是， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">利亚姆·布雷克（Liam Breck）</a>对错误处理机制提出了广泛的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">要求</a> 。 </p><br><p> 最终，在该建议发布之后，我们了解到<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Ryan Hileman在</a>五年前使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">og</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">rewriter</a>工具实施了<code>try</code>并成功地在实际项目中使用了它。 请参阅（ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">https://news.ycombinator.com/item?id=20101417</a> ）。 </p><br><h2 id="vstroennaya-funkciya-try"> 内置try功能 </h2><br><h3 id="predlozhenie"> 提供 </h3><br><p> 我们建议添加一个新的类似于函数的语言元素，称为<code>try</code>并使用签名进行调用 </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">try</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(expr)</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(T1, T2, ... Tn)</span></span></span></span></code> </pre> <br><p> 其中<code>expr</code>表示输入参数的表达式（通常是函数调用），该表达式返回n + 1个类型为<code>T1, T2, ... Tn</code>的值以及最后一个值的<code>error</code> 。 如果<code>expr</code>是单个值（n = 0），则该值必须为<code>error</code>类型，并且<code>try</code>不返回结果。 使用不返回类型<code>error</code>的最后一个值的表达式调用<code>try</code>导致编译错误。 </p><br><p>  <code>try</code>构造只能在至少返回一个值且最后一个返回值为<code>error</code>类型的<code>error</code> 。 在其他情况下调用<code>try</code>会导致编译错误。 </p><br><p> 如示例所示，使用<code>f()</code>函数调用<code>try</code> </p><br><pre> <code class="go hljs">x1, x2, … xn = try(f())</code> </pre> <br><p> 导致以下代码： </p><br><pre> <code class="go hljs">t1, … tn, te := f() <span class="hljs-comment"><span class="hljs-comment">// t1, … tn,  ()   if te != nil { err = te //  te    error return //     } x1, … xn = t1, … tn //     //    </span></span></code> </pre><br><p> 换句话说，如果<code>expr</code>返回的最后一个<code>error</code>类型为<code>nil</code> ，则<code>try</code>简单地返回前n个值，并删除最后的<code>nil</code> 。 </p><br><p> 如果<code>expr</code>返回的最后一个值不是<code>nil</code> ，则： </p><br><ul><li> 封闭函数的<code>error</code>返回值（在上面名为<code>err</code>的伪代码中，尽管它可以是任何标识符或未命名的返回值）接收从<code>expr</code>返回的错误值 </li><li> 从封装功能中退出 </li><li> 如果封闭函数具有其他返回参数，则这些参数将保留<code>try</code>调用之前其中包含的值。 </li><li> 如果封闭函数具有其他未命名的返回参数，则为它们返回相应的零值（这与保存用于初始化的原始零值相同）。 </li></ul><br><p> 如上例所示，如果在多个分配中使用了<code>try</code> ，并且检测到非零错误（以下称为non-nil-大约Per​​。），则不会执行分配（通过用户变量），并且分配左侧的任何变量都不会更改。 也就是说， <code>try</code>行为类似于函数调用：仅当<code>try</code>将控制权返回给调用者时（与从封闭函数返回的情况相反），其结果才可用。 因此，如果赋值左侧的变量是返回参数，则使用<code>try</code>会导致行为不同于现在遇到的典型代码。 例如，如果将<code>a,b, err</code>命名为封闭函数的返回参数，则此代码为： </p><br><pre> <code class="go hljs">a, b, err = f() <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> }</code> </pre> <br><p> 将始终为变量<code>a, b</code>和<code>err</code>赋值，而不管对<code>f()</code>的调用是否返回错误。 相反的挑战 </p><br><pre> <code class="go hljs">a, b = try(f())</code> </pre> <br><p> 如果发生错误，请保持<code>a</code>和<code>b</code>不变。 尽管这是一个细微的差别，但我们认为这种情况很少见。 如果需要无条件分配行为，则必须继续使用<code>if</code>表达式。 </p><br><h3 id="ispolzovanie"> 使用方法 </h3><br><p>  <code>try</code>的定义明确地告诉您如何使用它：许多<code>if</code>检查错误返回的表达式可以用<code>try</code>代替。 例如： </p><br><pre> <code class="go hljs">f, err := os.Open(filename) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> …, err <span class="hljs-comment"><span class="hljs-comment">//       }</span></span></code> </pre> <br><p> 可以简化为 </p><br><pre> <code class="go hljs">f := try(os.Open(filename))</code> </pre> <br><p> 如果调用函数没有返回错误，则不能使用<code>try</code> （请参见“讨论”部分）。 在这种情况下，无论如何都应在本地处理错误（因为没有错误返回），在这种情况下， <code>if</code>仍然存在适当的机制来检查错误。 </p><br><p> 一般而言，我们的目标不是用<code>try</code>替换所有可能的错误检查。  <code>if</code>表达式和显式变量带有错误值，则需要不同语义的代码可以并且应该继续使用。 </p><br><h3 id="testirovanie-i-try"> 测试并尝试 </h3><br><p> 在我们较早编写规范的尝试之一（请参阅下面的设计迭代部分）中， <code>try</code>在没有返回错误的情况下在函数内使用时发生错误时， <code>try</code>会引起恐慌。 这允许基于标准库的<code>testing</code>包使用<code>try</code>单元测试。 </p><br><p> 作为选项之一，可以在<code>testing</code>包中使用带有签名的测试功能 </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TestXxx</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(*testing.T)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BenchmarkXxx</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(*testing.B)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span></span></code> </pre> <br><p> 为了允许使用测试。 返回非零错误的测试函数将隐式调用<code>t.Fatal(err)</code>或<code>b.Fatal(err)</code> 。 这是一个很小的库更改，根据上下文，避免了<code>try</code>不同行为（返回或恐慌）的需要。 </p><br><p> 这种方法的缺点之一是<code>t.Fatal</code>和<code>b.Fatal</code>将无法返回测试所在的行号。 另一个缺点是我们也必须以某种方式更改子测验。 这个问题的解决方案是一个悬而未决的问题。 在本文档中，我们不建议对<code>testing</code>包进行特定更改。 </p><br><p> 另请参见<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">＃21111</a> ，它建议允许示例函数返回错误。 </p><br><h3 id="obrabotka-oshibok"> 错误处理 </h3><br><p> 原始<a href="">设计草案</a>主要涉及对包装错误或错误扩充的语言支持。 草案提出了新的关键字<code>handle</code>和<em>声明错误处理程序</em>的新方法。 这种新的语言结构由于非平凡的语义而吸引了像苍蝇这样的问题，尤其是考虑到它对执行流程的影响时。 特别是， <code>handle</code>功能与<code>defer</code>函数痛苦地交叉，这使得新语言功能与其他所有功能都不正交。 </p><br><p> 该提议将原始草案设计简化为实质。 如果需要扩充或错误包装，则有两种方法： <code>if err != nil { return err}</code>附加，或在<code>defer</code>表达式中“声明”错误处理程序： </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">defer</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-comment"><span class="hljs-comment">//      -   err = … // /  } }()</span></span></code> </pre> <br><p> 在此示例中， <code>err</code>是封闭函数的类型为<code>error</code>的返回参数的名称。 </p><br><p> 在实践中，我们可以想象这样的助手功能： </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">HandleErrorf</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(err *error, format </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">, args ...</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">interface</span></span></span></span><span class="hljs-function"><span class="hljs-params">{})</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> *err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { *err = fmt.Errorf(format + <span class="hljs-string"><span class="hljs-string">": %v"</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">append</span></span>(args, *err)...) } }</code> </pre><br><p> 或类似的东西。  <code>fmt</code>软件包可以成为此类帮助者的自然选择（它已经提供了<code>fmt.Errorf</code> ）。 使用帮助程序，错误处理程序的定义在许多情况下将简化为一行。 例如，要丰富“复制”功能中的错误，可以编写 </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">defer</span></span> fmt.HandleErrorf(&amp;err, <span class="hljs-string"><span class="hljs-string">"copy %s %s"</span></span>, src, dst)</code> </pre><br><p> 如果<code>fmt.HandleErrorf</code>隐式添加错误信息，则这种结构相当容易阅读，并且具有无需添加语言语法新元素即可实现的优点。 </p><br><p> 这种方法的主要缺点是必须命名返回的错误参数，这可能会导致API的准确性降低（请参阅本主题的FAQ）。 我们相信，一旦建立了适当的编写代码样式，我们就会习惯它。 </p><br><h3 id="effektivnost-defer"> 效率延迟 </h3><br><p> 使用<code>defer</code>作为错误处理程序时的重要考虑因素是效率。  <code>defer</code>表达被认为是<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">缓慢的</a> 。 我们不想在高效的代码和良好的错误处理之间进行选择。 不管提出什么建议，Go运行时团队和编译器团队都讨论了替代的实现方法，我们相信我们可以采用典型的方式来使用defer处理与现有“手动”代码效率相当的错误。 我们希望在Go 1.14中添加一个更快的<code>defer</code>实现（另请参见<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">故障</a>单<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">CL 171158</a> ，这是朝此方向迈出的第一步）。 </p><br><h3 id="specialnye-sluchai-go-tryf-defer-tryf"> 特殊情况<code>go try(f), defer try(f)</code> </h3><br><p>  <code>try</code>构造看起来像一个函数，因此，可以在可以接受函数调用的任何地方使用它。 但是，如果在<code>go</code>语句中使用了<code>try</code>调用，事情将会变得复杂： </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">go</span></span> try(f())</code> </pre><br><p> 这里的<code>f()</code>是在当前goroutine中执行go表达式时执行的，调用<code>f</code>的结果作为参数传递给<code>try</code> ， <code>try</code>从新的goroutine开始。 如果<code>f</code>返回非零错误，则期望<code>try</code>从封闭函数返回；否则，返回false。 但是，没有功能（也没有类型为<code>error</code>返回参数），因为 该代码在单独的goroutine中执行。 因此，我们建议禁用<code>go</code>表达式中的<code>try</code> 。 </p><br><p> 情况与 </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">defer</span></span> try(f())</code> </pre><br><p> 看起来很相似，但是在这里<code>defer</code>的语义意味着<code>try</code>的执行将被延迟，直到它从封闭函数返回为止。 和以前一样，在<code>defer</code>时对<code>f()</code>进行求值，并将其结果传递给deferred <code>try</code> 。 </p><br><p>  <code>try</code>检查仅在从封闭函数返回之前的最后一刻返回的错误<code>f()</code> 。 在不更改<code>try</code>行为的情况下，此类错误可以覆盖封闭函数尝试返回的另一个错误值。 这充其量会混淆，最糟糕的是会引发错误。 因此，我们建议您也禁止在<code>defer</code>语句中调用<code>try</code> 。 如果可以合理地使用这种语义，我们总是可以重新考虑这个决定。 </p><br><p> 最后，像其余的内置结构一样， <code>try</code>只能用作调用。 不能将其用作值函数或变量赋值表达式，如<code>f := try</code> （就像<code>f := print</code>和<code>f := new</code>一样）。 </p><br><h2 id="obsuzhdenie"> 讨论区 </h2><br><h3 id="iteracii-dizayna"> 设计迭代 </h3><br><p> 以下是对导致当前最小提议的早期设计的简短讨论。 我们希望这将为选定的设计决策提供启发。 </p><br><p> 我们从<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">“错误处理的关键部分”</a>一文中得到的两个想法启发了这句话的第一次迭代<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">，</a>即使用内置函数代替运算符，并使用通常的Go函数代替新的语言构造来处理错误。 与该出版物不同，我们的错误处理程序具有固定的签名<code>func(error) error</code>以简化事务。 如果在<code>try</code>退出封闭函数之前发生错误，则<code>try</code>函数将调用错误处理程序。 这是一个例子： </p><br><pre> <code class="go hljs">handler := <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(err error)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> fmt.Errorf(<span class="hljs-string"><span class="hljs-string">"foo failed: %v"</span></span>, err) <span class="hljs-comment"><span class="hljs-comment">//   } f := try(os.Open(filename), handler) //     </span></span></code> </pre><br><p> 尽管此方法允许定义有效的用户定义错误处理程序，但它还提出了许多显然没有正确答案的问题：如果将nil传递给处理程序，该怎么办？ 您是否应该感到恐慌或将其视为缺乏处理程序？ 如果以非零错误调用处理程序，然后返回空结果怎么办？ 这是否意味着错误已“消除”？ 还是封闭函数返回一个空错误？ 还有人怀疑错误处理程序的可选传输会鼓励开发人员忽略错误而不是纠正错误。 在各处进行正确的错误处理也很容易，但是跳过<code>try</code>一种用法。 等等。 </p><br><p> 在下一次迭代中，删除了传递自定义错误处理程序的功能，转而使用<code>defer</code>包裹错误。 这似乎是一种更好的方法，因为它使错误处理程序在源代码中更加引人注目。 此步骤还消除了与处理程序函数的可选传输有关的所有问题，但是，如果需要访问，则要求命名具有<code>error</code>类型的返回参数（我们认为这是正常的）。 此外，为了使<code>try</code>不仅在返回错误的函数中有用，还必须使<code>try</code>上下文的行为变得敏感：如果<code>try</code>在包级别使用的，或者如果它在不返回错误的函数中被调用，则在检测到错误时<code>try</code>自动惊慌。  （而且，副作用是，由于这个属性，所以<code>must</code>在该句子中调用该语言构造，而不是使用<code>try</code> 。） <code>try</code> （或<code>must</code> ）的上下文相关行为似乎很自然并且也非常有用：它将消除在表达式中使用的许多用户定义函数初始化程序包变量。 这也为在<code>testing</code>包中使用单元测试中的可能性提供了可能性。 </p><br><p> 但是， <code>try</code>的上下文相关行为充满了错误：例如，当在函数签名中添加或删除返回错误时，使用<code>try</code>的函数的行为可能会悄悄更改（无论是否紧急）。 这似乎太危险了。 显而易见的解决方案是将<code>try</code>功能分为两个单独的<code>must</code>和<code>try</code>函数（非常类似于<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">＃31442</a>中建议的方式）。 但是，这将需要两个内置函数，而仅<code>try</code>与更好地支持错误处理直接相关。 </p><br><p> 因此，在当前迭代中，我们决定删除<code>try</code>的双重语义，而不是包括第二个内置函数，因此，仅允许将其用于返回错误的函数中。 </p><br><h3 id="osobennosti-predlozhennogo-dizayna"> 拟议设计的特点 </h3><br><p> 这个建议很短，与去年的草案相比似乎有些退步。 我们认为所选解决方案是合理的： </p><br><ul><li><p> 首先， <code>try</code>的语义与原始文档中提出的<code>check</code>语句完全相同，没有<code>handle</code> 。 这在重要方面之一中确认了原始草案的真实性。 </p><br></li><li><p> 选择内置函数而不是运算符具有多个优点。 它不需要像<code>check</code>这样的新关键字，它会使设计与现有解析器不兼容。 也不需要使用新的运算符来扩展表达式的语法。 添加一个新的内置函数相对来说是微不足道的，并且与该语言的其他功能完全正交。 </p><br></li><li><p> 使用内联函数而不是运算符需要使用括号。 我们应该写<code>try(f())</code>而不是<code>try f()</code> 。 这是与现有解析器向后兼容所必须付出的（小）价格。 但是，这也使设计与将来的版本兼容：如果我们一路认为以某种形式传递错误处理函数或为此目的添加附加参数来<code>try</code>是个好主意，则在<code>try</code>调用中添加附加参数将是微不足道的。 </p><br></li><li><p> 事实证明，需要使用方括号有其优点。 在具有多个<code>try</code>调用的更复杂的表达式中，括号消除了对运算符优先级的处理，从而提高了可读性，如以下示例所示： </p><br></li></ul><br><pre> <code class="go hljs">info := try(try(os.Open(file)).Stat()) <span class="hljs-comment"><span class="hljs-comment">//   try info := try (try os.Open(file)).Stat() //  try   info := try (try (os.Open(file)).Stat()) //  try  </span></span></code> </pre><br><p>     <code>try</code> ,      :       <code>try</code> , ..   <code>try</code>   (receiver)  <code>.Stat</code> (  <code>os.Open</code> ). </p><br><p>     <code>try</code> ,        :    <code>os.Open(file)</code> ..       <code>try</code> (  ,   <code>try</code>    <code>os</code> ,   ,   <code>try</code>      <code>try</code> ). </p><br><p>           , ..      . </p><br><ul><li>           .   ,          .   ,      ,      ,     . </li></ul><br><h2 id="vyvody"> 结论 </h2><br><p>       <a href="">  </a>         .    ,      .            <code>defer</code> ,           . </p><br><p>  Go         -  ,         . ,   Go     <code>append</code> .     <code>append</code>         ,   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="></a>     .    ,       .  ,        <code>try</code> . </p><br><p>          ,     ,   Go      : <code>panic</code>  <code>recover</code> .   <code>error</code>   <code>try</code>   . </p><br><p>  , <code>try</code>     ,     ,      —      —   ,     .        Go: </p><br><ul><li>       </li><li>     , <code>try</code>       </li><li>      </li><li>    - </li></ul><br><p>        ,    ,       .     <code>if</code> -. </p><br><h2 id="realizaciya"> 实作 </h2><br><p>   : </p><br><ul><li>   Go. </li><li>     <code>try</code> . ,            .      . </li><li>  <code>go/types</code>  <code>try</code> .   . </li><li>    <code>gccgo</code> . ( ,  ). </li><li>      . </li></ul><br><p>    -  ,     . ,        .           . </p><br><p> Robert Griesemer    <code>go/types</code> ,     () <code>cmd/compile</code> .    ,         Go 1.14,  1  2019. </p><br><p> , Ian Lance Taylor    <code>gccgo</code> ,    . </p><br><p>     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">"Go 2,  !"</a> ,                . </p><br><p> 1 ,    ,      ,    Go 1.14  . </p><br><p>  </p><br><p>  <code>CopyFile</code>     : </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CopyFile</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(src, dst </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(err error)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">defer</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { err = fmt.Errorf(<span class="hljs-string"><span class="hljs-string">"copy %s %s: %v"</span></span>, src, dst, err) } }() r := try(os.Open(src)) <span class="hljs-keyword"><span class="hljs-keyword">defer</span></span> r.Close() w := try(os.Create(dst)) <span class="hljs-keyword"><span class="hljs-keyword">defer</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { w.Close() <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { os.Remove(dst) <span class="hljs-comment"><span class="hljs-comment">//    “try”    } }() try(io.Copy(w, r)) try(w.Close()) return nil }</span></span></code> </pre><br><p>   ,    " ",  <code>defer</code>  : </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">defer</span></span> fmt.HandleErrorf(&amp;err, <span class="hljs-string"><span class="hljs-string">"copy %s %s"</span></span>, src, dst)</code> </pre><br><p>           (  <code>defer</code> -),        <code>defer</code>     ,    . </p><br><p>  <code>printSum</code>          </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">printSum</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(a, b </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span></span> { x := try(strconv.Atoi(a)) y := try(strconv.Atoi(b)) fmt.Println(<span class="hljs-string"><span class="hljs-string">"result:"</span></span>, x + y) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span> }</code> </pre><br><p>   : </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">printSum</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(a, b </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span></span> { fmt.Println( <span class="hljs-string"><span class="hljs-string">"result:"</span></span>, try(strconv.Atoi(a)) + try(strconv.Atoi(b)), ) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span> }</code> </pre><br><p>  <code>main</code>  <a href="">   </a>      : </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">localMain</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span></span> { hex := try(ioutil.ReadAll(os.Stdin)) data := try(parseHexdump(<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>(hex))) try(os.Stdout.Write(data)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err := localMain(); err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { log.Fatal(err) } }</code> </pre><br><p> -   <code>try</code>      ,        : </p><br><pre> <code class="plaintext hljs">n, err := src.Read(buf) if err == io.EOF { break } try(err)</code> </pre><br><h2 id="voprosy-i-otvety">    </h2><br><p> ,     . </p><br><p> <strong>:        ?</strong> </p><br><p> :        <code>check</code>  <code>handle</code> ,     .  ,  <code>handle</code>          <code>defer</code> ,   <code>handle</code>   . </p><br><p> <strong>:  try   ?</strong> </p><br><p> :    <code>try</code>     Go     .       -  ,           .          ,     .        ,     "  ".  <code>try</code>     , ..          . </p><br><p> <strong>:  <code>try</code>  try?</strong> </p><br><p> :    ,  <code>check</code> , <code>must</code>  <code>do</code> .   <code>try</code>            ,           . <code>try</code>       <code>check</code> (,        ),  -       .         .         <code>must</code>          ; <code>try</code> —  . ,  Rust  Swift   <code>try</code>       (   ).         . </p><br><p> <strong>:      <code>?</code>   Rust?</strong> </p><br><p> : Go      ;  ,           Go (        ;   -   ).         ,     <code>?</code> ,      .   , ,   ,     (package, interface, if, append, recover, ...),  ,        (struct, var, func, int, len, image,  ..). Rust   <code>?</code>     <code>try</code>   —      Go,    ,   (   )   . ,  <code>?</code>      .    ,   ,     (,   ..)  .       .       ,   . </p><br><p> <strong>:       ( error)  ,  defer   ,   go doc.    ?</strong> </p><br><p> :     <code>go doc</code>   ,       -   ( <code>_</code> ) ,         . ,  <code>func f() (_ A, _ B, err error)</code>    <code>go doc</code>  <code>func f() (A, B, error)</code> .      ,   ,     ,      .  ,         ,     . ,   ,    ,       -,       (deferred) .    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Jonathan Geddes</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="></a>   <code>try()</code>        . </p><br><p> <strong>:     defer    ?</strong> </p><br><p> :    <code>defer</code>          . ,  ,       defer         "" . .  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">CL 171758</a> ,     defer   30%. </p><br><p> <strong>:           ?</strong> </p><br><p> :  ,        . ,         ( ,    ),      .     <code>defer</code>              ,     .   <code>defer</code> -   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">https://golang.org/issue/29934</a> (   Go 2),    . </p><br><p> <strong>:  ,   try,    error.  ,       ?</strong> </p><br><p> :           <code>error</code> (  )   ,  ,     <code>nil</code> .           <code>try</code> . (      ,  .     - ). </p><br><p> <strong>:    Go  ,     try   ?</strong> </p><br><p> :  <code>try</code>     ,   <code>try</code> .    <code>super return</code> -, <code>try</code>      <code>Go</code>        . <code>try</code>       .     <em></em>  . </p><br><p> <strong>:     try   ,         .   ?</strong> </p><br><p> : <code>try</code>        ;       ,     .       <code>try</code>    ( ),     .   , <code>if</code>   . </p><br><p> <strong>:   ,       .    try,    defer    .   ?</strong> </p><br><p> :         ,       .     . </p><br><p> <strong>:  <code>try</code>     (  <code>catch</code> )?</strong> </p><br><p> : <code>try</code> —   ("")      ,  ,      (    )   . <code>try</code>   ;       .        .     "" .     ,        .  , <code>try</code> —      .   ,  ,       <code>throw</code>  <code>try-catch</code>     Go. ,         (,    ),     (   )     ,      .    ""      <code>try-catch</code> ,       . ,    ,      .  Go    .     <code>panic</code> ,       . </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN472758/">https://habr.com/ru/post/zh-CN472758/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN472746/index.html">管理员终端服务器； SSH差距不大</a></li>
<li><a href="../zh-CN472748/index.html">语义浏览器或没有网站的生活</a></li>
<li><a href="../zh-CN472750/index.html">好吧，我真的需要Kubernetes吗？</a></li>
<li><a href="../zh-CN472752/index.html">CSE：适用于vCloud中任何人的Kubernetes</a></li>
<li><a href="../zh-CN472754/index.html">一个月内怎么说英语。 9个简单有效的步骤</a></li>
<li><a href="../zh-CN472760/index.html">将计算时间从几年减少到几分钟。 了解量子机器学习</a></li>
<li><a href="../zh-CN472762/index.html">checkm8漏洞利用的技术分析</a></li>
<li><a href="../zh-CN472766/index.html">从py.test中的文件进行参数化</a></li>
<li><a href="../zh-CN472768/index.html">如何聘用，解雇管理人员并从管理人员返回开发人员：Badoo Techleads Meetup＃5的视频</a></li>
<li><a href="../zh-CN472770/index.html">使用UI Canvas进行Unity中的界面组织</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>