<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üöé üßëüèº‚Äçü§ù‚Äçüßëüèª ü§≥üèº WAL no PostgreSQL: 3. Ponto de Verifica√ß√£o üèÇüèø ‚úçüèæ üòÑ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="J√° nos familiarizamos com o dispositivo de cache de buffer , um dos principais objetos da mem√≥ria compartilhada, e percebemos que, para recuperar-se d...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>WAL no PostgreSQL: 3. Ponto de Verifica√ß√£o</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/postgrespro/blog/460423/">  J√° nos familiarizamos com o dispositivo de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">cache de buffer</a> , um dos principais objetos da mem√≥ria compartilhada, e percebemos que, para recuperar-se de uma falha quando o conte√∫do da RAM √© perdido, √© necess√°rio manter um <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">registro de pr√©-registro</a> . <br><br>  O problema n√£o resolvido que paramos na √∫ltima vez √© que n√£o se sabe em que ponto voc√™ pode come√ßar a reproduzir os logs durante a recupera√ß√£o.  Come√ßar do in√≠cio, como o rei de <em>Alice</em> aconselhou, n√£o funcionar√°: √© imposs√≠vel armazenar todas as entradas do di√°rio desde o in√≠cio do servidor - isso √© potencialmente uma quantidade enorme e o mesmo tempo de recupera√ß√£o.  Precisamos de um ponto de avan√ßo progressivo a partir do qual possamos iniciar a recupera√ß√£o (e, portanto, podemos excluir com seguran√ßa todos os lan√ßamentos cont√°beis anteriores).  Este √© o <em>ponto de controle</em> que ser√° discutido hoje. <br><br><h1>  Ponto de controle </h1><br>  Que propriedade um ponto de controle deve ter?  Devemos ter certeza de que todos os lan√ßamentos cont√°beis manuais, a partir do ponto de verifica√ß√£o, ser√£o aplicados √†s p√°ginas gravadas no disco.  Se n√£o fosse assim, durante a restaura√ß√£o, poder√≠amos ler no disco uma vers√£o muito antiga da p√°gina e aplicar uma entrada de di√°rio a ela, danificando permanentemente os dados. <br><a name="habracut"></a><br>  Como obter um ponto de interrup√ß√£o?  A op√ß√£o mais f√°cil √© suspender periodicamente o sistema e liberar todas as p√°ginas sujas do buffer e outros caches no disco.  (Observe que as p√°ginas s√£o gravadas apenas, mas n√£o s√£o ejetadas do cache.) Esses pontos satisfazem a condi√ß√£o, mas, √© claro, ningu√©m deseja trabalhar com um sistema que congela constantemente por tempo indeterminado, mas muito significativo. <br><br>  Portanto, na pr√°tica, tudo √© um pouco mais complicado: um ponto de controle de um ponto se transforma em um segmento.  Primeiro, <em>come√ßamos o</em> ponto de interrup√ß√£o.  Depois disso, sem interromper o trabalho e, se poss√≠vel, sem criar picos de carga, despejamos lentamente buffers sujos no disco. <br><br><img src="https://habrastorage.org/webt/n0/ch/6f/n0ch6fdrfxkylmuqjdar7idfxsw.png"><br><br>  Quando todos os buffers que estavam sujos <em>no in√≠cio do</em> ponto <em>de</em> verifica√ß√£o foram gravados, o ponto de verifica√ß√£o √© considerado <em>completo</em> .  Agora (mas n√£o antes), podemos usar o ponto <em>inicial</em> como o ponto a partir do qual voc√™ pode iniciar a recupera√ß√£o.  E os lan√ßamentos cont√°beis at√© esse ponto n√£o precisamos mais. <br><br><img src="https://habrastorage.org/webt/q4/th/83/q4th83seql63dkrgfmg7esu3zh8.png"><br><br>  O ponto de verifica√ß√£o √© tratado por um processo especial de apontador de verifica√ß√£o em segundo plano. <br><br>  A dura√ß√£o dos buffers sujos √© determinada pelo valor do par√¢metro <em>checkpoint_completion_target</em> .  Mostra quanto tempo entre dois pontos de controle adjacentes a grava√ß√£o ocorrer√°.  O valor padr√£o √© 0,5 (como nas figuras acima), ou seja, a grava√ß√£o leva metade do tempo entre os pontos de controle.  Normalmente, o valor √© aumentado para 1,0 para maior uniformidade. <br><br>  Vamos considerar com mais detalhes o que acontece quando um ponto de controle √© executado. <br><br>  O processo do ponto de verifica√ß√£o libera primeiro os buffers de status da transa√ß√£o (XACT) no disco.  Como existem alguns deles (128 no total), eles s√£o gravados imediatamente. <br><br>  Ent√£o o trabalho principal come√ßa - escrevendo p√°ginas sujas do cache do buffer.  Como j√° dissemos, √© imposs√≠vel redefinir todas as p√°ginas de uma vez, pois o tamanho do cache do buffer pode ser significativo.  Portanto, primeiro, todas as p√°ginas sujas atualmente s√£o marcadas no cache do buffer nos cabe√ßalhos com um sinalizador especial. <br><br><img src="https://habrastorage.org/webt/_4/ym/eq/_4ymeqozl8o23kwq6su9ntvjujk.png"><br><br>  E ent√£o o processo do ponto de verifica√ß√£o passa gradualmente por todos os buffers e libera os marcados no disco.  Lembre-se de que as p√°ginas n√£o s√£o ejetadas do cache, mas s√£o gravadas apenas no disco, portanto, voc√™ n√£o precisa prestar aten√ß√£o ao n√∫mero de chamadas ao buffer ou √† sua corre√ß√£o. <br><br>  Os buffers rotulados tamb√©m podem ser gravados pelos processos do servidor - dependendo de quem chega primeiro ao buffer.  Em qualquer caso, o sinalizador definido anteriormente √© removido durante a grava√ß√£o, portanto (para fins do ponto de verifica√ß√£o) o buffer ser√° gravado apenas uma vez. <br><br>  Naturalmente, durante a execu√ß√£o do ponto de verifica√ß√£o, as p√°ginas continuam a mudar no cache do buffer.  Mas os novos buffers sujos n√£o s√£o sinalizados e o processo do ponto de verifica√ß√£o n√£o deve grav√°-los. <br><br><img src="https://habrastorage.org/webt/fg/uo/vm/fguovmm8yzy0jb4jwisgg10nmm8.png"><br><br>  No final de seu trabalho, o processo cria um lan√ßamento no di√°rio para o final do ponto de verifica√ß√£o.  Este registro cont√©m o LSN do in√≠cio do trabalho do ponto de controle.  Como o ponto de controle n√£o grava nada no log no in√≠cio de seu trabalho, esse LSN pode conter qualquer registro de log. <br><br>  Al√©m disso, o arquivo $ PGDATA / global / pg_control atualiza a indica√ß√£o do √∫ltimo ponto de verifica√ß√£o <em>passado</em> .  Antes da conclus√£o do ponto de verifica√ß√£o, pg_control aponta para o ponto de verifica√ß√£o anterior. <br><br><img src="https://habrastorage.org/webt/w0/cy/gi/w0cygixp3k4k3qscwfa2nlapqna.png"><br><br>  Para examinar o trabalho do ponto de verifica√ß√£o, crie uma tabela - suas p√°ginas ir√£o para o cache do buffer e ficar√£o sujas: <br><br><pre><code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> chkpt <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> generate_series(<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">10000</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> g(n); =&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">EXTENSION</span></span> pg_buffercache; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> count(*) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_buffercache <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> isdirty;</code> </pre> <pre> <code class="plaintext hljs"> count ------- 78 (1 row)</code> </pre><br>  Lembre-se da posi√ß√£o atual no log: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_current_wal_insert_lsn();</code> </pre><pre> <code class="plaintext hljs"> pg_current_wal_insert_lsn --------------------------- 0/3514A048 (1 row)</code> </pre><br>  Agora, executaremos o ponto de verifica√ß√£o manualmente e garantiremos que n√£o haja p√°ginas sujas no cache (como dissemos, novas p√°ginas sujas podem aparecer, mas, no nosso caso, n√£o houve altera√ß√µes no processo de execu√ß√£o do ponto de verifica√ß√£o): <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">CHECKPOINT</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> count(*) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_buffercache <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> isdirty;</code> </pre><pre> <code class="plaintext hljs"> count ------- 0 (1 row)</code> </pre><br>  Vamos ver como o ponto de verifica√ß√£o foi refletido no log: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_current_wal_insert_lsn();</code> </pre><pre> <code class="plaintext hljs"> pg_current_wal_insert_lsn --------------------------- 0/3514A0E4 (1 row)</code> </pre><br><pre> <code class="plaintext hljs">postgres$ /usr/lib/postgresql/11/bin/pg_waldump -p /var/lib/postgresql/11/main/pg_wal -s 0/3514A048 -e 0/3514A0E4</code> </pre><pre> <code class="plaintext hljs">rmgr: Standby len (rec/tot): 50/ 50, tx: 0, lsn: 0/3514A048, prev 0/35149CEC, desc: RUNNING_XACTS nextXid 101105 latestCompletedXid 101104 oldestRunningXid 101105</code> </pre><pre> <code class="plaintext hljs">rmgr: XLOG len (rec/tot): 102/ 102, tx: 0, lsn: 0/3514A07C, prev 0/3514A048, desc: CHECKPOINT_ONLINE redo 0/3514A048; tli 1; prev tli 1; fpw true; xid 0:101105; oid 74081; multi 1; offset 0; oldest xid 561 in DB 1; oldest multi 1 in DB 1; oldest/newest commit timestamp xid: 0/0; oldest running xid 101105; online</code> </pre><br>  Aqui vemos duas entradas.  O √∫ltimo √© um registro de aprova√ß√£o do ponto de controle (CHECKPOINT_ONLINE).  O LSN do in√≠cio do ponto de verifica√ß√£o √© indicado ap√≥s a palavra refazer e essa posi√ß√£o corresponde ao lan√ßamento no di√°rio, que foi o √∫ltimo no in√≠cio do ponto de verifica√ß√£o. <br><br>  N√≥s encontraremos as mesmas informa√ß√µes no arquivo de controle: <br><br><pre> <code class="plaintext hljs">postgres$ /usr/lib/postgresql/11/bin/pg_controldata -D /var/lib/postgresql/11/main | egrep 'Latest.*location'</code> </pre><pre> <code class="plaintext hljs">Latest checkpoint location: 0/3514A07C Latest checkpoint's REDO location: 0/3514A048</code> </pre><br><h1>  Recupera√ß√£o </h1><br>  Agora, estamos prontos para esclarecer o algoritmo de recupera√ß√£o descrito no artigo anterior. <br><br>  Se o servidor travar, na pr√≥xima vez em que iniciar, o processo de inicializa√ß√£o detectar√° isso observando o arquivo pg_control e vendo um status diferente de "desligar".  Nesse caso, a recupera√ß√£o autom√°tica √© realizada. <br><br>  Primeiro, o processo de recupera√ß√£o ler√° do mesmo pg_control a posi√ß√£o do in√≠cio do ponto de controle.  (Para garantir a integridade, observamos que, se o arquivo backup_label estiver presente, o registro do ponto de controle ser√° lido - isso √© necess√°rio para a restaura√ß√£o dos backups, mas esse √© um t√≥pico para um ciclo separado.) <br><br>  Em seguida, ele ler√° a revista, come√ßando pela posi√ß√£o encontrada, aplicando sequencialmente os lan√ßamentos do di√°rio nas p√°ginas (se necess√°rio, como discutimos na <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">√∫ltima vez</a> ). <br><br>  Em conclus√£o, todas as tabelas n√£o registradas no di√°rio s√£o substitu√≠das usando imagens nos arquivos init. <br><br>  Nesse ponto, o processo de inicializa√ß√£o √© finalizado e o processo do apontador de verifica√ß√£o executa imediatamente um ponto de verifica√ß√£o para corrigir o estado restaurado no disco. <br><br>  Voc√™ pode simular uma falha parando √† for√ßa o servidor no modo imediato. <br><br><pre> <code class="plaintext hljs">student$ sudo pg_ctlcluster 11 main stop -m immediate --skip-systemctl-redirect</code> </pre><br>  (A chave <code>--skip-systemctl-redirect</code> √© necess√°ria aqui porque o PostgreSQL est√° instalado no Ubuntu a partir do pacote. √â controlada pelo comando pg_ctlcluster, que realmente chama systemctl, e j√° chama pg_ctl. Com todos esses wrappers, o nome do modo √© perdido ao longo do caminho, e a <code>--skip-systemctl-redirect</code> permite que voc√™ fique sem o systemctl e salve informa√ß√µes importantes.) <br><br>  Verifique o status do cluster: <br><br><pre> <code class="plaintext hljs">postgres$ /usr/lib/postgresql/11/bin/pg_controldata -D /var/lib/postgresql/11/main | grep state</code> </pre><pre> <code class="plaintext hljs">Database cluster state: in production</code> </pre><br>  Na inicializa√ß√£o, o PostgreSQL entende que ocorreu uma falha e que √© necess√°ria uma recupera√ß√£o. <br><br><pre> <code class="plaintext hljs">student$ sudo pg_ctlcluster 11 main start</code> </pre><br><pre> <code class="plaintext hljs">postgres$ tail -n 7 /var/log/postgresql/postgresql-11-main.log</code> </pre><pre> <code class="plaintext hljs">2019-07-17 15:27:49.441 MSK [8865] LOG: database system was interrupted; last known up at 2019-07-17 15:27:48 MSK 2019-07-17 15:27:49.801 MSK [8865] LOG: database system was not properly shut down; automatic recovery in progress 2019-07-17 15:27:49.804 MSK [8865] LOG: redo starts at 0/3514A048 2019-07-17 15:27:49.804 MSK [8865] LOG: invalid record length at 0/3514A0E4: wanted 24, got 0 2019-07-17 15:27:49.804 MSK [8865] LOG: redo done at 0/3514A07C 2019-07-17 15:27:49.824 MSK [8864] LOG: database system is ready to accept connections 2019-07-17 15:27:50.409 MSK [8872] [unknown]@[unknown] LOG: incomplete startup packet</code> </pre><br>  A necessidade de recupera√ß√£o √© observada no log de mensagens: o <em>sistema do banco de dados n√£o foi desligado corretamente;</em>  <em>recupera√ß√£o autom√°tica em andamento</em> .  Em seguida, os lan√ßamentos cont√°beis manuais come√ßam a ser reproduzidos a partir da posi√ß√£o marcada em ‚Äúrefazer in√≠cio √†s‚Äù e continuam at√© que os pr√≥ximos lan√ßamentos cont√°beis manuais possam ser recuperados.  Isso conclui a recupera√ß√£o na posi√ß√£o ‚Äúrefazer feito em‚Äù e o DBMS come√ßa a trabalhar com os clientes (o <em>sistema de banco de dados est√° pronto para aceitar conex√µes</em> ). <br><br>  E o que acontece durante um desligamento normal do servidor?  Para liberar p√°ginas sujas para o disco, o PostgreSQL desconecta todos os clientes e executa o ponto de verifica√ß√£o final. <br><br>  Lembre-se da posi√ß√£o atual no log: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_current_wal_insert_lsn();</code> </pre><pre> <code class="plaintext hljs"> pg_current_wal_insert_lsn --------------------------- 0/3514A14C (1 row)</code> </pre><br>  Agora pare suavemente o servidor: <br><br><pre> <code class="plaintext hljs">student$ sudo pg_ctlcluster 11 main stop</code> </pre><br>  Verifique o status do cluster: <br><br><pre> <code class="plaintext hljs">postgres$ /usr/lib/postgresql/11/bin/pg_controldata -D /var/lib/postgresql/11/main | grep state</code> </pre><pre> <code class="plaintext hljs">Database cluster state: shut down</code> </pre><br>  E no log, encontramos o √∫nico registro sobre o ponto de controle final (CHECKPOINT_SHUTDOWN): <br><br><pre> <code class="plaintext hljs">postgres$ /usr/lib/postgresql/11/bin/pg_waldump -p /var/lib/postgresql/11/main/pg_wal -s 0/3514A14C</code> </pre><pre> <code class="plaintext hljs">rmgr: XLOG len (rec/tot): 102/ 102, tx: 0, lsn: 0/3514A14C, prev 0/3514A0E4, desc: CHECKPOINT_SHUTDOWN redo 0/3514A14C; tli 1; prev tli 1; fpw true; xid 0:101105; oid 74081; multi 1; offset 0; oldest xid 561 in DB 1; oldest multi 1 in DB 1; oldest/newest commit timestamp xid: 0/0; oldest running xid 0; shutdown</code> </pre><pre> <code class="plaintext hljs">pg_waldump: FATAL: error in WAL record at 0/3514A14C: invalid record length at 0/3514A1B4: wanted 24, got 0</code> </pre><br>  (Em uma terr√≠vel mensagem fatal, pg_waldump s√≥ quer dizer que leu at√© o final da revista.) <br><br>  Execute a inst√¢ncia novamente. <br><br><pre> <code class="plaintext hljs">student$ sudo pg_ctlcluster 11 main start</code> </pre><br><h1>  Grava√ß√£o em segundo plano </h1><br>  Como descobrimos, o ponto de verifica√ß√£o √© um dos processos que grava p√°ginas sujas do cache do buffer no disco.  Mas n√£o √© o √∫nico. <br><br>  Se o back-end precisar retirar a p√°gina do buffer e a p√°gina estiver suja, ser√° necess√°rio grav√°-la no disco por conta pr√≥pria.  Essa √© uma situa√ß√£o ruim, levando a expectativas - √© muito melhor quando a grava√ß√£o ocorre de forma ass√≠ncrona em segundo plano. <br><br>  Portanto, al√©m do <em>processo</em> do ponto de verifica√ß√£o <em>,</em> tamb√©m existe <em>um processo de grava√ß√£o em segundo</em> plano (gravador em segundo plano, bgwriter ou apenas gravador).  Esse processo usa o mesmo algoritmo de pesquisa de buffer que o mecanismo de preemp√ß√£o.  Existem basicamente duas diferen√ßas. <br><br><ol><li>  Ele n√£o usa um ponteiro para a "pr√≥xima v√≠tima", mas sim o seu.  Ele pode estar √† frente do ponteiro para a "v√≠tima", mas nunca fica atr√°s dele. </li><li>  Ao atravessar buffers, o contador de visitas n√£o diminui. </li></ol><br>  Buffers s√£o escritos simultaneamente: <br><br><ul><li>  conter dados alterados (sujos), </li><li>  n√£o fixo (contagem de pinos = 0), </li><li>  tem zero acertos (contagem de uso = 0). </li></ul><br>  Assim, o processo de grava√ß√£o em segundo plano, por assim dizer, corre √† frente da multid√£o e encontra aqueles buffers que provavelmente ser√£o lotados em breve.  Idealmente, devido a isso, os processos de servi√ßo devem descobrir que os buffers selecionados podem ser usados ‚Äã‚Äãsem parar para escrever. <br><br><h1>  Personaliza√ß√£o </h1><br>  <em>O processo do ponto de verifica√ß√£o √©</em> geralmente configurado pelos seguintes motivos. <br><br>  Primeiro, voc√™ precisa decidir quantos arquivos de log podemos economizar (e qual o tempo de recupera√ß√£o que mais nos conv√©m).  Quanto maior, melhor, mas, por raz√µes √≥bvias, esse valor ser√° limitado. <br><br>  Em seguida, podemos calcular quanto tempo esse volume ser√° gerado sob carga normal.  J√° consideramos como fazer isso (precisamos lembrar as posi√ß√µes no di√°rio e subtrair uma da outra). <br><br>  Esse tempo ser√° o intervalo habitual entre os pontos de controle.  N√≥s o escrevemos no par√¢metro <em>checkpoint_timeout</em> .  O valor padr√£o de 5 minutos √© obviamente muito pequeno, geralmente o tempo √© aumentado, digamos, para meia hora.  Repito: quanto menos vezes voc√™ puder pagar marcos, melhor - isso reduz as despesas gerais. <br><br>  No entanto, √© poss√≠vel (e at√© prov√°vel) que √†s vezes a carga seja maior que o normal e que sejam gerados muitos lan√ßamentos no tempo especificado no par√¢metro.  Nesse caso, eu gostaria de executar o ponto de controle com mais frequ√™ncia.  Para fazer isso, no par√¢metro <em>max_wal_size</em> , especificamos a quantidade que √© v√°lida dentro do mesmo ponto de controle.  Se o volume real for obtido mais, o servidor inicia um ponto de verifica√ß√£o n√£o programado. <br><br>  Assim, a maioria dos pontos de controle ocorre em uma programa√ß√£o: uma vez por unidades de tempo <em>checkpoint_timeout</em> .  Por√©m, com o aumento da carga, o ponto de controle √© chamado com mais frequ√™ncia quando o volume <em>max_wal_size</em> √© <em>atingido</em> . <br><br>  √â importante entender que o par√¢metro <em>max_wal_size</em> n√£o determina a quantidade m√°xima que os arquivos de log no disco podem ocupar. <br><br><ul><li>  Para se recuperar de uma falha, √© necess√°rio armazenar os arquivos a partir do momento em que o √∫ltimo ponto de verifica√ß√£o foi passado, al√©m dos arquivos acumulados durante a opera√ß√£o do ponto de verifica√ß√£o atual.  Portanto, o volume total pode ser estimado aproximadamente como <br>  (1 + <em>ponto de verifica√ß√£o_completo_target</em> ) √ó <em>max_wal_size</em> . </li><li>  Antes da vers√£o 11, o PostgreSQL tamb√©m armazenava arquivos para o ponto de verifica√ß√£o de dois anos; portanto, at√© a vers√£o 10 na f√≥rmula acima, voc√™ deve definir 2 em vez de 1. </li><li>  O par√¢metro <em>max_wal_size</em> √© apenas um desejo, mas n√£o um limite r√≠gido.  Pode resultar mais. </li><li>  O servidor n√£o tem o direito de apagar arquivos de log que ainda n√£o foram transferidos pelos slots de replica√ß√£o e que ainda n√£o foram arquivados durante o arquivamento cont√≠nuo.  Se essa funcionalidade for usada, √© necess√°rio monitoramento constante, pois √© f√°cil sobrecarregar a mem√≥ria do servidor. </li></ul><br>  Para concluir a imagem, voc√™ pode definir n√£o apenas o volume m√°ximo, mas tamb√©m o m√≠nimo: par√¢metro <em>min_wal_size</em> .  O significado dessa configura√ß√£o √© que o servidor n√£o exclui arquivos enquanto eles cabem no volume em <em>min_wal_size</em> , mas simplesmente os renomeia e os utiliza novamente.  Isso economiza um pouco, criando e excluindo constantemente arquivos. <br><br>  <em>O processo de grava√ß√£o em segundo plano</em> faz sentido para configurar ap√≥s a configura√ß√£o do ponto de verifica√ß√£o.  Juntos, esses processos devem ter tempo para gravar buffers sujos antes de serem necess√°rios pelos processos de manuten√ß√£o. <br><br>  O processo de grava√ß√£o em segundo plano √© executado em ciclos de no m√°ximo p√°ginas <em>bgwriter_lru_maxpages</em> , adormecendo entre os ciclos em <em>bgwriter_delay</em> . <br><br>  O n√∫mero de p√°ginas que ser√£o gravadas em um ciclo de trabalho √© determinado pelo n√∫mero m√©dio de buffers que foram solicitados pelos processos de manuten√ß√£o da √∫ltima execu√ß√£o (usando uma m√©dia m√≥vel para suavizar a desigualdade entre as execu√ß√µes, mas n√£o depende de um longo hist√≥rico).  O n√∫mero calculado de buffers √© multiplicado pelo coeficiente <em>bgwriter_lru_multiplier</em> (mas, em qualquer caso, n√£o exceder√° <em>bgwriter_lru_maxpages</em> ). <br><br>  Valores padr√£o: <em>bgwriter_delay</em> = 200ms (provavelmente muito, <em>vaza</em> muita √°gua em 1/5 segundo), <em>bgwriter_lru_maxpages</em> = 100, <em>bgwriter_lru_multiplier</em> = 2.0 (estamos tentando responder √† demanda com anteced√™ncia). <br><br>  Se o processo n√£o detectar buffers sujos (isto √©, nada acontece no sistema), ele "hiberna" a partir do qual se deduz que o processo do servidor acessa o buffer.  Depois disso, o processo √© ativado e funciona novamente da maneira usual. <br><br><h1>  Monitoramento </h1><br>  As configura√ß√µes do ponto de controle e da grava√ß√£o em segundo plano podem e devem ser ajustadas, recebendo feedback do monitoramento. <br><br>  O par√¢metro <em>checkpoint_warning</em> exibe um aviso se os pontos de verifica√ß√£o causados ‚Äã‚Äãpelo excesso de tamanho do arquivo de log forem executados com muita freq√º√™ncia.  Seu valor padr√£o √© 30 segundos e deve ser alinhado com o valor de <em>checkpoint_timeout</em> . <br><br>  O par√¢metro <em>log_checkpoints</em> (desativado por padr√£o) permite receber informa√ß√µes sobre os pontos de verifica√ß√£o executados no log de mensagens do servidor.  Ligue-o. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">ALTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SYSTEM</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> log_checkpoints = <span class="hljs-keyword"><span class="hljs-keyword">on</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_reload_conf();</code> </pre><br>  Agora mude algo nos dados e execute o ponto de verifica√ß√£o. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> chkpt <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> n = n + <span class="hljs-number"><span class="hljs-number">1</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">CHECKPOINT</span></span>;</code> </pre><br>  No log de mensagens, veremos algo como isto: <br><br><pre> <code class="plaintext hljs">postgres$ tail -n 2 /var/log/postgresql/postgresql-11-main.log</code> </pre><pre> <code class="plaintext hljs">2019-07-17 15:27:55.248 MSK [8962] LOG: checkpoint starting: immediate force wait 2019-07-17 15:27:55.274 MSK [8962] LOG: checkpoint complete: wrote 79 buffers (0.5%); 0 WAL file(s) added, 0 removed, 0 recycled; write=0.001 s, sync=0.013 s, total=0.025 s; sync files=2, longest=0.011 s, average=0.006 s; distance=1645 kB, estimate=1645 kB</code> </pre><br>  Aqui voc√™ pode ver quantos buffers foram gravados, como a composi√ß√£o dos arquivos de log mudou ap√≥s o ponto de controle, quanto tempo o ponto de controle levou e a dist√¢ncia (em bytes) entre os pontos de controle vizinhos. <br><br>  Mas, provavelmente, as informa√ß√µes mais √∫teis s√£o as estat√≠sticas do trabalho dos processos de ponto de verifica√ß√£o e registro em segundo plano na visualiza√ß√£o pg_stat_bgwriter.  A visualiza√ß√£o √© de um para dois, porque uma vez que as duas tarefas foram executadas por um processo;  ent√£o suas fun√ß√µes foram divididas e a vis√£o permaneceu. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_stat_bgwriter \gx</code> </pre><pre> <code class="plaintext hljs">-[ RECORD 1 ]---------+------------------------------ checkpoints_timed | 0 checkpoints_req | 1 checkpoint_write_time | 1 checkpoint_sync_time | 13 buffers_checkpoint | 79 buffers_clean | 0 maxwritten_clean | 0 buffers_backend | 42 buffers_backend_fsync | 0 buffers_alloc | 363 stats_reset | 2019-07-17 15:27:49.826414+03</code> </pre><br>  Aqui, entre outras coisas, vemos o n√∫mero de pontos de controle conclu√≠dos: <br><br><ul><li>  checkpoints_timed - de acordo com a programa√ß√£o (ao atingir checkpoint_timeout), </li><li>  checkpoints_req - sob demanda (inclusive ao atingir max_wal_size). </li></ul><br>  O grande valor de checkpoint_req (comparado com checkpoints_timed) indica que os pontos de controle ocorrem com mais frequ√™ncia do que o esperado. <br><br>  Informa√ß√µes importantes sobre o n√∫mero de p√°ginas gravadas: <br><br><ul><li>  buffers_checkpoint - processo de ponto de verifica√ß√£o, </li><li>  buffers_backend - servindo processos, </li><li>  buffers_clean - processo de grava√ß√£o em segundo plano. </li></ul><br>  Em um sistema bem ajustado, o valor de buffers_backend deve ser substancialmente menor que a soma de buffers_checkpoint e buffers_clean. <br><br>  Al√©m disso, maxwritten_clean √© √∫til para configurar a grava√ß√£o em segundo plano - esse n√∫mero mostra quantas vezes o processo de grava√ß√£o em segundo plano parou de funcionar devido a exceder <em>bgwriter_lru_maxpages</em> . <br><br>  Voc√™ pode redefinir as estat√≠sticas acumuladas usando a seguinte chamada: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_stat_reset_shared(<span class="hljs-string"><span class="hljs-string">'bgwriter'</span></span>);</code> </pre><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Para ser continuado</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt460423/">https://habr.com/ru/post/pt460423/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt460411/index.html">Mad Converter GIF'ok para stickers animados para Telegram</a></li>
<li><a href="../pt460413/index.html">7 sites e aplicativos √∫teis para aprender ingl√™s</a></li>
<li><a href="../pt460415/index.html">Apple Watch 4 (44 mm, 2019) vs Pebble Steel Classic (2014)</a></li>
<li><a href="../pt460419/index.html">Recupera√ß√£o de calor de gases de combust√£o: ambientalmente amig√°vel</a></li>
<li><a href="../pt460421/index.html">Switch √≥ptico TP-Link T2600G-28SQ para provedores de servi√ßos: uma revis√£o detalhada</a></li>
<li><a href="../pt460425/index.html">Frio infernal, levita√ß√£o e plasma: passado, presente e futuro da supercondutividade</a></li>
<li><a href="../pt460431/index.html">Criando um pipeline de teste automatizado no Azure DevOps</a></li>
<li><a href="../pt460433/index.html">Riscos e amea√ßas na Internet das coisas</a></li>
<li><a href="../pt460435/index.html">Petty little joy # 8: prazeres mesquinhos por trabalhar com o banco de dados</a></li>
<li><a href="../pt460437/index.html">Como colocamos uma bicicleta de suporte t√©cnico</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>