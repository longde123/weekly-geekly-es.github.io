<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§ûüèΩ üßô üë©‚Äçüè≠ WebGL-Wind- und GPU-Programmierung. Vortrag bei FrontTalks 2018 üë®üèæ‚Äçüöí üç∑ „Ä∞Ô∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Zum Rendern komplexer Grafiken auf Webseiten gibt es eine Webgrafikbibliothek, die als WebGL abgek√ºrzt wird. Der Interface-Designer Dmitry Vasiliev sp...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>WebGL-Wind- und GPU-Programmierung. Vortrag bei FrontTalks 2018</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/yandex/blog/433278/">  Zum Rendern komplexer Grafiken auf Webseiten gibt es eine Webgrafikbibliothek, die als WebGL abgek√ºrzt wird.  Der Interface-Designer Dmitry Vasiliev sprach √ºber die GPU-Programmierung aus Sicht eines Layout-Designers, dar√ºber, was WebGL ist und wie wir das Problem der Visualisierung gro√üer Wetterdaten mit dieser Technologie gel√∂st haben. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/-yvY4-ovavo" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  - Ich entwickle Schnittstellen im Jekaterinburger B√ºro von Yandex.  Ich habe in der Sportgruppe angefangen.  Wir haben spezielle Sportprojekte entwickelt, als es Weltmeisterschaften in Hockey, Fu√üball, Olympischen Spielen, Paralympics und anderen coolen Events gab.  Ich habe auch an der Entwicklung spezieller Suchergebnisse gearbeitet, die dem neuen Sotschi-Track gewidmet waren. <br><br><a name="habracut"></a><img src="https://habrastorage.org/webt/5p/l2/e_/5pl2e_nhpyefyjt0q3wfspflpyc.jpeg"><br><br><img src="https://habrastorage.org/webt/qw/zy/xd/qwzyxdlvu0jukewd-9prrerk-a8.jpeg"><br><br><img src="https://habrastorage.org/webt/uy/7b/mp/uy7bmpkufgne4mck5yiawv3mj1o.jpeg"><br><br><img src="https://habrastorage.org/webt/q6/cu/kw/q6cukwvmpmwru6iew_ranhk7mwo.jpeg"><br><h5>  <sub><sup><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Link von der Folie</a></sup></sub> </h5><br>  Au√üerdem haben wir in anderthalb Helmen den Dienst "Arbeit an Fehlern" neu gestartet.  Und dann begann die Arbeit in Pogoda, wo ich die Funktionsf√§higkeit der API, ihre Entwicklung, das Schreiben der Infrastruktur um diese API und das Schreiben von Knotenordnern f√ºr die trainierten maschinellen Lernformeln unterst√ºtzte. <br><br><img src="https://habrastorage.org/webt/sz/xs/zy/szxszynumbssi9qyhkxwalfmsdy.jpeg"><br><br>  Dann begann die Arbeit interessanter.  Teilnahme an der Neugestaltung unserer Wetterdienste.  Desktops, Schubkarren. <br><br><img src="https://habrastorage.org/webt/io/q4/cw/ioq4cwweh1vbjyqonlto5yuo_1e.jpeg"><br><br><img src="https://habrastorage.org/webt/ij/er/w6/ijerw62hpfkj2kvph4wvuag_www.jpeg"><br><br>  Nachdem wir die Standardprognosen in Ordnung gebracht hatten, beschlossen wir, die Prognose zu erstellen, die niemand hat.  Diese Prognose war die Prognose f√ºr die Bewegung der Niederschl√§ge in den Gebieten. <br><br><img src="https://habrastorage.org/webt/xc/n_/cf/xcn_cfakd_xnyoxaazxgc4bvmso.jpeg"><br><br>  Es gibt spezielle Wetterradare, die Niederschl√§ge in einem Umkreis von 2000 km erfassen, deren Dichte und Entfernung sie kennen. <br><br><img src="https://habrastorage.org/webt/as/ea/av/aseaavvwl0v3lqhex1kx_dvsr1w.jpeg"><br><br>  Mit diesen Daten und Vorhersagen mithilfe des maschinellen Lernens ihrer weiteren Bewegung haben wir eine <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">solche Visualisierung</a> auf der Karte erstellt.  Sie k√∂nnen sich hin und her bewegen. <br><br><img src="https://habrastorage.org/webt/jt/qo/fj/jtqofjz8eo8wrjybcydczpxse0a.jpeg"><br><h5>  <sub><sup><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Link von der Folie</a></sup></sub> </h5><br>  Wir haben uns die Bewertungen von Menschen angesehen.  Die Leute mochten es.  Alle Arten von Memen tauchten auf und es gab coole Bilder, als Moskau zur H√∂lle flutete. <br><br>  Da das Format allen gefallen hat, haben wir uns entschlossen, die folgende Vorhersage dem Wind zu widmen. <br><br><img src="https://habrastorage.org/webt/kl/mc/_f/klmc_fqnedxn-okos6d6bhmlszs.jpeg"><br><br>  Dienste, die die Windvorhersage anzeigen, sind bereits vorhanden.  Dies sind ein paar noble, die auffallen. <br><br><img src="https://habrastorage.org/webt/vo/vc/4k/vovc4kev5lhxvyph9t46z4uhei8.jpeg"><br><br>  Als wir sie betrachteten, wurde uns klar, dass wir dasselbe tun wollen - oder zumindest nicht schlimmer. <br><br>  Aus diesem Grund haben wir uns entschlossen, Partikel zu visualisieren, die sich je nach Windgeschwindigkeit reibungslos auf der Karte bewegen, und eine Art Schleife zu hinterlassen, damit sie gesehen werden k√∂nnen und die Flugbahn des Windes sichtbar ist. <br><br>  Da wir bereits gro√üartig sind und eine coole Karte mit Niederschlag unter Verwendung von 2D-Leinwand erstellt haben, haben wir beschlossen, dasselbe mit den Partikeln zu tun. <br><br><img src="https://habrastorage.org/webt/hz/jd/yi/hzjdyivbulbjmfod7n2-nix8uca.jpeg"><br><br>  Nach R√ºcksprache mit dem Designer haben wir festgestellt, dass wir etwa 6% des Bildschirms mit Partikeln f√ºllen m√ºssen, um einen k√ºhlen Effekt zu erzielen. <br><br>  Um eine solche Anzahl von Partikeln mit dem Standardansatz zu zeichnen, hatten wir ein Minimum von 5 ms. <br><br><img src="https://habrastorage.org/webt/yu/l1/7n/yul17ngn7dfm6cadtcy2dpkf6zu.jpeg"><br><br>  Wenn Sie der Meinung sind, dass wir die Partikel noch bewegen und eine Art Sch√∂nheit bringen m√ºssen, z. B. das Zeichnen des Schwanzes der Partikel, k√∂nnen wir davon ausgehen, dass wir f√ºr ein Minimum von 40 ms ausfallen, um eine reibungslose Animation zu zeigen, um mindestens 25 Bilder pro Sekunde zu erzeugen. <br><br>  Das Problem ist, dass hier jedes Partikel nacheinander verarbeitet wird.  Aber was ist, wenn Sie sie parallel verarbeiten? <br><br>  Eine klare Unterscheidung zwischen der Bedienung der Zentral- und Grafikprozessoren zeigte ‚ÄûLegend Destroyers‚Äú auf einer der Konferenzen.  Sie rollten eine Maschine aus, auf der ein Paintball-Marker installiert war, dessen Aufgabe es war, einen Smiley in einer Farbe zu zeichnen.  In ungef√§hr 10 Sekunden zeichnete er ein solches Bild.  ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Link zum Video</a> - ca.) <br><br><img src="https://habrastorage.org/webt/kk/pi/cw/kkpicwfdskxnicbu0jb7sowhgfq.jpeg"><br><br><img src="https://habrastorage.org/webt/zd/ka/3a/zdka3al72tgfcavb5yvww_qx2ug.jpeg"><br><br><img src="https://habrastorage.org/webt/i9/tm/kh/i9tmkhykoiz8vkim-vzftxjjl44.jpeg"><br><br>  Dann rollten die Jungs ein Kanu aus, das eine GPU ist, und ein paar Spie√üe bemalten Mona Lisa.  Auf diese Weise unterscheidet sich die Rechengeschwindigkeit von CPU und GPU. <br><br><img src="https://habrastorage.org/webt/dm/x-/hc/dmx-hckqzdlztdat2wm-j88cj-k.jpeg"><br><br><img src="https://habrastorage.org/webt/zg/pa/3m/zgpa3m281vzirvjqotbuoqnmms8.jpeg"><br><br><img src="https://habrastorage.org/webt/hq/lf/uj/hqlfujoqgr4mhgxucjpx7xnmedu.jpeg"><br><br><img src="https://habrastorage.org/webt/qb/zo/xz/qbzoxzq0tywqxi0pc2xifdnvnds.jpeg"><br><br><img src="https://habrastorage.org/webt/d6/z5/kq/d6z5kq5c23fjmb2uzfx4aqqj3ec.jpeg"><br><br>  Um diese Funktionen in einem Browser nutzen zu k√∂nnen, wurde die WebGL-Technologie erfunden. <br><br>  Was ist das?  Mit dieser Frage stieg ich ins Internet.  Ich f√ºgte ein paar W√∂rter mit Partikelanimation und Wind hinzu und fand ein paar Artikel. <br><br><img src="https://habrastorage.org/webt/ob/d-/w_/obd-w_edp80lvmzlh3xmh437itw.jpeg"><br><h5>  <sub><sup>Links von der Folie: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">erstens</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">zweitens</a></sup></sub> </h5><br>  Eine davon ist eine Demo von Vladimir Agafonkin, einem Ingenieur von Mapbox, der den Wind auf WebGL gemacht hat und auf den Blog von Chris Wellons verwiesen hat, der dar√ºber sprach, wie man den Zustand von Partikeln auf der GPU bewegt und speichert. <br><br>  Wir nehmen und kopieren.  Wir erwarten ein solches Ergebnis.  Hier bewegen sich die Partikel reibungslos. <br><br><img src="https://habrastorage.org/webt/s6/5t/7-/s65t7-020jphv-fvyzbk5vpkmoq.jpeg"><br><br>  Wir bekommen nicht zu verstehen was. <br><br><img src="https://habrastorage.org/webt/7n/8i/t1/7n8it1gwmfklms2akt9nydmgima.jpeg"><br><br>  Ich versuche den Code herauszufinden.  Verbessern, wieder ein unbefriedigendes Ergebnis erzielen.  Wir klettern noch tiefer - wir bekommen Regen statt Wind. <br><br><img src="https://habrastorage.org/webt/n4/bd/b1/n4bdb1-ar38mb8lokfjfgjqbrue.jpeg"><br><br>  Okay, wir beschlie√üen, es selbst zu tun. <br><br><img src="https://habrastorage.org/webt/lw/ue/kv/lwuekvj_c1996sjj2q1c2fl4pyk.jpeg"><br><br>  F√ºr die Arbeit mit WebGL sind Frameworks vorhanden.  Fast alle von ihnen zielen auf die Arbeit mit 3D-Objekten ab.  Wir ben√∂tigen diese 3D-Funktionen nicht.  Wir m√ºssen nur ein Teilchen zeichnen und es bewegen.  Deshalb beschlie√üen wir, alles mit unseren H√§nden zu machen. <br><br><img src="https://habrastorage.org/webt/rt/db/4z/rtdb4zokw74ivcedzljp4t3fu_g.jpeg"><br><br>  Derzeit gibt es zwei Versionen der WebGL-Technologie.  Die zweite Version, die cool ist, hat eine hochmoderne Version der Programmiersprache, in der das Programm im Grafikadapter ausgef√ºhrt wird, kann direkt Berechnungen durchf√ºhren und nicht nur zeichnen.  Aber es hat eine schlechte Kompatibilit√§t. <br><br><img src="https://habrastorage.org/webt/yk/gr/ty/ykgrtypkwclnix0f4pat1retheu.jpeg"><br><br>  Nun, wir entscheiden uns f√ºr das alte bew√§hrte WebGL 1, das neben Opera Mini, das niemand braucht, eine gute Unterst√ºtzung bietet. <br><br><img src="https://habrastorage.org/webt/sr/1q/xr/sr1qxr_ch7enl9z1rjwuv1hshpg.jpeg"><br><br>  WebGL ist eine Zwei-Komponenten-Sache.  Dies ist JS, das den Status von Programmen ausf√ºhrt, die auf der Grafikkarte ausgef√ºhrt werden.  Und es gibt Komponenten, die direkt auf der Grafikkarte ausgef√ºhrt werden. <br><br>  Beginnen wir mit JS.  WebGL ist nur der geeignete Kontext f√ºr das Canvas-Element.  Dar√ºber hinaus werden nach Erhalt dieses Kontexts nicht nur ein bestimmtes Objekt zugewiesen, sondern auch Eisenressourcen zugewiesen.  Und wenn wir in WebGL in einem Browser etwas Sch√∂nes ausf√ºhren und dann Quake spielen, ist es durchaus m√∂glich, dass diese Ressourcen verloren gehen und der Kontext verloren geht und Ihr gesamtes Programm kaputt geht. <br><br><img src="https://habrastorage.org/webt/y3/bm/p0/y3bmp0fddy1vkxkktxantfrfcdw.jpeg"><br><br>  Wenn Sie mit WebGL arbeiten, m√ºssen Sie daher auch auf den Kontextverlust achten und ihn wiederherstellen k√∂nnen.  Deshalb habe ich betont, dass init ist. <br><br><img src="https://habrastorage.org/webt/aj/iu/zk/ajiuzkpsukwyhrhvte4oduqivri.jpeg"><br><br>  Dar√ºber hinaus l√§uft die gesamte Arbeit von JS darauf hinaus, Programme zu sammeln, die auf der GPU ausgef√ºhrt werden, ihnen eine Grafikkarte zu senden, einige Parameter festzulegen und "Zeichnen" zu sagen. <br><br><img src="https://habrastorage.org/webt/3k/2m/zd/3k2mzdhdejzpaxjrx_upik6fdeu.jpeg"><br><br>  Wenn Sie in WebGL das Kontextelement selbst betrachten, sehen Sie eine Reihe von Konstanten.  Diese Konstanten beziehen sich auf Adressen im Speicher.  Sie sind im Verlauf des Programms nicht wirklich konstant.  Wenn der Kontext verloren geht und erneut wiederhergestellt wird, kann ein anderer Adresspool zugewiesen werden, und diese Konstanten unterscheiden sich f√ºr den aktuellen Kontext.  Daher werden fast alle Vorg√§nge in WebGL auf der JS-Seite √ºber Dienstprogramme ausgef√ºhrt.  Niemand m√∂chte die Routinearbeit erledigen, um Adressen und anderen M√ºll zu finden. <br><br><img src="https://habrastorage.org/webt/ii/o7/sa/iio7sahs5z0gt5bccxesgiict44.jpeg"><br><br>  Wir wenden uns dem zu, was auf der Grafikkarte selbst ausgef√ºhrt wird - einem Programm, das aus zwei Anweisungen besteht, die in einer C-√§hnlichen GLSL-Sprache geschrieben sind.  Diese Anweisungen werden als Vertex-Shader und Fragment-Shader bezeichnet.  Aus ihrem Paar wird ein Programm erstellt. <br><br><img src="https://habrastorage.org/webt/qg/fu/lb/qgfulbs6almqwpkmutcsxv38-cm.jpeg"><br><br>  Was ist der Unterschied zwischen diesen Shadern?  Der Vertex-Shader legt die Oberfl√§che fest, auf der etwas gezeichnet werden soll.  Nachdem das Grundelement festgelegt wurde, das √ºbermalt werden soll, wird der Fragment-Shader aufgerufen, der in diesen Bereich f√§llt. <br><br><img src="https://habrastorage.org/webt/up/h_/ya/uph_yasoh3q-99otxdym43zykmw.jpeg"><br><br><img src="https://habrastorage.org/webt/u7/vi/qb/u7viqbviwm76x4ovlvion5mm2o8.jpeg"><br><br>  Im Code sieht es so aus.  Der Shader verf√ºgt √ºber einen Abschnitt zum Deklarieren von Variablen, die extern von JS festgelegt werden. Ihr Typ und Name werden bestimmt.  Sowie der Hauptabschnitt, der den f√ºr diese Iteration erforderlichen Code ausf√ºhrt. <br><br>  In den meisten F√§llen wird von einem Vertex-Shader erwartet, dass er die Variable gl_Position auf eine Koordinate im vierdimensionalen Raum setzt.  Dies sind x, y, z und die Breite des Raums, was im Moment nicht sehr wichtig ist, um es zu wissen. <br><br>  Der Fragment-Shader erwartet, die Farbe eines bestimmten Pixels festzulegen. <br><br>  In diesem Beispiel haben wir die Pixelfarbe aus der verbundenen Textur ausgew√§hlt. <br><br><img src="https://habrastorage.org/webt/y8/nw/1y/y8nw1y1gnwstkv2rgqxatduyuni.jpeg"><br><br>  Um dies auf JS zu √ºbertragen, wickeln Sie einfach den Quellcode der Shader in Variablen ein. <br><br><img src="https://habrastorage.org/webt/ax/fz/ou/axfzouj0xwui47sftwgdhlcadd0.jpeg"><br><br>  Ferner werden diese Variablen in Shader umgewandelt.  Dies ist ein WebGL-Kontext. Wir erstellen Shader aus Quellcodes, erstellen parallel ein Programm und f√ºgen dem Programm einige Shader hinzu.  Wir bekommen ein praktikables Programm. <br><br>  Unterwegs √ºberpr√ºfen wir, ob die Kompilierung der Shader erfolgreich war und ob das Programm erfolgreich erstellt wurde.  Wir sagen, dass Sie dieses Programm verwenden m√ºssen, da es mehrere Programme f√ºr unterschiedliche Renderwerte geben kann. <br><br>  Richten Sie es ein und sagen Sie Zeichnen.  Es stellt sich eine Art Bild heraus. <br><br><img src="https://habrastorage.org/webt/oz/py/ri/ozpyrifyoft_invjrawmmz-_fjg.jpeg"><br><br>  Tiefer geklettert.  Im Vertex-Shader werden alle Berechnungen im Raum von -1 bis 1 ausgef√ºhrt, unabh√§ngig von der Gr√∂√üe Ihres Ausgabepunkts.  Beispielsweise kann der Abstand von -1 bis 1 den gesamten Bildschirm 1920 x 1080 einnehmen. Um ein Dreieck in der Mitte des Bildschirms zu zeichnen, m√ºssen Sie eine Fl√§che zeichnen, die die Koordinaten 0, 0 abdeckt. <br><br><img src="https://habrastorage.org/webt/4q/yp/ex/4qypexiothorcvzkrk9y_p5v9tk.jpeg"><br><br>  Der Fragment-Shader arbeitet im Bereich von 0 bis 1, und die Farben werden von vier Komponenten angezeigt: R, G, B, Alpha. <br><br>  Am Beispiel von CSS k√∂nnen Sie bei der Verwendung von Prozents√§tzen auf eine √§hnliche Farbnotation sto√üen. <br><br><img src="https://habrastorage.org/webt/ys/cn/kn/yscnkn-8x_yg0bl_zknm-42l17q.jpeg"><br><br>  Um etwas zu zeichnen, m√ºssen Sie angeben, welche Daten gezeichnet werden m√ºssen.  Speziell f√ºr ein Dreieck definieren wir ein typisiertes Array von drei Eckpunkten, die jeweils aus drei Komponenten bestehen: x, y und genug. <br><br>  In diesem Fall sieht der Vertex-Shader so aus, als w√ºrde er das aktuelle Paar von Punkten und Koordinaten abrufen und diese Koordinate auf dem Bildschirm festlegen.  Hier setzen wir ohne Transformationen einen Punkt auf den Bildschirm. <br><br><img src="https://habrastorage.org/webt/up/h_/ya/uph_yasoh3q-99otxdym43zykmw.jpeg"><br><br>  Der Fragment-Shader kann die von JS √ºbergebenen Konstanten auch ohne zus√§tzliche Berechnungen mit Farbe f√§rben.  Wenn au√üerdem einige Variablen im Fragment-Shader von au√üen oder vom vorherigen Shader √ºbertragen werden, muss die Genauigkeit angegeben werden.  In diesem Fall ist eine mittlere Genauigkeit ausreichend und fast immer ausreichend. <br><br><img src="https://habrastorage.org/webt/dx/9v/jb/dx9vjbxuiz_swlbl1hlmlb5hmys.jpeg"><br><br>  Wir gehen zu JS.  Wir weisen Variablen dieselben Shader zu und deklarieren eine Funktion, die diese Shader erstellt.  Das hei√üt, ein Shader wird erstellt, die Quelle wird hineingegossen und dann kompiliert. <br><br><img src="https://habrastorage.org/webt/jf/x3/eg/jfx3eg-hhqsdbmpc378peyi6tym.jpeg"><br><br>  Wir machen zwei Shader, Vertex und Fragment. <br><br><img src="https://habrastorage.org/webt/jh/pb/um/jhpbumsovp4-rkstmx9dldtg7ug.jpeg"><br><br>  Erstellen Sie anschlie√üend ein Programm und laden Sie bereits kompilierte Shader hoch.  Wir binden das Programm, weil die Shader Variablen untereinander austauschen k√∂nnen.  In diesem Stadium wird die √úbereinstimmung der Variablentypen √ºberpr√ºft, die diese Shader austauschen. <br><br>  Wir sagen, dass Sie dieses Programm verwenden. <br><br><img src="https://habrastorage.org/webt/7i/hm/rc/7ihmrctum2gyy9cuybn5pr6hcbu.jpeg"><br><br>  Als N√§chstes erstellen wir eine Liste der Scheitelpunkte, die wir visualisieren m√∂chten.  WebGL hat eine interessante Funktion f√ºr einige Variablen.  Um einen bestimmten Datentyp zu √§ndern, m√ºssen Sie den globalen Kontext f√ºr die Bearbeitung von array_buffer festlegen und dann etwas an diese Adresse hochladen.  Es gibt keine explizite Zuordnung von Daten zu einer Variablen.  Alles wird durch die Einbeziehung eines Kontextes getan. <br><br>  Es ist auch notwendig, die Regeln f√ºr das Lesen aus diesem Puffer festzulegen.  Es ist ersichtlich, dass wir ein Array von sechs Elementen angegeben haben, aber das Programm muss erkl√§ren, dass jeder Scheitelpunkt aus zwei Komponenten besteht, deren Typ float ist. Dies erfolgt in der letzten Zeile. <br><br><img src="https://habrastorage.org/webt/js/_j/qe/js_jqevmwlq0fmo_n6-vbdwsr-k.jpeg"><br><br>  Um die Farbe festzulegen, sucht das Programm nach der Adresse f√ºr die Variable u_color und legt den Wert f√ºr diese Variable fest.  Wir setzen die Farbe Rot 255, 0,8 von Gr√ºn, 0 Blau und ein v√∂llig undurchsichtiges Pixel - es wird gelb.  Und wir sagen, um dieses Programm mit den Dreiecksprimitiven auszuf√ºhren, k√∂nnen Sie in WebGL Punkte, Linien, Dreiecke, Dreiecke mit komplexer Form usw. zeichnen.  Und mache drei Spitzen. <br><br><img src="https://habrastorage.org/webt/lk/pz/xe/lkpzxe_tur-bgozsoj47kohstty.jpeg"><br><br>  Sie k√∂nnen auch festlegen, dass das Array, √ºber das wir rendern, von Anfang an gez√§hlt werden soll. <br><br><img src="https://habrastorage.org/webt/p4/1f/_k/p41f_kioprwkxx7ommkzz7tcclw.jpeg"><br><h5>  <sub><sup><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Link von der Folie</a></sup></sub> </h5><br>  Wenn Sie das Beispiel etwas komplizieren, k√∂nnen Sie eine Farbabh√§ngigkeit von der Cursorposition hinzuf√ºgen.  Gleichzeitig geht fps durch das Dach. <br><br><img src="https://habrastorage.org/webt/sl/eu/zl/sleuzlnxn8s1tlflhawo5obsrg8.jpeg"><br><br>  Um Partikel auf der ganzen Welt zu zeichnen, m√ºssen Sie die Windgeschwindigkeit an jedem Punkt dieser Welt kennen. <br><br>  Um die Karte zu vergr√∂√üern und irgendwie zu verschieben, m√ºssen Sie Container erstellen, die der aktuellen Position der Karte entsprechen. <br><br>  Um die Partikel selbst zu verschieben, m√ºssen Sie ein Datenformat erstellen, das mithilfe einer GPU aktualisiert werden kann.  Machen Sie die Zeichnung selbst und zeichnen Sie die Schleife. <br><br><img src="https://habrastorage.org/webt/2o/vf/o_/2ovfo_hqaimoyygbbcpkbupf_cu.jpeg"><br><br>  Wir machen alle Daten durch die Textur.  Wir verwenden 22 Kan√§le, um horizontale und vertikale Geschwindigkeiten zu bestimmen, wobei die Windgeschwindigkeit Null der Mitte des Farbbereichs entspricht.  Es ist ungef√§hr 128.  Da die Geschwindigkeit negativ und positiv sein kann, stellen wir die Farbe relativ zur Mitte des Bereichs ein. <br><br>  Es stellt sich so ein Bild heraus. <br><br><img src="https://habrastorage.org/webt/3-/qu/i8/3-qui8mkzufp6hucltuzpampili.jpeg"><br><br>  Um es auf eine Karte zu laden, m√ºssen wir es schneiden.  Um das Bild mit der Karte zu verbinden, verwenden wir das Standardwerkzeug Yandex.Map Layer, mit dem wir die Adresse bestimmen, von der aus die Kacheln geschnitten werden sollen, und diese Ebene zur Karte hinzuf√ºgen. <br><br><img src="https://habrastorage.org/webt/jo/zj/a8/jozja8duysio2wljyezgjnhfn64.jpeg"><br><h5>  <sub><sup><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Link von der Folie</a></sup></sub> </h5><br>  Wir bekommen ein Bild, in dem die unangenehme gr√ºne Farbe die Windgeschwindigkeit codiert. <br><br><img src="https://habrastorage.org/webt/uh/nk/jh/uhnkjh1e8sxzgzp-myix3xxyjn4.jpeg"><br><br>  Als n√§chstes m√ºssen Sie einen Ort finden, an dem wir die Animation selbst zeichnen, w√§hrend dieser Ort den Koordinaten der Karte, ihren Bewegungen und anderen Aktionen entsprechen sollte. <br><br>  Standardm√§√üig k√∂nnen wir davon ausgehen, dass wir Layer verwenden w√ºrden, aber die Kartenebene erstellt eine Zeichenfl√§che, aus der sofort der 2D-Kontext erfasst wird, den sie erfassen kann.  Wenn wir jedoch versuchen, aus der Leinwand, die bereits einen Kontext eines anderen Typs hat, einen GL-Kontext zu entnehmen, erhalten wir als Ergebnis null.  Wenn Sie darauf zugreifen, st√ºrzt das Programm ab. <br><br><img src="https://habrastorage.org/webt/lg/9a/mn/lg9amncxtx9ndmnc7bjqkzcs_lw.jpeg"><br><h5>  <sub><sup><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Link von der Folie</a></sup></sub> </h5><br>  Daher haben wir Pane verwendet, dies sind Container f√ºr Layouts, und dort unsere Leinwand hinzugef√ºgt, aus der wir bereits den ben√∂tigten Kontext √ºbernommen haben. <br><br><img src="https://habrastorage.org/webt/v9/on/pb/v9onpb5gnorqq05kg0og8bd6wvq.jpeg"><br><br>  Um die Partikel irgendwie auf dem Bildschirm anzuordnen und bewegen zu k√∂nnen, wurde das Format der Position der Partikel in der Textur verwendet. <br><br>  Wie funktioniert es  Zur Optimierung wird eine quadratische Textur erstellt, und hier ist die Gr√∂√üe ihrer Seite bekannt. <br><br><img src="https://habrastorage.org/webt/ov/hm/qg/ovhmqgdfgbzg3k5wua7se3l-scm.jpeg"><br><br>  Indem Sie die Partikel der Reihe nach zeichnen und die Seriennummer des Partikels sowie die Gr√∂√üe der Textur kennen, in der sie gespeichert sind, k√∂nnen Sie ein bestimmtes Pixel berechnen, in dem die Position auf dem realen Bildschirm codiert ist. <br><br><img src="https://habrastorage.org/webt/xw/6c/ly/xw6clysjjqrtppxzih0cm4q3sis.jpeg"><br><br><img src="https://habrastorage.org/webt/a_/jt/9m/a_jt9ml9jdjn0vxxk7riv9sbkw8.jpeg"><br><br>  Im Shader selbst sieht es so aus, als w√ºrde man den gerenderten Index, die Textur mit der aktuellen Position der Partikel und der Gr√∂√üe der Seite lesen.  Als n√§chstes bestimmen wir die x, y-Koordinaten f√ºr dieses Teilchen, lesen diesen Wert und decodieren ihn.  Was f√ºr eine Magie ist das: rg / 255 + ba? <br><br>  F√ºr die Position der Partikel verwenden wir 20 Doppelkan√§le.  Der Farbkanal hat einen Wert von 0 bis 255, und f√ºr den 1080-Bildschirm k√∂nnen wir die Partikel f√ºr eine Weile nicht an einer beliebigen Position des Bildschirms platzieren, da das Maximum h√∂chstens 255 Pixel betragen kann.  Daher speichern wir in einem Kanal das Wissen dar√ºber, wie oft ein Partikel 255 Pixel passiert hat, und im zweiten Kanal speichern wir den genauen Wert, wie viel es danach passiert hat. <br><br>  Als N√§chstes muss der Vertex-Shader diese Werte in seinen Arbeitsbereich konvertieren, dh von -1 bis 1, und diesen Punkt auf der Anzeige festlegen. <br><br><img src="https://habrastorage.org/webt/g2/ht/g_/g2htg_vqu8k5fdnn_zx6xtl82fs.jpeg"><br><br>  Um nur unsere Partikel zu betrachten, malen Sie sie einfach mit Wei√ü.  GLSL hat einen solchen Zucker, dass, wenn wir den Typ einer Variablen definieren und ihn an eine Konstante √ºbergeben, diese Konstante beispielsweise auf alle vier Komponenten verteilt wird. <br><br><img src="https://habrastorage.org/webt/ee/h-/hz/eeh-hzn9oaitmm7k7gwfpzin8rq.jpeg"><br><br>  Nachdem wir ein solches Programm gezeichnet haben, sehen wir eine Reihe identischer Quadrate.  Versuchen wir, ihnen Sch√∂nheit zu verleihen. <br><br><img src="https://habrastorage.org/webt/-r/ud/i1/-rudi16ytlwsw-_fvafdhqmqync.jpeg"><br><br>  Addieren Sie zun√§chst die Abh√§ngigkeit dieser Quadrate von der aktuellen Windgeschwindigkeit.  Wir lesen einfach die aktuelle Geschwindigkeit und die entsprechenden Texturen f√ºr jedes Partikel.  Wir erhalten die L√§nge des Vektors, die der absoluten Geschwindigkeit am Punkt entspricht, und addieren diese Geschwindigkeit zur Partikelgr√∂√üe. <br><br><img src="https://habrastorage.org/webt/or/v-/qs/orv-qs0vwvlrcxadmlpvbywokdw.jpeg"><br><br>  Um die Quadrate nicht zu zeichnen, schneiden wir im Fragment-Shader alle Pixel ab, die au√üerhalb des Radius liegen und nicht im Radius des beschrifteten Kreises enthalten sind.  Das hei√üt, unser Shader verwandelt sich in so etwas. <br><br><img src="https://habrastorage.org/webt/t4/rx/ah/t4rxahmunedzb3k0jamjxiikvia.jpeg"><br><br>  Wir berechnen den Abstand zum gerenderten Pixel von der Mitte.  Wenn es die H√§lfte des Platzes √ºberschreitet, zeigen wir es nicht. <br><br><img src="https://habrastorage.org/webt/nr/do/ma/nrdomaus-zdhgroynefo3qacxck.jpeg"><br><br>  Wir bekommen ein vielf√§ltigeres Bild. <br><br>  Als n√§chstes m√ºssen Sie diese Dinge irgendwie bewegen.  Da WebGL 1 nicht wei√ü, wie man etwas berechnet und direkt mit Daten arbeitet, werden wir die M√∂glichkeit nutzen, Programme in spezielle Komponenten, Rahmenpuffer, zu zeichnen. <br><br>  Rahmenpuffer k√∂nnen beispielsweise Texturen zugeordnet werden, die aktualisiert werden k√∂nnen.  Wenn der Bildspeicher nicht deklariert ist, wird standardm√§√üig auf dem Bildschirm gezeichnet. <br><br>  Wenn Sie die Ausgabe von einer Positionstextur in eine andere umschalten, k√∂nnen Sie sie einzeln aktualisieren und dann zum Rendern verwenden. <br><br><img src="https://habrastorage.org/webt/j7/-j/tn/j7-jtnjwzj-8pav52t-ngiolwji.jpeg"><br><br><img src="https://habrastorage.org/webt/8y/me/ey/8ymeey1havzw-wavn5x8ztr87em.jpeg"><br><br>  Das Verfahren zum Aktualisieren der Position selbst sieht folgenderma√üen aus: Lesen Sie die aktuelle Position, f√ºgen Sie sie dem aktuellen Geschwindigkeitsvektor hinzu, f√ºgen Sie sie hinzu und codieren Sie sie in einer neuen Farbe. <br><br><img src="https://habrastorage.org/webt/t7/up/wj/t7upwjpzr8ubgig0cwr1_hn7npa.jpeg"><br><br>  Im Code sieht es so aus, als w√ºrde man die aktuelle Position lesen, dekodieren, die aktuelle Geschwindigkeit lesen, die Geschwindigkeit normalisieren, die beiden Komponenten falten und in Farbe codieren. <br><br><img src="https://habrastorage.org/webt/uo/cc/qo/uoccqo8i2fubmgay3oi90teclzw.jpeg"><br><br>  Es stellt sich so ein Bild heraus.  Der Zustand der Partikel √§ndert sich st√§ndig und es erscheint eine Art Animation. <br><br>  Wenn Sie eine solche Animation 5-10 Minuten lang ausf√ºhren, ist klar, dass alle Partikel an ihrem endg√ºltigen Ziel ankommen.  Sie alle gleiten in den Trichter.  Du bekommst so ein Bild. <br><br><img src="https://habrastorage.org/webt/be/m0/bx/bem0bxbrxar_it9lgdjdc2fk91y.jpeg"><br><br>  Um dies zu vermeiden, f√ºhren wir einen Faktor der Partikelpermutation an einer zuf√§lligen Stelle ein. <br><br>  Dies h√§ngt von der aktuellen Windgeschwindigkeit, der aktuellen Partikelposition und der Zufallszahl ab, die wir von JS senden - da die erste Version von WebGL keine Randomisierungsfunktion und keine Rauschfunktionen enth√§lt. <br><br><img src="https://habrastorage.org/webt/zt/ur/_b/ztur_bhp_epcyqk1kzaz9b1r0a0.jpeg"><br><br>  In diesem Beispiel berechnen wir die vorhergesagte Position des Partikels, die zuf√§llige Position, und w√§hlen je nach R√ºcksetzfaktor entweder die eine oder die andere aus. <br><br><img src="https://habrastorage.org/webt/6o/qq/m8/6oqqm8iswgovcsguseunzhwxauc.jpeg"><br><h5>  <sub><sup>Links von der Folie: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">erste</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">zweite</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">dritte</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">vierte</a></sup></sub> </h5><br>  Um zu verstehen, was auf der letzten Folie war, k√∂nnen Sie diese Artikel lesen.  Die erste Methode bietet einen enormen Beitrag zum Verst√§ndnis dessen, was WebGL bietet, woraus es besteht und wie man keinen Fehler macht.  Bei Khronos ist dies eine Gruppe, die sich mit der Entwicklung des Standards befasst. Es gibt eine Beschreibung aller Funktionen. <br><br><img src="https://habrastorage.org/webt/5u/qi/st/5uqistm5t05pqha9xfm1oqdnxfu.jpeg"><br><br>  Der letzte Punkt unserer Aufgabe ist es, eine Spur von Partikeln zu zeichnen.  Zu diesem Zweck zeichnen wir, genau wie bei den Positionsaktualisierungstexturen, die aktuelle Position auf dem Bildschirm in zwei Texturen auf und zeigen die aktuelle Position an, wobei wir die Transparenz geringf√ºgig erh√∂hen, eine neue Partikelposition √ºberlagern und dann die Transparenz dieses Bildes immer wieder erh√∂hen    . <br><br><img src="https://habrastorage.org/webt/es/-8/oa/es-8oakhvm9ds8uh-e7teuivgnk.jpeg"><br><br>      . <br><br><img src="https://habrastorage.org/webt/qv/2s/hi/qv2shigmfokikarpx9kzdx0vsck.jpeg"><br><br><img src="https://habrastorage.org/webt/mu/3s/x2/mu3sx2aovopotm_gnyln8to95rm.jpeg"><br><br>      WebGL         2D canvas,      .   64 .   2D canvas,    25 ,     WebGL     0,3 .     . <br><br>  ,  WebGL     ,        ,      . <br><br>   , ,    ,   - break points, -  ,   . WebGL ‚Äî  . <br><br><img src="https://habrastorage.org/webt/6l/ke/u_/6lkeu_xuquuzt8pjc1uj8ckv1fa.jpeg"><br><br>    ,     . ,  Firefox    ¬´¬ª,        WebGL-,    ,    ,     . ,          . <br><br><img src="https://habrastorage.org/webt/w1/0j/vs/w10jvskiqvyvfrvhqwr4mpnu2uk.jpeg"><br><br>  ,    ,     Spector.js.    canvas  WebGL-         canvas,    . <br><br><img src="https://habrastorage.org/webt/o-/gm/sa/o-gmsa_uu9gddh7qzrept9418ne.jpeg"><br><br>          <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="> </a>  . ,   ,    , WebGL,    ,        .   . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de433278/">https://habr.com/ru/post/de433278/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de433268/index.html">PHP-Telegramm-Client (und Empfangen von Nachrichten mit MadelineProto)</a></li>
<li><a href="../de433270/index.html">MapStruct-Probleml√∂sung mit ManyToMany</a></li>
<li><a href="../de433272/index.html">Interview mit David Gobel</a></li>
<li><a href="../de433274/index.html">Oleg Dokuka √ºber die reaktive Entwicklung auf jug.msk.ru</a></li>
<li><a href="../de433276/index.html">Informationen zu den Vorteilen der Einbettung von CSS in JS</a></li>
<li><a href="../de433280/index.html">DEFCON-Konferenz 18. Trollim Reverse Engineering mit Mathematik</a></li>
<li><a href="../de433282/index.html">Gateways f√ºr industrielle Austauschprotokolle unter Linux. Bauen Sie sich zusammen</a></li>
<li><a href="../de433286/index.html">10 n√§chstgelegene IT-Meetings und Hackathons in Moskau</a></li>
<li><a href="../de433288/index.html">Web Security: Einf√ºhrung in HTTP</a></li>
<li><a href="../de433292/index.html">Die Zusammenfassung interessanter Materialien f√ºr den mobilen Entwickler # 279 (vom 10. bis 16. Dezember)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>