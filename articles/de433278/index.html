<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤞🏽 🧙 👩‍🏭 WebGL-Wind- und GPU-Programmierung. Vortrag bei FrontTalks 2018 👨🏾‍🚒 🍷 〰️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Zum Rendern komplexer Grafiken auf Webseiten gibt es eine Webgrafikbibliothek, die als WebGL abgekürzt wird. Der Interface-Designer Dmitry Vasiliev sp...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>WebGL-Wind- und GPU-Programmierung. Vortrag bei FrontTalks 2018</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/yandex/blog/433278/">  Zum Rendern komplexer Grafiken auf Webseiten gibt es eine Webgrafikbibliothek, die als WebGL abgekürzt wird.  Der Interface-Designer Dmitry Vasiliev sprach über die GPU-Programmierung aus Sicht eines Layout-Designers, darüber, was WebGL ist und wie wir das Problem der Visualisierung großer Wetterdaten mit dieser Technologie gelöst haben. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/-yvY4-ovavo" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  - Ich entwickle Schnittstellen im Jekaterinburger Büro von Yandex.  Ich habe in der Sportgruppe angefangen.  Wir haben spezielle Sportprojekte entwickelt, als es Weltmeisterschaften in Hockey, Fußball, Olympischen Spielen, Paralympics und anderen coolen Events gab.  Ich habe auch an der Entwicklung spezieller Suchergebnisse gearbeitet, die dem neuen Sotschi-Track gewidmet waren. <br><br><a name="habracut"></a><img src="https://habrastorage.org/webt/5p/l2/e_/5pl2e_nhpyefyjt0q3wfspflpyc.jpeg"><br><br><img src="https://habrastorage.org/webt/qw/zy/xd/qwzyxdlvu0jukewd-9prrerk-a8.jpeg"><br><br><img src="https://habrastorage.org/webt/uy/7b/mp/uy7bmpkufgne4mck5yiawv3mj1o.jpeg"><br><br><img src="https://habrastorage.org/webt/q6/cu/kw/q6cukwvmpmwru6iew_ranhk7mwo.jpeg"><br><h5>  <sub><sup><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Link von der Folie</a></sup></sub> </h5><br>  Außerdem haben wir in anderthalb Helmen den Dienst "Arbeit an Fehlern" neu gestartet.  Und dann begann die Arbeit in Pogoda, wo ich die Funktionsfähigkeit der API, ihre Entwicklung, das Schreiben der Infrastruktur um diese API und das Schreiben von Knotenordnern für die trainierten maschinellen Lernformeln unterstützte. <br><br><img src="https://habrastorage.org/webt/sz/xs/zy/szxszynumbssi9qyhkxwalfmsdy.jpeg"><br><br>  Dann begann die Arbeit interessanter.  Teilnahme an der Neugestaltung unserer Wetterdienste.  Desktops, Schubkarren. <br><br><img src="https://habrastorage.org/webt/io/q4/cw/ioq4cwweh1vbjyqonlto5yuo_1e.jpeg"><br><br><img src="https://habrastorage.org/webt/ij/er/w6/ijerw62hpfkj2kvph4wvuag_www.jpeg"><br><br>  Nachdem wir die Standardprognosen in Ordnung gebracht hatten, beschlossen wir, die Prognose zu erstellen, die niemand hat.  Diese Prognose war die Prognose für die Bewegung der Niederschläge in den Gebieten. <br><br><img src="https://habrastorage.org/webt/xc/n_/cf/xcn_cfakd_xnyoxaazxgc4bvmso.jpeg"><br><br>  Es gibt spezielle Wetterradare, die Niederschläge in einem Umkreis von 2000 km erfassen, deren Dichte und Entfernung sie kennen. <br><br><img src="https://habrastorage.org/webt/as/ea/av/aseaavvwl0v3lqhex1kx_dvsr1w.jpeg"><br><br>  Mit diesen Daten und Vorhersagen mithilfe des maschinellen Lernens ihrer weiteren Bewegung haben wir eine <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">solche Visualisierung</a> auf der Karte erstellt.  Sie können sich hin und her bewegen. <br><br><img src="https://habrastorage.org/webt/jt/qo/fj/jtqofjz8eo8wrjybcydczpxse0a.jpeg"><br><h5>  <sub><sup><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Link von der Folie</a></sup></sub> </h5><br>  Wir haben uns die Bewertungen von Menschen angesehen.  Die Leute mochten es.  Alle Arten von Memen tauchten auf und es gab coole Bilder, als Moskau zur Hölle flutete. <br><br>  Da das Format allen gefallen hat, haben wir uns entschlossen, die folgende Vorhersage dem Wind zu widmen. <br><br><img src="https://habrastorage.org/webt/kl/mc/_f/klmc_fqnedxn-okos6d6bhmlszs.jpeg"><br><br>  Dienste, die die Windvorhersage anzeigen, sind bereits vorhanden.  Dies sind ein paar noble, die auffallen. <br><br><img src="https://habrastorage.org/webt/vo/vc/4k/vovc4kev5lhxvyph9t46z4uhei8.jpeg"><br><br>  Als wir sie betrachteten, wurde uns klar, dass wir dasselbe tun wollen - oder zumindest nicht schlimmer. <br><br>  Aus diesem Grund haben wir uns entschlossen, Partikel zu visualisieren, die sich je nach Windgeschwindigkeit reibungslos auf der Karte bewegen, und eine Art Schleife zu hinterlassen, damit sie gesehen werden können und die Flugbahn des Windes sichtbar ist. <br><br>  Da wir bereits großartig sind und eine coole Karte mit Niederschlag unter Verwendung von 2D-Leinwand erstellt haben, haben wir beschlossen, dasselbe mit den Partikeln zu tun. <br><br><img src="https://habrastorage.org/webt/hz/jd/yi/hzjdyivbulbjmfod7n2-nix8uca.jpeg"><br><br>  Nach Rücksprache mit dem Designer haben wir festgestellt, dass wir etwa 6% des Bildschirms mit Partikeln füllen müssen, um einen kühlen Effekt zu erzielen. <br><br>  Um eine solche Anzahl von Partikeln mit dem Standardansatz zu zeichnen, hatten wir ein Minimum von 5 ms. <br><br><img src="https://habrastorage.org/webt/yu/l1/7n/yul17ngn7dfm6cadtcy2dpkf6zu.jpeg"><br><br>  Wenn Sie der Meinung sind, dass wir die Partikel noch bewegen und eine Art Schönheit bringen müssen, z. B. das Zeichnen des Schwanzes der Partikel, können wir davon ausgehen, dass wir für ein Minimum von 40 ms ausfallen, um eine reibungslose Animation zu zeigen, um mindestens 25 Bilder pro Sekunde zu erzeugen. <br><br>  Das Problem ist, dass hier jedes Partikel nacheinander verarbeitet wird.  Aber was ist, wenn Sie sie parallel verarbeiten? <br><br>  Eine klare Unterscheidung zwischen der Bedienung der Zentral- und Grafikprozessoren zeigte „Legend Destroyers“ auf einer der Konferenzen.  Sie rollten eine Maschine aus, auf der ein Paintball-Marker installiert war, dessen Aufgabe es war, einen Smiley in einer Farbe zu zeichnen.  In ungefähr 10 Sekunden zeichnete er ein solches Bild.  ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Link zum Video</a> - ca.) <br><br><img src="https://habrastorage.org/webt/kk/pi/cw/kkpicwfdskxnicbu0jb7sowhgfq.jpeg"><br><br><img src="https://habrastorage.org/webt/zd/ka/3a/zdka3al72tgfcavb5yvww_qx2ug.jpeg"><br><br><img src="https://habrastorage.org/webt/i9/tm/kh/i9tmkhykoiz8vkim-vzftxjjl44.jpeg"><br><br>  Dann rollten die Jungs ein Kanu aus, das eine GPU ist, und ein paar Spieße bemalten Mona Lisa.  Auf diese Weise unterscheidet sich die Rechengeschwindigkeit von CPU und GPU. <br><br><img src="https://habrastorage.org/webt/dm/x-/hc/dmx-hckqzdlztdat2wm-j88cj-k.jpeg"><br><br><img src="https://habrastorage.org/webt/zg/pa/3m/zgpa3m281vzirvjqotbuoqnmms8.jpeg"><br><br><img src="https://habrastorage.org/webt/hq/lf/uj/hqlfujoqgr4mhgxucjpx7xnmedu.jpeg"><br><br><img src="https://habrastorage.org/webt/qb/zo/xz/qbzoxzq0tywqxi0pc2xifdnvnds.jpeg"><br><br><img src="https://habrastorage.org/webt/d6/z5/kq/d6z5kq5c23fjmb2uzfx4aqqj3ec.jpeg"><br><br>  Um diese Funktionen in einem Browser nutzen zu können, wurde die WebGL-Technologie erfunden. <br><br>  Was ist das?  Mit dieser Frage stieg ich ins Internet.  Ich fügte ein paar Wörter mit Partikelanimation und Wind hinzu und fand ein paar Artikel. <br><br><img src="https://habrastorage.org/webt/ob/d-/w_/obd-w_edp80lvmzlh3xmh437itw.jpeg"><br><h5>  <sub><sup>Links von der Folie: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">erstens</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">zweitens</a></sup></sub> </h5><br>  Eine davon ist eine Demo von Vladimir Agafonkin, einem Ingenieur von Mapbox, der den Wind auf WebGL gemacht hat und auf den Blog von Chris Wellons verwiesen hat, der darüber sprach, wie man den Zustand von Partikeln auf der GPU bewegt und speichert. <br><br>  Wir nehmen und kopieren.  Wir erwarten ein solches Ergebnis.  Hier bewegen sich die Partikel reibungslos. <br><br><img src="https://habrastorage.org/webt/s6/5t/7-/s65t7-020jphv-fvyzbk5vpkmoq.jpeg"><br><br>  Wir bekommen nicht zu verstehen was. <br><br><img src="https://habrastorage.org/webt/7n/8i/t1/7n8it1gwmfklms2akt9nydmgima.jpeg"><br><br>  Ich versuche den Code herauszufinden.  Verbessern, wieder ein unbefriedigendes Ergebnis erzielen.  Wir klettern noch tiefer - wir bekommen Regen statt Wind. <br><br><img src="https://habrastorage.org/webt/n4/bd/b1/n4bdb1-ar38mb8lokfjfgjqbrue.jpeg"><br><br>  Okay, wir beschließen, es selbst zu tun. <br><br><img src="https://habrastorage.org/webt/lw/ue/kv/lwuekvj_c1996sjj2q1c2fl4pyk.jpeg"><br><br>  Für die Arbeit mit WebGL sind Frameworks vorhanden.  Fast alle von ihnen zielen auf die Arbeit mit 3D-Objekten ab.  Wir benötigen diese 3D-Funktionen nicht.  Wir müssen nur ein Teilchen zeichnen und es bewegen.  Deshalb beschließen wir, alles mit unseren Händen zu machen. <br><br><img src="https://habrastorage.org/webt/rt/db/4z/rtdb4zokw74ivcedzljp4t3fu_g.jpeg"><br><br>  Derzeit gibt es zwei Versionen der WebGL-Technologie.  Die zweite Version, die cool ist, hat eine hochmoderne Version der Programmiersprache, in der das Programm im Grafikadapter ausgeführt wird, kann direkt Berechnungen durchführen und nicht nur zeichnen.  Aber es hat eine schlechte Kompatibilität. <br><br><img src="https://habrastorage.org/webt/yk/gr/ty/ykgrtypkwclnix0f4pat1retheu.jpeg"><br><br>  Nun, wir entscheiden uns für das alte bewährte WebGL 1, das neben Opera Mini, das niemand braucht, eine gute Unterstützung bietet. <br><br><img src="https://habrastorage.org/webt/sr/1q/xr/sr1qxr_ch7enl9z1rjwuv1hshpg.jpeg"><br><br>  WebGL ist eine Zwei-Komponenten-Sache.  Dies ist JS, das den Status von Programmen ausführt, die auf der Grafikkarte ausgeführt werden.  Und es gibt Komponenten, die direkt auf der Grafikkarte ausgeführt werden. <br><br>  Beginnen wir mit JS.  WebGL ist nur der geeignete Kontext für das Canvas-Element.  Darüber hinaus werden nach Erhalt dieses Kontexts nicht nur ein bestimmtes Objekt zugewiesen, sondern auch Eisenressourcen zugewiesen.  Und wenn wir in WebGL in einem Browser etwas Schönes ausführen und dann Quake spielen, ist es durchaus möglich, dass diese Ressourcen verloren gehen und der Kontext verloren geht und Ihr gesamtes Programm kaputt geht. <br><br><img src="https://habrastorage.org/webt/y3/bm/p0/y3bmp0fddy1vkxkktxantfrfcdw.jpeg"><br><br>  Wenn Sie mit WebGL arbeiten, müssen Sie daher auch auf den Kontextverlust achten und ihn wiederherstellen können.  Deshalb habe ich betont, dass init ist. <br><br><img src="https://habrastorage.org/webt/aj/iu/zk/ajiuzkpsukwyhrhvte4oduqivri.jpeg"><br><br>  Darüber hinaus läuft die gesamte Arbeit von JS darauf hinaus, Programme zu sammeln, die auf der GPU ausgeführt werden, ihnen eine Grafikkarte zu senden, einige Parameter festzulegen und "Zeichnen" zu sagen. <br><br><img src="https://habrastorage.org/webt/3k/2m/zd/3k2mzdhdejzpaxjrx_upik6fdeu.jpeg"><br><br>  Wenn Sie in WebGL das Kontextelement selbst betrachten, sehen Sie eine Reihe von Konstanten.  Diese Konstanten beziehen sich auf Adressen im Speicher.  Sie sind im Verlauf des Programms nicht wirklich konstant.  Wenn der Kontext verloren geht und erneut wiederhergestellt wird, kann ein anderer Adresspool zugewiesen werden, und diese Konstanten unterscheiden sich für den aktuellen Kontext.  Daher werden fast alle Vorgänge in WebGL auf der JS-Seite über Dienstprogramme ausgeführt.  Niemand möchte die Routinearbeit erledigen, um Adressen und anderen Müll zu finden. <br><br><img src="https://habrastorage.org/webt/ii/o7/sa/iio7sahs5z0gt5bccxesgiict44.jpeg"><br><br>  Wir wenden uns dem zu, was auf der Grafikkarte selbst ausgeführt wird - einem Programm, das aus zwei Anweisungen besteht, die in einer C-ähnlichen GLSL-Sprache geschrieben sind.  Diese Anweisungen werden als Vertex-Shader und Fragment-Shader bezeichnet.  Aus ihrem Paar wird ein Programm erstellt. <br><br><img src="https://habrastorage.org/webt/qg/fu/lb/qgfulbs6almqwpkmutcsxv38-cm.jpeg"><br><br>  Was ist der Unterschied zwischen diesen Shadern?  Der Vertex-Shader legt die Oberfläche fest, auf der etwas gezeichnet werden soll.  Nachdem das Grundelement festgelegt wurde, das übermalt werden soll, wird der Fragment-Shader aufgerufen, der in diesen Bereich fällt. <br><br><img src="https://habrastorage.org/webt/up/h_/ya/uph_yasoh3q-99otxdym43zykmw.jpeg"><br><br><img src="https://habrastorage.org/webt/u7/vi/qb/u7viqbviwm76x4ovlvion5mm2o8.jpeg"><br><br>  Im Code sieht es so aus.  Der Shader verfügt über einen Abschnitt zum Deklarieren von Variablen, die extern von JS festgelegt werden. Ihr Typ und Name werden bestimmt.  Sowie der Hauptabschnitt, der den für diese Iteration erforderlichen Code ausführt. <br><br>  In den meisten Fällen wird von einem Vertex-Shader erwartet, dass er die Variable gl_Position auf eine Koordinate im vierdimensionalen Raum setzt.  Dies sind x, y, z und die Breite des Raums, was im Moment nicht sehr wichtig ist, um es zu wissen. <br><br>  Der Fragment-Shader erwartet, die Farbe eines bestimmten Pixels festzulegen. <br><br>  In diesem Beispiel haben wir die Pixelfarbe aus der verbundenen Textur ausgewählt. <br><br><img src="https://habrastorage.org/webt/y8/nw/1y/y8nw1y1gnwstkv2rgqxatduyuni.jpeg"><br><br>  Um dies auf JS zu übertragen, wickeln Sie einfach den Quellcode der Shader in Variablen ein. <br><br><img src="https://habrastorage.org/webt/ax/fz/ou/axfzouj0xwui47sftwgdhlcadd0.jpeg"><br><br>  Ferner werden diese Variablen in Shader umgewandelt.  Dies ist ein WebGL-Kontext. Wir erstellen Shader aus Quellcodes, erstellen parallel ein Programm und fügen dem Programm einige Shader hinzu.  Wir bekommen ein praktikables Programm. <br><br>  Unterwegs überprüfen wir, ob die Kompilierung der Shader erfolgreich war und ob das Programm erfolgreich erstellt wurde.  Wir sagen, dass Sie dieses Programm verwenden müssen, da es mehrere Programme für unterschiedliche Renderwerte geben kann. <br><br>  Richten Sie es ein und sagen Sie Zeichnen.  Es stellt sich eine Art Bild heraus. <br><br><img src="https://habrastorage.org/webt/oz/py/ri/ozpyrifyoft_invjrawmmz-_fjg.jpeg"><br><br>  Tiefer geklettert.  Im Vertex-Shader werden alle Berechnungen im Raum von -1 bis 1 ausgeführt, unabhängig von der Größe Ihres Ausgabepunkts.  Beispielsweise kann der Abstand von -1 bis 1 den gesamten Bildschirm 1920 x 1080 einnehmen. Um ein Dreieck in der Mitte des Bildschirms zu zeichnen, müssen Sie eine Fläche zeichnen, die die Koordinaten 0, 0 abdeckt. <br><br><img src="https://habrastorage.org/webt/4q/yp/ex/4qypexiothorcvzkrk9y_p5v9tk.jpeg"><br><br>  Der Fragment-Shader arbeitet im Bereich von 0 bis 1, und die Farben werden von vier Komponenten angezeigt: R, G, B, Alpha. <br><br>  Am Beispiel von CSS können Sie bei der Verwendung von Prozentsätzen auf eine ähnliche Farbnotation stoßen. <br><br><img src="https://habrastorage.org/webt/ys/cn/kn/yscnkn-8x_yg0bl_zknm-42l17q.jpeg"><br><br>  Um etwas zu zeichnen, müssen Sie angeben, welche Daten gezeichnet werden müssen.  Speziell für ein Dreieck definieren wir ein typisiertes Array von drei Eckpunkten, die jeweils aus drei Komponenten bestehen: x, y und genug. <br><br>  In diesem Fall sieht der Vertex-Shader so aus, als würde er das aktuelle Paar von Punkten und Koordinaten abrufen und diese Koordinate auf dem Bildschirm festlegen.  Hier setzen wir ohne Transformationen einen Punkt auf den Bildschirm. <br><br><img src="https://habrastorage.org/webt/up/h_/ya/uph_yasoh3q-99otxdym43zykmw.jpeg"><br><br>  Der Fragment-Shader kann die von JS übergebenen Konstanten auch ohne zusätzliche Berechnungen mit Farbe färben.  Wenn außerdem einige Variablen im Fragment-Shader von außen oder vom vorherigen Shader übertragen werden, muss die Genauigkeit angegeben werden.  In diesem Fall ist eine mittlere Genauigkeit ausreichend und fast immer ausreichend. <br><br><img src="https://habrastorage.org/webt/dx/9v/jb/dx9vjbxuiz_swlbl1hlmlb5hmys.jpeg"><br><br>  Wir gehen zu JS.  Wir weisen Variablen dieselben Shader zu und deklarieren eine Funktion, die diese Shader erstellt.  Das heißt, ein Shader wird erstellt, die Quelle wird hineingegossen und dann kompiliert. <br><br><img src="https://habrastorage.org/webt/jf/x3/eg/jfx3eg-hhqsdbmpc378peyi6tym.jpeg"><br><br>  Wir machen zwei Shader, Vertex und Fragment. <br><br><img src="https://habrastorage.org/webt/jh/pb/um/jhpbumsovp4-rkstmx9dldtg7ug.jpeg"><br><br>  Erstellen Sie anschließend ein Programm und laden Sie bereits kompilierte Shader hoch.  Wir binden das Programm, weil die Shader Variablen untereinander austauschen können.  In diesem Stadium wird die Übereinstimmung der Variablentypen überprüft, die diese Shader austauschen. <br><br>  Wir sagen, dass Sie dieses Programm verwenden. <br><br><img src="https://habrastorage.org/webt/7i/hm/rc/7ihmrctum2gyy9cuybn5pr6hcbu.jpeg"><br><br>  Als Nächstes erstellen wir eine Liste der Scheitelpunkte, die wir visualisieren möchten.  WebGL hat eine interessante Funktion für einige Variablen.  Um einen bestimmten Datentyp zu ändern, müssen Sie den globalen Kontext für die Bearbeitung von array_buffer festlegen und dann etwas an diese Adresse hochladen.  Es gibt keine explizite Zuordnung von Daten zu einer Variablen.  Alles wird durch die Einbeziehung eines Kontextes getan. <br><br>  Es ist auch notwendig, die Regeln für das Lesen aus diesem Puffer festzulegen.  Es ist ersichtlich, dass wir ein Array von sechs Elementen angegeben haben, aber das Programm muss erklären, dass jeder Scheitelpunkt aus zwei Komponenten besteht, deren Typ float ist. Dies erfolgt in der letzten Zeile. <br><br><img src="https://habrastorage.org/webt/js/_j/qe/js_jqevmwlq0fmo_n6-vbdwsr-k.jpeg"><br><br>  Um die Farbe festzulegen, sucht das Programm nach der Adresse für die Variable u_color und legt den Wert für diese Variable fest.  Wir setzen die Farbe Rot 255, 0,8 von Grün, 0 Blau und ein völlig undurchsichtiges Pixel - es wird gelb.  Und wir sagen, um dieses Programm mit den Dreiecksprimitiven auszuführen, können Sie in WebGL Punkte, Linien, Dreiecke, Dreiecke mit komplexer Form usw. zeichnen.  Und mache drei Spitzen. <br><br><img src="https://habrastorage.org/webt/lk/pz/xe/lkpzxe_tur-bgozsoj47kohstty.jpeg"><br><br>  Sie können auch festlegen, dass das Array, über das wir rendern, von Anfang an gezählt werden soll. <br><br><img src="https://habrastorage.org/webt/p4/1f/_k/p41f_kioprwkxx7ommkzz7tcclw.jpeg"><br><h5>  <sub><sup><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Link von der Folie</a></sup></sub> </h5><br>  Wenn Sie das Beispiel etwas komplizieren, können Sie eine Farbabhängigkeit von der Cursorposition hinzufügen.  Gleichzeitig geht fps durch das Dach. <br><br><img src="https://habrastorage.org/webt/sl/eu/zl/sleuzlnxn8s1tlflhawo5obsrg8.jpeg"><br><br>  Um Partikel auf der ganzen Welt zu zeichnen, müssen Sie die Windgeschwindigkeit an jedem Punkt dieser Welt kennen. <br><br>  Um die Karte zu vergrößern und irgendwie zu verschieben, müssen Sie Container erstellen, die der aktuellen Position der Karte entsprechen. <br><br>  Um die Partikel selbst zu verschieben, müssen Sie ein Datenformat erstellen, das mithilfe einer GPU aktualisiert werden kann.  Machen Sie die Zeichnung selbst und zeichnen Sie die Schleife. <br><br><img src="https://habrastorage.org/webt/2o/vf/o_/2ovfo_hqaimoyygbbcpkbupf_cu.jpeg"><br><br>  Wir machen alle Daten durch die Textur.  Wir verwenden 22 Kanäle, um horizontale und vertikale Geschwindigkeiten zu bestimmen, wobei die Windgeschwindigkeit Null der Mitte des Farbbereichs entspricht.  Es ist ungefähr 128.  Da die Geschwindigkeit negativ und positiv sein kann, stellen wir die Farbe relativ zur Mitte des Bereichs ein. <br><br>  Es stellt sich so ein Bild heraus. <br><br><img src="https://habrastorage.org/webt/3-/qu/i8/3-qui8mkzufp6hucltuzpampili.jpeg"><br><br>  Um es auf eine Karte zu laden, müssen wir es schneiden.  Um das Bild mit der Karte zu verbinden, verwenden wir das Standardwerkzeug Yandex.Map Layer, mit dem wir die Adresse bestimmen, von der aus die Kacheln geschnitten werden sollen, und diese Ebene zur Karte hinzufügen. <br><br><img src="https://habrastorage.org/webt/jo/zj/a8/jozja8duysio2wljyezgjnhfn64.jpeg"><br><h5>  <sub><sup><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Link von der Folie</a></sup></sub> </h5><br>  Wir bekommen ein Bild, in dem die unangenehme grüne Farbe die Windgeschwindigkeit codiert. <br><br><img src="https://habrastorage.org/webt/uh/nk/jh/uhnkjh1e8sxzgzp-myix3xxyjn4.jpeg"><br><br>  Als nächstes müssen Sie einen Ort finden, an dem wir die Animation selbst zeichnen, während dieser Ort den Koordinaten der Karte, ihren Bewegungen und anderen Aktionen entsprechen sollte. <br><br>  Standardmäßig können wir davon ausgehen, dass wir Layer verwenden würden, aber die Kartenebene erstellt eine Zeichenfläche, aus der sofort der 2D-Kontext erfasst wird, den sie erfassen kann.  Wenn wir jedoch versuchen, aus der Leinwand, die bereits einen Kontext eines anderen Typs hat, einen GL-Kontext zu entnehmen, erhalten wir als Ergebnis null.  Wenn Sie darauf zugreifen, stürzt das Programm ab. <br><br><img src="https://habrastorage.org/webt/lg/9a/mn/lg9amncxtx9ndmnc7bjqkzcs_lw.jpeg"><br><h5>  <sub><sup><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Link von der Folie</a></sup></sub> </h5><br>  Daher haben wir Pane verwendet, dies sind Container für Layouts, und dort unsere Leinwand hinzugefügt, aus der wir bereits den benötigten Kontext übernommen haben. <br><br><img src="https://habrastorage.org/webt/v9/on/pb/v9onpb5gnorqq05kg0og8bd6wvq.jpeg"><br><br>  Um die Partikel irgendwie auf dem Bildschirm anzuordnen und bewegen zu können, wurde das Format der Position der Partikel in der Textur verwendet. <br><br>  Wie funktioniert es  Zur Optimierung wird eine quadratische Textur erstellt, und hier ist die Größe ihrer Seite bekannt. <br><br><img src="https://habrastorage.org/webt/ov/hm/qg/ovhmqgdfgbzg3k5wua7se3l-scm.jpeg"><br><br>  Indem Sie die Partikel der Reihe nach zeichnen und die Seriennummer des Partikels sowie die Größe der Textur kennen, in der sie gespeichert sind, können Sie ein bestimmtes Pixel berechnen, in dem die Position auf dem realen Bildschirm codiert ist. <br><br><img src="https://habrastorage.org/webt/xw/6c/ly/xw6clysjjqrtppxzih0cm4q3sis.jpeg"><br><br><img src="https://habrastorage.org/webt/a_/jt/9m/a_jt9ml9jdjn0vxxk7riv9sbkw8.jpeg"><br><br>  Im Shader selbst sieht es so aus, als würde man den gerenderten Index, die Textur mit der aktuellen Position der Partikel und der Größe der Seite lesen.  Als nächstes bestimmen wir die x, y-Koordinaten für dieses Teilchen, lesen diesen Wert und decodieren ihn.  Was für eine Magie ist das: rg / 255 + ba? <br><br>  Für die Position der Partikel verwenden wir 20 Doppelkanäle.  Der Farbkanal hat einen Wert von 0 bis 255, und für den 1080-Bildschirm können wir die Partikel für eine Weile nicht an einer beliebigen Position des Bildschirms platzieren, da das Maximum höchstens 255 Pixel betragen kann.  Daher speichern wir in einem Kanal das Wissen darüber, wie oft ein Partikel 255 Pixel passiert hat, und im zweiten Kanal speichern wir den genauen Wert, wie viel es danach passiert hat. <br><br>  Als Nächstes muss der Vertex-Shader diese Werte in seinen Arbeitsbereich konvertieren, dh von -1 bis 1, und diesen Punkt auf der Anzeige festlegen. <br><br><img src="https://habrastorage.org/webt/g2/ht/g_/g2htg_vqu8k5fdnn_zx6xtl82fs.jpeg"><br><br>  Um nur unsere Partikel zu betrachten, malen Sie sie einfach mit Weiß.  GLSL hat einen solchen Zucker, dass, wenn wir den Typ einer Variablen definieren und ihn an eine Konstante übergeben, diese Konstante beispielsweise auf alle vier Komponenten verteilt wird. <br><br><img src="https://habrastorage.org/webt/ee/h-/hz/eeh-hzn9oaitmm7k7gwfpzin8rq.jpeg"><br><br>  Nachdem wir ein solches Programm gezeichnet haben, sehen wir eine Reihe identischer Quadrate.  Versuchen wir, ihnen Schönheit zu verleihen. <br><br><img src="https://habrastorage.org/webt/-r/ud/i1/-rudi16ytlwsw-_fvafdhqmqync.jpeg"><br><br>  Addieren Sie zunächst die Abhängigkeit dieser Quadrate von der aktuellen Windgeschwindigkeit.  Wir lesen einfach die aktuelle Geschwindigkeit und die entsprechenden Texturen für jedes Partikel.  Wir erhalten die Länge des Vektors, die der absoluten Geschwindigkeit am Punkt entspricht, und addieren diese Geschwindigkeit zur Partikelgröße. <br><br><img src="https://habrastorage.org/webt/or/v-/qs/orv-qs0vwvlrcxadmlpvbywokdw.jpeg"><br><br>  Um die Quadrate nicht zu zeichnen, schneiden wir im Fragment-Shader alle Pixel ab, die außerhalb des Radius liegen und nicht im Radius des beschrifteten Kreises enthalten sind.  Das heißt, unser Shader verwandelt sich in so etwas. <br><br><img src="https://habrastorage.org/webt/t4/rx/ah/t4rxahmunedzb3k0jamjxiikvia.jpeg"><br><br>  Wir berechnen den Abstand zum gerenderten Pixel von der Mitte.  Wenn es die Hälfte des Platzes überschreitet, zeigen wir es nicht. <br><br><img src="https://habrastorage.org/webt/nr/do/ma/nrdomaus-zdhgroynefo3qacxck.jpeg"><br><br>  Wir bekommen ein vielfältigeres Bild. <br><br>  Als nächstes müssen Sie diese Dinge irgendwie bewegen.  Da WebGL 1 nicht weiß, wie man etwas berechnet und direkt mit Daten arbeitet, werden wir die Möglichkeit nutzen, Programme in spezielle Komponenten, Rahmenpuffer, zu zeichnen. <br><br>  Rahmenpuffer können beispielsweise Texturen zugeordnet werden, die aktualisiert werden können.  Wenn der Bildspeicher nicht deklariert ist, wird standardmäßig auf dem Bildschirm gezeichnet. <br><br>  Wenn Sie die Ausgabe von einer Positionstextur in eine andere umschalten, können Sie sie einzeln aktualisieren und dann zum Rendern verwenden. <br><br><img src="https://habrastorage.org/webt/j7/-j/tn/j7-jtnjwzj-8pav52t-ngiolwji.jpeg"><br><br><img src="https://habrastorage.org/webt/8y/me/ey/8ymeey1havzw-wavn5x8ztr87em.jpeg"><br><br>  Das Verfahren zum Aktualisieren der Position selbst sieht folgendermaßen aus: Lesen Sie die aktuelle Position, fügen Sie sie dem aktuellen Geschwindigkeitsvektor hinzu, fügen Sie sie hinzu und codieren Sie sie in einer neuen Farbe. <br><br><img src="https://habrastorage.org/webt/t7/up/wj/t7upwjpzr8ubgig0cwr1_hn7npa.jpeg"><br><br>  Im Code sieht es so aus, als würde man die aktuelle Position lesen, dekodieren, die aktuelle Geschwindigkeit lesen, die Geschwindigkeit normalisieren, die beiden Komponenten falten und in Farbe codieren. <br><br><img src="https://habrastorage.org/webt/uo/cc/qo/uoccqo8i2fubmgay3oi90teclzw.jpeg"><br><br>  Es stellt sich so ein Bild heraus.  Der Zustand der Partikel ändert sich ständig und es erscheint eine Art Animation. <br><br>  Wenn Sie eine solche Animation 5-10 Minuten lang ausführen, ist klar, dass alle Partikel an ihrem endgültigen Ziel ankommen.  Sie alle gleiten in den Trichter.  Du bekommst so ein Bild. <br><br><img src="https://habrastorage.org/webt/be/m0/bx/bem0bxbrxar_it9lgdjdc2fk91y.jpeg"><br><br>  Um dies zu vermeiden, führen wir einen Faktor der Partikelpermutation an einer zufälligen Stelle ein. <br><br>  Dies hängt von der aktuellen Windgeschwindigkeit, der aktuellen Partikelposition und der Zufallszahl ab, die wir von JS senden - da die erste Version von WebGL keine Randomisierungsfunktion und keine Rauschfunktionen enthält. <br><br><img src="https://habrastorage.org/webt/zt/ur/_b/ztur_bhp_epcyqk1kzaz9b1r0a0.jpeg"><br><br>  In diesem Beispiel berechnen wir die vorhergesagte Position des Partikels, die zufällige Position, und wählen je nach Rücksetzfaktor entweder die eine oder die andere aus. <br><br><img src="https://habrastorage.org/webt/6o/qq/m8/6oqqm8iswgovcsguseunzhwxauc.jpeg"><br><h5>  <sub><sup>Links von der Folie: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">erste</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">zweite</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">dritte</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">vierte</a></sup></sub> </h5><br>  Um zu verstehen, was auf der letzten Folie war, können Sie diese Artikel lesen.  Die erste Methode bietet einen enormen Beitrag zum Verständnis dessen, was WebGL bietet, woraus es besteht und wie man keinen Fehler macht.  Bei Khronos ist dies eine Gruppe, die sich mit der Entwicklung des Standards befasst. Es gibt eine Beschreibung aller Funktionen. <br><br><img src="https://habrastorage.org/webt/5u/qi/st/5uqistm5t05pqha9xfm1oqdnxfu.jpeg"><br><br>  Der letzte Punkt unserer Aufgabe ist es, eine Spur von Partikeln zu zeichnen.  Zu diesem Zweck zeichnen wir, genau wie bei den Positionsaktualisierungstexturen, die aktuelle Position auf dem Bildschirm in zwei Texturen auf und zeigen die aktuelle Position an, wobei wir die Transparenz geringfügig erhöhen, eine neue Partikelposition überlagern und dann die Transparenz dieses Bildes immer wieder erhöhen    . <br><br><img src="https://habrastorage.org/webt/es/-8/oa/es-8oakhvm9ds8uh-e7teuivgnk.jpeg"><br><br>      . <br><br><img src="https://habrastorage.org/webt/qv/2s/hi/qv2shigmfokikarpx9kzdx0vsck.jpeg"><br><br><img src="https://habrastorage.org/webt/mu/3s/x2/mu3sx2aovopotm_gnyln8to95rm.jpeg"><br><br>      WebGL         2D canvas,      .   64 .   2D canvas,    25 ,     WebGL     0,3 .     . <br><br>  ,  WebGL     ,        ,      . <br><br>   , ,    ,   - break points, -  ,   . WebGL —  . <br><br><img src="https://habrastorage.org/webt/6l/ke/u_/6lkeu_xuquuzt8pjc1uj8ckv1fa.jpeg"><br><br>    ,     . ,  Firefox    «»,        WebGL-,    ,    ,     . ,          . <br><br><img src="https://habrastorage.org/webt/w1/0j/vs/w10jvskiqvyvfrvhqwr4mpnu2uk.jpeg"><br><br>  ,    ,     Spector.js.    canvas  WebGL-         canvas,    . <br><br><img src="https://habrastorage.org/webt/o-/gm/sa/o-gmsa_uu9gddh7qzrept9418ne.jpeg"><br><br>          <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="> </a>  . ,   ,    , WebGL,    ,        .   . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de433278/">https://habr.com/ru/post/de433278/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de433268/index.html">PHP-Telegramm-Client (und Empfangen von Nachrichten mit MadelineProto)</a></li>
<li><a href="../de433270/index.html">MapStruct-Problemlösung mit ManyToMany</a></li>
<li><a href="../de433272/index.html">Interview mit David Gobel</a></li>
<li><a href="../de433274/index.html">Oleg Dokuka über die reaktive Entwicklung auf jug.msk.ru</a></li>
<li><a href="../de433276/index.html">Informationen zu den Vorteilen der Einbettung von CSS in JS</a></li>
<li><a href="../de433280/index.html">DEFCON-Konferenz 18. Trollim Reverse Engineering mit Mathematik</a></li>
<li><a href="../de433282/index.html">Gateways für industrielle Austauschprotokolle unter Linux. Bauen Sie sich zusammen</a></li>
<li><a href="../de433286/index.html">10 nächstgelegene IT-Meetings und Hackathons in Moskau</a></li>
<li><a href="../de433288/index.html">Web Security: Einführung in HTTP</a></li>
<li><a href="../de433292/index.html">Die Zusammenfassung interessanter Materialien für den mobilen Entwickler # 279 (vom 10. bis 16. Dezember)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>