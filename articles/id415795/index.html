<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🌅 🔥 👎🏽 Menulis Snapchat UI di Swift 👯 🐞 😢</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Prolog 


 Di salah satu proyek saya, saya perlu membuat antarmuka seperti itu di Snepchat. Ketika sebuah kartu dengan informasi keluar dari gambar da...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Menulis Snapchat UI di Swift</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/415795/"><h2 id="prolog">  Prolog </h2><br><p> Di salah satu proyek saya, saya perlu membuat antarmuka seperti itu di Snepchat.  Ketika sebuah kartu dengan informasi keluar dari gambar dari kamera, gantikan dengan warna solid, dan juga arah yang berlawanan.  Saya pribadi sangat terpesona oleh transisi dari jendela kamera ke kartu samping, dan dengan senang hati saya pergi untuk menceritakan cara-cara untuk menyelesaikan masalah ini. </p><br><p>  Di sebelah kiri adalah contoh dari Snepchat, di sebelah kanan adalah contoh dari aplikasi yang akan kita buat. </p><br><p><img src="https://habrastorage.org/webt/es/cx/sd/escxsdlqbwqu7rfh9l9lcjjcl0a.gif"><img src="https://habrastorage.org/webt/vg/xf/8v/vgxf8vdl1gwnu0vplvu9gikqaho.gif"></p><a name="habracut"></a><br><p> Mungkin solusi pertama yang muncul dalam pikiran adalah untuk mengadaptasi <code>UIScrollView</code> , entah bagaimana mengatur pandangan di atasnya, menggunakan pagination, tetapi, terus terang, gulungan itu dianggap untuk menyelesaikan tugas yang sama sekali berbeda, mengambil animasi tambahan yang melelahkan, dan tidak memiliki fleksibilitas yang diperlukan pengaturan.  Oleh karena itu, menggunakannya untuk menyelesaikan masalah ini sama sekali tidak dapat dibenarkan. </p><br><p>  Gulir antara jendela kamera dan tab samping menipu - ini bukan gulungan sama sekali, ini merupakan transisi interaktif antara tampilan yang dimiliki oleh pengontrol yang berbeda.  Tombol-tombol di bagian bawahnya adalah tab biasa, mengklik tombol yang melemparkan kita di antara pengontrol. </p><br><p><img src="https://habrastorage.org/webt/s1/xq/o7/s1xqo7xcojshfu3lqvdjiyonluk.jpeg"></p><br><p>  Dengan cara ini, Snatch menggunakan pengontrol navigasi versi sendiri seperti <code>UITabBarController</code> dengan transisi interaktif khusus. </p><br><p>  <code>UIKit</code> menyertakan dua opsi untuk pengontrol navigasi yang memungkinkan Anda untuk menyesuaikan transisi - ini adalah <code>UINavigationController</code> dan <code>UITabBarController</code> .  Keduanya memiliki metode <code>navigationController(_:interactionControllerFor:)</code> dan <code>tabBarController(_:interactionControllerFor:)</code> di masing-masing delegasi, yang memungkinkan kami untuk menggunakan animasi interaktif sendiri untuk transisi. </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tabBarController (_: interaksiControllerFor :)</a> </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">navigationController (_: interaksiControllerFor :)</a> </p><br><p>  Tetapi saya tidak ingin dibatasi oleh implementasi <code>UITabBarController</code> atau <code>UINavigationController</code> , terutama karena kita tidak dapat mengendalikan logika internal mereka.  Oleh karena itu, saya memutuskan untuk menulis controller serupa saya, dan sekarang saya ingin memberi tahu dan menunjukkan apa yang terjadi. </p><br><h2 id="postanovka-zadachi">  Pernyataan masalah </h2><br><p>  Buat pengontrol wadah Anda sendiri, di mana Anda dapat beralih di antara pengontrol anak menggunakan animasi interaktif untuk transisi, menggunakan mekanisme standar di <code>UITabBarController</code> dan <code>UINavigationController</code> .  Kita memerlukan mekanisme standar ini untuk menggunakan animasi transisi yang sudah jadi dari tipe <code>UIViewControllerAnimatedTransitioning</code> sudah ditulis. </p><br><h2 id="podgotovka-proekta">  Persiapan proyek </h2><br><p>  Biasanya saya mencoba untuk memindahkan modul ke dalam kerangka kerja yang terpisah, untuk ini saya membuat proyek aplikasi baru, dan menambahkan target <code>Cocoa Touch Framework</code> sana, dan kemudian menyebarkan sumber dalam proyek untuk target yang sesuai.  Dengan cara ini saya mendapatkan kerangka kerja terpisah dengan aplikasi uji untuk debugging. </p><br><p>  Buat <code>Single View App</code> . </p><br><p><img src="https://habrastorage.org/webt/6p/eb/pa/6pebpaksin3ixvmlpse9tj7rnzs.png"></p><br><p>  <code>Product Name</code> akan menjadi target kami. </p><br><p><img src="https://habrastorage.org/webt/aq/qv/fg/aqqvfgoimy4kv85lqjrb34tbkco.png"></p><br><p>  Klik pada <code>+</code> untuk menambahkan target. </p><br><p><img src="https://habrastorage.org/webt/_b/2v/vj/_b2vvjuxpzkbvcmxuo8wxsctza0.png"></p><br><p>  Pilih <code>Cocoa Touch Framework</code> . </p><br><p><img src="https://habrastorage.org/webt/kr/mg/yy/krmgyylj_xfil50cdtejstjdpuc.png"></p><br><p>  Kami menyebut kerangka kerja kami nama yang tepat, Xcode secara otomatis memilih proyek untuk target kami dan menawarkan untuk mengikat biner langsung ke dalam aplikasi.  Kami setuju. </p><br><p><img src="https://habrastorage.org/webt/no/xi/cn/noxicnp_oslkyxhn3qkmcaukpom.png"></p><br><p>  Kami tidak akan memerlukan <code>Main.storyboard</code> dan <code>ViewController.swift</code> default, kami menghapusnya. </p><br><p><img src="https://habrastorage.org/webt/_m/zq/aw/_mzqawkdo2pi9zgulfqlwnhs2vo.png"></p><br><p>  Juga jangan lupa untuk menghapus nilai dari <code>Main Interface</code> di target aplikasi pada tab <code>General</code> . </p><br><p><img src="https://habrastorage.org/webt/kt/sv/3v/ktsv3vjy_1vqgwdnkh288h4ecpc.png"></p><br><p>  Sekarang kita pergi ke <code>AppDelegate.swift</code> dan hanya menyisakan metode <code>application</code> dari konten berikut: </p><br><pre> <code class="hljs swift"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">application</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">_</span></span></span></span><span class="hljs-function"><span class="hljs-params"> application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplicationLaunchOptionsKey: </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">Any</span></span></span></span><span class="hljs-function"><span class="hljs-params">]?)</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Bool</span></span> { <span class="hljs-comment"><span class="hljs-comment">// Launch our master view controller let master = MasterViewController() window = UIWindow() window?.rootViewController = master window?.makeKeyAndVisible() return true }</span></span></code> </pre> <br><p>  Di sini kita mengatur pengontrol kita di tempat utama sehingga muncul setelah peluncur. </p><br><p>  Sekarang buat <code>MasterViewController</code> .  Ini akan terkait dengan aplikasi, jadi penting untuk memilih target yang tepat saat membuat file. </p><br><p><img src="https://habrastorage.org/webt/7m/0y/r8/7m0yr8cefaenhznoqbjisg7sy1q.png"></p><br><p>  Kami akan mewarisi <code>MasterViewController</code> dari <code>SnapchatNavigationController</code> , yang akan kami implementasikan nanti dalam framework.  Jangan lupa untuk menentukan <code>import</code> kerangka kerja kami.  Saya tidak memberikan kode pengontrol lengkap di sini, kelalaian diperlihatkan oleh elips <code>...</code> , saya menempatkan aplikasi pada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">GitHub</a> , di sana Anda dapat melihat semua detail.  Dalam pengontrol ini, kami hanya tertarik pada metode <code>viewDidLoad()</code> , yang menginisialisasi pengontrol latar belakang dengan kamera + satu pengontrol transparan (jendela utama) + pengontrol yang berisi kartu yang berangkat. </p><br><pre> <code class="hljs scala"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-type"><span class="hljs-type">MakingSnapchatNavigation</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MasterViewController</span></span></span></span>: <span class="hljs-type"><span class="hljs-type">SnapchatNavigationController</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> func viewDidLoad() { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.viewDidLoad() <span class="hljs-comment"><span class="hljs-comment">//   let camera = CameraViewController() setBackground(vc: camera) //     var vcs: [UIViewController] = [] //    var stub = UIViewController() stub.view.backgroundColor = .clear vcs.append(stub) //  ,     stub = UIViewController() stub.view.backgroundColor = .clear //   let scroll = UIScrollView() stub.view.addSubview(scroll) //  ... //  ,      let content = GradientView() //  ... //    scroll.addSubview(content) vcs.append(stub) //     - setViewControllers(vcs: vcs) } }</span></span></code> </pre> <br><p>  Apa yang sedang terjadi di sini?  Kami membuat pengontrol dengan kamera dan mengaturnya ke latar belakang menggunakan metode <code>setBackground</code> dari <code>SnapchatNavigationController</code> .  Pengontrol ini berisi gambar yang diregangkan untuk seluruh tampilan dari kamera.  Kemudian kita membuat pengontrol transparan kosong dan menambahkannya ke array, itu hanya melewati gambar dari kamera melaluinya, kita dapat menempatkan kontrol di atasnya, membuat pengontrol transparan lain, menambahkan gulir ke sana, menambahkan tampilan dengan konten di dalam gulir, menambahkan pengontrol kedua ke array dan set array ini menggunakan metode <code>setViewControllers</code> khusus dari induk <code>SnapchatNavigationController</code> . </p><br><p>  Jangan lupa untuk menambahkan permintaan untuk menggunakan kamera di <code>Info.plist</code> </p><br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">key</span></span></span><span class="hljs-tag">&gt;</span></span>NSCameraUsageDescription<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">key</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">string</span></span></span><span class="hljs-tag">&gt;</span></span>Need camera for background<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">string</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br><p>  Pada ini, kami menganggap aplikasi uji siap, dan beralih ke bagian paling menarik - implementasi kerangka kerja. </p><br><h2 id="struktura-roditelskogo-kontrollera">  Struktur Pengontrol Induk </h2><br><p>  Pertama, buat <code>SnapchatNavigationController</code> kosong, penting untuk memilih target yang tepat untuk itu.  Jika semuanya dilakukan dengan benar, maka aplikasi harus dibangun.  Status proyek ini dapat diturunkan dengan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">referensi</a> . </p><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">open</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> SnapchatNavigationController: UIViewController { override <span class="hljs-keyword"><span class="hljs-keyword">open</span></span> func viewDidLoad() { super.viewDidLoad() // <span class="hljs-keyword"><span class="hljs-keyword">Do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">any</span></span> additional setup <span class="hljs-keyword"><span class="hljs-keyword">after</span></span> loading the <span class="hljs-keyword"><span class="hljs-keyword">view</span></span>. } // MARK: - <span class="hljs-built_in"><span class="hljs-built_in">Public</span></span> interface /// Sets <span class="hljs-keyword"><span class="hljs-keyword">view</span></span> controllers. <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> func setViewControllers(vcs: [UIViewController]) { } /// Sets background <span class="hljs-keyword"><span class="hljs-keyword">view</span></span>. <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> func setBackground(vc: UIViewController) { } }</code> </pre> <br><p>  Sekarang tambahkan komponen internal yang akan terdiri dari pengontrol.  Saya tidak membawa semua kode di sini, saya hanya fokus pada poin-poin penting. </p><br><p>  Kami mengatur variabel untuk menyimpan array pengendali anak.  Sekarang kita secara kaku mengatur jumlah yang dibutuhkan - 2 buah.  Di masa mendatang, dimungkinkan untuk memperluas logika pengontrol untuk digunakan dengan sejumlah pengontrol.  Kami juga mengatur variabel untuk menyimpan pengontrol saat ini ditampilkan. </p><br><pre> <code class="hljs pgsql">private let requiredChildrenAmount = <span class="hljs-number"><span class="hljs-number">2</span></span> // MARK: - <span class="hljs-keyword"><span class="hljs-keyword">View</span></span> controllers /// top child <span class="hljs-keyword"><span class="hljs-keyword">view</span></span> controller private var topViewController: UIViewController? /// <span class="hljs-keyword"><span class="hljs-keyword">all</span></span> children <span class="hljs-keyword"><span class="hljs-keyword">view</span></span> controllers private var children: [UIViewController] = []</code> </pre> <br><p>  Buat tampilan.  Kita perlu satu tampilan untuk latar belakang, satu tampilan dengan efek yang ingin kita terapkan ke latar belakang saat mengganti controller.  Kami juga memiliki wadah tampilan untuk pengontrol anak saat ini dan indikator tampilan yang akan memberi tahu pengguna cara bekerja dengan navigasi. </p><br><pre> <code class="hljs bash">// MARK: - Views private <span class="hljs-built_in"><span class="hljs-built_in">let</span></span> backgroundViewContainer = UIView() private <span class="hljs-built_in"><span class="hljs-built_in">let</span></span> backgroundBlurEffectView: UIVisualEffectView = { <span class="hljs-built_in"><span class="hljs-built_in">let</span></span> backgroundBlurEffect = UIBlurEffect(style: UIBlurEffectStyle.light) <span class="hljs-built_in"><span class="hljs-built_in">let</span></span> backgroundBlurEffectView = UIVisualEffectView(effect: backgroundBlurEffect) backgroundBlurEffectView.alpha = 0 <span class="hljs-built_in"><span class="hljs-built_in">return</span></span> backgroundBlurEffectView }() /// content view <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> children private <span class="hljs-built_in"><span class="hljs-built_in">let</span></span> contentViewContainer = UIView() private <span class="hljs-built_in"><span class="hljs-built_in">let</span></span> swipeIndicatorView = UIView()</code> </pre> <br><p>  Di blok berikutnya, kita menetapkan dua variabel, <code>swipeAnimator</code> bertanggung jawab untuk animasi, <code>swipeInteractor</code> bertanggung jawab atas interaksi (kemampuan untuk mengontrol kemajuan animasi), kita harus menginisialisasi selama boot controller, jadi kami memaksa membuka. </p><br><pre> <code class="hljs erlang">// MARK: - Animation <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> transition private <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> swipeAnimator = AnimatedTransitioning() private var swipeInteractor: CustomSwipeInteractor!</code> </pre> <br><p>  Kami juga mengatur transformasi untuk indikator.  Kami menggeser indikator dengan lebar wadah + pergeseran ganda dari tepi + lebar indikator itu sendiri sehingga indikator berada di ujung wadah.  Lebar wadah akan diketahui selama aplikasi, sehingga variabel dihitung saat bepergian. </p><br><pre> <code class="hljs pgsql">// MARK: - Animation transforms private var swipeIndicatorViewTransform: CGAffineTransform { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> CGAffineTransform(translationX: -contentViewContainer.bounds.size.width + (swipeIndicatorViewXShift * <span class="hljs-number"><span class="hljs-number">2</span></span>) + swipeIndicatorViewWidth, y: <span class="hljs-number"><span class="hljs-number">0</span></span>) } }</code> </pre> <br><p>  Saat memuat pengontrol, kami menetapkan <code>self</code> animasi (kami akan mengimplementasikan protokol yang sesuai di bawah ini), menginisialisasi berinteraksi berdasarkan animasi kami, kemajuan yang akan dikontrolnya.  Kami juga menunjuknya sebagai delegasi.  Delegasi akan menanggapi permulaan gerakan pengguna dan memulai animasi atau membatalkan tergantung pada status controller.  Kemudian kami menambahkan semua tampilan ke tampilan utama dan memanggil <code>setupViews()</code> , yang mengatur kendala. </p><br><pre> <code class="hljs swift"><span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">open</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">viewDidLoad</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.viewDidLoad() swipeAnimator.animation = <span class="hljs-keyword"><span class="hljs-keyword">self</span></span> swipeInteractor = <span class="hljs-type"><span class="hljs-type">CustomSwipeInteractor</span></span>(with: swipeAnimator) swipeInteractor.delegate = <span class="hljs-keyword"><span class="hljs-keyword">self</span></span> view.addSubview(backgroundViewContainer) view.addSubview(backgroundBlurEffectView) view.addSubview(contentViewContainer) view.addSubview(swipeIndicatorView) setupViews() }</code> </pre> <br><p>  Selanjutnya, kita beralih ke logika menginstal dan menghapus pengontrol anak dalam sebuah wadah.  Semuanya di sini sederhana seperti dalam dokumentasi Apple.  Kami menggunakan metode yang ditentukan untuk jenis operasi ini. </p><br><p>  <code>addChildViewController(vc)</code> - tambahkan pengendali anak ke yang sekarang. </p><br><p>  <code>contentViewContainer.addSubview(vc.view)</code> - tambahkan tampilan controller ke hierarki tampilan. </p><br><p>  <code>vc.view.frame = contentViewContainer.bounds</code> - rentangkan tampilan ke seluruh wadah.  Karena kita menggunakan bingkai di sini alih-alih tata letak otomatis, kita perlu mengubah ukurannya setiap kali ukuran pengontrol berubah, kita akan menghilangkan logika ini dan menganggap bahwa wadah tidak akan mengubah ukuran aplikasi saat aplikasi sedang berjalan. </p><br><p>  <code>vc.didMove(toParentViewController: self)</code> - mengakhiri operasi penambahan pengendali anak. </p><br><p>  <code>swipeInteractor.wireTo</code> - kita ikat pengontrol saat ini dengan gerakan pengguna.  Nanti kita akan menganalisis metode ini. </p><br><pre> <code class="hljs pgsql">// MARK: - Private methods private func addChild(vc: UIViewController) { addChildViewController(vc) contentViewContainer.addSubview(vc.<span class="hljs-keyword"><span class="hljs-keyword">view</span></span>) vc.<span class="hljs-keyword"><span class="hljs-keyword">view</span></span>.frame = contentViewContainer.bounds vc.didMove(toParentViewController: self) topViewController = vc let goingRight = children.<span class="hljs-keyword"><span class="hljs-keyword">index</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">of</span></span>: topViewController!) == <span class="hljs-number"><span class="hljs-number">0</span></span> swipeInteractor.wireTo(viewController: topViewController!, edge: goingRight ? .right : .left) } private func removeChild(vc: UIViewController) { vc.willMove(toParentViewController: nil) vc.<span class="hljs-keyword"><span class="hljs-keyword">view</span></span>.removeFromSuperview() vc.removeFromParentViewController() topViewController = nil }</code> </pre> <br><p>  Ada dua metode lagi yang kodenya tidak akan saya berikan di sini: <code>setViewControllers</code> dan <code>setBackground</code> .  Dalam metode <code>setViewControllers</code> kita cukup mengatur array pengontrol anak dalam variabel yang sesuai dari controller kita dan memanggil <code>addChild</code> untuk menampilkan salah satu dari mereka pada tampilan.  Dalam metode <code>setBackground</code> kami melakukan hal yang sama seperti di <code>addChild</code> , hanya untuk pengontrol latar belakang. </p><br><h2 id="logika-animacii-kontrollera-konteynera">  Logika Pengontrol Kontainer Animasi </h2><br><p>  Total, dasar dari kontroler induk kami adalah: </p><br><ul><li>  UIView dibagi menjadi dua jenis <br><ul><li>  Wadah </li><li>  Biasa </li></ul></li><li>  Daftar anak UIViewController </li><li>  Objek kontrol animasi dari <code>swipeAnimator</code> jenis <code>AnimatedTransitioning</code> </li><li>  Objek yang mengontrol program interaktif dari animasi <code>CustomSwipeInteractor</code> tipe <code>CustomSwipeInteractor</code> </li><li>  Delegasikan Animasi Interaktif </li><li>  Implementasi Protokol Animasi </li></ul><br><p>  Sekarang kita akan menganalisis dua poin terakhir, kemudian beralih ke implementasi <code>AnimatedTransitioning</code> dan <code>CustomSwipeInteractor</code> . </p><br><h3 id="delegat-interaktivnogo-hoda-animacii">  Delegasikan Animasi Interaktif </h3><br><p>  Delegasi hanya terdiri dari satu <code>panGestureDidStart(rightToLeftSwipe: Bool) -&gt; Bool</code> metode <code>panGestureDidStart(rightToLeftSwipe: Bool) -&gt; Bool</code> , yang menginformasikan pengontrol tentang awal gerakan dan arahnya.  Sebagai tanggapan, dia menunggu informasi tentang apakah animasi dapat dianggap dimulai. </p><br><p>  Sebagai delegasi, kami memeriksa urutan pengontrol saat ini untuk memahami apakah kami dapat memulai animasi dalam arah yang diberikan, dan jika semuanya baik-baik saja, kami memulai metode <code>transition</code> , dengan parameter: pengontrol tempat kami bergerak, pengontrol tempat kami bergerak, pengontrol tempat kami bergerak, arah gerakan, bendera interaktivitas (Jika <code>false</code> , animasi transisi yang diperbaiki waktu dipicu). </p><br><pre> <code class="hljs julia">func panGestureDidStart(rightToLeftSwipe: <span class="hljs-built_in"><span class="hljs-built_in">Bool</span></span>) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Bool</span></span> { guard <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> topViewController = topViewController, <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> fromIndex = children.index(of: topViewController) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> newIndex = rightToLeftSwipe ? <span class="hljs-number"><span class="hljs-number">1</span></span> : <span class="hljs-number"><span class="hljs-number">0</span></span> //   -    <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> newIndex &gt; -<span class="hljs-number"><span class="hljs-number">1</span></span> &amp;&amp; newIndex &lt; children.count &amp;&amp; newIndex != fromIndex { transition(from: children[fromIndex], to: children[newIndex], goingRight: rightToLeftSwipe, interactive: <span class="hljs-literal"><span class="hljs-literal">true</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span> }</code> </pre> <br><p>  Mari kita segera memeriksa isi dari metode <code>transition</code> .  Pertama-tama, kami membuat konteks animasi untuk animasi <code>CustomControllerContext</code> .  Kami juga akan menganalisis kelas ini sedikit kemudian, ini mengimplementasikan protokol <code>UIViewControllerContextTransitioning</code> .  Dalam kasus <code>UINavigationController</code> dan <code>UITabBarController</code> instance dari implementasi protokol ini secara otomatis dibuat oleh sistem dan logikanya tersembunyi dari kita, kita perlu membuat kita sendiri. </p><br><pre> <code class="hljs pgsql">let ctx = CustomControllerContext(fromViewController: <span class="hljs-keyword"><span class="hljs-keyword">from</span></span>, toViewController: <span class="hljs-keyword"><span class="hljs-keyword">to</span></span>, containerView: contentViewContainer, goingRight: goingRight) ctx.isAnimated = <span class="hljs-keyword"><span class="hljs-keyword">true</span></span> ctx.isInteractive = interactive ctx.completionBlock = { (didComplete: <span class="hljs-type"><span class="hljs-type">Bool</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> didComplete { self.removeChild(vc: <span class="hljs-keyword"><span class="hljs-keyword">from</span></span>) self.addChild(vc: <span class="hljs-keyword"><span class="hljs-keyword">to</span></span>) } };</code> </pre> <br><p>  Kemudian kita cukup memanggil animasi tetap atau interaktif.  Di masa mendatang, akan dimungkinkan untuk menggantung yang tetap pada tab tombol navigasi antara pengontrol, dalam contoh ini kita tidak akan melakukan ini. </p><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> interactive { // Animate <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> interaction swipeInteractor.startInteractiveTransition(ctx) } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { // Animate <span class="hljs-keyword"><span class="hljs-keyword">without</span></span> interaction swipeAnimator.animateTransition(<span class="hljs-keyword"><span class="hljs-keyword">using</span></span>: ctx) }</code> </pre> <br><h3 id="protokol-animacii">  Protokol Animasi </h3><br><p>  Protokol animasi <code>TransitionAnimation</code> terdiri dari 4 metode: </p><br><p>  <code>addTo</code> adalah metode yang dirancang untuk membuat struktur pandangan anak yang benar dalam wadah, sehingga tampilan sebelumnya tumpang tindih dengan yang baru sesuai dengan ide animasi. </p><br><pre> <code class="hljs objectivec"><span class="hljs-comment"><span class="hljs-comment">/// Setup the views hirearchy for animation. func addTo(containerView: UIView, fromView: UIView, toView: UIView, fromLeft: Bool)</span></span></code> </pre> <br><p>  <code>prepare</code> adalah metode yang disebut sebelum animasi untuk mempersiapkan tampilan. </p><br><pre> <code class="hljs sql">/// Setup the views position prior to the animation start. func <span class="hljs-keyword"><span class="hljs-keyword">prepare</span></span>(fromView <span class="hljs-keyword"><span class="hljs-keyword">from</span></span>: UIView?, toView <span class="hljs-keyword"><span class="hljs-keyword">to</span></span>: UIView?, fromLeft: <span class="hljs-built_in"><span class="hljs-built_in">Bool</span></span>)</code> </pre> <br><p>  <code>animation</code> - animasi itu sendiri. </p><br><pre> <code class="hljs objectivec"><span class="hljs-comment"><span class="hljs-comment">/// The animation. func animation(fromView from: UIView?, toView to: UIView?, fromLeft: Bool)</span></span></code> </pre> <br><p>  <code>finalize</code> - tindakan yang diperlukan setelah selesainya animasi. </p><br><pre> <code class="hljs objectivec"><span class="hljs-comment"><span class="hljs-comment">/// Cleanup the views position after the animation ended. func finalize(completed: Bool, fromView from: UIView?, toView to: UIView?, fromLeft: Bool)</span></span></code> </pre> <br><p>  Kami tidak akan mempertimbangkan implementasi yang digunakan, semuanya cukup transparan di sana, kami akan langsung ke tiga kelas utama, berkat animasi yang berlangsung. </p><br><h2 id="class-customcontrollercontext-nsobject-uiviewcontrollercontexttransitioning"> <code>class CustomControllerContext: NSObject, UIViewControllerContextTransitioning</code> </h2> <br><p>  Konteks animasi.  Untuk menjelaskan fungsinya, kami merujuk pada bantuan protokol <code>UIViewControllerContextTransitioning</code> : </p><br><blockquote>  Objek konteks merangkum informasi tentang pandangan dan pengendali tampilan yang terlibat dalam transisi.  Ini juga berisi perincian tentang bagaimana menjalankan transisi. </blockquote><p>  Yang paling menarik adalah larangan adaptasi protokol ini: </p><br><blockquote>  Jangan mengadopsi protokol ini di kelas Anda sendiri, Anda juga tidak harus secara langsung membuat objek yang mengadopsi protokol ini. </blockquote><p>  Tapi kami benar-benar membutuhkannya untuk menjalankan mesin animasi standar, jadi kami tetap mengadaptasinya.  Ini hampir tidak memiliki logika, hanya menyimpan keadaan.  Karena itu, saya bahkan tidak akan membawanya ke sini.  Anda dapat menontonnya di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">GitHub</a> . </p><br><p>  Ini bekerja sangat baik pada animasi yang ditetapkan waktu.  Tetapi ketika menggunakannya untuk animasi interaktif, satu masalah muncul - <code>UIPercentDrivenInteractiveTransition</code> memanggil metode tidak berdokumen pada konteksnya.  Satu-satunya solusi yang tepat dalam situasi ini adalah mengadaptasi protokol lain - <code>UIViewControllerInteractiveTransitioning</code> untuk menggunakan konteks Anda sendiri. </p><br><h2 id="class-percentdriveninteractivetransition-nsobject-uiviewcontrollerinteractivetransitioning"> <code>class PercentDrivenInteractiveTransition: NSObject, UIViewControllerInteractiveTransitioning</code> </h2> <br><p>  Ini dia - jantung dari proyek, memungkinkan animasi interaktif ada di pengontrol wadah kustom.  Mari kita bereskan. </p><br><p>  Kelas diinisialisasi dengan satu parameter dari tipe <code>UIViewControllerAnimatedTransitioning</code> , ini adalah protokol standar untuk menjiwai transisi antar pengontrol.  Dengan cara ini kita dapat menggunakan salah satu animasi yang sudah ditulis bersama dengan kelas kita. </p><br><pre> <code class="hljs objectivec">init(with animator: <span class="hljs-built_in"><span class="hljs-built_in">UIViewControllerAnimatedTransitioning</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.animator = animator }</code> </pre> <br><p>  Antarmuka publik cukup sederhana, empat metode, yang fungsinya harus jelas. </p><br><p>  Kita hanya perlu mencatat saat animasi dimulai, kita mengambil tampilan induk wadah dan mengatur kecepatan layer ke 0, jadi kita mendapatkan kemampuan untuk mengontrol kemajuan animasi secara manual. </p><br><pre> <code class="hljs pgsql">// MARK: - <span class="hljs-built_in"><span class="hljs-built_in">Public</span></span> func startInteractiveTransition(_ transitionContext: UIViewControllerContextTransitioning) { self.transitionContext = transitionContext transitionContext.containerView.superview?.layer.speed = <span class="hljs-number"><span class="hljs-number">0</span></span> animator.animateTransition(<span class="hljs-keyword"><span class="hljs-keyword">using</span></span>: transitionContext) } func updateInteractiveTransition(percentComplete: CGFloat) { setPercentComplete(percentComplete: (CGFloat(fmaxf(fminf(<span class="hljs-type"><span class="hljs-type">Float</span></span>(percentComplete), <span class="hljs-number"><span class="hljs-number">1</span></span>), <span class="hljs-number"><span class="hljs-number">0</span></span>)))) } func cancelInteractiveTransition() { transitionContext?.cancelInteractiveTransition() completeTransition() } func finishInteractiveTransition() { transitionContext?.finishInteractiveTransition() completeTransition() }</code> </pre> <br><p>  Kita sekarang beralih ke blok logika pribadi kelas kita. </p><br><p>  <code>setPercentComplete</code> menetapkan waktu offset perkembangan animasi untuk lapisan superview, menghitung nilai dari persentase penyelesaian dan durasi animasi. </p><br><pre> <code class="hljs swift"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setPercentComplete</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(percentComplete: CGFloat)</span></span></span></span> { setTimeOffset(timeOffset: <span class="hljs-type"><span class="hljs-type">TimeInterval</span></span>(percentComplete) * duration) transitionContext?.updateInteractiveTransition(percentComplete) } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setTimeOffset</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(timeOffset: TimeInterval)</span></span></span></span> { transitionContext?.containerView.superview?.layer.timeOffset = timeOffset }</code> </pre> <br><p>  <code>completeTransition</code> dipanggil ketika pengguna telah menghentikan gerakan mereka.  Di sini kita membuat instance dari kelas <code>CADisplayLink</code> , yang akan memungkinkan kita untuk menyelesaikan animasi secara indah dari titik ketika pengguna tidak lagi mengontrol progresnya.  Kami menambahkan <code>displayLink</code> kami ke <code>run loop</code> sehingga sistem memanggil pemilih kami setiap kali perlu menampilkan bingkai baru di layar perangkat. </p><br><pre> <code class="hljs swift"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">completeTransition</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { displayLink = <span class="hljs-type"><span class="hljs-type">CADisplayLink</span></span>(target: <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, selector: #selector(tickAnimation)) displayLink!.add(to: .main, forMode: .commonModes) }</code> </pre> <br><p>  Di pemilih kami, kami menghitung dan mengatur perpindahan sementara dari perkembangan animasi, seperti yang kami lakukan sebelumnya selama gerakan pengguna, atau kami menyelesaikan animasi ketika mencapai titik awal atau akhir. </p><br><pre> <code class="hljs coffeescript">@objc private func tickAnimation() { var timeOffset = self.timeOffset() let tick = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(displayLink?.duration ?? </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> * TimeInterval</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(completionSpeed)</span></span></span><span class="hljs-function"> timeOffset += </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(transitionContext?.transitionWasCancelled ?? </span></span><span class="hljs-literal"><span class="hljs-function"><span class="hljs-params"><span class="hljs-literal">false</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> ? -tick : tick; if </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(timeOffset &lt; </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0</span></span></span></span><span class="hljs-function"><span class="hljs-params"> || timeOffset &gt; duration)</span></span></span><span class="hljs-function"> { transitionFinished</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> } else { setTimeOffset</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(timeOffset: timeOffset)</span></span></span><span class="hljs-function"> } } private func timeOffset</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> -&gt;</span></span> TimeInterval { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> transitionContext?.containerView.superview?.layer.timeOffset ?? <span class="hljs-number"><span class="hljs-number">0</span></span> }</code> </pre> <br><p>  Menyelesaikan animasi, kita <code>displayLink</code> kita, kembalikan kecepatan lapisan, dan jika animasi belum dibatalkan, yaitu, itu telah mencapai bingkai akhir, kita menghitung waktu dari mana animasi lapisan harus dimulai.  Anda dapat mempelajari lebih lanjut tentang ini di Panduan Pemrograman Core Animation, atau dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">jawaban ini</a> untuk stackoverflow. </p><br><pre> <code class="hljs swift"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">transitionFinished</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { displayLink?.invalidate() <span class="hljs-keyword"><span class="hljs-keyword">guard</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> layer = transitionContext?.containerView.superview?.layer <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> } layer.speed = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> wasNotCanceled = !(transitionContext?.transitionWasCancelled ?? <span class="hljs-literal"><span class="hljs-literal">false</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (wasNotCanceled) { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> pausedTime = layer.timeOffset layer.timeOffset = <span class="hljs-number"><span class="hljs-number">0.0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> timeSincePause = layer.convertTime(<span class="hljs-type"><span class="hljs-type">CACurrentMediaTime</span></span>(), from: <span class="hljs-literal"><span class="hljs-literal">nil</span></span>) - pausedTime layer.beginTime = timeSincePause } animator.animationEnded?(wasNotCanceled) }</code> </pre> <br><h2 id="class-animatedtransitioning-nsobject-uiviewcontrolleranimatedtransitioning"> <code>class AnimatedTransitioning: NSObject, UIViewControllerAnimatedTransitioning</code> </h2> <br><p>  Kelas terakhir yang belum kita periksa adalah implementasi protokol <code>UIViewControllerAnimatedTransitioning</code> , di mana kita mengontrol urutan eksekusi metode protokol dari animasi kita, <code>addTo</code> , <code>prepare</code> , <code>animation</code> , <code>finalize</code> .  Semuanya di sini cukup sederhana, perlu dicatat hanya penggunaan <code>UIViewPropertyAnimator</code> untuk melakukan animasi, bukan <code>UIView.animate(withDuration:animations:)</code> lebih khas <code>UIView.animate(withDuration:animations:)</code> .  Hal ini dilakukan agar memungkinkan untuk lebih mengontrol kemajuan animasi, dan jika dibatalkan, kembalikan ke posisi <code>finishAnimation(at: .start)</code> dengan memanggil <code>finishAnimation(at: .start)</code> , yang menghindari kedip bingkai animasi terakhir yang tidak perlu pada layar. </p><br><h2 id="epilog">  Epilog </h2><br><p>  Kami telah membuat demo kerja antarmuka yang mirip dengan Snapchat.  Dalam versi saya, saya mengkonfigurasi konstanta sehingga ada bidang di kanan dan kiri kartu, selain itu, saya meninggalkan kamera pada tampilan latar belakang untuk membuat efek di belakang kartu.  Ini dilakukan semata-mata untuk menunjukkan kemampuan pendekatan ini, bagaimana itu akan mempengaruhi kinerja perangkat dan saya tidak memeriksa daya baterainya. </p><br><p>   —        ,    -  ,          .      ,    -    . </p><br><p>      GitHub  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="></a> . </p><br><p>   ,   ,  ,  ! </p><br><p><img src="https://habrastorage.org/webt/mh/se/2z/mhse2z7hfck6aicbobu-vwyi9bw.gif"></p><br><h2 id="istochniki-informacii">   </h2><br><p>        : </p><br><ol><li><p>  Custom Container View Controller Transitions,  Joachim Bondo. </p><br><p>        Objective C.          Swift. </p><br><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="></a> </p><br></li><li><p>  Interactive Custom Container View Controller Transitions,  Alek Åström </p><br><p>               ,   Objective C,           Swift. </p><br><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="></a> </p><br></li><li><p> <code>SwipeableTabBarController</code> </p> <br><p> ,            <code>UITabBarController</code> .      . </p><br><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="></a> </p><br></li></ol></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id415795/">https://habr.com/ru/post/id415795/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id415783/index.html">Cakram bintang mengungkapkan kepada kita rahasia kemunculan planet-planet</a></li>
<li><a href="../id415785/index.html">SpaceX mengirimkan robot kecerdasan buatan ke ISS</a></li>
<li><a href="../id415789/index.html">Algoritma Paten untuk Program Komputer</a></li>
<li><a href="../id415791/index.html">Optimalisasi kontrak pintar. Bagaimana Jenis Soliditas Mempengaruhi Biaya Transaksi</a></li>
<li><a href="../id415793/index.html">Panduan pemesanan domain lengkap</a></li>
<li><a href="../id415797/index.html">Ekspresi reguler + pemrograman logis. Apa hasilnya?</a></li>
<li><a href="../id415801/index.html">Google: AI "telepon" kami tidak cukup baik untuk berbahaya</a></li>
<li><a href="../id415805/index.html">Modifikasi modul penghalang GSM Doorhan untuk kontrol Internet</a></li>
<li><a href="../id415809/index.html">Cara menggunakan kedelai, requireejs, backbone js dalam plugin untuk Atlassian Jira</a></li>
<li><a href="../id415811/index.html">AI, tentu saja praktis. Tinjauan jaringan saraf untuk klasifikasi gambar</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>