<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üåà ‚úä üè≥Ô∏è‚Äçüåà GPU de la console Nintendo DS et fonctionnalit√©s int√©ressantes üîä üòô üë©üèø‚Äçü§ù‚Äçüë©üèΩ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Je voudrais vous parler du fonctionnement de la console GPU Nintendo DS, de ses diff√©rences avec les GPU modernes, et √©galement exprimer mon opinion s...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>GPU de la console Nintendo DS et fonctionnalit√©s int√©ressantes</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/429160/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/uc/yy/rg/ucyyrgszova3-3kx-wpaxjbonwk.jpeg"></div><br>  Je voudrais vous parler du fonctionnement de la console GPU Nintendo DS, de ses diff√©rences avec les GPU modernes, et √©galement exprimer mon opinion sur pourquoi l'utilisation de Vulkan au lieu d'OpenGL dans les √©mulateurs n'apportera aucun avantage. <br><br>  Je ne connais pas vraiment Vulkan, mais d'apr√®s ce que j'ai lu, il est clair pour moi que Vulkan diff√®re d'OpenGL en ce qu'il fonctionne √† un niveau inf√©rieur, permettant aux programmeurs de g√©rer la m√©moire du GPU et des choses similaires.  Cela peut √™tre utile pour √©muler des consoles plus modernes qui utilisent des API graphiques propri√©taires qui fournissent des niveaux de contr√¥le non disponibles dans OpenGL. <br><a name="habracut"></a><br>  Par exemple, le rendu mat√©riel blargSNES - l'une de ses astuces est que lors de certaines op√©rations avec des tampons de couleurs diff√©rentes, un tampon de profondeur / gabarit est utilis√©.  En OpenGL, ce n'est pas possible. <br><br>  De plus, il reste moins de d√©chets entre l'application et le GPU, ce qui signifie que s'il est correctement impl√©ment√©, les performances seront plus √©lev√©es.  Alors que les pilotes OpenGL regorgent d'optimisations pour les cas d'utilisation standard et m√™me pour des jeux sp√©cifiques, dans Vulkan, l'application elle-m√™me doit d'abord √™tre bien √©crite. <br><br>  Autrement dit, "une grande responsabilit√© s'accompagne d'une grande force". <br><br>  Je ne suis pas un sp√©cialiste de l'API 3D, alors revenons √† cela.  Ce que je sais bien: la console GPU DS. <br><br>  Plusieurs articles ont d√©j√† √©t√© √©crits sur ses parties individuelles ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">sur ses quads sophistiqu√©s</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">sur les b√™tises avec fen√™tre d'affichage</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">sur les fonctionnalit√©s amusantes du rasterizer</a> et <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">sur la mise en ≈ìuvre √©tonnante de l'anti-aliasing</a> ), mais dans cet article, nous consid√©rerons l'appareil dans son ensemble, mais avec tous les d√©tails juteux.  Du moins, c'est tout ce que nous savons. <br><br>  Le GPU lui-m√™me est un mat√©riel assez ancien et obsol√®te.  Elle est limit√©e √† 2048 polygones et / ou 6144 sommets par image.  La r√©solution est de 256x192.  M√™me si vous quadruple cela, les performances ne seront pas un probl√®me.  Dans des conditions optimales, DS peut produire jusqu'√† 122880 polygones par seconde, ce qui est ridicule par rapport aux normes des GPU modernes. <br><br>  Passons maintenant aux d√©tails du GPU.  En apparence, il semble assez standard, mais au fond de son travail est tr√®s diff√©rent du travail des GPU modernes, ce qui rend l'√©mulation de certaines fonctions plus compliqu√©e. <br><br>  Le GPU est divis√© en deux parties: un moteur de g√©om√©trie et un moteur de rendu.  Le moteur de g√©om√©trie traite les sommets r√©sultants, construit des polygones et les transforme pour que vous puissiez les transmettre au moteur de rendu qui (vous l'avez devin√©) dessine tout sur l'√©cran. <br><br><h2>  Moteur de g√©om√©trie </h2><br>  Convoyeur g√©om√©trique assez standard. <br><br>  Il convient de mentionner que toute l'arithm√©tique est effectu√©e en nombres entiers √† virgule fixe, car DS ne prend pas en charge les nombres √† virgule flottante. <br><br>  Le moteur de g√©om√©trie est enti√®rement √©mul√© par programmation (GPU3D.cpp), c'est-√†-dire qu'il ne s'applique pas beaucoup √† ce que nous utilisons pour le rendu des graphiques, mais je vous en dirai quand m√™me plus √† ce sujet. <br><br>  1. Transformation et √©clairage.  Les sommets et les coordonn√©es de texture r√©sultants sont convertis √† l'aide d'ensembles de matrices 4x4.  En plus des couleurs des sommets, l'√©clairage est appliqu√©.  Tout est assez standard ici, le seul non standard est le fonctionnement des coordonn√©es de texture (1.0 = un texel DS).  Il convient √©galement de mentionner l'ensemble du syst√®me de piles matricielles, qui sont √† un degr√© ou √† un autre l'impl√©mentation mat√©rielle de glPushMatrix (). <br><br>  2. Configuration des polygones.  Les sommets convertis sont assembl√©s en polygones, qui peuvent √™tre des triangles, des quadrangles (quads), des bandes de triangles ou des bandes de quadrangles.  Les quads sont trait√©s en mode natif et ne se convertissent pas en triangles, ce qui est assez probl√©matique car les GPU modernes ne prennent en charge que les triangles.  Cependant, il semble que quelqu'un ait <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">trouv√© une solution</a> que je dois tester. <br><br>  3. Laissez tomber.  Les polygones peuvent √™tre √©limin√©s en fonction de l'orientation sur l'√©cran et du mode d'abattage s√©lectionn√©.  √âgalement r√©gime assez standard.  Cependant, je dois comprendre comment cela fonctionne pour les quads. <br><br>  4. Troncature.  Les polygones au-del√† du champ de visibilit√© sont √©limin√©s.  Les polygones s'√©tendant partiellement au-del√† de cette r√©gion sont tronqu√©s.  Cette √©tape ne cr√©e pas de nouveaux polygones, mais ajoute des sommets aux polygones existants.  En fait, chacun des 6 plans de troncature peut ajouter un sommet au polygone, ce qui signifie que nous pouvons obtenir jusqu'√† 10 sommets.  Dans la section sur le moteur de rendu, je vais vous expliquer comment nous avons trait√© cela. <br><br>  5. Convertissez en fen√™tre.  Les coordonn√©es X / Y sont converties en coordonn√©es d'√©cran.  Les coordonn√©es Z sont converties pour tenir dans un intervalle de tampon de profondeur de 24 bits. <br><br>  Ce qui est int√©ressant, c'est la fa√ßon dont les coordonn√©es W sont trait√©es: elles sont ¬´normalis√©es¬ª pour tenir dans un intervalle de 16 bits.  Pour cela, chaque coordonn√©e W du polygone est prise, et si elle est sup√©rieure √† 0xFFFF, elle est alors d√©cal√©e vers la droite de 4 positions pour tenir sur 16 bits.  Inversement, si la coordonn√©e est inf√©rieure √† 0x1000, elle se d√©place vers la gauche jusqu'√† ce qu'elle tombe dans l'intervalle.  Je suppose que cela est n√©cessaire pour obtenir de bons intervalles, ce qui signifie une plus grande pr√©cision lors de l'interpolation. <br><br>  6. Tri.  Les polygones sont tri√©s de sorte que les polygones translucides soient dessin√©s en premier.  Ensuite, ils sont tri√©s par leurs coordonn√©es Y (oui), ce qui est n√©cessaire pour les polygones opaques et √©ventuellement translucides. <br><br>  De plus, c'est la raison de la restriction de 2048 polygones: pour le tri, ils doivent √™tre stock√©s quelque part.  Deux banques de m√©moire interne sont affect√©es au stockage des polygones et des sommets.  Il existe m√™me un registre indiquant le nombre de polygones et de sommets stock√©s. <br><br><h2>  Moteur de rendu </h2><br>  Et ici, le plaisir commence! <br><br>  Une fois tous les polygones configur√©s et tri√©s, le moteur de rendu commence √† fonctionner. <br><br>  La premi√®re chose amusante est de savoir comment il remplit les polygones.  Ceci est compl√®tement diff√©rent du travail des GPU modernes qui effectuent le remplissage des tuiles et utilisent des algorithmes optimis√©s pour les triangles.  Je ne sais pas comment ils fonctionnent tous, mais j'ai vu comment cela se fait dans le GPU de la console 3DS, et tout est bas√© sur des tuiles l√†-bas. <br><br>  Quoi qu'il en soit, sur DS, le rendu se fait en cha√Ænes raster.  Les d√©veloppeurs ont d√ª le faire pour que le rendu puisse √™tre effectu√© en parall√®le avec les moteurs de tuiles bidimensionnelles √† l'ancienne, qui effectuent le dessin sur des lignes raster.  Il y a un petit tampon avec 48 lignes raster qui peuvent √™tre utilis√©es pour ajuster certaines lignes raster. <br><br>  Un rasterizer est un rendu de polygones convexes bas√© sur des cha√Ænes raster.  Il peut g√©rer un nombre arbitraire de sommets.  Le rendu peut √™tre incorrect si vous lui passez des polygones qui ne sont pas convexes ou qui ont des bords qui se croisent, par exemple: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ul/ts/vd/ultsvdezpi2riupyjponrg--exq.png"></div><br>  <i>Le polygone est un papillon.</i>  <i>Tout est correct et magnifique.</i> <br><br>  Et si on le retournait? <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/t0/z-/48/t0z-48rfmcp8ndjpebeydxaof08.png"></div><br>  <i>Ouch.</i> <br><br>  Quelle est l'erreur ici?  Dessinons le contour du polygone d'origine pour comprendre: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/nl/mj/tx/nlmjtxlv9qeennvaulabodzsnu0.png"></div><br>  Un rendu ne peut remplir qu'un seul espace par ligne raster.  Il d√©finit les bords gauche et droit en commen√ßant par les pics les plus √©lev√©s et suit ces bords jusqu'√† ce qu'il rencontre de nouveaux pics. <br><br>  Dans l'image ci-dessus, il part du sommet sup√©rieur, c'est-√†-dire en haut √† gauche, et continue de se remplir jusqu'√† ce qu'il atteigne la fin du bord gauche (sommet inf√©rieur gauche).  Il ne sait pas que les bords se croisent. <br><br>  √Ä ce stade, il recherche le sommet suivant sur son bord gauche.  Il est int√©ressant de noter qu'il sait qu'il n'a pas besoin de prendre des sommets sup√©rieurs √† celui actuel, et sait √©galement que les bords gauche et droit se sont interchang√©s.  Par cons√©quent, il continue de se remplir jusqu'√† la fin de la d√©charge. <br><br>  J'ajouterais quelques exemples suppl√©mentaires de polygones non convexes, mais nous nous √©loignerons trop du sujet. <br><br>  Comprenons mieux comment l'ombrage et la texturation de Gouraud fonctionnent avec un nombre arbitraire de sommets.  Il existe des algorithmes barycentriques utilis√©s pour interpoler les donn√©es le long d'un triangle, mais ... dans notre cas, ils ne conviennent pas. <br><br>  Le rendu DS ici a √©galement sa propre impl√©mentation.  Quelques images plus int√©ressantes. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/p0/-l/qm/p0-lqmqqcinmjrvlzjiw_fsvh5w.png"></div><br>  Les sommets du polygone sont les points 1, 2, 3 et 4. Les nombres ne correspondent pas √† l'ordre de d√©placement r√©el, mais vous en comprenez la signification. <br><br>  Dans la ligne raster actuelle, le rendu d√©finit les sommets entourant directement les bords (comme mentionn√© ci-dessus, il part des sommets les plus √©lev√©s, puis passe par les bords jusqu'√† ce qu'ils soient complets).  Dans notre cas, ce sont les sommets 1 et 2 pour le bord gauche, 3 et 4 pour le bord droit. <br><br>  Les pentes des ar√™tes sont utilis√©es pour d√©terminer les limites de l'√©cart, c'est-√†-dire les points 5 et 6. √Ä ces points, les attributs des sommets sont interpol√©s en fonction des positions verticales des ar√™tes (ou des positions horizontales pour les ar√™tes, dont les pentes sont principalement le long de l'axe X). <br><br>  Ensuite, pour chaque pixel de l'espace (par exemple, pour le point 7), les attributs bas√©s sur la position X √† l'int√©rieur de l'espace sont interpol√©s √† partir des attributs pr√©c√©demment calcul√©s aux points 5 et 6. <br><br>  Ici, tous les coefficients utilis√©s sont √©gaux √† 50% pour simplifier le travail, mais le sens est clair. <br><br>  Je n'entrerai pas dans les d√©tails de l'interpolation d'attributs, bien qu'il soit √©galement int√©ressant d'√©crire √† ce sujet.  En fait, c'est une interpolation correcte du point de vue de la perspective, mais elle a des simplifications et des caract√©ristiques int√©ressantes. <br><br>  Parlons maintenant de la fa√ßon dont DS remplit les polygones. <br><br>  Quelles r√®gles de remplissage utilise-t-il?  Il y a aussi beaucoup de choses int√©ressantes ici! <br><br>  Premi√®rement, il existe diff√©rentes r√®gles de remplissage pour les polygones opaques et translucides.  Mais surtout, ces r√®gles s'appliquent <i>pixel par pixel</i> .  Les polygones translucides peuvent avoir des pixels opaques et ils suivront les m√™mes r√®gles que les polygones opaques.  Vous pouvez deviner que pour √©muler de telles astuces sur des GPU modernes, plusieurs passes de rendu sont n√©cessaires. <br><br>  De plus, diff√©rents attributs de polygone peuvent influencer le rendu de diverses mani√®res int√©ressantes.  En plus des tampons de couleur et de profondeur assez standard, le moteur de rendu dispose √©galement d' <i>un tampon d'attributs</i> qui suit toutes sortes de choses int√©ressantes.  √Ä savoir: l'ID du polygone (s√©par√©ment pour les polygones opaques et translucides), la translucidit√© du pixel, la n√©cessit√© d'appliquer du brouillard, si ce polygone est dirig√© vers ou depuis la cam√©ra (oui, cela aussi), et si le pixel est sur le bord du polygone.  Et peut-√™tre autre chose. <br><br>  La t√¢che d'√©muler un tel syst√®me ne sera pas anodine.  Un GPU moderne ordinaire a un tampon de gabarit limit√© √† 8 bits, ce qui est loin d'√™tre suffisant pour tout ce qui peut stocker un tampon d'attribut.  Nous devons trouver une solution de contournement d√©licate. <br><br>  Voyons cela: <br><br>  * Mise √† jour du tampon de profondeur: requise pour les pixels opaques, facultative pour les pixels translucides. <br><br>  * ID de polygone: des ID de 6 bits sont attribu√©s aux polygones, qui peuvent √™tre utilis√©s √† plusieurs fins.  Les ID de polygone opaques sont utilis√©s pour marquer les bords.  L'ID des polygones translucides peut √™tre utilis√© pour contr√¥ler o√π ils seront dessin√©s: un pixel translucide ne sera pas dessin√© si l'ID du polygone correspond √† l'ID du polygone translucide d√©j√† dans le tampon d'attributs.  En outre, les deux ID de polygone sont utilis√©s de la m√™me mani√®re pour contr√¥ler le rendu des ombres.  Par exemple, vous pouvez cr√©er une ombre qui couvre le sol, mais pas le personnage. <br><br>  (Remarque: les ombres ne sont qu'une impl√©mentation du tampon de gabarit, il n'y a rien de terrible ici.) <br><br>  Il convient de noter que lors du rendu des pixels translucides, l'ID existant du polygone opaque est enregistr√©, ainsi que les drapeaux de bord du dernier polygone opaque. <br><br>  * indicateur de brouillard: d√©termine s'il faut appliquer une passe de brouillard pour ce pixel.  Le processus de mise √† jour d√©pend de l'opacit√© ou de la translucidit√© du pixel entrant. <br><br>  * drapeau de premi√®re ligne: ici il a des probl√®mes.  Jetez un ≈ìil √† la capture d'√©cran: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/hb/8m/pb/hb8mpbdxkcher7n0xmaocay2j_4.png"></div><br>  Sands of Destruction, les √©crans de ce jeu sont un ensemble d'astuces.  Ils modifient non seulement leurs coordonn√©es Y pour affecter le tri Y.  L'√©cran montr√© dans cette capture d'√©cran est probablement le pire. <br><br>  Il utilise le cas limite du test de profondeur: la fonction de comparaison "moins que" <b>prend des valeurs √©gales</b> si le jeu <i>dessine un polygone en regardant la cam√©ra au-dessus des pixels opaques du polygone dirig√© loin de la cam√©ra</i> .  Oui, exactement.  Et les valeurs Z de tous les polygones sont nulles.  Si vous n'√©mulez pas cette fonctionnalit√©, certains √©l√©ments seront manquants √† l'√©cran. <br><br>  Je pense que cela a √©t√© fait pour que la face avant de l'objet soit toujours visible sur la face arri√®re, m√™me lorsqu'ils sont si plats que les valeurs Z sont les m√™mes.  Avec tous ces hacks et astuces, le rendu DS est similaire √† la version mat√©rielle des rendus de l'√®re DOS. <br><br>  Quoi qu'il en soit, il √©tait difficile d'√©muler ce comportement via le GPU.  Mais il existe d'autres cas limites similaires de tests de profondeur, qui doivent √©galement √™tre test√©s et document√©s. <br><br>  * drapeaux de c√¥tes: le moteur de rendu suit l'emplacement des bords des polygones.  Ils sont utilis√©s dans les derni√®res passes, notamment lors du marquage des bords et de l'anticr√©nelage.  Il existe √©galement des r√®gles sp√©ciales pour le remplissage de polygones opaques avec l'anticr√©nelage d√©sactiv√©.  Le diagramme ci-dessous illustre ces r√®gles: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ey/pu/hf/eypuhfe9rghuhobfo1r9njkt4wy.png"></div><br>  Remarque: les wireframes sont rendus en remplissant uniquement les bords!  Mouvement tr√®s intelligent. <br><br>  Une autre note amusante sur la mise en m√©moire tampon de la profondeur: <br><br>  Il existe deux modes de tampon de profondeur possibles sur DS: le tampon Z et le tampon W.  Cela semble √™tre assez standard, mais seulement si vous n'entrez pas dans les d√©tails. <br><br>  * La mise en m√©moire tampon Z utilise les coordonn√©es Z converties pour tenir dans un intervalle de tampon de profondeur de 24 bits.  Les coordonn√©es Z sont interpol√©es lin√©airement sur des polygones (avec quelques bizarreries, mais elles ne sont pas particuli√®rement importantes).  Il n'y a rien de non standard ici non plus. <br><br>  * Dans la mise en m√©moire tampon W, les coordonn√©es W sont utilis√©es ¬´telles quelles¬ª.  Les GPU modernes utilisent g√©n√©ralement 1 / W, mais DS n'utilise que l'arithm√©tique √† virgule fixe, donc l'utilisation de valeurs r√©ciproques n'est pas tr√®s pratique.  Quoi qu'il en soit, dans ce mode, les coordonn√©es W sont interpol√©es avec correction de perspective. <br><br>  Voici √† quoi ressemble le rendu final: <br><br>  * Marquage des bords: les pixels pour lesquels des drapeaux de bords sont d√©finis se voient attribuer une couleur tir√©e du tableau et d√©termin√©e en fonction de l'ID d'un polygone opaque. <br><br>  Ce seront des bords color√©s de polygones.  Il convient de noter que si un polygone translucide est dessin√© au-dessus d'un polygone opaque, les bords du polygone seront toujours color√©s. <br><br>  Un effet secondaire du principe de troncature: les bordures auxquelles les polygones se croisent avec les bordures de l'√©cran seront √©galement color√©es.  Vous pouvez par exemple le remarquer dans les captures d'√©cran de Picross 3D. <br><br>  * brouillard: il est appliqu√© √† chaque pixel en fonction des valeurs de profondeur utilis√©es pour indexer la table de densit√© de brouillard.  Comme vous pouvez le deviner, cela s'applique aux pixels dont les indicateurs de brouillard sont d√©finis dans le tampon d'attributs. <br><br>  * anticr√©nelage (lissage): il est appliqu√© sur les bords des polygones (opaques).  En fonction des pentes des bords lors du rendu des polygones, les valeurs de couverture en pixels sont calcul√©es.  Dans la derni√®re passe, ces pixels sont m√©lang√©s avec les pixels en dessous d'eux en utilisant le m√©canisme d√©licat que j'ai d√©crit dans un post pr√©c√©dent. <br><br>  L'anticr√©nelage ne doit pas (et ne peut pas) √™tre √©mul√© de cette mani√®re sur le GPU, donc ce n'est pas important ici. <br><br>  Sauf que si le marquage des bords et l'anticr√©nelage doivent √™tre appliqu√©s aux m√™mes pixels, ils n'obtiennent que la taille du bord, mais avec une opacit√© de 50%. <br><br>  Il me semble avoir d√©crit le processus de rendu plus ou moins bien.  Nous ne nous sommes pas plong√©s dans le m√©lange des textures (combinant les couleurs des sommets et des textures), mais il peut √™tre √©mul√© dans un fragment shader.  La m√™me chose s'applique au marquage des bords et au brouillard, √† condition que nous trouvions un moyen de contourner tout ce syst√®me avec un tampon d'attributs. <br><br>  Mais en g√©n√©ral, je voulais transmettre ce qui suit: OpenGL ou Vulkan (ainsi que Direct3D, ou Glide, ou toute autre chose) n'aidera pas ici.  Nos GPU modernes ont plus que suffisamment de puissance pour fonctionner avec des polygones bruts.  Le probl√®me r√©side dans les d√©tails et les fonctionnalit√©s de la pixellisation.  Et il ne s'agit m√™me pas de l'id√©alit√© des pixels, par exemple, regardez simplement le suivi des probl√®mes de l'√©mulateur DeSmuME pour comprendre quels probl√®mes les d√©veloppeurs rencontrent lors du rendu via OpenGL.  Nous devons √©galement faire face √† ces m√™mes probl√®mes d'une mani√®re ou d'une autre. <br><br>  Je note √©galement que l'utilisation d'OpenGL nous permettra de porter l'√©mulateur, par exemple, sur Switch (car un utilisateur Github nomm√© Hydr8gon a commenc√© √† cr√©er un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">port pour notre √©mulateur sur Switch</a> ). <br><br>  Alors ... souhaite-moi bonne chance. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr429160/">https://habr.com/ru/post/fr429160/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr429150/index.html">Gestion de vos modules pour CMS √† l'aide de composer</a></li>
<li><a href="../fr429152/index.html">Composant de navigation Android. Des choses simples √† faire soi-m√™me</a></li>
<li><a href="../fr429154/index.html">Facturation secondaire, place de march√© et bacs √† sable pour le Big Data: que peuvent faire les environnements de test dans le cloud?</a></li>
<li><a href="../fr429156/index.html">Toute la v√©rit√© sur RTOS. Article # 19. S√©maphores: introduction et services de base</a></li>
<li><a href="../fr429158/index.html">Le syndrome de l'imposteur affecte autant les hommes que les femmes ... et d'autres r√©sultats de 10 000 entretiens techniques</a></li>
<li><a href="../fr429162/index.html">¬´Pour apporter des changements, comprendre pourquoi les gens y r√©sistent¬ª: Jim Holmes sur le test de la culture</a></li>
<li><a href="../fr429166/index.html">Multicristal: de l'histoire √† la sp√©culation sur l'avenir</a></li>
<li><a href="../fr429168/index.html">√Ä travers le feu et l'eau: l'histoire de la litt√©rature scientifique populaire russe</a></li>
<li><a href="../fr429172/index.html">1C sur Proxmox. Remarques g√©n√©rales</a></li>
<li><a href="../fr429174/index.html">BlueStacks 4: test sur du mat√©riel faible + commentaires des d√©veloppeurs</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>