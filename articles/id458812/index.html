<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🧛 🥛 👇🏿 JVM TI: cara membuat plugin untuk mesin virtual 🤲 🤚🏼 👩🏿‍🤝‍👩🏽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Apakah Anda ingin menambahkan beberapa fitur yang bermanfaat ke JVM? Secara teoritis, setiap pengembang dapat berkontribusi pada OpenJDK, namun dalam ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>JVM TI: cara membuat plugin untuk mesin virtual</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/odnoklassniki/blog/458812/"><img src="https://habrastorage.org/webt/dk/iw/hm/dkiwhmwayxse8--tbyxqszp0xeg.jpeg"><br><br>  Apakah Anda ingin menambahkan beberapa fitur yang bermanfaat ke JVM?  Secara teoritis, setiap pengembang dapat berkontribusi pada OpenJDK, namun dalam praktiknya, setiap perubahan non-sepele untuk HotSpot tidak diterima dari samping, dan bahkan dengan siklus rilis yang diperpendek saat ini, mungkin diperlukan bertahun-tahun sebelum pengguna JDK melihat fitur Anda. <br><br>  Namun demikian, dalam beberapa kasus dimungkinkan untuk memperluas fungsionalitas mesin virtual tanpa menyentuh kodenya.  Antarmuka Alat JVM, API standar untuk berinteraksi dengan JVM, membantu. <br><br>  Dalam artikel ini saya akan menunjukkan dengan contoh nyata apa yang bisa dilakukan dengan itu, memberi tahu apa yang telah berubah di Jawa 9 dan 11, dan jujur ​​memperingatkan tentang kesulitan (spoiler: saya harus berurusan dengan C ++). <br><br>  Saya juga berbicara tentang materi ini di JPoint.  Jika Anda lebih suka video, Anda dapat menonton laporan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">video</a> . <br><a name="habracut"></a><br><h2>  Entri </h2><br>  Jejaring sosial Odnoklassniki, tempat saya bekerja sebagai insinyur terkemuka, hampir seluruhnya ditulis di Jawa.  Tetapi hari ini saya akan memberi tahu Anda tentang bagian lain, yang tidak sepenuhnya di Jawa. <br><br>  Seperti yang Anda ketahui, masalah paling populer dengan pengembang Java adalah NullPointerException.  Suatu ketika, saat bertugas di portal, saya juga menemukan NPE dalam produksi.  Kesalahan disertai dengan sesuatu seperti jejak tumpukan ini: <br><br><img src="https://habrastorage.org/webt/j6/lb/4t/j6lb4tmh3wmmti8tebobo7znwsu.jpeg"><br><br>  Tentu saja, pada stack stack, Anda dapat melacak tempat di mana pengecualian terjadi hingga baris tertentu dalam kode.  Hanya dalam kasus ini tidak membuat saya merasa lebih baik, karena di sini NPE dapat bertemu banyak di mana: <br><br><img src="https://habrastorage.org/webt/xt/kt/pq/xtktpq4cozo4xvjvllvgtk9cibe.jpeg"><br><br>  Akan lebih bagus jika JVM menyarankan persis di mana kesalahan ini, misalnya, seperti ini: <br> <code>java.lang.NullPointerException: Called 'getUsers()' method on null object</code> <br> <br>  Tapi, sayangnya, NPE sekarang tidak mengandung hal semacam itu.  Meskipun mereka telah meminta ini sejak lama, setidaknya dengan Java 1.4: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">bug</a> ini telah berusia 16 tahun.  Secara berkala, semakin banyak bug dibuka pada topik ini, tetapi bug itu selalu ditutup sebagai "Tidak akan Perbaiki": <br><br><img src="https://habrastorage.org/webt/5l/tc/xg/5ltcxgloqnkiiudcadczatl6_ne.jpeg"><br><br>  Ini tidak terjadi di mana-mana.  Volker Simonis dari SAP <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">mengatakan</a> bagaimana mereka telah mengimplementasikan fitur ini di SAP JVM sejak lama dan membantunya lebih dari sekali.  Karyawan SAP lainnya sekali lagi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">mengirimkan</a> bug di OpenJDK dan mengajukan diri untuk menerapkan mekanisme yang mirip dengan apa yang ada di SAP JVM.  Dan, lihatlah, kali ini bug tidak ditutup - ada kemungkinan fitur ini akan memasuki JDK 14. <br><br>  Tetapi kapan JDK 14 akan dirilis, dan kapan kita akan beralih ke itu?  Apa yang harus dilakukan jika Anda ingin menyelidiki masalah di sini dan sekarang? <br><br>  Anda tentu saja dapat mempertahankan garpu OpenJDK Anda.  Fitur pelaporan NPE itu sendiri tidak begitu rumit, kami bisa menerapkannya dengan sangat baik.  Tetapi pada saat yang sama, akan ada semua masalah untuk mendukung majelis Anda sendiri.  Akan sangat bagus untuk mengimplementasikan fitur sekali, dan kemudian cukup menghubungkannya ke versi JVM sebagai plugin.  Dan ini sangat mungkin!  JVM memiliki API khusus (awalnya dikembangkan untuk semua jenis debugger dan profiler): JVM Tool Interface. <br><br>  Yang terpenting, API ini standar.  Dia memiliki <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">spesifikasi yang</a> ketat, dan ketika mengimplementasikan fitur sesuai dengan itu, Anda dapat yakin bahwa itu akan berfungsi dalam versi baru JVM. <br><br>  Untuk menggunakan antarmuka ini, Anda perlu menulis program kecil (atau besar, tergantung pada apa tugas Anda).  Asli: biasanya ditulis dalam C atau C ++.  <code>jdk/include/jvmti.h</code> JDK standar memiliki file header <code>jdk/include/jvmti.h</code> yang ingin Anda sertakan. <br><br>  Program dikompilasi ke dalam perpustakaan dinamis, dan dihubungkan oleh parameter <code>-agentpath</code> selama dimulainya JVM.  Penting untuk tidak membingungkannya dengan parameter lain yang serupa: <code>-javaagent</code> .  Bahkan, agen Java adalah kasus khusus agen JVM TI.  Lebih lanjut dalam teks di bawah kata "agen" yang dimaksud justru agen asli. <br><br><h2>  Mulai dari mana </h2><br>  Mari kita lihat dalam praktiknya bagaimana menulis agen TI JVM yang paling sederhana, semacam "halo dunia". <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;jvmti.h&gt; #include &lt;stdio.h&gt; JNIEXPORT jint JNICALL Agent_OnLoad(JavaVM* vm, char* options, void* reserved) { jvmtiEnv* jvmti; vm-&gt;GetEnv((void**) &amp;jvmti, JVMTI_VERSION_1_0); char* vm_name = NULL; jvmti-&gt;GetSystemProperty("java.vm.name", &amp;vm_name); printf("Agent loaded. JVM name = %s\n", vm_name); fflush(stdout); return 0; }</span></span></span></span></code> </pre><br>  Baris pertama saya sertakan file header yang sama.  Berikutnya adalah fungsi utama yang perlu diimplementasikan dalam agen: <code>Agent_OnLoad()</code> .  Mesin virtual itu sendiri menyebutnya ketika agen melakukan boot, melewati sebuah pointer ke objek <code>JavaVM*</code> . <br><br>  Dengan menggunakannya, Anda bisa mendapatkan pointer ke lingkungan JVM TI: <code>jvmtiEnv*</code> .  Dan melaluinya, pada gilirannya, sudah memanggil fungsi-JVM TI.  Misalnya, menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">GetSystemProperty,</a> baca nilai properti sistem. <br><br>  Jika sekarang saya menjalankan "hello world" ini, meneruskan file dll yang dikompilasi ke <code>-agentpath</code> , baris yang dicetak oleh agen kami akan muncul di konsol sebelum program Java mulai berjalan: <br><br><img src="https://habrastorage.org/webt/rl/cq/eu/rlcqeul7gpb8mahabl0ehgckro8.png"><br><br><h2>  Pengayaan NPE </h2><br>  Karena hello world bukan contoh yang paling menarik, mari kembali ke pengecualian kami.  Kode agen lengkap yang melengkapi laporan NPE ada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">di GitHub</a> . <br><br>  Beginilah <code>Agent_OnLoad()</code> jika saya ingin meminta mesin virtual untuk memberi tahu kami tentang semua pengecualian: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">JNIEXPORT jint JNICALL </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Agent_OnLoad</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(JavaVM* vm, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params">* options, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">* reserved)</span></span></span><span class="hljs-function"> </span></span>{ jvmtiEnv* jvmti; vm-&gt;GetEnv((<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>**) &amp;jvmti, JVMTI_VERSION_1_0); jvmtiCapabilities capabilities = {<span class="hljs-number"><span class="hljs-number">0</span></span>}; capabilities.can_generate_exception_events = <span class="hljs-number"><span class="hljs-number">1</span></span>; jvmti-&gt;AddCapabilities(&amp;capabilities); jvmtiEventCallbacks callbacks = {<span class="hljs-number"><span class="hljs-number">0</span></span>}; callbacks.Exception = ExceptionCallback; jvmti-&gt;SetEventCallbacks(&amp;callbacks, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(callbacks)); jvmti-&gt;SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_EXCEPTION, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre><br>  Pertama saya meminta JVM TI untuk kapabilitas yang sesuai (can_generate_exception_events).  Kami akan berbicara tentang kemampuan secara terpisah. <br><br>  Langkah selanjutnya adalah berlangganan acara Pengecualian.  Setiap kali JVM melempar pengecualian (tidak peduli apakah mereka tertangkap atau tidak), fungsi <code>ExceptionCallback()</code> akan dipanggil. <br><br>  Langkah terakhir adalah memanggil <code>SetEventNotificationMode()</code> untuk memungkinkan pengiriman pemberitahuan. <br><br><div class="spoiler">  <b class="spoiler_title">Dalam ExceptionCallback, JVM melewati semua yang kita butuhkan untuk menangani pengecualian.</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> JNICALL </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ExceptionCallback</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(jvmtiEnv* jvmti, JNIEnv* env, jthread thread, jmethodID method, jlocation location, jobject exception, jmethodID catch_method, jlocation catch_location)</span></span></span><span class="hljs-function"> </span></span>{ jclass NullPointerException = env-&gt;FindClass(<span class="hljs-string"><span class="hljs-string">"java/lang/NullPointerException"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!env-&gt;IsInstanceOf(exception, NullPointerException)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } jclass Throwable = env-&gt;FindClass(<span class="hljs-string"><span class="hljs-string">"java/lang/Throwable"</span></span>); jfieldID detailMessage = env-&gt;GetFieldID(Throwable, <span class="hljs-string"><span class="hljs-string">"detailMessage"</span></span>, <span class="hljs-string"><span class="hljs-string">"Ljava/lang/String;"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (env-&gt;GetObjectField(exception, detailMessage) != <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> buf[<span class="hljs-number"><span class="hljs-number">32</span></span>]; <span class="hljs-built_in"><span class="hljs-built_in">sprintf</span></span>(buf, <span class="hljs-string"><span class="hljs-string">"at location %id"</span></span>, (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>) location); env-&gt;SetObjectField(exception, detailMessage, env-&gt;NewStringUTF(buf)); }</code> </pre><br></div></div><br>  Di sini ada objek dari thread yang melemparkan exception (thread), dan tempat terjadinya hal ini (metode, lokasi), dan objek pengecualian (pengecualian), dan bahkan tempat dalam kode yang menangkap pengecualian ini (catch_method, catch_location). <br><br>  Yang penting: dalam panggilan balik ini, selain penunjuk ke lingkungan TI JVM, lingkungan JNI (env) juga dilewati.  Ini berarti bahwa kita dapat menggunakan semua fungsi JNI di dalamnya.  Artinya, JVM TI dan JNI hidup berdampingan dengan sempurna, saling melengkapi. <br><br>  Dalam agen saya, saya menggunakan keduanya.  Secara khusus, melalui JNI saya memeriksa bahwa pengecualian saya adalah tipe <code>NullPointerException</code> , dan kemudian saya mengganti bidang <code>detailMessage</code> pesan kesalahan. <br><br>  Karena JVM itu sendiri melewati kita lokasi - indeks bytecode di mana pengecualian terjadi, maka saya hanya menempatkan lokasi ini di sini di pesan: <br><br><img src="https://habrastorage.org/webt/ix/h8/pc/ixh8pcrtxcg4rcdwwlg83_gfuam.png"><br><br>  Angka 66 menunjukkan indeks dalam bytecode di mana pengecualian ini terjadi.  Tetapi menganalisis bytecode secara manual itu suram: Anda perlu mendekompilasi file kelas, mencari instruksi ke-66, mencoba memahami apa yang dilakukannya ... Akan sangat bagus jika agen kami sendiri dapat menunjukkan sesuatu yang lebih dapat dibaca oleh manusia. <br><br>  Namun, dalam hal ini, JVM TI memiliki semua yang Anda butuhkan.  Benar, Anda harus meminta fitur tambahan dari JVM TI: dapatkan metode bytecode dan pool konstan. <br><br><pre> <code class="cpp hljs">jvmtiCapabilities capabilities = {<span class="hljs-number"><span class="hljs-number">0</span></span>}; capabilities.can_generate_exception_events = <span class="hljs-number"><span class="hljs-number">1</span></span>; capabilities.can_get_bytecodes = <span class="hljs-number"><span class="hljs-number">1</span></span>; capabilities.can_get_constant_pool = <span class="hljs-number"><span class="hljs-number">1</span></span>; jvmti-&gt;AddCapabilities(&amp;capabilities);</code> </pre><br>  Sekarang saya akan memperluas ExceptionCallback: melalui fungsi JVM TI <code>GetBytecodes()</code> Saya akan mendapatkan tubuh metode untuk memeriksa apa yang ada di dalamnya dengan indeks lokasi.  Berikutnya datang instruksi bytecode sakelar besar: jika ini adalah akses ke array, akan ada satu pesan kesalahan, jika akses ke bidang adalah pesan lain, jika pemanggilan metode adalah yang ketiga, dan seterusnya. <br><br><div class="spoiler">  <b class="spoiler_title">Kode ExceptionCallback</b> <div class="spoiler_text"><pre> <code class="cpp hljs">jint bytecode_count; u1* bytecodes; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (jvmti-&gt;GetBytecodes(method, &amp;bytecode_count, &amp;bytecodes) != <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (location &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; location &lt; bytecode_count) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>* message = get_exception_message(bytecodes[location]); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (message != <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>) { ... env-&gt;SetObjectField(exception, detailMessage, env-&gt;NewStringUTF(buf)); } } jvmti-&gt;Deallocate(bytecodes);</code> </pre><br></div></div><br>  Tetap hanya untuk mengganti nama bidang atau metode.  Anda bisa mendapatkannya dari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">kumpulan konstan</a> , yang tersedia lagi berkat JVM TI. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (jvmti-&gt;GetConstantPool(holder, &amp;cpool_count, &amp;cpool_bytes, &amp;cpool) != <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> strdup(<span class="hljs-string"><span class="hljs-string">"&lt;unknown&gt;"</span></span>); }</code> </pre><br>  Berikutnya datang sedikit keajaiban, tetapi pada kenyataannya tidak ada yang rumit, hanya sesuai dengan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">spesifikasi</a> format file kelas kami menganalisis kumpulan konstan dan dari sana kami mengisolasi garis - nama metode. <br><br><div class="spoiler">  <b class="spoiler_title">Analisis kumpulan konstan</b> <div class="spoiler_text"><pre> <code class="cpp hljs">u1* ref = get_cpool_at(cpool, get_u2(bytecodes + <span class="hljs-number"><span class="hljs-number">1</span></span>)); <span class="hljs-comment"><span class="hljs-comment">// CONSTANT_Fieldref u1* name_and_type = get_cpool_at(cpool, get_u2(ref + 3)); // CONSTANT_NameAndType u1* name = get_cpool_at(cpool, get_u2(name_and_type + 1)); // CONSTANT_Utf8 size_t name_length = get_u2(name + 1); char* result = (char*) malloc(name_length + 1); memcpy(result, name + 3, name_length); result[name_length] = 0;</span></span></code> </pre><br></div></div><br>  Poin penting lainnya: beberapa fungsi JVM TI, misalnya <code>GetConstantPool()</code> atau <code>GetBytecodes()</code> , mengalokasikan struktur tertentu dalam memori asli, yang perlu dibebaskan ketika Anda selesai bekerja dengannya. <br><br><pre> <code class="cpp hljs">jvmti-&gt;Deallocate(cpool);</code> </pre><br>  Jalankan program sumber dengan agen kami yang diperluas, dan ini adalah deskripsi yang sangat berbeda dari pengecualian: ia melaporkan bahwa kami memanggil metode longValue () pada objek nol. <br><br><img src="https://habrastorage.org/webt/8d/ge/-d/8dge-d_mtmqpdesbk6vm4nwolna.png"><br><br><h2>  Aplikasi lain </h2><br>  Secara umum, pengembang sering ingin menangani pengecualian dengan caranya sendiri.  Sebagai contoh, secara otomatis restart JVM jika <code>StackOverflowError</code> . <br><br>  Keinginan ini dapat dipahami, karena <code>StackOverflowError</code> adalah kesalahan fatal yang sama dengan <code>OutOfMemoryError</code> , setelah kejadiannya, tidak mungkin lagi menjamin operasi program yang benar.  Atau, misalnya, terkadang untuk menganalisis masalah, saya ingin menerima dump thread atau heap dump ketika pengecualian terjadi. <br><br><img src="https://habrastorage.org/webt/hh/8b/zy/hh8bzys2bji12vte4g_fsmlfaky.jpeg"><br><br>  Dalam keadilan, JDK IBM memiliki peluang seperti itu di luar kebiasaan.  Tapi sekarang kita sudah tahu bahwa menggunakan agen TI JVM, Anda dapat menerapkan hal yang sama di HotSpot.  Cukup dengan berlangganan callback pengecualian dan menganalisis pengecualian.  Tetapi bagaimana cara menghapus thread dump atau heap dump dari agen kami?  JVM TI memiliki semua yang Anda butuhkan untuk kasus ini: <br><br><img src="https://habrastorage.org/webt/yp/jj/5o/ypjj5o9xn9m7tmhdzmh-z8bo2tk.jpeg"><br><br>  Sangat tidak nyaman untuk menerapkan seluruh mekanisme melewati tumpukan dan membuat dump.  Tetapi saya akan membagikan rahasia cara membuatnya lebih mudah dan lebih cepat.  Benar, ini tidak lagi termasuk dalam standar JVM TI, tetapi merupakan ekstensi pribadi Hotspot. <br><br>  Anda perlu menghubungkan file header <a href="">jmm.h</a> dari sumber HotSpot dan memanggil fungsi <code>JVM_GetManagement()</code> : <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"jmm.h"</span></span></span><span class="hljs-meta"> JNIEXPORT void* JNICALL JVM_GetManagement(jint version); void JNICALL ExceptionCallback(jvmtiEnv* jvmti, JNIEnv* env, ...) { JmmInterface* jmm = (JmmInterface*) JVM_GetManagement(JMM_VERSION_1_0); jmm-&gt;DumpHeap0(env, env-&gt;NewStringUTF(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"dump.hprof"</span></span></span><span class="hljs-meta">), JNI_FALSE); }</span></span></code> </pre><br>  Ini akan mengembalikan pointer ke HotSpot Management Interface, yang dalam satu panggilan akan menghasilkan Heap Dump atau Thread Dump.  Kode lengkap untuk contoh dapat ditemukan dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">jawaban saya</a> untuk Stack Overflow. <br><br>  Secara alami, Anda dapat menangani tidak hanya pengecualian, tetapi juga banyak peristiwa lainnya yang terkait dengan operasi JVM: memulai / menghentikan thread, kelas pemuatan, pengumpulan sampah, metode kompilasi, metode masuk / keluar, bahkan mengakses atau memodifikasi bidang khusus objek Java. <br><br>  Saya punya contoh agen <a href="">vmtrace</a> lain yang berlangganan banyak acara JVM TI standar dan mencatatnya.  Jika saya menjalankan program sederhana dengan agen ini, saya akan mendapatkan log terperinci, yang bila selesai, dengan cap waktu: <br><br><img src="https://habrastorage.org/webt/wu/he/ci/wuhecifrgrrkleshnnkqx6hd9ew.jpeg"><br><br>  Seperti yang Anda lihat, untuk sekadar mencetak hello world, ratusan kelas dimuat, puluhan dan ratusan metode dihasilkan dan dikompilasi.  Menjadi jelas mengapa Java membutuhkan waktu begitu lama untuk dijalankan.  Segala sesuatu tentang semuanya membutuhkan lebih dari dua ratus milidetik. <br><br><h2>  Apa yang bisa dilakukan JVM TI </h2><br>  Selain penanganan acara, JVM TI memiliki banyak fitur lainnya.  Mereka dapat dibagi menjadi dua kelompok. <br><br>  Salah satunya adalah wajib, yang harus diterapkan oleh JVM mana pun yang mendukung JVM TI.  Ini termasuk operasi menganalisis metode, bidang, aliran, kemampuan untuk menambahkan kelas baru ke classpath, dan sebagainya. <br><br>  Ada fitur opsional yang membutuhkan permintaan kemampuan pendahuluan.  JVM tidak diperlukan untuk mendukung semuanya, namun HotSpot mengimplementasikan seluruh spesifikasi secara penuh.  Fitur opsional dibagi menjadi dua subkelompok: yang dapat dihubungkan hanya pada awal JVM (misalnya, kemampuan untuk mengatur breakpoint atau menganalisis variabel lokal), dan yang dapat dihubungkan kapan saja (khususnya, bytecode atau pool konstan, yang saya digunakan di atas). <br><br><img src="https://habrastorage.org/webt/ee/9e/oo/ee9eooqcrrdowlrc1rvqmfuhjs0.jpeg"><br><br>  Anda mungkin memperhatikan bahwa daftar fitur sangat mirip dengan fitur debugger.  Sebenarnya, debugger Java tidak lebih dari kasus khusus agen JVM TI, yang memanfaatkan semua kemampuan ini dan meminta semua kemampuan. <br><br>  Pemisahan kapabilitas menjadi kapabilitas yang dapat diaktifkan kapan saja, dan kapabilitas yang hanya pada saat boot, dilakukan dengan sengaja.  Tidak semua fitur gratis, ada yang membawa overhead. <br><br>  Jika semuanya jelas dengan overhead langsung yang menyertai penggunaan fitur, maka ada yang tidak langsung bahkan lebih jelas yang muncul bahkan jika Anda tidak menggunakan fitur, tetapi hanya melalui kemampuan Anda menyatakan bahwa itu akan dibutuhkan suatu saat di masa depan.  Ini disebabkan oleh fakta bahwa mesin virtual dapat mengkompilasi kode secara berbeda atau menambahkan pemeriksaan tambahan ke runtime. <br><br>  Misalnya, kemampuan yang sudah dianggap untuk berlangganan pengecualian (can_generate_exception_events) mengarah pada fakta bahwa semua pengecualian melempar akan berjalan lambat.  Pada prinsipnya, ini tidak begitu menakutkan, karena pengecualian adalah hal yang langka dalam program Java yang baik. <br><br>  Situasi dengan variabel lokal sedikit lebih buruk.  Untuk can_access_local_variables, yang memungkinkan Anda mendapatkan nilai variabel lokal kapan saja, Anda perlu menonaktifkan beberapa optimasi penting.  Secara khusus, Escape Analysis sepenuhnya berhenti bekerja, yang dapat memberikan overhead yang terlihat: tergantung pada aplikasi, 5-10%. <br><br>  Oleh karena itu kesimpulannya: jika Anda menjalankan Java dengan agen debug dihidupkan, bahkan tanpa menggunakannya, aplikasi akan berjalan lebih lambat.  Bagaimanapun, memasukkan agen debugging dalam produksi bukanlah ide yang baik. <br><br>  Sejumlah fitur, misalnya, mengatur breakpoint atau melacak semua input / output dari suatu metode, membawa overhead yang jauh lebih serius.  Secara khusus, beberapa peristiwa JVM TI (FieldAccess, MethodEntry / Exit) hanya berfungsi di interpreter. <br><br><h2>  Satu agen baik, dan dua lebih baik </h2><br>  Anda dapat menghubungkan beberapa agen ke satu proses dengan hanya menentukan beberapa parameter- <code>-agentpath</code> .  Setiap orang akan memiliki lingkungan TI JVM mereka sendiri.  Ini berarti bahwa setiap orang dapat berlangganan kemampuan mereka dan mencegat acara mereka secara mandiri. <br><br>  Dan jika dua agen berlangganan acara Breakpoint, dan dalam satu breakpoint diatur dalam beberapa metode, maka ketika metode ini dieksekusi, akankah agen kedua menerima acara tersebut? <br><br>  Pada kenyataannya, situasi seperti itu tidak dapat terjadi (setidaknya di HotSpot JVM).  Karena ada beberapa kemampuan yang hanya dimiliki oleh salah satu agen pada waktu tertentu.  Ini termasuk breakpoint_events khususnya.  Oleh karena itu, jika agen kedua meminta kemampuan yang sama, itu akan menerima kesalahan sebagai respons. <br><br>  Ini adalah kesimpulan penting: agen harus selalu memeriksa hasil permintaan kemampuan, bahkan jika Anda menjalankan di HotSpot dan tahu bahwa semuanya tersedia.  Spesifikasi JVM TI tidak mengatakan apa-apa tentang kemampuan eksklusif, tetapi HotSpot memiliki fitur implementasi seperti itu. <br><br>  Benar, isolasi agen tidak selalu bekerja dengan sempurna.  Selama pengembangan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">async-profiler,</a> saya menemukan masalah ini: ketika kami memiliki dua agen dan satu meminta generasi acara kompilasi metode, maka semua agen menerima peristiwa ini.  Tentu saja, saya mengajukan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">bug</a> , tetapi Anda harus ingat bahwa peristiwa yang tidak Anda harapkan dapat terjadi pada agen Anda. <br><br><h2>  Penggunaan dalam program reguler </h2><br>  JVM TI mungkin tampak seperti hal yang sangat spesifik untuk debugger dan profiler, tetapi juga dapat digunakan dalam program Java biasa.  Pertimbangkan sebuah contoh. <br><br>  Paradigma pemrograman reaktif sekarang tersebar luas ketika semuanya asinkron, tetapi ada masalah dengan paradigma ini. <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TaskRunner</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">good</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ CompletableFuture.runAsync(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> AsyncTask(GOOD)); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bad</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ CompletableFuture.runAsync(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> AsyncTask(BAD)); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String[] args)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> Exception </span></span>{ good(); bad(); Thread.sleep(<span class="hljs-number"><span class="hljs-number">200</span></span>); } }</code> </pre><br>  Saya menjalankan dua tugas asinkron yang hanya berbeda dalam parameter.  Dan jika terjadi kesalahan, pengecualian muncul: <br><br><img src="https://habrastorage.org/webt/ds/me/wx/dsmewxe5rd4lzgq8fgjxn42zh0e.png"><br><br>  Dari jejak stack, sama sekali tidak jelas tugas mana yang menyebabkan masalah.  Karena pengecualian terjadi pada utas yang sama sekali berbeda, di mana kita tidak memiliki konteks.  Bagaimana memahami tugas yang mana? <br><br>  Sebagai salah satu solusi, Anda dapat menambahkan informasi tentang di mana kami membuatnya ke konstruktor tugas asinkron kami: <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AsyncTask</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String arg)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.arg = arg; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.location = getLocation(); }</code> </pre><br>  Artinya, ingat lokasi - tempat tertentu dalam kode, sampai ke garis dari mana konstruktor dipanggil.  Dan dalam hal pengecualian untuk menjaminkannya: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> n = Integer.parseInt(arg); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (Throwable e) { System.err.println(<span class="hljs-string"><span class="hljs-string">"ParseTask failed at "</span></span> + location); e.printStackTrace(); }</code> </pre><br>  Sekarang, ketika pengecualian terjadi, kita akan melihat bahwa ini terjadi pada baris 14 di TaskRunner (di mana tugas dengan parameter BAD dibuat): <br><br><img src="https://habrastorage.org/webt/v-/tq/0q/v-tq0qa-bnlkakz8dnzxhrjfqvo.png"><br><br>  Tetapi bagaimana cara mendapatkan tempat dalam kode dari mana konstruktor dipanggil?  Sebelum ke Java 9, ada satu-satunya cara legal untuk melakukan ini: dapatkan jejak stack, lewati beberapa frame yang tidak relevan, dan sedikit lebih rendah pada stack akan menjadi tempat kode kita dipanggil. <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-function">String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getLocation</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ StackTraceElement caller = Thread.currentThread().getStackTrace()[<span class="hljs-number"><span class="hljs-number">3</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> caller.getFileName() + <span class="hljs-string"><span class="hljs-string">':'</span></span> + caller.getLineNumber(); }</code> </pre><br>  Tapi ada masalah.  Mendapatkan StackTrace lengkap sangat lambat.  Saya memiliki seluruh <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">laporan yang</a> ditujukan untuk ini. <br><br>  Ini tidak akan menjadi masalah besar jika jarang terjadi.  Tetapi, misalnya, kami memiliki layanan web - frontend yang menerima permintaan HTTP.  Ini adalah aplikasi hebat, jutaan baris kode.  Dan untuk menangkap kesalahan render, kami menggunakan mekanisme yang serupa: di komponen untuk rendering, kami ingat tempat pembuatannya.  Kami memiliki jutaan komponen seperti itu, jadi untuk mendapatkan semua jejak tumpukan memerlukan waktu nyata untuk memulai aplikasi, bukan hanya satu menit.  Oleh karena itu, fitur ini sebelumnya dinonaktifkan dalam produksi, meskipun untuk analisis masalah diperlukan dalam produksi. <br><br>  Java 9 memperkenalkan cara baru untuk mem-bypass stream stream: StackWalker, yang melalui Stream API dapat melakukan semua ini dengan malas, sesuai permintaan.  Artinya, kita dapat melewati jumlah frame yang tepat dan hanya mendapatkan satu yang menarik bagi kita. <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-function">String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getLocation</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> StackWalker.getInstance().walk(s -&gt; { StackWalker.StackFrame frame = s.skip(<span class="hljs-number"><span class="hljs-number">3</span></span>).findFirst().get(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> frame.getFileName() + <span class="hljs-string"><span class="hljs-string">':'</span></span> + frame.getLineNumber(); }); }</code> </pre><br>  Ini bekerja sedikit lebih baik daripada mendapatkan jejak tumpukan penuh, tetapi tidak dengan urutan besarnya atau bahkan berkali-kali.  Dalam kasus kami, ternyata sekitar satu setengah kali lebih cepat: <br><br><img src="https://habrastorage.org/webt/v8/bz/rk/v8bzrkf8szriwvghilzvhrddtzo.jpeg"><br><br>  Ada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">masalah yang diketahui</a> dengan implementasi StackWalker yang kurang optimal, dan kemungkinan besar itu akan diperbaiki di JDK 13. Tetapi sekali lagi, apa yang harus kita lakukan sekarang di Java 8, di mana StackWalker bahkan tidak lambat? <br><br>  JVM TI datang untuk menyelamatkan lagi.  Ada fungsi <code>GetStackTrace()</code> yang dapat melakukan semua yang Anda butuhkan: dapatkan fragmen jejak tumpukan dengan panjang tertentu, mulai dari bingkai yang ditentukan, dan tidak melakukan apa-apa lagi. <br><br><pre> <code class="cpp hljs">GetStackTrace(jthread thread, jint start_depth, jint max_frame_count, jvmtiFrameInfo* frame_buffer, jint* count_ptr)</code> </pre><br>  Hanya ada satu pertanyaan yang tersisa: bagaimana cara memanggil fungsi JVM TI dari program Java kami?  Sama seperti metode asli lainnya: muat pustaka asli dengan <code>System.loadLibrary()</code> , di mana implementasi JNI dari metode kami akan. <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">StackFrame</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">native</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getLocation</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> depth)</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> { System.loadLibrary(<span class="hljs-string"><span class="hljs-string">"stackframe"</span></span>); } }</code> </pre><br>  Pointer ke lingkungan JVM TI <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dapat diperoleh</a> tidak hanya dari Agent_OnLoad (), tetapi juga saat program sedang berjalan, dan untuk terus menggunakannya dari metode JNI asli asli: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">JNIEXPORT jstring JNICALL </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Java_StackFrame_getLocation</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(JNIEnv* env, jclass unused, jint depth)</span></span></span><span class="hljs-function"> </span></span>{ jvmtiFrameInfo frame; jint count; jvmti-&gt;GetStackTrace(<span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, depth, <span class="hljs-number"><span class="hljs-number">1</span></span>, &amp;frame, &amp;count);</code> </pre><br>               : <br><br><img src="https://habrastorage.org/webt/ia/-u/au/ia-uauyvrmwlvh84rh84rqqwu1s.jpeg"><br><br> ,    JDK   :    -  .          -. ,   ,      ,   JDK.   JDK 8u112,  JVM TI-,    (GetMethodName, GetMethodDeclaringClass   ),   . <br><br>   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="></a> ,  ,    :   JVM TI-   ,   ,         -.     ,         C++,    <a href="">jvmtiEnter.xsl</a> . <br><br>  :    HotSpot       XSLT-.       HotSpot. <br><br>     ?       ,   .  ,   - jmethodID  ,      .      ,      . <br><br><h2>   </h2><br>    ,  JVM TI     Java-     ,  <code>System.loadLibrary</code> . <br><br>  ,   ,    JVM TI-  <code>-agentpath</code>   JVM. <br><br>     :   (dynamic attach). <br><br>   ?          ,      - ,       ,    JVM TI-    . <br><br>   JDK 9,           jcmd: <br><br><pre> <code class="bash hljs">jcmd &lt;pid&gt; JVMTI.agent_load /path/to/agent.so [arguments]</code> </pre><br>      JDK     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">jattach</a> . , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">async-profiler</a>      ,   -  JVM-,    jattach. <br><br>    JVM TI-    , ,  <code>Agent_OnLoad()</code> ,    <code>Agent_OnAttach()</code> .  :  <code>Agent_OnAttach()</code>    capabilities,       . <br><br>  ,           ,   <code>Agent_OnAttach()</code>   . <br><br>   .     IntelliJ IDEA:    Java-, ,          - . <br><br>  process ID  IDEA,   jattach     JVM TI- patcher.dll: <br> <code>jattach 8648 load patcher.dll true</code> <br> <br>          : <br><br><img src="https://habrastorage.org/webt/rv/j7/wm/rvj7wmnfdbo26tjkcsqaix96k74.png"><br><br>    ?   Java-   ( <code>javax.swing.AbstractButton</code> )    JNI  <code>setBackground()</code> .     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="></a> . <br><br><h2>    Java 9 </h2><br> JVM TI   , ,    ,     API,     .      Java 9. <br><br>  , Java 9     ,   .  ,    «» JDK,       . <br><br> ,  JDK     Direct ByteBuffer.    API: <br><br><img src="https://habrastorage.org/webt/wj/qb/ue/wjqbuel-1g3j1qis_bihg0lpn_8.jpeg"><br><br> ,  Cassandra    ,          MappedByteBuffer,      ,  JVM  . <br><br>          JDK 9,  IllegalAccessError: <br><br><img src="https://habrastorage.org/webt/co/z-/49/coz-496tvv3ogo7kw44viuqtpwq.jpeg"><br><br>      Reflection:      . <br><br> ,  Java       Linux.   -        <code>java.io.FileDescriptor</code>       JNI    -  .  ,     JDK 9,     : <br><br><img src="https://habrastorage.org/webt/he/xc/6p/hexc6pnrkv0ehoablvlfy11imt0.jpeg"><br><br> ,   JVM,           .      ,   . ,    Cassandra  Java 11,   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="></a> : <br><br><pre> <code class="plaintext hljs">--add-exports java.base/jdk.internal.misc=ALL-UNNAMED --add-exports java.base/jdk.internal.ref=ALL-UNNAMED --add-exports java.base/sun.nio.ch=ALL-UNNAMED --add-exports java.management.rmi/com.sun.jmx.remote.internal.rmi=ALL-UNNAMED --add-exports java.rmi/sun.rmi.registry=ALL-UNNAMED --add-exports java.rmi/sun.rmi.server=ALL-UNNAMED --add-exports java.sql/java.sql=ALL-UNNAMED --add-opens java.base/java.lang.module=ALL-UNNAMED --add-opens java.base/jdk.internal.loader=ALL-UNNAMED --add-opens java.base/jdk.internal.ref=ALL-UNNAMED --add-opens java.base/jdk.internal.reflect=ALL-UNNAMED --add-opens java.base/jdk.internal.math=ALL-UNNAMED --add-opens java.base/jdk.internal.module=ALL-UNNAMED --add-opens java.base/jdk.internal.util.jar=ALL-UNNAMED --add-opens jdk.management/com.sun.management.internal=ALL-UNNAMED</code> </pre><br>       <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="></a> JVM TI    : <br><br><ul><li> GetAllModules </li><li> AddModuleExports </li><li> AddModuleOpens </li><li>  . . </li></ul><br>    ,    :    JVM,    ,    ,      . <br><br>      Direct ByteBuffer: <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String[] args)</span></span></span><span class="hljs-function"> </span></span>{ ByteBuffer buf = ByteBuffer.allocateDirect(<span class="hljs-number"><span class="hljs-number">1024</span></span>); ((sun.nio.ch.DirectBuffer) buf).cleaner().clean(); System.out.println(<span class="hljs-string"><span class="hljs-string">"Buffer cleaned"</span></span>); }</code> </pre><br>     ,   IllegalAccessError.     agentpath    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">antimodule</a> ,     .     . <br><br><h2>    Java 11 </h2><br>     Java 11.   ,   !     :    <code>SampledObjectAlloc</code> ,    ,      . <br><br>  callback   ,     : ,  ,   ,  , .   <code>SetHeapSampingInterval</code>   ,      . <br><br><img src="https://habrastorage.org/webt/5f/e1/8_/5fe18_nwt5i-zbm4e-vyn4roavm.jpeg"><br><br>   ?         ,    ,     .        Java Flight Recorder. <br><br>     ,     ,     ,  , . <br><br>           Thread Local Allocation Buffer   .      TLAB   ,   .        ,     . <br><br><img src="https://habrastorage.org/webt/v0/lm/di/v0lmdimdyk8uvasl3z9gkjlrfqe.jpeg"><br><br>     ,     TLAB,    .          JVM runtime   . <br><br>   ,        ,       —     5%. <br><br>  ,    ,    JDK 7,    Flight Recorder.    API     async-profiler.  ,   JDK 11,  API  ,   JVM TI,      .  , YourKit   .     API,    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="></a> ,    . <br><br>         . ,   ,    , , . <br><br><img src="https://habrastorage.org/webt/qi/t1/lw/qit1lwwqv3p7vxhhl-fbcfh5bos.jpeg"><br><br><h2>  Kesimpulan </h2><br> JVM TI —      . <br><br> ,     ++,     JVM         .  ,  JVM TI        . <br><br>        <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="> GitHub</a> . ,    . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id458812/">https://habr.com/ru/post/id458812/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id458798/index.html">Bot Nutrient atau cara saya ingin mengambil roti dari pelatih kebugaran</a></li>
<li><a href="../id458800/index.html">Pembelajaran yang mendalam. Pembelajaran Federasi</a></li>
<li><a href="../id458804/index.html">Intisari Artikel Pembelajaran Mesin dan Kecerdasan Buatan</a></li>
<li><a href="../id458808/index.html">Laporan postmortem Habr: surat kabar jatuh</a></li>
<li><a href="../id458810/index.html">Corel dan Parallels dijual ke grup investasi KKR dari AS</a></li>
<li><a href="../id458814/index.html">Meluncurkan situs untuk produk dengan permintaan yang belum terbentuk</a></li>
<li><a href="../id458818/index.html">Orang-orang sezamannya yang terkemuka</a></li>
<li><a href="../id458820/index.html">Tentang implementasi genre terkenal di platform Minecraft</a></li>
<li><a href="../id458826/index.html">Cara menyingkirkan artikel lama sehingga tumbuh tajam di organik: + 104% lalu lintas selama enam bulan</a></li>
<li><a href="../id458828/index.html">Mengapa, mengapa, dan kapan menggunakan ValueTask</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>