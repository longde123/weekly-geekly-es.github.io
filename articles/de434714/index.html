<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🐭 🤱🏿 🏪 Synchronisierung von Clientanforderungen im Frühjahr 👩🏽‍💼 🤦🏿 🚞</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Heute schlage ich Ihnen vor, eine praktische Aufgabe über das Rennen der Kundenanforderungen zu analysieren, auf die ich in MaximTelecom bei der Entwi...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Synchronisierung von Clientanforderungen im Frühjahr</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/maximatelecom/blog/434714/">  Heute schlage ich Ihnen vor, eine praktische Aufgabe über das Rennen der Kundenanforderungen zu analysieren, auf die ich in MaximTelecom bei der Entwicklung des Backends für unsere mobile Anwendung MT_FREE gestoßen bin. <br><br>  Beim Start sendet die Clientanwendung asynchron ein "Paket" von Anforderungen an die API.  Die Anwendung verfügt über die clientId-ID, anhand derer Anforderungen von einem Client von einem anderen unterschieden werden können.  Für jede Anforderung auf dem Server ein Code des Formulars: <br><br><pre><code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">//      Client client = clientRepository.findByClientId(clientId); //      if(client == null){ client = clientRepository.save(new Client(clientId)); } //   </span></span></code> </pre> <br>  Dabei verfügt die Client-Entität über ein clientId-Feld, das eindeutig sein muss und dafür eine eindeutige Einschränkung in der Datenbank aufweist.  Da im Frühjahr jede Anforderung diesen Code in einem separaten Thread ausführt, wird ein Fehler des Formulars angezeigt, auch wenn es sich um Anforderungen derselben Clientanwendung handelt: <br><blockquote>  Verletzung der Integritätsbeschränkung: Verletzung der eindeutigen Einschränkung oder des Index;  Tabelle UK_BFJDOY2DPUSSYLQ7G1S3S1TN8: CLIENT </blockquote><br>  Der Fehler tritt aus einem offensichtlichen Grund auf: 2 oder mehr Threads mit derselben clientId empfangen die Entität client == null und beginnen mit der Erstellung. Danach wird beim Festschreiben ein Fehler angezeigt. <br><br><h3>  Herausforderung: </h3><br>  Es ist erforderlich, Anforderungen von einer Client-ID zu synchronisieren, damit nur die erste Anforderung die Erstellung der Client-Entität abschließt und der Rest zum Zeitpunkt der Erstellung blockiert wird und das bereits erstellte Objekt empfängt. <br><a name="habracut"></a><br><h3>  Lösung 1 </h3><br><pre> <code class="java hljs"> <span class="hljs-comment"><span class="hljs-comment">//      if(client == null){ //   synchronized (this){ //    client = clientRepository.findByClientId(clientId); if(client == null){ client = clientRepository.save(new Client(clientId)); } } }</span></span></code> </pre><br>  Diese Lösung funktioniert, ist aber sehr teuer, da alle Anforderungen (Threads), die erstellt werden müssen, blockiert werden, auch wenn sie einen Client mit einer anderen clientId erstellen und nicht miteinander konkurrieren. <br><br>  Bitte beachten Sie, dass die Kombination aus Synchronisation mit @ Transactional-Annotation <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Transactional</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">synchronized</span></span></span><span class="hljs-function"> Client </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getOrCreateUser</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String clientId)</span></span></span></span>{ <span class="hljs-comment"><span class="hljs-comment">//      Client client = clientRepository.findByClientId(clientId); //      if(client == null){ client = clientRepository.save(new Client(clientId)); } return client; }</span></span></code> </pre><br>  Der gleiche Fehler tritt erneut auf.  Der Grund dafür ist, dass der Monitor (synchronisiert) zuerst freigegeben wird und der nächste Thread den synchronisierten Bereich betritt. Erst danach wird die Transaktion vom ersten Thread im Proxy-Objekt festgeschrieben.  Die Lösung dieses Problems ist einfach: Sie müssen den Monitor nach dem Festschreiben freigeben. Daher muss oben synchronisiert aufgerufen werden: <br><br><pre> <code class="java hljs"> <span class="hljs-keyword"><span class="hljs-keyword">synchronized</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>){ client = clientService.getOrCreateUser(clientId); }</code> </pre><br><h3>  Entscheidung 2 </h3><br>  Ich würde wirklich gerne ein Design des Formulars verwenden: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">synchronized</span></span> (clientId)</code> </pre> <br>  Das Problem ist jedoch, dass für jede Anforderung ein neues clientId-Objekt erstellt wird, auch wenn ihre Werte äquivalent sind. Daher kann die Synchronisierung nicht auf diese Weise durchgeführt werden.  Um das Problem mit verschiedenen clientId-Objekten zu lösen, müssen Sie den Pool verwenden: <br><br><pre> <code class="java hljs">Client client = clientRepository.findByClientId(clientId); <span class="hljs-comment"><span class="hljs-comment">//      if(client == null){ //   synchronized (clientId.intern()){ //    client = clientRepository.findByClientId(clientId); if(client == null){ client = clientRepository.save(new Client(clientId)); } } }</span></span></code> </pre><br>  Diese Lösung verwendet den Java-String-Pool. Anforderungen mit der entsprechenden clientId erhalten durch Aufrufen von clientId.intern () dasselbe Objekt.  Leider ist diese Lösung in der Praxis nicht anwendbar, da es unmöglich ist, die "verrottende" clientId zu verwalten, was früher oder später zu OutOfMemory führen wird. <br><br><h3>  Entscheidung 3 </h3><br>  Um ReentrantLock verwenden zu können, benötigen Sie einen Pool des Formulars: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> ConcurrentMap&lt;String, ReentrantLock&gt; locks;</code> </pre> <br>  und dann: <br><br><pre> <code class="java hljs">Client client = clientRepository.findByClientId(clientId); <span class="hljs-comment"><span class="hljs-comment">//      if(client == null){ //   ReentrantLock lock = locks.computeIfAbsent(clientId, (k) -&gt; new ReentrantLock()); lock.lock(); try{ //    client = clientRepository.findByClientId(clientId); if(client == null){ client = clientRepository.save(new Client(clientId)); } } finally { //   lock.unlock(); } }</span></span></code> </pre><br>  Das einzige Problem ist die Verwaltung der "veralteten" clientId. Sie kann mithilfe der nicht standardmäßigen Implementierung von ConcurrentMap gelöst werden, die bereits das Ablaufen unterstützt. Nehmen Sie beispielsweise den Guaven-Cache: <br><br><pre> <code class="java hljs">locks = CacheBuilder.newBuilder() .concurrencyLevel(<span class="hljs-number"><span class="hljs-number">4</span></span>) .expireAfterWrite(Duration.ofMinutes(<span class="hljs-number"><span class="hljs-number">1</span></span>)) .&lt;String, ReentrantLock&gt;build().asMap();</code> </pre><br><h3>  Entscheidung 4 </h3><br>  Die oben genannten Lösungen synchronisieren Anforderungen innerhalb einer einzelnen Instanz.  Was tun, wenn sich Ihr Dienst auf N Knoten dreht und Anforderungen gleichzeitig an andere gesendet werden können?  In dieser Situation ist die Verwendung der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Redisson-</a> Bibliothek als Lösung perfekt: <br><br><pre> <code class="java hljs"> Client client = clientRepository.findByClientId(clientId); <span class="hljs-comment"><span class="hljs-comment">//      if(client == null){ //   RLock lock = redissonClient.getFairLock(clientId); lock.lock(); try{ //    client = clientRepository.findByClientId(clientId); if(client == null){ client = clientRepository.save(new Client(clientId)); } } finally { //   lock.unlock(); } }</span></span></code> </pre><br>  Die Bibliothek löst das Problem der verteilten Sperren mithilfe von redis als Repository. <br><br><h2>  Fazit </h2><br>  Welche Entscheidung für eine Anwendung getroffen wird, hängt sicherlich vom Ausmaß des Problems ab: Die Lösungen 1 bis 3 eignen sich gut für kleine Dienste mit einer Instanz, Lösung 4 richtet sich an verteilte Dienste.  Es ist auch erwähnenswert, dass die Lösung dieses Problems mit Redisson oder Analoga (z. B. klassischer Zookeeper) natürlich ein Sonderfall ist, da sie für einen viel größeren Aufgabenbereich für verteilte Systeme ausgelegt sind. <br><br>  In unserem Fall haben wir uns für Lösung 4 entschieden, da unser Service verteilt ist und die Redisson-Integration im Vergleich zu Analoga am einfachsten war. <br><br>  Freunde, schlagen Sie in den Kommentaren Ihre Möglichkeiten zur Lösung dieses Problems vor, ich werde mich sehr freuen! <br>  Der Quellcode für die Beispiele ist auf <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">GitHub</a> verfügbar. <br><br>  Übrigens erweitern wir ständig das Entwicklungspersonal, relevante Stellen finden Sie auf unserer <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Karriereseite</a> . <br><br><h3>  UPD 1. Lösung von Lesern 1 </h3><br>  Diese Lösung schlägt vor, Anforderungen nicht zu synchronisieren, sondern im Falle eines Fehlers des Formulars: <br><blockquote>  Verletzung der Integritätsbeschränkung: Verletzung der eindeutigen Einschränkung oder des Index;  Tabelle UK_BFJDOY2DPUSSYLQ7G1S3S1TN8: CLIENT </blockquote><br>  muss verarbeitet und zurückgerufen werden <br><pre> <code class="java hljs">client = clientRepository.findByClientId(clientId);</code> </pre><br>  oder machen Sie es durch Spring-Retry: <br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Retryable</span></span>(value = { SQLException.class }, maxAttempts = <span class="hljs-number"><span class="hljs-number">3</span></span>, backoff = <span class="hljs-meta"><span class="hljs-meta">@Backoff</span></span>(delay = <span class="hljs-number"><span class="hljs-number">1000</span></span>)) <span class="hljs-meta"><span class="hljs-meta">@Transactional</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Client </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getOrCreateUser</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String clientId)</span></span></span></span></code> </pre><br>  (danke an <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link">Throwable</a> für <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ein Beispiel</a> ) <br>  In diesem Fall gibt es "zusätzliche" Abfragen an die Datenbank, aber in der Praxis wird die Erstellung der Client-Entität nicht häufig durchgeführt. Wenn eine Synchronisierung nur erforderlich ist, um das Problem des Einfügens in die Datenbank zu lösen, kann auf diese Lösung verzichtet werden. <br><br><h3>  UPD 2. Lösung von Lesern 2 </h3><br>  Diese Lösung schlägt vor, die Synchronisierung über die Sitzung durchzuführen: <br><pre> <code class="java hljs">HttpSession session = request.getSession(<span class="hljs-keyword"><span class="hljs-keyword">false</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (session != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { Object mutex = WebUtils.getSessionMutex(session); <span class="hljs-keyword"><span class="hljs-keyword">synchronized</span></span> (mutex) { ... } }</code> </pre><br>  Diese Lösung funktioniert für Dienste mit einer Instanz, das Problem muss jedoch behoben werden, damit alle Anforderungen von einem Client an die API in derselben Sitzung ausgeführt werden. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de434714/">https://habr.com/ru/post/de434714/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de434704/index.html">Gründe für den Rückgang der Kosten des Mobilfunkverkehrs in Russland und die Prognose für 2019</a></li>
<li><a href="../de434706/index.html">UDB. Was ist das Teil 3. Datenpfad-FIFO</a></li>
<li><a href="../de434708/index.html">HL 2018. Zusammenfassung des Berichts „Machen Sie Passwörter wieder großartig! Wie man rohe Gewalt besiegt und Hackern nichts hinterlässt “</a></li>
<li><a href="../de434710/index.html">RUVDS-Blog über Habr: Jahr in drei</a></li>
<li><a href="../de434712/index.html">Dritter Turing-Test in russischer Sprache</a></li>
<li><a href="../de434716/index.html">Umzug ins Rechenzentrum: Vorbereitung</a></li>
<li><a href="../de434718/index.html">Zwei Jahre später vermisse ich immer noch die Kopfhörerbuchse</a></li>
<li><a href="../de434720/index.html">Kehrseite des Nullwissens: Eine Hintertür in zk-SNARK, die nicht erkannt werden kann</a></li>
<li><a href="../de434722/index.html">Schmerzen, Pillen und zwei Krankenwagen oder wie wir alle in Sotschi auf den fünften Platz IronStar 226 geklettert sind</a></li>
<li><a href="../de434724/index.html">Chinesische Bauern machen Live-Streaming</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>