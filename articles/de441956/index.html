<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üëµüèΩ üö´ üå°Ô∏è Einheitliche Fehlerbehandlung (C ++ - Option f√ºr Mikrocontroller) üë®üèæ‚Äçü§ù‚Äçüë®üèº üíÉ üéä</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Bei der Entwicklung von Software f√ºr Mikrocontroller in C ++ kann h√§ufig festgestellt werden, dass die Verwendung der Standardbibliothek zu unerw√ºnsch...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Einheitliche Fehlerbehandlung (C ++ - Option f√ºr Mikrocontroller)</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/441956/"> Bei der Entwicklung von Software f√ºr Mikrocontroller in C ++ kann h√§ufig festgestellt werden, dass die Verwendung der Standardbibliothek zu unerw√ºnschten zus√§tzlichen Kosten f√ºr Ressourcen, sowohl RAM als auch ROM, f√ºhren kann.  Daher sind die Klassen und Methoden aus der <code>std</code> h√§ufig nicht f√ºr die Implementierung im Mikrocontroller geeignet.  Es gibt auch einige Einschr√§nkungen bei der Verwendung von dynamisch zugewiesenem Speicher, RTTI, Ausnahmen usw.  Um kompakten und schnellen Code zu schreiben, k√∂nnen Sie im Allgemeinen nicht einfach die <code>typeid</code> verwenden und beispielsweise <code>typeid</code> Operatoren verwenden, da Sie RTTI-Unterst√ºtzung ben√∂tigen. Dies ist ein Overhead, wenn auch nicht sehr gro√ü. <br><br>  Daher muss man manchmal das Rad neu erfinden, um all diese Bedingungen zu erf√ºllen.  Es gibt nur wenige solche Aufgaben, aber sie sind es.  In diesem Beitrag m√∂chte ich √ºber eine scheinbar einfache Aufgabe sprechen - die R√ºckkehrcodes vorhandener Subsysteme in Mikrocontroller-Software zu erweitern. <br><a name="habracut"></a><br><h2>  Herausforderung </h2><br>  Angenommen, Sie haben ein CPU-Diagnose-Subsystem und es gibt unz√§hlige R√ºckkehrcodes. Sagen Sie Folgendes: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Cpu_Error</span></span></span><span class="hljs-class"> {</span></span> Ok, Alu, Rom, Ram } ;</code> </pre><br>  Wenn das CPU-Diagnosesubsystem einen Fehler eines der CPU-Module (z. B. ALU oder RAM) feststellt, muss es den entsprechenden Code zur√ºckgeben. <br><br>  Dasselbe gilt f√ºr ein anderes Subsystem: Es handelt sich um eine Messdiagnose, bei der √ºberpr√ºft wird, ob der gemessene Wert im Bereich liegt und allgemein g√ºltig ist (nicht gleich NAN oder Infinity): <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Measure_Error</span></span></span><span class="hljs-class"> {</span></span> OutOfLimits, Ok, BadCode } ;</code> </pre> <br>  <code>GetLastError()</code> f√ºr jedes Subsystem eine <code>GetLastError()</code> -Methode an, die den aufgez√§hlten Fehlertyp dieses Subsystems zur√ºckgibt.  F√ºr <code>CpuDiagnostic</code> Code vom Typ <code>CpuDiagnostic</code> zur√ºckgegeben, f√ºr <code>MeasureDiagnostic</code> Code vom Typ <code>Measure_Error</code> . <br><br>  Und es gibt ein bestimmtes Protokoll, das im Fehlerfall den Fehlercode protokollieren sollte. <br>  Zum Verst√§ndnis werde ich dies in einer sehr vereinfachten Form schreiben: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Logger::Update() { Log(<span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span>&gt;(cpuDiagnostic.GetLastError()) ; Log(<span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span>&gt;(measureDiagstic.GetLastError()) ; }</code> </pre><br>  Es ist klar, dass wir beim Konvertieren der Aufz√§hlungstypen in eine Ganzzahl denselben Wert f√ºr verschiedene Typen erhalten k√∂nnen.  Wie kann man unterscheiden, dass der erste Fehlercode der Fehlercode des CPU-Diagnose-Subsystems und des zweiten Mess-Subsystems ist? <br><br><h3>  Suche nach L√∂sungen </h3><br>  Es w√§re logisch, <code>GetLastError()</code> die <code>GetLastError()</code> -Methode unterschiedlichen Code f√ºr unterschiedliche Subsysteme <code>GetLastError()</code> .  Eine der direktesten Entscheidungen auf der Stirn w√§re die Verwendung unterschiedlicher Codebereiche f√ºr jeden aufgez√§hlten Typ.  So etwas in der Art <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> tU32 CPU_ERROR_ALU = <span class="hljs-number"><span class="hljs-number">0x10000001</span></span> ; <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> tU32 CPU_ERROR_ROM = <span class="hljs-number"><span class="hljs-number">0x10000002</span></span> ; ... <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> tU32 MEAS_ERROR_OUTOF = <span class="hljs-number"><span class="hljs-number">0x01000001</span></span> ; <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> tU32 MEAS_ERROR_BAD = <span class="hljs-number"><span class="hljs-number">0x01000002</span></span> ; ... <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Cpu_Error</span></span></span><span class="hljs-class"> {</span></span> Ok, Alu = CPU_ERROR_ALU, Rom = CPU_ERROR_ROM, Ram = CPU_ERROR_RAM } ; ...</code> </pre><br>  Ich denke, die Nachteile dieses Ansatzes liegen auf der Hand.  Erstens m√ºssen Sie bei viel manueller Arbeit die Bereiche und R√ºckkehrcodes manuell bestimmen, was sicherlich zu einem menschlichen Fehler f√ºhren wird.  Zweitens kann es viele Subsysteme geben, und das Hinzuf√ºgen von Aufz√§hlungen f√ºr jedes Subsystem ist √ºberhaupt keine Option. <br><br>  Eigentlich w√§re es gro√üartig, wenn es m√∂glich w√§re, die √úbertragungen √ºberhaupt nicht zu ber√ºhren, ihre Codes auf eine etwas andere Weise zu erweitern, zum Beispiel, um dies tun zu k√∂nnen: <br><br><pre> <code class="cpp hljs">ResultCode result = Cpu_Error::Ok ; <span class="hljs-comment"><span class="hljs-comment">//GetLastError()   Cpu_Error result = cpuDiagnostic.GetLastError() ; if(result) //    { //       Logger::Log(result) ; } //GetLastError()   Measure_Error result = measureDiagnostic.GetLastError() ; if(result) //    { //       Logger::Log(result) ; }</span></span></code> </pre><br>  Oder so: <br><br><pre> <code class="cpp hljs">ReturnCode result ; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> it: diagnostics) { <span class="hljs-comment"><span class="hljs-comment">//GetLastError()     result = it.GetLastError() ; if (result) //    { Logger::Log(result) ; //      } }</span></span></code> </pre><br>  Oder so: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> CpuDiagnostic::SomeFunction(ReturnCode errocode) { Cpu_Error status = errorcode ; <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (status) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> CpuError::Alu: <span class="hljs-comment"><span class="hljs-comment">// do something ; break; .... } }</span></span></code> </pre><br>  Wie Sie dem Code <code>ReturnCode</code> wird hier eine Klasse <code>ReturnCode</code> verwendet, die sowohl den Fehlercode als auch dessen Kategorie enthalten sollte.  In der Standardbibliothek gibt es eine solche Klasse <code>std::error_code</code> , die eigentlich fast alles macht.  Sehr gut wird sein Zweck hier beschrieben: <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Dein eigener std :: code_error</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Unterst√ºtzung f√ºr Systemfehler in C ++</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Deterministische Ausnahmen und Fehlerbehandlung in ‚ÄûC ++ der Zukunft‚Äú</a> <br><br>  Die Hauptbeschwerde ist, dass wir zur Verwendung dieser Klasse <code>std::error_category</code> erben <code>std::error_category</code> , das f√ºr die Verwendung in Firmware auf kleinen Mikrocontrollern eindeutig stark √ºberlastet ist.  Sogar zumindest mit std :: string. <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CpuErrorCategory</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::error_category { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">char</span></span></span><span class="hljs-function"> * </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">name</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-function"><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">message</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> ev)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span></span>; };</code> </pre><br>  Dar√ºber hinaus m√ºssen Sie die Kategorie (Name und Nachricht) f√ºr jeden der aufgez√§hlten Typen manuell beschreiben.  Und auch der Code, der das Fehlen eines Fehlers in <code>std::error_code</code> ist 0. Und es gibt m√∂gliche F√§lle, in denen der Fehlercode f√ºr verschiedene Typen unterschiedlich ist. <br>  Ich m√∂chte keinen Overhead haben, au√üer eine Kategorienummer hinzuzuf√ºgen. <br><br>  Daher w√§re es logisch, etwas zu ‚Äûerfinden‚Äú, das es dem Entwickler erm√∂glicht, ein Minimum an Bewegungen auszuf√ºhren, um eine Kategorie f√ºr seinen aufgez√§hlten Typ hinzuzuf√ºgen. <br><br>  Zuerst m√ºssen Sie eine Klasse <code>std::error_code</code> , die <code>std::error_code</code> und in der Lage ist, jeden Aufz√§hlungstyp in eine Ganzzahl umzuwandeln und umgekehrt von einer Ganzzahl in einen Aufz√§hlungstyp.  Zus√§tzlich zu diesen Funktionen, um die Kategorie, den tats√§chlichen Wert des Codes zur√ºckgeben zu k√∂nnen und um Folgendes √ºberpr√ºfen zu k√∂nnen: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//GetLastError()   CpuError ReturnCode result(cpuDiagnostic.GetLastError()) ; if(result) //    { ... }</span></span></code> </pre><br><h3>  L√∂sung </h3><br>  Die Klasse muss den Fehlercode, den Kategoriecode und den Code, der der Abwesenheit von Fehlern entspricht, den Umwandlungsoperator und den Zuweisungsoperator speichern.  Die entsprechende Klasse lautet wie folgt: <br><br><img src="https://habrastorage.org/webt/v9/s3/nv/v9s3nvtgcu06simqv7mahn0h3fk.png"><br><br><div class="spoiler">  <b class="spoiler_title">Klassencode</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ReturnCode</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: ReturnCode() { } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">explicit</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ReturnCode</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">const</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">initReturnCode</span></span></span><span class="hljs-class">):</span></span> errorValue(<span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;tU32&gt;(initReturnCode)), errorCategory(GetCategory(initReturnCode)), goodCode(GetOk(initReturnCode)) { <span class="hljs-keyword"><span class="hljs-keyword">static_assert</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::is_enum&lt;T&gt;::value, <span class="hljs-string"><span class="hljs-string">"   "</span></span>) ; } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">operator</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">() </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">const</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-comment"><span class="hljs-comment">//Cast to only enum types static_assert(std::is_enum&lt;T&gt;::value, "   ") ; return static_cast&lt;T&gt;(errorValue) ; } tU32 GetValue() const { return errorValue; } tU32 GetCategoryValue() const { return errorCategory; } operator bool() const { return (GetValue() != goodCode); } template&lt;class T&gt; ReturnCode&amp; operator=(const T returnCode) { errorValue = static_cast&lt;tU32&gt;(returnCode) ; errorCategory = GetCategory(returnCode) ; goodCode = GetOk(returnCode) ; return *this ; } private: tU32 errorValue = 0U ; tU32 errorCategory = 0U ; tU32 goodCode = 0U ; } ;</span></span></code> </pre><br></div></div><br>  Es ist notwendig, ein wenig zu erkl√§ren, was hier passiert.  Beginnen Sie mit einem Vorlagenkonstruktor <br><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">explicit</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ReturnCode</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">const</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">initReturnCode</span></span></span><span class="hljs-class">):</span></span> errorValue(<span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;tU32&gt;(initReturnCode)), errorCategory(GetCategory(initReturnCode)), goodCode(GetOk(initReturnCode)) { <span class="hljs-keyword"><span class="hljs-keyword">static_assert</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::is_enum&lt;T&gt;::value, <span class="hljs-string"><span class="hljs-string">"   "</span></span>) ; }</code> </pre><br><br>  Sie k√∂nnen eine Objektklasse aus einem beliebigen Aufz√§hlungstyp erstellen: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">ReturnCode </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">result</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Cpu_Error::Ok)</span></span></span><span class="hljs-function"> </span></span>; <span class="hljs-function"><span class="hljs-function">ReturnCode </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">result1</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(My_Error::Error1)</span></span></span></span>; <span class="hljs-function"><span class="hljs-function">ReturnCode </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">result2</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(cpuDiagnostic.GetLatestError())</span></span></span><span class="hljs-function"> </span></span>;</code> </pre><br>  Um sicherzustellen, dass der Konstruktor nur einen Aufz√§hlungstyp akzeptieren kann, wird <code>static_assert</code> zu seinem Hauptteil hinzugef√ºgt, der beim Kompilieren den an den Konstruktor √ºbergebenen Typ mit <code>std::is_enum</code> und <code>std::is_enum</code> Fehler mit Klartext <code>std::is_enum</code> .  Hier wird kein echter Code generiert, dies ist alles f√ºr den Compiler.  Tats√§chlich ist dies also ein leerer Konstruktor. <br><br>  Der Konstruktor initialisiert auch private Attribute, darauf werde ich sp√§ter zur√ºckkommen ... <br>  Als n√§chstes der Darsteller: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">operator</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">() </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">const</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-comment"><span class="hljs-comment">//Cast to only enum types static_assert(std::is_enum&lt;T&gt;::value, "   ") ; return static_cast&lt;T&gt;(errorValue) ; }</span></span></code> </pre><br>  Es kann auch nur zu einem Aufz√§hlungstyp f√ºhren und erm√∂glicht uns Folgendes: <br><br><pre> <code class="cpp hljs"> <span class="hljs-function"><span class="hljs-function">ReturnCode </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">returnCode</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Cpu_Error::Rom)</span></span></span><span class="hljs-function"> </span></span>; Cpu_Error status = errorCode ; returnCode = My_Errror::Error2; My_Errror status1 = returnCode ; returnCode = myDiagnostic.GetLastError() ; MyDiagsonticError status2 = returnCode ;</code> </pre><br>  Gut und getrennt der Operator bool (): <br><br><pre> <code class="cpp hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">operator</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bool</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (GetValue() != goodCode); }</code> </pre><br>  Auf diese Weise k√∂nnen wir direkt pr√ºfen, ob der R√ºckkehrcode einen Fehler enth√§lt: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//GetLastError()   Cpu_Error ReturnCode result(cpuDiagnostic.GetLastError()) ; if(result) //    { ... }</span></span></code> </pre><br>  Das ist im Wesentlichen alles.  Die Frage bleibt in den Funktionen <code>GetCategory()</code> und <code>GetOkCode()</code> .  Wie Sie vielleicht erraten haben, ist der erste f√ºr den Aufz√§hlungstyp vorgesehen, um seine Kategorie irgendwie an die <code>ReturnCode</code> Klasse zu <code>ReturnCode</code> , und der zweite f√ºr den Aufz√§hlungstyp, um anzuzeigen, dass es sich um einen guten R√ºckkehrcode handelt, da wir ihn mit dem Operator <code>bool()</code> werden. <br><br>  Es ist klar, dass diese Funktionen vom Benutzer bereitgestellt werden k√∂nnen, und wir k√∂nnen sie in unserem Konstruktor √ºber den argumentabh√§ngigen Suchmechanismus ehrlich aufrufen. <br>  Zum Beispiel: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CategoryError</span></span></span><span class="hljs-class"> {</span></span> Nv = <span class="hljs-number"><span class="hljs-number">100</span></span>, Cpu = <span class="hljs-number"><span class="hljs-number">200</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Cpu_Error</span></span></span><span class="hljs-class"> {</span></span> Ok, Alu, Rom } ; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> tU32 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetCategory</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Cpu_Error errorNum)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;tU32&gt;(CategoryError::Cpu); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> tU32 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetOkCode</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Cpu_Error)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;tU32&gt;(Cpu_Error::Ok); }</code> </pre><br>  Dies erfordert zus√§tzlichen Aufwand vom Entwickler.  Wir ben√∂tigen f√ºr jeden Aufz√§hlungstyp, den wir kategorisieren m√∂chten, diese beiden Methoden hinzuzuf√ºgen und die <code>CategoryError</code> Aufz√§hlung zu aktualisieren. <br><br>  Wir m√∂chten jedoch, dass der Entwickler dem Code fast nichts hinzuf√ºgt und sich nicht darum k√ºmmert, wie er seinen Aufz√§hlungstyp erweitern kann. <br>  Was kann getan werden? <br><br><ul><li>  Erstens war es gro√üartig, dass die Kategorie automatisch berechnet wurde und der Entwickler <b>nicht</b> f√ºr jede Aufz√§hlung eine Implementierung der <code>GetCategory()</code> -Methode <code>GetCategory()</code> . </li><li>  Zweitens wird in 90% der F√§lle in unserem Code Ok verwendet, um guten Code zur√ºckzugeben.  Daher k√∂nnen Sie f√ºr diese 90% eine allgemeine Implementierung schreiben, und f√ºr 10% m√ºssen Sie sich spezialisieren. </li></ul><br>  Konzentrieren wir uns also auf die erste Aufgabe - die automatische Kategorieberechnung.  Die Idee meines Kollegen ist, dass der Entwickler seinen Aufz√§hlungstyp registrieren kann.  Dies kann mithilfe einer Vorlage mit einer variablen Anzahl von Argumenten erfolgen.  Deklarieren Sie eine solche Struktur <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span>... Types&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">EnumTypeRegister</span></span></span><span class="hljs-class">{</span></span>}; <span class="hljs-comment"><span class="hljs-comment">//    </span></span></code> </pre><br>  Um nun eine neue Aufz√§hlung zu registrieren, die um eine Kategorie erweitert werden soll, definieren wir einfach einen neuen Typ <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> CategoryErrorsList = EnumTypeRegister&lt;Cpu_Error, Measure_Error&gt;;</code> </pre><br>  Wenn wir pl√∂tzlich eine weitere Aufz√§hlung hinzuf√ºgen m√ºssen, f√ºgen Sie sie einfach der Liste der Vorlagenparameter hinzu: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> CategoryErrorsList = EnumTypeRegister&lt;Cpu_Error, Measure_Error, My_Error&gt;;</code> </pre><br>  Offensichtlich kann die Kategorie f√ºr unsere Auflistungen eine Position in der Liste der Vorlagenparameter sein, d.h.  f√ºr <code>Cpu_Error</code> es <b>0</b> , f√ºr <code>Measure_Error</code> es <b>1</b> , f√ºr <code>My_Error</code> es <b>2</b> .  Es bleibt, den Compiler zu zwingen, dies automatisch zu berechnen.  F√ºr C ++ 14 machen wir das: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> QueriedType, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Type&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constexpr</span></span></span><span class="hljs-function"> tU32 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetEnumPosition</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(EnumTypeRegister&lt;Type&gt;)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">static_assert</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::is_same&lt;Type, QueriedType&gt;::value, <span class="hljs-string"><span class="hljs-string">"     EnumTypeRegister"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> tU32(<span class="hljs-number"><span class="hljs-number">0U</span></span>) ; } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> QueriedType, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Type, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span>... Types&gt; <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">enable_if_t</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::is_same&lt;Type, QueriedType&gt;::value, tU32&gt; GetEnumPosition(EnumTypeRegister&lt;Type, Types...&gt;) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0U</span></span> ; } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> QueriedType, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Type, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span>... Types&gt; <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">enable_if_t</span></span>&lt;!<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::is_same&lt;Type, QueriedType&gt;::value, tU32&gt; GetEnumPosition(EnumTypeRegister&lt;Type, Types...&gt;) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1U</span></span> + GetEnumPosition&lt;QueriedType&gt;(EnumTypeRegister&lt;Types...&gt;()) ; }</code> </pre><br>  Was ist hier los?  Kurz gesagt, die Funktion <code>GetEnumPosition&lt;T&lt;&gt;&gt;</code> , wobei der Eingabeparameter eine Liste der Aufz√§hlungstypen von <code>EnumTypeRegister</code> , in unserem Fall <code>EnumTypeRegister&lt;Cpu_Error, Measure_Error, My_Error&gt;</code> , und der Vorlagenparameter <b>T</b> ist ein Aufz√§hlungstyp, dessen Index wir in dieser Liste finden sollten. l√§uft durch die Liste und wenn T mit einem der Typen in der Liste √ºbereinstimmt, gibt es seinen Index zur√ºck, andernfalls wird die Meldung "Typ ist nicht in der EnumTypeRegister-Liste registriert" angezeigt <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//..    constexpr EnumTypeRegister&lt;Cpu_Error, Measure_Error, My_Error&gt; list //  GetEnumPosition&lt;Measure_Error&gt;(list) //   1 -    Measure_Error   .</span></span></code> </pre><br>  Lassen Sie uns genauer analysieren.  Niedrigste Funktion <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> QueriedType, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Type, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span>... Types&gt; <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">enable_if_t</span></span>&lt;!<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::is_same&lt;Type, QueriedType&gt;::value, tU32&gt; GetEnumPosition(TypeRegister&lt;Type, Types...&gt;) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1U</span></span> + GetEnumPosition&lt;QueriedType&gt;(TypeRegister&lt;Types...&gt;()) ; }</code> </pre><br>  Hier pr√ºft der Zweig <code>std::enable_if_t&lt; <b>!std::is_same</b> ..</code> , ob der angeforderte Typ mit dem ersten Typ in der Vorlagenliste <code>std::enable_if_t&lt; <b>!std::is_same</b> ..</code> Wenn nicht, <code>GetEnumPosition</code> der zur√ºckgegebene Typ der <code>GetEnumPosition</code> Funktion <code>tU32</code> und dann wird der Funktionsk√∂rper ausgef√ºhrt, <code>tU32</code> ein rekursiver Aufruf derselben Funktion , w√§hrend die Anzahl der Vorlagenargumente um <b>1</b> abnimmt und der R√ºckgabewert um <b>1</b> zunimmt.  Das hei√üt, bei jeder Iteration wird es etwas √Ñhnliches geben: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//Iteration 1, 1+: tU32 GetEnumPosition&lt;T&gt;(EnumTypeRegister&lt;Cpu_Error, Measure_Error, My_Error&gt;) //Iteration 2, 1+1+: tU32 GetEnumPosition&lt;T&gt;(EnumTypeRegister&lt;Measure_Error, My_Error&gt;) //Iteration 3, 1+1+1: tU32 GetEnumPosition&lt;T&gt;(EnumTypeRegister&lt;My_Error&gt;)</span></span></code> </pre><br>  Sobald alle Typen in der Liste beendet sind, kann <code>std::enable_if_t</code> nicht mehr auf den Typ des R√ºckgabewerts der Funktion <code>GetEnumPosition()</code> , und an dieser Iteration endet: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//         GetEnumPosition&lt;T&gt;(TypeRegister&lt;&gt;) template &lt;typename QueriedType, typename Type&gt; constexpr tU32 GetEnumPosition(EnumTypeRegister&lt;Type&gt;) { static_assert(std::is_same&lt;Type, QueriedType&gt;::value, "     EnumTypeRegister"); return tU32(0U) ; }</span></span></code> </pre><br>  Was passiert, wenn der Typ in der Liste enthalten ist?  In diesem Fall funktioniert ein anderer Zweig, Zweig c <code>std::enable_if_t&lt; <b>std::is_same</b> ..</code> : <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> QueriedType, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Type, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span>... Types&gt; <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">enable_if_t</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::is_same&lt;Type, QueriedType&gt;::value, tU32&gt; GetEnumPosition(TypeRegister&lt;Type, Types...&gt;) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0U</span></span> ; }</code> </pre><br>  Hier wird <code><b>std::enable_if_t&lt; std::is_same ...</b></code> ob die Typen <code>std::enable_if_t&lt; <b>std::is_same</b> ...</code> Und wenn beispielsweise am Eingang ein Typ <code>Measure_Error</code> , wird die folgende Sequenz erhalten: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//Iteration 1, tU32 GetEnumPosition&lt;Measure_Error&gt;(EnumTypeRegister&lt;Cpu_Error, Measure_Error, My_Error&gt;) { return 1U + GetEnumPosition&lt;Measure_Error&gt;(EnumTypeRegister&lt;Measure_Error, My_Error&gt;) } //Iteration 2: tU32 GetEnumPosition&lt;Measure_Error&gt;(EnumTypeRegister&lt;Measure_Error, My_Error&gt;) { return 0 ; }</span></span></code> </pre><br>  Bei der zweiten Iteration endet der rekursive Funktionsaufruf und wir erhalten 1 (von der ersten Iteration) + 0 (von der zweiten) = <b>1</b> am Ausgang - dies ist ein Index vom Typ Measure_Error in der Liste <code>EnumTypeRegister&lt;Cpu_Error, Measure_Error, My_Error&gt;</code> <br><br>  Da dies eine <code>constexpr,</code> Funktion ist <code>constexpr,</code> alle Berechnungen in der Kompilierungsphase durchgef√ºhrt und es wird tats√§chlich kein Code generiert. <br><br>  All dies konnte nicht geschrieben werden, steht C ++ 17 zur Verf√ºgung.  Leider unterst√ºtzt mein IAR-Compiler C ++ 17 nicht vollst√§ndig, sodass das gesamte Fu√ütuch durch den folgenden Code ersetzt werden konnte: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//for C++17 template &lt;typename QueriedType, typename Type, typename... Types&gt; constexpr tU32 GetEnumPosition(EnumTypeRegister&lt;Type, Types...&gt;) { //        if constexpr (std::is_same&lt;Type, QueriedType&gt;::value) { return 0U ; } else { return 1U + GetEnumPosition&lt;QueriedType&gt;(EnumTypeRegister&lt;Types...&gt;()) ; } }</span></span></code> </pre><br>  Es bleiben nun die Vorlagenmethoden <code>GetCategory()</code> und <code>GetOk()</code> , die <code>GetEnumPosition</code> . <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constexpr</span></span></span><span class="hljs-function"> tU32 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetCategory</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> T)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;tU32&gt;(GetEnumPosition&lt;T&gt;(categoryDictionary)); } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constexpr</span></span></span><span class="hljs-function"> tU32 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetOk</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> T)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;tU32&gt;(T::Ok); }</code> </pre><br>  Das ist alles.  Mal sehen, was mit dieser Objektkonstruktion passiert: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">ReturnCode </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">result</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Measure_Error::Ok)</span></span></span><span class="hljs-function"> </span></span>;</code> </pre><br>  <code>ReturnCode</code> wir zum Konstruktor der <code>ReturnCode</code> Klasse zur√ºck <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">explicit</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ReturnCode</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">const</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">initReturnCode</span></span></span><span class="hljs-class">):</span></span> errorValue(<span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;tU32&gt;(initReturnCode)), errorCategory(GetCategory(initReturnCode)), goodCode(GetOk(initReturnCode)) { <span class="hljs-keyword"><span class="hljs-keyword">static_assert</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::is_enum&lt;T&gt;::value, <span class="hljs-string"><span class="hljs-string">"The type have to be enum"</span></span>) ; }</code> </pre><br>  Es handelt sich um eine Vorlage, und wenn <code>T</code> ein <code>Measure_Error</code> bedeutet dies, dass die Instanziierung der <code>GetCategory(Measure_Error)</code> -Methodenvorlage f√ºr den Typ <code>Measure_Error</code> , der wiederum <code>GetEnumPosition</code> mit dem Typ <code>Measure_Error</code> , <code>GetEnumPosition&lt;Measure_Error&gt;(EnumTypeRegister&lt;Cpu_Error, Measure_Error, My_Error&gt;)</code> <code>Measure_Error</code> gibt die Position von <code>Measure_Error</code> in der Liste zur√ºck.  Position ist <b>1</b> .  Und tats√§chlich wird der gesamte Konstruktorcode bei der Instanziierung des <code>Measure_Error</code> Typs durch den Compiler ersetzt durch: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">explicit</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ReturnCode</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Measure_Error initReturnCode)</span></span></span><span class="hljs-function">: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">errorValue</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">1</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function">, </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">errorCategory</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">1</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function">, </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">goodCode</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">1</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ }</code> </pre><br><h3>  Zusammenfassung </h3><br>  F√ºr einen Entwickler, der <code>ReturnCode</code> verwenden <code>ReturnCode</code> gibt es nur eines: <br>  Registrieren Sie Ihren Aufz√§hlungstyp in der Liste. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Add enum in the category using CategoryErrorsList = EnumTypeRegister&lt;Cpu_Error, Measure_Error, My_Error&gt;;</span></span></code> </pre><br>  Und keine unn√∂tigen Bewegungen, der vorhandene Code bewegt sich nicht und f√ºr die Erweiterung m√ºssen Sie nur den Typ in der Liste registrieren.  Dar√ºber hinaus wird dies alles in der Kompilierungsphase durchgef√ºhrt, und der Compiler berechnet nicht nur alle Kategorien, sondern warnt Sie auch, wenn Sie vergessen haben, den Typ zu registrieren, oder versucht haben, einen nicht nicht aufz√§hlbaren Typ zu √ºbergeben. <br><br>  Fairerweise ist anzumerken, dass Sie in den 10% des Codes, in denen die Aufz√§hlungen anstelle des Ok-Codes einen anderen Namen haben, Ihre eigene Spezialisierung f√ºr diesen Typ vornehmen m√ºssen. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> tU32 GetOk&lt;MyError&gt;(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> MyError) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;tU32&gt;(MyError::Good) ; } ;</code> </pre><br>  Ich habe hier ein kleines Beispiel gepostet: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Codebeispiel</a> <br><br>  Im Allgemeinen ist hier eine Anwendung: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Cpu_Error</span></span></span><span class="hljs-class"> {</span></span> Ok, Alu, Rom, Ram } ; <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Measure_Error</span></span></span><span class="hljs-class"> {</span></span> OutOfLimits, Ok, BadCode } ; <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">My_Error</span></span></span><span class="hljs-class"> {</span></span> Error1, Error2, Error3, Error4, Ok } ; <span class="hljs-comment"><span class="hljs-comment">// Add enum in the category list using CategoryErrorsList = EnumTypeRegister&lt;Cpu_Error, Measure_Error, My_Error&gt;; Cpu_Error CpuCheck() { return Cpu_Error::Ram; } My_Error MyCheck() { return My_Error::Error4; } int main() { ReturnCode result(CpuCheck()); //cout &lt;&lt; " Return code: "&lt;&lt; result.GetValue() // &lt;&lt; " Return category: "&lt;&lt; result.GetCategoryValue() &lt;&lt; endl; if (result) //if something wrong { result = MyCheck() ; // cout &lt;&lt; " Return code: "&lt;&lt; result.GetValue() // &lt;&lt; " Return category: "&lt;&lt; result.GetCategoryValue() &lt;&lt; endl; } result = Measure_Error::BadCode ; //cout &lt;&lt; " Return code: "&lt;&lt; result.GetValue() // &lt;&lt; " Return category: "&lt;&lt; result.GetCategoryValue() &lt;&lt; endl; result = Measure_Error::Ok ; if (!result) //if all is Ok { Measure_Error mError = result ; if (mError == Measure_Error::Ok) { // cout &lt;&lt; "mError: "&lt;&lt; tU32(mError) &lt;&lt; endl; } } return 0; }</span></span></code> </pre> <br>  Drucken Sie die folgenden Zeilen: <br><blockquote>  R√ºckkehrcode: 3 R√ºckkehrkategorie: 0 <br>  R√ºckkehrcode: 3 R√ºckkehrkategorie: 2 <br>  R√ºckkehrcode: 2 R√ºckkehrkategorie: 1 <br>  mError: 1 <br></blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de441956/">https://habr.com/ru/post/de441956/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de441944/index.html">Warum wir uns f√ºr den Lexus RX450h entschieden haben</a></li>
<li><a href="../de441946/index.html">REST-API auf Laravel in 100 Codezeilen</a></li>
<li><a href="../de441950/index.html">Eclipse Che 7 ist schon da</a></li>
<li><a href="../de441952/index.html">Auswahl eines Dateispeichersystems f√ºr die Teamarbeit</a></li>
<li><a href="../de441954/index.html">Benutzerbelohnung an Habrs Autoren</a></li>
<li><a href="../de441962/index.html">Indizes in PostgreSQL - 1</a></li>
<li><a href="../de441964/index.html">Tipps und Tricks von Kubernetes: Verschieben von Clusterressourcen auf Helm 2</a></li>
<li><a href="../de441966/index.html">Starter Kit zum Testen der Web-Sicherheit</a></li>
<li><a href="../de441968/index.html">Entwicklung einer neuen Produktbranche: Wie man Unpraktisches loswird und n√ºtzlich bleibt</a></li>
<li><a href="../de441970/index.html">FinFisher Butkit-Analyse</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>