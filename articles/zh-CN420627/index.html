<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🎪 👩🏼‍🏭 🆒 C＃异步编程：您如何处理性能？ 😠 ♒️ 💃🏾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="最近，我们已经讨论过在C＃中进行编程时是否覆盖Equals和GetHashCode。 今天，我们将处理异步方法的性能参数。 立即加入！ 



 在msdn博客的最后两篇文章中，我们介绍了C＃中异步方法的内部结构以及C＃编译器提供的用于控制异步方法行为的扩展点 。 

 根据第一篇文章中的信息，编译...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>C＃异步编程：您如何处理性能？</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/microsoft/blog/420627/"> 最近，我们已经<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">讨论</a>过在C＃中进行编程时是否覆盖Equals和GetHashCode。 今天，我们将处理异步方法的性能参数。 立即加入！ <br><br><img src="https://habrastorage.org/webt/ag/zp/yy/agzpyy85elnfvb3vg4qotz0wt6s.jpeg"><a name="habracut"></a><br><br> 在msdn博客的最后两篇文章中，我们介绍<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">了C＃中异步方法</a>的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">内部结构</a>以及C＃编译器提供的用于控制异步方法行为<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">的扩展点</a> 。 <br><br> 根据第一篇文章中的信息，编译器执行许多转换，以使异步编程尽可能类似于同步。 为此，他创建了状态机的实例，将其传递给异步方法的构建器，该方法调用任务的等待者对象，等等。当然，这种逻辑有代价，但是要花多少钱呢？ <br><br> 直到TPL库出现，异步操作才被大量使用，因此成本并不高。 但是今天，即使是一个相对简单的应用程序也可以每秒执行数百甚至数千个异步操作。  TPL并行任务库是在考虑到此类工作负载的情况下创建的，但是这里没有魔术，您必须付出一切。 <br><br> 为了估算异步方法的成本，我们将使用第一篇文章中经过稍微修改的示例。 <br><br><pre><code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">StockPrices</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Count = <span class="hljs-number"><span class="hljs-number">100</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> List&lt;(<span class="hljs-keyword"><span class="hljs-keyword">string</span></span> name, <span class="hljs-keyword"><span class="hljs-keyword">decimal</span></span> price)&gt; _stockPricesCache; <span class="hljs-comment"><span class="hljs-comment">// Async version public async Task&lt;decimal&gt; GetStockPriceForAsync(string companyId) { await InitializeMapIfNeededAsync(); return DoGetPriceFromCache(companyId); } // Sync version that calls async init public decimal GetStockPriceFor(string companyId) { InitializeMapIfNeededAsync().GetAwaiter().GetResult(); return DoGetPriceFromCache(companyId); } // Purely sync version public decimal GetPriceFromCacheFor(string companyId) { InitializeMapIfNeeded(); return DoGetPriceFromCache(companyId); } private decimal DoGetPriceFromCache(string name) { foreach (var kvp in _stockPricesCache) { if (kvp.name == name) { return kvp.price; } } throw new InvalidOperationException($"Can't find price for '{name}'."); } [MethodImpl(MethodImplOptions.NoInlining)] private void InitializeMapIfNeeded() { // Similar initialization logic. } private async Task InitializeMapIfNeededAsync() { if (_stockPricesCache != null) { return; } await Task.Delay(42); // Getting the stock prices from the external source. // Generate 1000 items to make cache hit somewhat expensive _stockPricesCache = Enumerable.Range(1, Count) .Select(n =&gt; (name: n.ToString(), price: (decimal)n)) .ToList(); _stockPricesCache.Add((name: "MSFT", price: 42)); } }</span></span></code> </pre> <br>  <code>StockPrices</code>类从外部来源<code>StockPrices</code>股票价格，并允许您通过API请求价格。 与第一篇文章中的示例的主要区别是从字典到价格列表的过渡。 为了估算与同步方法相比各种异步方法的成本，操作本身必须完成一定的工作，在我们的案例中，这是对股价的线性搜索。 <br><br>  <code>GetPricesFromCache</code>方法<code>GetPricesFromCache</code>故意围绕一个简单的循环构建的，以避免资源分配。 <br><br><h2> 同步方法和基于任务的异步方法的比较 </h2><br> 在第一个性能测试中，我们比较了调用异步初始化方法（ <code>GetStockPriceForAsync</code> ）的异步方法，调用异步初始化方法（ <code>GetStockPriceFor</code> ）的同步方法以及调用同步初始化方法的同步方法。 <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> StockPrices _stockPrices = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StockPrices(); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SyncVsAsyncBenchmark</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-comment"><span class="hljs-comment">// Warming up the cache _stockPrices.GetStockPriceForAsync("MSFT").GetAwaiter().GetResult(); } [Benchmark] public decimal GetPricesDirectlyFromCache() { return _stockPrices.GetPriceFromCacheFor("MSFT"); } [Benchmark(Baseline = true)] public decimal GetStockPriceFor() { return _stockPrices.GetStockPriceFor("MSFT"); } [Benchmark] public decimal GetStockPriceForAsync() { return _stockPrices.GetStockPriceForAsync("MSFT").GetAwaiter().GetResult(); }</span></span></code> </pre><br> 结果如下所示： <br><br><img src="https://habrastorage.org/webt/nc/cb/zd/nccbzd9-gv5ehroih0zxvdofc20.png"><br><br> 在这个阶段，我们已经收到了非常有趣的数据： <br><br><ul><li> 异步方法非常快。  <code>GetPricesForAsync</code>在此测试中同步运行，比纯同步方法慢大约15％（*）。 </li><li> 调用异步<code>InitializeMapIfNeededAsync</code>方法的同步<code>GetPricesFor</code>方法的成本更低，但最令人惊讶的是，它根本不分配资源（在上表的Allocated列中， <code>GetPricesDirectlyFromCache</code>和<code>GetStockPriceFor</code>成本均为0）。 </li></ul><br>  <i>（*）当然，不能说在所有可能的情况下同步执行异步方法的成本都是15％。</i>  <i>该值直接取决于该方法执行的工作量。</i>  <i>纯调用异步方法（不执行任何操作）和同步方法（不执行任何操作）的开销之间的差异将很大。</i>  <i>该比较测试的思想是表明异步方法的成本相对较低，该方法执行的工作量较小。</i> <br><br> 调用<code>InitializeMapIfNeededAsync</code> ，资源根本没有分配吗？ 在本系列的第一篇文章中，我提到异步方法应在托管标头中分配至少一个对象-任务实例本身。 让我们更详细地讨论这一点。 <br><br><h2> 优化＃1：尽可能缓存任务实例 </h2><br> 上面的问题的答案非常简单： <code>AsyncMethodBuilder</code> <b>对每个成功完成的异步操作使用任务的一个实例</b> 。  <code>Task</code>返回的异步方法在<code>SetResult</code>方法中使用具有以下逻辑的<code>AsyncMethodBuilder</code> ： <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// AsyncMethodBuilder.cs from mscorlib public void SetResult() { // Ie the resulting task for all successfully completed // methods is the same -- s_cachedCompleted. m_builder.SetResult(s_cachedCompleted); }</span></span></code> </pre> <br> 仅对成功完成的异步方法调用<code>SetResult</code>方法，并且<b>可以自由地一起使用每个基于<code>Task</code>的方法</b>的<b>成功结果</b> 。 我们甚至可以通过以下测试来跟踪这种行为： <br><br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">Test</span></span>] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AsyncVoidBuilderCachesResultingTask</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> t1 = Foo(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> t2 = Foo(); Assert.AreSame(t1, t2); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> Task </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Foo</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { } }</code> </pre><br> 但这不是唯一可能的优化。  <code>AsyncTaskMethodBuilder&lt;T&gt;</code>以类似的方式优化工作：缓存任务<code>Task&lt;bool&gt;</code>和其他一些简单类型的任务。 例如，它缓存一组整数类型的所有默认值，并对<code>Task&lt;int&gt;</code>使用特殊的缓存，放置范围[-1;  9]（有关更多详细信息，请参见<code>AsyncTaskMethodBuilder&lt;T&gt;.GetTaskForResult()</code> ）。 <br><br> 以下测试证实了这一点： <br><br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">Test</span></span>] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AsyncTaskBuilderCachesResultingTask</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-comment"><span class="hljs-comment">// These values are cached Assert.AreSame(Foo(-1), Foo(-1)); Assert.AreSame(Foo(8), Foo(8)); // But these are not Assert.AreNotSame(Foo(9), Foo(9)); Assert.AreNotSame(Foo(int.MaxValue), Foo(int.MaxValue)); async Task&lt;int&gt; Foo(int n) =&gt; n; }</span></span></code> </pre><br>  <b>不要过度依赖这种行为</b> ，但是总是很高兴认识到语言和平台的创建者正在尽一切可能以所有可用的方式提高生产率。 任务缓存是一种流行的优化方法，也用于其他领域。 例如， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">corefx</a>存储库中<code>Socket</code>的新实现广泛使用了此方法，并在可能的情况下应用了<a href="">缓存的任务</a> 。 <br><br><h2> 优化＃2：使用<code>ValueTask</code> </h2><br> 上述优化方法仅在少数情况下有效。 因此，代替它，我们可以使用<code>ValueTask&lt;T&gt;</code> （**），这是一种类似于任务的特殊类型的值。 如果该方法同步运行，它将不会分配资源。 <br><br>  <code>ValueTask&lt;T&gt;</code>是<code>T</code>和<code>Task&lt;T&gt;</code>的可区分组合：如果“ value-task”完成，则将使用基值。 如果基本分配尚未用尽，则将为该任务分配资源。 <br><br> 同步执行操作时，此特殊类型有助于防止过多的堆置备。 要使用<code>ValueTask&lt;T&gt;</code> ，您需要更改<code>GetStockPriceForAsync</code>的返回类型：而不是<code>Task&lt;decimal&gt;</code>应指定<code>ValueTask&lt;decimal&gt;</code> ： <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> ValueTask&lt;</span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">decimal</span></span></span><span class="hljs-function">&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetStockPriceForAsync</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> companyId</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> InitializeMapIfNeededAsync(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> DoGetPriceFromCache(companyId); }</code> </pre><br> 现在，我们可以使用其他比较测试来评估差异： <br><br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">Benchmark</span></span>] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">decimal</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetStockPriceWithValueTaskAsync_Await</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _stockPricesThatYield.GetStockPriceValueTaskForAsync(<span class="hljs-string"><span class="hljs-string">"MSFT"</span></span>).GetAwaiter().GetResult(); }</code> </pre><br><img src="https://habrastorage.org/webt/ek/pm/o5/ekpmo5bxsquftyndmelvwgsgjsc.png"><br><br> 如您所见，使用<code>ValueTask</code>的版本仅比使用Task的版本快一点。 主要区别是防止堆分配。 稍后，我们将讨论这种过渡的可行性，但在此之前，我想谈一谈棘手的优化。 <br><br><h2> 优化之三：在通用路径中放弃异步方法 </h2><br> 如果您经常使用某种异步方法并希望进一步降低成本，建议您进行以下优化：删除async修饰符，然后检查方法内部任务的状态并同步执行整个操作，完全放弃异步方法。 <br><br> 看起来复杂吗？ 考虑一个例子。 <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> ValueTask&lt;</span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">decimal</span></span></span><span class="hljs-function">&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetStockPriceWithValueTaskAsync_Optimized</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> companyId</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> task = InitializeMapIfNeededAsync(); <span class="hljs-comment"><span class="hljs-comment">// Optimizing for acommon case: no async machinery involved. if (task.IsCompleted) { return new ValueTask&lt;decimal&gt;(DoGetPriceFromCache(companyId)); } return DoGetStockPricesForAsync(task, companyId); async ValueTask&lt;decimal&gt; DoGetStockPricesForAsync(Task initializeTask, string localCompanyId) { await initializeTask; return DoGetPriceFromCache(localCompanyId); } }</span></span></code> </pre><br> 在这种情况下， <code>GetStockPriceWithValueTaskAsync_Optimized</code>方法中未使用<code>async</code>修饰符，因此当它从<code>InitializeMapIfNeededAsync</code>方法接收任务时，它将检查其执行状态。 如果任务完成，则该方法仅使用<code>DoGetPriceFromCache</code>立即获取结果。 如果初始化任务仍在进行中，则该方法将调用本地函数并等待结果。 <br><br> 使用局部函数不是唯一的方法，而是最简单的方法之一。 但是有一个警告。 在最自然的实现过程中，局部函数将接收外部状态（局部变量和参数）： <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> ValueTask&lt;</span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">decimal</span></span></span><span class="hljs-function">&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetStockPriceWithValueTaskAsync_Optimized2</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> companyId</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-comment"><span class="hljs-comment">// Oops! This will lead to a closure allocation at the beginning of the method! var task = InitializeMapIfNeededAsync(); // Optimizing for acommon case: no async machinery involved. if (task.IsCompleted) { return new ValueTask&lt;decimal&gt;(DoGetPriceFromCache(companyId)); } return DoGetStockPricesForAsync(); async ValueTask&lt;decimal&gt; DoGetStockPricesForAsync() { await task; return DoGetPriceFromCache(companyId); } }</span></span></code> </pre><br> 但是，不幸的是，由于<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">编译器错误</a> ，即使该方法在公共路径中执行<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">，</a>此代码也将生成一个关闭。 这是从内部看这种方法的样子： <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> ValueTask&lt;</span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">decimal</span></span></span><span class="hljs-function">&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetStockPriceWithValueTaskAsync_Optimized</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> companyId</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> closure = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> __DisplayClass0_0() { __this = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, companyId = companyId, task = InitializeMapIfNeededAsync() }; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (closure.task.IsCompleted) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ... } <span class="hljs-comment"><span class="hljs-comment">// The rest of the code }</span></span></code> </pre><br> 正如在“ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">剖析C＃中的局部函数</a> ”一文中讨论的那样，编译器对特定区域中的所有局部变量和参数使用一个通用的闭包实例。 因此，这种代码生成具有某种意义，但是这使得分配堆的整个工作变得毫无用处。 <br><br>  <b>提示</b> 。 这样的优化是非常隐蔽的事情。 好处是微不足道的，即使您编写了<b>正确的</b>原始本地函数，也可能会意外地获得导致分配堆的外部状态。 如果使用肯定会在代码的已加载部分中使用的方法的常用库（例如BCL），您仍然可以诉诸优化。 <br><br><h4> 与等待任务相关的费用 </h4><br> 目前，我们仅考虑了一种特定情况：同步运行的异步方法的开销。 这是有目的的。 异步方法越小，其总体性能成本就越明显。 通常，更详细的异步方法将同步运行并执行较小的工作量。 而且我们通常会更频繁地致电给他们。 <br><br> 但是，当方法“等待”完成未完成的任务时，我们必须意识到异步机制的成本。 为了估算这些成本，我们将对<code>InitializeMapIfNeededAsync</code>进行更改，即使在初始化缓存时也将调用<code>Task.Yield()</code> ： <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> Task </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">InitializeMapIfNeededAsync</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_stockPricesCache != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> Task.Yield(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } <span class="hljs-comment"><span class="hljs-comment">// Old initialization logic }</span></span></code> </pre><br> 我们在基准测试包中添加了以下方法进行比较测试： <br><br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">Benchmark</span></span>] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">decimal</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetStockPriceFor_Await</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _stockPricesThatYield.GetStockPriceFor(<span class="hljs-string"><span class="hljs-string">"MSFT"</span></span>); } [Benchmark] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">decimal</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetStockPriceForAsync_Await</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _stockPricesThatYield.GetStockPriceForAsync(<span class="hljs-string"><span class="hljs-string">"MSFT"</span></span>).GetAwaiter().GetResult(); } [Benchmark] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">decimal</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetStockPriceWithValueTaskAsync_Await</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _stockPricesThatYield.GetStockPriceValueTaskForAsync(<span class="hljs-string"><span class="hljs-string">"MSFT"</span></span>).GetAwaiter().GetResult(); }</code> </pre><br><img src="https://habrastorage.org/webt/d9/hm/qt/d9hmqtsqod_pexw3xdmfprfww2m.png"><br><br> 如您所见，在速度和内存使用方面，两者之间的差异是显而易见的。 简要解释结果。 <br><br><ul><li> 每个未完成任务的等待操作大约需要4微秒，并为每个调用分配近300个字节（**）。 这就是为什么GetStockPriceFor运行速度几乎是GetStockPriceForAsync的两倍，并且分配的内存更少。 </li><li> 当此方法不同步执行时，基于ValueTask的异步方法所需的时间要比Task的变体长一些。 与基于Task &lt;T&gt;的方法的状态机相比，基于ValueTask &lt;T&gt;的方法的状态机应存储更多的数据。 </li></ul><br>  <i>（**）它取决于平台（x64或x86）以及异步方法的许多局部变量和参数。</i> <br><br><h4> 异步方法性能101 </h4><br><ul><li> 如果异步方法同步运行，那么开销将很小。 </li><li> 如果异步方法是同步执行的，则会发生以下内存开销：对于异步Task方法，没有开销，对于异步Task &lt;T&gt;方法，每个操作的溢出量为88字节（对于x64平台）。 </li><li>  ValueTask &lt;T&gt;消除了同步执行的异步方法的上述开销。 </li><li> 当基于ValueTask &lt;T&gt;的异步方法被同步执行时，它所花费的时间比使用Task &lt;T&gt;的方法要少一些，否则在支持第二个选项上会有细微的差异。 </li><li> 等待完成未完成任务的异步方法的性能开销要高得多（对于x64平台，每个操作大约300个字节）。 </li></ul><br> 当然，测量是我们的一切。 如果看到异步操作导致性能问题，则可以从<code>Task&lt;T&gt;</code>切换到<code>ValueTask&lt;T&gt;</code> ，缓存任务，或在可能的情况下使整个执行路径同步。 您也可以尝试聚合异步操作。 通常，这将有助于提高性能，简化调试和代码分析。  <b>并非每小段代码都应该是异步的。</b> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN420627/">https://habr.com/ru/post/zh-CN420627/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN420615/index.html">JavaScript：探索对象</a></li>
<li><a href="../zh-CN420617/index.html">开发人员网页设计指南</a></li>
<li><a href="../zh-CN420619/index.html">自适应图像：节省时间的CSS技巧</a></li>
<li><a href="../zh-CN420623/index.html">尽力而为的分布式C ++应用程序</a></li>
<li><a href="../zh-CN420625/index.html">KDD 2018，第一天，教程</a></li>
<li><a href="../zh-CN420629/index.html">PHP摘要137号（2018年8月6日至20日）</a></li>
<li><a href="../zh-CN420631/index.html">我们不怕“乌云”</a></li>
<li><a href="../zh-CN420633/index.html">在15分钟内用Grafana编写具有可视化效果的Prometheus GeoIP导出器</a></li>
<li><a href="../zh-CN420635/index.html">AI，实践课程。 识别图像中情绪的基本模型</a></li>
<li><a href="../zh-CN420637/index.html">WANHAO D9 / 300 3D打印机评论：视频</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>