<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🐱 👨🏽‍🏫 ⚗️ Bekerja dengan pohon sintaksis JavaScript abstrak 🏓 🚞 🧑🏼‍🤝‍🧑🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Mengapa menguraikan kode Anda? Misalnya, untuk menemukan console.log yang terlupakan sebelum melakukan. Tetapi bagaimana jika Anda perlu mengubah tand...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Bekerja dengan pohon sintaksis JavaScript abstrak</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/jugru/blog/428628/">  Mengapa menguraikan kode Anda?  Misalnya, untuk menemukan console.log yang terlupakan sebelum melakukan.  Tetapi bagaimana jika Anda perlu mengubah tanda tangan fungsi dalam ratusan entri dalam kode?  Akankah ekspresi reguler mengatasi di sini?  Artikel ini akan menunjukkan kepada Anda kemungkinan apa yang ditawarkan pohon sintaksis abstrak kepada pengembang. <br><br><img src="https://habrastorage.org/webt/l6/7k/fh/l67kfhnakjfo3vquzkyvklpwrns.png"><br><br>  Di bawah potongan - video dan transkrip teks dari laporan oleh Kirill Cherkashin ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" class="user_link">z6Dabrata</a> ) dari konferensi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">HolyJS 2018 Piter</a> . <br><a name="habracut"></a><br><iframe width="560" height="315" src="https://www.youtube.com/embed/ILSpvViUlPU" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  <i><b>Tentang penulis</b></i> <i><br></i>  <i>Cyril lahir di Moskow, sekarang tinggal di New York dan bekerja di Firebase.</i>  <i>Mengajar Angular tidak hanya di Google, tetapi di seluruh dunia.</i>  <i>Penyelenggara mitap Angular terbesar di dunia adalah AngularNYC (serta VueNYC dan ReactNYC).</i>  <i>Di waktu luangnya dari pemrograman, ia menyukai tango, buku, dan percakapan yang menyenangkan.</i> <br><br><h2>  Gergaji besi atau kayu? </h2><br>  Mari kita mulai dengan sebuah contoh: katakanlah Anda mendebug sebuah program dan mengirimkan perubahan yang dibuat ke git, setelah itu Anda pergi tidur dengan tenang.  Di pagi hari ternyata kolega Anda mengunduh perubahan Anda dan, karena Anda lupa menghapus output informasi debug ke konsol sehari sebelumnya, itu menampilkannya dan menyumbat output.  Banyak yang menghadapi masalah ini. <br><br>  Ada alat, seperti <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">EsLint</a> , untuk memperbaiki situasi, tetapi untuk tujuan pendidikan, mari kita coba mencari solusi sendiri. <br>  Alat mana yang harus saya gunakan untuk menghapus semua <code>console.log()</code> dari kode? <br>  Kami memilih antara ekspresi reguler dan penggunaan Abstract Sitax trees (ASD).  Mari kita coba selesaikan ini dengan ekspresi reguler dengan menulis beberapa fungsi <code>findConsoleLog</code> .  Pada input, ia akan menerima kode program sebagai argumen dan menampilkan true jika console.log () ditemukan di suatu tempat dalam teks program. <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">findConsoleLog</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">code</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> !!code.match(<span class="hljs-regexp"><span class="hljs-regexp">/console.log/</span></span>); }</code> </pre><br>  Saya menulis 17 tes, mencoba menemukan berbagai cara untuk merusak fungsi kami.  Daftar ini jauh dari lengkap. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/c28/d83/9c4/c28d839c4c1450db0e7d752667ffd4c8.png"><br><br>  Tes paling sederhana berlalu. <br>  Dan bagaimana jika ada fungsi yang berisi string "console.log" dalam namanya? <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">findConsoleLog</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">code</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> !!code.match(<span class="hljs-regexp"><span class="hljs-regexp">/\bconsole.log/</span></span>); }</code> </pre><br>  Menambahkan karakter yang menunjukkan bahwa <code>console.log</code> harus muncul di awal kata. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/3cf/d71/598/3cfd715980aec5c9ead2421d87679fe8.jpg"><br><br>  Hanya dua tes yang lulus, tetapi bagaimana jika <code>console.log</code> ada di komentar dan tidak perlu dihapus? <br><br>  Kami menulis ulang sehingga parser tidak menyentuh komentar. <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">findConsoleLog</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">code</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> !!code   .replace(<span class="hljs-regexp"><span class="hljs-regexp">/\/\/.*/</span></span>)   .match(<span class="hljs-regexp"><span class="hljs-regexp">/\bconsole.log/</span></span>); }</code> </pre><br><img src="https://habrastorage.org/getpro/habr/post_images/a24/518/df4/a24518df4bd82e31257e50f4723083da.jpg"><br><br>  Kami mengecualikan penghapusan "console.log" dari baris: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">findConsoleLog</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">code</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> !!code   .replace(<span class="hljs-regexp"><span class="hljs-regexp">/\/\/.*|'.*'/</span></span>, <span class="hljs-string"><span class="hljs-string">''</span></span>)   .match(<span class="hljs-regexp"><span class="hljs-regexp">/\bconsole.log/</span></span>); }</code> </pre><br><img src="https://habrastorage.org/getpro/habr/post_images/832/c81/94b/832c8194b5e62d995d939e798fc9f2af.jpg"><br><br>  Jangan lupa bahwa kami masih memiliki spasi dan karakter lain yang dapat mencegah beberapa tes lulus: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/077/793/86c/07779386cbd54babe9f0aff7db1c35f3.jpg"><br><br>  Terlepas dari kenyataan bahwa ide itu tidak cukup sederhana, semua 17 tes menggunakan ekspresi reguler dapat dilewati.  Di sini, dalam hal ini, kode solusi akan terlihat: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">findConsoleLog</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">code</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> code   .replace(<span class="hljs-regexp"><span class="hljs-regexp">/\/\/.*|'.*?[^\\]'|".*?"|`[\s\S]*`|\/\*[\s\S]*\*\//</span></span>)   .match(<span class="hljs-regexp"><span class="hljs-regexp">/\bconsole\s*.log\(/</span></span>); }</code> </pre><br><br>  Masalahnya adalah bahwa kode ini tidak mencakup semua kasus yang mungkin, dan agak sulit untuk mempertahankannya. <br><br>  Pertimbangkan cara mengatasi masalah ini menggunakan ASD. <br><br><h2>  Bagaimana pohon-pohon tumbuh? </h2><br>  Pohon sintaksis abstrak diperoleh sebagai hasil parser yang bekerja dengan kode aplikasi Anda.  Parser <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">@ babel / parser</a> digunakan untuk demonstrasi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">.</a> <br>  Sebagai contoh, ambil string <code>console.log('holy')</code> , sampaikan melalui parser. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { parse } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'babylon'</span></span>; parse(<span class="hljs-string"><span class="hljs-string">"console.log('holy')"</span></span>);</code> </pre><br>  Sebagai hasil karyanya, file JSON sekitar 300 baris diperoleh.  Kami mengecualikan dari garis nomor mereka dengan informasi layanan.  Kami tertarik pada bagian tubuh.  Meta-informasi juga tidak menarik bagi kita.  Hasilnya sekitar 100 baris.  Dibandingkan dengan struktur apa yang dihasilkan browser untuk satu variabel body (sekitar 300 baris), ini tidak banyak. <br><br>  Mari kita lihat beberapa contoh bagaimana berbagai literal direpresentasikan dalam kode di pohon sintaks: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/0d1/ca2/867/0d1ca286756a8f61b77edcff73ed95c1.jpg"><br><br>  Ini adalah ungkapan di mana ada Numeric Literal, literal numerik. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/4bd/c34/419/4bdc34419216b4a39c3636cee741cbab.png"><br><br>  Ekspresi console.log sudah akrab.  Ia memiliki objek yang memiliki properti. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/11e/860/609/11e8606097dc09b48bf993c0be5dbdff.jpg"><br><br>  Jika log adalah panggilan fungsi, maka deskripsinya adalah sebagai berikut: ada ekspresi panggilan, ia memiliki argumen - literal numerik.  Pada saat yang sama, ekspresi panggilan memiliki log nama. <br><br>  Literal dapat berbeda: angka, string, ekspresi reguler, boolean, null. <br>  Kembali ke panggilan console.log <br><br><img src="https://habrastorage.org/getpro/habr/post_images/9e1/4cb/2f2/9e14cb2f2efccc2fb7a43c4fa1945fd9.jpg"><br><br>  Ini adalah ekspresi panggilan yang memiliki Ekspresi Anggota di dalamnya.  Dari sini jelas bahwa objek konsol di dalamnya memiliki properti yang disebut log. <br><br><h2>  Bypass ASD </h2><br>  Sekarang mari kita coba bekerja dengan struktur ini dalam kode.  Perpustakaan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">babel-traverse</a> akan digunakan untuk melintasi pohon <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">.</a> <br><br>  17 tes yang sama diberikan.  Kode tersebut diperoleh dengan menganalisis pohon sintaks program dan mencari entri "console.log": <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">traverseConsoleLog</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">code, {babylon, babelTraverse, types, log}</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> ast = babylon.parse(code); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> hasConsoleLog = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; babelTraverse(ast, {   MemberExpression(path){     <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (       path.node.property.type === <span class="hljs-string"><span class="hljs-string">'Identifier'</span></span> &amp;&amp;       path.node.property.name === <span class="hljs-string"><span class="hljs-string">'log'</span></span> &amp;&amp;       path.node.object.type === <span class="hljs-string"><span class="hljs-string">'Identifier'</span></span> &amp;&amp;       path.node.object.name === <span class="hljs-string"><span class="hljs-string">'console'</span></span> &amp;&amp;       path.parent.type === <span class="hljs-string"><span class="hljs-string">'CallExpression'</span></span> &amp;&amp;       path.Parentkey === <span class="hljs-string"><span class="hljs-string">'callee'</span></span>     ) {       hasConsoleLog = <span class="hljs-literal"><span class="hljs-literal">true</span></span>;     }   } }) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> hasConsoleLog; }</code> </pre><br>  Mari kita analisis apa yang tertulis di sini. <code>const ast = babylon.parse(code);</code>  ke dalam variabel ast kita menguraikan pohon sintaksis dari kode.  Selanjutnya kita berikan pustaka babel-parse pohon ini untuk diproses.  Kami mencari simpul dan properti dengan nama yang cocok di dalam ekspresi panggilan.  Setel variabel hasConsoleLog menjadi true jika kombinasi node dan nama yang diperlukan ditemukan. <br><br>  Kita dapat bergerak di sekitar pohon, mengambil orang tua dari node, keturunan, mencari argumen dan properti apa yang mereka miliki, melihat nama-nama properti ini, jenis - ini sangat nyaman. <br><br>  Ada nuansa yang tidak menyenangkan yang dapat dengan mudah diperbaiki menggunakan perpustakaan tipe-babel.  Untuk menghindari kesalahan ketika mencari di pohon karena nama yang salah, misalnya, alih-alih <code>path.parent.type === 'CallExpression'</code> Anda tidak sengaja menulis <code>path.parent.type === 'callExpression'</code> , dengan tipe-babel Anda dapat menulis seperti ini : <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// Before path.node.property.type === 'Identifier' path.node.property.name === 'log' // with babel types import {isIdentifier} from 'babel-types'; isIdentifier(path.node.property, {name: log}) //         ,  ,    isIdentifier,     </span></span></code> </pre><br>  Kami menulis ulang kode sebelumnya menggunakan tipe-babel: <br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">traverseConsoleLogSolved2</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">code, {babylon, babelTraverse, types}</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> ast = babylon.parse(code); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> hasConsoleLog = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; babelTraverse(ast, {   MemberExpression(path) {     <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (       types.isIdentifier(path.node.object, { <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">'console'</span></span>}) &amp;&amp;       types.isIdentifier(path.node.property, { <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">'log'</span></span>}) &amp;&amp;       types.isCallExpression(path.parent) &amp;&amp;       path.parentKey === <span class="hljs-string"><span class="hljs-string">'callee'</span></span>     ) {       hasConsoleLog = <span class="hljs-literal"><span class="hljs-literal">true</span></span>;     }   } }); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> hasConsoleLog; }</code> </pre><br><h2>  Transform ASD menggunakan babel-traverse </h2><br>  Untuk mengurangi biaya tenaga kerja, kita perlu <code>console.log</code> segera dihapus dari kode - alih-alih sinyal bahwa kode itu ada dalam kode. <br><br>  Karena kita perlu menghapus bukan MemberExpression itu sendiri, tetapi induknya, di tempat <code>hasConsoleLog = true;</code>  kami menulis <code>path.parentPath.remove();</code>  . <br><br>  Dari fungsi <code>removeConsoleLog</code> , kami masih mengembalikan nilai Boolean.  Kami mengganti outputnya dengan kode yang akan menghasilkan generator-babel, seperti ini: <br>  <code>hasConsoleLog</code> =&gt; <code>babelGenerator(ast).code</code> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Babel-generator</a> menerima pohon sintaksis abstrak yang dimodifikasi sebagai parameter, mengembalikan objek dengan properti kode, di dalam objek ini kode dibuat ulang tanpa <code>console.log</code> .  Omong-omong, jika kita ingin mendapatkan peta kode, kita dapat memanggil properti sourceMaps untuk objek ini. <br><br><h2>  Dan jika Anda perlu menemukan debugger? </h2><br>  Kali ini kita akan menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ASTexplorer</a> untuk menyelesaikan tugas.  Debugger adalah jenis node pernyataan debugger.  Kita tidak perlu melihat keseluruhan struktur, karena ini adalah jenis simpul khusus, cukup temukan pernyataan debugger.  Kami akan menulis sebuah plugin untuk ESLint (di ASTexplorer). <br><br>  ASTexplorer dirancang sedemikian rupa sehingga Anda menulis kode di sebelah kiri, dan di sebelah kanan Anda mendapatkan ASD yang sudah selesai.  Anda dapat memilih dalam format mana Anda ingin menerimanya: JSON atau dalam format pohon. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/e91/ee0/ecc/e91ee0ecc1d31ec006dcb4e99fa04d49.jpg"><br><br>  Karena kita menggunakan ESLint, itu akan melakukan semua pekerjaan mencari file untuk kita dan memberi kita file yang diperlukan sehingga kita dapat menemukan baris debugger di dalamnya.  Alat ini menggunakan parser ASD yang berbeda.  Namun, ada beberapa jenis ASD dalam JavaScript.  Sesuatu yang mengingatkan masa lalu, ketika browser yang berbeda mengimplementasikan spesifikasi dengan cara yang berbeda.  Dengan demikian, kami menerapkan pencarian debugger: <br><br><pre> <code class="hljs lua">export default <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(context)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> {   DebuggerStatement(node) { // ,     console.<span class="hljs-built_in"><span class="hljs-built_in">log</span></span>    <span class="hljs-built_in"><span class="hljs-built_in">path</span></span>,    -  ,     <span class="hljs-built_in"><span class="hljs-built_in">path</span></span>         context.report(node, <span class="hljs-string"><span class="hljs-string">'LOL Debugger!!!'</span></span>); //   ESLint ,   debugger, node     ,    ,    debugger   } } }</code> </pre><br>  Memeriksa pekerjaan plugin tertulis: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/90e/334/3fe/90e3343fe59bb834c9725beeb925598b.jpg"><br><br>  Demikian pula, Anda dapat menghapus debugger dari kode. <br><br><h2>  Apa lagi ASD yang berguna </h2><br>  Saya pribadi menggunakan ASD untuk mempermudah bekerja dengan Angular dan kerangka kerja front-end lainnya.  Anda dapat mengimpor, memperluas, menambahkan antarmuka, metode, dekorator, dan hal lainnya dengan mengklik tombol.  Meskipun kita berbicara tentang Javascript dalam kasus ini, bagaimanapun, TypeScript juga memiliki ASD sendiri, satu-satunya perbedaan adalah perbedaan antara nama-nama jenis simpul dan struktur.  Dalam ASTExplorer yang sama dapat dipilih sebagai bahasa TypeScript. <br><br>  Jadi: <br><br><ul><li>  Kami memiliki kontrol lebih besar atas kode, refactoring lebih mudah, codemods.  Misalnya, sebelum melakukan, Anda dapat menekan satu tombol untuk memformat seluruh kode sesuai dengan pedoman.  Codemods menyiratkan pencocokan kode otomatis sesuai dengan versi kerangka kerja yang diperlukan. <br></li><li>  Lebih sedikit perselisihan tentang desain kode. <br></li><li>  Anda dapat membuat proyek game.  Misalnya, secara otomatis memberikan umpan balik kepada programmer tentang kode yang ia tulis. <br></li><li>  Pemahaman yang lebih baik tentang JavaScript. <br></li></ul><br><h2>  Beberapa tautan bermanfaat untuk Babel </h2><br><ol><li>  Semua transformasi Babel menggunakan API ini: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">plugins dan preset</a> . <br></li><li>  Bagian dari proses menambahkan fungsionalitas baru ke ECMAScript adalah membuat plugin untuk Babel.  Ini diperlukan agar orang dapat menguji fungsionalitas baru.  Jika Anda mengikuti <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tautan</a> , Anda dapat melihat bahwa di dalam yang sama digunakan kemampuan ASD.  Misalnya, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">operator penugasan-logis</a> . <br></li><li>  Babel Generator kehilangan pemformatan saat membuat kode.  Ini sebagian baik, karena jika alat ini digunakan dalam tim pengembangan, maka setelah menghasilkan kode dari ASD, itu akan terlihat sama untuk semua orang.  Tetapi jika Anda ingin tetap memformat, Anda dapat menggunakan salah satu dari alat ini: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Recast</a> atau <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Babel CodeMod</a> . <br></li><li>  Dari tautan ini Anda dapat menemukan banyak informasi tentang Babel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Awesome Babel</a> . <br></li><li>  Babel adalah proyek sumber terbuka dan tim sukarelawan sedang mengerjakannya.  Kamu bisa membantu.  Ada tiga cara untuk melakukan ini: bantuan keuangan, Anda dapat mendukung situs web patreon, tempat Henry Zhu, salah satu kontributor utama babel, bekerja, membantu dengan kode pada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">opencollective.com/babel</a> . <br></li></ol><br><h2>  Bonus </h2><br>  Bagaimana lagi kita bisa menemukan kode <code>console.log</code> kita?  Gunakan IDE Anda!  Menggunakan alat temukan dan ganti, setelah memilih tempat mencari kode. <br>  Intellij IDEA juga memiliki alat "pencarian struktural" yang dapat membantu Anda menemukan tempat yang tepat dalam kode Anda, dengan cara itu, ia menggunakan ASD. <br><br><blockquote>  <b>Pada 24-25 November,</b> Kirill akan <b>memberikan</b> presentasi tentang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">JavaScript * LOVES * data biner</a> di <b>Moscow HolyJS</b> : kita akan turun ke tingkat data biner, menggali file biner menggunakan file * .gif sebagai contoh, dan berurusan dengan kerangka kerja serialisasi seperti Protobuf atau Thrift.  Setelah laporan, akan mungkin untuk berbicara dengan Cyril dan membahas semua masalah yang menarik di bidang diskusi. </blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id428628/">https://habr.com/ru/post/id428628/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id428612/index.html">Fungsi tingkat tinggi dalam JavaScript: apa itu?</a></li>
<li><a href="../id428614/index.html">Jumat Ocehan Programmer 4.2</a></li>
<li><a href="../id428616/index.html">Konversikan file XLS ke Google Spreadsheet menggunakan Google Apps Script</a></li>
<li><a href="../id428624/index.html">Jeffrey Richter, Pavel Yosifovich, Greg Young dan semuanya. Hardcore dan arsitektur di DotNext 2018 Moscow</a></li>
<li><a href="../id428626/index.html">Cara membuat ekstensi di PHP7 lebih sulit daripada "halo, dunia", dan tidak menjadi mata merah. Bagian 1</a></li>
<li><a href="../id428630/index.html">Tidak, Bitcoin tidak akan menghancurkan iklim kita pada tahun 2033.</a></li>
<li><a href="../id428632/index.html">Berurusan dengan Pencegat dalam Bereaksi</a></li>
<li><a href="../id428634/index.html">Porting Quake3</a></li>
<li><a href="../id428636/index.html">Roskomnadzor akan memulihkan denda dari Google</a></li>
<li><a href="../id428638/index.html">Hearts Flame Motor: QardioCore Heart Monitor Review</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>