<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🚔 👇🏿 🖖🏾 使塔防成为统一游戏-第1部分 👩🏽‍🏫 👊🏿 🤚🏽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="塔防游戏越来越受欢迎，这并不奇怪-几乎没有什么比观察自己的防御线能够消灭邪恶敌人的乐趣可比了！ 在这个分为两部分的教程中，我们将在Unity引擎上创建一个塔防游戏！ 

 您将学习如何执行以下操作： 



- 制造敌人之波 
- 让他们跟随路线点 
- 建造和升级塔，并教他们如何将敌人分解成小像素...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>使塔防成为统一游戏-第1部分</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/413837/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6c5/894/e67/6c5894e675d3be7fedc6bf87038b2188.png" alt="图片"></div><br> 塔防游戏越来越受欢迎，这并不奇怪-几乎没有什么比观察自己的防御线能够消灭邪恶敌人的乐趣可比了！ 在这个分为两部分的教程中，我们将在<em>Unity</em>引擎上创建一个塔防游戏！ <br><br> 您将学习如何执行以下操作： <br><br><ul><li> 制造敌人之波 </li><li> 让他们跟随路线点 </li><li> 建造和升级塔，并教他们如何将敌人分解成小像素 </li></ul><br> 最后，我们得到了游戏的框架，可以进一步开发它！ <br><a name="habracut"></a><br><blockquote>  <em>注意</em> ：您需要基本的Unity知识（例如，您需要知道如何添加资产和组件，什么是预制件）以及<em>C＃</em>的基础知识。 要学习所有这些，我建议您阅读<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Sean Duffy的</a> Unity教程或Brian Mockley的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Unity</a>入门<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">C＃</a>系列教程。 </blockquote><br> 我将在Unity for OS X中工作，但本教程也适用于Windows。 <br><br><h2> 透过象牙塔的窗户 </h2><br> 在本教程中，我们将创建一个塔防游戏，其中敌人（小虫子）爬到属于您和您的奴才（当然，这些都是怪物！）的cookie。 玩家可以将怪物放置在战略要点上并升级以获得金牌。 <br><br> 玩家必须杀死所有错误，直到它们到达cookie。 每一波新的敌人都越来越难以战胜。 当您在所有海浪中幸免（胜利！）或五个敌人爬到cookie（丢失！）时，游戏结束。 <br><br> 这是完成游戏的屏幕截图： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/782/a94/fef/782a94fefd675365aba52fbfc4008ab6.png"></div><br>  <i>怪物，团结起来！</i>  <i>保护cookie！</i> <br><br><h2> 开始工作 </h2><br> 将<a href="">项目</a>下载为<a href="">空白</a> ，解压缩，然后在Unity中打开<em>TowerDefense-Part1-Starter</em>项目。 <br><br> 项目草案包含图形和声音，现成的动画以及一些有用的脚本的资产。 这些脚本与塔防游戏没有直接关系，因此在此我将不再赘述。 但是，如果您想了解有关在Unity中创建2D动画的更多信息，请查看此<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" title="Unity 2D教程">Unity 2D教程</a> 。 <br><br> 该项目还包含预制件，我们将在以后添加这些预制件来创建角色。 最后，项目中有一个场景，具有背景和自定义的用户界面。 <br><br> 打开位于“ <em>场景”</em>文件夹中的<em>GameScene</em> ，并将“游戏”模式设置为<em>4：3</em>的纵横比，以便所有标签正确匹配背景。 在游戏模式下，您将看到以下内容： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fb7/050/bda/fb7050bda1d91c148f65e70a7c217083.png"></div><br>  <em>著作权：</em> <br><br><ul><li> 该项目的图形取自免费的Wiki Wenderlich包！ 其他图形作品可以在她的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" title="gameartguppy">gameartguppy</a>网站上找到。 </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" title="贝南德">BenSound带来的</a>美妙音乐，还有其他很棒的配乐！ </li><li> 我也感谢Michael Jesper的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" title="相机震动">相机抖动</a>功能<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" title="相机震动">。</a> </li></ul>  。 <br><h2> 这个地方标有一个十字架：怪物的位置 </h2><br> 怪物只能放置在标有<em>x的点上</em> 。 <br><br> 要将它们添加到场景中， <em>请</em>从“ <em>项目浏览器”</em> <em>中将“图像\对象\ Openspot”</em>拖动到“ <em>场景”</em>窗口中。 虽然这个职位对我们并不重要。 <br><br> 在层次结构中选择<em>Openspot</em>后，在<em><em>检查器中</em></em>单击“ <em>添加组件”</em> ，然后选择<em>Box Collider 2D</em> 。 在“场景”窗口中，Unity将显示带有绿线的矩形对撞机。 我们将使用此对撞机识别此位置上的鼠标单击。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/271/6a9/3da/2716a93da69de6b5cf73a7edfc794210.png"></div><br> 以相同的方式将<em>Audio \ Audio Source</em>组件添加到<em>Openspot</em> 。 对于“音频源”组件的<em>AudioClip</em>参数，选择位于“ <em>音频”</em>文件夹中的<em>tower_place</em>文件，并禁用<em>“唤醒时播放”</em> 。 <br><br> 我们需要再创建11个点。 尽管有重复这些步骤的诱惑，但Unity还是有一个更好的解决方案： <em>Prefab</em> ！ <br><br> 将<em>Openspot</em>从<em>层次结构</em>拖动到<em>项目浏览器</em>内的<em>Prefabs</em>文件夹中。 其名称在层次结构中将变为蓝色，这表示它已连接到预制件。 像这样： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ad3/cb2/6a0/ad3cb26a0d51c893dd040e8f4f5dfea6.gif"></div><br> 现在有了预制坯，我们可以创建任意数量的副本。 只需将<em>Openspot</em>从<em>Project Browser</em>内的<em>Prefabs</em>文件夹拖放到<em>Scene</em>窗口中。 重复此11次，场景中将出现12个Openspot对象。 <br><br> 现在，使用<em>检查器</em>使用以下坐标设置这12个Openspot对象： <br><br><ul><li>  （X：-5.2，Y：3.5，Z：0） </li><li>  （X：-2.2，Y：3.5，Z：0） </li><li>  （X：0.8，Y：3.5，Z：0） </li><li>  （X：3.8，Y：3.5，Z：0） </li><li>  （X：-3.8，Y：0.4，Z：0） </li><li>  （X：-0.8，Y：0.4，Z：0） </li><li>  （X：2.2，Y：0.4，Z：0） </li><li>  （X：5.2，Y：0.4，Z：0） </li><li>  （X：-5.2，Y：-3.0，Z：0） </li><li>  （X：-2.2，Y：-3.0，Z：0） </li><li>  （X：0.8，Y：-3.0，Z：0） </li><li>  （X：3.8，Y：-3.0，Z：0） </li></ul><br> 执行此操作时，场景将如下所示： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/69e/248/fb2/69e248fb213cfee35ce43f5f9c14baeb.png"></div><br><h2> 我们放置怪物 </h2><br> 为了简化放置，项目的<em>Prefab</em>文件夹中有一个<em>Monster</em>预制件。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c65/908/80a/c6590880acbdbac94bd15ec023311235.png"></div><br>  <i>Monster Prefab即用型</i> <br><br> 目前，它由一个带有三个不同精灵的空游戏对象组成，并以子级形式拍摄动画。 <br><br> 每个精灵都是具有不同等级力量的怪物。 预制件还包含<em>音频源</em>组件，当怪物发射激光时，它将启动以播放声音。 <br><br> 现在，我们将创建一个脚本，该脚本将在<em>Openspot</em>上<em>托管</em> <em>Monster</em> 。 <br><br> 在<em>项目浏览器中，</em>在<em>Prefabs</em>文件夹中选择<em>Openspot</em>对象。 在<em>检查器中，</em>单击“ <em>添加组件”</em> ，然后选择“ <em>新建脚本”</em> ，并将脚本命名为<em>PlaceMonster</em> 。 选择<em>C Sharp</em>作为语言，然后点击<em>创建和添加</em> 。 由于我们已将脚本添加到<i>Openspot</i>预制中，因此场景中的所有Openspot对象现在都将具有此脚本。 太好了！ <br><br> 双击脚本以在IDE中将其打开。 然后添加两个变量： <br><br><pre><code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> GameObject monsterPrefab; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> GameObject monster;</code> </pre> <br> 我们将创建一个存储在<code>monsterPrefab</code>中的对象的实例，以创建怪物，并将其存储在<code>monsterPrefab</code>中，以便可以在游戏中对其进行操作。 <br><br><h3> 每点一个怪物 </h3><br> 为了使一个怪物只能放在一个点上，请添加以下方法： <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CanPlaceMonster</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> monster == <span class="hljs-literal"><span class="hljs-literal">null</span></span>; }</code> </pre> <br> 在<code>CanPlaceMonster()</code>我们可以检查<code>CanPlaceMonster()</code>变量是否仍然为<code>null</code> 。 如果是这样，那么此时就没有怪物了，我们可以将其放置。 <br><br> 现在添加以下代码，以在玩家单击此GameObject时放置怪物： <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">//1 void OnMouseUp() { //2 if (CanPlaceMonster()) { //3 monster = (GameObject) Instantiate(monsterPrefab, transform.position, Quaternion.identity); //4 AudioSource audioSource = gameObject.GetComponent&lt;AudioSource&gt;(); audioSource.PlayOneShot(audioSource.clip); // </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">TODO:</span></span></span><span class="hljs-comment">   } }</span></span></code> </pre> <br> 当您单击鼠标或触摸屏幕时，此代码将定位怪物。 他如何工作？ <br><br><ol><li> 当玩家触摸物理对撞机GameObject时，Unity会自动调用OnMouseUp。 </li><li> 调用时，如果<code>CanPlaceMonster()</code>返回<code>true</code> ，则此方法放置怪物。 </li><li> 我们使用<code>Instantiate</code>方法创建一个怪物，该方法创建具有指定位置和旋转的给定预制实例。 在这种情况下，我们复制<code>monsterPrefab</code> ，为它提供当前<code>monsterPrefab</code>的位置并且不旋转，将结果传输到<code>GameObject</code>并将其保存到<code>GameObject</code> </li><li> 最后，我们调用<code>PlayOneShot</code>播放附加到对象<code>AudioSource</code>组件上的声音效果。 </li></ol><br> 现在，我们的<code>PlaceMonster</code>脚本可以包含一个新的怪物，但是我们仍然需要指定一个预制件。 <br><br><h3> 使用正确的预制件 </h3><br> 保存文件并返回到Unity。 <br><br> 要设置<em>monsterPrefab</em>变量，请首先从项目浏览器的<em>Prefabs</em>文件夹中选择<em>Openspot</em>对象。 <br><br> 在<em><em>检查器中，</em></em>单击<em>PlaceMonster（脚本）</em>组件的<em>Monster Prefab</em>字段右侧的圆圈<em><em>，</em></em>然后在出现的对话框中选择<em>Monster</em> 。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b87/8bc/9c7/b878bc9c77c6e7c63a54f4a87d2a7c42.gif"></div><br> 仅此而已。 通过单击鼠标或触摸屏幕来启动场景并在不同位置创建怪物。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/095/f08/01d/095f0801ddbbc91ce0eca144a22d4f7b.png"></div><br> 太好了！ 现在我们可以创建怪物了。 但是，它们看起来像一个奇怪的烂摊子，因为绘制了怪物的所有子精灵。 现在我们将修复它。 <br><br><h2> 提高怪物的等级 </h2><br> 下图显示，随着等级的提高，怪物看起来越来越可怕。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a92/23d/480/a9223d480dda51f941c3b0b82f9f0dd6.png"></div><br>  <i>真可爱！</i>  <i>但是，如果您尝试偷走他的饼干，那么这个怪物就会变成杀手。</i> <br><br> 该脚本用作实现怪物关卡系统的基础。 它跟踪怪物在每个级别上的力量，当然还跟踪怪物的当前级别。 <br><br> 添加此脚本。 <br><br> 在<em>项目浏览器中</em>选择<em>Prefabs / Monster</em>预制件。 添加一个名为<em>MonsterData</em>的新<em>C＃</em>脚本。 在IDE中打开脚本，然后在<code>MonsterData</code>类<i>上方</i>添加以下代码。 <br><br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">System.Serializable</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">MonsterLevel</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> cost; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> GameObject visualization; }</code> </pre> <br> 因此，我们创建了<code>MonsterLevel</code> 。 它对价格（以金币计，我们将在下面提供支持）进行分组，并以可视化方式表示怪物的水平。 <br><br> 我们在<code>[System.Serializable]</code>上添加，以便可以在检查器中修改类实例。 这样，即使在游戏运行时，我们也可以快速更改Level类的所有值。 这对于平衡游戏非常有用。 <br><br><h3> 设定怪物等级 </h3><br> 在我们的例子中，我们将指定的<code>MonsterLevel</code>存储在<code>List&lt;T&gt;</code> 。 <br><br> 为什么不只使用<code>MonsterLevel[]</code> ？ 我们将多次需要特定<code>MonsterLevel</code>对象的索引。 尽管为此编写代码很容易，但是我们仍然必须使用实现<code>Lists</code>功能的<code>IndexOf()</code> 。 重新发明轮子没有任何意义。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/aae/85f/785/aae85f7854f44c8f418c5fde22153a53.jpg"></div><br>  <i>重新设计自行车通常不是一个好主意。</i> <br><br> 在<em>MonsterData.cs</em>的顶部， <code>using</code>以下结构添加以下内容： <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Collections.Generic;</code> </pre> <br> 它使我们能够访问通用数据结构，以便我们可以在脚本中使用<code>List&lt;T&gt;</code>类。 <br><br><blockquote>  <em>注意</em> ：泛化是强大的C＃概念。 它们使您可以指定类型安全的数据结构，而不必遵守类型。 这对于诸如列表和集合之类的容器类很有用。 要了解有关泛型结构的更多信息，请阅读《 <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" title="C＃泛型简介">C＃泛型介绍》</a>一书。 </blockquote><br> 现在将以下变量添加到<code>MonsterData</code>来保存<code>MonsterLevel</code>列表： <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> List&lt;MonsterLevel&gt; levels;</code> </pre> <br> 多亏了归纳法，我们可以保证<code>level</code>中的<code>List</code>仅包含<code>MonsterLevel</code>对象。 <br><br> 保存文件并切换到Unity以配置每个级别。 <br><br> 在<em>项目浏览器中</em>选择“ <em>预制件/怪物</em> <em>”</em> 。 现在， <em><em>检查器将</em></em>显示<em>MonsterData（脚本）</em>组件的“ <em>级别”</em>字段。 将<em>大小</em>设置为<em>3</em> 。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/660/dda/a18/660ddaa185b824721453ca1c892eedff.png"></div><br> 接下来，为每个级别设置<em>成本</em> ： <br><br><ul><li>  <em>元素0</em> ： <em>200</em> </li><li>  <em>元素1</em> ： <em>110</em> </li><li>  <em>元素2</em> ： <em>120</em> </li></ul><br> 现在，我们分配视觉显示字段的值。 <br><br> 在项目浏览器中展开<em>Prefabs / Monster</em> ，以查看其子级。 将子<em>Monster0</em>拖到<em>可视化的</em> <em>Element 0</em>字段中。 <br><br> 接下来，将<em>Element 1</em>设置为<em>Monster1</em> ，将<em>Element 2设置</em>为<em>Monster2</em> 。  GIF显示此过程： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/662/404/e30/662404e30bd808e1cf9a9d34b47d4d61.gif"></div><br> 当您选择<em>Prefabs / Monster时</em> ，预制件应如下所示： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/80b/e4d/17e/80be4d17e9894cf291b7be8a44152044.png"></div><br><h3> 设置当前水平 </h3><br> 返回IDE中的<em>MonsterData.cs</em>并将另一个变量添加到<code>MonsterData</code> 。 <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> MonsterLevel currentLevel;</code> </pre> <br> 在私有变量<code>currentLevel</code>我们将存储怪物的当前等级。 <br><br> 现在设置<code>currentLevel</code>并使它对其他脚本可见。  <code>MonsterData</code>与实例变量的声明一起添加到<code>MonsterData</code> ： <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">//1 public MonsterLevel CurrentLevel { //2 get { return currentLevel; } //3 set { currentLevel = value; int currentLevelIndex = levels.IndexOf(currentLevel); GameObject levelVisualization = levels[currentLevelIndex].visualization; for (int i = 0; i &lt; levels.Count; i++) { if (levelVisualization != null) { if (i == currentLevelIndex) { levels[i].visualization.SetActive(true); } else { levels[i].visualization.SetActive(false); } } } } }</span></span></code> </pre> <br> 相当大的C＃代码块，对不对？ 让我们按顺序进行： <br><br><ol><li> 设置私有变量<code>currentLevel</code>的<em>属性</em> 。 通过设置属性，我们可以像调用其他任何变量一样调用它：作为<code>CurrentLevel</code> （在类内部）或<code>monster.CurrentLevel</code> （在外部）。 我们可以在属性的getter或setter方法中定义任何行为，并且通过仅创建getter，setter或这两者，我们可以控制属性的属性：只读，只写和写/读。 </li><li> 在getter中，我们返回<code>currentLevel</code>的值。 </li><li> 在设置器中，我们为<code>currentLevel</code>分配<code>currentLevel</code>新值。 然后我们得到当前水平的指数。 最后，我们遍历所有<em>级别</em>并根据<code>currentLevelIndex</code>启用/禁用可视显示。 这很棒，因为当<code>currentLevel</code>更改时，子画面会自动更新。 属性是非常方便的事情！ </li></ol><br> 添加以下<code>OnEnable</code>实现： <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnEnable</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { CurrentLevel = levels[<span class="hljs-number"><span class="hljs-number">0</span></span>]; }</code> </pre> <br> 在这里，我们在放置时设置<code>CurrentLevel</code> 。 这样可以确保仅显示所需的精灵。 <br><br><blockquote>  <em>注意</em> ：在<code>OnEnable</code>中而不是<code>OnStart</code>初始化属性很重要，因为在创建预制实例时我们会调用序数方法。 <br><br> 创建预制件时（如果预制件保存在启用状态下）将立即调用<code>OnEnable</code> ，但是直到对象开始作为场景的一部分开始运行时才调用<code>OnStart</code> 。 <br><br> 我们需要在放置怪物之前验证此数据，因此我们将其初始化为<code>OnEnable</code> 。 </blockquote><br> 保存文件并返回到Unity。 运行项目并放置怪物； 它们现在显示最低级别的正确精灵。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/08e/16e/549/08e16e5498d12f78d106d873d34c8d1b.png"></div><br><h3> 怪物升级 </h3><br> 返回IDE并将以下方法添加到<code>MonsterData</code> ： <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> MonsterLevel </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetNextLevel</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> currentLevelIndex = levels.IndexOf (currentLevel); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> maxLevelIndex = levels.Count - <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (currentLevelIndex &lt; maxLevelIndex) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> levels[currentLevelIndex+<span class="hljs-number"><span class="hljs-number">1</span></span>]; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; } }</code> </pre> <br> 在<code>GetNextLevel</code>我们获得<code>currentLevel</code>索引和最高级别的索引； 如果怪物尚未达到最大等级，则返回下一个等级。 否则，返回<code>null</code> 。 <br><br> 您可以使用此方法来找出是否有可能升级怪物。 <br><br> 要提高怪物的等级，请添加以下方法： <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IncreaseLevel</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> currentLevelIndex = levels.IndexOf(currentLevel); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (currentLevelIndex &lt; levels.Count - <span class="hljs-number"><span class="hljs-number">1</span></span>) { CurrentLevel = levels[currentLevelIndex + <span class="hljs-number"><span class="hljs-number">1</span></span>]; } }</code> </pre> <br> 在这里，我们获取当前级别的索引，然后确保它不是最大级别，并检查它是否小于<code>levels.Count - 1</code> 。 如果是这样，则将<code>CurrentLevel</code>为下一个级别。 <br><br><h3> 检查升级功能 </h3><br> 保存文件， <em>然后</em>在IDE中返回<em>PlaceMonster.cs</em> 。 添加新方法： <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CanUpgradeMonster</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (monster != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { MonsterData monsterData = monster.GetComponent&lt;MonsterData&gt;(); MonsterLevel nextLevel = monsterData.GetNextLevel(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (nextLevel != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; }</code> </pre> <br> 首先，我们检查是否有可以通过将<code>monster</code>变量与<code>null</code>进行比较来改善的<code>monster</code> 。 如果这是真的，那么我们从其<code>MonsterData</code>获取当前的怪物等级。 <br><br> 然后，我们检查下一个级别是否可用，即<code>GetNextLevel()</code>是否不返回<code>null</code> 。 如果可以提高级别，那么我们返回<code>true</code> ； 否则返回<code>false</code> 。 <br><br><h3> 我们对黄金进行改进 </h3><br> 要启用升级选项，请将<code>else if</code>分支添加到<code>OnMouseUp</code> ： <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (CanPlaceMonster()) { <span class="hljs-comment"><span class="hljs-comment">//      } else if (CanUpgradeMonster()) { monster.GetComponent&lt;MonsterData&gt;().IncreaseLevel(); AudioSource audioSource = gameObject.GetComponent&lt;AudioSource&gt;(); audioSource.PlayOneShot(audioSource.clip); // </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">TODO:</span></span></span><span class="hljs-comment">   }</span></span></code> </pre> <br> 我们使用<code>CanUpgradeMonster()</code>检查升级的可能性。 如果可能，我们使用<code>GetComponent()</code>访问<code>MonsterData</code>组件，然后调用<code>GetComponent()</code> <code>IncreaseLevel()</code> ，这会增加怪物的等级。 最后，我们启动Monster <em>AudioSource</em> 。 <br><br> 保存文件并返回到Unity。 运行游戏，放置并升级<i>任意数量的</i>怪物（但目前为止）。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cb7/495/bed/cb7495bed8ebcd3993439de25a08a0e7.png"></div><br><h2> 支付金-游戏管理员 </h2><br> 尽管我们可以立即构建和改进任何怪物，但在游戏中会有趣吗？ <br><br> 让我们看看黄金的问题。 跟踪问题在于我们必须在不同游戏对象之间传递信息。 <br><br> 下图显示了应该参与的所有对象。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e35/8cd/6f4/e358cd6f461c75385f61f1c12862a16b.png"></div><br>  <i>所有选定的游戏对象必须知道玩家拥有多少黄金。</i> <br><br> 为了存储此数据，我们将使用其他对象可以访问的公共对象。 <br><br> 右键单击<em>层次结构，</em>然后选择<em>创建空</em> 。 命名新的<em>GameManager</em>对象。 <br><br> 将名为<em>GameManagerBehavior</em>的新<em>C＃</em>脚本添加<em>到GameManager</em> ，然后在IDE中将其打开。 我们将在标签中显示玩家的总金额，因此在文件顶部添加以下行： <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine.UI;</code> </pre> <br> 这将允许我们访问UI类，例如用于标签的<code>Text</code> 。 现在将以下变量添加到类中： <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Text goldLabel;</code> </pre> <br> 它将存储指向<code>Text</code>组件的链接，该链接用于显示玩家拥有的黄金数量。 <br><br> 既然<code>GameManager</code>知道了标签，我们如何同步存储在变量中的黄金量和标签中显示的值？ 我们将创建一个属性。 <br><br> 将以下代码添加到<code>GameManagerBehavior</code> ： <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> gold; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Gold { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> gold; } <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { gold = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; goldLabel.GetComponent&lt;Text&gt;().text = <span class="hljs-string"><span class="hljs-string">"GOLD: "</span></span> + gold; } }</code> </pre> <br> 他看起来很熟吗？ 该代码类似于我们在<code>Monster</code>设置的<code>CurrentLevel</code> 。 首先，我们创建一个私有变量<code>gold</code>来保存当前数量的黄金。 然后，我们设置<code>Gold</code>属性（出乎意料，对吧？）并实现getter和setter。 <br><br> 吸气剂只是返回<code>gold</code>的价值。 塞特犬更有趣。 除了设置变量的值外，它还设置<code>goldLabel</code>的<code>text</code>字段以显示新的黄金值。 <br><br> 我们会多么慷慨？ 将以下行添加到<code>Start()</code> ，为播放器提供<em>1000</em>金币；如果您为这笔钱感到遗憾，则少给他： <br><br><pre> <code class="cs hljs">Gold = <span class="hljs-number"><span class="hljs-number">1000</span></span>;</code> </pre> <br><h3> 将标签对象分配给脚本 </h3><br> 保存文件并返回到Unity。 在<em>层次结构中，</em>选择<em>GameManager</em> 。 在<em><em>检查器中，</em></em>单击“ <em>金标</em> ”右侧的圆圈。 在“ <em>选择文本”</em>对话框中，选择“ <em>场景”</em>选项卡，然后选择“ <em>GoldLabel”</em> 。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/05e/82e/956/05e82e95690113e0086020a817e2718c.png"></div><br> 运行场景，标签将显示<em>Gold：1000</em> 。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a97/b8f/b45/a97b8fb455f50659176371e484a280e6.png"></div><br><h3> 查看玩家的“钱包” </h3><br> 在IDE中打开<em>PlaceMonster.cs</em>脚本，并添加以下实例变量： <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> GameManagerBehavior gameManager;</code> </pre> <br> 我们将使用<code>gameManager</code>访问场景中<code>GameManagerBehavior</code>对象的<code>GameManagerBehavior</code>组件。 要指定它，请将以下内容添加到<code>Start()</code> ： <br><br><pre> <code class="cs hljs">gameManager = GameObject.Find(<span class="hljs-string"><span class="hljs-string">"GameManager"</span></span>).GetComponent&lt;GameManagerBehavior&gt;();</code> </pre> <br> 我们使用GameObject.Find <code>GameObject.Find()</code>函数获得了一个名为GameManager的GameObject，它返回使用该名称找到的第一个游戏对象。 然后我们获取其组件<code>GameManagerBehavior</code>并将其保存以备将来使用。 <br><br><blockquote>  <em>注意</em> ：您可以通过在Unity编辑器中设置一个字段或向<code>GameManager</code>添加静态方法来返回单例实例，从中可以获取<code>GameManagerBehavior</code> 。 <br><br> 但是，在上面显示的代码块中有一个黑马： <code>Find</code>方法，它在应用程序执行期间工作得更慢； 但它很方便，可以适量使用。 </blockquote><br><h3> 拿走我的钱！ </h3><br> 我们还没有减去金，所以我们将这行添加<em>两次</em>到<code>OnMouseUp()</code> ，替换每个注释<code>// TODO:  </code> ： <br><br><pre> <code class="cs hljs">gameManager.Gold -= monster.GetComponent&lt;MonsterData&gt;().CurrentLevel.cost;</code> </pre> <br> 保存文件并返回到Unity，升级一些怪物并查看Gold值的更新。 现在我们扣除金币，但是玩家只要有足够的空间就可以建造怪物。 他们只是借钱。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/581/2fe/eaf/5812feeafd4b9d316f8294db56d55789.png"></div><br>  <i>无限信用？</i>  <i>太好了！</i>  <i>但是我们不能允许它。</i>  <i>玩家必须在有足够的金币时下注怪物。</i> <br><br><h3> 怪物金牌 </h3><br> 在IDE中切换到<em>PlaceMonster.cs</em>并将<code>CanPlaceMonster()</code>的内容替换<code>CanPlaceMonster()</code>以下内容： <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> cost = monsterPrefab.GetComponent&lt;MonsterData&gt;().levels[<span class="hljs-number"><span class="hljs-number">0</span></span>].cost; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> monster == <span class="hljs-literal"><span class="hljs-literal">null</span></span> &amp;&amp; gameManager.Gold &gt;= cost;</code> </pre> <br> 我们从<code>MonsterData</code> <code>levels</code> <code>MonsterData</code>怪物放置价格。 然后我们检查<code>gameManager.Gold</code>不为<code>null</code> ，以及<code>gameManager.Gold</code>超过此价格。 <br><br> 您的任务：独立地向<code>CanUpgradeMonster()</code>添加<code>CanUpgradeMonster()</code>检查玩家是否有足够的金币。 <br><br><div class="spoiler">  <b class="spoiler_title">内部解决方案</b> <div class="spoiler_text"> 替换行： <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>;</code> </pre> <br> 在此： <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> gameManager.Gold &gt;= nextLevel.cost;</code> </pre> <br> 它将检查玩家的<em>金币数量是否</em>超过升级价格。 </div></div><br> 在Unity中保存并运行场景。 现在尝试那些如何无限添加怪物！ <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/24b/f58/b6a/24bf58b6a0a1d4258295902f5d05c6bd.png"></div><br>  <i>现在我们只能建造数量有限的怪物。</i> <br><br><h2> 塔式策略：敌人，海浪和航路点 </h2><br> 现在是时候为我们的敌人“铺路”了。 敌人出现在路线的第一点，移至下一个并重复该过程，直到到达Cookie。 <br><br> 您可以像这样使敌人移动： <br><br><ol><li> 设定敌人要走的路 </li><li> 沿着道路移动敌人 </li><li> 转向敌人，以便他向前看 </li></ol><br><h3> 从航点创建道路 </h3><br> 右键单击“ <em>层次结构”，</em>然后选择“ <em>创建空白”</em>以创建一个新的空白游戏对象。 将其命名为<em>Road</em>并将其定位在<em>（0，0，0）</em> 。 <br><br> 现在，在<em>层次结构中的</em> <em>Road</em>上单击鼠标右键，并创建另一个空游戏对象作为Road的子代。 将其命名为<em>Waypoint0</em>并将其放置在<em>（-12，2，0）点</em> -敌人将从此处开始移动。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/78a/21a/044/78a21a0443e9b71b4c28064196cd0f8f.png"></div><br> 同样，使用以下名称和位置再创建五个路线点： <br><br><ul><li> 航点1：（X：7，Y：2，Z：0） </li><li> 航点2：（X：7，Y：-1，Z：0） </li><li> 航点3：（X：-7.3，Y：-1，Z：0） </li><li> 航点4：（X：-7.3，Y：-4.5，Z：0） </li><li> 航点5：（X：7，Y：-4.5，Z：0） </li></ul><br> 下面的屏幕截图显示了路线点和生成的路径。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6c5/894/e67/6c5894e675d3be7fedc6bf87038b2188.png"></div><br><h2> 结交敌人 </h2><br> 现在创建一些敌人，以便他们可以沿着道路移动。  <em>Prefabs</em>文件夹中有一个<em>敌人</em>预制件。 它的位置是<em>（-20，0，0）</em> ，因此将在屏幕外创建新​​实例。 <br><br> 在所有其他方面，它的配置几乎与Monster预制件相同，并具有<code>AudioSource</code>和<code>Sprite</code>子代，将来我们可以旋转此Sprite，而无需打开运行状况栏。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d46/5c7/b09/d465c7b0950d7c718abcb8869263753c.png"></div><br><h3> 我们沿着道路移动敌人 </h3><br> 在<em>Prefabs \ Enemy预制件中</em>添加一个名为<em>MoveEnemy</em>的新<em>C＃</em>脚本。 在IDE中打开脚本并添加以下变量： <br><br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">HideInInspector</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> GameObject[] waypoints; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> currentWaypoint = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> lastWaypointSwitchTime; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> speed = <span class="hljs-number"><span class="hljs-number">1.0f</span></span>;</code> </pre> <br> 在<code>waypoints</code> ，路径点的副本存储在数组中，并且<code>waypoints</code>上方的<code>[HideIn <em>inspector</em> ]</code>确保我们不会意外更改<em><em>Inspector中的</em></em>此字段，但仍可以从其他脚本访问它。 <br><br>  <code>currentWaypoint</code>会跟踪敌人当前路线的位置， <code>lastWaypointSwitchTime</code>存储敌人经过它的时间。 另外，我们存储敌人的<code>speed</code> 。 <br><br> 将此行添加到<code>Start()</code> ： <br><br><pre> <code class="cs hljs">lastWaypointSwitchTime = Time.time;</code> </pre> <br> 因此，我们使用当前时间的值初始化<code>lastWaypointSwitchTime</code> 。 <br><br> 为了使敌人沿着路线前进，请将以下代码添加到<code>Update()</code> ： <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// 1 Vector3 startPosition = waypoints [currentWaypoint].transform.position; Vector3 endPosition = waypoints [currentWaypoint + 1].transform.position; // 2 float pathLength = Vector3.Distance (startPosition, endPosition); float totalTimeForPath = pathLength / speed; float currentTimeOnPath = Time.time - lastWaypointSwitchTime; gameObject.transform.position = Vector2.Lerp (startPosition, endPosition, currentTimeOnPath / totalTimeForPath); // 3 if (gameObject.transform.position.Equals(endPosition)) { if (currentWaypoint &lt; waypoints.Length - 2) { // 3.a currentWaypoint++; lastWaypointSwitchTime = Time.time; // </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">TODO:</span></span></span><span class="hljs-comment">     } else { // 3.b Destroy(gameObject); AudioSource audioSource = gameObject.GetComponent&lt;AudioSource&gt;(); AudioSource.PlayClipAtPoint(audioSource.clip, transform.position); // </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">TODO:</span></span></span><span class="hljs-comment">   } }</span></span></code> </pre> <br> 让我们逐步分析代码： <br><br><ol><li> 从路线点数组中，我们可以获得当前路线段的起点和终点。 </li><li> 我们使用公式<em>time = distance / speed</em>来计算覆盖整个距离所需的<em>时间</em> ，然后确定路线上的当前时间。 使用<code>Vector2.Lerp</code> ，我们在开始和结束精确段之间插入敌人的当前位置。 </li><li> 检查敌人是否到达<code>endPosition</code> 。 如果是，那么我们将处理两种可能的情况： <br><ol><li> 敌人尚未到达路线的最后一点，因此增加<code>currentWaypoint</code>的值并更新<code>lastWaypointSwitchTime</code> 。 稍后，我们将添加代码以使敌人转身，以便他朝自己的运动方向看。 </li><li> 敌人已到达路线的最后一点，然后我们将其摧毁并开始音效。 稍后，我们将添加一条代码，以减少玩家的<code>health</code> 。 </li></ol></li></ol><br> 保存文件并返回到Unity。 <br><br><h3> 我们告知敌人运动的方向 </h3><br> 在当前状态下，敌人不知道路线点的顺序。 <br><br> 在<em>层次结构中</em>选择<em>Road</em> ，然后添加一个名为<em>SpawnEnemy</em>的新<em>C＃</em>脚本。 在IDE中打开它并添加以下变量： <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> GameObject[] waypoints;</code> </pre> <br> 我们将使用<code>waypoints</code>以所需顺序在场景中存储对<code>waypoints</code>引用。 <br><br> 保存文件并返回到Unity。 在<em>层次结构中</em>选择<em>Road</em>并将<em>Waypoints</em>数组的<em>Size</em>设置为<em>6</em> 。 <br><br> 通过将<em>元素0</em>中的<em>Waypoint0</em>粘贴到<em>元素1中的</em> <em>Waypoint1</em> <em>，</em>等等，将每个Road子级拖到字段中。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/95a/1e3/251/95a1e3251247a04f62f8a618b681c052.gif"></div><br> 现在，我们有了一个包含正确顺序的路线点的数组-提醒您，敌人永不退缩，他们不断努力争取甜蜜的回报。 <br><br><h3> 检查一切如何 </h3><br> 在IDE中打开<em>SpawnEnemy</em>并添加以下变量： <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> GameObject testEnemyPrefab;</code> </pre> <br> 它将在<code>testEnemyPrefab</code>存储对<em>敌人</em> <code>testEnemyPrefab</code>的<code>testEnemyPrefab</code> 。 <br><br> 要在运行脚本时创建敌人，请将以下代码添加到<code>Start()</code> ： <br><br><pre> <code class="cs hljs">Instantiate(testEnemyPrefab).GetComponent&lt;MoveEnemy&gt;().waypoints = waypoints;</code> </pre> <br> 因此，我们将创建一个存储在<code>testEnemy</code>中的预制件的新副本，并为其分配路由。 <br><br> 保存文件并返回到Unity。 在“ <em>层次结构”中</em>选择<em>Road</em>对象，然后为“ <em>测试敌人”</em>参数选择“ <em>敌人”</em>预制件。 <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 启动该项目，并观察敌人如何沿道路行驶（在GIF中，为清楚起见，速度提高了20倍）。 </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0b6/b10/384/0b6b1038491a74c27d6b42860e44365e.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">注意到他并不总是看他要去哪里？</font><font style="vertical-align: inherit;">这很有趣，但是我们正在尝试制作专业游戏。</font><font style="vertical-align: inherit;">因此，在本教程的第二部分中，我们将教导敌人前瞻。</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 接下来要去哪里？ </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们已经做了很多工作，并且正在迅速创建自己的塔防游戏。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">玩家可以创建数量有限的怪物，敌人沿着马路奔向我们的cookie。</font><font style="vertical-align: inherit;">玩家拥有金币，他们可以升级怪物。</font><a href=""><font style="vertical-align: inherit;">从此处</font></a></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">下载完成的结果</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">在</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;">第二部分中，</font></a><font style="vertical-align: inherit;">我们将考虑制造巨大的敌人浪潮并将其消灭。</font><font style="vertical-align: inherit;">待会见！</font></font><a href=""><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"></font><br><br><font style="vertical-align: inherit;"></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN413837/">https://habr.com/ru/post/zh-CN413837/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN413817/index.html">一次严格的实时异构竞争数据处理</a></li>
<li><a href="../zh-CN413819/index.html">诚实地对待俄罗斯的IT市场</a></li>
<li><a href="../zh-CN413823/index.html">无意义的就业热潮</a></li>
<li><a href="../zh-CN413827/index.html">Kubernetes项目已满4岁</a></li>
<li><a href="../zh-CN413831/index.html">特斯拉自动驾驶仪的新版本将于8月发布，首次具有“全自动驾驶功能”</a></li>
<li><a href="../zh-CN413839/index.html">AI，实践课程。 图像采集与研究</a></li>
<li><a href="../zh-CN413841/index.html">Google产品的替代品</a></li>
<li><a href="../zh-CN413843/index.html">Waymo领先于其他公司：该公司的机器人移动了1100万公里</a></li>
<li><a href="../zh-CN413847/index.html">“活”触发器纪念碑</a></li>
<li><a href="../zh-CN413849/index.html">森海塞尔品牌历史：自由与远见</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>