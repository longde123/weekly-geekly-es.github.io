<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🏑 ‼️ 🥈 Fermeture de type générique en rouille 🤰🏿 📨 🏾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dans ce court article, je vais parler d'un modèle dans Rust qui vous permet de "sauvegarder" pour une utilisation ultérieure d'un type passé par une m...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Fermeture de type générique en rouille</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/454310/"><p><img src="https://habrastorage.org/webt/jc/35/qj/jc35qjpmk7ypmaece7ki1xpzsz8.jpeg"></p><br><p>  Dans ce court article, je vais parler d'un modèle dans Rust qui vous permet de "sauvegarder" pour une utilisation ultérieure d'un type passé par une méthode générique.  Ce modèle se trouve dans les bibliothèques source des bibliothèques Rust, et je l'utilise aussi parfois dans mes projets.  Je n'ai pas pu trouver de publications à son sujet dans le réseau, alors je lui ai donné mon nom: «Fermeture de type généralisé», et dans cet article, je veux vous dire ce que c'est, pourquoi et comment il peut être utilisé. </p><a name="habracut"></a><br><h2 id="problema">  Le problème </h2><br><p>  À Rust, un système de type statique développé et ses capacités statiques sont suffisants pour probablement 80% des cas.  Mais il arrive que la saisie dynamique soit nécessaire lorsque vous souhaitez stocker des objets de différents types au même endroit.  Les objets-types de personnages viennent à la rescousse ici: ils effacent les vrais types d'objets, les réduisent à une certaine interface commune définie par le type, puis vous pouvez opérer sur ces objets comme les mêmes objets-types-types. </p><br><p> Cela fonctionne bien dans la moitié des cas restants.  Mais que se passe-t-il si nous avons encore besoin de restaurer les types d'objets effacés lors de leur utilisation?  Par exemple, si le comportement de nos objets est déterminé par un type qui <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ne peut pas être utilisé comme objet-type</a> .  Il s'agit d'une situation courante pour les traits avec des types associés.  Que faire dans ce cas? </p><br><h2 id="reshenie">  Solution </h2><br><p> Pour tous <code>'static</code> types <code>'static</code> (c'est-à-dire les types qui ne contiennent pas de liens non statiques), Rust implémente le type <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><code>Any</code></a> , qui permet la conversion de l'objet type <code>dyn Any</code> en une référence au type d'objet d'origine: </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> value = <span class="hljs-string"><span class="hljs-string">"test"</span></span>.to_string(); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> value_any = &amp;value <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> &amp;dyn Any; <span class="hljs-comment"><span class="hljs-comment">//       String.  //   -      . if let Some(as_string) = value_any.downcast_ref::&lt;String&gt;() { println!("String: {}", as_string); } else { println!("Unknown type"); }</span></span></code> </pre> <br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><em>Exécuter</em></a> </p><br><p>  <code>Box</code> dispose également d'une méthode de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><code>downcast</code></a> à cet effet. </p><br><p>  Cette solution convient aux cas où le type de source est connu sur le lieu de travail avec lui.  Et si ce n'est pas le cas?  Que se passe-t-il si le code appelant ne connaît tout simplement pas le type source de l'objet au lieu de son utilisation?  Ensuite, nous devons en quelque sorte nous souvenir du type d'origine, le prendre là où il est défini et enregistrer avec l'objet <code>dyn Any</code> type, afin que ce dernier puisse ensuite être converti au type d'origine au bon endroit. </p><br><p>  Les types généralisés dans Rust peuvent être traités comme des variables de type dans lesquelles l'une ou l'autre valeur de type peut être transmise lors de l'appel.  Mais à Rust, il n'y a aucun moyen de se souvenir de ce type pour une utilisation ultérieure ailleurs.  Cependant, il existe un moyen de se souvenir de toutes les fonctionnalités utilisant ce type, avec ce type.  C'est l'idée du modèle "Fermeture d'un type généralisé": le code utilisant un type est exécuté sous la forme d'une fermeture, qui est stockée comme une fonction normale, car il n'utilise aucun objet de l'environnement, sauf pour les types généralisés. </p><br><h2 id="realizaciya">  Implémentation </h2><br><p>  Regardons un exemple d'implémentation.  Supposons que nous voulons créer un arbre récursif qui représente une hiérarchie d'objets graphiques, dans laquelle chaque nœud peut être soit une primitive graphique avec des nœuds enfants, soit un composant - un arbre distinct d'objets graphiques: </p><br><pre> <code class="rust hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">enum</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Node</span></span></span></span> { Prim(Primitive), Comp(Component), } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Primitive</span></span></span></span> { shape: Shape, children: <span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>&lt;Node&gt;, } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Component</span></span></span></span> { node: <span class="hljs-built_in"><span class="hljs-built_in">Box</span></span>&lt;Node&gt;, } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">enum</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Shape</span></span></span></span> { Rectangle, Circle, }</code> </pre> <br><p>  <code>Node</code> empaquetage des <code>Node</code> dans la structure des <code>Component</code> est nécessaire car la structure des <code>Component</code> elle-même est utilisée dans le <code>Node</code> . </p><br><p>  Supposons maintenant que notre arbre soit juste une représentation d'un modèle auquel il devrait être associé.  De plus, chaque composant aura son propre modèle: </p><br><pre> <code class="rust hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Primitive</span></span></span></span>&lt;Model&gt; { shape: Shape, children: <span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>&lt;Node&lt;Model&gt;&gt;, } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Component</span></span></span></span>&lt;Model&gt; { node: <span class="hljs-built_in"><span class="hljs-built_in">Box</span></span>&lt;Node&lt;Model&gt;&gt;, model: Model, <span class="hljs-comment"><span class="hljs-comment">//   Model }</span></span></code> </pre> <br><p>  On pourrait écrire: </p><br><pre> <code class="rust hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">enum</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Node</span></span></span></span>&lt;Model&gt; { Prim(Primitive&lt;Model&gt;), Comp(Component&lt;Model&gt;), }</code> </pre> <br><p>  Mais ce code ne fonctionnera pas comme nous en avons besoin.  Parce que le composant doit avoir son propre modèle, et non le modèle de l'élément parent, qui contient le composant.  Autrement dit, nous avons besoin de: </p><br><pre> <code class="rust hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">enum</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Node</span></span></span></span>&lt;Model&gt; { Prim(Primitive&lt;Model&gt;), Comp(Component), } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Primitive</span></span></span></span>&lt;Model&gt; { shape: Shape, children: <span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>&lt;Node&lt;Model&gt;&gt;, _model: PhantomData&lt;Model&gt;, <span class="hljs-comment"><span class="hljs-comment">//   Model } struct Component { node: Box&lt;dyn Any&gt;, model: Box&lt;dyn Any&gt;, } impl Component { fn new&lt;Model: 'static&gt;(node: Node&lt;Model&gt;, model: Model) -&gt; Self { Self { node: Box::new(node), model: Box::new(model), } } }</span></span></code> </pre> <br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><em>Exécuter</em></a> </p><br><p>  Nous avons déplacé l'indication d'un type spécifique de modèle vers la <code>new</code> méthode, et dans le composant lui-même, nous stockons le modèle et le sous-arbre déjà avec des types effacés. </p><br><p>  Ajoutez maintenant la méthode <code>use_model</code> , qui utilisera le modèle, mais ne sera pas paramétrée par son type: </p><br><pre> <code class="rust hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Component</span></span></span></span> { node: <span class="hljs-built_in"><span class="hljs-built_in">Box</span></span>&lt;dyn Any&gt;, model: <span class="hljs-built_in"><span class="hljs-built_in">Box</span></span>&lt;dyn Any&gt;, use_model_closure: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span></span>(&amp;Component), } <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> Component { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">new</span></span></span></span>&lt;Model: <span class="hljs-symbol"><span class="hljs-symbol">'static</span></span>&gt;(node: Node&lt;Model&gt;, model: Model) -&gt; <span class="hljs-keyword"><span class="hljs-keyword">Self</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> use_model_closure = |comp: &amp;Component| { comp.model.downcast_ref::&lt;Model&gt;().unwrap(); }; <span class="hljs-keyword"><span class="hljs-keyword">Self</span></span> { node: <span class="hljs-built_in"><span class="hljs-built_in">Box</span></span>::new(node), model: <span class="hljs-built_in"><span class="hljs-built_in">Box</span></span>::new(model), use_model_closure, } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">use_model</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) { (<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.use_model_closure)(<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>); } }</code> </pre> <br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><em>Exécuter</em></a> </p><br><p>  Notez que dans le composant, nous stockons un pointeur sur une fonction qui est créée dans la <code>new</code> méthode en utilisant la syntaxe pour définir une fermeture.  Mais tout ce qu'il doit capturer de l'extérieur est le type de <code>Model</code> , nous sommes donc obligés de passer un lien vers le composant lui-même dans cette fonction via un argument. </p><br><blockquote>  Il semble qu'au lieu de fermer, nous pouvons utiliser une fonction interne, mais un tel code ne compile pas.  Parce que la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">fonction interne dans Rust ne peut pas capturer les types généralisés à partir de la externe en</a> raison du fait qu'elle ne diffère de la fonction de haut niveau habituelle que par la visibilité. </blockquote><p>  La méthode <code>use_model</code> peut <code>use_model</code> être utilisée dans un contexte où le type réel de <code>Model</code> inconnu.  Par exemple, dans une arborescence récursive composée de nombreux composants différents avec différents modèles. </p><br><h2 id="alternativa">  Alternative </h2><br><p>  S'il est possible de transférer l'interface du composant vers un type qui permet la création d'un objet-type, il est préférable de le faire, et d'utiliser à la place le composant lui-même pour opérer sur son objet-type: </p><br><pre> <code class="rust hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">enum</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Node</span></span></span></span>&lt;Model&gt; { Prim(Primitive&lt;Model&gt;), Comp(<span class="hljs-built_in"><span class="hljs-built_in">Box</span></span>&lt;dyn ComponentApi&gt;), } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Component</span></span></span></span>&lt;Model&gt; { node: Node&lt;Model&gt;, model: Model, } <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span>&lt;Model&gt; Component&lt;Model&gt; { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">new</span></span></span></span>(node: Node&lt;Model&gt;, model: Model) -&gt; <span class="hljs-keyword"><span class="hljs-keyword">Self</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">Self</span></span> { node, model, } } } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">trait</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ComponentApi</span></span></span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">use_model</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span>&lt;Model&gt; ComponentApi <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> Component&lt;Model&gt; { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">use_model</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) { &amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.model; } }</code> </pre> <br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><em>Exécuter</em></a> </p><br><h2 id="zaklyuchenie">  Conclusion </h2><br><p>  Il s'avère que les fermetures dans Rust peuvent capturer non seulement des objets d'environnement, mais aussi des types.  Cependant, ils peuvent être interprétés comme des fonctions ordinaires.  Cette propriété devient utile lorsque vous devez travailler uniformément avec différents types sans perdre d'informations à leur sujet, si les types de caractères ne sont pas applicables. </p><br><p>  J'espère que cet article vous aidera à utiliser Rust.  Partagez vos pensées dans les commentaires. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr454310/">https://habr.com/ru/post/fr454310/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr454300/index.html">Comment les CTT diffèrent des caloducs conventionnels et comment les appliquer</a></li>
<li><a href="../fr454302/index.html">Fichiers QVD - contenu</a></li>
<li><a href="../fr454304/index.html">Imprimante Delta 3D à faire soi-même pour la céramique</a></li>
<li><a href="../fr454306/index.html">Cinq erreurs que j'ai commises en tant que développeur principal</a></li>
<li><a href="../fr454308/index.html">AMA avec Habr. V.9.0. Podcast, conférence et concepts</a></li>
<li><a href="../fr454312/index.html">Comment utiliser la bibliothèque jQuery avec le framework Angular (quand c'est vraiment nécessaire)</a></li>
<li><a href="../fr454314/index.html">10 principes de programmation orientée objet que chaque développeur doit connaître</a></li>
<li><a href="../fr454316/index.html">Sur les traces du ninja industriel: nous vous invitons à participer au concours en ligne de sécurité industrielle</a></li>
<li><a href="../fr454318/index.html">Sondant le passé. Un guide pour les historiens sur la conversion des données en sons</a></li>
<li><a href="../fr454320/index.html">Analystes du marché du travail et scientifiques des données</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>