<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü•¶ üëÉüèΩ üö≥ Faltungsstruktur üçú üò¶ üßñüèΩ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Selbstaktualisierende Texturen 
 Wenn es m√∂glich ist, Simulationen oder Rendering-Aufgaben zu parallelisieren, ist es normalerweise am besten, sie in ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Faltungsstruktur</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/478772/"><h2>  Selbstaktualisierende Texturen </h2><br>  Wenn es m√∂glich ist, Simulationen oder Rendering-Aufgaben zu parallelisieren, ist es normalerweise am besten, sie in der GPU auszuf√ºhren.  In diesem Artikel werde ich eine Technik erl√§utern, die diese Tatsache nutzt, um beeindruckende visuelle Tricks mit geringem Leistungsaufwand zu erstellen.  Alle Effekte, die ich demonstrieren werde, werden mit Texturen implementiert, die sich bei Aktualisierung " <em>selbst rendern</em> ".  Die Textur wird aktualisiert, wenn ein neuer Frame gerendert wird, und der n√§chste Texturzustand ist vollst√§ndig vom vorherigen Zustand abh√§ngig.  Auf diesen Texturen k√∂nnen Sie zeichnen, was zu bestimmten √Ñnderungen f√ºhrt, und die Textur selbst kann direkt oder indirekt zum Rendern interessanter Animationen verwendet werden.  Ich nenne sie <em>Faltungsstrukturen</em> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/756/a1a/005/756a1a0051471cbe895a8883d89efadd.jpg"></div><br>  <i>Abbildung 1: Doppelte Faltungspufferung</i> <br><br>  Bevor wir fortfahren, m√ºssen wir ein Problem l√∂sen: Die Textur kann nicht gleichzeitig gelesen und geschrieben werden, Grafik-APIs wie OpenGL und DirectX erlauben dies nicht.  Da der n√§chste Status der Textur vom vorherigen abh√§ngt, m√ºssen wir diese Einschr√§nkung irgendwie umgehen.  Ich muss von einer anderen Textur lesen, nicht von der, in der ich schreibe. <br><br>  Die L√∂sung ist die <em>doppelte Pufferung</em> .  Abbildung 1 zeigt, wie es funktioniert: Statt einer Textur gibt es zwei, aber eine wird beschrieben und eine wird von der anderen gelesen.  Die Textur, in die geschrieben wird, wird als <em>Back-Buffer bezeichnet</em> , und die gerenderte Textur wird als <em>Front-Buffer bezeichnet</em> .  Da der Faltungstest "in sich selbst geschrieben" ist, schreibt der Sekund√§rpuffer in jedem Frame in den Prim√§rpuffer, und dann wird der Prim√§rpuffer gerendert oder zum Rendern verwendet.  Im n√§chsten Frame √§ndern sich die Rollen und der vorherige Prim√§rpuffer wird als Quelle f√ºr den n√§chsten Prim√§rpuffer verwendet. <br><a name="habracut"></a><br>  Durch Rendern des vorherigen Zustands in eine neue Faltungsstruktur mit dem Fragment-Shader (oder <em>Pixel-Shader</em> ) werden interessante Effekte und Animationen erzielt.  Der Shader bestimmt, wie sich der Status √§ndert.  Der Quellcode f√ºr alle Beispiele aus dem Artikel (sowie f√ºr andere) befindet sich im <a href="https://github.com/jobtalle/ConvolutionalTextures">Repository auf GitHub</a> . <br><br><h2>  Einfache Anwendungsbeispiele </h2><br>  Um diese Technik zu demonstrieren, habe ich eine bekannte Simulation gew√§hlt, bei der der Status beim Aktualisieren vollst√§ndig vom vorherigen Status abh√§ngt: dem <em>Conway-Spiel ‚ÄûLife‚Äú</em> .  Diese Simulation wird in einem Gitter von Quadraten durchgef√ºhrt, von denen jede Zelle lebt oder tot ist.  Die Regeln f√ºr den folgenden Zellstatus sind einfach: <br><br><ul><li>  Wenn eine lebende Zelle weniger als zwei Nachbarn hat, wird sie aber tot. </li><li>  Wenn eine lebende Zelle zwei oder drei lebende Nachbarn hat, bleibt sie am Leben. </li><li>  Wenn eine lebende Zelle mehr als drei lebende Nachbarn hat, ist sie tot. </li><li>  Wenn eine tote Zelle drei lebende Nachbarn hat, wird sie lebendig. </li></ul><br>  Um dieses Spiel als Faltungstextur zu implementieren, interpretiere ich die Textur als das Raster des Spiels und der Shader rendert basierend auf den obigen Regeln.  Ein transparentes Pixel ist eine tote Zelle, und ein wei√ües undurchsichtiges Pixel ist eine lebende Zelle.  Eine interaktive Implementierung wird unten gezeigt.  F√ºr den Zugriff auf die GPU verwende ich <a href=""><em>myr.js</em></a> , wof√ºr <em>WebGL 2</em> erforderlich ist.  Die meisten modernen Browser (wie Chrome und Firefox) k√∂nnen damit arbeiten, aber wenn die Demo nicht funktioniert, unterst√ºtzt sie der Browser h√∂chstwahrscheinlich nicht.  Verwenden Sie die Maus (oder den Touchscreen) [im Originalartikel], um lebende Zellen auf die Textur zu zeichnen. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/SQ3EKUPm8FY" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Der Fragment-Shader-Code (in GLSL, da ich WebGL zum Rendern verwende) ist unten dargestellt.  Zuerst implementiere ich die <code>get</code> Funktion, mit der ich ein Pixel von einem bestimmten Versatz von dem aktuellen lesen kann.  Die <code>pixelSize</code> Variable ist ein vordefinierter 2D-Vektor, der den UV-Versatz jedes Pixels enth√§lt, und die <code>get</code> Funktion liest damit die benachbarte Zelle.  Die Hauptfunktion bestimmt dann die neue Farbe der Zelle basierend auf dem aktuellen Status ( <code>live</code> ) und der Anzahl der lebenden Nachbarn. <br><br><pre> <code class="cpp hljs">uniform sampler2D source; uniform lowp vec2 pixelSize; in mediump vec2 uv; layout (location = <span class="hljs-number"><span class="hljs-number">0</span></span>) out lowp vec4 color; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> dx, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> dy)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>(texture(source, uv + pixelSize * vec2(dx, dy)).r); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> live = get(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> neighbors = get(<span class="hljs-number"><span class="hljs-number">-1</span></span>, <span class="hljs-number"><span class="hljs-number">-1</span></span>) + get(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">-1</span></span>) + get(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">-1</span></span>) + get(<span class="hljs-number"><span class="hljs-number">-1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>) + get(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>) + get(<span class="hljs-number"><span class="hljs-number">-1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>) + get(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>) + get(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (live == <span class="hljs-number"><span class="hljs-number">1</span></span> &amp;&amp; neighbors &lt; <span class="hljs-number"><span class="hljs-number">2</span></span>) color = vec4(<span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (live == <span class="hljs-number"><span class="hljs-number">1</span></span> &amp;&amp; (neighbors == <span class="hljs-number"><span class="hljs-number">2</span></span> || neighbors == <span class="hljs-number"><span class="hljs-number">3</span></span>)) color = vec4(<span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (live == <span class="hljs-number"><span class="hljs-number">1</span></span> &amp;&amp; neighbors == <span class="hljs-number"><span class="hljs-number">3</span></span>) color = vec4(<span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (live == <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; neighbors == <span class="hljs-number"><span class="hljs-number">3</span></span>) color = vec4(<span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> color = vec4(<span class="hljs-number"><span class="hljs-number">0</span></span>); }</code> </pre> <br>  Eine andere einfache Faltungsstruktur ist ein <em>Spiel mit fallendem Sand</em> , bei dem der Benutzer bunten Sand auf die Szene werfen kann, die herunterf√§llt und Berge bildet.  Obwohl die Implementierung etwas komplizierter ist, sind die Regeln einfacher: <br><br><ul><li>  Befindet sich kein Sand unter einem Sandkorn, f√§llt dieser ein Pixel nach unten. </li><li>  Befindet sich Sand unter einem Sandkorn, der jedoch um 45 Grad nach links oder rechts abrutschen kann, so wird dies der Fall sein. </li></ul><br>  Das Management in diesem Beispiel ist dasselbe wie im Spiel "Leben".  Da Sand nach solchen Regeln mit einer Geschwindigkeit von nur einem Pixel pro Frame abfallen kann, um den Prozess geringf√ºgig zu beschleunigen, wird die Textur pro Frame dreimal aktualisiert.  Der Quellcode der Anwendung ist <a href="https://github.com/jobtalle/ConvolutionalTextures/blob/master/sand.html">hier</a> . <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/MV10ScILiAY" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><h2>  Ein Schritt vorw√§rts </h2><br><div class="scrollable-table"><table><tbody><tr><td>  <b>Kanal</b> </td><td>  <b>Bewerbung</b> </td></tr><tr><td>  Rot </td><td>  Wellenh√∂he </td></tr><tr><td>  Gr√ºn </td><td>  Wellengeschwindigkeit </td></tr><tr><td>  Blau </td><td>  <i>Wird nicht benutzt</i> </td></tr><tr><td>  Alpha </td><td>  <i>Wird nicht benutzt</i> </td></tr></tbody></table></div><br>  <i>Abbildung 2: Pixelwellen.</i> <br><br>  Die obigen Beispiele verwenden direkt eine Faltungstextur;  Der Inhalt wird unver√§ndert auf dem Bildschirm angezeigt.  Wenn Sie Bilder nur als Pixel interpretieren, sind die Einsatzgrenzen dieser Technik sehr begrenzt, k√∂nnen aber dank moderner Ausstattung erweitert werden.  Anstatt Pixel als Farben zu z√§hlen, werde ich sie etwas anders interpretieren, was verwendet werden kann, um Animationen einer weiteren Textur oder eines 3D-Modells zu erstellen. <br><br>  Zuerst werde ich die Faltungsstruktur als H√∂henkarte interpretieren.  Die Textur simuliert <em>Wellen</em> und <em>Vibrationen</em> auf der Wasserebene und die Ergebnisse werden zum Rendern von Reflexionen und schattierten Wellen verwendet.  Wir m√ºssen die Textur nicht mehr als Bild lesen, sodass wir ihre Pixel zum Speichern von Informationen verwenden k√∂nnen.  Bei einem Water Shader speichere ich die Wellenh√∂he im roten Kanal und den Wellenimpuls im gr√ºnen Kanal, wie in Abbildung 2 dargestellt. Der blaue und der Alpha-Kanal werden noch nicht verwendet.  Wellen entstehen durch das Zeichnen roter Flecken auf einer Faltungsstruktur. <br><br>  Ich werde die Methode zur Aktualisierung der H√∂henkarte, die ich von der Website von <em>Hugo Elias ausgeliehen habe</em> , die aus dem Internet verschwunden zu sein scheint, nicht ber√ºcksichtigen.  Er lernte diesen Algorithmus auch von einem unbekannten Autor und implementierte ihn in C zur Ausf√ºhrung in der CPU.  Der Quellcode f√ºr die unten stehende Anwendung ist <a href="https://github.com/jobtalle/ConvolutionalTextures/blob/master/water.html">hier</a> . <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/h8GjEGMV8AE" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Hier habe ich eine H√∂henkarte nur zum Versetzen der Textur und zum Hinzuf√ºgen von Schattierungen verwendet, aber in der dritten Dimension k√∂nnen viel interessantere Anwendungen implementiert werden.  Wenn eine Faltungstextur von einem Vertex-Shader interpretiert wird, kann eine flach unterteilte Ebene verzerrt werden, um dreidimensionale Wellen zu erzeugen.  Sie k√∂nnen die resultierende Form mit der √ºblichen Schattierung und Beleuchtung versehen. <br><br>  Es ist anzumerken, dass die Pixel in der Faltungstextur des oben gezeigten Beispiels manchmal sehr kleine Werte speichern, die aufgrund von Rundungsfehlern nicht verschwinden sollten.  Daher sollten die Farbkan√§le dieser Textur eine h√∂here Aufl√∂sung haben und nicht die Standard-8-Bits.  In diesem Beispiel habe ich die Gr√∂√üe jedes Farbkanals auf 16 Bit erh√∂ht, was ziemlich genaue Ergebnisse ergab.  Wenn Sie keine Pixel speichern, m√ºssen Sie h√§ufig die Genauigkeit der Textur erh√∂hen.  Gl√ºcklicherweise unterst√ºtzen moderne Grafik-APIs diese Funktion. <br><br><h2>  Wir nutzen alle Kan√§le </h2><br><div class="scrollable-table"><table><tbody><tr><td>  <b>Kanal</b> </td><td>  <b>Bewerbung</b> </td></tr><tr><td>  Rot </td><td>  X Versatz </td></tr><tr><td>  Gr√ºn </td><td>  Y-Versatz </td></tr><tr><td>  Blau </td><td>  X Geschwindigkeit </td></tr><tr><td>  Alpha </td><td>  Y-Versatz </td></tr></tbody></table></div><br>  <i>Abbildung 3: Pixelgras.</i> <br><br>  Im Wasserbeispiel werden nur die roten und gr√ºnen Kan√§le verwendet, aber im n√§chsten Beispiel werden alle vier angewendet.  Es wird ein Feld mit Gras (oder B√§umen) simuliert, das mit dem Cursor verschoben werden kann.  Abbildung 3 zeigt, welche Daten in einem Pixel gespeichert sind.  Der Versatz wird in den roten und gr√ºnen Kan√§len und die Geschwindigkeit in den blauen und Alpha-Kan√§len gespeichert.  Diese Geschwindigkeit wird aktualisiert, um sich mit einer allm√§hlich verblassenden Wellenbewegung in die Ruheposition zu verschieben. <br><br>  Im Beispiel mit Wasser ist das Erstellen von Wellen ganz einfach: Auf der Textur k√∂nnen Punkte gezeichnet werden, und Alpha-Blending sorgt f√ºr glatte Formen.  Sie k√∂nnen problemlos mehrere √ºberlappende Punkte erstellen.  In diesem Beispiel ist alles schwieriger, da der Alpha-Kanal bereits verwendet wird.  Wir k√∂nnen keinen Punkt mit einem Alpha-Wert von 1 in der Mitte und 0 vom Rand aus zeichnen, da dies dem Gras einen unn√∂tigen Impuls gibt (da der vertikale Impuls im Alpha-Kanal gespeichert ist).  In diesem Fall wurde ein separater Shader geschrieben, um den Effekt auf die Faltungstextur zu zeichnen.  Dieser Shader stellt sicher, dass beim Alpha-Blending keine unerwarteten Effekte auftreten. <br><br>  Den Quellcode der Anwendung finden Sie <a href="https://github.com/jobtalle/ConvolutionalTextures/blob/master/grass.html">hier</a> . <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/oBqQL7HViLE" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Gras wird in 2D erstellt, aber der Effekt funktioniert in 3D-Umgebungen.  Anstelle der Pixelverschiebung werden die Scheitelpunkte verschoben, was ebenfalls schneller ist.  Mit Hilfe von Gipfeln kann auch ein anderer Effekt erzielt werden: Unterschiedliche St√§rke der √Ñste - das Gras biegt sich m√ºhelos mit dem geringsten Wind, und starke B√§ume schwanken nur w√§hrend St√ºrmen. <br><br>  Obwohl es viele Algorithmen und Shader gibt, um die Auswirkungen von Wind und Verschiebung der Vegetation zu erzeugen, hat dieser Ansatz einen schwerwiegenden Vorteil: Das Zeichnen von Effekten auf eine Faltungstextur ist ein sehr kosteng√ºnstiger Prozess.  Wenn der Effekt in einem Spiel angewendet wird, kann die Bewegung der Vegetation durch Hunderte verschiedener Einfl√ºsse bestimmt werden.  Nicht nur die Hauptfigur, sondern auch alle Gegenst√§nde, Tiere und Bewegungen k√∂nnen die Welt auf Kosten unbedeutender Kosten beeinflussen. <br><br><h2>  Andere Anwendungsf√§lle und M√§ngel </h2><br>  Sie k√∂nnen mit vielen anderen Technologieanwendungen aufwarten, zum Beispiel: <br><br><ul><li>  Mit einer Faltungsstruktur k√∂nnen Sie die Windgeschwindigkeit simulieren.  Auf die Textur k√∂nnen Sie Hindernisse zeichnen, die die Luft um sie herum bewegen.  Partikel (Regen, Schnee und Bl√§tter) k√∂nnen diese Textur verwenden, um um Hindernisse zu fliegen. </li><li>  Sie k√∂nnen die Ausbreitung von Rauch oder Feuer simulieren. </li><li>  Die Textur kann die Dicke einer Schnee- oder Sandschicht kodieren.  Spuren und andere Wechselwirkungen mit der Ebene k√∂nnen Dellen und Drucke auf der Ebene erzeugen. </li></ul><br>  Bei dieser Methode gibt es Schwierigkeiten und Einschr√§nkungen: <br><br><ul><li>  Es ist schwierig, Animationen an sich √§ndernde Bildraten anzupassen.  Beispielsweise fallen in einer Anwendung mit fallendem Sand Sandk√∂rner mit einer konstanten Geschwindigkeit ab - ein Pixel pro Aktualisierung.  Eine m√∂gliche L√∂sung k√∂nnte darin bestehen, Faltungsstrukturen mit einer konstanten Frequenz zu aktualisieren, √§hnlich wie die meisten physischen Engines funktionieren.  Die Physik-Engine l√§uft mit einer konstanten Frequenz und die Ergebnisse werden interpoliert. </li><li>  Das √úbertragen von Daten auf die GPU ist ein schneller und einfacher Vorgang, das Zur√ºckholen von Daten ist jedoch nicht so einfach.  Dies bedeutet, dass die meisten Effekte, die mit dieser Technik erzeugt werden, unidirektional sind.  Sie werden auf die GPU √ºbertragen und die GPU erledigt ihre Arbeit ohne weitere Eingriffe und R√ºckmeldungen.  Wenn ich die Wellenl√§nge aus dem Wasser beispielsweise in physikalische Berechnungen einbetten wollte (zum Beispiel, damit die Schiffe mit den Wellen mitschwingen), ben√∂tigte ich Werte aus der Faltungstextur.  Das Abrufen von Texturdaten von einer GPU ist ein schrecklich langsamer Prozess, der nicht in Echtzeit ausgef√ºhrt werden muss.  Die L√∂sung f√ºr dieses Problem kann die Implementierung von zwei Simulationen sein: eine mit einer hohen Aufl√∂sung f√ºr Wassergrafiken als Faltungstextur, die andere mit einer niedrigen Aufl√∂sung in der CPU f√ºr Wasserphysik.  Wenn die Algorithmen gleich sind, k√∂nnen die Abweichungen durchaus akzeptabel sein. </li></ul><br>  Die Demos in diesem Artikel k√∂nnen weiter optimiert werden.  Im Gras-Beispiel k√∂nnen Sie eine Textur mit viel geringerer Aufl√∂sung ohne erkennbare M√§ngel verwenden.  Dies wird in gro√üen Szenen sehr hilfreich sein.  Eine weitere Optimierung: Sie k√∂nnen beispielsweise in jedem vierten Frame oder in einem Viertel pro Frame eine niedrigere Aktualisierungsrate verwenden (da diese Technik keine Probleme mit segmentierten Aktualisierungen verursacht).  Um eine gleichm√§√üige Bildrate aufrechtzuerhalten, k√∂nnen der vorherige und der aktuelle Zustand der Faltungstextur interpoliert werden. <br><br>  Da Faltungsstrukturen eine interne Doppelpufferung verwenden, k√∂nnen Sie beide Strukturen gleichzeitig zum Rendern verwenden.  Der prim√§re Puffer ist der aktuelle Status und der sekund√§re der vorherige.  Dies kann n√ºtzlich sein, um die Textur √ºber die Zeit zu interpolieren oder um Ableitungen f√ºr Texturwerte zu berechnen. <br><br><h2>  Fazit </h2><br>  GPUs, insbesondere in 2D-Programmen, sind h√§ufig inaktiv.  Obwohl es den Anschein hat, dass es nur zum Rendern komplexer 3D-Szenen verwendet werden kann, zeigt die in diesem Artikel beschriebene Technik mindestens eine andere M√∂glichkeit, die Leistung der GPU zu nutzen.  Mithilfe der Funktionen, f√ºr die die GPU entwickelt wurde, k√∂nnen Sie interessante Effekte und Animationen implementieren, die f√ºr die CPU normalerweise zu kostspielig sind. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de478772/">https://habr.com/ru/post/de478772/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de478752/index.html">Geschichte der Versionskontrollsysteme</a></li>
<li><a href="../de478758/index.html">Hervorragende UTM-Tag-Anleitung: So finden Sie heraus, woher Benutzer kommen</a></li>
<li><a href="../de478760/index.html">"Zero" H√∂lle und wie man da rauskommt</a></li>
<li><a href="../de478764/index.html">JavaScript-Fehler: beheben, verarbeiten, reparieren</a></li>
<li><a href="../de478766/index.html">Passen Sie die Zuordnung von Spring MVC-Controllern an</a></li>
<li><a href="../de478774/index.html">Neujahrsstimmung von Arduino und St√∂cken</a></li>
<li><a href="../de478782/index.html">Erlangung der Genehmigung zum Fliegen einer Drohne (BVS, UAV) in der Russischen F√∂deration</a></li>
<li><a href="../de478788/index.html">In einem bestimmten K√∂nigreich, nicht in einem "springenden" Zustand. Yandex-Bericht</a></li>
<li><a href="../de478790/index.html">Julia und Verteilungssemantik</a></li>
<li><a href="../de478796/index.html">Undergraduate in den USA: Unkonventioneller Weg zu Top High Schools</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>