<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§∂üèº üîí üåÇ Verificando o c√≥digo fonte de Roslyn üíê üë®‚Äçüé§ üò´</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Periodicamente, voltamos aos projetos que testamos anteriormente com o PVS-Studio e escrevemos artigos sobre o assunto. H√° duas raz√µes para fazer isso...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Verificando o c√≥digo fonte de Roslyn</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/pvs-studio/blog/446592/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/833/abb/d94/833abbd94d6e48526a175b89fffc9dd5.png" alt="Roslyn vs PVS-Studio"></div><br>  Periodicamente, voltamos aos projetos que testamos anteriormente com o PVS-Studio e escrevemos artigos sobre o assunto.  H√° duas raz√µes para fazer isso.  Primeiro, para entender o qu√£o melhor nosso analisador se tornou.  Em segundo lugar, para rastrear se os autores do projeto prestaram aten√ß√£o ao nosso artigo, bem como ao relat√≥rio de erros que geralmente fornecemos a eles.  Obviamente, os erros podem ser corrigidos sem a nossa participa√ß√£o.  Mas √© sempre bom quando exatamente nossos esfor√ßos ajudam a melhorar um projeto.  Roslyn n√£o foi exce√ß√£o.  Um artigo de revis√£o anterior deste projeto data de 23 de dezembro de 2015.  Isso √© bastante tempo, considerando o caminho que nosso analisador percorreu em seu desenvolvimento durante esse per√≠odo.  Para n√≥s, pessoalmente, Roslyn tamb√©m √© de interesse adicional pelo fato de o n√∫cleo do analisador C # PVS-Studio se basear nele.  Portanto, estamos muito interessados ‚Äã‚Äãna qualidade do c√≥digo para este projeto.  Organizaremos uma segunda verifica√ß√£o e descobriremos o que h√° de novo e interessante (mas esperemos que nada significativo) o PVS-Studio possa encontrar l√°. <br><a name="habracut"></a><br>  Roslyn (ou a plataforma do compilador .NET) provavelmente √© familiar para muitos de nossos leitores.  Em resumo, √© um conjunto de APIs e compiladores de c√≥digo aberto para an√°lise de c√≥digo para as linguagens C # e Visual Basic .NET da Microsoft.  O c√≥digo fonte do projeto est√° dispon√≠vel no <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">GitHub</a> . <br><br>  N√£o vou dar uma descri√ß√£o detalhada dessa plataforma, mas eu recomendaria a todos os interessados ‚Äã‚Äãum artigo do meu colega Sergey Vasiliev, " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Introdu√ß√£o ao Roslyn. Usando ferramentas de an√°lise est√°tica para desenvolver</a> ".  Neste artigo, voc√™ pode aprender n√£o apenas sobre os recursos da arquitetura Roslyn, mas tamb√©m como exatamente usamos essa plataforma. <br><br>  Como mencionei anteriormente, mais de tr√™s anos se passaram desde a reda√ß√£o do √∫ltimo artigo de meu colega Andrei Karpov sobre a verifica√ß√£o de Roslyn " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Lan√ßamento de ano novo do PVS-Studio 6.00: verifica√ß√£o de Roslyn</a> ".  Durante esse per√≠odo, o analisador C # PVS-Studio adquiriu muitos recursos novos.  Em geral, o artigo de Andrey era uma esp√©cie de "bola de teste", porque o analisador C # foi adicionado apenas ao PVS-Studio.  Apesar disso, mesmo assim, em um projeto incondicionalmente de alta qualidade, Roslyn conseguiu encontrar erros interessantes.  O que mudou no analisador para o c√≥digo C # at√© agora, o que potencialmente permitir√° uma an√°lise mais profunda? <br><br>  Nos √∫ltimos tempos, o n√∫cleo do analisador e a infraestrutura foram desenvolvidos.  Foi adicionado suporte para o Visual Studio 2017 e Roslyn 2.0, al√©m de profunda integra√ß√£o com o MSBuild.  Voc√™ pode ler mais sobre nossa abordagem de integra√ß√£o com o MSBuild e sobre os motivos que nos levaram a aceit√°-la no artigo de meu colega Pavel Yeremeyev, " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Suporte para Visual Studio 2017 e Roslyn 2.0 no PVS-Studio: √†s vezes, usar solu√ß√µes prontas n√£o √© t√£o f√°cil quanto parece. de relance</a> . " <br><br>  Agora, estamos trabalhando ativamente na transi√ß√£o para o Roslyn 3.0, de acordo com o mesmo esquema em que inicialmente apoiamos o Visual Studio 2017, ou seja, por meio de nosso pr√≥prio conjunto de ferramentas, que vem no kit de distribui√ß√£o PVS-Studio com um "esbo√ßo" na forma de um arquivo MSBuild.exe vazio.  Apesar de parecer uma "muleta" (a API do MSBuild n√£o √© muito amig√°vel para reutiliza√ß√£o em projetos de terceiros patentes devido √† baixa portabilidade das bibliotecas), essa abordagem j√° nos ajudou a reviver v√°rias atualiza√ß√µes indolores de Roslyn durante a vida do Visual Studio 2017, de maneira relativamente indolor. e agora, embora com muitas sobreposi√ß√µes, sobreviva √† atualiza√ß√£o para o Visual Studio 2019, al√©m de manter a compatibilidade e o desempenho com vers√µes anteriores em sistemas com vers√µes mais antigas do MSBuild. <br><br>  O n√∫cleo do analisador tamb√©m passou por v√°rias melhorias.  Uma das principais inova√ß√µes √© uma an√°lise interprocedual completa, levando em considera√ß√£o os valores de entrada e sa√≠da dos m√©todos, levando em considera√ß√£o, dependendo desses par√¢metros, a acessibilidade dos ramos de execu√ß√£o e pontos de retorno. <br><br>  A tarefa de rastrear par√¢metros dentro dos m√©todos j√° est√° quase conclu√≠da, preservando as anota√ß√µes autom√°ticas para o que acontece com esses par√¢metros (por exemplo, uma desrefer√™ncia potencialmente perigosa).  Isso permitir√° que qualquer diagn√≥stico que use o mecanismo de fluxo de dados leve em considera√ß√£o situa√ß√µes perigosas que ocorrem ao passar um par√¢metro para um m√©todo.  Anteriormente, ao analisar locais t√£o perigosos, um aviso n√£o era gerado, pois n√£o pod√≠amos conhecer todos os poss√≠veis valores de entrada para esse m√©todo.  Agora podemos detectar o perigo, pois em todos os locais em que esse m√©todo √© chamado, esses par√¢metros de entrada ser√£o levados em considera√ß√£o. <br><br>  Nota: voc√™ pode se familiarizar com os principais mecanismos do analisador, como fluxo de dados e outros, no artigo " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Tecnologias usadas no analisador de c√≥digo PVS-Studio para encontrar erros e vulnerabilidades em potencial</a> ". <br><br>  A an√°lise interprocedural no PVS-Studio C # n√£o √© limitada pelos par√¢metros de entrada ou pela profundidade.  A √∫nica limita√ß√£o s√£o os m√©todos virtuais em classes que n√£o foram fechadas por heran√ßa e ca√≠ram em recurs√£o (pararemos quando vimos na pilha uma chamada repetida para um m√©todo j√° calculado).  Al√©m disso, o pr√≥prio m√©todo recursivo ser√° finalmente calculado com a suposi√ß√£o de que o valor de retorno de sua auto-recurs√£o √© desconhecido. <br><br>  Outra grande inova√ß√£o no analisador C # √© a possibilidade de desreferenciar um ponteiro potencialmente nulo.  Anteriormente, o analisador jurava uma poss√≠vel exce√ß√£o de refer√™ncia nula se tivesse certeza de que em todas as ramifica√ß√µes de execu√ß√£o o valor da vari√°vel seria nulo.  Obviamente, ele √†s vezes estava enganado; portanto, o diagn√≥stico do <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">V3080</a> era anteriormente chamado de refer√™ncia nula potencial. <br><br>  Agora, o analisador lembra que a vari√°vel pode ser nula em uma das ramifica√ß√µes de execu√ß√£o (por exemplo, sob uma determinada condi√ß√£o em if).  Se ele vir acesso a essa vari√°vel sem verificar, receber√° uma mensagem V3080, mas com um n√≠vel de import√¢ncia menor do que se vir nulo em todas as ramifica√ß√µes.  Em combina√ß√£o com a an√°lise interprocedural aprimorada, esse mecanismo permite encontrar muito dif√≠cil detectar erros.  Um exemplo √© uma longa cadeia de chamadas de m√©todo, a √∫ltima com a qual voc√™ n√£o est√° familiarizado e que, por exemplo, retorna nulo em determinadas circunst√¢ncias, mas voc√™ n√£o se protegeu disso porque simplesmente n√£o a conhecia.  Nesse caso, o analisador jura apenas quando v√™ precisamente a atribui√ß√£o de nulo.  Em nossa opini√£o, isso distingue qualitativamente nossa abordagem de uma inova√ß√£o do C # 8.0 como o tipo de refer√™ncia anul√°vel, que, de fato, se resume a definir verifica√ß√µes nulas em cada m√©todo.  Oferecemos uma alternativa - fazer verifica√ß√µes apenas onde o nulo pode realmente chegar, e nosso analisador agora pode procurar essas situa√ß√µes. <br><br>  Portanto, sem demora, passemos ao "interrogat√≥rio" - analisando os resultados da verifica√ß√£o de Roslyn.  Primeiro, vamos olhar para os erros encontrados gra√ßas √†s inova√ß√µes descritas acima.  Em geral, alguns avisos foram emitidos para o c√≥digo Roslyn dessa vez.  Acho que isso se deve ao fato de a plataforma estar se desenvolvendo muito ativamente (atualmente, a base de c√≥digo √© de cerca de 2.770.000 linhas de c√≥digo, excluindo as vazias) e n√£o analisamos esse projeto h√° muito tempo.  No entanto, n√£o existem muitos erros cr√≠ticos, ou seja, eles s√£o de interesse do artigo.  E sim, existem alguns testes em Roslyn que eu, como sempre, exclu√≠ dos testes. <br><br>  Iniciarei com erros V3080, com n√≠vel de criticidade M√©dio, no qual o analisador detectou um poss√≠vel acesso por um link zero, mas n√£o em todos os casos poss√≠veis (ramifica√ß√µes de c√≥digo). <br><br>  <b>Poss√≠vel desrefer√™ncia nula - M√©dia</b> <br><br>  V3080 Poss√≠vel desrefer√™ncia nula.  Considere inspecionar 'atual'.  CSharpSyntaxTreeFactoryService.PositionalSyntaxReference.cs 70 <br><br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> SyntaxNode </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetNode</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(SyntaxNode root)</span></span></span><span class="hljs-function"> </span></span>{ var current = root; .... <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (current.FullSpan.Contains(....)) <span class="hljs-comment"><span class="hljs-comment">// &lt;= { .... var nodeOrToken = current.ChildThatContainsPosition(....); .... current = nodeOrToken.AsNode(); // &lt;= } .... } public SyntaxNode AsNode() { if (_token != null) { return null; } return _nodeOrParent; }</span></span></code> </pre> <br>  Considere o m√©todo <i>GetNode</i> .  O analisador considera que o acesso por refer√™ncia nula √© poss√≠vel na condi√ß√£o do bloco <i>while</i> .  No corpo do bloco <i>while</i> , a vari√°vel <i>atual</i> receber√° um valor - o resultado da execu√ß√£o do m√©todo <i>AsNode</i> .  E esse valor em alguns casos ser√° <i>nulo</i> .  Um bom exemplo de an√°lise interprocedural em a√ß√£o. <br><br>  Agora considere um caso semelhante no qual a an√°lise interprocedural foi realizada por meio de duas chamadas de m√©todo. <br><br>  V3080 Poss√≠vel desrefer√™ncia nula.  Considere inspecionar 'diret√≥rio'.  CommonCommandLineParser.cs 911 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> IEnumerable&lt;CommandLineSourceFile&gt; ExpandFileNamePattern(<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> path, <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> baseDirectory, ....) { <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> directory = PathUtilities.GetDirectoryName(path); .... var resolvedDirectoryPath = (directory.Length == <span class="hljs-number"><span class="hljs-number">0</span></span>) ? <span class="hljs-comment"><span class="hljs-comment">// &lt;= baseDirectory : FileUtilities.ResolveRelativePath(directory, baseDirectory); .... } public static string GetDirectoryName(string path) { return GetDirectoryName(path, IsUnixLikePlatform); } internal static string GetDirectoryName(string path, bool isUnixLike) { if (path != null) { .... } return null; }</span></span></code> </pre> <br>  A vari√°vel de <i>diret√≥rio</i> no corpo do m√©todo <i>ExpandFileNamePattern</i> obt√©m o valor do m√©todo <i>GetDirectoryName (string)</i> .  Isso, por sua vez, retornar√° o resultado do m√©todo <i>GetDirectoryName (string, bool)</i> sobrecarregado, cujo valor pode ser <i>nulo</i> .  Como mais adiante no corpo do m√©todo <i>ExpandFileNamePattern</i> a vari√°vel de <i>diret√≥rio</i> √© usada sem primeiro verificar a igualdade <i>nula</i> , podemos falar sobre a legitimidade do aviso pelo analisador.  Este √© um design potencialmente inseguro. <br><br>  Outro trecho de c√≥digo com o erro V3080, mais precisamente, imediatamente com dois erros emitidos para uma linha de c√≥digo.  Aqui, a an√°lise interprocedural n√£o era necess√°ria. <br><br>  V3080 Poss√≠vel desrefer√™ncia nula.  Considere inspecionar 'spanStartLocation'.  TestWorkspace.cs 574 <br><br>  V3080 Poss√≠vel desrefer√™ncia nula.  Considere inspecionar 'spanEndLocationExclusive'.  TestWorkspace.cs 574 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MapMarkupSpans</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ .... foreach (....) { .... foreach (....) { .... <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>? spanStartLocation = null; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>? spanEndLocationExclusive = null; foreach (....) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (....) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (spanStartLocation == null &amp;&amp; positionInMarkup &lt;= markupSpanStart &amp;&amp; ....) { .... spanStartLocation = ....; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (spanEndLocationExclusive == null &amp;&amp; positionInMarkup &lt;= markupSpanEndExclusive &amp;&amp; ....) { .... spanEndLocationExclusive = ....; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } .... } .... } tempMappedMarkupSpans[key]. Add(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> TextSpan( spanStartLocation.Value, <span class="hljs-comment"><span class="hljs-comment">// &lt;= spanEndLocationExclusive.Value - // &lt;= spanStartLocation.Value)); } } .... }</span></span></code> </pre> <br>  As <i>vari√°veis ‚Äã‚ÄãspanStartLocation</i> e <i>spanEndLocationExclusive</i> s√£o do tipo <i>nulo int</i> e s√£o inicializadas para <i>nulo</i> .  Al√©m disso, no c√≥digo, eles podem receber valores, mas somente se determinadas condi√ß√µes forem atendidas.  Em alguns casos, seu valor permanecer√° igual a <i>nulo</i> .  Al√©m disso, no c√≥digo, essas vari√°veis ‚Äã‚Äãs√£o acessadas por refer√™ncia sem primeiro verificar a igualdade <i>nula</i> , como indica o analisador. <br><br>  O c√≥digo de Roslyn cont√©m alguns desses erros, mais de 100. Geralmente, o padr√£o desses erros √© o mesmo.  Existe algum m√©todo geral que potencialmente retorna <i>nulo</i> .  O resultado desse m√©todo √© usado em um grande n√∫mero de locais, √†s vezes atrav√©s de dezenas de chamadas de m√©todo intermedi√°rias ou verifica√ß√µes adicionais.  √â importante entender que esses erros n√£o s√£o fatais, mas podem levar ao acesso via link nulo.  E detectar esses erros √© muito dif√≠cil.  Portanto, em alguns casos, considere refatorar o c√≥digo, no qual uma exce√ß√£o seria lan√ßada se o m√©todo retornasse <i>nulo</i> .  Caso contr√°rio, voc√™ pode proteger seu c√≥digo apenas com verifica√ß√µes totais, o que √© bastante tedioso e n√£o confi√°vel.  Obviamente, em cada caso, a decis√£o deve ser tomada com base nas caracter√≠sticas do projeto. <br><br>  Nota  Ocorre que, no momento, n√£o h√° situa√ß√µes (dados de entrada) em que o m√©todo retorne <i>nulo</i> e n√£o haja erro real.  No entanto, esse c√≥digo ainda n√£o √© confi√°vel, pois tudo pode mudar quando s√£o feitas altera√ß√µes no c√≥digo. <br><br>  Para fechar o t√≥pico com a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">V3080</a> , vamos dar uma olhada nos erros √≥bvios com o alto n√≠vel de confian√ßa, quando o acesso por um link nulo √© mais prov√°vel ou at√© inevit√°vel. <br><br>  <b>Poss√≠vel desrefer√™ncia nula - Alta</b> <br><br>  V3080 Poss√≠vel desrefer√™ncia nula.  Considere inspecionar 'collectionType.Type'.  AbstractConvertForToForEachCodeRefactoringProvider.cs 137 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> override async Task </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ComputeRefactoringsAsync</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(CodeRefactoringContext context)</span></span></span><span class="hljs-function"> </span></span>{ .... var collectionType = semanticModel.GetTypeInfo(....); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (collectionType.Type == null &amp;&amp; collectionType.Type.TypeKind == TypeKind.Error) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } .... }</code> </pre> <br>  Devido a um erro de digita√ß√£o na condi√ß√£o (em vez do operador <i>||</i> que usamos <i>&amp;&amp;</i> ), o c√≥digo n√£o funciona conforme o esperado e a vari√°vel <i>collectionType.Type</i> ser√° acessada se for <i>nula</i> .  A condi√ß√£o deve ser corrigida da seguinte maneira: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (collectionType.Type == null || collectionType.Type.TypeKind == TypeKind.Error) ....</code> </pre> <br>  A prop√≥sito, a segunda variante do desenvolvimento de eventos tamb√©m √© poss√≠vel: na primeira parte, as condi√ß√µes s√£o misturadas pelos operadores <i>==</i> e <i>! =</i> .  Em seguida, o c√≥digo corrigido seria: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (collectionType.Type != null &amp;&amp; collectionType.Type.TypeKind == TypeKind.Error) ....</code> </pre> <br>  Esta vers√£o do c√≥digo √© menos l√≥gica, mas tamb√©m corrige o erro.  A decis√£o final √© com os autores do projeto. <br><br>  Outro erro semelhante. <br><br>  V3080 Poss√≠vel desrefer√™ncia nula.  Considere inspecionar 'a√ß√£o'.  TextViewWindow_InProc.cs 372 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Func&lt;IWpfTextView, Task&gt; GetLightBulbApplicationAction(....) { .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (action == null) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> InvalidOperationException( $<span class="hljs-string"><span class="hljs-string">"Unable to find FixAll in {fixAllScope.ToString()} code fix for suggested action '{action.DisplayText}'."</span></span>); } .... }</code> </pre> <br>  Ocorreu um erro ao compor uma mensagem para uma exce√ß√£o.  Ao mesmo tempo, √© feita uma tentativa de acessar a propriedade <i>action.DisplayText</i> atrav√©s da vari√°vel <i>action</i> , que obviamente √© <i>nula</i> . <br><br>  E o √∫ltimo erro √© o n√≠vel alto do V3080. <br><br>  V3080 Poss√≠vel desrefer√™ncia nula.  Considere inspecionar 'tipo'.  ObjectFormatterHelpers.cs 91 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IsApplicableAttribute</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( TypeInfo type, TypeInfo targetType, </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> targetTypeName)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> type != null &amp;&amp; AreEquivalent(targetType, type) || targetTypeName != null &amp;&amp; type.FullName == targetTypeName; }</code> </pre> <br>  O m√©todo √© pequeno, ent√£o eu dou todo o c√≥digo.  A condi√ß√£o no bloco de <i>devolu√ß√£o</i> est√° incorreta.  Em alguns casos, √© poss√≠vel lan√ßar uma <i>NullReferenceException</i> ao acessar <i>type.FullName</i> .  Eu uso colchetes (eles n√£o mudar√£o de comportamento aqui) para esclarecer a situa√ß√£o: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (type != null &amp;&amp; AreEquivalent(targetType, type)) || (targetTypeName != null &amp;&amp; type.FullName == targetTypeName);</code> </pre> <br>  √â assim que, de acordo com a prioridade das opera√ß√µes, esse c√≥digo funcionar√°.  Se a vari√°vel <i>type</i> for <i>nula</i> , entramos em uma verifica√ß√£o else, onde, certificando-se de que a vari√°vel <i>targetTypeName</i> seja <i>nula</i> , usamos a refer√™ncia de <i>tipo</i> nula.  Voc√™ pode corrigir o c√≥digo, por exemplo, assim: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> type != null &amp;&amp; (AreEquivalent(targetType, type) || targetTypeName != null &amp;&amp; type.FullName == targetTypeName);</code> </pre> <br>  Acho que √© a√≠ que voc√™ pode concluir o estudo dos erros do V3080 e ver o que mais o analisador interessante do PVS-Studio conseguiu encontrar no c√≥digo de Roslyn. <br><br>  <b>Typo</b> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">V3005</a> A vari√°vel 'SourceCodeKind' √© atribu√≠da a si mesma.  DynamicFileInfo.cs 17 <br><br><pre> <code class="cpp hljs">internal sealed <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DynamicFileInfo</span></span></span><span class="hljs-class"> {</span></span> .... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DynamicFileInfo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> filePath, SourceCodeKind sourceCodeKind, TextLoader textLoader, IDocumentServiceProvider documentServiceProvider)</span></span></span><span class="hljs-function"> </span></span>{ FilePath = filePath; SourceCodeKind = SourceCodeKind; <span class="hljs-comment"><span class="hljs-comment">// &lt;= TextLoader = textLoader; DocumentServiceProvider = documentServiceProvider; } .... }</span></span></code> </pre> <br>  Devido a um nome de vari√°vel malsucedido, um erro de digita√ß√£o foi feito no construtor da classe <i>DynamicFileInfo</i> .  O <i>campo SourceCodeKind</i> recebe seu pr√≥prio valor, em vez de usar o par√¢metro <i>sourceCodeKind</i> .  Para minimizar a probabilidade de tais erros, √© recomend√°vel usar o prefixo de sublinhado para nomes de par√¢metros nesses casos.  Vou dar um exemplo de uma vers√£o corrigida do c√≥digo: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DynamicFileInfo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> _filePath, SourceCodeKind _sourceCodeKind, TextLoader _textLoader, IDocumentServiceProvider _documentServiceProvider)</span></span></span><span class="hljs-function"> </span></span>{ FilePath = _filePath; SourceCodeKind = _sourceCodeKind; TextLoader = _textLoader; DocumentServiceProvider = _documentServiceProvider; }</code> </pre> <br>  <b>Descuido</b> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">V3006</a> O objeto foi criado, mas n√£o est√° sendo usado.  A palavra-chave 'throw' pode estar ausente: throw new InvalidOperationException (FOO).  ProjectBuildManager.cs 61 <br><br><pre> <code class="cpp hljs">~ProjectBuildManager() { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_batchBuildStarted) { <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> InvalidOperationException(<span class="hljs-string"><span class="hljs-string">"ProjectBuilderManager.Stop() not called."</span></span>); } }</code> </pre> <br>  Sob uma determinada condi√ß√£o, o destruidor deve lan√ßar uma exce√ß√£o, mas isso n√£o acontece, e o objeto de exce√ß√£o √© simplesmente criado.  A palavra-chave <i>throw</i> foi omitida.  Vers√£o corrigida do c√≥digo: <br><br><pre> <code class="cpp hljs">~ProjectBuildManager() { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_batchBuildStarted) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> InvalidOperationException(<span class="hljs-string"><span class="hljs-string">"ProjectBuilderManager.Stop() not called."</span></span>); } }</code> </pre> <br>  A quest√£o de trabalhar com destruidores em C # e lan√ßar exce√ß√µes a eles √© um t√≥pico para uma discuss√£o separada, que est√° al√©m do escopo deste artigo. <br><br>  <b>Quando o resultado n√£o √© importante</b> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">V√°rios</a> avisos do <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">V3009</a> foram recebidos para m√©todos que retornam o mesmo valor em todos os casos.  √Äs vezes, isso n√£o √© cr√≠tico ou o c√≥digo de retorno simplesmente n√£o √© verificado no c√≥digo de chamada.  Eu perdi esses avisos.  Mas alguns peda√ßos de c√≥digo pareciam suspeitos para mim.  Vou citar um deles: <br><br>  V3009 √â estranho que esse m√©todo sempre retorne um e o mesmo valor de 'true'.  GoToDefinitionCommandHandler.cs 62 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">internal </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TryExecuteCommand</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> (context.OperationContext.AddScope(....)) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (....) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } } .... <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> <br>  O m√©todo <i>TryExecuteCommand</i> retorna apenas <i>true</i> e nada al√©m de <i>true</i> .  Ao mesmo tempo, o valor de retorno est√° envolvido em algumas verifica√ß√µes no c√≥digo de chamada: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ExecuteCommand</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (caretPos.HasValue &amp;&amp; TryExecuteCommand(....)) { .... } .... }</code> </pre> <br>  √â dif√≠cil dizer o qu√£o perigoso √© esse comportamento.  Mas se o resultado n√£o for necess√°rio, pode valer a pena substituir o tipo de retorno por void e fazer altera√ß√µes m√≠nimas no m√©todo de chamada.  Isso tornar√° o c√≥digo mais compreens√≠vel e seguro. <br><br>  Outros avisos semelhantes: <br><br><ul><li>  V3009 √â estranho que esse m√©todo sempre retorne um e o mesmo valor de 'true'.  CommentUncommentSelectionCommandHandler.cs 86 </li><li>  V3009 √â estranho que esse m√©todo sempre retorne um e o mesmo valor de 'true'.  RenomearTrackingTaggerProvider.RenameTrackingCommitter.cs 99 </li><li>  V3009 √â estranho que esse m√©todo sempre retorne um e o mesmo valor de 'true'.  JsonRpcClient.cs 138 </li><li>  V3009 √â estranho que esse m√©todo sempre retorne um e o mesmo valor de 'true'.  AbstractFormatEngine.OperationApplier.cs 164 </li><li>  V3009 √â estranho que esse m√©todo sempre retorne um e o mesmo valor de 'false'.  TriviaDataFactory.CodeShapeAnalyzer.cs 254 </li><li>  V3009 √â estranho que esse m√©todo sempre retorne um e o mesmo valor de 'true'.  ObjectList.cs 173 </li><li>  V3009 √â estranho que esse m√©todo sempre retorne um e o mesmo valor de 'true'.  ObjectList.cs 249 </li></ul><br>  <b>N√£o verificado</b> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">V3019</a> Possivelmente, uma vari√°vel incorreta √© comparada com nulo ap√≥s a convers√£o do tipo usando a palavra-chave 'as'.  Verifique as vari√°veis ‚Äã‚Äã'valor', 'valueToSerialize'.  RoamingVisualStudioProfileOptionPersister.cs 277 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TryPersist</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(OptionKey optionKey, object value)</span></span></span><span class="hljs-function"> </span></span>{ .... var valueToSerialize = value as NamingStylePreferences; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (value != null) { value = valueToSerialize.CreateXElement().ToString(); } .... }</code> </pre> <br>  O <i>valor da</i> vari√°vel √© do tipo <i>NamingStylePreferences</i> .  O problema est√° seguindo essa verifica√ß√£o.  Mesmo que a vari√°vel <i>value</i> n√£o seja nula, isso n√£o garante que a convers√£o do tipo tenha sido bem-sucedida e que <i>valueToSerialize</i> n√£o contenha <i>nulo</i> .  Uma <i>NullReferenceException pode ser lan√ßada</i> .  O c√≥digo precisa ser corrigido da seguinte maneira: <br><br><pre> <code class="cpp hljs">var valueToSerialize = value as NamingStylePreferences; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (valueToSerialize != null) { value = valueToSerialize.CreateXElement().ToString(); }</code> </pre> <br>  E mais um erro semelhante. <br><br>  V3019 Possivelmente, uma vari√°vel incorreta √© comparada com nulo ap√≥s a convers√£o do tipo usando a palavra-chave 'as'.  Verifique as vari√°veis ‚Äã‚Äã'columnState', 'columnState2'.  StreamingFindUsagesPresenter.cs 181 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetDefinitionGroupingPriority</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ .... foreach (var columnState in ....) { var columnState2 = columnState as ColumnState2; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (columnState?.Name == <span class="hljs-comment"><span class="hljs-comment">// &lt;= StandardTableColumnDefinitions2.Definition) { newColumns.Add(new ColumnState2( columnState2.Name, // &lt;= ....)); } .... } .... }</span></span></code> </pre> <br>  A vari√°vel <i>columnState</i> √© do tipo <i>ColumnState2</i> .  No entanto, o resultado da opera√ß√£o, a vari√°vel <i>columnState2</i> , n√£o √© mais verificado quanto a <i>nulo</i> .  Em vez disso, a vari√°vel <i>columnState √©</i> verificada usando a instru√ß√£o <i>nula</i> condicional.  Qual √© o perigo desse c√≥digo?  Como no exemplo anterior, a convers√£o de tipo usando o operador as pode falhar e a vari√°vel <i>columnState2</i> ser√° <i>nula</i> , o que lan√ßar√° uma exce√ß√£o.  A prop√≥sito, um erro de digita√ß√£o pode ser o culpado.  Observe a condi√ß√£o no bloco <i>if</i> .  Talvez em vez de <i>columnState? .Name</i> eles quisessem escrever <i>columnState2? .Name</i> .  Isso √© muito prov√°vel, devido aos nomes de vari√°veis ‚Äã‚Äãbastante infelizes <i>columnState e columnState2.</i> <br><br>  <b>Verifica√ß√µes redundantes</b> <br><br>  Um n√∫mero bastante grande de avisos (acima de 100) foi emitido para constru√ß√µes n√£o cr√≠ticas, mas potencialmente inseguras associadas a verifica√ß√µes redundantes.  Por exemplo, darei um deles. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">A</a> express√£o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">V3022</a> 'navInfo == null' sempre √© falsa.  AbstractSyncClassViewCommandHandler.cs 101 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ExecuteCommand</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ .... IVsNavInfo navInfo = null; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (symbol != null) { navInfo = libraryService.NavInfoFactory.CreateForSymbol(....); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (navInfo == null) { navInfo = libraryService.NavInfoFactory.CreateForProject(....); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (navInfo == null) <span class="hljs-comment"><span class="hljs-comment">// &lt;= { return true; } .... } public IVsNavInfo CreateForSymbol(....) { .... return null; } public IVsNavInfo CreateForProject(....) { return new NavInfo(....); }</span></span></code> </pre> <br>  Talvez n√£o haja nenhum erro real aqui.  Apenas uma boa raz√£o para demonstrar a combina√ß√£o de tecnologias "an√°lise interprocedural + an√°lise de fluxo de dados" em a√ß√£o.  O analisador considera que a segunda verifica√ß√£o <i>navInfo == null √©</i> redundante.  De fato, antes disso, o valor para atribuir <i>navInfo</i> ser√° obtido a partir do m√©todo <i>libraryService.NavInfoFactory.CreateForProject</i> , que construir√° e retornar√° um novo objeto da classe <i>NavInfo</i> .  Mas n√£o <i>nulo de</i> forma alguma.  A quest√£o √©: por que o analisador n√£o <i>gerou um</i> aviso para a primeira verifica√ß√£o <i>navInfo == null</i> ?  H√° uma explica√ß√£o para isso.  Primeiro, se a vari√°vel do <i>s√≠mbolo</i> for <i>nula</i> , o valor de <i>navInfo</i> permanecer√° uma refer√™ncia nula.  Em segundo lugar, mesmo se <i>navInfo</i> obtiver o valor do m√©todo <i>libraryService.NavInfoFactory.CreateForSymbol</i> , esse valor poder√° ser <i>nulo</i> .  Portanto, a primeira verifica√ß√£o de <i>navInfo == null √©</i> realmente necess√°ria. <br><br>  <b>Cheques insuficientes</b> <br><br>  E agora a situa√ß√£o √© o inverso do acima.  V√°rios avisos da <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">V3042</a> foram recebidos para c√≥digo que pode ser acessado por uma refer√™ncia nula.  Al√©m disso, apenas uma ou duas pequenas verifica√ß√µes poderiam consertar tudo. <br><br>  Considere um peda√ßo interessante de c√≥digo que cont√©m dois desses erros. <br><br>  V3042 Poss√≠vel NullReferenceException.  O '?'  e '.'  operadores s√£o usados ‚Äã‚Äãpara acessar membros do objeto 'receptor' Binder_Expressions.cs 7770 <br><br>  V3042 Poss√≠vel NullReferenceException.  O '?'  e '.'  operadores s√£o usados ‚Äã‚Äãpara acessar membros do objeto 'receptor' Binder_Expressions.cs 7776 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> BoundExpression </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetReceiverForConditionalBinding</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( ExpressionSyntax binding, DiagnosticBag diagnostics)</span></span></span><span class="hljs-function"> </span></span>{ .... BoundExpression receiver = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.ConditionalReceiverExpression; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (receiver?.Syntax != <span class="hljs-comment"><span class="hljs-comment">// &lt;= GetConditionalReceiverSyntax(conditionalAccessNode)) { receiver = BindConditionalAccessReceiver(conditionalAccessNode, diagnostics); } var receiverType = receiver.Type; // &lt;= if (receiverType?.IsNullableType() == true) { .... } receiver = new BoundConditionalReceiver(receiver.Syntax, 0, // &lt;= receiverType ?? CreateErrorType(), hasErrors: receiver.HasErrors) // &lt;= { WasCompilerGenerated = true }; return receiver; }</span></span></code> </pre> <br>  A vari√°vel do <i>receptor</i> pode ser <i>nula</i> .  O autor do c√≥digo sabe disso porque ele usa o operador <i>nulo</i> condicional na condi√ß√£o do bloco <i>if</i> para acessar o <i>receptor? .Sintaxe</i> .  Al√©m disso, no c√≥digo, o <i>receptor</i> vari√°vel <i>√©</i> usado sem nenhuma verifica√ß√£o para acessar o <i>receiver.Type</i> , <i>receiver.Syntax</i> e <i>receiver.HasErrors</i> .  Esses erros precisam ser corrigidos: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> BoundExpression </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetReceiverForConditionalBinding</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( ExpressionSyntax binding, DiagnosticBag diagnostics)</span></span></span><span class="hljs-function"> </span></span>{ .... BoundExpression receiver = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.ConditionalReceiverExpression; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (receiver?.Syntax != GetConditionalReceiverSyntax(conditionalAccessNode)) { receiver = BindConditionalAccessReceiver(conditionalAccessNode, diagnostics); } var receiverType = receiver?.Type; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (receiverType?.IsNullableType() == <span class="hljs-literal"><span class="hljs-literal">true</span></span>) { .... } receiver = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BoundConditionalReceiver(receiver?.Syntax, <span class="hljs-number"><span class="hljs-number">0</span></span>, receiverType ?? CreateErrorType(), hasErrors: receiver?.HasErrors) { WasCompilerGenerated = <span class="hljs-literal"><span class="hljs-literal">true</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> receiver; }</code> </pre> <br>  Voc√™ tamb√©m precisa garantir que o construtor <i>BoundConditionalReceiver</i> suporte a obten√ß√£o de valores <i>nulos</i> para seus par√¢metros ou execute refatora√ß√£o adicional. <br><br>  Outros erros semelhantes: <br><br><ul><li>  V3042 Poss√≠vel NullReferenceException.  O '?'  e '.'  operadores s√£o usados ‚Äã‚Äãpara acessar membros do objeto 'containsType' SyntaxGeneratorExtensions_Negate.cs 240 </li><li>  V3042 Poss√≠vel NullReferenceException.  O '?'  e '.'  operadores s√£o usados ‚Äã‚Äãpara acessar membros do objeto 'express√£o' ExpressionSyntaxExtensions.cs 349 </li><li>  V3042 Poss√≠vel NullReferenceException.  O '?'  e '.'  operadores s√£o usados ‚Äã‚Äãpara acessar membros do objeto 'express√£o' ExpressionSyntaxExtensions.cs 349 </li></ul><br>  <b>Erro na condi√ß√£o</b> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">V3057</a> A fun√ß√£o ' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Substring</a> ' pode receber o valor '-1' enquanto se espera um valor n√£o negativo.  Inspecione o segundo argumento.  CommonCommandLineParser.cs 109 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">internal </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TryParseOption</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (colon &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span>) { name = arg.Substring(<span class="hljs-number"><span class="hljs-number">1</span></span>, colon - <span class="hljs-number"><span class="hljs-number">1</span></span>); value = arg.Substring(colon + <span class="hljs-number"><span class="hljs-number">1</span></span>); } .... }</code> </pre> <br>  Se a vari√°vel de <i>dois pontos</i> for 0, o que permite uma condi√ß√£o no c√≥digo, o m√©todo <i>Substring</i> lan√ßar√° uma <i>ArgumentOutOfRangeException</i> .  Corre√ß√£o necess√°ria: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (colon &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>)</code> </pre> <br>  <b>Erro de digita√ß√£o √© poss√≠vel</b> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">V3065 O</a> par√¢metro 't2' n√£o √© utilizado dentro do corpo do m√©todo.  CSharpCodeGenerationHelpers.cs 84 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> TypeDeclarationSyntax </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ReplaceUnterminatedConstructs</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ .... var updatedToken = lastToken.ReplaceTrivia(lastToken.TrailingTrivia, (t1, t2) =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (t1.Kind() == SyntaxKind.MultiLineCommentTrivia) { var text = t1.ToString(); .... } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (t1.Kind() == SyntaxKind.SkippedTokensTrivia) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ReplaceUnterminatedConstructs(t1); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> t1; }); .... }</code> </pre> <br>  Dois par√¢metros s√£o passados ‚Äã‚Äãpara a express√£o lambda: t1 e t2.  No entanto, apenas t1 √© usado.  Parece suspeito, considerando como √© f√°cil cometer um erro ao usar vari√°veis ‚Äã‚Äãcom esses nomes. <br><br>  <b>Descuido</b> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">V3083 Chamada n√£o segura</a> do evento 'TagsChanged', NullReferenceException √© poss√≠vel.  Considere atribuir um evento a uma vari√°vel local antes de invoc√°-lo.  PreviewUpdater.Tagger.cs 37 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnTextBufferChanged</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (PreviewUpdater.SpanToShow != <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (TagsChanged != null) { var span = _textBuffer.CurrentSnapshot.GetFullSpan(); TagsChanged(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SnapshotSpanEventArgs(span)); <span class="hljs-comment"><span class="hljs-comment">// &lt;= } } }</span></span></code> </pre> <br>  O evento <i>TagsChanged √©</i> acionado de maneira insegura.  Entre a verifica√ß√£o da igualdade <i>nula</i> e a chamada de um evento, eles podem ter tempo para cancelar a inscri√ß√£o, e uma exce√ß√£o ser√° lan√ßada.  Al√©m disso, no corpo do bloco <i>if</i> , imediatamente antes da chamada do evento, algumas outras opera√ß√µes s√£o feitas.  Chamei esse erro de "Desaten√ß√£o", porque em outros lugares do c√≥digo eles trabalham com esse evento com mais precis√£o, por exemplo, assim: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnTrackingSpansChanged</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> leafChanged)</span></span></span><span class="hljs-function"> </span></span>{ var handler = TagsChanged; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (handler != null) { var snapshot = _buffer.CurrentSnapshot; handler(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SnapshotSpanEventArgs(snapshot.GetFullSpan())); } }</code> </pre> <br>  O uso da vari√°vel <i>manipuladora</i> opcional elimina o problema.  No m√©todo <i>OnTextBufferChanged</i> , <i>voc√™</i> precisa fazer edi√ß√µes para a mesma opera√ß√£o segura com o evento. <br><br>  <b>Interse√ß√£o de intervalos</b> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">V3092 As</a> interse√ß√µes de faixa s√£o poss√≠veis dentro de express√µes condicionais.  Exemplo: if (A&gt; 0 &amp;&amp; A &lt;5) {...} else if (A&gt; 3 &amp;&amp; A &lt;9) {...}.  ILBuilderEmit.cs 677 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">internal </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EmitLongConstant</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> value)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (value &gt;= <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>.MinValue &amp;&amp; value &lt;= <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>.MaxValue) { .... } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (value &gt;= uint.MinValue &amp;&amp; value &lt;= uint.MaxValue) { .... } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { .... } }</code> </pre> <br>  Para uma melhor compreens√£o, reescreverei esse fragmento de c√≥digo, substituindo os nomes das constantes pelos valores reais: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">internal </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EmitLongConstant</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> value)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (value &gt;= <span class="hljs-number"><span class="hljs-number">-2147483648</span></span> &amp;&amp; value &lt;= <span class="hljs-number"><span class="hljs-number">2147483648</span></span>) { .... } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (value &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; value &lt;= <span class="hljs-number"><span class="hljs-number">4294967295</span></span>) { .... } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { .... } }</code> </pre> <br>  Provavelmente, n√£o h√° nenhum erro real, mas a condi√ß√£o parece estranha.  A segunda parte ( <i>sen√£o se</i> ) ser√° executada apenas para o intervalo de valores de 2147483648 + 1 a 4294967295. <br><br>  Mais alguns destes avisos: <br><br><ul><li>  V3092 As interse√ß√µes de faixa s√£o poss√≠veis dentro de express√µes condicionais.  Exemplo: if (A&gt; 0 &amp;&amp; A &lt;5) {...} else if (A&gt; 3 &amp;&amp; A &lt;9) {...}.  LocalRewriter_Literal.cs 109 </li><li>  V3092 As interse√ß√µes de faixa s√£o poss√≠veis dentro de express√µes condicionais.  Exemplo: if (A&gt; 0 &amp;&amp; A &lt;5) {...} else if (A&gt; 3 &amp;&amp; A &lt;9) {...}.  LocalRewriter_Literal.cs 66 </li></ul><br>  <b>Mais sobre verifica√ß√µes de igualdade nulas (ou a falta delas)</b> <br><br>  Alguns erros do <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">V3095</a> sobre a verifica√ß√£o de uma vari√°vel como <i>nula</i> ap√≥s o uso.  O primeiro √© amb√≠guo, considere o c√≥digo. <br><br>  V3095 O objeto 'displayName' foi usado antes de ser verificado contra nulo.  Verifique as linhas: 498, 503. FusionAssemblyIdentity.cs 498 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">internal </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> IAssemblyName </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ToAssemblyNameObject</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> displayName)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (displayName.IndexOf(<span class="hljs-string"><span class="hljs-string">'\0'</span></span>) &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> null; } Debug.Assert(displayName != null); .... }</code> </pre> <br>  Sup√µe-se que a refer√™ncia <i>displayName</i> possa ser nula.  Para fazer isso, verifique <i>Debug.Assert</i> .  N√£o est√° claro por que isso ocorre depois de usar a string.  Tamb√©m deve ser <i>observado</i> que, para outras configura√ß√µes que n√£o sejam Debug, o compilador <i>remover√° o Debug.Assert</i> do c√≥digo.  Isso significa que apenas para Debug √© poss√≠vel obter uma refer√™ncia nula?  E se n√£o for assim, por que n√£o verificou <i>string.IsNullOrEmpty (string)</i> , por exemplo.  Essas s√£o perguntas para os autores do c√≥digo. <br><br>  O seguinte erro √© mais √≥bvio. <br><br>  V3095 O objeto 'scriptArgsOpt' foi usado antes de ser verificado em rela√ß√£o a nulo.  Verifique as linhas: 321, 325. CommonCommandLineParser.cs 321 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">internal </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FlattenArgs</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(...., List&lt;</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt; scriptArgsOpt, ....)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (args.Count &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (parsingScriptArgs) { scriptArgsOpt.Add(arg); <span class="hljs-comment"><span class="hljs-comment">// &lt;= continue; } if (scriptArgsOpt != null) { .... } .... } }</span></span></code> </pre> <br>  Eu acho que esse peda√ßo de c√≥digo n√£o requer explica√ß√µes.  Vou dar a vers√£o corrigida: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">internal </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FlattenArgs</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(...., List&lt;</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt; scriptArgsOpt, ....)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (args.Count &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (parsingScriptArgs) { scriptArgsOpt?.Add(arg); <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (scriptArgsOpt != null) { .... } .... } }</code> </pre> <br>  O c√≥digo Roslyn encontrou outros 15 desses erros: <br><br><ul><li>  V3095 O objeto 'LocalFunctions' foi usado antes de ser verificado contra nulo.  Verifique as linhas: 289, 317. ControlFlowGraphBuilder.RegionBuilder.cs 289 </li><li>  V3095 O objeto 'resolution.OverloadResolutionResult' foi usado antes de ser verificado como nulo.  Verifique as linhas: 579, 588. Binder_Invocation.cs 579 </li><li>  V3095 O objeto 'resolution.MethodGroup' foi usado antes de ser verificado contra nulo.  Verifique as linhas: 592, 621. Binder_Invocation.cs 592 </li><li>  V3095 O objeto 'touchedFilesLogger' foi usado antes de ser verificado como nulo.  Verifique as linhas: 111, 126. CSharpCompiler.cs 111 </li><li>  V3095 O objeto 'newExceptionRegionsOpt' foi usado antes de ser verificado como nulo.  Verifique as linhas: 736, 743. AbstractEditAndContinueAnalyzer.cs 736 </li><li>  V3095 O objeto 'symbol' foi usado antes de ser verificado com rela√ß√£o a nulo.  Verifique as linhas: 422, 427. AbstractGenerateConstructorService.Editor.cs 422 </li><li>  V3095 O objeto '_state.BaseTypeOrInterfaceOpt' foi usado antes de ser verificado como nulo.  Verifique as linhas: 132, 140. AbstractGenerateTypeService.GenerateNamedType.cs 132 </li><li>  V3095 O objeto 'elemento' foi usado antes de ser verificado com rela√ß√£o a nulo.  Verifique as linhas: 232, 233. ProjectUtil.cs 232 </li><li>  V3095 O objeto 'languages' foi usado antes de ser verificado com valor nulo.  Verifique as linhas: 22, 28. ExportCodeCleanupProvider.cs 22 </li><li>  V3095 O objeto 'memberType' foi usado antes de ser verificado com rela√ß√£o a nulo.  Verifique as linhas: 183, 184. SyntaxGeneratorExtensions_CreateGetHashCodeMethod.cs 183 </li><li>  V3095 O objeto 'validTypeDeclarations' foi usado antes de ser verificado em rela√ß√£o a nulo. Check lines: 223, 228. SyntaxTreeExtensions.cs 223 </li><li> V3095 The 'text' object was used before it was verified against null. Check lines: 376, 385. MSBuildWorkspace.cs 376 </li><li> V3095 The 'nameOrMemberAccessExpression' object was used before it was verified against null. Check lines: 206, 223. CSharpGenerateTypeService.cs 206 </li><li> V3095 The 'simpleName' object was used before it was verified against null. Check lines: 83, 85. CSharpGenerateMethodService.cs 83 </li><li> V3095 The 'option' object was used before it was verified against null. Check lines: 23, 28. OptionKey.cs 23 </li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Considere os erros do </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">V3105</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Aqui, usamos o operador </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nulo</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> condicional </font><font style="vertical-align: inherit;">ao inicializar a vari√°vel e, a seguir, no c√≥digo, a vari√°vel √© usada sem verificar a igualdade </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nula</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O pr√≥ximo erro √© sinalizado imediatamente por dois avisos. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">V3105 A vari√°vel 'documentId' foi usada ap√≥s ser atribu√≠da por meio do operador condicional nulo. NullReferenceException √© poss√≠vel. CodeLensReferencesService.cs 138 </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">V3105 A vari√°vel 'documentId' foi usada ap√≥s ser atribu√≠da por meio do operador condicional nulo. NullReferenceException √© poss√≠vel. CodeLensReferencesService.cs 139</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> async Task&lt;ReferenceLocationDescriptor&gt; GetDescriptorOfEnclosingSymbolAsync(....) { .... var documentId = solution.GetDocument(location.SourceTree)?.Id; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ReferenceLocationDescriptor( .... documentId.ProjectId.Id, documentId.Id, ....); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A vari√°vel </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">documentId</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> pode ser inicializada como </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nula</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Como resultado, a cria√ß√£o do </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ReferenceLocationDescriptor</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> acabar√° lan√ßando uma exce√ß√£o. </font><font style="vertical-align: inherit;">O c√≥digo precisa ser corrigido:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ReferenceLocationDescriptor( .... documentId?.ProjectId.Id, documentId?.Id, ....);</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Al√©m disso, al√©m do c√≥digo, √© necess√°rio prever a possibilidade de igualdade de </font><font style="vertical-align: inherit;">vari√°veis </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nulas</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> passadas para o construtor. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Outros erros semelhantes no c√≥digo:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">V3105 A vari√°vel 'symbol' foi usada ap√≥s ser atribu√≠da atrav√©s do operador condicional nulo. </font><font style="vertical-align: inherit;">NullReferenceException √© poss√≠vel. </font><font style="vertical-align: inherit;">SymbolFinder_Hierarchy.cs 44</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">V3105 A vari√°vel 'symbol' foi usada ap√≥s ser atribu√≠da atrav√©s do operador condicional nulo. </font><font style="vertical-align: inherit;">NullReferenceException √© poss√≠vel. </font><font style="vertical-align: inherit;">SymbolFinder_Hierarchy.cs 51</font></font></li></ul><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Prioridades e colchetes </font></font></b> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">V3123</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Talvez o operador '?:' </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;">Funcione de</font></a><font style="vertical-align: inherit;"> maneira diferente do esperado. Sua prioridade √© menor que a prioridade de outros operadores em sua condi√ß√£o. Edit.cs 70</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Equals</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Edit&lt;TNode&gt; other)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _kind == other._kind &amp;&amp; (_oldNode == null) ? other._oldNode == null : _oldNode.Equals(other._oldNode) &amp;&amp; (_newNode == null) ? other._newNode == null : _newNode.Equals(other._newNode); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A condi√ß√£o no bloco de retorno n√£o √© calculada como pensava o desenvolvedor. </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sup√¥s-</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> se que a primeira condi√ß√£o seria </font><i><font style="vertical-align: inherit;">_tipo == outro._kin</font></i><font style="vertical-align: inherit;"> d (portanto, o </font><i><font style="vertical-align: inherit;">agrupamento de</font></i><font style="vertical-align: inherit;"> linhas foi feito ap√≥s essa condi√ß√£o) e, em seguida, os blocos de condi√ß√µes com o operador </font><font style="vertical-align: inherit;">" </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">?</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> " </font><font style="vertical-align: inherit;">Seriam calculados sequencialmente </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">De fato, a primeira condi√ß√£o ser√° </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">_kind == other._kind &amp;&amp; (_oldNode == null)</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Isso ocorre porque o operador </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">&amp;&amp;</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> tem uma prioridade mais alta que o operador </font><font style="vertical-align: inherit;">" </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">?</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ". </font><font style="vertical-align: inherit;">Para corrigir o erro, √© necess√°rio agrupar todas as express√µes do operador </font><font style="vertical-align: inherit;">" </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">?</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ":</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _kind == other._kind &amp;&amp; ((_oldNode == null) ? other._oldNode == null : _oldNode.Equals(other._oldNode)) &amp;&amp; ((_newNode == null) ? other._newNode == null : _newNode.Equals(other._newNode));</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Isso conclui a descri√ß√£o dos erros encontrados. </font></font><br><br>  <b>Conclus√µes</b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Apesar do n√∫mero significativo de erros que pude detectar, em termos do tamanho do c√≥digo do projeto Roslyn (2.770.000 linhas), isso ser√° uma quantia bastante pequena. Como Andrei no artigo anterior, tamb√©m estou pronto para reconhecer a alta qualidade deste projeto. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Quero observar que essas verifica√ß√µes ocasionais de c√≥digo n√£o t√™m nada a ver com a metodologia da an√°lise est√°tica e praticamente n√£o trazem nenhum benef√≠cio. A an√°lise est√°tica deve ser aplicada regularmente, e n√£o de caso para caso. Muitos erros ser√£o corrigidos nos est√°gios iniciais e, portanto, o custo para corrigi-los ser√° dez vezes menor. Essa id√©ia √© descrita em mais detalhes neste pequeno </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">artigo</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , com o qual pe√ßo que voc√™ se familiarize.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Voc√™ pode procurar por mais erros de forma independente no projeto considerado e em qualquer outro. </font><font style="vertical-align: inherit;">Para fazer isso, basta fazer o </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">download</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> e experimentar o nosso analisador.</font></font><br><br><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><img src="https://habrastorage.org/getpro/habr/post_images/c78/30f/70c/c7830f70c5577c3d6704f254d7cad6a3.png" align="left"></a> </p><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Se voc√™ deseja compartilhar este artigo com um p√∫blico que fala ingl√™s, use o link para a tradu√ß√£o: Sergey Khrenov. </font></font> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Verificando o c√≥digo-fonte da Roslyn</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt446592/">https://habr.com/ru/post/pt446592/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt446578/index.html">Linguagem de programa√ß√£o baseada em cart√£o postal</a></li>
<li><a href="../pt446582/index.html">Reflex√µes sobre hospedagem solar para abelhas</a></li>
<li><a href="../pt446586/index.html">Configura√ß√µes de rede do FreeRadius via DHCP</a></li>
<li><a href="../pt446588/index.html">Verificando o c√≥digo fonte de Roslyn</a></li>
<li><a href="../pt446590/index.html">39 novos recursos dispon√≠veis no Java 12</a></li>
<li><a href="../pt446598/index.html">Recriando fontes CRT</a></li>
<li><a href="../pt446602/index.html">Corrente m√°xima DC atrav√©s do transistor de efeito de campo</a></li>
<li><a href="../pt446604/index.html">ESET: Novos esquemas de entrega de backdoor de grupos cibern√©ticos da OceanLotus</a></li>
<li><a href="../pt446606/index.html">Verifique se voc√™ √© bom em tecnologia aditiva</a></li>
<li><a href="../pt446608/index.html">Superando a Terceira Lei da Gravidade Organizacional</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>