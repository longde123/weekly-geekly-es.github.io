<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨‍👧‍👦 👩🏼‍💼 🗺️ 自记录REST服务器（Node.JS，TypeScript，Koa，Joi，Swagger） 👩🏽‍🎨 👵 🤓</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="已经有很多关于REST的优缺点的文章（甚至在有关它们的评论中）。 而且，如果碰巧需要开发一种应在其中应用此体系结构的服务，那么您肯定会涉及其文档。 毕竟，创建每种方法后，我们当然理解其他程序员将引用这些方法。 因此，文档应该是全面的，最重要的是相关的。 

 欢迎来到这只猫，在这里我将描述我们如何在...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>自记录REST服务器（Node.JS，TypeScript，Koa，Joi，Swagger）</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/449906/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/tg/hh/en/tghhend0r6amxsxj0mhnr9uy3l4.jpeg"></div><br> 已经有很多关于REST的优缺点的文章（甚至在有关它们的评论中）。 而且，如果碰巧需要开发一种应在其中应用此体系结构的服务，那么您肯定会涉及其文档。 毕竟，创建每种方法后，我们当然理解其他程序员将引用这些方法。 因此，文档应该是全面的，最重要的是相关的。 <br><br> 欢迎来到这只猫，在这里我将描述我们如何在团队中解决这个问题。 <br><a name="habracut"></a><br> 有点背景。 <br><br> 我们的团队的任务是在短时间内在<b>Node.js上发布</b>中等复杂度的后端产品。 前端程序员和动员者应该与该产品交互。 <br><br> 经过一番思考，我们决定尝试使用<b>TypeScript</b>作为<b>YaP</b> 。 精心调整的<b>TSLint</b>和<b>Prettier</b>帮助我们在编码/汇编阶段（甚至在提交阶段也很<b>沙哑</b> ）实现相同的代码样式和严格检查。 强类型使每个人都清楚地描述所有对象的接口和类型。 易于阅读和理解此函数将什么作为输入参数，它将最终返回什么，以及对象的哪些属性是强制性的，哪些不是强制性的。 该代码开始非常类似于Java）。 当然， <b>TypeDoc</b>为每个函数增加了可读性。 <br><br> 这是代码的外观： <br><br><pre><code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">/** * Interface of all responses */</span></span> export <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IResponseData</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span></span>{ nonce: number; code: number; message?: string; data?: T; } <span class="hljs-comment"><span class="hljs-comment">/** * Utils helper */</span></span> export <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TransferObjectUtils</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/** * Compose all data to result response package * * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@param</span></span></span><span class="hljs-comment"> responseCode - 200 | 400 | 500 * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@param</span></span></span><span class="hljs-comment"> message - any info text message * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@param</span></span></span><span class="hljs-comment"> data - response data object * * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@return</span></span></span><span class="hljs-comment"> ready object for REST response */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> createResponseObject&lt;T = object&gt;(responseCode: number, message: string, data: T): IResponseData&lt;T&gt; { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> result: IResponseData&lt;T&gt; = { code: responseCode || <span class="hljs-number"><span class="hljs-number">200</span></span>, nonce: Date.now() }; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (message) { result.message = message; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (data) { result.data = data; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; } }</code> </pre> <br> 我们考虑了后代，维护我们的代码并不难，现在应该考虑REST服务器的用户了。 <br><br> 由于一切工作都非常迅速，因此我们了解到分别编写代码和单独编写文档非常困难。 尤其要根据前端或mobilchiki的要求将其他参数添加到答案或请求中，不要忘了警告其他人。 这是出现明确要求的地方： <b>带有文档</b>的<b>代码应始终同步</b> 。 这意味着应该排除人为因素，文档应影响代码，而代码应影响文档。 <br><br> 在这里，我深入研究了为此目的寻找合适的工具。 幸运的是，NPM存储库只是各种想法和解决方案的仓库。 <br><br> 该工具的要求如下： <br><br><ul><li> 文档与代码同步； </li><li>  TypeScript支持； </li><li> 验证传入/传出数据包； </li><li> 实时和受支持的软件包。 </li></ul><br> 我不得不使用许多不同的软件包编写REST服务，其中最受欢迎的软件包是：tsoa，swagger-node-express，express-openapi，swagger-codegen。 <br><br><img src="https://habrastorage.org/webt/fs/dl/7m/fsdl7mmvvi8c64rgqoks-9loh_i.png"><br><br> 但是在某些情况下，没有TypeScript支持，在某些程序包验证中，有些能够基于文档生成代码，但是它们没有提供进一步的同步。 <br><br> 这是我碰巧碰到的地方。 一个很棒的软件包，它可以将Joi方案中描述的内容变成详尽的文档，甚至带有TypeScript支持。 除同步外，所有项目均被执行。 经过一段时间的<b>忙碌</b>之后，我发现了一个废弃的中国人资料库，该人使用<b>joi-to-swagger</b>和Koa框架。 由于我们的团队中没有对Koa的偏见，也没有理由盲目追随Express的趋势，因此我们决定尝试从这个堆栈中脱颖而出。 <br><br> 我分叉了这个存储库，修复了错误，完成了一些工作，现在发布了我对OpenSource Koa-Joi-Swagger-TS的第一篇贡献。 我们成功通过了该项目，在此之后，已经有其他几个项目了。 编写和维护REST服务变得非常方便，这些服务的用户只需要Swagger在线文档的链接即可。 在他们之后，很清楚可以在哪里开发此软件包，并且还进行了其他一些改进。 <br><br> 现在，让我们看看如何使用<b>Koa-Joi-Swagger-TS</b>编写一个自我文档化的REST服务器。  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">我把完成的代码贴在这里</a> 。 <br><br> 由于此项目是一个演示，因此我简化并合并了几个文件。 通常，如果索引初始化应用程序并调用app.ts文件，则该文件将是好的，这将依次读取资源，调用连接到数据库等。 服务器应以最新命令开头（下面将对此进行描述）。 <br><br> 因此，对于初学者来说，创建具有以下内容的<b>index.ts</b> ： <br><br><div class="spoiler">  <b class="spoiler_title">索引</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> Koa <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"koa"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { BaseContext } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"koa"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> bodyParser <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"koa-bodyparser"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> Router <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"koa-router"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> SERVER_PORT = <span class="hljs-number"><span class="hljs-number">3002</span></span>; <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">async</span></span></span></span><span class="hljs-function"><span class="hljs-params"> (</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> app = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Koa(); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> router = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Router(); app.use(bodyParser()); router.get(<span class="hljs-string"><span class="hljs-string">"/"</span></span>, (ctx: BaseContext, <span class="hljs-attr"><span class="hljs-attr">next</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">Function</span></span>) =&gt; { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"Root loaded!"</span></span>) }); app .use(router.routes()) .use(router.allowedMethods()); app.listen(SERVER_PORT); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">`Server listening on http://localhost:</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${SERVER_PORT}</span></span></span><span class="hljs-string"> ...`</span></span>); })();</code> </pre><br><br></div></div><br> 当您启动此服务时，将启动一个REST服务器，到目前为止，尚不知道该如何做。 现在介绍一下项目的体系结构。 由于我从Java切换到Node.JS，因此尝试在此处构建具有相同层的服务。 <br><br><ul><li> 控制器 </li><li> 服务项目 </li><li> 储存库 </li></ul><br> 让我们<b>开始</b>连接<b>Koa-Joi-Swagger-TS</b> 。 自然地安装它。 <br><br><pre> <code class="bash hljs">npm install koa-joi-swagger-ts --save</code> </pre> <br> 在其中创建<b>“ controllers”</b>文件夹和<b>“ schemas”</b>文件夹。 在controllers文件夹中，创建我们的第一个控制器<b>base.controller.ts</b> ： <br><br><div class="spoiler">  <b class="spoiler_title">基本控制器</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { BaseContext } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"koa"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { controller, description, get, response, summary, tag } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"koa-joi-swagger-ts"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { ApiInfoResponseSchema } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"./schemas/apiInfo.response.schema"</span></span>; @controller(<span class="hljs-string"><span class="hljs-string">"/api/v1"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> abstract <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BaseController</span></span></span><span class="hljs-class"> </span></span>{ @get(<span class="hljs-string"><span class="hljs-string">"/"</span></span>) @response(<span class="hljs-number"><span class="hljs-number">200</span></span>, { <span class="hljs-attr"><span class="hljs-attr">$ref</span></span>: ApiInfoResponseSchema }) @tag(<span class="hljs-string"><span class="hljs-string">"GET"</span></span>) @description(<span class="hljs-string"><span class="hljs-string">"Returns text info about version of API"</span></span>) @summary(<span class="hljs-string"><span class="hljs-string">"Show API index page"</span></span>) public <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> index(ctx: BaseContext, <span class="hljs-attr"><span class="hljs-attr">next</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">Function</span></span>): <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>&gt; { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"GET /api/v1/"</span></span>); ctx.status = <span class="hljs-number"><span class="hljs-number">200</span></span>; ctx.body = { <span class="hljs-attr"><span class="hljs-attr">code</span></span>: <span class="hljs-number"><span class="hljs-number">200</span></span>, <span class="hljs-attr"><span class="hljs-attr">data</span></span>: { <span class="hljs-attr"><span class="hljs-attr">appVersion</span></span>: <span class="hljs-string"><span class="hljs-string">"1.0.0"</span></span>, <span class="hljs-attr"><span class="hljs-attr">build</span></span>: <span class="hljs-string"><span class="hljs-string">"1001"</span></span>, <span class="hljs-attr"><span class="hljs-attr">apiVersion</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-attr"><span class="hljs-attr">reqHeaders</span></span>: ctx.request.headers, <span class="hljs-attr"><span class="hljs-attr">apiDoc</span></span>: <span class="hljs-string"><span class="hljs-string">"/api/v1/swagger.json"</span></span> } } }; }</code> </pre><br></div></div><br> 从装饰器（Java注释）中可以看到，该类将与路径“ / api / v1”相关联，内部的所有方法都将与此路径相关。 <br><br> 此方法对响应格式进行了描述，在文件“ ./schemas/apiInfo.response.schema”中进行了描述： <br><br><div class="spoiler">  <b class="spoiler_title">apiInfo.response.schema</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> Joi <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"joi"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { definition } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"koa-joi-swagger-ts"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { BaseAPIResponseSchema } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"./baseAPI.response.schema"</span></span>; @definition(<span class="hljs-string"><span class="hljs-string">"ApiInfo"</span></span>, <span class="hljs-string"><span class="hljs-string">"Information data about current application and API version"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ApiInfoResponseSchema</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BaseAPIResponseSchema</span></span></span><span class="hljs-class"> </span></span>{ public data = Joi.object({ <span class="hljs-attr"><span class="hljs-attr">appVersion</span></span>: Joi.string() .description(<span class="hljs-string"><span class="hljs-string">"Current version of application"</span></span>) .required(), <span class="hljs-attr"><span class="hljs-attr">build</span></span>: Joi.string().description(<span class="hljs-string"><span class="hljs-string">"Current build version of application"</span></span>), <span class="hljs-attr"><span class="hljs-attr">apiVersion</span></span>: Joi.number() .positive() .description(<span class="hljs-string"><span class="hljs-string">"Version of current REST api"</span></span>) .required(), <span class="hljs-attr"><span class="hljs-attr">reqHeaders</span></span>: Joi.object().description(<span class="hljs-string"><span class="hljs-string">"Request headers"</span></span>), <span class="hljs-attr"><span class="hljs-attr">apiDoc</span></span>: Joi.string() .description(<span class="hljs-string"><span class="hljs-string">"URL path to swagger document"</span></span>) .required() }).required(); }</code> </pre><br></div></div><br> 在Joi中对方案进行这种描述的可能性非常广泛，并在此处进行了更详细的描述： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">www.npmjs.com/package/joi-to-swagger</a> <br><br> 这是所描述类的祖先（实际上，这是我们服务的所有答案的基类）： <br><br><div class="spoiler">  <b class="spoiler_title">baseAPI.response.schema</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> Joi <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"joi"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { definition } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"koa-joi-swagger-ts"</span></span>; @definition(<span class="hljs-string"><span class="hljs-string">"BaseAPIResponse"</span></span>, <span class="hljs-string"><span class="hljs-string">"Base response entity with base fields"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BaseAPIResponseSchema</span></span></span><span class="hljs-class"> </span></span>{ public code = Joi.number() .required() .strict() .only(<span class="hljs-number"><span class="hljs-number">200</span></span>, <span class="hljs-number"><span class="hljs-number">400</span></span>, <span class="hljs-number"><span class="hljs-number">500</span></span>) .example(<span class="hljs-number"><span class="hljs-number">200</span></span>) .description(<span class="hljs-string"><span class="hljs-string">"Code of operation result"</span></span>); public message = Joi.string().description(<span class="hljs-string"><span class="hljs-string">"message will be filled in some causes"</span></span>); }</code> </pre><br></div></div><br> 现在，在Koa-Joi-Swagger-TS系统中注册这些电路和控制器。 <br> 在index.ts旁边，创建另一个<b>routing.ts</b>文件： <br><br><div class="spoiler">  <b class="spoiler_title">routing.ts</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { KJSRouter } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"koa-joi-swagger-ts"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { BaseController } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"./controllers/base.controller"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { BaseAPIResponseSchema } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"./controllers/schemas/baseAPI.response.schema"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { ApiInfoResponseSchema } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"./controllers/schemas/apiInfo.response.schema"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> SERVER_PORT = <span class="hljs-number"><span class="hljs-number">3002</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> loadRoutes = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> router = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> KJSRouter({ <span class="hljs-attr"><span class="hljs-attr">swagger</span></span>: <span class="hljs-string"><span class="hljs-string">"2.0"</span></span>, <span class="hljs-attr"><span class="hljs-attr">info</span></span>: { <span class="hljs-attr"><span class="hljs-attr">version</span></span>: <span class="hljs-string"><span class="hljs-string">"1.0.0"</span></span>, <span class="hljs-attr"><span class="hljs-attr">title</span></span>: <span class="hljs-string"><span class="hljs-string">"simple-rest"</span></span> }, <span class="hljs-attr"><span class="hljs-attr">host</span></span>: <span class="hljs-string"><span class="hljs-string">`localhost:</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${SERVER_PORT}</span></span></span><span class="hljs-string">`</span></span>, <span class="hljs-attr"><span class="hljs-attr">basePath</span></span>: <span class="hljs-string"><span class="hljs-string">"/api/v1"</span></span>, <span class="hljs-attr"><span class="hljs-attr">schemes</span></span>: [<span class="hljs-string"><span class="hljs-string">"http"</span></span>], <span class="hljs-attr"><span class="hljs-attr">paths</span></span>: {}, <span class="hljs-attr"><span class="hljs-attr">definitions</span></span>: {} }); router.loadDefinition(ApiInfoResponseSchema); router.loadDefinition(BaseAPIResponseSchema); router.loadController(BaseController); router.setSwaggerFile(<span class="hljs-string"><span class="hljs-string">"swagger.json"</span></span>); router.loadSwaggerUI(<span class="hljs-string"><span class="hljs-string">"/api/docs"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> router.getRouter(); };</code> </pre><br></div></div><br> 在这里，我们创建了KJSRouter类的实例，该实例本质上是Koa-router，但是添加了中间件和处理程序。 <br><br> 因此，在<b>index.ts</b>文件中， <b>我们</b>只需更改 <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> router = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Router();</code> </pre> <br> 在 <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> router = loadRoutes();</code> </pre> <br> 好吧，删除不必要的处理程序： <br><br><div class="spoiler">  <b class="spoiler_title">索引</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> Koa <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"koa"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> bodyParser <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"koa-bodyparser"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { loadRoutes } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"./routing"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> SERVER_PORT = <span class="hljs-number"><span class="hljs-number">3002</span></span>; <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">async</span></span></span></span><span class="hljs-function"><span class="hljs-params"> (</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> app = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Koa(); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> router = loadRoutes(); app.use(bodyParser()); app .use(router.routes()) .use(router.allowedMethods()); app.listen(SERVER_PORT); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">`Server listening on http://localhost:</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${SERVER_PORT}</span></span></span><span class="hljs-string"> ...`</span></span>); })();</code> </pre><br></div></div><br> 启动此服务时，我们可以使用3条路线： <br>  <b>1. / api / v1-</b>记录的路由 <br> 在我的情况下显示： <br><br><div class="spoiler">  <b class="spoiler_title">http：//本地主机：3002 / api / v1</b> <div class="spoiler_text"><pre> <code class="json hljs">{ code: <span class="hljs-number"><span class="hljs-number">200</span></span>, data: { appVersion: <span class="hljs-string"><span class="hljs-string">"1.0.0"</span></span>, build: <span class="hljs-string"><span class="hljs-string">"1001"</span></span>, apiVersion: <span class="hljs-number"><span class="hljs-number">1</span></span>, reqHeaders: { host: <span class="hljs-string"><span class="hljs-string">"localhost:3002"</span></span>, connection: <span class="hljs-string"><span class="hljs-string">"keep-alive"</span></span>, cache-control: <span class="hljs-string"><span class="hljs-string">"max-age=0"</span></span>, upgrade-insecure-requests: <span class="hljs-string"><span class="hljs-string">"1"</span></span>, user-agent: <span class="hljs-string"><span class="hljs-string">"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_4) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/73.0.3683.103 Safari/537.36"</span></span>, accept: <span class="hljs-string"><span class="hljs-string">"text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3"</span></span>, accept-encoding: <span class="hljs-string"><span class="hljs-string">"gzip, deflate, br"</span></span>, accept-language: <span class="hljs-string"><span class="hljs-string">"uk-UA,uk;q=0.9,ru;q=0.8,en-US;q=0.7,en;q=0.6"</span></span> }, apiDoc: <span class="hljs-string"><span class="hljs-string">"/api/v1/swagger.json"</span></span> } }</code> </pre><br></div></div><br> 和两条服务路线： <br><br>  <b>2. /api/v1/swagger.json</b> <br><br><div class="spoiler">  <b class="spoiler_title">swagger.json</b> <div class="spoiler_text"><pre> <code class="json hljs">{ swagger: <span class="hljs-string"><span class="hljs-string">"2.0"</span></span>, info: { version: <span class="hljs-string"><span class="hljs-string">"1.0.0"</span></span>, title: <span class="hljs-string"><span class="hljs-string">"simple-rest"</span></span> }, host: <span class="hljs-string"><span class="hljs-string">"localhost:3002"</span></span>, basePath: <span class="hljs-string"><span class="hljs-string">"/api/v1"</span></span>, schemes: [ <span class="hljs-string"><span class="hljs-string">"http"</span></span> ], paths: { /: { get: { tags: [ <span class="hljs-string"><span class="hljs-string">"GET"</span></span> ], summary: <span class="hljs-string"><span class="hljs-string">"Show API index page"</span></span>, description: <span class="hljs-string"><span class="hljs-string">"Returns text info about version of API"</span></span>, consumes: [ <span class="hljs-string"><span class="hljs-string">"application/json"</span></span> ], produces: [ <span class="hljs-string"><span class="hljs-string">"application/json"</span></span> ], responses: { 200: { description: <span class="hljs-string"><span class="hljs-string">"Information data about current application and API version"</span></span>, schema: { type: <span class="hljs-string"><span class="hljs-string">"object"</span></span>, $ref: <span class="hljs-string"><span class="hljs-string">"#/definitions/ApiInfo"</span></span> } } }, security: [ ] } } }, definitions: { BaseAPIResponse: { type: <span class="hljs-string"><span class="hljs-string">"object"</span></span>, required: [ <span class="hljs-string"><span class="hljs-string">"code"</span></span> ], properties: { code: { type: <span class="hljs-string"><span class="hljs-string">"number"</span></span>, format: <span class="hljs-string"><span class="hljs-string">"float"</span></span>, enum: [ <span class="hljs-number"><span class="hljs-number">200</span></span>, <span class="hljs-number"><span class="hljs-number">400</span></span>, <span class="hljs-number"><span class="hljs-number">500</span></span> ], description: <span class="hljs-string"><span class="hljs-string">"Code of operation result"</span></span>, example: { value: <span class="hljs-number"><span class="hljs-number">200</span></span> } }, message: { type: <span class="hljs-string"><span class="hljs-string">"string"</span></span>, description: <span class="hljs-string"><span class="hljs-string">"message will be filled in some causes"</span></span> } } }, ApiInfo: { type: <span class="hljs-string"><span class="hljs-string">"object"</span></span>, required: [ <span class="hljs-string"><span class="hljs-string">"code"</span></span>, <span class="hljs-string"><span class="hljs-string">"data"</span></span> ], properties: { code: { type: <span class="hljs-string"><span class="hljs-string">"number"</span></span>, format: <span class="hljs-string"><span class="hljs-string">"float"</span></span>, enum: [ <span class="hljs-number"><span class="hljs-number">200</span></span>, <span class="hljs-number"><span class="hljs-number">400</span></span>, <span class="hljs-number"><span class="hljs-number">500</span></span> ], description: <span class="hljs-string"><span class="hljs-string">"Code of operation result"</span></span>, example: { value: <span class="hljs-number"><span class="hljs-number">200</span></span> } }, message: { type: <span class="hljs-string"><span class="hljs-string">"string"</span></span>, description: <span class="hljs-string"><span class="hljs-string">"message will be filled in some causes"</span></span> }, data: { type: <span class="hljs-string"><span class="hljs-string">"object"</span></span>, required: [ <span class="hljs-string"><span class="hljs-string">"appVersion"</span></span>, <span class="hljs-string"><span class="hljs-string">"apiVersion"</span></span>, <span class="hljs-string"><span class="hljs-string">"apiDoc"</span></span> ], properties: { appVersion: { type: <span class="hljs-string"><span class="hljs-string">"string"</span></span>, description: <span class="hljs-string"><span class="hljs-string">"Current version of application"</span></span> }, build: { type: <span class="hljs-string"><span class="hljs-string">"string"</span></span>, description: <span class="hljs-string"><span class="hljs-string">"Current build version of application"</span></span> }, apiVersion: { type: <span class="hljs-string"><span class="hljs-string">"number"</span></span>, format: <span class="hljs-string"><span class="hljs-string">"float"</span></span>, minimum: <span class="hljs-number"><span class="hljs-number">1</span></span>, description: <span class="hljs-string"><span class="hljs-string">"Version of current REST api"</span></span> }, reqHeaders: { type: <span class="hljs-string"><span class="hljs-string">"object"</span></span>, properties: { }, description: <span class="hljs-string"><span class="hljs-string">"Request headers"</span></span> }, apiDoc: { type: <span class="hljs-string"><span class="hljs-string">"string"</span></span>, description: <span class="hljs-string"><span class="hljs-string">"URL path to swagger document"</span></span> } } } } } } }</code> </pre><br></div></div><br>  <b>3. / API /文档</b> <br><br> 这是带有Swagger UI的页面-这是Swagger方案的非常方便的可视表示形式，在其中，除了方便查看之外，您甚至可以生成请求并从服务器获取真实答案。 <br><br><img src="https://habrastorage.org/webt/go/zc/fg/gozcfgxxsvy_qu_us6jbpgutxdo.png"><br><br> 此用户界面需要访问swagger.json文件，这就是为什么包含先前路由的原因。 <br><br> 好吧，一切似乎都在那里，一切正常，但是！.. <br><br> 随着时间的流逝，我们圈出一个这样的实现，我们有很多代码重复。 在控制器需要执行相同操作的情况下。 正是由于这个原因，我后来完成了该程序包，并添加了描述控制器的“包装器”的功能。 <br><br> 考虑这种服务的一个例子。 <br><br> 假设我们有一个带有几种方法的“用户”控制器。 <br><br><div class="spoiler">  <b class="spoiler_title">获取所有用户</b> <div class="spoiler_text"><pre> <code class="javascript hljs"> @get(<span class="hljs-string"><span class="hljs-string">"/"</span></span>) @response(<span class="hljs-number"><span class="hljs-number">200</span></span>, { <span class="hljs-attr"><span class="hljs-attr">$ref</span></span>: UsersResponseSchema }) @response(<span class="hljs-number"><span class="hljs-number">400</span></span>, { <span class="hljs-attr"><span class="hljs-attr">$ref</span></span>: BaseAPIResponseSchema }) @response(<span class="hljs-number"><span class="hljs-number">500</span></span>, { <span class="hljs-attr"><span class="hljs-attr">$ref</span></span>: BaseAPIResponseSchema }) @tag(<span class="hljs-string"><span class="hljs-string">"User"</span></span>) @description(<span class="hljs-string"><span class="hljs-string">"Returns list of all users"</span></span>) @summary(<span class="hljs-string"><span class="hljs-string">"Get all users"</span></span>) public <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> getAllUsers(ctx: BaseContext): <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>&gt; { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"GET /api/v1/users"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> message = <span class="hljs-string"><span class="hljs-string">"Get all users error"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> code = <span class="hljs-number"><span class="hljs-number">400</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> data = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> serviceResult = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> getAllUsers(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (serviceResult) { data = serviceResult; code = <span class="hljs-number"><span class="hljs-number">200</span></span>; message = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (e) { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"Error while getting users list"</span></span>); code = <span class="hljs-number"><span class="hljs-number">500</span></span>; } ctx.status = code; ctx.body = TransferObjectUtils.createResponseObject(code, message, data); };</code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">更新用户</b> <div class="spoiler_text"><pre> <code class="javascript hljs"> @post(<span class="hljs-string"><span class="hljs-string">"/"</span></span>) @parameter(<span class="hljs-string"><span class="hljs-string">"body"</span></span>, { <span class="hljs-attr"><span class="hljs-attr">$ref</span></span>: UsersRequestSchema }, ENUM_PARAM_IN.body) @response(<span class="hljs-number"><span class="hljs-number">200</span></span>, { <span class="hljs-attr"><span class="hljs-attr">$ref</span></span>: BaseAPIResponseSchema }) @response(<span class="hljs-number"><span class="hljs-number">400</span></span>, { <span class="hljs-attr"><span class="hljs-attr">$ref</span></span>: BaseAPIResponseSchema }) @response(<span class="hljs-number"><span class="hljs-number">500</span></span>, { <span class="hljs-attr"><span class="hljs-attr">$ref</span></span>: BaseAPIResponseSchema }) @tag(<span class="hljs-string"><span class="hljs-string">"User"</span></span>) @description(<span class="hljs-string"><span class="hljs-string">"Update user data"</span></span>) @summary(<span class="hljs-string"><span class="hljs-string">"Update user data"</span></span>) public <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> updateUser(ctx: BaseContext): <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>&gt; { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"POST /api/v1/users"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> message = <span class="hljs-string"><span class="hljs-string">"Update user data error"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> code = <span class="hljs-number"><span class="hljs-number">400</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> data = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> serviceResult = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> updateUser(ctx.request.body.data); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (serviceResult) { code = <span class="hljs-number"><span class="hljs-number">200</span></span>; message = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (e) { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"Error while updating user"</span></span>); code = <span class="hljs-number"><span class="hljs-number">500</span></span>; } ctx.status = code; ctx.body = TransferObjectUtils.createResponseObject(code, message, data); };</code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">插入用户</b> <div class="spoiler_text"><pre> <code class="javascript hljs"> @put(<span class="hljs-string"><span class="hljs-string">"/"</span></span>) @parameter(<span class="hljs-string"><span class="hljs-string">"body"</span></span>, { <span class="hljs-attr"><span class="hljs-attr">$ref</span></span>: UsersRequestSchema }, ENUM_PARAM_IN.body) @response(<span class="hljs-number"><span class="hljs-number">200</span></span>, { <span class="hljs-attr"><span class="hljs-attr">$ref</span></span>: BaseAPIResponseSchema }) @response(<span class="hljs-number"><span class="hljs-number">400</span></span>, { <span class="hljs-attr"><span class="hljs-attr">$ref</span></span>: BaseAPIResponseSchema }) @response(<span class="hljs-number"><span class="hljs-number">500</span></span>, { <span class="hljs-attr"><span class="hljs-attr">$ref</span></span>: BaseAPIResponseSchema }) @tag(<span class="hljs-string"><span class="hljs-string">"User"</span></span>) @description(<span class="hljs-string"><span class="hljs-string">"Insert new user"</span></span>) @summary(<span class="hljs-string"><span class="hljs-string">"Insert new user"</span></span>) public <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> insertUser(ctx: BaseContext): <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>&gt; { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"PUT /api/v1/users"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> message = <span class="hljs-string"><span class="hljs-string">"Insert new user error"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> code = <span class="hljs-number"><span class="hljs-number">400</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> data = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> serviceResult = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> insertUser(ctx.request.body.data); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (serviceResult) { code = <span class="hljs-number"><span class="hljs-number">200</span></span>; message = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (e) { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"Error while inserting user"</span></span>); code = <span class="hljs-number"><span class="hljs-number">500</span></span>; } ctx.status = code; ctx.body = TransferObjectUtils.createResponseObject(code, message, data); };</code> </pre><br></div></div><br> 如您所见，这三个控制器方法包含重复的代码。 在这种情况下，我们现在利用这个机会。 <br><br> 首先，例如，直接在<b>routing.ts</b>文件中创建包装函数。 <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> controllerDecorator = <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> (controller: <span class="hljs-built_in"><span class="hljs-built_in">Function</span></span>, <span class="hljs-attr"><span class="hljs-attr">ctx</span></span>: BaseContext, <span class="hljs-attr"><span class="hljs-attr">next</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">Function</span></span>, <span class="hljs-attr"><span class="hljs-attr">summary</span></span>: string): <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>&gt; =&gt; { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">`</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${ctx.request.method}</span></span></span><span class="hljs-string"> </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${ctx.request.url}</span></span></span><span class="hljs-string">`</span></span>); ctx.body = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; ctx.status = <span class="hljs-number"><span class="hljs-number">400</span></span>; ctx.statusMessage = <span class="hljs-string"><span class="hljs-string">`Error while executing '</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${summary}</span></span></span><span class="hljs-string">'`</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> controller(ctx); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (e) { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(e, <span class="hljs-string"><span class="hljs-string">`Error while executing '</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${summary}</span></span></span><span class="hljs-string">'`</span></span>); ctx.status = <span class="hljs-number"><span class="hljs-number">500</span></span>; } ctx.body = TransferObjectUtils.createResponseObject(ctx.status, ctx.statusMessage, ctx.body); };</code> </pre><br> 然后将其连接到我们的控制器。 <br><br> 更换 <br><br><pre> <code class="javascript hljs">router.loadController(UserController);</code> </pre> <br> 在 <br><br><pre> <code class="javascript hljs">router.loadController(UserController, controllerDecorator);</code> </pre> <br> 好吧，让我们简化控制器方法 <br><br><div class="spoiler">  <b class="spoiler_title">用户控制器</b> <div class="spoiler_text"><pre> <code class="javascript hljs"> @get(<span class="hljs-string"><span class="hljs-string">"/"</span></span>) @response(<span class="hljs-number"><span class="hljs-number">200</span></span>, { <span class="hljs-attr"><span class="hljs-attr">$ref</span></span>: UsersResponseSchema }) @response(<span class="hljs-number"><span class="hljs-number">400</span></span>, { <span class="hljs-attr"><span class="hljs-attr">$ref</span></span>: BaseAPIResponseSchema }) @response(<span class="hljs-number"><span class="hljs-number">500</span></span>, { <span class="hljs-attr"><span class="hljs-attr">$ref</span></span>: BaseAPIResponseSchema }) @tag(<span class="hljs-string"><span class="hljs-string">"User"</span></span>) @description(<span class="hljs-string"><span class="hljs-string">"Returns list of all users"</span></span>) @summary(<span class="hljs-string"><span class="hljs-string">"Get all users"</span></span>) public <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> getAllUsers(ctx: BaseContext): <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>&gt; { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> serviceResult = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> getAllUsers(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (serviceResult) { ctx.body = serviceResult; ctx.status = <span class="hljs-number"><span class="hljs-number">200</span></span>; ctx.statusMessage = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; } }; @post(<span class="hljs-string"><span class="hljs-string">"/"</span></span>) @parameter(<span class="hljs-string"><span class="hljs-string">"body"</span></span>, { <span class="hljs-attr"><span class="hljs-attr">$ref</span></span>: UsersRequestSchema }, ENUM_PARAM_IN.body) @response(<span class="hljs-number"><span class="hljs-number">200</span></span>, { <span class="hljs-attr"><span class="hljs-attr">$ref</span></span>: BaseAPIResponseSchema }) @response(<span class="hljs-number"><span class="hljs-number">400</span></span>, { <span class="hljs-attr"><span class="hljs-attr">$ref</span></span>: BaseAPIResponseSchema }) @response(<span class="hljs-number"><span class="hljs-number">500</span></span>, { <span class="hljs-attr"><span class="hljs-attr">$ref</span></span>: BaseAPIResponseSchema }) @tag(<span class="hljs-string"><span class="hljs-string">"User"</span></span>) @description(<span class="hljs-string"><span class="hljs-string">"Update user data"</span></span>) @summary(<span class="hljs-string"><span class="hljs-string">"Update user data"</span></span>) public <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> updateUser(ctx: BaseContext): <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>&gt; { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> serviceResult = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> updateUser(ctx.request.body.data); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (serviceResult) { ctx.status = <span class="hljs-number"><span class="hljs-number">200</span></span>; ctx.statusMessage = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; } }; @put(<span class="hljs-string"><span class="hljs-string">"/"</span></span>) @parameter(<span class="hljs-string"><span class="hljs-string">"body"</span></span>, { <span class="hljs-attr"><span class="hljs-attr">$ref</span></span>: UsersRequestSchema }, ENUM_PARAM_IN.body) @response(<span class="hljs-number"><span class="hljs-number">200</span></span>, { <span class="hljs-attr"><span class="hljs-attr">$ref</span></span>: BaseAPIResponseSchema }) @response(<span class="hljs-number"><span class="hljs-number">400</span></span>, { <span class="hljs-attr"><span class="hljs-attr">$ref</span></span>: BaseAPIResponseSchema }) @response(<span class="hljs-number"><span class="hljs-number">500</span></span>, { <span class="hljs-attr"><span class="hljs-attr">$ref</span></span>: BaseAPIResponseSchema }) @tag(<span class="hljs-string"><span class="hljs-string">"User"</span></span>) @description(<span class="hljs-string"><span class="hljs-string">"Insert new user"</span></span>) @summary(<span class="hljs-string"><span class="hljs-string">"Insert new user"</span></span>) public <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> insertUser(ctx: BaseContext): <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>&gt; { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> serviceResult = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> insertUser(ctx.request.body.data); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (serviceResult) { ctx.status = <span class="hljs-number"><span class="hljs-number">200</span></span>; ctx.statusMessage = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; } };</code> </pre><br></div></div><br> 在此<b>controllerDecorator中，</b>您可以添加任何检查逻辑或输入/输出的详细日志。 <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">我把完成的代码贴在这里</a> 。 <br><br> 现在我们几乎已经准备好CRUD。 删除可以类推。 实际上，现在要编写一个新的控制器，我们必须： <br><br><ol><li> 创建控制器文件 </li><li> 将其添加到routing.ts </li><li> 描述方法 </li><li> 在每种方法中，使用输入/输出电路 </li><li> 描述这些方案 </li><li> 在routing.ts中连接这些方案 </li></ol><br> 如果传入的数据包与方案不匹配，则我们的REST服务的用户将收到400错误，并描述了确切的错误。 如果输出数据包无效，则将生成500错误。 <br><br> 好吧，仍然是一个愉快的琐事。 在Swagger UI中，您可以在任何方法上使用“ <b>试用</b> ”功能。 将通过curl向运行的服务生成一个请求，当然您可以立即看到结果。 为此，在电路中描述参数“ <b>示例</b> ”非常方便。 因为将根据描述的示例立即使用现成的软件包生成请求。 <br><br><img src="https://habrastorage.org/webt/gk/iq/hi/gkiqhirxja87xqofboi5oo9af1w.png"><br><br><h4>  <b>结论</b> </h4><br> 最终，结果非常方便且有用。 起初，他们不想验证传出数据包，但随后在此验证的帮助下，他们发现了几个重要的错误。 当然，您不能完全使用Joi的所有功能（因为我们受joi-swagger的限制），但这些功能已经足够。 <br><br> 现在，文档始终在线，并且始终严格对应于代码-这是主要内容。 <br> 还有什么其他想法？ <br><br> 是否可以添加快速支持？ <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">我刚读过</a> 。 <br><br> 一次描述实体真的很酷。 因为现在必须同时编辑电路和接口。 <br><br> 也许您会有一些有趣的想法。 更好的请求请求:) <br> 欢迎贡献者。 </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN449906/">https://habr.com/ru/post/zh-CN449906/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN449890/index.html">Yandex采访中的算法部分如何</a></li>
<li><a href="../zh-CN449896/index.html">如何放牧猫，或给年轻程序员的建议</a></li>
<li><a href="../zh-CN449898/index.html">由内而外的新闻</a></li>
<li><a href="../zh-CN449902/index.html">最小的有线电视网络。 第2部分：组成和波形</a></li>
<li><a href="../zh-CN449904/index.html">创建用于劫持dll操作检查的代理dll</a></li>
<li><a href="../zh-CN449910/index.html">GitLab Shell Runner。 使用Docker Compose竞争性地启动测试服务</a></li>
<li><a href="../zh-CN449916/index.html">高负载情况下部署PHP代码的5种方法</a></li>
<li><a href="../zh-CN449918/index.html">带有传感器的红外测温仪MLX90614</a></li>
<li><a href="../zh-CN449920/index.html">更改CMS时会损害SEO的10种非标准方式（+1奖励）</a></li>
<li><a href="../zh-CN449922/index.html">试驾nanoCAD SPDS Metalwork 1.2。 第三部分</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>