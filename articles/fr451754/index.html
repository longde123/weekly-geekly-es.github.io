<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üîµ üë©‚Äçüëß üëáüèΩ Comment trouver les expressions Lambda dans IntelliJ IDEA üçú üéÖüèø üöä</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="La recherche de code et la navigation sont des fonctionnalit√©s importantes de tout IDE. En Java, l'une des options de recherche couramment utilis√©es c...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Comment trouver les expressions Lambda dans IntelliJ IDEA</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/JetBrains/blog/451754/"><p><img alt="Hi√©rarchie des types dans IntelliJ IDEA" src="https://habrastorage.org/webt/ff/js/7m/ffjs7m9ycsved2ciyrqdvb4uiwe.png" align="right" width="300">  La recherche de code et la navigation sont des fonctionnalit√©s importantes de tout IDE.  En Java, l'une des options de recherche couramment utilis√©es consiste √† rechercher toutes les impl√©mentations d'une interface.  Cette fonctionnalit√© est souvent appel√©e Hi√©rarchie des types et ressemble √† l'image de droite. </p><br><p>  Il est inefficace d'it√©rer sur toutes les classes de projet lorsque cette fonctionnalit√© est invoqu√©e.  Une option consiste √† enregistrer la hi√©rarchie compl√®te des classes dans l'index pendant la compilation, car le compilateur la construit de toute fa√ßon.  Nous le faisons lorsque la compilation est ex√©cut√©e par l'EDI et non d√©l√©gu√©e, par exemple, √† Gradle.  Mais cela ne fonctionne que si rien n'a √©t√© chang√© dans le module apr√®s la compilation.  En g√©n√©ral, le code source est le fournisseur d'informations le plus √† jour et les index sont bas√©s sur le code source. </p><br><p> Trouver des enfants imm√©diats est une t√¢che simple si nous n'avons pas affaire √† une interface fonctionnelle.  Lors de la recherche d'impl√©mentations de l'interface <code>Foo</code> , nous devons trouver toutes les classes qui ont des <code>implements Foo</code> et des interfaces qui ont <code>extends Foo</code> , ainsi que de <code>new Foo(...) {...}</code> classes anonymes <code>new Foo(...) {...}</code> .  Pour ce faire, il suffit de construire √† l'avance une arborescence de syntaxe de chaque fichier de projet, de trouver les constructions correspondantes et de les ajouter √† un index. <a name="habracut"></a>  Il y a cependant une complexit√© ici: vous recherchez peut-√™tre l'interface <code>org.example.evilcompany.Foo</code> , tandis que <code>org.example.evilcompany.Foo</code> est en fait utilis√©.  Pouvons-nous mettre √† l'avance le nom complet de l'interface parent dans l'index?  Cela peut √™tre d√©licat.  Par exemple, le fichier dans lequel l'interface est utilis√©e peut ressembler √† ceci: </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// MyFoo.java import org.example.foo.*; import org.example.bar.*; import org.example.evilcompany.*; class MyFoo implements Foo {...}</span></span></code> </pre> <br><p>  En regardant le fichier seul, il est impossible de dire quel est le nom r√©el et complet de <code>Foo</code> .  Nous devrons examiner le contenu de plusieurs packages.  Et chaque package peut √™tre d√©fini √† plusieurs endroits du projet (par exemple, dans plusieurs fichiers JAR).  Si nous effectuons une r√©solution correcte des symboles lors de l'analyse de ce fichier, l'indexation prendra beaucoup de temps.  Mais le principal probl√®me est que l'index construit sur <code>MyFoo.java</code> d√©pendra √©galement d'autres fichiers.  Nous pouvons d√©placer la d√©claration de l'interface <code>Foo</code> , par exemple, du package <code>org.example.foo</code> vers le package <code>org.example.bar</code> , sans rien changer dans le fichier <code>MyFoo.java</code> , mais le nom complet de <code>Foo</code> changera. </p><br><p>  Dans IntelliJ IDEA, les index d√©pendent uniquement du contenu d'un seul fichier.  D'une part, c'est tr√®s pratique: l'index associ√© √† un fichier sp√©cifique devient invalide lorsque le fichier est modifi√©.  En revanche, il impose des restrictions importantes sur ce qui peut √™tre mis dans l'indice.  Par exemple, il n'autorise pas l'enregistrement fiable des noms complets des classes parentes dans l'index.  Mais, en g√©n√©ral, ce n'est pas si mal.  Lorsque vous demandez une hi√©rarchie de types, nous pouvons trouver tout ce qui correspond √† notre demande par un nom court, puis effectuer la r√©solution de symboles appropri√©e pour ces fichiers et d√©terminer si c'est ce que nous recherchons.  Dans la plupart des cas, il n'y aura pas trop de symboles redondants et la v√©rification ne prendra pas longtemps. </p><br><p><img alt="Hi√©rarchie des interfaces fonctionnelles dans IntelliJ IDEA" src="https://habrastorage.org/webt/e-/nn/0y/e-nn0ynvtojiydboaco5uiyzwms.png" align="right" width="300">  Les choses changent cependant lorsque la classe dont nous recherchons les enfants est une interface fonctionnelle.  Ensuite, en plus des sous-classes explicites et anonymes, il y aura des expressions lambda et des r√©f√©rences de m√©thode.  Que mettons-nous dans l'index maintenant et que doit-on √©valuer pendant la recherche? </p><br><p>  Supposons que nous ayons une interface fonctionnelle: </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@FunctionalInterface</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">StringConsumer</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">consume</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String s)</span></span></span></span>; }</code> </pre> <br><p>  Le code contient diff√©rentes expressions lambda.  Par exemple: </p><br><pre> <code class="java hljs">() -&gt; {} <span class="hljs-comment"><span class="hljs-comment">// a certain mismatch: no parameters (a, b) -&gt; a + b // a certain mismatch: two parameters s -&gt; { return list.add(s); // a certain mismatch: a value is returned } s -&gt; list.add(s); // a potential match</span></span></code> </pre> <br><p>  Cela signifie que nous pouvons rapidement filtrer les lambdas qui ont un nombre inappropri√© de param√®tres ou un type de retour clairement inappropri√©, par exemple, void au lieu de non-void.  Il est g√©n√©ralement impossible de d√©terminer plus pr√©cis√©ment le type de retour.  Par exemple, dans <code>s -&gt; list.add(s)</code> vous devrez r√©soudre <code>list</code> et <code>add</code> , et, √©ventuellement, ex√©cuter une proc√©dure d'inf√©rence de type r√©guli√®re.  Cela prend du temps et d√©pend du contenu des autres fichiers. </p><br><p>  Nous avons de la chance si l'interface fonctionnelle prend cinq arguments.  Mais s'il n'en prend qu'un, le filtre gardera un grand nombre de lambdas inutiles.  C'est encore pire quand il s'agit de r√©f√©rences de m√©thode.  √Ä premi√®re vue, on ne peut pas dire si une r√©f√©rence de m√©thode est appropri√©e ou non. </p><br><p>  Pour clarifier les choses, il pourrait √™tre utile de regarder ce qui entoure la lambda.  Parfois, √ßa marche.  Par exemple: </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// declaration of a local variable or a field of different type Predicate&lt;String&gt; p = s -&gt; list.add(s); // a different return type IntPredicate getPredicate() { return s -&gt; list.add(s); } // assignment to a variable of a different type SomeType fn; fn = s -&gt; list.add(s); // cast to a different type foo((SomeFunctionalType)(s -&gt; list.add(s))); // declaration of a different type array Foo[] myLambdas = {s -&gt; list.add(s), s -&gt; list.remove(s)};</span></span></code> </pre> <br><p>  Dans tous ces cas, le nom abr√©g√© de l'interface fonctionnelle correspondante peut √™tre d√©termin√© √† partir du fichier actuel et peut √™tre plac√© dans l'index √† c√¥t√© de l'expression fonctionnelle, qu'il s'agisse d'un lambda ou d'une r√©f√©rence de m√©thode.  Malheureusement, dans les projets r√©els, ces cas couvrent un tr√®s faible pourcentage de tous les lambdas.  Dans la plupart des cas, les lambdas sont utilis√©s comme arguments de m√©thode: </p><br><pre> <code class="java hljs">list.stream() .filter(s -&gt; StringUtil.isNonEmpty(s)) .map(s -&gt; s.trim()) .forEach(s -&gt; list.add(s));</code> </pre> <br><p>  Lequel des trois lambdas peut contenir <code>StringConsumer</code> ?  √âvidemment, aucun.  Ici, nous avons une cha√Æne d'API Stream qui ne comporte que des interfaces fonctionnelles de la biblioth√®que standard, elle ne peut pas avoir le type personnalis√©. </p><br><p>  Cependant, l'IDE devrait √™tre capable de voir √† travers l'astuce et de nous donner une r√©ponse exacte.  Que faire si la <code>list</code> n'est pas exactement <code>java.util.List</code> et que <code>list.stream()</code> renvoie quelque chose de diff√©rent de <code>java.util.stream.Stream</code> ?  Ensuite, nous devrons r√©soudre la <code>list</code> , qui, comme nous le savons, ne peut pas √™tre effectu√©e de mani√®re fiable uniquement en fonction du contenu du fichier actuel.  Et m√™me si nous le faisons, la recherche ne doit pas reposer sur l'impl√©mentation de la biblioth√®que standard.  Et si dans ce projet particulier, nous avons remplac√© <code>java.util.List</code> par une classe √† part?  La recherche doit en tenir compte.  Et, naturellement, les lambdas sont utilis√©s non seulement dans les flux standard: il existe de nombreuses autres m√©thodes auxquelles ils sont transmis. </p><br><p>  Par cons√©quent, nous pouvons interroger l'index pour obtenir une liste de tous les fichiers Java qui utilisent des lambdas avec le nombre de param√®tres requis et un type de retour valide (en fait, nous ne recherchons que quatre options: void, non-void, boolean et tout).  Et quelle est la prochaine?  Avons-nous besoin de construire une arborescence PSI compl√®te (une sorte d'arbre d'analyse avec r√©solution de symboles, inf√©rence de type et autres fonctionnalit√©s intelligentes) pour chacun de ces fichiers et d'effectuer une inf√©rence de type appropri√©e pour les lambdas?  Pour un gros projet, il faudra du temps pour obtenir la liste de toutes les impl√©mentations d'interfaces, m√™me s'il n'y en a que deux. </p><br><p>  Nous devons donc prendre les mesures suivantes: </p><br><ul><li>  Index des demandes (non co√ªteux) </li><li>  Construire PSI (co√ªteux) </li><li>  Inf√©rer le type lambda (tr√®s co√ªteux) </li></ul><br><p>  Pour Java 8 et versions ult√©rieures, l'inf√©rence de type est une op√©ration extr√™mement co√ªteuse.  Dans une cha√Æne d'appels complexe, il peut y avoir de nombreux param√®tres g√©n√©riques de substitution, dont les valeurs doivent √™tre d√©termin√©es √† l'aide de la proc√©dure de coup dur d√©crite au <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">chapitre 18</a> de la sp√©cification.  Pour le fichier actuel, cela peut √™tre fait en arri√®re-plan, mais le traitement de milliers de fichiers non ouverts de cette mani√®re serait une t√¢che co√ªteuse. </p><br><p>  Ici, cependant, il est possible de couper l√©g√®rement les coins: dans la plupart des cas, nous n'avons pas besoin du type de b√©ton.  √Ä moins qu'une m√©thode n'accepte un param√®tre g√©n√©rique o√π le lambda lui est transmis, l'√©tape de substitution de param√®tre finale peut √™tre √©vit√©e.  Si nous avons d√©duit le type lambda <code>java.util.function.Function&lt;T, R&gt;</code> , nous n'avons pas √† √©valuer les valeurs des param√®tres de substitution <code>T</code> et <code>R</code> : il est d√©j√† clair d'inclure le lambda dans les r√©sultats de recherche ou non.  Cependant, cela ne fonctionnera pas pour une m√©thode comme celle-ci: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> &lt;T&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">doSmth</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Class&lt;T&gt; aClass, T value)</span></span></span><span class="hljs-function"> </span></span>{}</code> </pre> <br><p>  Cette m√©thode peut √™tre appel√©e avec <code>doSmth(Runnable.class, () -&gt; {})</code> .  Le type lambda sera alors d√©duit comme <code>T</code> , la substitution √©tant toujours requise.  Cependant, c'est un cas rare.  Nous pouvons r√©ellement √©conomiser du temps CPU ici, mais seulement environ 10%, donc cela ne r√©sout pas le probl√®me dans son essence. </p><br><p>  Alternativement, lorsque l'inf√©rence de type pr√©cise est trop compliqu√©e, elle peut √™tre rendue approximative.  Contrairement √† ce que la sp√©cification sugg√®re, laissez-le fonctionner uniquement sur les types de classe effac√©s et ne r√©duisez pas l'ensemble des contraintes, mais suivez simplement une cha√Æne d'appel.  Tant que le type effac√© ne comprend pas de param√®tres g√©n√©riques, tout va bien.  Examinons le flux de l'exemple ci-dessus et d√©terminons si le dernier lambda impl√©mente <code>StringConsumer</code> : </p><br><ul><li>  variable de <code>list</code> -&gt; type <code>java.util.List</code> </li><li>  <code>List.stream()</code> ‚Üí type <code>java.util.stream.Stream</code> </li><li>  <code>Stream.filter(...)</code> -&gt; Type <code>java.util.stream.Stream</code> , nous n'avons pas √† consid√©rer les arguments de <code>filter</code> </li><li>  de m√™me, <code>Stream.map(...)</code> ‚Üí type <code>java.util.stream.Stream</code> </li><li>  <code>Stream.forEach(...)</code> ‚Üí une telle m√©thode existe, son param√®tre a le type <code>Consumer</code> , qui n'est √©videmment pas <code>StringConsumer</code> . </li></ul><br><p>  Et c'est ainsi que nous pourrions nous passer de l'inf√©rence de type r√©guli√®re.  Avec cette approche simple, cependant, il est facile d'ex√©cuter des m√©thodes surcharg√©es.  Si nous n'effectuons pas l'inf√©rence de type appropri√©e, nous ne pouvons pas choisir la bonne m√©thode surcharg√©e.  Parfois, c'est possible, cependant: si les m√©thodes ont un nombre diff√©rent de param√®tres.  Par exemple: </p><br><pre> <code class="java hljs">CompletableFuture.supplyAsync(Foo::bar, myExecutor).thenRunAsync(s -&gt; list.add(s));</code> </pre> <br><p>  Ici, nous pouvons voir que: </p><br><ul><li>  Il existe deux m√©thodes <code>CompletableFuture.supplyAsync</code> ;  le premier prend un argument et le second en prend deux, nous choisissons donc le second.  Il renvoie <code>CompletableFuture</code> . </li><li>  Il existe √©galement deux m√©thodes <code>thenRunAsync</code> , et nous pouvons √©galement choisir celle qui prend un argument.  Le param√®tre correspondant a le type <code>Runnable</code> , ce qui signifie qu'il n'est pas <code>StringConsumer</code> . </li></ul><br><p>  Si plusieurs m√©thodes prennent le m√™me nombre de param√®tres ou ont un nombre variable de param√®tres mais semblent appropri√©es, nous devrons rechercher dans toutes les options.  Souvent, ce n'est pas si effrayant: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StringBuilder().append(foo).append(bar).chars().forEach(s -&gt; list.add(s));</code> </pre> <br><ul><li>  <code>new StringBuilder()</code> cr√©e √©videmment <code>java.lang.StringBuilder</code> .  Pour les constructeurs, nous r√©solvons toujours la r√©f√©rence, mais l'inf√©rence de type complexe n'est pas requise ici.  M√™me s'il y avait de <code>new Foo&lt;&gt;(x, y, z)</code> , nous ne d√©duirions pas les valeurs des param√®tres de type car seul <code>Foo</code> nous int√©resse. </li><li>  Il existe de nombreuses m√©thodes <code>StringBuilder.append</code> qui prennent un argument, mais elles renvoient toutes le type <code>java.lang.StringBuilder</code> , donc nous ne nous soucions pas des types de <code>foo</code> et <code>bar</code> . </li><li>  Il existe une m√©thode <code>StringBuilder.chars</code> et elle renvoie <code>java.util.stream.IntStream</code> . </li><li>  Il existe une seule m√©thode <code>IntStream.forEach</code> et elle prend le type <code>IntConsumer</code> . </li></ul><br><p>  M√™me s'il reste plusieurs options, vous pouvez toujours toutes les suivre.  Par exemple, le type lambda transmis √† <code>ForkJoinPool.getInstance().submit(...)</code> peut √™tre <code>Runnable</code> ou <code>Callable</code> , et si nous recherchons une autre option, nous pouvons toujours ignorer ce lambda. </p><br><p>  Les choses empirent lorsque la m√©thode retourne un param√®tre g√©n√©rique.  Ensuite, la proc√©dure √©choue et vous devez effectuer l'inf√©rence de type appropri√©e.  Cependant, nous avons soutenu un cas.  Il est bien pr√©sent√© dans ma biblioth√®que StreamEx, qui a une classe abstraite <code>AbstractStreamEx&lt;T, S extends AbstractStreamEx&lt;T, S&gt;&gt;</code> qui contient des m√©thodes comme le <code>S filter(Predicate&lt;? super T&gt; predicate)</code> .  Habituellement, les gens travaillent avec une <code>StreamEx&lt;T&gt; extends AbstractStreamEx&lt;T, StreamEx&lt;T&gt;&gt;</code> concr√®te <code>StreamEx&lt;T&gt; extends AbstractStreamEx&lt;T, StreamEx&lt;T&gt;&gt;</code> .  Dans ce cas, vous pouvez remplacer le param√®tre type et d√©couvrir que <code>S = StreamEx</code> . </p><br><p>  C'est ainsi que nous nous sommes d√©barrass√©s de l'inf√©rence de type co√ªteuse dans de nombreux cas.  Mais nous n'avons rien fait avec la construction de PSI.  Il est d√©cevant d'avoir analys√© un fichier avec 500 lignes de code pour d√©couvrir que le lambda sur la ligne 480 ne correspond pas √† notre requ√™te.  Revenons √† notre flux: </p><br><pre> <code class="java hljs">list.stream() .filter(s -&gt; StringUtil.isNonEmpty(s)) .map(s -&gt; s.trim()) .forEach(s -&gt; list.add(s));</code> </pre> <br><p>  Si <code>list</code> est une variable locale, un param√®tre de m√©thode ou un champ de la classe actuelle, d√©j√† au stade de l'indexation, nous pouvons trouver sa d√©claration et √©tablir que le nom de type court est <code>List</code> .  En cons√©quence, nous pouvons mettre les informations suivantes dans l'indice de la derni√®re lambda: </p><br><blockquote>  Ce type lambda est un type de param√®tre d'une m√©thode <code>forEach</code> qui prend un argument, appel√© sur le r√©sultat d'une m√©thode <code>map</code> qui prend un argument, appel√© sur le r√©sultat d'une m√©thode de <code>filter</code> qui prend un argument, appel√© sur le r√©sultat d'une m√©thode <code>stream</code> qui ne prend aucun argument, appel√© sur un objet <code>List</code> . </blockquote><p>  Toutes ces informations sont disponibles dans le fichier actuel et peuvent donc √™tre plac√©es dans l'index.  Pendant la recherche, nous demandons ces informations sur tous les lambdas de l'index et essayons de restaurer le type lambda sans construire de PSI.  Tout d'abord, nous devrons effectuer une recherche globale des classes avec le nom de <code>List</code> court.  √âvidemment, nous trouverons non seulement <code>java.util.List</code> mais aussi <code>java.awt.List</code> ou quelque chose du code du projet.  Ensuite, toutes ces classes passeront par la m√™me proc√©dure d'inf√©rence de type approximative que nous avons utilis√©e auparavant.  Les classes redondantes sont souvent rapidement √©limin√©es.  Par exemple, <code>java.awt.List</code> n'a pas de m√©thode de <code>stream</code> , il sera donc exclu.  Mais m√™me s'il reste quelque chose de redondant et que nous trouvons plusieurs candidats pour le type lambda, il est probable qu'aucun d'entre eux ne correspondra √† la requ√™te de recherche, et nous √©viterons toujours de cr√©er un PSI complet. </p><br><p>  La recherche globale peut s'av√©rer trop co√ªteuse (lorsqu'un projet contient trop de classes <code>List</code> ), ou le d√©but de la cha√Æne ne peut pas √™tre r√©solu dans le contexte d'un fichier (disons, c'est un champ d'une classe parent), ou la cha√Æne peut se rompre lorsque la m√©thode renvoie un param√®tre g√©n√©rique.  Nous n'abandonnerons pas et essaierons de recommencer avec une recherche globale sur la prochaine m√©thode de la cha√Æne.  Par exemple, pour la <code>map.get(key).updateAndGet(a -&gt; a * 2)</code> , l'instruction suivante va √† l'index: </p><br><blockquote>  Ce type lambda est le type du param√®tre unique d'une m√©thode <code>updateAndGet</code> , appel√© sur le r√©sultat d'une m√©thode <code>get</code> avec un param√®tre, appel√© sur un objet <code>Map</code> . </blockquote><p>  Imaginez que nous avons de la chance, et le projet n'a qu'un seul type de <code>Map</code> <code>java.util.Map</code> .  Il a une m√©thode <code>get(Object)</code> , mais, malheureusement, il renvoie un param√®tre g√©n√©rique <code>V</code>  Ensuite, nous √©liminerons la cha√Æne et rechercherons la m√©thode <code>updateAndGet</code> avec un param√®tre globalement (en utilisant l'index, bien s√ªr).  Et nous sommes heureux de d√©couvrir qu'il n'y a que trois m√©thodes de ce type dans le projet: dans les <code>AtomicInteger</code> , <code>AtomicLong</code> et <code>AtomicReference</code> avec les types de param√®tres <code>IntUnaryOperator</code> , <code>LongUnaryOperator</code> et <code>UnaryOperator</code> , respectivement.  Si nous recherchons un autre type, nous avons d√©j√† d√©couvert que ce lambda ne correspond pas √† la demande, et nous n'avons pas √† construire le PSI. </p><br><p>  √âtonnamment, c'est un bon exemple d'une fonctionnalit√© qui fonctionne plus lentement avec le temps.  Par exemple, lorsque vous recherchez des impl√©mentations d'une interface fonctionnelle et que vous n'en avez que trois dans votre projet, il faut dix secondes √† IntelliJ IDEA pour les trouver.  Vous vous souvenez qu'il y a trois ans, leur nombre √©tait le m√™me, mais l'IDE vous a fourni les r√©sultats de la recherche en seulement deux secondes sur la m√™me machine.  Et bien que votre projet soit √©norme, il n'a augment√© que de 5% au cours de ces ann√©es.  Il est raisonnable de commencer √† se plaindre de ce que les d√©veloppeurs IDE ont fait de mal pour le rendre si terriblement lent. </p><br><p>  Bien que nous n'ayons rien chang√© du tout.  La recherche fonctionne comme il y a trois ans.  Le fait est qu'il y a trois ans, vous venez de passer √† Java 8 et n'aviez qu'une centaine de lambdas dans votre projet.  √Ä ce jour, vos coll√®gues ont transform√© des classes anonymes en lambdas, ont commenc√© √† utiliser des flux ou une biblioth√®que r√©active.  En cons√©quence, au lieu d'une centaine de lambdas, il y en a dix mille.  Et maintenant, pour trouver les trois n√©cessaires, l'IDE doit rechercher parmi cent fois plus d'options. </p><br><p>  J'ai dit ¬´nous pourrions¬ª parce que, naturellement, nous revenons √† cette recherche de temps en temps et essayons de l'acc√©l√©rer.  Mais c'est comme ramer sur le ruisseau, ou plut√¥t sur la cascade.  Nous essayons dur, mais le nombre de lambdas dans les projets continue de cro√Ætre tr√®s rapidement. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr451754/">https://habr.com/ru/post/fr451754/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr451742/index.html">Un jour avant DotNext 2019 Piter. Annonce de diffusion gratuite</a></li>
<li><a href="../fr451746/index.html">MegaSlerm pour les ing√©nieurs et architectes Kubernetes</a></li>
<li><a href="../fr451748/index.html">Surveillance de l'√©tat du SSD dans les baies Qsan</a></li>
<li><a href="../fr451750/index.html">Livre "Elasticsearch, Kibana, Logstash et Next Generation Search Engine"</a></li>
<li><a href="../fr451752/index.html">30e anniversaire de l'ins√©curit√© galopante</a></li>
<li><a href="../fr451758/index.html">Liaisons montantes suppl√©mentaires dans l'architecture logique du syst√®me Intel C620</a></li>
<li><a href="../fr451760/index.html">Utilisation de Golang pour cr√©er des microservices dans The Economist: A Retrospective</a></li>
<li><a href="../fr451766/index.html">Heisenbug 2019 Piter: ce qui se passera dans la diffusion gratuite, et ce uniquement lors de l'√©v√©nement</a></li>
<li><a href="../fr451768/index.html">Am√©liorer le travail du Wi-Fi. Principes g√©n√©raux et choses utiles</a></li>
<li><a href="../fr451770/index.html">Veeam Backup & Replication: conseils utiles pour rendre les sauvegardes et les r√©pliques viables</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>