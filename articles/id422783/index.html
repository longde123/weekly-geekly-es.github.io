<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>💒 👩‍❤️‍👩 🤶🏽 Lebih baik, lebih cepat, lebih kuat: komponen v4 gaya 🤚🏻 📴 🎅🏿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Penulis materi, terjemahan yang kami terbitkan hari ini, ingin menyajikan versi beta dari perpustakaan komponen-v4 gaya ke komunitas pengembang web. D...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Lebih baik, lebih cepat, lebih kuat: komponen v4 gaya</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/422783/"> Penulis materi, terjemahan yang kami terbitkan hari ini, ingin menyajikan versi beta dari perpustakaan komponen-v4 gaya ke komunitas pengembang web.  Dia, berbicara atas nama pembuat perpustakaan, mengatakan bahwa komponen yang ditata sekarang memiliki API global baru untuk bekerja dengan gaya dan dukungan asli untuk properti <code>as</code> dan <code>ref</code> .  Perpustakaan mengikuti jalur penolakan <code>.extend</code> , itu kompatibel dengan StrictMode React v16 dan telah menjadi lebih baik, lebih cepat dan lebih kuat. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><img src="https://habrastorage.org/webt/tx/xf/6u/txxf6u1rz9jrcize_-uuv7iykni.jpeg"></a> <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">Fitur komponen bergaya v4</font> </h2><br>  Untuk menginstal versi komponen-gaya terbaru, gunakan perintah ini: <br><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">npm</span></span> install styled-components<span class="hljs-variable"><span class="hljs-variable">@beta</span></span></code> </pre> <br>  Anda dapat membiasakan diri dengan kemampuan perpustakaan, memeriksanya, dan jika ternyata ada sesuatu yang perlu ditingkatkan, biarkan pengembang mengetahuinya.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Di sini</a> Anda dapat menemukan instruksi untuk memutakhirkan ke versi baru perpustakaan.  <a href="">Berikut adalah</a> changelog untuk komponen gaya v4.0.0-beta.0. <br><br>  Pertimbangkan fitur utama dari rilis komponen-gaya ini: <br><br><ul><li>  Mengurangi ukuran dan meningkatkan kecepatan.  Ukuran pustaka telah dikurangi dari 16.1 KB menjadi kurang dari 15 KB (ukuran akhir tergantung pada bundler Anda dan pada penggunaan plugin babel).  Kecepatan pemasangan meningkat sekitar 25%, kecepatan rendering ulang - sekitar 7,5%. </li><li>  API <code>createGlobalStyle</code> baru, yang merupakan pengganti untuk <code>injectGlobal</code> API lama dengan dukungan untuk pemuatan ulang panas dan tema. </li><li>  Dukungan untuk properti <code>as</code> , alternatif yang lebih fleksibel untuk <code>.withComponent()</code> . <br></li><li>  Menyingkirkan <code>Comp.extend</code> dengan dukungan untuk terjemahan otomatis basis kode ke dalam format terpadu <code>styled(Comp)</code> . </li><li>  Kompatibilitas penuh dengan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">StrictMode</a> React v16.  Ini, di samping itu, berarti bahwa pengembang harus meninggalkan dukungan untuk React v15 dan lainnya, versi React yang lebih lama (walaupun polyfill mungkin dapat digunakan untuk mengatur pekerjaan dengan komponen gaya v4 dalam React v15). </li><li>  Dukungan asli untuk <code>ref</code> untuk setiap komponen bergaya, dan berkat React v16, tidak perlu menggunakan <code>innerRef</code> . </li></ul><br>  Pustaka komponen-gaya dilepaskan dalam versi beta sehingga mereka yang menggunakannya memiliki cukup waktu untuk menekankan pengujian perubahan, dan sehingga dimungkinkan untuk menyiapkan mekanisme bantu seperti deskripsi jenis dan alat penyorot sintaksis untuk yang baru. API  Perpustakaan diharapkan tetap dalam status beta selama sekitar satu bulan. <br><br><h2>  <font color="#3AC1EF">Performa</font> </h2><br>  Ketika versi kedua dari komponen yang ditata dirilis, kami berjanji, setelah menyelesaikan API inti, untuk fokus pada kinerja.  Sejak itu, berkat tambalan, kami telah meningkatkan kinerja perpustakaan, yang, khususnya, telah menyebabkan peningkatan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">10 kali lipat</a> dalam kinerja di v3.1. <br><br>  Bekerja pada kinerja komponen ditata terus.  Berkat optimalisasi internal yang terkait dengan bekerja dengan memori, karena kekhasan menerapkan mesin JS dan kode refactoring, kecepatan pemasangan komponen v4 gaya untuk pohon komponen dalam dan lebar meningkat sekitar 25%.  Pembaruan gaya dinamis sekitar 7% lebih cepat.  Berikut ini adalah perbandingan kinerja komponen-ditata v3 dan v4, berdasarkan hasil tiga tes.  Dua yang pertama terkait dengan studi pemasangan komponen pohon, yang ketiga menyangkut memperbarui komponen dengan gaya dinamis. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/497/2a7/0ff/4972a70fff6d1beb1a1f5d1bd8970bd4.png"><br>  <i>Perbandingan komponen gaya v3 dan v4</i> <br><br>  Hasil ini, diperoleh dalam lingkungan yang terisolasi, terlihat mengesankan.  Namun, akan sangat menarik untuk membandingkan komponen-komponen yang ditata gaya v4 dengan perpustakaan ekosistem CSS-in-JS lainnya, khususnya, dalam hal kecepatan pemasangan. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/7df/0d7/5a3/7df0d75a3536f9f1588ab9f1da059604.png"><br>  <i>Styled-components v4 dan perbandingan kinerja perpustakaan lainnya</i> <br><br>  Seperti yang Anda lihat, kinerja komponen yang ditata terlihat sangat mengesankan.  Secara khusus, dibandingkan dengan pustaka tercepat, hasil komponen yang ditata dalam standar deviasi dari hasil mereka dalam hal kecepatan pemasangan dan pembaruan.  Semua ini memungkinkan kami untuk secara resmi menyatakan bahwa kinerja tidak lagi menjadi masalah perpustakaan ini. <br><br>  Meskipun kinerja komponen-gaya adalah hasil dari pengembangan perpustakaan dan waktu dan upaya yang cukup untuk memperbaikinya, ini tidak berarti bahwa kita tidak akan lagi terlibat dalam peningkatan kinerja.  Jika kami menemukan peluang untuk membuat perpustakaan lebih cepat, kami akan menggunakan kesempatan ini. <br><br><h2>  <font color="#3AC1EF">API penataan gaya global baru</font> </h2><br>  Kami telah mengembangkan API penataan gaya global baru untuk beberapa waktu.  API lama, <code>injectGlobal</code> , memiliki tiga kelemahan serius: tidak mendukung pembaruan dinamis, pemuatan ulang panas, dan penggunaan tema secara kontekstual. <br><br>  Sekarang kami dengan senang hati memperkenalkan Anda kepada <code>createGlobalStyle</code> , API gaya global baru yang mendukung pembaruan dinamis.  Seperti apa bentuknya bekerja dengannya: <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { createGlobalStyle } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"styled-components"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> GlobalStyle = createGlobalStyle<span class="hljs-string"><span class="hljs-string">` html {   color: red; } `</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">App</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (   <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">     </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">GlobalStyle</span></span></span></span><span class="xml"><span class="hljs-tag"> /&gt;</span></span></span><span class="xml">     This is my app!   </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span> ); }</code> </pre> <br>  Menggunakan <code>createGlobalStyle</code> gaya global sekarang menjadi bagian dari pohon komponen React.  Meskipun, pada pandangan pertama, tidak ada yang istimewa tentang ini, memungkinkan untuk memperbarui dan me-panas gaya pemuatan secara dinamis, dan juga memungkinkan Anda menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tema kontekstual</a> untuk gaya global.  Semuanya terlihat persis sama seperti ketika bekerja dengan komponen bergaya lainnya. <br><br><pre> <code class="hljs powershell">import { createGlobalStyle, ThemeProvider } from <span class="hljs-string"><span class="hljs-string">"styled-components"</span></span>; //  ,       const GlobalStyle = createGlobalStyle` html {   background: <span class="hljs-variable"><span class="hljs-variable">$</span></span>{p =&gt; p.backgroundColor}   color: red;   font<span class="hljs-literal"><span class="hljs-literal">-family</span></span>: <span class="hljs-variable"><span class="hljs-variable">$</span></span>{p =&gt; p.theme.fontFamily}; } `; export default <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">App</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (   &lt;ThemeProvider theme={{ fontFamily: <span class="hljs-string"><span class="hljs-string">"Helvetica Neue"</span></span> }}&gt;     &lt;GlobalStyle backgroundColor=<span class="hljs-string"><span class="hljs-string">"turquoise"</span></span> /&gt;   &lt;/ThemeProvider&gt; ); }</code> </pre> <br><h2>  <font color="#3AC1EF">Penolakan komponen .extend dan "lipat"</font> </h2><br>  Pelepasan komponen yang ditata ini memiliki mekanisme internal, berkat komponen yang telah diubahsuaikan dalam bungkusnya sekarang secara otomatis "diciutkan", yang memungkinkan rendering hanya satu komponen. <br><br>  Apa artinya ini bagi pengguna perpustakaan?  Faktanya adalah bahwa <code>StyledComp.extend</code> API muncul di perpustakaan untuk memungkinkan beberapa optimasi berdasarkan pada fakta bahwa komponen yang dapat diperluas adalah komponen yang bergaya.  Berkat kerja internal pada "lipat" komponen secara otomatis, saat menggunakan <code>styled(StyledComp)</code> optimasi yang sama yang diterapkan berkat <code>StyledComp.extend</code> secara otomatis diterapkan.  Ini berarti <code>.extend</code> sekarang tidak terlalu berguna, yang diizinkan untuk meninggalkan API ini.  Akibatnya, sekarang pengguna perpustakaan dapat menulis lebih sedikit kode dan mendapatkan kesempatan untuk tidak membuang waktu mengembangkan satu API tambahan.  Kami percaya ini sangat bagus. <br><br><h2>  <font color="#3AC1EF">Properti polimorfik sebagai</font> </h2><br>  Ada lagi fitur baru yang ditata-komponen v4, yang kami sangat antusias.  Kita berbicara tentang dukungan asli untuk properti <code>as</code> untuk setiap komponen bergaya, yang memungkinkan kita untuk secara dinamis mempengaruhi rendering selama eksekusi program.  Pertimbangkan sebuah contoh: <br><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> styled <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> "styled-components" <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { Link } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> "react-router-dom" // &lt;Component /&gt;   DOM  div const Component = styled.div` color: red; ` &lt;Component&gt;Hello World!&lt;/Component&gt; //     ,      HTML-  ! &lt;Component <span class="hljs-keyword"><span class="hljs-keyword">as</span></span>="span"&gt;Hello World!&lt;/Component&gt; &lt;Component <span class="hljs-keyword"><span class="hljs-keyword">as</span></span>={Link} <span class="hljs-keyword"><span class="hljs-keyword">to</span></span>="home"&gt;Hello World!&lt;/Component&gt;</code> </pre> <br>  Jika Anda membandingkan ini dengan mekanisme <code>.withComponent(something)</code> yang ada, alat baru lebih fleksibel, karena Anda tidak perlu menjelaskan penggantian di muka, dan, berkat mekanisme "lipat" internal yang baru, stilisasi tidak hilang jika komponen dasar ditata- komponen! <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> styled <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"styled-components"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> RedColor = styled.div<span class="hljs-string"><span class="hljs-string">` color: red; `</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> BlueBackgroundRedColor = styled(RedColor)<span class="hljs-string"><span class="hljs-string">` background: blue; `</span></span> &lt;BlueBackgroundRedColor <span class="hljs-keyword"><span class="hljs-keyword">as</span></span>=<span class="hljs-string"><span class="hljs-string">"span"</span></span>&gt;Hello!<span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">BlueBackgroundRedColor</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span> <span class="hljs-comment"><span class="hljs-comment">//       `span`   // &lt;RedColor /&gt;,       // !! (.withComponent    )</span></span></code> </pre> <br>  Seperti yang Anda lihat, properti <code>as</code> hanyalah hal yang luar biasa, yang sangat menyederhanakan rendering kode HTML semantik di mana saja dalam aplikasi.  "Sup" dari tag <code>&lt;div&gt;</code> tidak memiliki alasan lain untuk membenarkan. <br><br>  Harap dicatat bahwa sampai kami memastikan bahwa properti tersebut dapat menjadi pengganti yang cocok untuk <code>.withComponent</code> dalam semua kasus penggunaan, kami tidak akan menolaknya.  Diasumsikan bahwa periode transisi ini tidak akan bertahan terlalu lama, dan kami, dalam rilis utama berikutnya, akan menghapus <code>.withComponent</code> . <br><br><h2>  <font color="#3AC1EF">Bereaksi v16 dan ref</font> </h2><br>  Dalam proses beralih ke React v16 API, kami menemukan, antara lain, bahwa berkat <code>React.forwardRef</code> API baru, kami dapat menyingkirkan <code>innerRef</code> .  Kami tidak pernah menyukai teknik ini, karena sepertinya ini semacam peretasan yang tidak terlalu bersih.  Namun berkat kerja yang luar biasa dari tim React, Anda sekarang dapat menggunakan <code>ref</code> asli: <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> styled <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"styled-components"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Component = styled.div<span class="hljs-string"><span class="hljs-string">` color: red; `</span></span> <span class="hljs-comment"><span class="hljs-comment">//    render &lt;Component ref={element =&gt; { this.myRef = element; }}</span></span></code> </pre> <br><h2>  <font color="#3AC1EF">Perbaikan untuk Penulis TypeScript</font> </h2><br>  Kami tidak melakukan ini secara langsung, tetapi kami sangat menyukai <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">naskah @ babel / preset yang baru</a> .  Keberadaannya berarti bahwa sekarang semua orang yang menulis pada TypeScript akhirnya akan dapat menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">plugin</a> babel untuk komponen-gaya dengan semua kegunaannya, termasuk debugging yang disederhanakan menggunakan nama-nama komponen di kelas, dukungan untuk rendering server, dan mengurangi ukuran bundel. <br><br>  Selain itu, kami telah menyelesaikan terjemahan tipe TS ke dalam DefinitelyTyped.  Komunitas sekarang dapat bekerja dengan mereka dan memperbaiki kesalahan pengetikan dengan langkah mereka sendiri, tanpa terikat dengan rilis komponen-gaya.  Ketik deklarasi dapat ditemukan di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> . <br><br><h2>  <font color="#3AC1EF">Ringkasan</font> </h2><br>  Dari materi ini, Anda belajar tentang fitur beta baru dari komponen-gaya v4 dan perbaikan yang dilakukan untuk itu.  Kami berharap semua ini akan bermanfaat bagi mereka yang menggunakan komponen bergaya, dan mungkin akan menarik bagi mereka yang hanya akan mencoba perpustakaan ini. <br><br>  <b>Pembaca yang budiman!</b>  Apakah Anda menggunakan pustaka komponen-gaya dalam proyek Anda? <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id422783/">https://habr.com/ru/post/id422783/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id422771/index.html">Aturan desain, mencapai level baru dan pemikiran desain</a></li>
<li><a href="../id422773/index.html">NVIDIA. Mengungkap Rahasia Arsitektur GPU Turing Generasi Selanjutnya: Penelusuran Ray Ganda, GDDR6, dan Banyak Lagi</a></li>
<li><a href="../id422775/index.html">Konferensi DEFCON 22. Andrew "Zoz" Brooks. Jangan mengacaukannya! Bagian 1</a></li>
<li><a href="../id422777/index.html">Pengantar sederhana untuk ALU untuk jaringan saraf: penjelasan, makna fisik dan implementasi</a></li>
<li><a href="../id422781/index.html">Intisari Fintech: SWIFT akan terus bekerja di Federasi Rusia, VISA akan memungkinkan Anda mentransfer dana dengan nomor telepon, biometrik mahal</a></li>
<li><a href="../id422785/index.html">Digitalisasi Pabrik: Pandangan di Depan</a></li>
<li><a href="../id422787/index.html">Perubahan besar dalam arsitektur chip terkemuka</a></li>
<li><a href="../id422789/index.html">@Pythonetc Agustus 2018</a></li>
<li><a href="../id422791/index.html">Bagaimana TIDAK untuk Belajar Bahasa Inggris: Kesalahan Umum</a></li>
<li><a href="../id422793/index.html">Konferensi DEFCON 22. Andrew "Zoz" Brooks. Jangan mengacaukannya! Bagian 2</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>