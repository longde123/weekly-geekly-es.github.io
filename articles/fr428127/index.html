<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>💇🏽 😑 🔽 Cache Nginx: tout nouveau - vieux bien oublié 👨🏾‍🔬 🆒 👮</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dans la vie de chaque projet, le moment vient où le serveur cesse de répondre aux exigences SLA et commence littéralement à s'étouffer sur la quantité...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Cache Nginx: tout nouveau - vieux bien oublié</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/428127/">  Dans la vie de chaque projet, le moment vient où le serveur cesse de répondre aux exigences SLA et commence littéralement à s'étouffer sur la quantité de trafic entrant.  Après cela, le long processus de recherche de goulots d'étranglement, de requêtes lourdes, d'index mal créés, de données non mises en cache ou vice versa, de données trop souvent mises à jour dans le cache et d'autres côtés sombres du projet, commence. <br><br>  Mais que faire lorsque votre code est «parfait», toutes les demandes lourdes sont placées en arrière-plan, tout ce qui était possible a été mis en cache et le serveur n'atteint toujours pas les indicateurs SLA dont nous avons besoin?  Si possible, vous pouvez bien sûr acheter de nouvelles voitures, répartir une partie du trafic et oublier le problème pendant un certain temps. <br><br>  Mais si vous avez le sentiment que votre serveur est capable de plus, ou s'il existe un paramètre magique qui accélère le site de 100 fois, vous pouvez rappeler la fonction nginx intégrée qui vous permet de mettre en cache les réponses du backend.  Voyons ce que c'est et comment cela peut aider à augmenter le nombre de demandes traitées par le serveur. <a name="habracut"></a><br><br><h3>  Qu'est-ce que le cache Nginx et comment fonctionne-t-il? </h3><br>  Le cache Nginx peut réduire considérablement le nombre de demandes pour le backend.  Ceci est réalisé en enregistrant la réponse HTTP pendant un certain temps et en accédant à nouveau à la ressource, en la renvoyant du cache sans mandataire de la demande pour le backend.  La mise en cache, même pour une courte période, augmentera considérablement le nombre de requêtes traitées par le serveur. <br><br>  Avant de procéder à la configuration de nginx, vous devez vous assurer qu'il est construit avec le module «ngx_http_proxy_module», car nous allons le configurer à l'aide de ce module. <br><br>  Pour plus de commodité, vous pouvez placer la configuration dans un fichier séparé, par exemple, «/etc/nginx/conf.d/cache.conf».  Examinons la directive proxy_cache_path, qui vous permet de configurer les paramètres de stockage du cache. <br><br><pre><code class="hljs swift">proxy_cache_path /<span class="hljs-keyword"><span class="hljs-keyword">var</span></span>/lib/nginx/proxy_cache levels=<span class="hljs-number"><span class="hljs-number">1</span></span>:<span class="hljs-number"><span class="hljs-number">2</span></span> keys_zone=proxy_cache:15m max_size=1G;</code> </pre> <br>  «/ Var / lib / nginx / proxy_cache» spécifie le chemin de stockage du cache sur le serveur.  C'est dans ce répertoire que nginx enregistrera les fichiers mêmes avec la réponse du backend.  En même temps, nginx ne créera pas indépendamment un répertoire pour le cache, vous devez vous en occuper vous-même. <br><br>  "Niveaux = 1: 2" - définit le niveau d'imbrication des répertoires avec un cache.  Les niveaux d'imbrication sont indiqués par «:», dans ce cas 2 répertoires seront créés, au total 3 niveaux d'imbrication sont autorisés.  Pour chaque niveau d'imbrication, des valeurs de 1 à 2 sont disponibles, indiquant comment créer le nom du répertoire. <br><br>  Le point important est que le nom du répertoire n'est pas choisi au hasard, mais est créé en fonction du nom du fichier.  Le nom du fichier, à son tour, est le résultat de la fonction md5 de la clé de cache; nous examinerons la clé de cache un peu plus tard. <br><br>  Voyons en pratique comment le chemin d'accès au fichier cache est construit: <br><br><pre> <code class="hljs swift">/<span class="hljs-keyword"><span class="hljs-keyword">var</span></span>/lib/nginx/proxy_cache/<span class="hljs-number"><span class="hljs-number">2</span></span>/<span class="hljs-number"><span class="hljs-number">49</span></span>/07edcfe6974569ab4da6634ad4e5d492</code> </pre> <br>  Le paramètre "Keys_zone = proxy_cache: 15m" définit le nom de la zone dans la mémoire partagée, où toutes les clés actives et les informations les concernant sont stockées.  Grâce à «:» indique la taille de la mémoire allouée en Mo.  Selon nginx, 1 Mo suffit pour stocker 8 000 clés. <br><br>  "Max_size = 1G" définit la taille maximale du cache pour toutes les pages au-dessus desquelles nginx se chargera de supprimer les données moins nécessaires. <br><br>  Il est également possible de contrôler la durée de vie des données dans le cache, pour cela il suffit de définir le paramètre «inactif» de la directive «proxy_cache_path» qui est de 10 minutes par défaut.  Si pendant le temps spécifié dans le paramètre «inactif» il n'y a pas eu d'appel aux données de cache, alors ces données sont supprimées même si le cache n'est pas encore «aigre». <br><br>  À quoi ressemble ce cache?  Il s'agit en fait d'un fichier normal sur le serveur, dont le contenu est écrit: <br><br>  • clé de cache; <br>  • en-têtes de cache; <br>  • réponse du contenu du backend. <br><br>  Si tout est clair avec les en-têtes et la réponse du backend, alors il y a un certain nombre de questions sur la «clé de cache».  Comment est-il construit et comment peut-il être géré? <br><br>  Pour décrire le modèle de construction d'une clé de cache dans nginx, il existe une directive proxy_cache_key, dans laquelle une chaîne est spécifiée comme paramètre.  Une chaîne peut être constituée de toutes les variables disponibles dans nginx. <br><br>  Par exemple: <br><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">proxy_cache_key</span></span> <span class="hljs-variable"><span class="hljs-variable">$request_method</span></span><span class="hljs-variable"><span class="hljs-variable">$host</span></span><span class="hljs-variable"><span class="hljs-variable">$orig_uri</span></span>:<span class="hljs-variable"><span class="hljs-variable">$cookie_some_cookie</span></span>:<span class="hljs-variable"><span class="hljs-variable">$arg_some_arg</span></span>;</code> </pre> <br>  Le symbole «:» entre le paramètre cookie et le paramètre get est utilisé pour éviter les collisions entre les clés de cache, vous pouvez choisir n'importe quel autre symbole de votre choix.  Par défaut, nginx utilise la ligne suivante pour générer la clé: <br><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">proxy_cache_key</span></span> <span class="hljs-variable"><span class="hljs-variable">$scheme</span></span><span class="hljs-variable"><span class="hljs-variable">$proxy_host</span></span><span class="hljs-variable"><span class="hljs-variable">$request_uri</span></span>;</code> </pre> <br>  Il convient de noter les directives suivantes qui vous aideront à gérer votre mise en cache de manière plus flexible: <br><br>  <i>proxy_cache_valid</i> - Spécifie le temps de mise en cache des réponses.  Il est possible d'indiquer le statut spécifique de la réponse, par exemple 200, 302, 404, etc., ou de tout spécifier à la fois en utilisant la construction «any».  Si seul le temps de mise en cache est spécifié, nginx mettra par défaut en cache uniquement les statuts 200, 301 et 302. <br><br>  Un exemple: <br><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">proxy_cache_valid</span></span> <span class="hljs-number"><span class="hljs-number">15m</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">proxy_cache_valid</span></span> <span class="hljs-number"><span class="hljs-number">404</span></span> <span class="hljs-number"><span class="hljs-number">15s</span></span>;</code> </pre><br>  Dans cet exemple, nous avons défini la durée de vie du cache sur 15 minutes pour les états 200, 301, 302 (nginx les utilise par défaut, car nous n'avons pas spécifié d'état spécifique).  La ligne suivante définit le temps de mise en cache sur 15 secondes, uniquement pour les réponses avec un état de 404. <br><br>  <i>proxy_cache_lock</i> - Cette directive aidera à éviter plusieurs passes vers le backend immédiatement après un ensemble de cache, il suffit de définir la valeur en position «on».  Toutes les autres demandes attendront une réponse dans le cache ou un délai d'expiration pour bloquer la demande sur la page.  Par conséquent, tous les délais d'attente peuvent être configurés. <br><br>  <i>proxy_cache_lock_age</i> - Vous permet de définir un délai d'expiration pour une réponse du serveur, après quoi la prochaine requête lui sera envoyée une fois le cache défini.  La valeur par défaut est 5 secondes. <br><br>  <i>proxy_cache_lock_timeout</i> - Définit le temps d'attente pour le verrouillage, après quoi la demande sera envoyée au backend, mais la réponse ne sera pas mise en cache.  La valeur par défaut est 5 secondes. <br><br>  <i>proxy_cache_use_stale</i> - Une autre directive utile qui vous permet de configurer quand il est possible d'utiliser un cache obsolète. <br><br>  Un exemple: <br><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">proxy_cache_use_stale</span></span> <span class="hljs-literal"><span class="hljs-literal">error</span></span> timeout updating;</code> </pre> <br>  Dans ce cas, il utilisera un cache obsolète en cas d'erreur de connexion, d'envoi d'une demande, de lecture d'une réponse du serveur, de dépassement de la limite d'attente pour l'envoi d'une demande, de lecture d'une réponse du serveur, ou si les données du cache sont mises à jour au moment de la demande. <br><br>  <i>proxy_cache_bypass</i> - Spécifie les conditions dans lesquelles nginx ne prendra pas de réponse du cache, mais redirigera immédiatement la demande vers le backend.  Si au moins un des paramètres n'est pas vide et n'est pas égal à «0».  Un exemple: <br><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">proxy_cache_bypass</span></span> <span class="hljs-variable"><span class="hljs-variable">$cookie_nocache</span></span> <span class="hljs-variable"><span class="hljs-variable">$arg_nocache</span></span>;</code> </pre> <br>  <i>proxy_no_cache</i> - Définit la condition dans laquelle nginx n'enregistrera pas la réponse du backend dans le cache.  Le principe de fonctionnement est le même que celui de la directive proxy_cache_bypass. <br><br><h3>  Problèmes possibles avec la mise en cache des pages </h3><br>  Comme mentionné ci-dessus, avec la mise en cache d'une réponse HTTP, nginx enregistre les en-têtes reçus du backend.  Si votre site utilise une session, le cookie de session sera également mis en cache.  Tous les utilisateurs qui visitent la page que vous avez eu la chance de mettre en cache recevront vos données personnelles stockées dans la session. <br><br>  Le prochain défi auquel vous serez confronté est la gestion de la mise en cache.  Bien sûr, vous pouvez définir un temps de cache insignifiant de 2 à 5 minutes et cela suffira dans la plupart des cas.  Mais cela n'est pas applicable dans toutes les situations, nous allons donc réinventer notre vélo.  Maintenant, tout d'abord. <br><br>  <b>Gestion de la conservation des cookies</b> <br><br>  La mise en cache du côté nginx impose certaines restrictions de conception.  Par exemple, nous ne pouvons pas utiliser de sessions sur les pages mises en cache, puisque l'utilisateur n'atteint pas le backend, une autre limitation est la livraison de cookies par le backend.  Étant donné que nginx met en cache tous les en-têtes, afin d'éviter de stocker la session de quelqu'un d'autre dans le cache, nous devons interdire la livraison de cookies pour les pages mises en cache.  La directive proxy_ignore_headers nous y aidera.  L'argument répertorie les en-têtes qui doivent être ignorés du backend. <br><br>  Un exemple: <br><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">proxy_ignore_headers</span></span> <span class="hljs-string"><span class="hljs-string">"Set-Cookie"</span></span>;</code> </pre> <br>  Avec cette ligne, nous ignorons l'installation de cookies à partir du serveur mandaté, c'est-à-dire que l'utilisateur recevra une réponse sans l'en-tête "Set-Cookies".  En conséquence, tout ce que le backend a tenté d'écrire dans le cookie sera ignoré côté client, car il ne saura même pas que quelque chose lui était destiné.  Cette restriction de cookie doit être prise en compte lors du développement d'une application.  Par exemple, pour demander une autorisation, vous pouvez désactiver l'allumage de l'en-tête afin que l'utilisateur reçoive un cookie de session. <br><br>  Vous devez également prendre en compte la durée de vie de la session, elle peut être consultée dans le paramètre « <i>session.gc_maxlifetime</i> » de la configuration php.ini.  Imaginez que l'utilisateur se connecte au site et commence à consulter le fil d'actualités, toutes les données sont déjà dans le cache nginx.  Après un certain temps, l'utilisateur remarque que son autorisation a disparu et il doit à nouveau passer par le processus d'autorisation, bien qu'il soit resté tout le temps sur le site pour regarder les informations.  Cela s'est produit parce que sur toutes ses demandes, nginx a renvoyé le résultat du cache sans envoyer de demande au backend.  Par conséquent, le backend a décidé que l'utilisateur était inactif et après une heure spécifiée dans « <i>session.gc_maxlifetime</i> » a supprimé le fichier de session. <br><br>  Pour éviter que cela ne se produise, nous pouvons émuler des demandes d'arrière-plan.  Par exemple, via ajax, envoyez une demande qui sera transmise au backend.  Pour passer le cache nginx au backend, il suffit d'envoyer une requête POST, vous pouvez également utiliser la règle de la directive «proxy_cache_bypass», ou tout simplement désactiver le cache de cette page.  La demande n'a pas à rendre quelque chose, il peut s'agir d'un fichier avec une seule ligne commençant la session.  Le but d'une telle demande est de prolonger la durée de vie de la session pendant que l'utilisateur est sur le site, et nginx donne consciencieusement les données mises en cache à toutes ses demandes. <br><br>  <b>Gestion du vidage du cache</b> <br><br>  Vous devez d'abord déterminer les exigences, le but que nous essayons d'atteindre.  Disons que notre site a une section avec une diffusion de texte des événements sportifs populaires.  Lorsque le chargement de la page est donné depuis le cache, tous les nouveaux messages arrivent sur les sockets.  Pour que l'utilisateur puisse voir les messages actuels à l'heure actuelle au premier démarrage, plutôt qu'il y a 15 minutes, nous devons être en mesure d'effacer indépendamment le cache nginx à tout moment.  En même temps, nginx peut ne pas se trouver sur la même machine que l'application.  En outre, l'une des exigences pour une réinitialisation sera la possibilité de supprimer le cache, sur plusieurs pages à la fois. <br><br>  Avant de commencer à rédiger votre solution, voyons ce que nginx propose immédiatement.  Pour réinitialiser le cache, nginx a une directive spéciale appelée "proxy_cache_purge", qui enregistre la condition de réinitialisation du cache.  La condition est en fait une ligne normale qui, si elle n'est pas vide et non «0», supprimera le cache par la clé passée.  Prenons un petit exemple. <br><br><pre> <code class="hljs perl">proxy_cache_path /data/nginx/cache keys_zone=cache_zone:<span class="hljs-number"><span class="hljs-number">10</span></span><span class="hljs-keyword"><span class="hljs-keyword">m</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">map</span></span> $request_method $purge_method { PURGE <span class="hljs-number"><span class="hljs-number">1</span></span>; default <span class="hljs-number"><span class="hljs-number">0</span></span>; } server { ... location / { proxy_pass http:<span class="hljs-regexp"><span class="hljs-regexp">//backend</span></span>; proxy_cache cache_zone; proxy_cache_key $uri; proxy_cache_purge $purge_method; } }</code> </pre><br>  <i>Un exemple est tiré du site officiel de nginx.</i> <br><br>  La variable $ purge_method est responsable du vidage du cache, qui est une condition pour la directive proxy_cache_purge et est définie sur 0 par défaut.  Cela signifie que nginx fonctionne en mode «normal» (il enregistre les réponses du backend).  Mais si vous changez la méthode de demande en «PURGE», puis au lieu de mandater la demande pour le backend avec l'enregistrement de la réponse, l'entrée de cache sera supprimée à l'aide de la clé de mise en cache correspondante.  Il est également possible de spécifier un masque de suppression en spécifiant un «*» à la fin de la clé de cache.  Ainsi, nous n'avons pas besoin de connaître l'emplacement du cache sur le disque et le principe de formation des clés, nginx assume ces responsabilités.  Mais cette approche présente également des inconvénients. <br><br><ul><li>  La directive proxy_cache_purge est disponible dans le cadre d'un abonnement commercial. </li><li>  Il est uniquement possible de supprimer le cache point par point, ou en utilisant le masque de la forme {clé de cache} "*" </li></ul><br>  Étant donné que les adresses des pages mises en cache peuvent être complètement différentes, sans parties communes, l'approche avec le masque «*» et la directive «proxy_cache_purge» ne nous convient pas.  Reste à rappeler un peu de théorie et à découvrir votre idée préférée. <br><br>  Nous savons que le cache nginx est un fichier normal sur le serveur.  Nous avons spécifié indépendamment le répertoire de stockage des fichiers de cache dans la directive "proxy_cache_path", nous avons même spécifié la logique de formation du chemin d'accès au fichier à partir de ce répertoire en utilisant des "niveaux".  La seule chose qui nous manque est la formation correcte de la clé de mise en cache.  Mais nous pouvons également le voir dans la directive "proxy_cache_key".  Il ne nous reste plus qu'à: <br><br><ul><li>  forment le chemin d'accès complet à la page, exactement comme spécifié dans la directive proxy_cache_key; </li><li>  coder la chaîne résultante dans md5; </li><li>  créer des répertoires imbriqués en utilisant la règle du paramètre «niveaux». </li><li>  Et maintenant, nous avons déjà le chemin d'accès complet au fichier cache sur le serveur.  Il ne nous reste plus qu'à supprimer ce fichier.  De la partie introductive, nous savons que nginx peut ne pas être situé sur la machine d'application, vous devez donc permettre de supprimer plusieurs adresses à la fois.  Encore une fois, nous décrivons l'algorithme: </li><li>  Les chemins générés vers les fichiers de cache que nous écrirons dans le fichier; </li><li>  Écrivons un simple script bash que nous mettons sur la machine avec l'application.  Sa tâche sera de se connecter via ssh au serveur où nous avons mis en cache nginx et de supprimer tous les fichiers de cache spécifiés dans le fichier généré à l'étape 1; </li></ul><br>  Nous passons de la théorie à la pratique, nous écrirons un petit exemple illustrant notre algorithme de travail. <br><br>  Étape 1. Génération d'un fichier avec des chemins d'accès au cache. <br><br><pre> <code class="hljs powershell"><span class="hljs-variable"><span class="hljs-variable">$urls</span></span> = [ <span class="hljs-string"><span class="hljs-string">'httpGETdomain.ru/news/111/1:2'</span></span>, <span class="hljs-string"><span class="hljs-string">'httpGETdomain.ru/news/112/3:4'</span></span>, ]; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">to_nginx_cache_path</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(url)</span></span></span></span> { <span class="hljs-variable"><span class="hljs-variable">$nginxHash</span></span> = md5(<span class="hljs-variable"><span class="hljs-variable">$url</span></span>); <span class="hljs-variable"><span class="hljs-variable">$firstDir</span></span> = substr(<span class="hljs-variable"><span class="hljs-variable">$nginxHash</span></span>, <span class="hljs-literal"><span class="hljs-literal">-1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-variable"><span class="hljs-variable">$secondDir</span></span> = substr(<span class="hljs-variable"><span class="hljs-variable">$nginxHash</span></span>, <span class="hljs-literal"><span class="hljs-literal">-3</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"/var/lib/nginx/proxy_cache/</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$firstDir</span></span></span><span class="hljs-string">/</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$secondDir</span></span></span><span class="hljs-string">/</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$nginxHash</span></span></span><span class="hljs-string">"</span></span>; } //        tmp <span class="hljs-variable"><span class="hljs-variable">$filePath</span></span> = tempnam(<span class="hljs-string"><span class="hljs-string">'tmp'</span></span>, <span class="hljs-string"><span class="hljs-string">'nginx_cache_'</span></span>); //      <span class="hljs-variable"><span class="hljs-variable">$fileStream</span></span> = fopen(<span class="hljs-variable"><span class="hljs-variable">$filePath</span></span>, <span class="hljs-string"><span class="hljs-string">'a'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-variable"><span class="hljs-variable">$urls</span></span> as <span class="hljs-variable"><span class="hljs-variable">$url</span></span>) { //      <span class="hljs-variable"><span class="hljs-variable">$cachePath</span></span> = to_nginx_cache_path(<span class="hljs-variable"><span class="hljs-variable">$url</span></span>); //       fwrite(<span class="hljs-variable"><span class="hljs-variable">$fileStream</span></span>, <span class="hljs-variable"><span class="hljs-variable">$cachePath</span></span> . PHP_EOL); } //     fclose(<span class="hljs-variable"><span class="hljs-variable">$fileStream</span></span>); //  bash       exec(<span class="hljs-string"><span class="hljs-string">"/usr/local/bin/cache_remover </span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$filePath</span></span></span><span class="hljs-string">"</span></span>);</code> </pre><br>  Veuillez noter que la variable $ urls contient l'url des pages mises en cache, déjà au format proxy_cache_key spécifié dans la configuration nginx.  L'URL agit comme une balise pour les entités affichées sur la page.  Par exemple, vous pouvez créer une table régulière dans la base de données, où chaque entité sera mappée sur une page spécifique sur laquelle elle est affichée.  Ensuite, lorsque vous modifiez des données, nous pouvons faire une sélection sur la table et supprimer le cache de toutes les pages dont nous avons besoin. <br><br>  Étape 2. Connectez-vous au serveur de cache et supprimez les fichiers de cache. <br><br><pre> <code class="hljs smalltalk">#      ,      <span class="hljs-type"><span class="hljs-type">FILE_LIST</span></span>=`cat <span class="hljs-string"><span class="hljs-string">$1</span></span> | tr <span class="hljs-comment"><span class="hljs-comment">"\n"</span></span> <span class="hljs-comment"><span class="hljs-comment">" "</span></span>` #   ssh  <span class="hljs-type"><span class="hljs-type">SSH</span></span>=`which ssh` <span class="hljs-type"><span class="hljs-type">USER</span></span>=<span class="hljs-comment"><span class="hljs-comment">"root"</span></span> #         nginx <span class="hljs-type"><span class="hljs-type">HOST</span></span>=<span class="hljs-comment"><span class="hljs-comment">"10.10.1.0"</span></span> #   <span class="hljs-type"><span class="hljs-type">KEY</span></span>=<span class="hljs-comment"><span class="hljs-comment">"/var/keys/id_rsa"</span></span> # <span class="hljs-type"><span class="hljs-type">SSH</span></span> ,          <span class="hljs-string"><span class="hljs-string">$S</span></span>SH -i <span class="hljs-string"><span class="hljs-string">${</span></span><span class="hljs-type"><span class="hljs-type">KEY</span></span>} <span class="hljs-string"><span class="hljs-string">${</span></span><span class="hljs-type"><span class="hljs-type">USER</span></span>}@<span class="hljs-string"><span class="hljs-string">${</span></span><span class="hljs-type"><span class="hljs-type">HOST</span></span>} <span class="hljs-comment"><span class="hljs-comment">"rm -f ${FILE_LIST}"</span></span> #       rm -rf rm -f <span class="hljs-string"><span class="hljs-string">$1</span></span> #  </code> </pre><br>  Les exemples ci-dessus sont fournis à titre indicatif uniquement, ne les utilisez pas en production.  Dans les exemples, les vérifications des paramètres d'entrée et des restrictions de commande sont omises.  L'un des problèmes que vous pouvez rencontrer est de limiter la longueur de l'argument à la commande rm.  Lorsque vous testez dans un environnement de développement sur de petits volumes, cela peut facilement être manqué, et en production, vous obtenez l'erreur «rm: Liste d'arguments trop longue». <br><br><h3>  Mise en cache de blocs personnalisée </h3><br>  Résumons ce que nous avons réussi à faire: <br><br><ul><li>  réduit la charge sur le backend; </li><li>  Découvrez comment gérer la mise en cache </li><li>  appris à vider le cache à tout moment. </li></ul><br>  Mais tout n'est pas aussi bon que cela puisse paraître à première vue.  Maintenant, probablement, sinon tous les premiers, alors précisément chaque deuxième site a une fonctionnalité d'enregistrement / autorisation, après avoir traversé, nous voudrons afficher le nom d'utilisateur quelque part dans l'en-tête.  Le bloc avec le nom est unique et devrait afficher le nom d'utilisateur sous lequel nous sommes autorisés.  Puisque nginx enregistre la réponse du backend, et dans le cas de la page, c'est le contenu html de la page, le bloc avec les données personnelles sera également mis en cache.  Tous les visiteurs du site verront le nom du premier utilisateur qui est passé au backend pour un ensemble de cache. <br>  Par conséquent, le backend ne doit pas donner de blocs dans lesquels se trouvent des informations personnelles afin que ces informations ne tombent pas dans le cache nginx. <br><br>  Il est nécessaire d'envisager un chargement alternatif de ces parties de la page.  Comme toujours, cela peut se faire de plusieurs manières, par exemple, après avoir chargé la page, envoyé une demande ajax et affiché le chargeur à la place du contenu personnel.  Une autre façon que nous considérerons aujourd'hui est d'utiliser des balises ssi.  Voyons d'abord ce qu'est SSI, puis comment l'utiliser en conjonction avec le cache nginx. <br><br><h3>  Qu'est-ce que SSI et comment ça marche </h3><br>  SSI (Server-Side includes, server-side inclusions) est un ensemble de commandes intégrées dans une page html qui indique au serveur quoi faire. <br><br>  Voici une liste de ces commandes (directives): <br><br>  • if / elif / else / endif - L'opérateur de branchement; <br>  • echo - Affiche les valeurs des variables; <br>  • inclure - Vous permet d'insérer le contenu d'un autre fichier dans le document. <br>  Seule la dernière directive sera discutée.  La directive include a deux paramètres: <br>  • fichier - Spécifie le chemin d'accès au fichier sur le serveur.  Concernant le répertoire courant; <br>  • virtuel - Indique le chemin d'accès virtuel au document sur le serveur. <br><br>  Nous nous intéressons au paramètre «virtuel», car spécifier le chemin complet du fichier sur le serveur n'est pas toujours pratique, ou dans le cas d'une architecture distribuée, le fichier sur le serveur n'est tout simplement pas là.  Exemple de directive: <br><br><pre> <code class="hljs xml"><span class="hljs-comment"><span class="hljs-comment">&lt;!--#include virtual="/user/personal_news/"--&gt;</span></span></code> </pre> <br>  Pour que nginx démarre le traitement des insertions ssi, vous devez modifier l'emplacement comme suit: <br><br><pre> <code class="hljs cs">location / { ssi <span class="hljs-keyword"><span class="hljs-keyword">on</span></span>; ... }</code> </pre><br>  Désormais, toutes les demandes traitées par l'emplacement «/» pourront effectuer des insertions ssi. <br><br>  Comment notre demande passera-t-elle par tout ce schéma? <br><br><ul><li>  le client demande la page; </li><li>  Nginx proxy la demande pour le backend; </li><li>  le backend donne la page avec des insertions ssi; </li><li>  le résultat est stocké dans le cache; </li><li>  Nginx «interroge» les blocs manquants; </li><li>  La page résultante est envoyée au client. </li></ul><br>  Comme vous pouvez le voir dans les étapes, les constructions ssi entreront dans le cache nginx, ce qui permettra de ne pas mettre en cache les blocs personnels, et une page html prête à l'emploi avec toutes les insertions sera envoyée au client.  Ici, notre chargement fonctionne, nginx demande indépendamment les blocs de page manquants.  Mais comme toute autre solution, cette approche a ses avantages et ses inconvénients.  Imaginez qu'il y ait plusieurs blocs sur la page qui devraient être affichés différemment selon l'utilisateur, puis chacun de ces blocs sera remplacé par un insert ssi.  Nginx, comme prévu, demandera chacun de ces blocs au backend, c'est-à-dire qu'une requête de l'utilisateur générera immédiatement plusieurs requêtes pour le backend, ce que je ne voudrais pas du tout. <br><br><h3>  Se débarrasser des requêtes backend persistantes via ssi </h3><br>  Pour résoudre ce problème, le module nginx «ngx_http_memcached_module» nous aidera.  Le module permet de recevoir des valeurs du serveur memcached.  L'écriture dans le module ne fonctionnera pas, le serveur d'applications devrait s'en occuper.  Prenons un petit exemple de configuration de nginx en conjonction avec un module: <br><br><pre> <code class="hljs nginx"><span class="hljs-section"><span class="hljs-section">server</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">location</span></span> /page { <span class="hljs-attribute"><span class="hljs-attribute">set</span></span> <span class="hljs-variable"><span class="hljs-variable">$memcached_key</span></span> <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$uri</span></span></span><span class="hljs-string">"</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">memcached_pass</span></span> <span class="hljs-number"><span class="hljs-number">127.0.0.1:11211</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">error_page</span></span> <span class="hljs-number"><span class="hljs-number">404</span></span> <span class="hljs-number"><span class="hljs-number">502</span></span> <span class="hljs-number"><span class="hljs-number">504</span></span> = <span class="hljs-variable"><span class="hljs-variable">@fallback</span></span>; } <span class="hljs-attribute"><span class="hljs-attribute">location</span></span> <span class="hljs-variable"><span class="hljs-variable">@fallback</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">proxy_pass</span></span> http://backend; } }</code> </pre><br>  Dans la variable $ memcache_key, nous avons spécifié la clé par laquelle nginx tentera d'obtenir les données de memcache.  Les paramètres de connexion au serveur memcache sont définis dans la directive memcached_pass.  La connexion peut être spécifiée de plusieurs manières: <br><br>  • nom de domaine; <br><br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">memcached_pass</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">cache</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.domain</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.ru</span></span>;</code> </pre> <br>  • adresse IP et port; <br><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">memcached_pass</span></span> localhost:<span class="hljs-number"><span class="hljs-number">11211</span></span>;</code> </pre> <br>  • prise unix; <br><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">memcached_pass</span></span> unix:/tmp/memcached.socket;</code> </pre> <br>  • directive amont. <br><br><pre> <code class="hljs axapta">upstream cachestream { hash $request_uri consistent; <span class="hljs-keyword"><span class="hljs-keyword">server</span></span> <span class="hljs-number"><span class="hljs-number">10.10</span></span><span class="hljs-number"><span class="hljs-number">.1</span></span><span class="hljs-number"><span class="hljs-number">.1</span></span>:<span class="hljs-number"><span class="hljs-number">11211</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">server</span></span> <span class="hljs-number"><span class="hljs-number">10.10</span></span><span class="hljs-number"><span class="hljs-number">.1</span></span><span class="hljs-number"><span class="hljs-number">.2</span></span>:<span class="hljs-number"><span class="hljs-number">11211</span></span>; } location / { ... memcached_pass cachestream; ... }</code> </pre><br>  Si nginx a réussi à obtenir une réponse du serveur de cache, il la donne au client.  S'il n'y a pas de données dans le cache, la demande sera envoyée au backend via «@fallback».  Cette petite configuration du module memcached sous nginx nous aidera à réduire le nombre de demandes de passage pour le backend des insertions ssi. <br><br>  Nous espérons que cet article a été utile et que nous avons pu montrer l'une des façons d'optimiser la charge sur le serveur, de considérer les principes de base de la configuration de la mise en cache nginx et de résoudre les problèmes qui se posent lors de son utilisation. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr428127/">https://habr.com/ru/post/fr428127/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr428117/index.html">Processeurs tensoriels gratuits de Google dans le cloud collaboratif</a></li>
<li><a href="../fr428119/index.html">«Class-fields-proposition» ou «Qu'est-ce qui s'est mal passé dans tc39 commit»</a></li>
<li><a href="../fr428121/index.html">Stan Drapkin. Pièges de cryptographie de haut niveau dans .NET</a></li>
<li><a href="../fr428123/index.html">Semaine de la sécurité 41: Bonne nouvelle</a></li>
<li><a href="../fr428125/index.html">Qui sont les analyses de produits et pourquoi sont-elles nécessaires dans une équipe?</a></li>
<li><a href="../fr428129/index.html">Une logique floue simple collée «de ce qui était» pour un moteur à turbine à gaz</a></li>
<li><a href="../fr428131/index.html">Toute la vérité sur RTOS. Article # 17. Groupes de drapeaux d'événements: introduction et services de base</a></li>
<li><a href="../fr428133/index.html">Hasura. Architecture GraphQL à SQL Server haute performance</a></li>
<li><a href="../fr428135/index.html">Comment configurer ou désactiver les peluches dans l'éditeur de code intégré</a></li>
<li><a href="../fr428137/index.html">Olympiade, concours d'idées, conférences sur la gestion de projets informatiques et projections de films: 10 événements à venir à l'Université ITMO</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>