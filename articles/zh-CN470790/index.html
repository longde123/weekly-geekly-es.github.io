<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>💫 🍒 🎨 我们以实用的方式解决Yandex.Interview任务 👈🏻 ☘️ 💃</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="几个月前，Yandex博客上发表了一篇文章 ，讨论了采访算法部分的通过。 除其他外，在本文中，链接指向了一个特殊竞赛，其中包含类似于Yandex向其候选人提供的任务的任务。 


 在系统中注册后，解决Haskell问题的能力立即吸引了我的注意力。 事实是，尽管我喜欢用这种语言进行编程，但除了在各种...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>我们以实用的方式解决Yandex.Interview任务</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/470790/"><p> 几个月前，Yandex博客上发表<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">了一篇文章</a> ，讨论了采访算法部分的通过。 除其他外，在本文中，链接指向了一个特殊竞赛，其中包含类似于Yandex向其候选人提供的任务的任务。 </p><br><p> 在系统中注册后，解决Haskell问题的能力立即吸引了我的注意力。 事实是，尽管我喜欢用这种语言进行编程，但除了在各种在线教育平台课程中执行任务之外，我没有取得什么进步。 认为他们的解决方案可能是一个有趣的挑战，并将提高我作为开发人员的水平之后，我着手解决了它们。 </p><br><p> 谁在乎它的最终结果，欢迎来关注。 </p><a name="habracut"></a><br><h2 id="a-kamni-i-ukrasheniya">  A.石头和珠宝 </h2><br><blockquote>给出了两行小写拉丁字符：字符串J和字符串S。字符串J中包含的字符是“珠宝”，字符串S中包含的字符是“石头”。 有必要确定S中有多少个字符同时是“珠宝”。 简而言之，您需要检查J中有多少个S字符。 </blockquote><p> 第一个任务是热身，我们将“在额头上”解决。 我们定义函数<em>jewelleryCount :: String-&gt; String-&gt; Int</em> ，该函数使用第二个参数传递的列表的卷积，对第一个列表中正在处理的项目的所有情况进行汇总。 为此，我们基于<em>elem</em>函数定义<em>elemInt</em>函数，与最后一个函数不同的是， <em>elemInt</em>函数将不返回True或False，而是返回数字0或1。在main函数中，您只需要读取两行，并将它们传递给相应的函数并打印结果即可。 测试系统的判定是可以的，我们转到第二项任务。 </p><br><pre><code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">jeweleryCount</span></span> :: <span class="hljs-type"><span class="hljs-type">String</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">String</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Int</span></span> jeweleryCount j = foldr ((+).(elemInt j)) <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> elemInt sx = fromEnum $ elem xs main :: <span class="hljs-type"><span class="hljs-type">IO</span></span> () main = <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> j &lt;- getLine s &lt;- getLine print $ jeweleryCount js</code> </pre> <br><p>  <em><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">github存储库中</a>也提供了用于解决此任务和其他任务的源代码<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">。</a></em> </p><br><h2 id="b-posledovatelno-iduschie-edinicy">  B.连续单位 </h2><br><blockquote> 需要找到二进制向量中最长的单位序列并打印其长度。 </blockquote><p> 为了解决这个问题，我们实现了一个递归函数，该函数将遍历传输的列表并计算所需序列的长度。 使用函数的参数，除了列表本身，我们还将传递当前的最大长度和当前调用中的连续单位数。 首先，我们基于空列表定义递归，然后递归步骤本身。 </p><br><p> 要读取输入，我们定义函数<em>getUserInputs :: IO [Char]</em> ，在该函数中，我们首先读取数字n-列表的大小，然后使用组合器<em>plicateM</em>获得一个函数，该函数将调用函数<em>&lt;&lt; get&gt; getLine</em> n次，并将结果合并到列表中。 </p><br><pre> <code class="haskell hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Control.Monad (<span class="hljs-title"><span class="hljs-title">replicateM</span></span>) onesCount :: [Char] -&gt; Int onesCount xs = onesCount' xs 0 0 where onesCount' "" max curr | max &gt; curr = max | otherwise = curr onesCount' (<span class="hljs-title"><span class="hljs-title">x</span></span>:<span class="hljs-title"><span class="hljs-title">xs</span></span>) max curr | x == '1' = onesCount' xs max $ curr + 1 | curr &gt; max = onesCount' xs curr 0 | otherwise = onesCount' xs max 0 getUserInputs :: IO [Char] getUserInputs = do n &lt;- read &lt;$&gt; getLine :: IO Int replicateM n $ head &lt;$&gt; getLine main :: IO () main = do xs &lt;- getUserInputs print $ onesCount xs</code> </pre><br><p> 我们发送决定，判决是可以的。 我们继续前进。 </p><br><h2 id="c-udalenie-dublikatov">  C.重复删除 </h2><br><blockquote>  32位整数数组以非降序排列。 您要从中删除所有重复项。 </blockquote><p> 让我们从一个简单的实现开始。 我们定义一个初始函数，该函数读取一个数字，打印该数字，然后将其包装在IO monad中返回。 我们还定义了<em>deleteDoubles :: Int-&gt; Int-&gt; IO（）</em>函数，该函数读取一个数字并仅在它不等于第二个参数时才打印该数字（我们将在那里传递上一步中读取的数字）。 之后，该函数递归地调用自身，从而前进到输入流中的下一个数字。 递归基数是要读取的数字数，我们将其传递给第一个参数。 </p><br><pre> <code class="haskell hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Control.Monad initial :: IO Int initial = do a &lt;- read &lt;$&gt; getLine print a return a deleteDoubles :: Int -&gt; Int -&gt; IO() deleteDoubles 0 _ = return () deleteDoubles ta = do b &lt;- read &lt;$&gt; getLine unless (<span class="hljs-title"><span class="hljs-title">a</span></span> == <span class="hljs-title"><span class="hljs-title">b</span></span>) $ print b deleteDoubles (<span class="hljs-title"><span class="hljs-title">t</span></span>-1) b main :: IO () main = do t &lt;- read &lt;$&gt; getLine unless (<span class="hljs-title"><span class="hljs-title">t</span></span> &lt; 1) $ initial &gt;&gt;= deleteDoubles (<span class="hljs-title"><span class="hljs-title">t</span></span>-1)</code> </pre> <br><p> 我们发送了解决方案，它通过了所有测试，似乎可以继续执行下一个任务，但是在我看来，在IO monad中运行的函数的递归调用比简洁更为令人困惑。 让我们尝试改善它。 </p><br><p> 请注意，通常来讲，您可以首先读取整个数字列表（我们将使用已经熟悉第二个任务的copyM组合器），然后将其传递给一个纯函数，该函数过滤掉所有重复项，最后打印结果。 </p><br><pre> <code class="haskell hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Control.Monad deleteDoubles' _ [] = [] deleteDoubles' prev (<span class="hljs-title"><span class="hljs-title">x</span></span>:<span class="hljs-title"><span class="hljs-title">xs</span></span>) | prev /= x = x:(<span class="hljs-title"><span class="hljs-title">deleteDoubles'</span></span> <span class="hljs-title"><span class="hljs-title">x</span></span> <span class="hljs-title"><span class="hljs-title">xs</span></span>) | otherwise = deleteDoubles' x xs deleteDoubles (<span class="hljs-title"><span class="hljs-title">x</span></span>:<span class="hljs-title"><span class="hljs-title">xs</span></span>) = x:deleteDoubles' x xs getUserInputs :: Int -&gt; IO [Int] getUserInputs t = replicateM t $ read &lt;$&gt; getLine main :: IO () main = do t &lt;- read &lt;$&gt; getLine unless (<span class="hljs-title"><span class="hljs-title">t</span></span> &lt; 1) $ (<span class="hljs-title"><span class="hljs-title">deleteDoubles</span></span> &lt;$&gt; <span class="hljs-title"><span class="hljs-title">getUserInputs</span></span> <span class="hljs-title"><span class="hljs-title">t</span></span>) &gt;&gt;= mapM_ print</code> </pre> <br><p> 我提出了一个解决方案，但让我失望的是该程序由于超出了已用内存的限制而没有通过193测试。 主要错误是将整个列表读入整个内存。 我们将尝试避免这种情况，并将实现第一版和第二版的某种混合形式。 </p><br><p> 请注意，删除重复项的任务在某种程度上让人联想到左联想卷积：在每一步中，我们计算一个函数，该函数根据读取的当前项及其某些结果，在上一步决定打印，然后继续进行下一对值。 </p><br><p> 一个函数根据其参数打印或不打印结果，然后返回包装在IO monad中的第二个参数，该函数非常简单，我们将其称为步骤： </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">step</span></span> :: <span class="hljs-type"><span class="hljs-type">Int</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Int</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">IO</span></span> <span class="hljs-type"><span class="hljs-type">Int</span></span> step fst snd = unless (fst == snd) (print snd) &gt;&gt; return snd</code> </pre> <br><p> 我们根据传递的值确定了是否要打印，但是如何组织读数？ 为此，我们使用单子卷积函数<em>foldM ::（可折叠t，单子m）=&gt;（b-&gt; a-&gt; mb）-&gt; b-&gt; ta-&gt; mb</em> ，它适用于读取函数列表。 <br> 通过函数foldM的类型，我们注意到在每个步骤中，函数的先前应用的结果的“拆包”都发生在foldM本身的内部。 因此，在每一步中，我们只需要使用<em>bind</em>运算符（ <em>&gt;&gt; =</em> ）对当前列表项进行单子计算（实际上，读取下一个数字），并将其与前一个数字一起传递给步骤。 结果，我们得到以下程序 </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">step</span></span> :: <span class="hljs-type"><span class="hljs-type">Int</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Int</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">IO</span></span> <span class="hljs-type"><span class="hljs-type">Int</span></span> step fst snd = unless (fst == snd) (print snd) &gt;&gt; return snd initial :: <span class="hljs-type"><span class="hljs-type">IO</span></span> <span class="hljs-type"><span class="hljs-type">Int</span></span> initial = <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> a &lt;- read &lt;$&gt; getLine print a return a getUserInputs t = replicate t $ read &lt;$&gt; getLine main :: <span class="hljs-type"><span class="hljs-type">IO</span></span> () main = <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> t &lt;- read &lt;$&gt; getLine unless (t &lt; <span class="hljs-number"><span class="hljs-number">1</span></span>) $ <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> init &lt;- initial foldM_ ((=&lt;&lt;) . step) init $ getUserInputs (t<span class="hljs-number"><span class="hljs-number">-1</span></span>)</code> </pre> <br><h2 id="d-generaciya-skobochnyh-posledovatelnostey">  D.括号序列的生成 </h2><br><blockquote> 给定整数n。 需要导出所有正确的长度为2⋅n的括号序列，按字典顺序排序（请参阅<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">https://ru.wikipedia.org/wiki/Lexographic_order</a> ）。 <br> 任务中仅使用括号。 <br> 建议获得一个在与响应中正确的括号序列的总数成比例的时间内工作的解决方案，同时使用与n成比例的存储容量。 </blockquote><p> 与许多其他任务一样，必须导出满足某些条件的序列（例如，可以在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">此处</a>更详细地阅读交换硬币，安排八个皇后和其他女王的任务），该任务可以使用列表monad简洁地解决。 简而言之，此方法基于列表的单子绑定，其含义是将对列表的每个元素执行的一组操作结合在一起。 </p><br><p> 定义一个递归函数<em>generate':: Int-&gt; Int-&gt; [[Char]]</em> ，该函数将要放入括号的数目作为第二个参数，并将已经设置为第一个参数的开放括号的数目。 对于递归步骤，我们需要两个辅助功能： <em>可能</em> -返回可以在下一步中放置的括号列表，以及<em>步骤</em> -使用必要的参数对generate'函数进行递归调用。 </p><br><pre> <code class="haskell hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Control.Monad(<span class="hljs-title"><span class="hljs-title">mapM_</span></span>) generate :: Int -&gt; [String] generate = generate' 0 where generate' _ 0 = [[]] generate' an = [x:xs | x &lt;- possible, xs &lt;- step x] where step '(' = <span class="hljs-title"><span class="hljs-title">generate'</span></span> (<span class="hljs-title"><span class="hljs-title">a</span></span> + 1) (<span class="hljs-title"><span class="hljs-title">n</span></span> - 1) step ')' = generate' (<span class="hljs-title"><span class="hljs-title">a</span></span> - 1) (<span class="hljs-title"><span class="hljs-title">n</span></span> - 1) possible | n == a = ")" | a == 0 = "(" | <span class="hljs-title"><span class="hljs-title">otherwise</span></span> = "()" main :: IO () main = do n &lt;- read &lt;$&gt; getLine let result = generate $ n * 2 mapM_ putStrLn result</code> </pre><br><p> 我们发送了解决方案，并且我们了解到我们没有考虑对程序使用的内存量施加的限制-由于超出了已用内存的限制，该解决方案未通过第14次测试。 </p><br><p> 我们修改了generate'函数，以便与其构建正确的括号序列的整个列表，不如将它们立即显示在屏幕上。 为此，我们将必须在函数中添加第三个参数-为当前步骤构建的序列的一部分。 我注意到在此实现中，我们将以相反的顺序构造序列-这将允许我们使用列表构造函数（ <em>:)</em>而不是更昂贵的串联运算符（ <em>++</em> ）。 </p><br><pre> <code class="haskell hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Control.Monad(<span class="hljs-title"><span class="hljs-title">mapM_</span></span>) generate :: Int -&gt; IO() generate = generate' "" 0 where generate' xs _ 0 = putStrLn $ reverse xs generate' xs an | n == a = step ')' | a == 0 = step '(' | <span class="hljs-title"><span class="hljs-title">otherwise</span></span> = <span class="hljs-title"><span class="hljs-title">step</span></span> '(' &gt;&gt; <span class="hljs-title"><span class="hljs-title">step</span></span> ')' where step '(' = <span class="hljs-title"><span class="hljs-title">generate'</span></span> ('(':<span class="hljs-title"><span class="hljs-title">xs</span></span>) (<span class="hljs-title"><span class="hljs-title">a</span></span> + 1) (<span class="hljs-title"><span class="hljs-title">n</span></span> - 1) step ')' = generate' (')':xs) (<span class="hljs-title"><span class="hljs-title">a</span></span> - 1) (<span class="hljs-title"><span class="hljs-title">n</span></span> - 1) main :: IO () main = do n &lt;- read &lt;$&gt; getLine generate $ n * 2</code> </pre><br><h2 id="e-anagrammy">  E.字谜 </h2><br><blockquote> 给出了两行，由小写拉丁字母组成。 需要确定这些行是否为字谜，即它们是否仅在字符顺序上有所不同。 </blockquote><p> 为了解决这个问题，我们将计算每行中出现一个字母的次数并比较结果。 我们立即了解到标准列表不适合我们，因此有必要使用一种数据结构，该结构将允许我们通过其索引有效地访问该元素。 有几种类型的数据可以满足我们的条件，但是我们将使用标准的不可<em>变数</em>组<em>Data.Array</em> （仍然至少存在各种可变数组以及<em>Data.Vector</em> ）。 </p><br><p> 为了构造必要的数组，我们使用函数<em>hist ::（Ix a，Num b）=&gt;（a，a）-&gt; [a]-&gt; Array ab</em> ，根据传递的元素列表和这些元素应属于的范围，该数组形成一个数组，它存储列表中元素的重复次数。 尽管未包含在Data.Array模块中，但此函数通常作为使用另一个已经存在的库函数accumArray的示例给出。 我们只能复制其实现并编写<em>main-数组Char Int</em>相等性比较的好处已经定义。 我将您的注意力吸引到一个不错的功能-作为索引，我们不仅可以使用整数，而且可以使用<em>Ix</em>类的任何代表。 就我们而言，Char在此角色中扮演着自然的角色。 </p><br><pre> <code class="haskell hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Data.Array hist :: (<span class="hljs-type"><span class="hljs-type">Ix</span></span> <span class="hljs-title"><span class="hljs-title">a</span></span>, <span class="hljs-type"><span class="hljs-type">Num</span></span> <span class="hljs-title"><span class="hljs-title">b</span></span>) =&gt; (<span class="hljs-title"><span class="hljs-title">a</span></span>,<span class="hljs-title"><span class="hljs-title">a</span></span>) -&gt; [a] -&gt; Array ab hist bnds is = accumArray (+) 0 bnds [(<span class="hljs-title"><span class="hljs-title">i</span></span>, 1) | i&lt;-is, inRange bnds i] main = do arr1 &lt;- hist ('<span class="hljs-title"><span class="hljs-title">a'</span></span>,'<span class="hljs-title"><span class="hljs-title">z'</span></span>) &lt;$&gt; getLine arr2 &lt;- hist ('<span class="hljs-title"><span class="hljs-title">a'</span></span>,'<span class="hljs-title"><span class="hljs-title">z'</span></span>) &lt;$&gt; getLine if (<span class="hljs-title"><span class="hljs-title">arr1</span></span> == <span class="hljs-title"><span class="hljs-title">arr2</span></span>) then print 1 else print 0</code> </pre><br><h2 id="f-sliyanie-k-sortirovannyh-spiskov">  F.合并k个排序列表 </h2><br><blockquote> 给定k个以非降序排序的非负整数数组，每个数组不超过100。构造它们合并的结果是必需的：一个以非降序排序的数组，其中包含原始k数组的所有元素。 <br> 每个数组的长度不超过10⋅k。 <br> 如果我们假设输入数组的长度为n，则尝试使解决方案在时间k⋅log（k）⋅n上起作用。 </blockquote><p> 合并两个排序的列表是一项经典的列表任务，在Haskell编程的许多课程中都有介绍。 例如，可以如下解决。 </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">merge</span></span> :: [<span class="hljs-type"><span class="hljs-type">Int</span></span>] -&gt; [<span class="hljs-type"><span class="hljs-type">Int</span></span>] -&gt; [<span class="hljs-type"><span class="hljs-type">Int</span></span>] merge [] ys = ys merge xs [] = xs merge (x:xs) (y:ys) | x &lt; y = x:merge xs (y:ys) | otherwise = y:merge (x:xs) ys</code> </pre><br><p> 好吧，我们可以合并两个列表。 列表应该怎么做？ 使用此功能进行卷积！ 因此，我们将所有列表合并为一个列表，只需要打印即可。 </p><br><div class="spoiler">  <b class="spoiler_title">解决方案</b> <div class="spoiler_text"><pre> <code class="haskell hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Control.Monad merge :: [Int] -&gt; [Int] -&gt; [Int] merge [] ys = ys merge xs [] = xs merge (<span class="hljs-title"><span class="hljs-title">x</span></span>:<span class="hljs-title"><span class="hljs-title">xs</span></span>) (<span class="hljs-title"><span class="hljs-title">y</span></span>:<span class="hljs-title"><span class="hljs-title">ys</span></span>) | x &lt; y = x:merge xs (<span class="hljs-title"><span class="hljs-title">y</span></span>:<span class="hljs-title"><span class="hljs-title">ys</span></span>) | otherwise = y:merge (<span class="hljs-title"><span class="hljs-title">x</span></span>:<span class="hljs-title"><span class="hljs-title">xs</span></span>) ys mergeLists :: [[Int]] -&gt; [Int] mergeLists = foldl merge [] getUserInputs :: Int -&gt; IO [[Int]] getUserInputs t = replicateM t $ do n &lt;- getLine return $ tail $ read &lt;$&gt; words n main :: IO () main = do k &lt;- read &lt;$&gt; getLine lists &lt;- getUserInputs k let res = mergeLists lists mapM_ (<span class="hljs-title"><span class="hljs-title">putStrLn</span></span> . <span class="hljs-title"><span class="hljs-title">show</span></span>) res</code> </pre> </div></div><br><p> 但是，此解决方案有两个严重的问题-计算复杂度高于所需的<em>-O（k ^ 2⋅n）</em>而不是<em>O（k⋅log（k）⋅n）</em> ，并且它使用了大量的额外内存。 结果，此解决方案由于超出了已使用的内存限制-17.27Mb（而不是允许的10Mb）而无法通过测试编号17。 </p><br><p> 尽管我们不会关注提供给输入的数字属于有限范围的值的事实，但是我们将继续寻找更通用的解决方案。 </p><br><p> 下一步是尝试通过分析这些任务来实现原始文章中提出的方法。 让我提醒您，它基于数据结构的使用，该数据结构提供了提取最小元素的有效方法。 作为这种结构，请选择<em>Data.Set</em> 。 我们使用第一个元素的列表初始化Set，然后在每个步骤中提取并打印最小元素，然后从相应的列表中添加下一个元素。 另外，我们将需要一个<em>Data.Sequence</em>结构来存储列表本身。 选择它的原因是，在每个步骤中都需要通过其索引快速访问列表（列表无法提供），并且无需复制整个结构即可更改该元素的元素（通常不能提供不变的<em>数据）。数组</em> ）。 </p><br><p> 因此，我们有以下程序： </p><br><div class="spoiler">  <b class="spoiler_title">解决方案</b> <div class="spoiler_text"><pre> <code class="haskell hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-keyword"><span class="hljs-keyword">qualified</span></span> Data.Sequence <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> Seq <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-keyword"><span class="hljs-keyword">qualified</span></span> Data.Set <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> Set <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Control.Monad <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Data.Foldable mergeLists :: Set.Set (<span class="hljs-type"><span class="hljs-type">Int</span></span>, <span class="hljs-type"><span class="hljs-type">Int</span></span>) -&gt; Seq.Seq [Int] -&gt; IO () mergeLists set seq | Set.null set = return () | otherwise = do let ((<span class="hljs-title"><span class="hljs-title">val</span></span>, <span class="hljs-title"><span class="hljs-title">idx</span></span>), set') = Set.deleteFindMin set print val if null (<span class="hljs-type"><span class="hljs-type">Seq</span></span>.<span class="hljs-title"><span class="hljs-title">index</span></span> <span class="hljs-title"><span class="hljs-title">seq</span></span> <span class="hljs-title"><span class="hljs-title">idx</span></span>) then mergeLists set' seq else mergeLists (<span class="hljs-type"><span class="hljs-type">Set</span></span>.<span class="hljs-title"><span class="hljs-title">insert</span></span> (<span class="hljs-title"><span class="hljs-title">head</span></span> (<span class="hljs-type"><span class="hljs-type">Seq</span></span>.<span class="hljs-title"><span class="hljs-title">index</span></span> <span class="hljs-title"><span class="hljs-title">seq</span></span> <span class="hljs-title"><span class="hljs-title">idx</span></span>), idx) set') (<span class="hljs-type"><span class="hljs-type">Seq</span></span>.<span class="hljs-title"><span class="hljs-title">adjust</span></span> <span class="hljs-title"><span class="hljs-title">tail</span></span> <span class="hljs-title"><span class="hljs-title">idx</span></span> <span class="hljs-title"><span class="hljs-title">seq</span></span>) getUserInputs :: Int -&gt; IO [[Int]] getUserInputs t = replicateM t $ do n &lt;- getLine return $ tail $ read &lt;$&gt; words n main :: IO () main = do t &lt;- read &lt;$&gt; getLine lists &lt;- getUserInputs t let init_seq = Seq.fromList (<span class="hljs-title"><span class="hljs-title">filter</span></span> (<span class="hljs-title"><span class="hljs-title">not</span></span> . <span class="hljs-title"><span class="hljs-title">null</span></span>) lists) let init_heap = Set.fromList (<span class="hljs-title"><span class="hljs-title">zipWith</span></span> (,) (<span class="hljs-title"><span class="hljs-title">toList</span></span> (<span class="hljs-title"><span class="hljs-title">fmap</span></span> <span class="hljs-title"><span class="hljs-title">head</span></span> <span class="hljs-title"><span class="hljs-title">init_seq</span></span>)) [0..]) mergeLists init_heap $ tail &lt;$&gt; init_seq</code> </pre></div></div><br><p> 我们发送了解决方案，发现即使程序开始消耗更少的内存（10.26Mb代替了第17个测试中的17.27Mb），它仍然没有达到限制。 这样做的原因在于，通过这种决定，我们必须以一种或另一种方式将整个输入数据读入存储器。 让我们尝试在此问题的第三个解决方案的帮助下避免这种情况-通过计数排序。 </p><br><p> 解决上一个字谜问题时，我们已经计算了传入字符的数量。 同样，在解决问题时，我们将使用<em>Data.Array</em> 。 首先，我们实现<em>addToArray :: Array Int Int-&gt; [Int]-&gt; Array Int Int</em>函数，该函数通过增加与列表中的值相对应的索引处的值，基于现有数组形成数组。 </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">addToArray</span></span> :: <span class="hljs-type"><span class="hljs-type">Array</span></span> <span class="hljs-type"><span class="hljs-type">Int</span></span> <span class="hljs-type"><span class="hljs-type">Int</span></span> -&gt; [<span class="hljs-type"><span class="hljs-type">Int</span></span>] -&gt; <span class="hljs-type"><span class="hljs-type">Array</span></span> <span class="hljs-type"><span class="hljs-type">Int</span></span> <span class="hljs-type"><span class="hljs-type">Int</span></span> addToArray acc elems = accum (+) acc [(i, <span class="hljs-number"><span class="hljs-number">1</span></span>) | i&lt;-elems]</code> </pre><br><p> 然后，在消除重复的任务中，我们将使用已知的方法-使用单<em>峰</em>卷积，将<em>addToArray</em>函数依次应用于<em>k个</em>源数组。 在第17次测试中，我们得到了10.26Mb的相同结果。 然后是时候记住， <em>foldl</em> （其类似物为<em>foldM</em> ）根据公认的归约顺序将首先扩展嵌套表达式的整个链，然后才进行它们的主动计算。 如您所知，为了解决这个问题， <em>Data.List</em>模块实现了<em>foldl'</em>函数，该函数使用函数<em>seq ::</em> <em>a-</em> <em>&gt; b-&gt; b</em> ，该函数首先将第一个参数转换为弱头范式，即将其<em>简化</em>为外部-函数或构造函数的值，然后返回第二个（ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">https://www.ibm.com/developerworks/ru/library/l-haskell4/index.html</a> ）。 我们别无选择， <em>只能独立</em>实现<em>foldM'</em>功能。 </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">foldM'</span></span> :: (<span class="hljs-type"><span class="hljs-type">Monad</span></span> m) =&gt; (a -&gt; b -&gt; ma) -&gt; a -&gt; [b] -&gt; ma foldM' _ z [] = return z foldM' fz (x:xs) = <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> z' &lt;- fzx z' `seq` foldM' fz' xs</code> </pre> <br><p> 结果，第17次测试的已用内存量几乎减少了一半，达到5.64Mb！ 尽管成功地通过了第17和第18个测试，但是由于超出了内存限制-10.25Mb的相同原因，此实现未通过第19个测试。 </p><br><p> 好的，继续-我们还没有尝试过Data.Array.Unboxed。 值得注意的是，这种类型的数组与标准不同，它可以自己存储值，而不是指向它们的指针（ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">https://wiki.haskell.org/Arrays#Unboxed_arrays</a> ）。 因此，此类阵列占用的存储空间更少，效率更高。 为了使用它们，我们只需要更改导入和函数类型，因为<em>Data.Array</em>和<em>Data.Array.Unboxed</em>实现了不可变<em>IArray</em>数组的一个接口。 </p><br><p> 我们正在发送一个解决方案-内存消耗减少了4.5倍，达到2.26 MB，但尚未超过时间限制-执行时间为1.09秒。 这可能与什么有关？ 从其余测试的执行时间保持不变的事实来判断，我认为原因并不是未装箱的阵列比装箱的阵列慢，而是特别是测试系统。 似乎一旦违反其中一项限制，任务就会中断。 但是，在极少数情况下，此实现仍以0.98秒的结果通过第19次测试，但由于超过了时间限制，因此未通过20号测试。 </p><br><p> 之后，我尝试使用Accum函数的不安全模拟，从理论上讲它应该更快，各种缓冲方法（ <em>hSetBuffering :: Handle-&gt; BufferMode-&gt; IO（）</em>函数），可变的<em>IOArray</em>数组，但是这些方法均未<em>产生</em>任何结果。 </p><br><p> 我不倾向于认为Haskell的限制设置得太紧，我希望仍然有一种解决方案能够通过所有测试。 在项目存储库中，我发布了用于解决此问题的几种不同版本的代码（使用Array和IOArray），也许这将是通过所有测试的解决方案的起点。 </p><br><h2 id="zaklyuchenie"> 结论 </h2><br><p> 尽管事实上只有六分之五的任务要我完成，但我还是完成了我的主要任务-练习函数式编程。 程序消耗的资源受到严格限制，这至少发挥了作用，这迫使我们寻找越来越多的新方法来解决问题。 我希望他们的描述对刚开始函数式编程之旅的人有用。 </p><br><p> 功能方法是否方便解决此类问题？ 老实说，我有双重印象。 一方面，解决大多数问题的方法非常简洁，Haskell本人的表达工具以及丰富的标准库在其中发挥了重要作用。 另一方面，人们不得不承认，在大多数情况下，消耗资源的管理可能是一个特定的问题，这将无法在给定的限制下解决该问题。 </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN470790/">https://habr.com/ru/post/zh-CN470790/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN470778/index.html">希捷ST2000DM008驱动器评测：快速的“两个”而不会过高的价格</a></li>
<li><a href="../zh-CN470780/index.html">酒吧已被使用-希捷（Seagate）的新产品用于存储</a></li>
<li><a href="../zh-CN470782/index.html">边界数据：如何构建新的IT架构</a></li>
<li><a href="../zh-CN470784/index.html">死细胞神秘世界的色彩设计</a></li>
<li><a href="../zh-CN470786/index.html">准备春季专业认证。 春季安全</a></li>
<li><a href="../zh-CN470792/index.html">采访无题鹅游戏的创造者之一</a></li>
<li><a href="../zh-CN470794/index.html">Laravel：解释基本概念。 第一部分：理论</a></li>
<li><a href="../zh-CN470800/index.html">P-预期以及DUMP喀山初步计划。 查看通过绞肉机选择的报告</a></li>
<li><a href="../zh-CN470802/index.html">备份，第6部分：比较备份工具</a></li>
<li><a href="../zh-CN470804/index.html">爱丽丝奖：获胜者的5个见解</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>