<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üçπ üè° üê¨ Tout ce dont vous avez besoin est une URL üöä üëñ üíê</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Les utilisateurs de VKontakte √©changent quotidiennement 10 milliards de messages. Ils s'envoient des photos, des bandes dessin√©es, des m√®mes et d'autr...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Tout ce dont vous avez besoin est une URL</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/vk/blog/467605/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/g6/l2/us/g6l2usvzzisf7ezfubycuyoty08.jpeg" alt="image"></div><br>  Les utilisateurs de VKontakte √©changent quotidiennement 10 milliards de messages.  Ils s'envoient des photos, des bandes dessin√©es, des m√®mes et d'autres pi√®ces jointes.  Nous allons vous expliquer comment nous avons cr√©√© une application iOS pour t√©l√©charger des images √† l'aide de <b><code>URLProtocol</code></b> , et √©tape par √©tape, nous d√©couvrirons comment impl√©menter la n√¥tre. <br><a name="habracut"></a><br>  Il y a environ un an et demi, le d√©veloppement d'une nouvelle section de messages dans l'application VK pour iOS battait son plein.  Ceci est la premi√®re section enti√®rement √©crite en Swift.  Il est situ√© dans un module s√©par√© <code>vkm</code> (VK Messages), qui ne sait rien du dispositif de l'application principale.  Il peut m√™me √™tre ex√©cut√© dans un projet distinct - la fonctionnalit√© de base de lecture et d'envoi de messages continuera de fonctionner.  Dans l'application principale, des contr√¥leurs de messages sont ajout√©s via le conteneur Container View Controller correspondant pour afficher, par exemple, une liste de conversations ou de messages dans une conversation. <br><br>  Messages est l'une des sections les plus populaires de l'application mobile VKontakte, il est donc important qu'elle fonctionne comme une horloge.  Dans le projet de <code>messages</code> , nous nous battons pour chaque ligne de code.  Nous avons toujours vraiment aim√© la fa√ßon dont les messages sont int√©gr√©s √† l'application, et nous nous effor√ßons de veiller √† ce que tout reste le m√™me. <br><br>  En remplissant progressivement la section de nouvelles fonctions, nous avons abord√© la t√¢che suivante: nous devions nous assurer que la photo jointe au message √©tait d'abord affich√©e dans un brouillon, et apr√®s l'avoir envoy√©e, dans la liste g√©n√©rale des messages.  Nous pourrions simplement ajouter un module pour travailler avec <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><code>PHImageManager</code></a> , mais des conditions suppl√©mentaires ont rendu la t√¢che plus difficile. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/0l/7t/hm/0l7thmey5vyyonmpbt5wicd-vjm.gif" alt="image"></div><br><br>  Lors du choix d'un instantan√©, l'utilisateur peut le traiter: appliquer un filtre, faire pivoter, rogner, etc. Dans l'application VK, cette fonctionnalit√© est impl√©ment√©e dans un composant <code>AssetService</code> distinct.  Maintenant, il fallait apprendre √† travailler avec lui √† partir du projet de message. <br><br><blockquote>  Eh bien, la t√¢che est assez simple, nous allons le faire.  C'est approximativement la solution moyenne, car il y a beaucoup de variations.  Nous prenons le protocole, le vidons dans les messages et commen√ßons √† le remplir avec des m√©thodes.  Nous ajoutons √† AssetService, adaptons le protocole et ajoutons notre impl√©mentation de cache!  pour la viscosit√©.  Ensuite, nous mettons l'impl√©mentation dans des messages, l'ajoutons √† un service ou un gestionnaire qui fonctionnera avec tout cela, et commencerons √† l'utiliser.  Dans le m√™me temps, un nouveau d√©veloppeur vient toujours et, tout en essayant de tout comprendre, il condamne √† voix basse ... (enfin, vous comprenez).  En m√™me temps, de la sueur appara√Æt sur son front. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/7i/ze/q8/7izeq8h2gkpsgj2qybfro74kobc.jpeg" alt="image"></div><br></blockquote><br>  Cette d√©cision n'√©tait <i>pas √† notre go√ªt</i> .  De nouvelles entit√©s apparaissent que les composants de message doivent conna√Ætre lorsqu'ils travaillent avec des images d' <code>AssetService</code> .  Le d√©veloppeur doit √©galement faire un travail suppl√©mentaire pour comprendre comment ce syst√®me fonctionne.  Enfin, il y avait un lien implicite suppl√©mentaire vers les composants du projet principal, que nous essayons d'√©viter afin que la section message continue de fonctionner comme un module ind√©pendant. <br><br>  Je voulais r√©soudre le probl√®me afin que le projet ne sache pas du tout quel type d'image a √©t√© choisi, comment la stocker, si elle avait besoin d'un chargement et d'un rendu sp√©ciaux.  De plus, nous avons d√©j√† la possibilit√© de t√©l√©charger des images conventionnelles √† partir d'Internet, seulement elles ne sont pas t√©l√©charg√©es via un service suppl√©mentaire, mais simplement par <code>URL</code> .  Et, en fait, il n'y a pas de diff√©rence entre les deux types d'images.  Seuls certains sont stock√©s localement, tandis que d'autres sont stock√©s sur le serveur. <br><br>  Nous avons donc eu une id√©e tr√®s simple: que faire si les ressources locales peuvent √©galement √™tre apprises √† charger via <code>URL</code> ?  Il semble qu'avec un seul clic des doigts de <s>Thanos</s> , cela r√©soudrait tous nos probl√®mes: vous n'avez rien √† savoir sur <code>AssetService</code> , ajouter de nouveaux types de donn√©es et augmenter l'entropie en vain, apprendre √† charger un nouveau type d'image, prendre soin de la mise en cache des donn√©es.  Cela ressemble √† un plan. <br><br><h2>  Tout ce dont nous avons besoin est une URL </h2><br>  Nous avons examin√© cette id√©e et d√©cid√© de d√©finir le format d' <code>URL</code> que nous utiliserons pour charger les ressources locales: <br><br><pre> <code class="json hljs">asset://?id=<span class="hljs-number"><span class="hljs-number">123</span></span>&amp;width=<span class="hljs-number"><span class="hljs-number">1920</span></span>&amp;height=<span class="hljs-number"><span class="hljs-number">1280</span></span></code> </pre> <br>  Nous utiliserons la valeur de la propri√©t√© <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><code>localIdentifier</code></a> de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><code>localIdentifier</code></a> comme <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><code>PHObject</code></a> , et nous passerons les param√®tres <code>width</code> et <code>height</code> pour charger les images de la taille souhait√©e.  Nous ajoutons √©galement quelques param√®tres suppl√©mentaires comme <code>crop</code> , <code>filter</code> , <code>rotate</code> , ce qui vous permettra de travailler avec les informations de l'image trait√©e. <br><br>  Pour g√©rer ces <code>URL</code> nous allons cr√©er un <code>AssetURLProtocol</code> : <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AssetURLProtocol</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">URLProtocol</span></span></span><span class="hljs-class"> </span></span>{ }</code> </pre> <br>  Sa t√¢che consiste √† charger l'image via <code>AssetService</code> et √† renvoyer les donn√©es d√©j√† pr√™tes √† l'emploi. <br><br>  Tout cela nous permettra de d√©l√©guer presque compl√®tement le travail du protocole <code>URL Loading System</code> et du <code>URL Loading System</code> . <br><br>  √Ä l'int√©rieur des messages, il sera possible de fonctionner avec les <code>URL</code> les plus courantes, uniquement dans un format diff√©rent.  Il sera √©galement possible de r√©utiliser le m√©canisme existant de chargement des images, il est tr√®s simple de s√©rialiser dans la base de donn√©es et d'impl√©menter la mise en cache des donn√©es via <code>URLCache</code> standard. <br><br>  Cela at-il fonctionn√©?  Si, en lisant cet article, vous pouvez joindre une photo de la galerie au message sur l'application VKontakte, alors oui :) <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/bm/6j/tb/bm6jtb7mkd489czjvwhzpy-dpo0.jpeg" alt="image"></div><br>  Pour clarifier comment impl√©menter votre <code>URLProtocol</code> , je propose de consid√©rer cela avec un exemple. <br><br>  Nous nous sommes fix√© la t√¢che: mettre en ≈ìuvre une application simple avec une liste dans laquelle vous devez afficher une liste d'instantan√©s de carte aux coordonn√©es donn√©es.  Pour t√©l√©charger des instantan√©s, nous utiliserons le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><code>MKMapSnapshotter</code></a> standard de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><code>MapKit</code></a> et nous chargerons les donn√©es via le <code>URLProtocol</code> personnalis√©.  Le r√©sultat pourrait ressembler √† ceci: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/l1/bg/s8/l1bgs8g0xzehoxt49oddmmtbuoe.gif" alt="image"></div><br>  Tout d'abord, nous impl√©mentons le m√©canisme de chargement des donn√©es par <code>URL</code> .  Pour afficher l'instantan√© de la carte, nous devons conna√Ætre les coordonn√©es du point - sa latitude et sa longitude ( <code>latitude</code> , <code>longitude</code> ).  D√©finissez le format d' <code>URL</code> personnalis√© par lequel nous voulons charger les informations: <br><br><pre> <code class="json hljs">map://?latitude=<span class="hljs-number"><span class="hljs-number">59.935634</span></span>&amp;longitude=<span class="hljs-number"><span class="hljs-number">30.325935</span></span></code> </pre> <br>  Maintenant, nous impl√©mentons <code>URLProtocol</code> , qui traitera ces liens et g√©n√©rera le r√©sultat souhait√©.  Cr√©ons la classe <code>MapURLProtocol</code> , que nous h√©riterons de la classe de base <code>URLProtocol</code> .  Malgr√© son nom, <code>URLProtocol</code> est cependant une classe abstraite.  Ne soyez pas g√™n√©, nous utilisons ici d'autres concepts - <code>URLProtocol</code> repr√©sente exactement le protocole <code>URL</code> et n'a aucun rapport avec les termes de POO.  Donc <code>MapURLProtocol</code> : <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MapURLProtocol</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">URLProtocol</span></span></span><span class="hljs-class"> </span></span>{ }</code> </pre> <br>  Maintenant, nous red√©finissons certaines m√©thodes requises sans lesquelles le protocole <code>URL</code> ne fonctionnera pas: <br><br><h3>  1. <code>canInit(with:)</code> </h3><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">func</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">canInit</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">with</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">request</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">URLRequest</span></span></span><span class="hljs-class">) -&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Bool</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> request.url?.scheme == <span class="hljs-string"><span class="hljs-string">"map"</span></span> }</code> </pre> <br>  La <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><code>canInit(with:)</code></a> est n√©cessaire pour indiquer les types de requ√™tes que notre protocole <code>URL</code> peut g√©rer.  Pour cet exemple, supposons que le protocole traite uniquement les demandes avec un sch√©ma de <code>map</code> dans l' <code>URL</code> .  Avant de lancer une requ√™te, l' <code>URL Loading System</code> passe par tous les protocoles enregistr√©s pour la session et appelle cette m√©thode.  Le premier protocole enregistr√©, qui dans cette m√©thode retournera <code>true</code> , sera utilis√© pour traiter la demande. <br><br><h4>  <code>canonicalRequest(for:)</code> </h4><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">func</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">canonicalRequest</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">for</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">request</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">URLRequest</span></span></span><span class="hljs-class">) -&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">URLRequest</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> request }</code> </pre> <br>  La m√©thode <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><code>canonicalRequest(for:)</code></a> est destin√©e √† r√©duire la demande au format canonique.  La documentation indique que la mise en ≈ìuvre du protocole lui-m√™me d√©cide ce qu'il faut consid√©rer comme la d√©finition de ce concept.  Ici, vous pouvez normaliser le sch√©ma, ajouter des en-t√™tes √† la demande, si n√©cessaire, etc. La seule condition pour que cette m√©thode fonctionne est que pour chaque demande entrante, il devrait toujours y avoir le m√™me r√©sultat, y compris parce que cette m√©thode est √©galement utilis√©e pour rechercher des r√©ponses mises en cache. demandes dans <code>URLCache</code> . <br><br><h4>  3. <code>startLoading()</code> </h4><br>  La m√©thode <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><code>startLoading()</code></a> d√©crit toute la logique de chargement des donn√©es n√©cessaires.  Dans cet exemple, vous devez analyser l' <code>URL</code> la demande et, en fonction des valeurs de ses param√®tres de <code>latitude</code> et de <code>longitude</code> , vous tourner vers <code>MKMapSnapshotter</code> et charger l'instantan√© de carte souhait√©. <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">startLoading</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">guard</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> url = request.url, <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> components = <span class="hljs-type"><span class="hljs-type">URLComponents</span></span>(url: url, resolvingAgainstBaseURL: <span class="hljs-literal"><span class="hljs-literal">false</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> queryItems = components.queryItems <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { fail(with: .badURL) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> } load(with: queryItems) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">load</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(with queryItems: [URLQueryItem])</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> snapshotter = <span class="hljs-type"><span class="hljs-type">MKMapSnapshotter</span></span>(queryItems: queryItems) snapshotter.start( with: <span class="hljs-type"><span class="hljs-type">DispatchQueue</span></span>.global(qos: .background), completionHandler: handle ) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">handle</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(snapshot: MKMapSnapshotter.Snapshot?, error: Error?)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> snapshot = snapshot, <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> data = snapshot.image.jpegData(compressionQuality: <span class="hljs-number"><span class="hljs-number">1</span></span>) { complete(with: data) } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> error = error { fail(with: error) } }</code> </pre> <br>  Apr√®s avoir re√ßu les donn√©es, il est n√©cessaire d'arr√™ter correctement le protocole: <br><br><pre> <code class="swift hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">complete</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(with data: Data)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">guard</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> url = request.url, <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> client = client <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> response = <span class="hljs-type"><span class="hljs-type">URLResponse</span></span>( url: url, mimeType: <span class="hljs-string"><span class="hljs-string">"image/jpeg"</span></span>, expectedContentLength: data.<span class="hljs-built_in"><span class="hljs-built_in">count</span></span>, textEncodingName: <span class="hljs-literal"><span class="hljs-literal">nil</span></span> ) client.urlProtocol(<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, didReceive: response, cacheStoragePolicy: .allowed) client.urlProtocol(<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, didLoad: data) client.urlProtocolDidFinishLoading(<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) }</code> </pre> <br>  Tout d'abord, cr√©ez un objet de type <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><code>URLResponse</code></a> .  Cet objet contient des m√©tadonn√©es importantes pour r√©pondre √† une demande.  Ensuite, nous ex√©cutons trois m√©thodes importantes pour un objet de type <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><code>URLProtocolClient</code></a> .  La propri√©t√© <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><code>client</code></a> de ce type contient chaque entit√© du protocole <code>URL</code> .  Il agit comme un proxy entre le protocole <code>URL</code> et l' <code>URL Loading System</code> enti√®re <code>URL Loading System</code> , qui, lorsque ces m√©thodes sont appel√©es, tire des conclusions sur ce qui doit √™tre fait avec les donn√©es: cache, transmet les demandes √† <code>completionHandler</code> , traite en quelque sorte l'arr√™t du protocole, etc. et le nombre d'appels √† ces m√©thodes peut varier en fonction de la mise en ≈ìuvre du protocole.  Par exemple, nous pouvons t√©l√©charger des donn√©es √† partir du r√©seau avec des lots et en informer p√©riodiquement <code>URLProtocolClient</code> √† ce sujet pour montrer la progression du chargement des donn√©es dans l'interface. <br><br>  Si une erreur se produit dans le fonctionnement du protocole, il est √©galement n√©cessaire de traiter correctement et d'informer <code>URLProtocolClient</code> √† ce sujet: <br><br><pre> <code class="swift hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fail</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(with error: Error)</span></span></span></span> { client?.urlProtocol(<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, didFailWithError: error) }</code> </pre> <br>  C'est cette erreur qui sera ensuite envoy√©e √† l' <code>completionHandler</code> la demande, o√π elle peut √™tre trait√©e et un beau message affich√© √† l'utilisateur. <br><br><h4>  4. <code>stopLoading()</code> </h4><br>  La m√©thode <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><code>stopLoading()</code></a> est appel√©e lorsque l'op√©ration de protocole a √©t√© termin√©e pour une raison quelconque.  Cela peut √™tre une r√©ussite, une erreur ou une demande d'annulation.  C'est un bon endroit pour lib√©rer des ressources occup√©es ou supprimer des donn√©es temporaires. <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">stopLoading</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { }</code> </pre> <br>  Ceci termine la mise en ≈ìuvre du protocole <code>URL</code> ; il peut √™tre utilis√© n'importe o√π dans l'application.  Pour savoir o√π appliquer notre protocole, ajoutez quelques √©l√©ments suppl√©mentaires. <br><br><h4> <code>URLImageView</code> </h4> <br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">URLImageView</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UIImageView</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> task: <span class="hljs-type"><span class="hljs-type">URLSessionDataTask?</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> taskId: <span class="hljs-type"><span class="hljs-type">Int?</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">render</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(url: URL)</span></span></span></span> { <span class="hljs-built_in"><span class="hljs-built_in">assert</span></span>(task == <span class="hljs-literal"><span class="hljs-literal">nil</span></span> || task?.taskIdentifier != taskId) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> request = <span class="hljs-type"><span class="hljs-type">URLRequest</span></span>(url: url) task = session.dataTask(with: request, completionHandler: complete) taskId = task?.taskIdentifier task?.resume() } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">complete</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(data: Data?, response: URLResponse?, error: Error?)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.taskId == task?.taskIdentifier, <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> data = data, <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> image = <span class="hljs-type"><span class="hljs-type">UIImage</span></span>(data: data) { didLoadRemote(image: image) } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">didLoadRemote</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(image: UIImage)</span></span></span></span> { <span class="hljs-type"><span class="hljs-type">DispatchQueue</span></span>.main.async { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.image = image } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">prepareForReuse</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { task?.cancel() taskId = <span class="hljs-literal"><span class="hljs-literal">nil</span></span> image = <span class="hljs-literal"><span class="hljs-literal">nil</span></span> } }</code> </pre> <br>  Il s'agit d'une classe simple, le descendant de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><code>UIImageView</code></a> , une impl√©mentation similaire dont vous avez probablement dans n'importe quelle application.  Ici, nous chargeons simplement l'image par l' <code>URL</code> dans la m√©thode <code>render(url:)</code> et l'√©crivons dans la propri√©t√© <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><code>image</code></a> .  La commodit√© est que vous pouvez t√©l√©charger absolument n'importe quelle image, soit par <code>URL</code> <code>http</code> / <code>https</code> , soit par notre <code>URL</code> personnalis√©e. <br><br>  Pour ex√©cuter les demandes de chargement d'images, vous aurez √©galement besoin d'un objet de type <code>URLSession</code> : <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> config: <span class="hljs-type"><span class="hljs-type">URLSessionConfiguration</span></span> = { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-built_in"><span class="hljs-built_in">c</span></span> = <span class="hljs-type"><span class="hljs-type">URLSessionConfiguration</span></span>.ephemeral <span class="hljs-built_in"><span class="hljs-built_in">c</span></span>.protocolClasses = [ <span class="hljs-type"><span class="hljs-type">MapURLProtocol</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">self</span></span> ] <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">c</span></span> }() <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> session = <span class="hljs-type"><span class="hljs-type">URLSession</span></span>( configuration: config, delegate: <span class="hljs-literal"><span class="hljs-literal">nil</span></span>, delegateQueue: <span class="hljs-literal"><span class="hljs-literal">nil</span></span> )</code> </pre> <br>  La configuration de la session est particuli√®rement importante ici.  Dans <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><code>URLSessionConfiguration</code></a> il existe une propri√©t√© importante pour nous - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><code>protocolClasses</code></a> .  Il s'agit d'une liste des types de protocoles <code>URL</code> qu'une session avec cette configuration peut g√©rer.  Par d√©faut, la session prend en charge le traitement des protocoles <code>http</code> / <code>https</code> et si une prise en charge personnalis√©e est requise, ils doivent √™tre sp√©cifi√©s.  Pour notre exemple, sp√©cifiez <code>MapURLProtocol</code> . <br><br>  Il ne reste plus qu'√† impl√©menter View Controller, qui affichera des instantan√©s de carte.  Son code source se trouve <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> . <br><br>  Voici le r√©sultat: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ed/gf/c8/edgfc8crekglljfq33hfggic520.gif" alt="image"></div><br><h2>  Et la mise en cache? </h2><br>  Tout semble bien fonctionner - sauf un point important: lorsque nous faisons d√©filer la liste d'avant en arri√®re, des points blancs apparaissent √† l'√©cran.  Il semble que les instantan√©s ne soient en aucun cas mis en cache et pour chaque appel √† la m√©thode <code>render(url:)</code> , nous <code>MKMapSnapshotter</code> donn√©es via <code>MKMapSnapshotter</code> .  Cela prend du temps, et donc de tels √©carts de chargement.  Il convient de mettre en ≈ìuvre un m√©canisme de mise en cache des donn√©es afin que les instantan√©s d√©j√† cr√©√©s ne soient pas t√©l√©charg√©s √† nouveau.  Ici, nous utilisons la puissance du <code>URL Loading System</code> , qui dispose d√©j√† d'un m√©canisme de mise en cache pour <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><code>URLCache</code></a> . <br><br>  Consid√©rez ce processus plus en d√©tail et divisez le travail avec le cache en deux √©tapes importantes: la lecture et l'√©criture. <br><br><h3>  La lecture </h3><br>  Pour lire correctement les donn√©es mises en cache, l' <code>URL Loading System</code> besoin d'aide pour obtenir des r√©ponses √† plusieurs questions importantes: <br><br>  <b>1. Quel URLCache utiliser?</b> <br><br>  Bien s√ªr, <code>URLCache.shared</code> est d√©j√† termin√©, mais l' <code>URL Loading System</code> ne peut pas toujours l'utiliser - apr√®s tout, le d√©veloppeur peut vouloir cr√©er et utiliser sa propre entit√© <code>URLCache</code> .  Pour r√©pondre √† cette question, la <code>URLSessionConfiguration</code> session <code>URLSessionConfiguration</code> a une propri√©t√© <code>urlCache</code> .  Il est utilis√© pour lire et enregistrer les r√©ponses aux demandes.  Nous <code>URLCache</code> un <code>URLCache</code> √† ces fins dans notre configuration existante. <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> config: <span class="hljs-type"><span class="hljs-type">URLSessionConfiguration</span></span> = { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-built_in"><span class="hljs-built_in">c</span></span> = <span class="hljs-type"><span class="hljs-type">URLSessionConfiguration</span></span>.ephemeral <span class="hljs-built_in"><span class="hljs-built_in">c</span></span>.urlCache = <span class="hljs-type"><span class="hljs-type">ImageURLCache</span></span>.current <span class="hljs-built_in"><span class="hljs-built_in">c</span></span>.protocolClasses = [ <span class="hljs-type"><span class="hljs-type">MapURLProtocol</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">self</span></span> ] <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">c</span></span> }()</code> </pre> <br>  <b>2. Dois-je utiliser des donn√©es en cache ou les t√©l√©charger √† nouveau?</b> <br><br>  La r√©ponse √† cette question d√©pend de la requ√™te <code>URLRequest</code> nous sommes sur le point d'ex√©cuter.  Lors de la cr√©ation d'une demande, nous avons la possibilit√© de sp√©cifier une politique de cache dans l'argument <code>cachePolicy</code> en plus de l' <code>URL</code> . <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> request = <span class="hljs-type"><span class="hljs-type">URLRequest</span></span>( url: url, cachePolicy: .returnCacheDataElseLoad, timeoutInterval: <span class="hljs-number"><span class="hljs-number">30</span></span> )</code> </pre> <br>  La valeur par d√©faut est <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><code>.useProtocolCachePolicy</code></a> , qui est √©galement √©crite dans la documentation.  Cela signifie que dans cette version, la t√¢che de trouver une r√©ponse mise en cache √† une demande et de d√©terminer sa pertinence incombe enti√®rement √† la mise en ≈ìuvre du protocole <code>URL</code> .  Mais il existe un moyen plus simple.  Si vous d√©finissez la valeur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><code>.returnCacheDataElseLoad</code></a> , lors de la cr√©ation de la prochaine entit√© <code>URLProtocol</code> <code>URL Loading System</code> cela prendra une partie du travail: il demandera √† <code>urlCache</code> r√©ponse mise en cache √† la demande actuelle √† l'aide de la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><code>cachedResponse(for:)</code></a> .  S'il y a des donn√©es en cache, un objet de type <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><code>CachedURLResponse</code></a> sera transf√©r√© imm√©diatement lorsque le <code>URLProtocol</code> initialis√© et stock√© dans la propri√©t√© <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><code>cachedResponse</code></a> : <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">init</span></span>( request: <span class="hljs-type"><span class="hljs-type">URLRequest</span></span>, cachedResponse: <span class="hljs-type"><span class="hljs-type">CachedURLResponse?</span></span>, client: <span class="hljs-type"><span class="hljs-type">URLProtocolClient?</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">init</span></span>( request: request, cachedResponse: cachedResponse, client: client ) }</code> </pre> <br>  <code>CachedURLResponse</code> est une classe simple qui contient des donn√©es ( <code>Data</code> ) et des m√©ta-informations pour eux ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><code>URLResponse</code></a> ). <br><br>  Nous pouvons seulement changer un <code>startLoading</code> m√©thode <code>startLoading</code> et v√©rifier la valeur de cette propri√©t√© √† l'int√©rieur - et terminer imm√©diatement le protocole avec ces donn√©es: <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">startLoading</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> cachedResponse = cachedResponse { complete(with: cachedResponse.data) } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">guard</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> url = request.url, <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> components = <span class="hljs-type"><span class="hljs-type">URLComponents</span></span>(url: url, resolvingAgainstBaseURL: <span class="hljs-literal"><span class="hljs-literal">false</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> queryItems = components.queryItems <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { fail(with: .badURL) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> } load(with: queryItems) } }</code> </pre> <br><h3>  Record </h3><br>  Pour trouver des donn√©es dans le cache, vous devez les y mettre.  Le <code>URL Loading System</code> s'occupe √©galement de ce travail.  Tout ce qui nous est demand√© est de lui dire que nous voulons mettre en cache les donn√©es lorsque le protocole <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><code>cacheStoragePolicy</code></a> aide du <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><code>cacheStoragePolicy</code></a> strat√©gie de cache <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><code>cacheStoragePolicy</code></a> .  Il s'agit d'une √©num√©ration simple avec les valeurs suivantes: <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">enum</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">StoragePolicy</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> allowed <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> allowedInMemoryOnly <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> notAllowed }</code> </pre> <br>  Ils signifient que la mise en cache est autoris√©e en m√©moire et sur disque, uniquement en m√©moire ou est interdite.  Dans notre exemple, nous indiquons que la mise en cache est autoris√©e en m√©moire et sur disque, car pourquoi pas. <br><br><pre> <code class="swift hljs">client.urlProtocol(<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, didReceive: response, cacheStoragePolicy: .allowed)</code> </pre> <br>  Ainsi, en suivant quelques √©tapes simples, nous avons pris en charge la possibilit√© de mettre en cache les instantan√©s de carte.  Et maintenant, l'application fonctionne comme ceci: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/l1/bg/s8/l1bgs8g0xzehoxt49oddmmtbuoe.gif" alt="image"></div><br>  Comme vous pouvez le voir, il n'y a plus de points blancs - les cartes sont charg√©es une fois puis simplement r√©utilis√©es √† partir du cache. <br><br><h2>  Pas toujours facile </h2><br>  Lors de la mise en ≈ìuvre du protocole <code>URL</code> , nous avons rencontr√© une s√©rie de plantages. <br><br>  Le premier √©tait li√© √† l'impl√©mentation interne de l'interaction du <code>URL Loading System</code> avec <code>URLCache</code> lors de la mise en cache des r√©ponses aux demandes.  La documentation <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">indique</a> : malgr√© la s√©curit√© des <code>URLCache</code> d' <code>URLCache</code> , le fonctionnement des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><code>cachedResponse(for:)</code></a> et <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><code>storeCachedResponse(_:for:)</code></a> pour lire / √©crire les r√©ponses aux requ√™tes peut conduire √† une race d'√©tats, donc ce point doit √™tre pris en compte dans les sous-classes <code>URLCache</code> .  Nous nous attendions √† ce que l'utilisation d' <code>URLCache.shared</code> ce probl√®me soit r√©solu, mais il s'est av√©r√© √™tre faux.  Pour r√©soudre ce probl√®me, nous utilisons un cache <code>ImageURLCache</code> distinct, un descendant d' <code>URLCache</code> , dans lequel nous <code>URLCache</code> les m√©thodes sp√©cifi√©es de mani√®re synchrone sur une file d'attente distincte.  Comme bonus agr√©able, nous pouvons configurer s√©par√©ment la capacit√© du cache en m√©moire et sur le disque s√©par√©ment des autres entit√©s <code>URLCache</code> . <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> accessQueue = <span class="hljs-type"><span class="hljs-type">DispatchQueue</span></span>( label: <span class="hljs-string"><span class="hljs-string">"image-urlcache-access"</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cachedResponse</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">for</span></span></span></span><span class="hljs-function"><span class="hljs-params"> request: URLRequest)</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">CachedURLResponse?</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-type"><span class="hljs-type">ImageURLCache</span></span>.accessQueue.sync { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.cachedResponse(<span class="hljs-keyword"><span class="hljs-keyword">for</span></span>: request) } } <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">storeCachedResponse</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">_</span></span></span></span><span class="hljs-function"><span class="hljs-params"> response: CachedURLResponse, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">for</span></span></span></span><span class="hljs-function"><span class="hljs-params"> request: URLRequest)</span></span></span></span> { <span class="hljs-type"><span class="hljs-type">ImageURLCache</span></span>.accessQueue.sync { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.storeCachedResponse(response, <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>: request) } }</code> </pre> <br>  Un autre probl√®me a √©t√© reproduit uniquement sur les appareils avec iOS 9. Les m√©thodes pour d√©marrer et terminer le chargement du protocole <code>URL</code> peuvent √™tre effectu√©es sur diff√©rents threads, ce qui peut entra√Æner des plantages rares mais d√©sagr√©ables.  Pour r√©soudre le probl√®me, nous enregistrons le thread actuel dans la m√©thode <code>startLoading</code> , puis <code>startLoading</code> le code de fin de t√©l√©chargement directement sur ce thread. <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> thread: <span class="hljs-type"><span class="hljs-type">Thread!</span></span> <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">startLoading</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">guard</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> url = request.url, <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> components = <span class="hljs-type"><span class="hljs-type">URLComponents</span></span>(url: url, resolvingAgainstBaseURL: <span class="hljs-literal"><span class="hljs-literal">false</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> queryItems = components.queryItems <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { fail(with: .badURL) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> } thread = <span class="hljs-type"><span class="hljs-type">Thread</span></span>.current <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> cachedResponse = cachedResponse { complete(with: cachedResponse) } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { load(request: request, url: url, queryItems: queryItems) } }</code> </pre> <br><pre> <code class="swift hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">handle</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(snapshot: MKMapSnapshotter.Snapshot?, error: Error?)</span></span></span></span> { thread.execute { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> snapshot = snapshot, <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> data = snapshot.image.jpegData(compressionQuality: <span class="hljs-number"><span class="hljs-number">0.7</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.complete(with: data) } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> error = error { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.fail(with: error) } } }</code> </pre> <br><h2>  Quand un protocole URL peut-il √™tre utile? </h2><br>  En cons√©quence, presque tous les utilisateurs de notre application iOS rencontrent d'une mani√®re ou d'une autre des √©l√©ments qui fonctionnent via le protocole <code>URL</code> .  En plus de t√©l√©charger des m√©dias √† partir de la galerie, diverses impl√©mentations de protocoles <code>URL</code> nous aident √† afficher des cartes et des sondages, ainsi qu'√† afficher des avatars de chat compos√©s de photos de leurs participants. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/5v/jz/sl/5vjzsliedpi6l9qt6qhnaloi1l8.jpeg" alt="image"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/p0/g4/rz/p0g4rzbdjqqbx3oc-ochol6ilwy.jpeg" alt="image"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/n4/1e/mb/n41embtawargx2zofdmevlyq_nk.jpeg" alt="image"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/j4/dn/gj/j4dngjkluh5gyxb3od9vwkse9zu.jpeg" alt="image"></div><br>  Comme toute solution, <code>URLProtocol</code> a ses avantages et ses inconv√©nients. <br><br><h3>  Inconv√©nients de <code>URLProtocol</code> </h3><br><ul><li>  <b>Manque de frappe stricte</b> - lors de la cr√©ation d'une <code>URL</code> param√®tres de sch√©ma et de lien sont sp√©cifi√©s manuellement via des cha√Ænes.  Si vous faites une faute de frappe, le param√®tre souhait√© ne sera pas trait√©.  Cela peut compliquer le d√©bogage de l'application et la recherche d'erreurs dans son fonctionnement.  Dans l'application VKontakte, nous utilisons des <code>URLBuilder</code> sp√©ciaux qui forment l' <code>URL</code> finale en fonction des param√®tres transmis.  Cette d√©cision n'est pas tr√®s belle et contredit quelque peu l'objectif de ne pas produire d'entit√©s suppl√©mentaires, mais il n'y a pas encore de meilleure id√©e.  Mais nous savons que si vous avez besoin de cr√©er une sorte d' <code>URL</code> personnalis√©e, il existe √† coup s√ªr un <code>URLBuilder</code> sp√©cial qui vous aidera √† ne pas faire d'erreur. </li><li>  <code>URLProtocol</code> <b>non √©vidents</b> - J'ai d√©j√† d√©crit quelques sc√©narios qui pourraient provoquer le <code>URLProtocol</code> une application utilisant <code>URLProtocol</code> .  Il y en a peut-√™tre d'autres.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Mais ces probl√®mes, comme d'habitude, sont r√©solus soit par une lecture plus r√©fl√©chie de la documentation, soit en √©tudiant en profondeur la trace de la pile et en trouvant la racine du probl√®me. </font></font></li></ul><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Avantages d'URLProtocol </font></font></h3><br><ul><li> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Faible connectivit√© des composants</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - la partie de l'application qui lance le chargement des donn√©es dont elle a besoin peut ne pas savoir du tout comment elle est organis√©e: quels composants sont utilis√©s pour cela, comment la mise en cache est organis√©e. </font><font style="vertical-align: inherit;">Nous ne connaissons qu'un certain format </font></font><code>URL</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- et n'interagissons qu'avec lui.</font></font></li><li> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Simplicit√© de mise en ≈ìuvre</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - pour le bon fonctionnement du </font></font><code>URL</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">protocole, il suffit de mettre en ≈ìuvre plusieurs m√©thodes simples et d'enregistrer le protocole. </font><font style="vertical-align: inherit;">Apr√®s cela, il peut √™tre utilis√© n'importe o√π dans l'application.</font></font></li><li> <b>  </b> ‚Äî       ,      ,   <code>URL</code> -.       <code>URL</code> , <code>URLSession</code> , <code>URLSessionDataTask</code> . </li><li> <b> </b> ‚Äî    <code>URL</code> -   <code>URL</code> -,             <code>URL Loading System</code> . </li><li> <b>*  API</b> ‚Äî      .     ,        API,   -  ,   <code>URL</code> -.       ,       API         ,  .         <code>URL</code> -      <code>http</code> / <code>https</code> . </li></ul><br> <code>URL</code> - ‚Äî         .      .  -   ,   -    ,   ,    , ‚Äî  ,      .  ,     , ‚Äî  <code>URL</code> . <br><br> <b>      <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">  GitHub</a></b> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr467605/">https://habr.com/ru/post/fr467605/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr467591/index.html">La nouvelle preuve r√©sout l'approximation de nombres tels que pi</a></li>
<li><a href="../fr467593/index.html">(Sans objet, r√©par√©) Remarque. Comment Tele2 partage l'acc√®s au compte personnel des nouveaux abonn√©s</a></li>
<li><a href="../fr467595/index.html">Voyager √† travers le centre de donn√©es Selectel. Dinosaure en feu, VMware, C2F5H et le loup-garou invisible</a></li>
<li><a href="../fr467597/index.html">Personnalisation des directives de produit Big Data avec Vowpal Wabbit</a></li>
<li><a href="../fr467599/index.html">Rendu graphique 3D avec OpenGL</a></li>
<li><a href="../fr467607/index.html">Confession de haineux docker</a></li>
<li><a href="../fr467609/index.html">Cr√©ation d'une application mobile sur React Native</a></li>
<li><a href="../fr467611/index.html">Algorithmes de d√©tection de contour d'image</a></li>
<li><a href="../fr467615/index.html">Comment cr√©er un wrapper Python et ne pas devenir fou</a></li>
<li><a href="../fr467617/index.html">Kaspresso: le framework d'autotest que vous attendiez</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>