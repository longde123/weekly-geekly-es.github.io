<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üç¶ üñïüèø üìº Le format Clang ralentit le programme üßïüèΩ üîì üà∏</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Aujourd'hui, nous mesurerons les performances des diff√©rentes impl√©mentations de la fonction toupper, car c'est ce qu'elles font le mardi. 

 En fait,...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Le format Clang ralentit le programme</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/pvs-studio/blog/480012/">  Aujourd'hui, nous mesurerons les performances des diff√©rentes impl√©mentations de la fonction toupper, car c'est ce qu'elles font le mardi. <br><br>  En fait, je ne me soucie pas de la fonction <a href="http://man7.org/linux/man-pages/man3/toupper.3.html"><i>toupper</i></a> , je viens d'√©crire un autre post r√©cemment et j'avais besoin d'une sorte de trame commune, et <i>toupper</i> semble √™tre un candidat assez int√©ressant et inoffensif pour les benchmarks.  J'ai essay√© de choisir quelque chose d'aussi simple que possible qui ne me laisserait pas de c√¥t√©, mais il se trouve que dans ce test, j'ai rencontr√© un probl√®me √©trange. <br><a name="habracut"></a><br>  Ce message sera petit - un article plus complet sur le sujet original, peut-√™tre plus int√©ressant, devrait √™tre publi√© prochainement.  Si vous souhaitez reproduire les r√©sultats avec moi, vous <a href="https://github.com/travisdowns/toupper-bench">pouvez prendre le</a> code source <a href="https://github.com/travisdowns/toupper-bench">sur github</a> . <br><br>  Ainsi, nous consid√©rerons trois impl√©mentations de la fonction <i>toupper</i> , qui traduit les caract√®res majuscules d'un tableau compos√© d'√©l√©ments de type <i>char</i> , √† savoir, il prend un tableau en argument et modifie directement ses √©l√©ments afin que toutes les lettres minuscules soient capitalis√©es. <br><br>  Dans la premi√®re impl√©mentation, nous appelons simplement <a href="https://linux.die.net/man/3/toupper">la fonction toupper</a> [1] <a href="https://linux.die.net/man/3/toupper">de la</a> biblioth√®que standard C et ex√©cutons une boucle de style C: <br><br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">toupper_rawloop</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params">* buf, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> size)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; size; i++) { buf[i] = <span class="hljs-built_in"><span class="hljs-built_in">toupper</span></span>(buf[i]); } }</code> </pre> <br>  Dans la deuxi√®me impl√©mentation, nous utilisons une approche <a href="https://www.youtube.com/watch%3Fv%3D2olsGf6JIkU">plus moderne</a> en rempla√ßant le cycle brut par <i>std :: transform</i> : <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">toupper_transform</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params">* buf, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> size)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::transform(buf, buf + size, buf, ::<span class="hljs-built_in"><span class="hljs-built_in">toupper</span></span>); }</code> </pre> <br>  Enfin, dans la troisi√®me impl√©mentation, nous utilisons un algorithme sp√©cial qui fonctionne avec des caract√®res ASCII.  Il v√©rifie si le caract√®re se situe dans la plage <i>a - z</i> , et en cas de succ√®s, substitue la m√™me lettre en majuscule, en soustrayant le nombre 32 du code de caract√®re [2]: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">toupper_branch</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params">* buf, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> size)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; size; i++) { <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> c = buf[i]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (c &gt;= <span class="hljs-string"><span class="hljs-string">'a'</span></span> &amp;&amp; c &lt;= <span class="hljs-string"><span class="hljs-string">'z'</span></span>) { buf[i] = c - <span class="hljs-number"><span class="hljs-number">32</span></span>; } } }</code> </pre> <br>  √áa a l'air facile, non? <br><br>  Maintenant, nous allons mesurer la vitesse de ces impl√©mentations sur mon ordinateur portable avec le processeur Skylake i7-6700HQ sur le compilateur gcc 5.5 avec les param√®tres par d√©faut.  Les r√©sultats sont donn√©s sous forme de diagramme de dispersion [3]: <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/webt/ec/ps/uf/ecpsuf8lfb6dcp2empyh6vqbkco.png"></div><br>  Nous traiterons imm√©diatement trois questions qui ne sont pas pertinentes pour notre t√¢che. <br><br>  Tout d'abord, regardez le graphique de l'algorithme de branchement (montr√© en vert).  Il varie consid√©rablement en fonction de la taille des donn√©es d'entr√©e - les deux autres graphiques restent presque plats.  Ce n'est en fait qu'un artefact de test.  Les caract√®res ASCII d'entr√©e sont s√©lectionn√©s au hasard [4], par cons√©quent, le facteur d√©cisif dans le cas de la troisi√®me impl√©mentation est le fonctionnement de l'algorithme de pr√©diction de branche.  Avec une petite quantit√© de donn√©es, il m√©morise compl√®tement la s√©quence des √©l√©ments au fur et √† mesure que l'it√©ration est effectu√©e, donc le nombre de rat√©s est petit et la vitesse est √©lev√©e, <a href="https://lemire.me/blog/2019/10/16/benchmarking-is-hard-processors-learn-to-predict-branches/">comme indiqu√© dans cette note</a> .  √Ä mesure que la taille de la s√©quence de donn√©es augmente, l'algorithme de pr√©diction se souvient de moins en moins jusqu'√† ce qu'il commence enfin √† manquer avec chaque lettre majuscule (0,27 manque par caract√®re), puis le graphique est nivel√©. <br><br>  Deuxi√®mement, faites attention au groupe de taches vertes en haut √† gauche, correspondant √† des vitesses beaucoup plus faibles de la variante avec ramification <i>toupper_branch</i> : <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/webt/b6/kj/by/b6kjbygj9inzadobigp0txj3vxu.png"></div><br>  Ce n'est pas un artefact isol√©: ces taches sont apparues lors de plusieurs lancements.  En m√™me temps, ils ne peuvent pas √™tre reproduits si vous testez l'algorithme uniquement sur ces tailles de donn√©es - ils n'apparaissent que lorsque le test est ex√©cut√© sur toutes les tailles.  Mais dans ce cas, ils n'apparaissent pas toujours.  Je ne l'ai pas particuli√®rement explor√©, mais je peux supposer que cela est d√ª √† certains conflits de noms ou d'alias dans l'algorithme de pr√©diction de branche ou lors du mappage de pages physiques de 4 Ko de m√©moire en virtuel (bien que la randomisation de l'espace d'adressage virtuel ait √©t√© d√©sactiv√©e). <br><br>  Troisi√®mement, l'impl√©mentation de <i>toupper_rawloop</i> (repr√©sent√©e en bleu) sur le graphique ressemble √† deux lignes distinctes: l'une l√©g√®rement au-dessus de la marque de 2 mesures par caract√®re, et l'autre au niveau de 1,5 mesure par caract√®re.  Ces deux lignes sont apparues dans tous les testeurs.  L'option plus rapide, avec une vitesse de 1,57 caract√®res par cycle, ralentit en fait sur les ports de t√©l√©chargement: la lecture des donn√©es sur les ports 2 et 3 se produit √† une vitesse de 1,54 micro-op√©rations par cycle, elles seront donc occup√©es √† 98%.  Je n'ai pas pu √©tablir la raison du ¬´r√©gime¬ª plus lent. <br><br>  Pendant que je traitais de cette question, le ¬´r√©gime¬ª rapide a soudainement disparu et seul le lent est rest√©.  Peut-√™tre que le processeur a r√©alis√© ce que j'essayais de faire et a secr√®tement t√©l√©charg√© la mise √† jour du microcode pour supprimer la contradiction, mais j'ai (toujours) la preuve - une image vectorielle avec des graphiques. <br><br>  Qu'est-ce qui nous int√©resse alors dans cet exemple? <br><br>  Mais ce qui nous int√©resse, c'est que la version avec un cycle brut est 3-4 fois plus rapide que la version avec <i>std :: transform</i> : 1,5-2 cycles par caract√®re contre 7 avec quelques cycles par caract√®re. <br><br>  Quelle est la question ici?  Les algorithmes standard m'ont-ils √©chou√©?  Est-ce que <i>std :: transform</i> a un d√©faut? <br><br>  Pas vraiment.  Plus pr√©cis√©ment, pas du tout. <br><br>  Il s'av√®re que de tels r√©sultats apparaissent lorsque les fonctions sont compil√©es dans <a href="">diff√©rents fichiers</a> .  Si vous les mettez dans le m√™me fichier, leurs performances deviennent √©galement faibles. <br><br>  Et non, l'alignement n'a rien √† voir avec cela. <br><br>  Mais ce n'est pas tout: la version rapide avec un cycle brut, lorsqu'elle est compil√©e dans un fichier s√©par√©, ralentit si vous y attachez simplement le fichier d'en-t√™te <i>&lt;algorithm&gt;</i> .  Oui, c'est vrai: connectez simplement ce fichier, qui n'est jamais utilis√© et ne g√©n√®re aucun code dans le fichier objet final, et la vitesse du cycle ¬´brut¬ª chutera 3-4 fois.  Au contraire, la version avec <i>std :: transform est</i> acc√©l√©r√©e √† la limite si vous copiez et collez l'impl√©mentation de <i>std :: transform √†</i> partir du fichier <i>&lt;algorithm&gt;</i> , mais n'incluez pas ce fichier. <br><br>  Les bizarreries ne s'arr√™tent pas l√† (il n'y en aura plus, je vous le promets): l'inclusion du fichier <i>&lt;algorithme&gt;</i> ne conduit pas toujours √† l'effet d√©crit.  Une baisse de vitesse se produit si <i>&lt;algorithme&gt; est</i> connect√© avant <i>&lt;ctype.h&gt;</i> , mais si vous les <i>√©changez</i> , alors non: <br><br>  <b>Code lent:</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;algorithm&gt; #include &lt;ctype.h&gt;</span></span></span></span></code> </pre> <br>  <b>Code rapide:</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;ctype.h&gt; #include &lt;algorithm&gt;</span></span></span></span></code> </pre> <br>  En fait, cette anomalie est apparue en moi (dans un autre projet) lorsque clang-format a automatiquement tri√© les fichiers d'en-t√™te inclus et plac√© l' <i>algorithme</i> au tout d√©but de la liste, o√π il appartient (d'o√π l'en-t√™te clickbait de l'article). <br><br>  Naturellement, nous avons d√ª nous plonger t√¥t ou tard dans la liste des assembleurs.  Nous ne retarderons pas ce moment d√©sagr√©able. <br><br>  Les versions <a href="https://godbolt.org/z/DwZBJM">rapides et lentes</a> des fonctions [5] sont illustr√©es ci-dessous, de petites boucles sont fournies avec des annotations: <br><br>  <b>&lt;algorithme&gt; se connecte en premier:</b> <br><br><pre> <code class="cpp hljs">toupper_rawloop(<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>*, <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span>): push rbp push rbx lea rbp, [rdi+rsi] sub rsp, <span class="hljs-number"><span class="hljs-number">8</span></span> test rsi, rsi je .L1 mov rbx, rdi .L5: movsx edi, BYTE PTR [rbx] ;  <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>-  *buf add rbx, <span class="hljs-number"><span class="hljs-number">1</span></span> ; buf++ call <span class="hljs-built_in"><span class="hljs-built_in">toupper</span></span> ;  <span class="hljs-built_in"><span class="hljs-built_in">toupper</span></span>(c) mov BYTE PTR [rbx<span class="hljs-number"><span class="hljs-number">-1</span></span>], al ;    buf[<span class="hljs-number"><span class="hljs-number">-1</span></span>] cmp rbp, rbx ;  buf == buf_end jne .L5 ; .L1: add rsp, <span class="hljs-number"><span class="hljs-number">8</span></span> pop rbx pop rbp ret</code> </pre> <br>  <b>&lt;algorithme&gt; est connect√© en second:</b> <br><br><pre> <code class="cpp hljs">toupper_rawloop(<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>*, <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span>): test rsi, rsi je .L7 push rbp push rbx mov rbp, rsi mov rbx, rdi sub rsp, <span class="hljs-number"><span class="hljs-number">8</span></span> call __ctype_toupper_loc lea rsi, [rbx+rbp] mov rdi, rbx .L4: ;  <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>-  buf movsx rcx, BYTE PTR [rdi] ;      <span class="hljs-built_in"><span class="hljs-built_in">toupper</span></span> ; (   __ctype_toupper_loc) mov rdx, QWORD PTR [rax] ; buf++ add rdi, <span class="hljs-number"><span class="hljs-number">1</span></span> ;   <span class="hljs-built_in"><span class="hljs-built_in">toupper</span></span>  , ;       mov edx, DWORD PTR [rdx+rcx*<span class="hljs-number"><span class="hljs-number">4</span></span>] mov BYTE PTR [rdi<span class="hljs-number"><span class="hljs-number">-1</span></span>], dl ;   cmp rsi, rdi ;  buf == end_buf jne .L4 ; add rsp, <span class="hljs-number"><span class="hljs-number">8</span></span> pop rbx pop rbp .L7: rep ret</code> </pre> <br>  La principale diff√©rence est que dans la version lente, la fonction toupper est simplement appel√©e en boucle, tandis que dans la version rapide, les appels de fonction sont compl√®tement absents, et il n'y a qu'une recherche dans la table de correspondance [6], c'est-√†-dire  le corps de la fonction <i>std :: toupper est</i> substitu√© √† l'endroit de l'appel. <br><br>  Si vous regardez le <a href="https://sourceware.org/git/%3Fp%3Dglibc.git%3Ba%3Dblob%3Bf%3Dctype/ctype.h%3Bh%3Dd17f727cf0dc2a0f6c62fa50aff799b175dcb426%3Bhb%3D2a764c6ee848dfe92cb2921ed3b14085f15d9e79">code source de</a> la biblioth√®que glibc, on y trouve l'impl√©mentation de la fonction <i>toupper</i> : <br><br><pre> <code class="cpp hljs">__extern_inline <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-comment"><span class="hljs-comment">// __NTH ‚Äì  , ,      __NTH (toupper (int __c)) { return __c &gt;= -128 &amp;&amp; __c &lt; 256 ? (*__ctype_toupper_loc ())[__c] : __c; }</span></span></code> </pre> <br>  Comme nous pouvons le voir, <i>toupper est</i> d√©fini comme une fonction <i>externe en ligne</i> qui v√©rifie d'abord que la taille du caract√®re char tient dans un octet [7], puis recherche le caract√®re dans la table de correspondance retourn√©e par la fonction <i>__ctype_toupper_loc ()</i> .  Cette fonction renvoie un pointeur de flux local (de type <i>const int **</i> ), qui, √† son tour, pointe vers une table de correspondance, √† partir de laquelle, en r√©ponse √† une demande de notre symbole, sa version majuscule est retourn√©e [8]. <br><br>  Maintenant, il est clair ce qui se passe dans la fiche.  Dans la version rapide de l'algorithme, le compilateur remplace le corps de la fonction <i>toupper</i> , mais ne peut pas remplacer l'appel √† la fonction <i>__ctype_toupper_loc ()</i> [9].  Cet appel, cependant, est d√©clar√© comme <i>__attribute __ ((const))</i> , ce qui signifie que la valeur de retour d√©pend uniquement des arguments (qui ne sont pas ici).  Le compilateur sait que cette fonction renvoie la m√™me valeur √† chaque fois, et prend donc son appel en dehors de la boucle, et dans la boucle elle-m√™me il n'y a que quelques op√©rations de lecture associ√©es √† l'acc√®s √† la table de correspondance, √† l'√©criture d'une nouvelle valeur dans le tampon et au contr√¥le de la boucle. <br><br>  Dans la version lente, l'appel √† <i>toupper ()</i> reste dans le corps de la boucle.  La boucle elle-m√™me est plus courte d'une commande, mais, bien s√ªr, vous devez maintenant ex√©cuter tout le code √† l'int√©rieur de la fonction <i>toupper</i> .  Sur mon syst√®me, cela ressemble √† ceci: <br><br><pre> <code class="cpp hljs"> lea edx,[rdi+<span class="hljs-number"><span class="hljs-number">0x80</span></span>] ; edx = rdi + <span class="hljs-number"><span class="hljs-number">0x80</span></span> movsxd rax,edi ;    c cmp edx,<span class="hljs-number"><span class="hljs-number">0x17f</span></span> ; ,  c     <span class="hljs-number"><span class="hljs-number">-128</span></span>  <span class="hljs-number"><span class="hljs-number">255</span></span> ja <span class="hljs-number"><span class="hljs-number">2</span></span>a ;  ,   mov rdx,QWORD PTR [rip+<span class="hljs-number"><span class="hljs-number">0x395f30</span></span>] ;    ;   mov rdx,QWORD PTR fs:[rdx] ;     ;     mov rdx,QWORD PTR [rdx] ;    ;    mov rdx,QWORD PTR [rdx+<span class="hljs-number"><span class="hljs-number">0x48</span></span>] ;     <span class="hljs-built_in"><span class="hljs-built_in">toupper</span></span> mov eax,DWORD PTR [rdx+rax*<span class="hljs-number"><span class="hljs-number">4</span></span>+<span class="hljs-number"><span class="hljs-number">0x200</span></span>] ;  c   <span class="hljs-number"><span class="hljs-number">2</span></span>a: ret</code> </pre> <br>  Comme il s'agit d'un appel non int√©gr√©, le programme fait plus de travail.  Il y a au moins cinq op√©rations cons√©cutives d'acc√®s √† la m√©moire (la soi-disant poursuite des pointeurs, la poursuite du pointeur).  Dans la version rapide, il n'en reste que deux, puisque tous les autres sont retir√©s de la boucle.  Le d√©lai entre l'appel d'une fonction et sa sortie devrait √™tre d'environ 25 cycles, et nous avons environ 7 cycles qui sortent - cela signifie que le processeur a pu parall√©liser l'appel, ce qui est assez bien, compte tenu des circonstances. <br><br>  Pourquoi en est-il ainsi? <br><br>  Dans une longue cha√Æne de fichiers d'inclusion, les fichiers d'en-t√™te C ++, tels que <i>&lt;algorithm&gt;</i> , incluent √† leur tour le fichier <i>&lt;bits / os_defines.h&gt;</i> , qui contient la ligne suivante: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//      isanum  .  //   . #define __NO_CTYPE 1</span></span></code> </pre> <br>  Lorsque le fichier <i>&lt;ctype.h&gt; est</i> enfin connect√©, √† cause de cette directive, le code dans lequel <i>toupper est</i> d√©fini comme <i>externe en ligne</i> ne peut pas √™tre inclus: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> !defined __NO_CTYPE # </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifdef</span></span></span><span class="hljs-meta"> __isctype_f __isctype_f (alnum) </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//  ..  .. __isctype_f (xdigit) # elif defined __isctype # define isalnum(c) __isctype((c), _ISalnum) # define isalpha(c) __isctype((c), _ISalpha) //  ..  .. # endif //      # ifdef __USE_EXTERN_INLINES __extern_inline int __NTH (tolower (int __c)) { return __c &gt;= -128 &amp;&amp; __c &lt; 256 ? (*__ctype_tolower_loc ())[__c] : __c; } __extern_inline int __NTH (toupper (int __c)) { return __c &gt;= -128 &amp;&amp; __c &lt; 256 ? (*__ctype_toupper_loc ())[__c] : __c; } # endif //   tolower     # if __GNUC__ &gt;= 2 &amp;&amp; defined __OPTIMIZE__ &amp;&amp; !defined __cplusplus # define tolower(c) __tobody (c, tolower, *__ctype_tolower_loc (), (c)) # define toupper(c) __tobody (c, toupper, *__ctype_toupper_loc (), (c)) # endif /* Optimizing gcc */ #endif /* Not __NO_CTYPE. */</span></span></span></span></code> </pre> <br>  Veuillez noter que lors de la connexion de <i>&lt;ctype.h&gt;, la</i> version C ++ de <i>toupper n'est</i> jamais d√©finie en tant que macro - au maximum en tant que <i>ligne</i> <i>externe</i> - car les d√©finitions des macros sont prot√©g√©es par la <i>v√©rification! Defined __cplusplus</i> et ne prendront donc jamais effet. <br><br>  En g√©n√©ral, je ne sais pas avec certitude si <i>__NO_CTYPE</i> dans ce cas devrait exclure les corps des fonctions <i>tolower</i> et <i>toupper</i> d√©clar√©es comme <i>externes en ligne</i> , mais c'est exactement ce qui se passe - et donc une baisse significative de la vitesse de notre cycle.  En conclusion, je peux dire que si vous incluez <i>&lt;cctype&gt;</i> au lieu de <i>&lt;ctype.h&gt;</i> (c'est-√†-dire que C ++ est la version du fichier d'en-t√™te C qui place les fonctions dans l' <i>espace de noms std ::)</i> , alors dans ce cas, le code fonctionnera lentement car <i>&lt;cctype&gt;</i> inclut finalement <i>&lt;bits / os_defines.h&gt;</i> . <br><br>  Est-ce que c'est si important?  Non, non. <br><br>  La fonction <i>toupper</i> ne convient pas pour un travail s√©rieux avec des caract√®res de diff√©rentes langues, donc si vous avez besoin de traiter uniquement des caract√®res ASCII, vous pouvez √©crire votre propre impl√©mentation plus rapide.  Si vous avez besoin de travailler s√©rieusement avec du texte, vous utiliserez tr√®s probablement UTF-8 et devrez utiliser une sorte d'ICU pour prendre en charge les param√®tres r√©gionaux, ou attendre que la prise en charge Unicode apparaisse en C ++ (cela peut prendre un certain temps) .  Ainsi, la d√©claration ¬´le format de clang peut entra√Æner une baisse de performance de 4x¬ª ne convient que comme en-t√™te de clickbait. <br><br>  Cet effet est-il observ√© dans toutes les versions de libc?  Oui, dans presque tous, mais m√™me ici ce n‚Äôest pas si simple. <br><br>  Les r√©sultats ci-dessus sont valables pour gcc 5.5 et glibc 2.23, car j'ai utilis√© ces versions, mais quelque chose de nouveau se produit dans les nouvelles versions (√† partir de la glibc 2.27 environ).  L√†, l'activation de <i>&lt;algorithm&gt;</i> avant <i>&lt;ctype.h&gt;</i> donne toujours le m√™me effet, mais maintenant <i>&lt;stdlib.h&gt;</i> [10] cr√©e √©galement des probl√®mes: si vous l'activez avant <i>&lt;ctype.h&gt;</i> , les performances chutent √©galement, ce qui n'est pas observ√© dans les versions ant√©rieures.  De toute √©vidence, dans les versions plus r√©centes, le fichier <i>&lt;stdlib.h&gt;</i> contient √©galement la d√©finition <i>__NO_CTYPE</i> .  Au moins, maintenant, il ne sera pas possible de bl√¢mer le format clang pour le tri - ici, cela peut simplement aider √† r√©soudre le probl√®me (s'il n'y a pas d'autres fichiers probl√©matiques dans la liste des fichiers connect√©s). <br><br>  J'ai publi√© <a href="https://sourceware.org/bugzilla/show_bug.cgi%3Fid%3D25214">un rapport de bogue dans libc</a> , il est donc probable que ce bogue sera corrig√©, mais il ne fait aucun doute que les erreurs li√©es √† l'ordre dans lequel les fichiers d'en-t√™te sont connect√©s nous importuneront davantage. <br><br><h2>  Commentaires </h2><br>  Je n'ai pas de syst√®me de commentaires sur mon site, mais j'y travaille (c'est-√†-dire en pleurant p√©riodiquement qu'il est difficile de faire des commentaires sur un site statique). <br><br>  En attendant, vous pouvez discuter de cet article sur le site Web de <a href="https://news.ycombinator.com/item%3Fid%3D21579333">Hacker News</a> ou <a href="https://lobste.rs/s/tjxzck/clang_format_tanks_performance">lobste.rs</a> . <br><br><h2>  Remerciements </h2><br>  Merci √† l'utilisateur ufo de Hacker News, qui a <a href="https://news.ycombinator.com/item%3Fid%3D21579483">soulign√©</a> qu'il n'est pas n√©cessaire d'utiliser la fonction lambda pour adapter <i>std :: toupper</i> pour une utilisation dans <i>std :: transform</i> , et aussi √† Jonathan Muller qui a <a href="https://twitter.com/foonathan/status/1197051249822195712">expliqu√©</a> que la fonction lambda est toujours n√©cessaire. <br><br><ol><li>  Oui, la fonction <i>toupper (3)</i> du fichier d'en-t√™te <i>&lt;ctype.h&gt;</i> ne convient pas pour travailler avec la plupart des caract√®res non ASCII, car  ne peut pas g√©rer des caract√®res sup√©rieurs √† un octet, mais il convient √† notre t√¢che, car nous ne lui passerons que des cha√Ænes de caract√®res ASCII. </li><li>  Dans le tableau ASCII, les caract√®res minuscules et majuscules sont tr√®s bien situ√©s - √† une distance de 32 positions l'un de l'autre, ce qui signifie que vous pouvez transf√©rer des caract√®res d'un cas √† l'autre simplement en soustrayant ou en ajoutant 32. En g√©n√©ral, si nous savions avec certitude que toutes les entr√©es les donn√©es sont des lettres ASCII, nous pourrions r√©initialiser le 5√®me bit sans aucune v√©rification (par exemple, <i>c &amp; 0b11011111</i> ) afin de transformer n'importe quelle lettre majuscule en minuscule, alors que cela ne se refl√©terait pas dans les lettres minuscules.  Mais nous ne le savons probablement pas, nous devons donc v√©rifier si le caract√®re est une lettre, afin de ne pas casser accidentellement des caract√®res non-lettre comme <i>char</i> . </li><li>  Cela devrait √™tre appel√© un nuage de points avec l'ajout de ¬´bruit¬ª √† l'emplacement des points.  En fait, il s'agit d'un diagramme de dispersion ordinaire dans lequel le param√®tre qui nous int√©resse (la taille des donn√©es d'entr√©e) est trac√© sur l'axe des x, et la vitesse de travail est sur l'axe des y (mesures par symbole - <i>plus la valeur est basse, plus la vitesse est √©lev√©e</i> ).  La principale caract√©ristique de ce diagramme est que pour chaque valeur de param√®tre sur l'axe x, l'√©chantillonnage est effectu√© plusieurs fois: dans ce cas, le test est r√©p√©t√© 10 fois pour chaque taille de r√©seau. </li><li>  √Ä savoir, les caract√®res sont s√©lectionn√©s de mani√®re al√©atoire et uniforme dans la plage [32, 127], de sorte que la condition dans la fonction sera vraie dans environ 27% des cas. </li><li>  Les deux listes font r√©f√©rence √† une impl√©mentation de cycle brut et diff√®rent uniquement dans l'ordre dans lequel les <i>fichiers</i> <i>&lt;algorithm&gt;</i> et <i>&lt;ctype.h&gt; sont inclus</i> .  Le code source g√©n√©r√© est le m√™me pour toutes les impl√©mentations - √† la fois dans les versions rapides et lentes.  Par exemple, une impl√©mentation avec <i>std :: transform</i> produira le m√™me code d'assembleur lent si vous incluez le fichier <i>&lt;algorithm&gt;</i> et le m√™me code rapide si vous copiez uniquement la d√©finition de fonction et n'incluez pas le fichier. </li><li>  Cependant, cette boucle rapide est plus lente qu'elle ne le pourrait car le pointeur vers la table de correspondance est lu trop de fois ( <i>mov rdx, QWORD PTR [rax]</i> ) √† l'int√©rieur de la boucle.  Ce pointeur peut √™tre diff√©rent selon les param√®tres r√©gionaux, mais il n'est pas mis √† jour pendant l'ex√©cution du cycle et peut donc √™tre d√©plac√© en dehors du cycle.  Il doit √™tre que le compilateur pense qu'il n'y a pas assez de raisons √† cela, puisque nous √©crivons dans un tableau d'√©l√©ments de type <i>char</i> , et ils peuvent en principe √™tre utilis√©s comme alias pour <i>[rax]</i> ie  pointeur vers la table.  Quoi qu'il en soit, m√™me <i>__restrict__ n'aidera</i> pas ici.  Mais dans une autre version de la boucle, o√π des valeurs plus <i>strictes</i> sont simplement ajout√©es et rien n'est √©crit dans le tableau, <a href="https://godbolt.org/z/Kb6pc8">cette optimisation est appliqu√©e</a> - le pointeur est lu en dehors de la boucle. </li><li>  Cette v√©rification n'est pas refl√©t√©e dans le code assembleur substituable, car le compilateur sait d√©j√† que les valeurs <i>char</i> sont toujours dans la plage <i>[-128, 255]</i> .  La v√©rification n'est n√©cessaire que parce que l'API de la fonction <i>toupper ¬©</i> accepte une valeur de type <i>int</i> plut√¥t que <i>char</i> , afin que l'utilisateur puisse lui transmettre tout nombre familier de type <i>int</i> , tandis que les tables de correspondance sont con√ßues uniquement pour les valeurs de type <i>char</i> , de sorte que la v√©rification permet d'√©viter de lire en dehors du tampon . </li><li>  Soit dit en passant, cela explique pourquoi les proc√©dures <i>std :: toupper</i> sont ind√©pendantes de la taille des donn√©es d'entr√©e: elles n'utilisent pas de branches (sauf pour les v√©rifications de plage, qui sont remarquablement pr√©dites), mais utilisent une table de correspondance ind√©pendante des branches.  <a href="https://habr.com/ru/company/pvs-studio/blog/480012/">‚Üµ</a> </li><li>  La substitution de cet appel ne fonctionnera pas m√™me avec un d√©sir tr√®s fort: le corps de la fonction n'est pas disponible dans le fichier d'en-t√™te. </li><li>  Je ne trouve <i>aucunement</i> d√©faut avec <i>stdlib.h</i> (ou <i>&lt;algorithme&gt;</i> , d'ailleurs) - il est fort possible que de nombreux autres fichiers d'en-t√™te C et tous les fichiers d'en-t√™te C ++ provoquent √©galement ce comportement, je ne les ai tout simplement pas test√©s.  J'ai connect√© <i>stdlib.h</i> juste pour d√©terminer <i>size_t</i> . </li></ol><br>  <b>Remarque</b>  Cet article a d'abord √©t√© publi√© sur le site Web <a href="https://travisdowns.github.io/blog/2019/11/19/toupper.html">Performance Matters</a> .  Les articles traduits sont publi√©s ici avec la permission de l'auteur. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr480012/">https://habr.com/ru/post/fr480012/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr480000/index.html">Indicateur de qualit√© du canal WebRTC du serveur sur TCP</a></li>
<li><a href="../fr480002/index.html">Revoir DevOpsDays Moscou: aper√ßu de 6 rapports</a></li>
<li><a href="../fr480006/index.html">Indicateur de qualit√© de canal pour le serveur WebRTC sur TCP</a></li>
<li><a href="../fr480008/index.html">Yuri Rogachev: "Je suis venu faire le M-1, ne connaissant pas la technologie informatique"</a></li>
<li><a href="../fr480010/index.html">Les 3 principaux √©l√©ments HTML que nous avons oubli√©s</a></li>
<li><a href="../fr480016/index.html">39% des PME russes font face √† des cyberattaques cibl√©es</a></li>
<li><a href="../fr480018/index.html">D√©veloppement d'applications mobiles en Python. Biblioth√®que KivyMD</a></li>
<li><a href="../fr480022/index.html">Instanciation de Python</a></li>
<li><a href="../fr480024/index.html">Pervenche: processeur √† instruction unique</a></li>
<li><a href="../fr480026/index.html">Annonce de l'aper√ßu des machines virtuelles Azure Spot</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>