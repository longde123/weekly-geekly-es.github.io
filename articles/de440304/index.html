<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üí™ üë®üèΩ‚Äçüé§ üöì Interrupts von externen Ger√§ten in einem x86-System. Teil 3. Konfigurieren des Interrupt-Routings im Chipsatz anhand des Coreboot-Beispiels üòë üêå üîÄ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Wir werden weiterhin in Betracht ziehen, Interrupts von externen Ger√§ten im x86-System zu konfigurieren. 
 In Teil 1 (Die Entwicklung von Interrupt-Co...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Interrupts von externen Ger√§ten in einem x86-System. Teil 3. Konfigurieren des Interrupt-Routings im Chipsatz anhand des Coreboot-Beispiels</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/440304/">  Wir werden weiterhin in Betracht ziehen, Interrupts von externen Ger√§ten im x86-System zu konfigurieren. <br>  In Teil 1 (Die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Entwicklung von Interrupt-Controllern</a> ) haben wir die theoretischen Grundlagen von Interrupt-Controllern und allgemeine Begriffe untersucht. In Teil 2 ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Linux-Kernel-Boot-Optionen</a> ) haben wir untersucht, wie das Betriebssystem in der Praxis zwischen Controllern w√§hlt.  In diesem Teil werden wir uns ansehen, wie das BIOS das IRQ-Routing f√ºr Interrupt-Controller im Chipsatz konfiguriert. <br><br>  Keine modernen BIOS-Entwicklungsunternehmen (AwardBIOS / AMIBIOS / Insyde) legen den Quellcode ihrer Programme offen.  Aber zum Gl√ºck gibt es <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Coreboot</a> , ein Projekt, das das propriet√§re BIOS durch freie Software ersetzt.  In seinem Code werden wir sehen, wie das Interrupt-Routing im Chipsatz konfiguriert ist. <br><br><img src="https://habrastorage.org/webt/mx/vi/wu/mxviwuisp5rglec_kgsk872hmy8.png"><br><br><a name="habracut"></a><br><h2>  Theorie </h2><br>  Erfrischen und erg√§nzen Sie zun√§chst unser theoretisches Wissen.  In <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 1 haben</a> wir einen gemeinsamen Interrupt-Pfad f√ºr den Fall von PIC und APIC identifiziert. <br><br>  <b>Bild:</b> <br><br><img src="https://habrastorage.org/webt/u_/jr/u9/u_jru9pemdeda2xvvbqihvgtp3y.png"><br><br>  <b>APIC:</b> <br><br><img src="https://habrastorage.org/webt/mc/ra/hj/mcrahjn-owk9qrcmyiixcmhomcq.png"><br><br>  In diesen Figuren ist das PCI-Ger√§t ‚Üí PIR-Mapping abstrakt dargestellt, tats√§chlich ist es etwas komplizierter.  In Wirklichkeit hat jedes PCI-Ger√§t 4 Interrupt-Leitungen (INTA #, INTB #, INTC #, INTD #).  Jedes PCI-Ger√§t kann bis zu 8 Funktionen haben und jede Funktion hat bereits einen INTx # Interrupt.  Welche Zeile von INTx # jede Funktion des Ger√§ts abruft, ist entweder in der Hardware festgelegt oder wird durch die Konfiguration des Ger√§ts bestimmt. <br><br><img src="https://habrastorage.org/webt/dk/ny/gh/dknyghwfo8gktn5l_lmmqb5awz0.png"><br><br>  Funktionen sind im Wesentlichen separate logische Bl√∂cke.  Beispielsweise kann in einem PCI-Ger√§t eine Smbus-Controller-Funktion, eine SATA-Controller-Funktion oder eine LPC-Bridge-Funktion vorhanden sein.  Auf der Betriebssystemseite ist jede Funktion ein separates Ger√§t mit einem eigenen Konfigurationsbereich f√ºr die PCI-Konfiguration. <br><br>  Im einfachsten (und h√§ufigsten) Fall eines PCI-Ger√§ts gibt es nur eine Funktion, deren Interrupt √ºber die INTA # -Leitung erfolgt.  Im Allgemeinen verf√ºgt das Ger√§t jedoch m√∂glicherweise sogar √ºber mehr als 4 Funktionen (wie bereits erw√§hnt, 8). Einige davon m√ºssen dann auf einer INTx # -Leitung platziert werden (PCI-Interrupts k√∂nnen die Leitung gemeinsam nutzen).  Au√üerdem kann bei PCI-Ger√§ten, die im Chipsatz enthalten sind, durch Schreiben in spezielle Register h√§ufig angegeben werden, welche Funktionen welche INTx # -Leitungen verwenden (und ob sie √ºberhaupt verwendet werden). <br><br>  Wir systematisieren unser Wissen und bezeichnen den Pfad (Routing) von Unterbrechungen von jeder PCI-Funktion √ºber INTx # ‚Üí PIRQy ‚Üí IRQz, wobei: <br><br><ul><li>  INTx # - Zeile INT # (INTA #, INTB #, INTC #, INTD #) des PCI-Ger√§ts, das die Funktion verwenden wird </li><li>  PIRQy - die PIRQ-Leitung (PIRQA, PIRQB, ...) von der PIR, mit der die INTx # -Leitung verbunden ist </li><li>  IRQz - IRQ-Leitung (0, 1, 2, ...) am Interrupt-Controller (APIC / PIC), der mit der PIRQy-Leitung verbunden ist </li></ul><br><h3>  Warum k√∂nnen Sie nicht einfach √ºberall eine Verbindung herstellen? INTA # ‚Üí PIRQA, INTB # ‚Üí PIRQB, ...? </h3><br>  Warum √ºberhaupt Routing einrichten?  Angenommen, wir m√∂chten nicht alle Interrupt-Leitungen von allen PCI-Ger√§ten auf die gleichen PIRQ-Leitungen √ºbertragen.  Sagen wir Folgendes: <br><br><ul><li>  INTA # ‚Üí PIRQA </li><li>  INTB # ‚Üí PIRQB </li><li>  INTC # ‚Üí PIRQC </li><li>  INTD # ‚Üí PIRQD </li></ul><br>  Wie oben erw√§hnt, ist der h√§ufigste Fall, wenn ein PCI-Ger√§t eine Funktion hat und seine Unterbrechung mit der INTA # -Leitung verbunden ist (warum sollte der Ger√§teentwickler es anders starten?).  Wenn wir uns also pl√∂tzlich dazu entschlie√üen, alle Zeilen so zu starten, wie wir sie geschrieben haben, werden fast alle Interrupts von Ger√§ten in PIRQA-Zeilen unterteilt.  Nehmen wir an, sie ist auf IRQ16 gelandet.  Jedes Mal, wenn der Prozessor dar√ºber informiert wird, dass ein Interrupt auf der IRQ16-Leitung aufgetreten ist, muss er die Treiber aller an die IRQ16-Leitung (PIRQA) angeschlossenen Ger√§te abfragen, ob sie einen Interrupt daf√ºr haben.  Wenn es viele solcher Ger√§te gibt, beschleunigt dies nat√ºrlich nicht die Systemreaktion auf Unterbrechungen.  Und die PIRQB-PIRQD-Leitungen sind in diesem Fall gr√∂√ütenteils inaktiv.  Zur Verdeutlichung die Abbildung, die das Problem veranschaulicht: <br><br><img src="https://habrastorage.org/webt/cz/dv/bf/czdvbfsnymw5xyyqujavawdcv_m.png"><br><br>  Aber alles k√∂nnte so gemacht werden: <br><br><img src="https://habrastorage.org/webt/dk/3e/x6/dk3ex67xjmm_9h0q3miq2djqnti.png"><br><br>  Das Bild ist etwas verwirrend, aber der Punkt ist, dass wir einfach die INTx # -Linien mit PIRQy mit Round-Robin verbinden (PIRQA, PIRQB, PIRQC, PIRQD, PIRQA, PIRQB, PIRQC, PIRQD, PIRQA, PIRQB, PIRQC, PIRQD). ..) <br><br>  Es ist zu beachten, dass hier nicht nur ber√ºcksichtigt werden muss, dass auf jeder PIRQ-Leitung die gleiche Anzahl von PCI-Funktionen geladen ist.  Schlie√ülich k√∂nnen einige Funktionen sehr selten und einige dauerhaft Interrupts erzeugen (z. B. Ethernet-Controller).  In diesem Fall kann sogar die Zuweisung einer separaten PIRQ-Leitung f√ºr Interrupts mit einer solchen Funktion durchaus gerechtfertigt sein. <br><br>  Auf der Grundlage des Vorstehenden hat der BIOS-Entwickler unter anderem die Aufgabe sicherzustellen, dass die PIRQ-Leitungen gleichm√§√üig mit Interrupts geladen werden. <br><br><h3>  Was soll das BIOS √ºberhaupt tun? </h3><br>  Wir systematisieren in der Abbildung: <br><br><img src="https://habrastorage.org/webt/pm/rq/xg/pmrqxgkdu0nkjz6yb44vdn79a8q.png"><br><br><ul><li>  <b>1) Geben Sie an, welche INTx # -Zeile jede Funktion von PCI-Ger√§ten abruft</b> <br>  Bei externen PCI-Ger√§ten wird dieser Punkt nicht ausgef√ºhrt, bei den im Chipsatz enthaltenen Funktionen von PCI-Ger√§ten jedoch m√∂glicherweise. </li><li>  <b>2) Konfigurieren Sie die INTx # ‚Üí PIRQy-Zuordnung f√ºr jedes PCI-Ger√§t</b> <br>  Es ist erw√§hnenswert, dass es mehr als vier Standard-PIRQy-Signale geben kann (PIRQA, PIRQB, PIRQC, PIRQD).  Zum Beispiel 8: PIRQA-PIRQH. </li></ul><br>  PIRQy-Signale gehen auf die IRQz-Leitung des ausgew√§hlten Interrupt-Controllers (APIC / PIC).  Da wir alle m√∂glichen Lademethoden unterst√ºtzen m√∂chten (siehe <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 2</a> ), m√ºssen wir beide Zuordnungen ausf√ºllen: <br><br><ul><li>  <b>3a) F√ºllen Sie das Mapping PIRQy ‚Üí IRQz1 f√ºr die Kommunikation PIR ‚Üí I / O APIC aus</b> <br>  In der Regel ist dies jedoch nicht erforderlich, da die PIRQy-Leitungen auf der APIC-Leitung festgelegt sind.  Die √ºbliche L√∂sung ist PIRQA ‚Üí IRQ16, PIRQB ‚Üí IRQ17, ... Die einfachste L√∂sung, weil  Wenn Sie PIRQy-Leitungen auf Controller-Leitungen ‚â• 16 platzieren, m√ºssen Sie sich keine Gedanken √ºber Konflikte mit untrennbaren Interrupts von ISA-Ger√§ten machen. </li><li>  <b>3b) F√ºllen Sie das Mapping PIRQy ‚Üí IRQz2 f√ºr die Kommunikation PIR ‚Üí PIC</b> <br>  Dies muss angegeben werden, wenn wir das Routing √ºber den PIC-Controller verwenden.  Es gibt keine so eindeutige L√∂sung wie im Fall von APIC, da im Fall von PIC die M√∂glichkeit von Konflikten mit untrennbaren Interrupts von ISA-Ger√§ten bekannt sein sollte. </li></ul><br>  Der letzte vierte Punkt ist erforderlich, um das Betriebssystem bei der Bestimmung des Interrupt-Routings zu unterst√ºtzen.  Das Ger√§t selbst verwendet diese Register normalerweise nicht. <br><br><ul><li>  <b>4) F√ºllen Sie die Interrupt Line / Interrupt Pin-Register f√ºr jede PCI-Funktion aus</b> <br>  Im Allgemeinen wird das Interrupt-Pin-Register automatisch ausgef√ºllt und ist normalerweise schreibgesch√ºtzt. Daher muss beim Ausf√ºllen h√∂chstwahrscheinlich nur das Interrupt-Line-Register ausgef√ºllt werden.  Dies muss bereitgestellt werden, wenn wir das Routing √ºber den PIC-Controller verwenden, ohne dem Betriebssystem eine Tabelle zu Routing-Interrupts zur Verf√ºgung zu stellen (siehe erneut <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 2</a> ).  Wenn Tabellen bereitgestellt werden und diese Zuordnung mit Routing-Tabellen ($ PIR / ACPI) √ºbereinstimmt, verl√§sst das Betriebssystem diese h√§ufig. </li></ul><br>  Es ist zu beachten, dass wir die Tabellen $ PIR / MPtable / ACPI noch nicht ber√ºhren und √ºberlegen, wie die Chipsatzregister in Bezug auf Routing-Interrupts konfiguriert werden, bevor die Steuerung an den Systemloader √ºbertragen wird.  Interrupt-Tabellen sind ein Thema f√ºr einen separaten Artikel (m√∂glicherweise einen zuk√ºnftigen). <br><br>  Also werden die theoretischen Grundlagen studiert, endlich fangen wir an zu √ºben! <br><br><h2>  √úbe </h2><br>  Als Beispiel f√ºr Artikel in dieser Serie verwende ich ein benutzerdefiniertes Board mit einem Intel Haswell i7-Prozessor und einem LynxPoint-LP-Chipsatz.  Auf diesem Board habe ich Coreboot in Verbindung mit SeaBIOS gestartet.  Coreboot bietet eine hardwarespezifische Initialisierung, und die SeaBIOS-Nutzdaten bieten eine BIOS-Schnittstelle f√ºr Betriebssysteme.  In diesem Artikel werde ich nicht den Prozess der Konfiguration von Coreboot beschreiben, sondern nur anhand eines Beispiels zeigen, welche BIOS-Einstellungen im Chipsatz vorgenommen werden sollten, um IRQ-Interrupts von externen Ger√§ten weiterzuleiten. <br><br>  Da sich das Coreboot-Projekt aktiv entwickelt, sodass der Artikel immer auf dem neuesten Stand ist, werden wir den Code am Beispiel der neuesten festen Version <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">4.9</a> (Release 2018-12-20) betrachten. <br><br>  Das Motherboard, das meinem am n√§chsten kommt, ist Google Beltino mit Panther-Variante.  Der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Hauptordner</a> f√ºr dieses Motherboard ist der Ordner <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">"src \ mainboard \ google \ bearino"</a> .  Alle Einstellungen sind hier und der f√ºr diese Karte spezifische Code konzentriert. <br><br>  Beginnen wir also damit, herauszufinden, wo die oben genannten Elemente konfiguriert sind: <br><br><h4>  1) Geben Sie an, welche INTx # -Zeile jede Funktion von PCI-Ger√§ten abruft </h4><br>  Diese Informationen werden in der Datei <a href="">‚Äûsrc / mainboard / google / bearino / romstage.c‚Äú</a> in der Struktur rcba_config √ºber die DxxIP-Register (Device xx Interrupt Pin Register (IP)) definiert.  Dieses Register zeigt an, welcher Pin INTx # (A / B / C / D) jede der Ger√§tefunktionen einen Interrupt ausgibt. <br><br>  M√∂gliche Optionen (siehe Datei <a href="">"src / southbridge / intel / lynxpoint / pch.h"</a> ): <br><br><pre><code class="cpp hljs"><span class="hljs-number"><span class="hljs-number">0</span></span>h = No interrupt <span class="hljs-number"><span class="hljs-number">1</span></span>h = INTA# <span class="hljs-number"><span class="hljs-number">2</span></span>h = INTB# <span class="hljs-number"><span class="hljs-number">3</span></span>h = INTC# <span class="hljs-number"><span class="hljs-number">4</span></span>h = INTD#</code> </pre> <br>  Es wird angenommen, dass mehrere Funktionen denselben Pin verwenden. <br><br>  Es wird angenommen, dass Funktionen den Pin m√∂glicherweise nicht f√ºr Unterbrechungen verwenden (keine Unterbrechung). <br>  Alles, wie wir in der Abbildung am Anfang des Artikels gesehen haben. <br><br>  Der vollst√§ndige Code ist f√ºr den von uns bezeichneten Artikel verantwortlich: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* Device interrupt pin register (board specific) */</span></span> RCBA_SET_REG_32(D31IP, (INTC &lt;&lt; D31IP_TTIP) | (NOINT &lt;&lt; D31IP_SIP2) | (INTB &lt;&lt; D31IP_SMIP) | (INTA &lt;&lt; D31IP_SIP)), RCBA_SET_REG_32(D29IP, (INTA &lt;&lt; D29IP_E1P)), RCBA_SET_REG_32(D28IP, (INTA &lt;&lt; D28IP_P1IP) | (INTC &lt;&lt; D28IP_P3IP) | (INTB &lt;&lt; D28IP_P4IP)), RCBA_SET_REG_32(D27IP, (INTA &lt;&lt; D27IP_ZIP)), RCBA_SET_REG_32(D26IP, (INTA &lt;&lt; D26IP_E2P)), RCBA_SET_REG_32(D22IP, (NOINT &lt;&lt; D22IP_MEI1IP)), RCBA_SET_REG_32(D20IP, (INTA &lt;&lt; D20IP_XHCI)),</code> </pre> <br>  Betrachten Sie zum besseren Verst√§ndnis einige Beispiele: <br><br>  <b>Beispiel 1:</b> <br><br>  Das Ger√§t 0x1d (29 in Dezimalzahl) hat eine Funktion (EHCI-Controller). <br><br>  Weisen Sie in diesem Fall INTA # einen Interrupt zu. <br><br>  00: 1d.0 - INTA # <br><br><pre> <code class="cpp hljs">RCBA_SET_REG_32(D29IP, (INTA &lt;&lt; D29IP_E1P)),</code> </pre> <br>  <b>Beispiel 2:</b> <br>  Das Ger√§t 0x1f (31 in Dezimalzahl) hat die Funktionen Thermosensor-Controller (00: 1f.6), SATA-Controller 2 (00: 1f.2), SMBus-Controller (00: 1f.3), SATA-Controller 1 (00: 1f) .2).  Wir m√∂chten nur den SMBus-Controller, den SATA-Controller 1 und den Thermosensor-Controller verwenden. <br><br>  00: 1f.2 - INTA # (SATA-Controller 1) <br>  00: 1f.3 - INTB # (SMBus-Controller) <br>  00: 1f.2 - Kein Interrupt (SATA-Controller 2 wird nicht verwendet) <br>  00: 1f.6 - INTC # (Thermosensorregler) <br><br>  F√ºr diese Konfiguration sollten Sie schreiben: <br><br><pre> <code class="cpp hljs">RCBA_SET_REG_32(D31IP, (INTC &lt;&lt; D31IP_TTIP) | (NOINT &lt;&lt; D31IP_SIP2) | (INTB &lt;&lt; D31IP_SMIP) | (INTA &lt;&lt; D31IP_SIP)),</code> </pre> <br>  <b>Beispiel 3:</b> <br><br>  In einem Ger√§t sind mehr als 4 Funktionen erforderlich. Im 0x1c-Ger√§t ist jede Funktion f√ºr den PCI Express-Port verantwortlich.  Damit die Ports 0-5 funktionieren und Interrupts gleichm√§√üig auf die Leitungen verteilt werden, k√∂nnen Sie Folgendes konfigurieren: <br><br>  00: 1c.0 - INTA # (PCI Express Port 0) <br>  00.1c.1 - INTB # (PCI Express Port 1) <br>  00.1c.2 - INTC # (PCI Express Port 2) <br>  00.1c.3 - INTD # (PCI Express Port 3) <br>  00.1c.4 - INTA # (PCI Express Port 4) <br>  00.1c.5 - INTB # (PCI Express Port 5) <br>  00.1c.6 - Kein Interrupt (Port nicht verwendet) <br>  00.1c.7 - Kein Interrupt (Port nicht verwendet) <br><br><pre> <code class="cpp hljs">RCBA_SET_REG_32(D28IP, (INTA &lt;&lt; D28IP_P1IP) | (INTB &lt;&lt; D28IP_P2IP) | (INTC &lt;&lt; D28IP_P3IP) | (INTD &lt;&lt; D28IP_P4IP) | (INTA &lt;&lt; D28IP_P5IP) | (INTB &lt;&lt; D28IP_P6IP) | (NOINT &lt;&lt; D28IP_P7IP) | (NOINT &lt;&lt; D28IP_P8IP)),</code> </pre> <br><h4>  2) Konfigurieren Sie die INTx # ‚Üí PIRQy-Zuordnung f√ºr jedes PCI-Ger√§t </h4><br>  Diese Informationen sind auch in der Datei <a href="">"src \ mainboard \ google \ bearino \ romstage.c" definiert.</a> <br>  in der Struktur rcba_config, jedoch bereits √ºber die Register DxxIR (Device xx Interrupt Route Register). <br><br>  Die Informationen in diesem Register zeigen, mit welcher PIRQx-Leitung (A / B / C / D / E / F / G / H) jede INTx # -Unterbrechungsleitung verbunden ist. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* Device interrupt route registers */</span></span> RCBA_SET_REG_32(D31IR, DIR_ROUTE(PIRQG, PIRQC, PIRQB, PIRQA)),<span class="hljs-comment"><span class="hljs-comment">/* LPC */</span></span> RCBA_SET_REG_32(D29IR, DIR_ROUTE(PIRQD, PIRQD, PIRQD, PIRQD)),<span class="hljs-comment"><span class="hljs-comment">/* EHCI */</span></span> RCBA_SET_REG_32(D28IR, DIR_ROUTE(PIRQA, PIRQB, PIRQC, PIRQD)),<span class="hljs-comment"><span class="hljs-comment">/* PCIE */</span></span> RCBA_SET_REG_32(D27IR, DIR_ROUTE(PIRQG, PIRQG, PIRQG, PIRQG)),<span class="hljs-comment"><span class="hljs-comment">/* HDA */</span></span> RCBA_SET_REG_32(D22IR, DIR_ROUTE(PIRQA, PIRQA, PIRQA, PIRQA)),<span class="hljs-comment"><span class="hljs-comment">/* ME */</span></span> RCBA_SET_REG_32(D21IR, DIR_ROUTE(PIRQE, PIRQF, PIRQF, PIRQF)),<span class="hljs-comment"><span class="hljs-comment">/* SIO */</span></span> RCBA_SET_REG_32(D20IR, DIR_ROUTE(PIRQC, PIRQC, PIRQC, PIRQC)),<span class="hljs-comment"><span class="hljs-comment">/* XHCI */</span></span> RCBA_SET_REG_32(D23IR, DIR_ROUTE(PIRQH, PIRQH, PIRQH, PIRQH)),<span class="hljs-comment"><span class="hljs-comment">/* SDIO */</span></span></code> </pre> <br>  <b>Beispiel 1:</b> <br><br>  Das 0x1c-Ger√§t (28 im Dezimalsystem) sind die PCIe-Ports, wie wir bereits herausgefunden haben. <br><br>  Wir stellen eine "direkte" Verbindung her: <br><br><ul><li>  INTA # ‚Üí PIRQA </li><li>  INTB # ‚Üí PIRQB </li><li>  INTC # ‚Üí PIRQC </li><li>  INTD # ‚Üí PIRQD </li></ul><br><pre> <code class="cpp hljs">RCBA_SET_REG_32(D28IR, DIR_ROUTE(PIRQA, PIRQB, PIRQC, PIRQD))</code> </pre> <br>  <b>Beispiel 2:</b> <br><br>  Ger√§t 0x1d (29 in Dezimalzahl) - Eine Funktion (EHCI-Controller) auf INTA #, andere Zeilen werden nicht verwendet. <br><br>  Verbinden Sie die INTA # -Leitung mit PIRQD: <br><br><pre> <code class="cpp hljs">RCBA_SET_REG_32(D29IR, DIR_ROUTE(PIRQD, PIRQD, PIRQD, PIRQD))</code> </pre> <br>  In diesem Fall ist nur der erste PIRQD-Datensatz (f√ºr INTA #) sinnvoll, der Rest macht keinen Sinn. <br><br><h4>  3a) F√ºllen Sie das Mapping PIRQy ‚Üí IRQz1 (PIR ‚Üí APIC) aus. </h4><br>  Wie bereits erw√§hnt, wird die Zuordnung hier h√§ufig behoben, und dieser Fall ist keine Ausnahme. <br><br><ul><li>  PIRQA ‚Üí IRQ16 </li><li>  PIRQB ‚Üí IRQ17 </li><li>  ... </li><li>  PIRQH ‚Üí IRQ23 </li></ul><br><h4>  3b) F√ºllen Sie das Mapping PIRQy ‚Üí IRQz2 (PIR ‚Üí PIC) aus. </h4><br>  In coreboot wird der Inhalt zum F√ºllen dieser Register in der Datei <a href="">devicetree.cb</a> im Motherboard-Ordner "src \ mainboard \ google \ bearino \" definiert. <br><br>  devicetree.cb (der Name devicetree f√ºr die Kommunikation mit einem √§hnlichen Konzept im Linux-Kernel und "cb" steht f√ºr coreboot) ist eine spezielle Datei, die die Konfiguration dieses Motherboards widerspiegelt: Welcher Prozessor, welcher Chipsatz werden verwendet, welche Ger√§te sind in welchen enthalten? aus usw.  Dar√ºber hinaus k√∂nnen in dieser Datei spezielle Informationen zur Konfiguration des Chipsatzes angegeben werden.  Dies ist genau der Fall, den wir brauchen: <br><br><pre> <code class="python hljs">register <span class="hljs-string"><span class="hljs-string">"pirqa_routing"</span></span> = <span class="hljs-string"><span class="hljs-string">"0x8b"</span></span> register <span class="hljs-string"><span class="hljs-string">"pirqb_routing"</span></span> = <span class="hljs-string"><span class="hljs-string">"0x8a"</span></span> register <span class="hljs-string"><span class="hljs-string">"pirqc_routing"</span></span> = <span class="hljs-string"><span class="hljs-string">"0x8b"</span></span> register <span class="hljs-string"><span class="hljs-string">"pirqd_routing"</span></span> = <span class="hljs-string"><span class="hljs-string">"0x8b"</span></span> register <span class="hljs-string"><span class="hljs-string">"pirqe_routing"</span></span> = <span class="hljs-string"><span class="hljs-string">"0x80"</span></span> register <span class="hljs-string"><span class="hljs-string">"pirqf_routing"</span></span> = <span class="hljs-string"><span class="hljs-string">"0x80"</span></span> register <span class="hljs-string"><span class="hljs-string">"pirqg_routing"</span></span> = <span class="hljs-string"><span class="hljs-string">"0x80"</span></span> register <span class="hljs-string"><span class="hljs-string">"pirqh_routing"</span></span> = <span class="hljs-string"><span class="hljs-string">"0x80"</span></span></code> </pre> <br>  Diese Zeilen geben die Zuordnung PIRQy ‚Üí IRQz2 an.  Im Code werden sie nach dem Parsen der Datei devicetree.cb in die Variablen "config-&gt; pirqX_routing" umgewandelt. <br><br>  Die Variable "config-&gt; pirqa_routing = 0x8b" bedeutet, dass die PIRQA mit der IRIC11-Interrupt-Leitung (0x0b = 11) des PIC-Controllers verbunden ist. Das h√∂here Bit (0x80) bedeutet jedoch, dass kein Interrupt-Routing durchgef√ºhrt wird.  Meiner Erfahrung nach ist dies ein Fehler. Standardm√§√üig lohnt es sich, das PIC-Routing zu aktivieren. Das Betriebssystem selbst kann zu E / A-APIC wechseln, indem dieses Bit bei Bedarf auf 1 gesetzt wird. <br><br>  Das hei√üt, in diesem Fall w√§re es korrekter zu schreiben: <br><br><pre> <code class="python hljs">register <span class="hljs-string"><span class="hljs-string">"pirqa_routing"</span></span> = <span class="hljs-string"><span class="hljs-string">"0x0b"</span></span> register <span class="hljs-string"><span class="hljs-string">"pirqb_routing"</span></span> = <span class="hljs-string"><span class="hljs-string">"0x0a"</span></span> register <span class="hljs-string"><span class="hljs-string">"pirqc_routing"</span></span> = <span class="hljs-string"><span class="hljs-string">"0x0b"</span></span> register <span class="hljs-string"><span class="hljs-string">"pirqd_routing"</span></span> = <span class="hljs-string"><span class="hljs-string">"0x0b"</span></span> register <span class="hljs-string"><span class="hljs-string">"pirqe_routing"</span></span> = <span class="hljs-string"><span class="hljs-string">"0x80"</span></span> <span class="hljs-comment"><span class="hljs-comment"># not used register "pirqf_routing" = "0x80" # not used register "pirqg_routing" = "0x80" # not used register "pirqh_routing" = "0x80" # not used</span></span></code> </pre><br>  Wir haben die letzten 4 Interrupts nicht aktiviert, weil  Der IRQ0-Interrupt wird immer unter dem System-Timer verwendet und ist eindeutig nicht verf√ºgbar (siehe <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Allgemeine Informationen zu IBM-PC-kompatiblen Interrupts</a> ). <br><br>  Wenn wir uns jedoch Punkt 2) genauer ansehen, werden wir feststellen, dass einige PCI-Ger√§te die PIRQE-PIRQH-Leitungen verwenden. Wenn Sie sie also nicht angeschlossen lassen, ist dies der richtige Weg, um Ger√§te zu besch√§digen. <br><br>  Es ist also besser, so etwas zu schreiben: <br><pre> <code class="python hljs">register <span class="hljs-string"><span class="hljs-string">"pirqa_routing"</span></span> = <span class="hljs-string"><span class="hljs-string">"0x03"</span></span> register <span class="hljs-string"><span class="hljs-string">"pirqb_routing"</span></span> = <span class="hljs-string"><span class="hljs-string">"0x04"</span></span> register <span class="hljs-string"><span class="hljs-string">"pirqc_routing"</span></span> = <span class="hljs-string"><span class="hljs-string">"0x05"</span></span> register <span class="hljs-string"><span class="hljs-string">"pirqd_routing"</span></span> = <span class="hljs-string"><span class="hljs-string">"0x06"</span></span> register <span class="hljs-string"><span class="hljs-string">"pirqe_routing"</span></span> = <span class="hljs-string"><span class="hljs-string">"0x0a"</span></span> register <span class="hljs-string"><span class="hljs-string">"pirqf_routing"</span></span> = <span class="hljs-string"><span class="hljs-string">"0x0b"</span></span> register <span class="hljs-string"><span class="hljs-string">"pirqg_routing"</span></span> = <span class="hljs-string"><span class="hljs-string">"0x0e"</span></span> register <span class="hljs-string"><span class="hljs-string">"pirqh_routing"</span></span> = <span class="hljs-string"><span class="hljs-string">"0x0f"</span></span></code> </pre> <br><br>  Das eigentliche F√ºllen der entsprechenden Register erfolgt in der Datei <a href="">src \ southbridge \ intel \ lynxpoint \ lpc.c</a> in der Funktion pch_pirq_init. <br><br>  Code-Snippet, das f√ºr das Ausf√ºllen des Registers verantwortlich ist: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* Get the chip configuration */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">config_t</span></span> *config = dev-&gt;chip_info; pci_write_config8(dev, PIRQA_ROUT, config-&gt;pirqa_routing); pci_write_config8(dev, PIRQB_ROUT, config-&gt;pirqb_routing); pci_write_config8(dev, PIRQC_ROUT, config-&gt;pirqc_routing); pci_write_config8(dev, PIRQD_ROUT, config-&gt;pirqd_routing); pci_write_config8(dev, PIRQE_ROUT, config-&gt;pirqe_routing); pci_write_config8(dev, PIRQF_ROUT, config-&gt;pirqf_routing); pci_write_config8(dev, PIRQG_ROUT, config-&gt;pirqg_routing); pci_write_config8(dev, PIRQH_ROUT, config-&gt;pirqh_routing);</code> </pre> <br>  Registeradresskonstanten werden in derselben <a href="">pch.h-</a> Datei beschrieben <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> PIRQA_ROUT 0x60 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> PIRQB_ROUT 0x61 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> PIRQC_ROUT 0x62 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> PIRQD_ROUT 0x63 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> PIRQE_ROUT 0x68 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> PIRQF_ROUT 0x69 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> PIRQG_ROUT 0x6A #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> PIRQH_ROUT 0x6B</span></span></code> </pre> <br>  Die Zuordnung von PIRQy ‚Üí IRQz2 f√ºr diesen Chipsatz wird in die PIRQy_ROUT-Register auf das LPC-PCI-Ger√§t (Adresse 00: 1f.0) geschrieben.  Es ist zu beachten, dass h√§ufig nicht alle 15 IRQz2-Leitungen pro PIC verwendet werden d√ºrfen, sondern nur ein Teil (z. B. 3,4,5,6,7,9,10,11,12,14,15).  Die Beschreibung dieser Register sollte Informationen dar√ºber enthalten, welche IRQs verf√ºgbar sind, um ihnen Interrupts von PIRQ-Leitungen zuzuweisen.  Das von uns oben vorgeschlagene Mapping ist also nur m√∂glich, wenn die Zuordnung von PIRQ auf der Leitung IRQ3, IRQ4, IRQ5, IRQ6, IRQ10, IRQ11, IRQ14, IRQ15 verf√ºgbar ist.  Wenn wir uns jedoch den Kommentar vor der Funktion pch_pirq_init genau ansehen, werden wir feststellen, dass es sich um Folgendes handelt: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* PIRQ[n]_ROUT[3:0] - PIRQ Routing Control * 0x00 - 0000 = Reserved * 0x01 - 0001 = Reserved * 0x02 - 0010 = Reserved * 0x03 - 0011 = IRQ3 * 0x04 - 0100 = IRQ4 * 0x05 - 0101 = IRQ5 * 0x06 - 0110 = IRQ6 * 0x07 - 0111 = IRQ7 * 0x08 - 1000 = Reserved * 0x09 - 1001 = IRQ9 * 0x0A - 1010 = IRQ10 * 0x0B - 1011 = IRQ11 * 0x0C - 1100 = IRQ12 * 0x0D - 1101 = Reserved * 0x0E - 1110 = IRQ14 * 0x0F - 1111 = IRQ15 * PIRQ[n]_ROUT[7] - PIRQ Routing Control * 0x80 - The PIRQ is not routed. */</span></span></code> </pre> <br><h4>  4) F√ºllen Sie die Interrupt Line / Interrupt Pin-Register f√ºr jede PCI-Funktion aus </h4><br>  Im PCI-Konfigurationsraum (jede PCI hat Funktionen gem√§√ü dem Standard) gibt es 2 Register, die f√ºr uns von Interesse sind: <br><br><ul><li>  3Ch: Interrupt Line - Hier m√ºssen Sie die IRQz2-Nummer (eine Nummer von 0 bis 15) schreiben, die Interrupt-Nummer, die die Funktion bei Verwendung des PIC-Controllers eventuell abruft </li><li>  3Dh: Interrupt Pin - Zeigt an, welche Zeile INTx # (A / B / C / D) die Funktion verwendet </li></ul><br>  Beginnen wir mit dem letzten.  Das Interrupt-Pin-Register wird basierend auf den von uns in Absatz 1 vorgenommenen Chipsatzeinstellungen (DxxIP-Registern) automatisch gef√ºllt und ist schreibgesch√ºtzt. <br><br>  Sie m√ºssen also nur noch das Interrupt Line-Register mit einem IRQz2-Interrupt f√ºr jede PCI-Funktion f√ºllen. <br><br>  Wenn Sie das Mapping PIRQy ‚Üí IRQz2 (Punkt 3b) und das Mapping INTx # ‚Üí PIRQy (Punkt 2) kennen, k√∂nnen Sie das Interrupt Line-Register f√ºr jede Funktion einfach ausf√ºllen und wissen, welchen INTx # Interrupt es verwendet (Punkt 1). <br><br>  In Coreboot werden die Interrupt Line-Register auch in der <a href="">Datei src \ southbridge \ intel \ lynxpoint \ lpc.c</a> in der Funktion pch_pirq_init gef√ºllt: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* Eric Biederman once said we should let the OS do this. * I am not so sure anymore he was right. */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (irq_dev = all_devices; irq_dev; irq_dev = irq_dev-&gt;next) { u8 int_pin=<span class="hljs-number"><span class="hljs-number">0</span></span>, int_line=<span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!irq_dev-&gt;enabled || irq_dev-&gt;path.type != DEVICE_PATH_PCI) <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; int_pin = pci_read_config8(irq_dev, PCI_INTERRUPT_PIN); <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (int_pin) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>: <span class="hljs-comment"><span class="hljs-comment">/* INTA# */</span></span> int_line = config-&gt;pirqa_routing; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>: <span class="hljs-comment"><span class="hljs-comment">/* INTB# */</span></span> int_line = config-&gt;pirqb_routing; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span>: <span class="hljs-comment"><span class="hljs-comment">/* INTC# */</span></span> int_line = config-&gt;pirqc_routing; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">4</span></span>: <span class="hljs-comment"><span class="hljs-comment">/* INTD# */</span></span> int_line = config-&gt;pirqd_routing; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!int_line) <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; pci_write_config8(irq_dev, PCI_INTERRUPT_LINE, int_line); }</code> </pre> <br>  Aus irgendeinem Grund impliziert dieser Code, dass die Zuordnung auf jeden Fall INTA # ‚Üí PIRQA, INTB # ‚Üí PIRQB, INTC # ‚Üí PIRQC, INTD # ‚Üí PIRQD ist.  Obwohl wir in der Praxis gesehen haben, dass es anders sein kann (siehe Absatz 2). <br><br>  Im Allgemeinen "Eric Biederman hat einmal gesagt", und wir haben es √ºberall kopiert: <br><br><pre> <code class="bash hljs">$ grep <span class="hljs-string"><span class="hljs-string">"Eric Biederman once said"</span></span> -r src/ src/southbridge/intel/fsp_bd82x6x/lpc.c: /* Eric Biederman once said we should <span class="hljs-built_in"><span class="hljs-built_in">let</span></span> the OS <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> this. src/southbridge/intel/i82801gx/lpc.c: /* Eric Biederman once said we should <span class="hljs-built_in"><span class="hljs-built_in">let</span></span> the OS <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> this. src/southbridge/intel/i82801ix/lpc.c: /* Eric Biederman once said we should <span class="hljs-built_in"><span class="hljs-built_in">let</span></span> the OS <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> this. src/southbridge/intel/lynxpoint/lpc.c: /* Eric Biederman once said we should <span class="hljs-built_in"><span class="hljs-built_in">let</span></span> the OS <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> this. src/southbridge/intel/sch/lpc.c: /* Eric Biederman once said we should <span class="hljs-built_in"><span class="hljs-built_in">let</span></span> the OS <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> this.</code> </pre> <br>  Im Allgemeinen k√ºmmert sich Coreboot nicht wirklich um die Unterst√ºtzung √§lterer Interrupts.  Sie sollten sich also nicht √ºber diesen Fehler wundern.  Wenn Sie ein modernes Betriebssystem laden, wird Sie dies nicht st√∂ren. Wenn Sie jedoch pl√∂tzlich Linux mit den Optionen "acpi = off nolapic" laden m√ºssen, ist dies kaum m√∂glich. <br><br><h2>  Fazit </h2><br>  Abschlie√üend wiederholen wir die typischen Informationen, die im Chipsatz f√ºr das Routing von PCI-Interrupts konfiguriert werden m√ºssen: <br><br><ol><li>  Geben Sie an, welche INTx # -Zeile jede PCI-Funktion zieht </li><li>  Konfigurieren Sie die INTx # ‚Üí PIRQy-Zuordnung f√ºr jedes PCI-Ger√§t </li><li>  F√ºllen Sie die Zuordnung PIRQy ‚Üí IRQz1 (PIR ‚Üí APIC) und die Zuordnung PIRQy ‚Üí IRQz2 (PIR ‚Üí PIC). </li><li>  F√ºllen Sie f√ºr jede PCI-Funktion die Register Interrupt Line / Interrupt Pin des PCI-Konfigurationsbereichs aus. </li></ol></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de440304/">https://habr.com/ru/post/de440304/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de440294/index.html">MIDI-Router auf Raspberry Pi</a></li>
<li><a href="../de440296/index.html">6 Anwendungen f√ºr das industrielle IoT</a></li>
<li><a href="../de440298/index.html">Valentinstag-Anwendung auf Libgdx</a></li>
<li><a href="../de440300/index.html">10 Konsolenbefehle zur Diskussion von JavaScript-Code wie bei einem PRO</a></li>
<li><a href="../de440302/index.html">CRM - Erfolgskosten, Fehlerkosten, Betriebskosten</a></li>
<li><a href="../de440306/index.html">Datenbankskalierung in hoch belasteten Systemen</a></li>
<li><a href="../de440308/index.html">Teilen und erobern oder langsam schreiben - schnell lesen</a></li>
<li><a href="../de440310/index.html">Wie man einer Maschine beibringt, Rechnungen zu verstehen und Daten daraus zu extrahieren</a></li>
<li><a href="../de440312/index.html">Hackquest 2018. Ergebnisse & Zuschreibungen. Tag 4-7</a></li>
<li><a href="../de440314/index.html">JDK 12 Release Candidate: Shenandoah, G1, JMH, Arm64. Bugs in Swing schlagen zur√ºck</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>