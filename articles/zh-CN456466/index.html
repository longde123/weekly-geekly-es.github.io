<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏼‍🌾 🦕 🥫 如今的PHP泛型（差不多） 🏇🏽 🧓🏿 👩🏻‍🤝‍👨🏼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="如果您问PHP开发人员他们想在PHP中看到什么样的机会，那么大多数人会称之为泛型。 


 语言级别的通用支持将是最好的解决方案。 但是，实现它们很困难 。 我们希望有一天本地支持将成为该语言的一部分，但可能要花几年的时间。 


 本文将展示如何使用现有工具，在某些情况下，只需进行很少的修改，就可...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>如今的PHP泛型（差不多）</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/456466/"><p> 如果您问PHP开发人员他们想在PHP中看到什么样的机会，那么大多数人会称之为泛型。 </p><br><p> 语言级别的通用支持将是最好的解决方案。 但是，实现它们很<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">困难</a> 。 我们希望有一天本地支持将成为该语言的一部分，但可能要花几年的时间。 </p><br><p> 本文将展示如何使用现有工具，在某些情况下，只需进行很少的修改，就可以立即获得PHP中泛型的强大功能。 </p><a name="habracut"></a><br><blockquote> 译者：我特意使用英文“泛型”中的描图纸，因为 我从未在通信中听到有人称它为“通用编程”。 </blockquote><br><h2 id="soderzhanie"> 内容： </h2><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">什么是泛型</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">如何在没有语言支持的情况下实现泛型</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">标准化</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">工具支援</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第三方代码支持</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">进一步的步骤</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">局限性</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">您为什么不只是在舌头上添加泛型？</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">如果我不需要泛型怎么办？</a> </li></ul><br><h2 id="anchorwhat-are-genericsanchorchto-takoe-dzheneriki"><a name="what-are-generics"></a> 什么是泛型 </h2><br><p> 本节将简要介绍<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">泛型</a> 。 </p><br><p> 阅读链接： </p><br><ul><li> 用于添加PHP泛型的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">RFC</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">潘的</a>通用支持 </li><li> 诗篇泛型和<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">模板</a> </li></ul><br><h3 id="prosteyshiy-primer"> 最简单的例子 </h3><br><p> 由于当前无法在语言级别定义泛型，因此我们将不得不利用另一个巨大的机会-在码头区中定义泛型。 </p><br><p> 我们已经在许多项目中使用此选项。 看一下这个例子： </p><br><pre><code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">/** * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@param</span></span></span><span class="hljs-comment"> string[] $names * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@return</span></span></span><span class="hljs-comment"> User[] */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createUsers</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(iterable $names)</span></span></span><span class="hljs-function">: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">array</span></span></span><span class="hljs-function"> </span></span>{ ... }</code> </pre> <br><p> 在上面的代码中，我们尽力在语言级别上做。 我们将<code>$names</code>参数定义为可以列出的内容。 我们还表明该函数将返回一个数组。 如果参数类型和返回值不匹配，PHP将抛出<code>TypeError</code> 。 </p><br><p>  Docblock增强了对代码的理解。  <code>$names</code>必须是字符串，并且该函数必须返回<code>User</code>对象的数组。  PHP本身不进行此类检查。 但是诸如PhpStorm之类的IDE会理解这种表示法，并警告开发人员未遵守附加合同。 除此之外，静态分析工具（例如Psalm，PHPStan和Phan）还可以验证与函数之间传输的数据的正确性。 </p><br><h3 id="dzheneriki-dlya-opredeleniya-klyuchey-i-znacheniy-perechislyaemyh-tipov"> 用于确定枚举类型的键和值的泛型 </h3><br><p> 上面是泛型的最简单示例。 更复杂的方法包括能够指定其键的类型以及值的类型。 下面是描述此问题的一种方法： </p><br><pre> <code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">/** * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@return</span></span></span><span class="hljs-comment"> array&lt;string, User&gt; */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getUsers</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">array</span></span></span><span class="hljs-function"> </span></span>{ ... }</code> </pre> <br><p> 这里说的是， <code>getUsers</code>返回的数组具有字符串键和类型<code>User</code>值。 </p><br><p> 静态分析器（例如Psalm，PHPStan和Phan）了解此注释，并在检查时将其考虑在内。 </p><br><p> 考虑以下代码： </p><br><pre> <code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">/** * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@return</span></span></span><span class="hljs-comment"> array&lt;string, User&gt; */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getUsers</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">array</span></span></span><span class="hljs-function"> </span></span>{ ... } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">showAge</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(int $age)</span></span></span><span class="hljs-function">: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">void</span></span></span><span class="hljs-function"> </span></span>{ ... } <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span>(getUsers() <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> $name =&gt; $user) { showAge($name); }</code> </pre> <br><p> 静态分析器将在<code>showAge</code>调用上引发警告，并显示错误，如下所示： <code>Argument 1 of showAge expects int, string provided</code> 。 </p><br><p> 不幸的是，在撰写本文时，PhpStorm不知道如何。 </p><br><h3 id="bolee-slozhnye-dzheneriki"> 更复杂的泛型 </h3><br><p> 我们将继续研究泛型主题。 考虑一个<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">栈</a>对象： </p><br><pre> <code class="php hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Stack</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">push</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($item)</span></span></span><span class="hljs-function">: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">void</span></span></span><span class="hljs-function"> </span></span>{ ... } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">pop</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ ... } }</code> </pre> <br><p> 堆栈可以接受任何类型的对象。 但是，如果我们想将堆栈限制为仅<code>User</code>类型的对象，该怎么办？ </p><br><p>  Psalm和Phan支持以下注释： </p><br><pre> <code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">/** * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@template</span></span></span><span class="hljs-comment"> T */</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Stack</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/** * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@param</span></span></span><span class="hljs-comment"> T $item */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">push</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($item)</span></span></span><span class="hljs-function">: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">void</span></span></span></span>; <span class="hljs-comment"><span class="hljs-comment">/** * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@return</span></span></span><span class="hljs-comment"> T */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">pop</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; }</code> </pre> <br><p>  docblock用于传达其他类型信息，例如： </p><br><pre> <code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">/** </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@var</span></span></span><span class="hljs-comment"> Stack&lt;User&gt; $userStack */</span></span> $stack = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Stack(); Means that $userStack must only contain Users.</code> </pre> <br><p> 诗篇，分析以下代码时： </p><br><pre> <code class="php hljs">$userStack-&gt;push(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> User()); $userStack-&gt;push(<span class="hljs-string"><span class="hljs-string">"hello"</span></span>);</code> </pre> <br><p> 将会抱怨第2行，并带有错误<code>Argument 1 of Stack::push expects User, string(hello) provided.</code> </p><br><p>  PhpStorm当前不支持此注释。 </p><br><p> 实际上，我们仅涵盖了有关泛型的部分信息，但目前就足够了。 </p><br><h2 id="anchorhow-to-implement-generics-without-language-level-supportanchorkak-vnedrit-dzheneriki-bez-podderzhki-yazyka"><a name="how-to-implement-generics-without-language-level-support"></a> 如何在没有语言支持的情况下实现泛型 </h2><br><p> 您必须完成以下步骤： </p><br><ul><li> 在社区级别，在扩展坞中定义通用标准（例如，新的PSR，或还原为PSR-5） </li><li> 在代码中添加Dockblock批注 </li><li> 使用了解这些约定的IDE进行实时静态分析，以发现不一致之处。 </li><li> 使用静态分析工具（例如Psalm）作为CI的步骤之一来捕获错误。 </li><li> 定义一种将类型信息传递给第三方库的方法。 </li></ul><br><h2 id="anchoragreeing-on-a-standardanchorstandartizaciya"><a name="agreeing-on-a-standard"></a> 标准化 </h2><br><p> 目前，PHP社区已经非正式地采用了这种通用格式（大多数工具都支持它们，并且大多数人都清楚它们的含义）： </p><br><pre> <code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">/** * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@return</span></span></span><span class="hljs-comment"> User[] */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getUsers</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">array</span></span></span><span class="hljs-function"> </span></span>{ ... }</code> </pre> <br><p> 但是，对于这样的简单示例，我们会遇到问题： </p><br><pre> <code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">/** * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@return</span></span></span><span class="hljs-comment"> array&lt;string, User&gt; */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getUsers</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">array</span></span></span><span class="hljs-function"> </span></span>{ ... }</code> </pre> <br><p>  Psalm理解它，并且知道键具有什么类型以及返回的数组的值。 </p><br><p> 在撰写本文时，PhpStorm还不了解这一点。 使用此条目，我想念PhpStorm提供的实时静态分析的功能。 </p><br><p> 考虑下面的代码。  PhpStorm无法理解<code>$user</code>是<code>User</code>类型，而<code>$name</code>是字符串类型： </p><br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span>(getUsers() <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> $name =&gt; $user) { ... }</code> </pre> <br><p> 如果我选择Psalm作为静态分析工具，则可以编写以下代码： </p><br><pre> <code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">/** * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@return</span></span></span><span class="hljs-comment"> User[] * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@psalm</span></span></span><span class="hljs-comment">-return array&lt;string, User&gt; */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getUsers</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">array</span></span></span><span class="hljs-function"> </span></span>{ ... }</code> </pre> <br><p> 诗篇理解所有这些。 </p><br><p>  PhpStorm知道<code>$user</code>变量的类型为<code>User</code> 。 但是，他仍然不明白数组键是指字符串。  Phan和PHPStan不了解特定的诗篇注解。 他们在此代码中了解的最大值与PhpStorm中的相同： <code>$user</code>的类型 </p><br><p> 您可能会争辩说PhpStorm应该只接受协议<code>array&lt;keyType, valueType&gt;</code> 。 我不同意你的看法，因为 我认为，对标准的要求是语言和社区的任务，并且仅应遵循这些工具。 </p><br><p> 我认为上述描述的协议将被大多数PHP社区欢迎。 一个对泛型感兴趣的人。 但是，关于模式，事情变得更加复杂。  PHPStan和PhpStorm当前均不支持模板。 不同于诗篇和藩。 它们的目的是相似的，但是如果您深入研究，您将意识到实现略有不同。 </p><br><p> 提出的每个选项都是一种折衷。 </p><br><p> 简而言之，需要就通用记录格式达成协议： </p><br><ul><li> 它们改善了开发人员的生活。 开发人员可以在其代码中添加泛型并从中受益。 </li><li> 开发人员可以使用他们最喜欢的工具，并在必要时在它们之间进行切换。 </li><li> 工具制造商可以创建这些工具，从而了解对社区的好处，而不必担心某些事情会发生变化或被指责为“错误的做法”。 </li></ul><br><h2 id="anchortool-supportanchorpodderzhka-instrumentami"><a name="tool-support"></a> 工具支援 </h2><br><p>  Psalm具有检查泛型的所有必要功能。 潘也一样。 </p><br><p> 我敢肯定，一旦社区达成单一格式协议，PhpStorm就会引入泛型。 </p><br><h2 id="anchorthird-party-code-supportanchorpodderzhka-storonnego-koda"><a name="third-party-code-support"></a> 第三方代码支持 </h2><br><p> 通用难题的最后一部分是添加对第三方库的支持。 </p><br><p> 希望当通用定义标准出现时，大多数库都将实现它。 但是，这不会立即发生。 使用了某些库，但没有有效的支持。 使用静态分析器验证泛型中的类型时，重要的是定义这些泛型接受或返回的所有函数。 </p><br><p> 如果您的项目依赖于没有通用支持的第三方库，会发生什么？ </p><br><p> 幸运的是，这个问题已经解决了，而存根函数就是解决方案。  Psalm， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">Phan</a>和<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">PhpStorm</a>支持存根。 </p><br><p> 存根是包含功能和方法签名，但不实现它们的普通文件。 通过将桩块添加到存根，静态分析工具可以获得所需的其他信息。 例如，如果您有一个没有类型提示和泛型的堆栈类。 </p><br><pre> <code class="php hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Stack</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">push</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($item)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/* some implementation */</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">pop</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/* some implementation */</span></span> } }</code> </pre> <br><p> 您可以创建一个存根文件，该存根文件具有相同的方法，但是增加了停靠块并且没有实现功能。 </p><br><pre> <code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">/** * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@template</span></span></span><span class="hljs-comment"> T */</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Stack</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/** * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@param</span></span></span><span class="hljs-comment"> T $item * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@return</span></span></span><span class="hljs-comment"> void */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">push</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($item)</span></span></span></span>; <span class="hljs-comment"><span class="hljs-comment">/** * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@return</span></span></span><span class="hljs-comment"> T */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">pop</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; }</code> </pre> <br><p> 当静态分析器看到堆栈类时，它从存根而不是实际代码中获取类型信息。 </p><br><p> 仅共享存根代码（例如，通过作曲家）的功能将非常有用，因为 将允许分享完成的工作。 </p><br><h2 id="anchornext-stepsanchordalneyshie-shagi"><a name="next-steps"></a> 进一步的步骤 </h2><br><p> 社区需要远离协议和制定标准。 </p><br><p> 也许最好的选择是通用的PSR？ </p><br><p> 也许主要的静态分析器，PhpStorm，其他IDE的创建者以及任何参与PHP开发（用于控制）的人员都可以开发出每个人都可以使用的标准。 </p><br><p> 标准出现后，每个人都将能够帮助将泛型添加到现有库和项目中，从而创建请求请求。 并且在不可能的地方，开发人员可以编写和共享存根。 </p><br><p> 完成所有操作后，我们可以在编写代码时使用PhpStorm等工具实时检查泛型。 我们可以使用静态分析工具作为CI的一部分，以确保安全。 </p><br><p> 泛型也可以用PHP实现（好吧，差不多）。 </p><br><h2 id="anchorlimitationsanchorogranicheniya"><a name="limitations"></a> 局限性 </h2><br><p> 有很多限制。  PHP是一种动态语言，允许您执行许多“神奇”的事情，例如<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">这些</a> 。 如果使用过多的PHP魔术，则可能会发生静态分析器无法准确提取系统中所有类型的情况。 如果未知任何类型，则这些工具将无法在所有情况下正确使用泛型。 </p><br><p> 但是，此分析的主要应用是验证您的业务逻辑。 如果编写干净的代码，则不应使用过多的魔术。 </p><br><h2 id="anchorwhy-dont-you-just-add-generics-to-the-languageanchorpochemu-by-vam-prosto-ne-dobavit-dzheneriki-v-yazyk"><a name="why-dont-you-just-add-generics-to-the-language"></a> 您为什么不只是在舌头上添加泛型？ </h2><br><p> 那将是最好的选择。  PHP具有开源代码，没有人会打扰您克隆源代码并实现泛型！ </p><br><h2 id="anchorwhat-if-i-dont-want-genericsanchorchto-esli-mne-ne-nuzhny-dzheneriki"><a name="what-if-i-dont-want-generics"></a> 如果我不需要泛型怎么办？ </h2><br><p> 只需忽略以上所有内容。  PHP的主要优点之一是，它可以根据您创建的内容灵活地选择适当级别的实现复杂性。 使用一次性代码，您无需考虑诸如键入提示之类的事情。 但是在大型项目中，值得利用这样的机会。 </p><br><blockquote> 感谢所有阅读这个地方的人。 我将很高兴您在下午的评论。 <br><br>  <strong>UPD</strong> ： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" class="user_link">注释</a>中的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" class="user_link">ghost404</a>指出<em>版本0.12.x的PHPStan理解psalm注释并支持泛型</em> </blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN456466/">https://habr.com/ru/post/zh-CN456466/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN456446/index.html">Ceph-从“膝盖”到“生产”</a></li>
<li><a href="../zh-CN456448/index.html">选择JS框架的规则</a></li>
<li><a href="../zh-CN456450/index.html">DO-RA.Avia用于监控航空宇宙辐射</a></li>
<li><a href="../zh-CN456452/index.html">Ranges之前和之后的C ++代码示例</a></li>
<li><a href="../zh-CN456462/index.html">将角度组件库组装为Web组件</a></li>
<li><a href="../zh-CN456470/index.html">WSUS Package Publisher的陷阱</a></li>
<li><a href="../zh-CN456472/index.html">介绍Go和Mggo框架</a></li>
<li><a href="../zh-CN456474/index.html">井字游戏第0部分：比较苗条和反应</a></li>
<li><a href="../zh-CN456476/index.html">修改了蓝牙堆栈，以改善没有AAC，aptX或LDAC编解码器的耳机上的音频质量</a></li>
<li><a href="../zh-CN456486/index.html">界面与选择（2014）</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>