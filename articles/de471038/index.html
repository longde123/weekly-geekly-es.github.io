<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👊🏿 💴 🦎 Linux-Deskriptordatei mit Beispielen 👩🏾‍🤝‍👨🏿 📙 🤸🏾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Einmal haben sie mich in einem Interview gefragt, was Sie tun sollen, wenn Sie einen Dienst finden, der nicht funktioniert, weil auf der Festplatte ni...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Linux-Deskriptordatei mit Beispielen</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/471038/"> Einmal haben sie mich in einem Interview gefragt, was Sie tun sollen, wenn Sie einen Dienst finden, der nicht funktioniert, weil auf der Festplatte nicht genügend Speicherplatz vorhanden ist. <br><br>  Natürlich antwortete ich, dass ich sehen würde, was dieser Ort besetzt ist, und wenn möglich, würde ich den Ort reinigen. <br>  Dann fragte der Interviewer, was ist, wenn in der Sektion kein freier Speicherplatz vorhanden ist, Sie aber auch nicht die Dateien sehen, die den gesamten Platz einnehmen würden? <br><br>  Dazu habe ich gesagt, dass Sie immer offene Dateideskriptoren anzeigen können, beispielsweise mit dem Befehl lsof, und verstehen können, welche Anwendung den gesamten verfügbaren Speicherplatz belegt hat, und dann je nach den Umständen fortfahren können, je nachdem, ob die Daten benötigt werden. <br><br>  Der Interviewer unterbrach mich beim letzten Wort und fügte meine Frage hinzu: "Angenommen, wir benötigen die Daten nicht, es ist nur ein Debug-Protokoll, aber die Anwendung funktioniert nicht, weil sie kein Debug aufzeichnen kann." <br><br>  "Okay", antwortete ich, "wir können das Debuggen in der Konfiguration der Anwendung deaktivieren und neu starten." <br>  Der Interviewer beanstandete: „Nein, wir können die Anwendung nicht neu starten, wichtige Daten werden noch in unserem Speicher gespeichert und wichtige Clients sind mit dem Dienst selbst verbunden, den wir nicht erzwingen können, um die Verbindung wiederherzustellen.“ <br><br>  "Nun", sagte ich, "wenn wir die Anwendung nicht neu starten können und die Daten für uns nicht wichtig sind, können wir diese geöffnete Datei einfach über den Dateideskriptor löschen, auch wenn wir sie im Befehl ls im Dateisystem nicht sehen." <br><br>  Der Interviewer war zufrieden, ich aber nicht. <br><br>  Dann dachte ich, warum gräbt die Person, die mein Wissen testet, nicht tiefer?  Was aber, wenn die Daten noch wichtig sind?  Was ist, wenn wir den Prozess nicht neu starten können und dieser Prozess gleichzeitig in einem Abschnitt, in dem kein freier Speicherplatz vorhanden ist, in das Dateisystem schreibt?  Was ist, wenn wir nicht nur nicht bereits aufgezeichnete Daten verlieren können, sondern auch die Daten, die dieser Prozess schreibt oder aufzuzeichnen versucht? <br><a name="habracut"></a><br><h3>  Tuzik </h3><br>  Zu Beginn meiner Karriere habe ich versucht, eine kleine Anwendung zu erstellen, in der Informationen über Benutzer gespeichert werden mussten.  Und dann dachte ich, wie kann ich den Benutzer seinen Daten zuordnen.  Zum Beispiel habe ich Ivan Ivanov Ivanich, und er hat einige Daten, aber wie kann man sich mit ihnen anfreunden?  Ich kann direkt darauf hinweisen, dass der Hund namens "Tuzik" genau diesem Ivan gehört.  Aber was ist, wenn er seinen Namen ändert und anstelle von Ivan zum Beispiel Olya wird?  Dann stellt sich heraus, dass unsere Olya Ivanovna Ivanova keinen Hund mehr haben wird und unser Tuzik immer noch dem nicht existierenden Ivan gehören wird.  Diese Datenbank wurde durch eine Datenbank unterstützt, die jedem Benutzer eine eindeutige Kennung (ID) gab, und mein Tuzik wurde an diese ID angehängt, die eigentlich nur eine Ordnungszahl war.  Somit hatte der Besitzer des Tuzik die ID-Nummer 2, und irgendwann befand sich Ivan unter dieser ID, und dann wurde Olya dieselbe ID.  Das Problem der Menschlichkeit und Tierhaltung ist praktisch gelöst. <br><br><h3>  Dateideskriptor </h3><br>  Das Problem der Datei und des Programms, die mit dieser Datei arbeiten, ist ungefähr das gleiche wie das unseres Hundes und unserer Person.  Angenommen, ich habe eine Datei unter dem Namen ivan.txt geöffnet und mit dem Schreiben des Wortes tuzik begonnen, aber es ist mir gelungen, nur den ersten Buchstaben „t“ in die Datei zu schreiben, und diese Datei wurde von jemandem umbenannt, z. B. olya.txt.  Aber die Datei ist dieselbe geblieben, und ich möchte immer noch mein Ass darin schreiben.  Jedes Mal, wenn ich eine Datei mit dem offenen Systemaufruf in einer beliebigen Programmiersprache öffne, erhalte ich eine eindeutige ID, die mich auf eine Datei verweist. Diese ID ist ein Dateideskriptor.  Und es spielt keine Rolle, was jemand als Nächstes mit dieser Datei macht, er kann sie löschen, umbenennen, den Eigentümer ändern oder Lese- und Schreibberechtigungen wegnehmen. Ich habe weiterhin Zugriff darauf, da zum Zeitpunkt des Öffnens der Datei Ich hatte das Recht, es zu lesen und / oder zu schreiben, und es gelang mir, mit ihm zusammenzuarbeiten, was bedeutet, dass ich dies weiterhin tun muss. <br><br>  Unter Linux wird die libc-Bibliothek für jede laufende Anwendungs- (Prozess-) 3-Deskriptordatei mit den Nummern 0,1,2 geöffnet.  Weitere Informationen finden Sie unter den Links <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">man stdio</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">man stdout</a> <br><br><ul><li>  Der Dateideskriptor 0 heißt STDIN und ist der Dateneingabe aus der Anwendung zugeordnet </li><li>  Der Dateideskriptor 1 heißt STDOUT und wird von Anwendungen verwendet, um Daten auszugeben, beispielsweise Druckbefehle </li><li>  Der Dateideskriptor 2 heißt STDERR und wird von Anwendungen zur Ausgabe von Fehlerberichtsdaten verwendet. </li></ul><br>  Wenn Sie in Ihrem Programm eine Datei zum Lesen oder Schreiben öffnen, erhalten Sie höchstwahrscheinlich die erste freie ID und dies ist Nummer 3. <br><br>  Eine Liste von Deskriptordateien kann von jedem Prozess aus angezeigt werden, wenn Sie die PID kennen. <br><br>  Öffnen Sie beispielsweise eine Konsole mit Bash und sehen Sie die PID unseres Prozesses <br><br><pre><code class="bash hljs">[user@localhost ]$ <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> $$ 15771</code> </pre> <br>  Führen Sie in der zweiten Konsole aus <br><br><pre> <code class="bash hljs">[user@localhost ]$ ls -lah /proc/15771/fd/ total 0 dr-x------ 2 user user 0 Oct 7 15:42 . dr-xr-xr-x 9 user user 0 Oct 7 15:42 .. lrwx------ 1 user user 64 Oct 7 15:42 0 -&gt; /dev/pts/21 lrwx------ 1 user user 64 Oct 7 15:42 1 -&gt; /dev/pts/21 lrwx------ 1 user user 64 Oct 7 15:42 2 -&gt; /dev/pts/21 lrwx------ 1 user user 64 Oct 7 15:42 255 -&gt; /dev/pts/21</code> </pre><br>  Sie können den Dateideskriptor Nr. 255 im Rahmen dieses Artikels ignorieren. Er wurde von bash selbst und nicht von einer verknüpften Bibliothek für Ihre Anforderungen geöffnet. <br><br>  Jetzt sind alle 3 Deskriptordateien dem Pseudo-Endgerät <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">/ dev / pts zugeordnet</a> , aber wir können sie weiterhin bearbeiten, z. B. in der zweiten Konsole ausführen <br><br><pre> <code class="bash hljs">[user@localhost ]$ <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">"hello world"</span></span> &gt; /proc/15771/fd/0</code> </pre><br>  Und in der ersten Konsole werden wir sehen <br><br><pre> <code class="bash hljs">[user@localhost ]$ hello world</code> </pre><br><h3>  Weiterleiten und leiten </h3><br>  Sie können diese 3 Deskriptordateien in jedem Prozess leicht überschreiben, auch in Bash, z. B. über eine Pipe, die zwei Prozesse verbindet <br><br><pre> <code class="bash hljs">[user@localhost ]$ cat /dev/zero | sleep 10000</code> </pre><br>  Sie können diesen Befehl selbst mit <i>strace -f ausführen</i> und sehen, was im Inneren passiert, aber ich werde es Ihnen kurz sagen. <br><br>  Unsere übergeordnete Prozess-Bash mit PID 15771 analysiert unseren Befehl und versteht genau, wie viele Befehle wir ausführen möchten. In unserem Fall gibt es zwei davon: Katze und Schlaf.  Bash weiß, dass er zwei untergeordnete Prozesse erstellen und mit einer Pipe kombinieren muss.  Total Bash benötigt 2 untergeordnete Prozesse und eine Pipe. <br><br>  Vor dem Erstellen untergeordneter Prozesse startet bash den <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Pipe</a> -Systemaufruf und empfängt neue Dateideskriptoren für den temporären Pipe-Puffer. Dieser Puffer bindet unsere beiden untergeordneten Prozesse jedoch noch nicht. <br><br>  Für den übergeordneten Prozess scheint die Pipe bereits vorhanden zu sein, und es gibt noch keine untergeordneten Prozesse: <br><br><pre> <code class="bash hljs">PID <span class="hljs-built_in"><span class="hljs-built_in">command</span></span> 15771 bash lrwx------ 1 user user 64 Oct 7 15:42 0 -&gt; /dev/pts/21 lrwx------ 1 user user 64 Oct 7 15:42 1 -&gt; /dev/pts/21 lrwx------ 1 user user 64 Oct 7 15:42 2 -&gt; /dev/pts/21 lrwx------ 1 user user 64 Oct 7 15:42 3 -&gt; pipe:[253543032] lrwx------ 1 user user 64 Oct 7 15:42 4 -&gt; pipe:[253543032] lrwx------ 1 user user 64 Oct 7 15:42 255 -&gt; /dev/pts/21</code> </pre><br>  Dann erstellt <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Clone</a> Bash mithilfe eines Systemaufrufs zwei untergeordnete Prozesse, und unsere drei Prozesse sehen folgendermaßen aus: <br><br><pre> <code class="bash hljs">PID <span class="hljs-built_in"><span class="hljs-built_in">command</span></span> 15771 bash lrwx------ 1 user user 64 Oct 7 15:42 0 -&gt; /dev/pts/21 lrwx------ 1 user user 64 Oct 7 15:42 1 -&gt; /dev/pts/21 lrwx------ 1 user user 64 Oct 7 15:42 2 -&gt; /dev/pts/21 lrwx------ 1 user user 64 Oct 7 15:42 3 -&gt; pipe:[253543032] lrwx------ 1 user user 64 Oct 7 15:42 4 -&gt; pipe:[253543032] lrwx------ 1 user user 64 Oct 7 15:42 255 -&gt; /dev/pts/21 PID <span class="hljs-built_in"><span class="hljs-built_in">command</span></span> 9004 bash lrwx------ 1 user user 64 Oct 7 15:57 0 -&gt; /dev/pts/21 lrwx------ 1 user user 64 Oct 7 15:57 1 -&gt; /dev/pts/21 lrwx------ 1 user user 64 Oct 7 15:57 2 -&gt; /dev/pts/21 lrwx------ 1 user user 64 Oct 7 15:57 3 -&gt; pipe:[253543032] lrwx------ 1 user user 64 Oct 7 15:57 4 -&gt; pipe:[253543032] lrwx------ 1 user user 64 Oct 7 15:57 255 -&gt; /dev/pts/21 PID <span class="hljs-built_in"><span class="hljs-built_in">command</span></span> 9005 bash lrwx------ 1 user user 64 Oct 7 15:57 0 -&gt; /dev/pts/21 lrwx------ 1 user user 64 Oct 7 15:57 1 -&gt; /dev/pts/21 lrwx------ 1 user user 64 Oct 7 15:57 2 -&gt; /dev/pts/21 lrwx------ 1 user user 64 Oct 7 15:57 3 -&gt; pipe:[253543032] lrwx------ 1 user user 64 Oct 7 15:57 4 -&gt; pipe:[253543032] lrwx------ 1 user user 64 Oct 7 15:57 255 -&gt; /dev/pts/21</code> </pre><br>  Vergessen Sie nicht, dass der Klon den Prozess zusammen mit allen Dateideskriptoren klont, damit sie im übergeordneten und im untergeordneten Prozess gleich sind.  Die Aufgabe des übergeordneten Prozesses mit PID 15771 besteht darin, die untergeordneten Prozesse zu überwachen, sodass nur auf eine Antwort der untergeordneten Prozesse gewartet wird. <br><br>  Daher benötigt er keine Pipe und schließt die Dateideskriptoren mit den Nummern 3 und 4. <br><br>  Im ersten <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">untergeordneten</a> Bash-Prozess mit PID 9004, dem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Systemaufruf dup2</a> , wird unser STDOUT-Dateideskriptor mit der Nummer 1 in einen Dateideskriptor geändert, der auf die Pipe zeigt. In unserem Fall ist es die Nummer 3. Somit wird alles, was der erste untergeordnete Prozess mit der PID 9004 in STDOUT schreibt fällt automatisch in den Rohrpuffer. <br><br>  Im zweiten untergeordneten Prozess mit PID 9005 ändert bash den Deskriptor STDIN mit der Nummer 0 unter Verwendung von dup2. Jetzt liest alles, was unser zweiter bash mit PID 9005 liest, aus der Pipe. <br><br>  Danach werden die Deskriptoren mit den Nummern 3 und 4 auch in untergeordneten Prozessen geschlossen, da sie nicht mehr verwendet werden. <br><br>  Ich ignoriere absichtlich den Dateideskriptor 255, er verwendet Bash für interne Anforderungen und wird auch in untergeordneten Prozessen geschlossen. <br><br>  Außerdem startet bash im ersten untergeordneten Prozess mit PID 9004 die ausführbare Datei, die wir in der Befehlszeile mit dem Systemaufruf <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">exec angegeben haben</a> , in unserem Fall / usr / bin / cat. <br><br>  Im zweiten untergeordneten Prozess mit PID 9005 startet bash die zweite ausführbare Datei, die wir angegeben haben, in unserem Fall / usr / bin / sleep. <br><br>  Der Systemaufruf exec schließt keine Dateideskriptoren, wenn sie während des Aufrufs nicht mit dem Flag O_CLOEXEC geöffnet wurden.  In unserem Fall werden nach dem Ausführen der ausführbaren Dateien alle aktuellen Dateideskriptoren gespeichert. <br><br>  Überprüfen Sie in der Konsole: <br><br><pre> <code class="bash hljs">[user@localhost ]$ pgrep -P 15771 9004 9005 [user@localhost ]$ ls -lah /proc/15771/fd/ total 0 dr-x------ 2 user user 0 Oct 7 15:42 . dr-xr-xr-x 9 user user 0 Oct 7 15:42 .. lrwx------ 1 user user 64 Oct 7 15:42 0 -&gt; /dev/pts/21 lrwx------ 1 user user 64 Oct 7 15:42 1 -&gt; /dev/pts/21 lrwx------ 1 user user 64 Oct 7 15:42 2 -&gt; /dev/pts/21 lrwx------ 1 user user 64 Oct 7 15:42 255 -&gt; /dev/pts/21 [user@localhost ]$ ls -lah /proc/9004/fd total 0 dr-x------ 2 user user 0 Oct 7 15:57 . dr-xr-xr-x 9 user user 0 Oct 7 15:57 .. lrwx------ 1 user user 64 Oct 7 15:57 0 -&gt; /dev/pts/21 l-wx------ 1 user user 64 Oct 7 15:57 1 -&gt; pipe:[253543032] lrwx------ 1 user user 64 Oct 7 15:57 2 -&gt; /dev/pts/21 lr-x------ 1 user user 64 Oct 7 15:57 3 -&gt; /dev/zero [user@localhost ]$ ls -lah /proc/9005/fd total 0 dr-x------ 2 user user 0 Oct 7 15:57 . dr-xr-xr-x 9 user user 0 Oct 7 15:57 .. lr-x------ 1 user user 64 Oct 7 15:57 0 -&gt; pipe:[253543032] lrwx------ 1 user user 64 Oct 7 15:57 1 -&gt; /dev/pts/21 lrwx------ 1 user user 64 Oct 7 15:57 2 -&gt; /dev/pts/21 [user@localhost ]$ ps -up 9004 USER PID %CPU %MEM VSZ RSS TTY STAT START TIME COMMAND user 9004 0.0 0.0 107972 620 pts/21 S+ 15:57 0:00 cat /dev/zero [user@localhost ]$ ps -up 9005 USER PID %CPU %MEM VSZ RSS TTY STAT START TIME COMMAND user 9005 0.0 0.0 107952 360 pts/21 S+ 15:57 0:00 sleep 10000</code> </pre><br>  Wie Sie sehen können, ist die eindeutige Anzahl unserer Rohre in beiden Prozessen gleich.  Wir haben also eine Verbindung zwischen zwei verschiedenen Prozessen mit einem Elternteil. <br><br>  Für diejenigen, die mit den von bash verwendeten Systemaufrufen nicht vertraut sind, empfehle ich dringend, die Befehle über strace auszuführen und zu sehen, was im Inneren beispielsweise so passiert: <br><br><pre> <code class="bash hljs">strace -s 1024 -f bash -c <span class="hljs-string"><span class="hljs-string">"ls | grep hello"</span></span></code> </pre><br>  Kehren wir zu unserem Problem zurück, bei dem der Speicherplatz knapp wird und versucht wird, Daten zu speichern, ohne den Prozess neu zu starten.  Schreiben wir ein kleines Programm, das ungefähr 1 Megabyte pro Sekunde auf die Festplatte schreibt.  Wenn wir aus irgendeinem Grund keine Daten auf die Festplatte schreiben konnten, ignorieren wir sie einfach und versuchen nach einer Sekunde erneut, Daten zu schreiben.  In dem Beispiel, in dem ich Python verwende, können Sie jede andere Programmiersprache verwenden. <br><br><pre> <code class="python hljs">[user@localhost ]$ cat openforwrite.py <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> datetime <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> time mystr=<span class="hljs-string"><span class="hljs-string">"a"</span></span>*<span class="hljs-number"><span class="hljs-number">1024</span></span>*<span class="hljs-number"><span class="hljs-number">1024</span></span>+<span class="hljs-string"><span class="hljs-string">"\n"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> open(<span class="hljs-string"><span class="hljs-string">"123.txt"</span></span>, <span class="hljs-string"><span class="hljs-string">"w"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> f: <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">try</span></span>: f.write(str(datetime.datetime.now())) f.write(mystr) f.flush() time.sleep(<span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">except</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">pass</span></span></code> </pre><br>  Führen Sie das Programm aus und sehen Sie sich die Dateideskriptoren an <br><br><pre> <code class="bash hljs">[user@localhost ]$ python openforwrite.py &amp; [1] 3762 [user@localhost ]$ ps axuf | grep [o]penforwrite user 3762 0.0 0.0 128600 5744 pts/22 S+ 16:28 0:00 | \_ python openforwrite.py [user@localhost ]$ ls -la /proc/3762/fd total 0 dr-x------ 2 user user 0 Oct 7 16:29 . dr-xr-xr-x 9 user user 0 Oct 7 16:29 .. lrwx------ 1 user user 64 Oct 7 16:29 0 -&gt; /dev/pts/22 lrwx------ 1 user user 64 Oct 7 16:29 1 -&gt; /dev/pts/22 lrwx------ 1 user user 64 Oct 7 16:29 2 -&gt; /dev/pts/22 l-wx------ 1 user user 64 Oct 7 16:29 3 -&gt; /home/user/123.txt</code> </pre><br>  Wie Sie sehen können, haben wir unsere 3 Standard-Dateideskriptoren und einen weiteren, den wir geöffnet haben.  Überprüfen Sie die Dateigröße: <br><br><pre> <code class="bash hljs">[user@localhost ]$ ls -lah 123.txt -rw-rw-r-- 1 user user 117M Oct 7 16:30 123.txt</code> </pre><br>  Daten werden geschrieben. Versuchen Sie, die Dateiberechtigungen zu ändern: <br><br><pre> <code class="bash hljs">[user@localhost ]$ sudo chown root: 123.txt [user@localhost ]$ ls -lah 123.txt -rw-rw-r-- 1 root root 168M Oct 7 16:31 123.txt [user@localhost ]$ ls -lah 123.txt -rw-rw-r-- 1 root root 172M Oct 7 16:31 123.txt</code> </pre><br>  Wir sehen, dass die Daten noch geschrieben werden, obwohl unser Benutzer nicht das Recht hat, in die Datei zu schreiben.  Versuchen wir es zu entfernen: <br><br><pre> <code class="bash hljs">[user@localhost ]$ sudo rm 123.txt [user@localhost ]$ ls 123.txt ls: cannot access 123.txt: No such file or directory</code> </pre><br>  Wo sind die Daten geschrieben?  Und sind sie überhaupt geschrieben?  Wir prüfen: <br><br><pre> <code class="bash hljs">[user@localhost ]$ ls -la /proc/3762/fd total 0 dr-x------ 2 user user 0 Oct 7 16:29 . dr-xr-xr-x 9 user user 0 Oct 7 16:29 .. lrwx------ 1 user user 64 Oct 7 16:29 0 -&gt; /dev/pts/22 lrwx------ 1 user user 64 Oct 7 16:29 1 -&gt; /dev/pts/22 lrwx------ 1 user user 64 Oct 7 16:29 2 -&gt; /dev/pts/22 l-wx------ 1 user user 64 Oct 7 16:29 3 -&gt; /home/user/123.txt (deleted)</code> </pre><br>  Ja, unsere Deskriptordatei ist noch vorhanden, und wir können mit dieser Deskriptordatei wie mit unserer alten Datei arbeiten, sie lesen, bereinigen und kopieren. <br><br>  Wir betrachten die Dateigröße: <br><br><pre> <code class="bash hljs">[user@localhost ]$ lsof | grep 123.txt python 31083 user 3w REG 8,5 19923457 2621522 /home/user/123.txt</code> </pre><br>  Dateigröße 19923457. Versuch, die Datei zu löschen: <br><br><pre> <code class="bash hljs">[user@localhost ]$ truncate -s 0 /proc/31083/fd/3 [user@localhost ]$ lsof | grep 123.txt python 31083 user 3w REG 8,5 136318390 2621522 /home/user/123.txt</code> </pre><br>  Wie Sie sehen können, nimmt die Dateigröße nur zu und unser Trankate hat nicht funktioniert.  Informationen zum <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Öffnen des</a> Systemaufrufs finden Sie in der Dokumentation.  Wenn wir beim Öffnen einer Datei das O_APPEND-Flag verwenden, geschieht dies jedes Mal atomar, wenn das Betriebssystem die Dateigröße überprüft und Daten bis zum Ende der Datei schreibt.  Dadurch können mehrere Threads oder Prozesse in dieselbe Datei schreiben.  In unserem Code verwenden wir dieses Flag jedoch nicht.  Wir können eine andere Dateigröße in lsof nach dem Trankieren nur sehen, wenn wir die Datei für zusätzliche Aufzeichnungen öffnen, was bedeutet, dass anstelle von in unserem Code <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">with</span></span> open(<span class="hljs-string"><span class="hljs-string">"123.txt"</span></span>, <span class="hljs-string"><span class="hljs-string">"w"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> f:</code> </pre><br>  wir müssen setzen <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">with</span></span> open(<span class="hljs-string"><span class="hljs-string">"123.txt"</span></span>, <span class="hljs-string"><span class="hljs-string">"a"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> f:</code> </pre><br>  Überprüfung mit dem Flag "w" <br><br><pre> <code class="bash hljs">[user@localhost ]$ strace -e trace=open python openforwrite.py 2&gt;&amp;1| grep 123.txt open(<span class="hljs-string"><span class="hljs-string">"123.txt"</span></span>, O_WRONLY|O_CREAT|O_TRUNC, 0666) = 3</code> </pre><br>  und mit der Flagge "a" <br><br><pre> <code class="bash hljs">[user@localhost ]$ strace -e trace=open python openforwrite.py 2&gt;&amp;1| grep 123.txt open(<span class="hljs-string"><span class="hljs-string">"123.txt"</span></span>, O_WRONLY|O_CREAT|O_APPEND, 0666) = 3</code> </pre><br><h3>  Programmieren Sie einen bereits laufenden Prozess </h3><br>  Häufig verwenden Programmierer beim Erstellen und Testen von Programmen Debugger (z. B. GDB) oder verschiedene Protokollierungsebenen in der Anwendung.  Linux bietet die Möglichkeit, ein bereits laufendes Programm tatsächlich zu schreiben und zu ändern, z. B. die Werte von Variablen zu ändern, einen Haltepunkt festzulegen usw. usw. <br><br>  Zurück zur ursprünglichen Frage mit nicht genügend Speicherplatz zum Schreiben der Datei, werden wir versuchen, das Problem zu emulieren. <br><br>  Erstellen Sie eine Datei für unsere Partition, die wir als separate Festplatte bereitstellen: <br><br><pre> <code class="bash hljs">[user@localhost ~]$ dd <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>=/dev/zero of=~/tempfile_for_article.dd bs=1M count=10 10+0 records <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> 10+0 records out 10485760 bytes (10 MB) copied, 0.00525929 s, 2.0 GB/s [user@localhost ~]$</code> </pre><br>  Erstellen Sie ein Dateisystem: <br><br><pre> <code class="bash hljs">[user@localhost ~]$ mkfs.ext4 ~/tempfile_for_article.dd mke2fs 1.42.9 (28-Dec-2013) /home/user/tempfile_for_article.dd is not a block special device. Proceed anyway? (y,n) y ... Writing superblocks and filesystem accounting information: <span class="hljs-keyword"><span class="hljs-keyword">done</span></span> [user@localhost ~]$</code> </pre><br>  Mounten Sie das Dateisystem: <br><br><pre> <code class="bash hljs">[user@localhost ~]$ sudo mount ~/tempfile_for_article.dd /mnt/ [sudo] password <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> user: [user@localhost ~]$ df -h | grep mnt /dev/loop0 8.7M 172K 7.9M 3% /mnt</code> </pre><br>  Erstellen Sie ein Verzeichnis mit unserem Besitzer: <br><br><pre> <code class="bash hljs">[user@localhost ~]$ sudo mkdir /mnt/logs [user@localhost ~]$ sudo chown user: /mnt/logs</code> </pre><br>  Wir öffnen die Datei nur zum Schreiben in unserem Programm: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">with</span></span> open(<span class="hljs-string"><span class="hljs-string">"/mnt/logs/123.txt"</span></span>, <span class="hljs-string"><span class="hljs-string">"w"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> f:</code> </pre><br>  Wir starten <br><br><pre> <code class="bash hljs">[user@localhost ]$ python openforwrite.py</code> </pre><br>  Ich warte ein paar Sekunden <br><br><pre> <code class="bash hljs">[user@localhost ~]$ df -h | grep mnt /dev/loop0 8.7M 8.0M 0 100% /mnt</code> </pre><br>  Wir haben also das am Anfang dieses Artikels beschriebene Problem.  Freier Speicherplatz 0, zu 100% belegt. <br><br>  Wir erinnern uns, dass wir gemäß den Bedingungen der Aufgabe versuchen, sehr wichtige Daten aufzuzeichnen, die nicht verloren gehen können.  Gleichzeitig müssen wir den Service reparieren, ohne den Prozess neu zu starten. <br><br>  Angenommen, wir haben noch Speicherplatz, aber in einer anderen Partition, zum Beispiel in / home. <br><br>  Versuchen wir, unseren Code "on the fly neu zu programmieren". <br><br>  Wir betrachten die PID unseres Prozesses, der den gesamten Speicherplatz verbraucht hat: <br><br><pre> <code class="bash hljs">[user@localhost ~]$ ps axuf | grep [o]penfor user 10078 27.2 0.0 128600 5744 pts/22 R+ 11:06 0:02 | \_ python openforwrite.py</code> </pre><br>  Wir verbinden uns über gdb mit dem Prozess <br><br><pre> <code class="bash hljs">[user@localhost ~]$ gdb -p 10078 ... (gdb)</code> </pre><br>  Wir schauen uns die offenen Dateideskriptoren an: <br><br><pre> <code class="bash hljs">(gdb) shell ls -lah /proc/10078/fd/ total 0 dr-x------ 2 user user 0 Oct 8 11:06 . dr-xr-xr-x 9 user user 0 Oct 8 11:06 .. lrwx------ 1 user user 64 Oct 8 11:09 0 -&gt; /dev/pts/22 lrwx------ 1 user user 64 Oct 8 11:09 1 -&gt; /dev/pts/22 lrwx------ 1 user user 64 Oct 8 11:06 2 -&gt; /dev/pts/22 l-wx------ 1 user user 64 Oct 8 11:09 3 -&gt; /mnt/logs/123.txt</code> </pre><br>  Wir sehen uns die Informationen zum Dateideskriptor mit der Nummer 3 an, die uns interessieren <br><br><pre> <code class="bash hljs">(gdb) shell cat /proc/10078/fdinfo/3 pos: 8189952 flags: 0100001 mnt_id: 482</code> </pre><br>  Wenn wir uns daran erinnern, welche Art von Systemaufruf Python ausführt (siehe oben, wo wir strace ausgeführt und den offenen Aufruf gefunden haben), unseren Code zum Öffnen der Datei verarbeiten, tun wir dasselbe in unserem eigenen Namen, benötigen jedoch die Bits O_WRONLY | O_CREAT | O_TRUNC durch einen numerischen Wert ersetzen.  Öffnen Sie dazu beispielsweise <a href="">hier</a> die Kernelquellen und sehen Sie, welche Flags für was verantwortlich sind <br><br>  #define O_WRONLY 00000001 <br>  #define O_CREAT 00000100 <br>  #define O_TRUNC 00001000 <br><br>  Wir kombinieren alle Werte zu einem, wir erhalten 00001101 <br><br>  Führen Sie unseren Anruf von gdb aus <br><br><pre> <code class="bash hljs">(gdb) call open(<span class="hljs-string"><span class="hljs-string">"/home/user/123.txt"</span></span>, 00001101,0666) <span class="hljs-variable"><span class="hljs-variable">$1</span></span> = 4</code> </pre><br>  Also haben wir eine neue Deskriptordatei mit der Nummer 4 und eine neue geöffnete Datei in einem anderen Abschnitt. Überprüfen Sie: <br><br><pre> <code class="bash hljs">(gdb) shell ls -lah /proc/10078/fd/ total 0 dr-x------ 2 user user 0 Oct 8 11:06 . dr-xr-xr-x 9 user user 0 Oct 8 11:06 .. lrwx------ 1 user user 64 Oct 8 11:09 0 -&gt; /dev/pts/22 lrwx------ 1 user user 64 Oct 8 11:09 1 -&gt; /dev/pts/22 lrwx------ 1 user user 64 Oct 8 11:06 2 -&gt; /dev/pts/22 l-wx------ 1 user user 64 Oct 8 11:09 3 -&gt; /mnt/logs/123.txt l-wx------ 1 user user 64 Oct 8 11:15 4 -&gt; /home/user/123.txt</code> </pre><br>  Wir erinnern uns an das Pipe-Beispiel - wie bash Dateideskriptoren ändert und haben den Systemaufruf dup2 bereits gelernt. <br><br>  Wir versuchen, einen Dateideskriptor durch einen anderen zu ersetzen <br><br><pre> <code class="bash hljs">(gdb) call dup2(4,3) <span class="hljs-variable"><span class="hljs-variable">$2</span></span> = 3</code> </pre><br>  Wir prüfen: <br><br><pre> <code class="bash hljs">(gdb) shell ls -lah /proc/10078/fd/ total 0 dr-x------ 2 user user 0 Oct 8 11:06 . dr-xr-xr-x 9 user user 0 Oct 8 11:06 .. lrwx------ 1 user user 64 Oct 8 11:09 0 -&gt; /dev/pts/22 lrwx------ 1 user user 64 Oct 8 11:09 1 -&gt; /dev/pts/22 lrwx------ 1 user user 64 Oct 8 11:06 2 -&gt; /dev/pts/22 l-wx------ 1 user user 64 Oct 8 11:09 3 -&gt; /home/user/123.txt l-wx------ 1 user user 64 Oct 8 11:15 4 -&gt; /home/user/123.txt</code> </pre><br>  Wir schließen den Dateideskriptor 4, da wir ihn nicht benötigen: <br><br><pre> <code class="bash hljs">(gdb) call close (4) <span class="hljs-variable"><span class="hljs-variable">$1</span></span> = 0</code> </pre><br>  Und gdb verlassen <br><br><pre> <code class="bash hljs">(gdb) quit A debugging session is active. Inferior 1 [process 10078] will be detached. Quit anyway? (y or n) y Detaching from program: /usr/bin/python2.7, process 10078</code> </pre><br>  Überprüfen Sie die neue Datei: <br><br><pre> <code class="bash hljs">[user@localhost ~]$ ls -lah /home/user/123.txt -rw-rw-r-- 1 user user 5.1M Oct 8 11:18 /home/user/123.txt [user@localhost ~]$ ls -lah /home/user/123.txt -rw-rw-r-- 1 user user 7.1M Oct 8 11:18 /home/user/123.txt</code> </pre><br>  Wie Sie sehen können, werden die Daten in eine neue Datei geschrieben, wir überprüfen die alte: <br><br><pre> <code class="bash hljs">[user@localhost ~]$ ls -lah /mnt/logs/123.txt -rw-rw-r-- 1 user user 7.9M Oct 8 11:08 /mnt/logs/123.txt</code> </pre><br>  Daten gehen nicht verloren, die Anwendung funktioniert, Protokolle werden an einen neuen Ort geschrieben. <br><br><h3>  Lassen Sie uns die Aufgabe etwas komplizieren </h3><br>  Stellen Sie sich vor, die Daten sind für uns wichtig, aber wir haben in keinem der Abschnitte Speicherplatz und können die Festplatte nicht verbinden. <br><br>  Was wir tun können, ist, unsere Daten irgendwo umzuleiten, zum Beispiel an Pipe, und die Daten von Pipe werden wiederum über ein Programm, zum Beispiel Netcat, zum Netzwerk umgeleitet. <br>  Mit dem Befehl mkfifo können wir eine Named Pipe erstellen.  Es wird eine Pseudodatei im Dateisystem erstellt, auch wenn kein freier Speicherplatz vorhanden ist. <br><br>  Wir starten die Anwendung neu und überprüfen: <br><br><pre> <code class="bash hljs">[user@localhost ]$ python openforwrite.py [user@localhost ~]$ ps axuf | grep [o]pen user 5946 72.9 0.0 128600 5744 pts/22 R+ 11:27 0:20 | \_ python openforwrite.py [user@localhost ~]$ ls -lah /proc/5946/fd total 0 dr-x------ 2 user user 0 Oct 8 11:27 . dr-xr-xr-x 9 user user 0 Oct 8 11:27 .. lrwx------ 1 user user 64 Oct 8 11:28 0 -&gt; /dev/pts/22 lrwx------ 1 user user 64 Oct 8 11:28 1 -&gt; /dev/pts/22 lrwx------ 1 user user 64 Oct 8 11:27 2 -&gt; /dev/pts/22 l-wx------ 1 user user 64 Oct 8 11:28 3 -&gt; /mnt/logs/123.txt [user@localhost ~]$ df -h | grep mnt /dev/loop0 8.7M 8.0M 0 100% /mnt</code> </pre><br>  Es gibt keinen Speicherplatz, aber wir haben dort erfolgreich eine Named Pipe erstellt: <br><br><pre> <code class="bash hljs">[user@localhost ~]$ mkfifo /mnt/logs/megapipe [user@localhost ~]$ ls -lah /mnt/logs/megapipe prw-rw-r-- 1 user user 0 Oct 8 11:28 /mnt/logs/megapipe</code> </pre><br>  Jetzt müssen wir irgendwie alle Daten, die in diese Pipe gelangen, über das Netzwerk auf einen anderen Server verpacken, da dies alles derselbe Netcat tun wird. <br><br>  Führen Sie auf dem Server remote-server.example.com aus <br><br><pre> <code class="bash hljs">[user@localhost ~]$ nc -l 7777 &gt; 123.txt</code> </pre><br>  Führen Sie auf unserem Problemserver ein separates Terminal aus <br><br><pre> <code class="bash hljs">[user@localhost ~]$ nc remote-server.example.com 7777 &lt; /mnt/logs/megapipe</code> </pre><br>  Jetzt werden alle Daten, die in die Pipe gelangen, automatisch in netcat an stdin gesendet, wodurch sie an Port 7777 an das Netzwerk gesendet werden. <br><br>  Alles was wir tun müssen, ist unsere Daten in diese Named Pipe zu schreiben. <br><br>  Wir haben bereits eine laufende Anwendung: <br><br><pre> <code class="bash hljs">[user@localhost ~]$ ps axuf | grep [o]pen user 5946 99.8 0.0 128600 5744 pts/22 R+ 11:27 169:27 | \_ python openforwrite.py [user@localhost ~]$ ls -lah /proc/5946/fd total 0 dr-x------ 2 user user 0 Oct 8 11:27 . dr-xr-xr-x 9 user user 0 Oct 8 11:27 .. lrwx------ 1 user user 64 Oct 8 11:28 0 -&gt; /dev/pts/22 lrwx------ 1 user user 64 Oct 8 11:28 1 -&gt; /dev/pts/22 lrwx------ 1 user user 64 Oct 8 11:27 2 -&gt; /dev/pts/22 l-wx------ 1 user user 64 Oct 8 11:28 3 -&gt; /mnt/logs/123.txt</code> </pre><br>  Von allen Flags benötigen wir nur O_WRONLY, da die Datei bereits vorhanden ist und wir sie nicht löschen müssen <br><br><pre> <code class="bash hljs">[user@localhost ~]$ gdb -p 5946 ... (gdb) call open(<span class="hljs-string"><span class="hljs-string">"/mnt/logs/megapipe"</span></span>, 00000001,0666) <span class="hljs-variable"><span class="hljs-variable">$1</span></span> = 4 (gdb) shell ls -lah /proc/5946/fd total 0 dr-x------ 2 user user 0 Oct 8 11:27 . dr-xr-xr-x 9 user user 0 Oct 8 11:27 .. lrwx------ 1 user user 64 Oct 8 11:28 0 -&gt; /dev/pts/22 lrwx------ 1 user user 64 Oct 8 11:28 1 -&gt; /dev/pts/22 lrwx------ 1 user user 64 Oct 8 11:27 2 -&gt; /dev/pts/22 l-wx------ 1 user user 64 Oct 8 11:28 3 -&gt; /mnt/logs/123.txt l-wx------ 1 user user 64 Oct 8 14:20 4 -&gt; /mnt/logs/megapipe (gdb) call dup2(4,3) <span class="hljs-variable"><span class="hljs-variable">$2</span></span> = 3 (gdb) shell ls -lah /proc/5946/fd total 0 dr-x------ 2 user user 0 Oct 8 11:27 . dr-xr-xr-x 9 user user 0 Oct 8 11:27 .. lrwx------ 1 user user 64 Oct 8 11:28 0 -&gt; /dev/pts/22 lrwx------ 1 user user 64 Oct 8 11:28 1 -&gt; /dev/pts/22 lrwx------ 1 user user 64 Oct 8 11:27 2 -&gt; /dev/pts/22 l-wx------ 1 user user 64 Oct 8 11:28 3 -&gt; /mnt/logs/megapipe l-wx------ 1 user user 64 Oct 8 14:20 4 -&gt; /mnt/logs/megapipe (gdb) call close(4) <span class="hljs-variable"><span class="hljs-variable">$3</span></span> = 0 (gdb) shell ls -lah /proc/5946/fd total 0 dr-x------ 2 user user 0 Oct 8 11:27 . dr-xr-xr-x 9 user user 0 Oct 8 11:27 .. lrwx------ 1 user user 64 Oct 8 11:28 0 -&gt; /dev/pts/22 lrwx------ 1 user user 64 Oct 8 11:28 1 -&gt; /dev/pts/22 lrwx------ 1 user user 64 Oct 8 11:27 2 -&gt; /dev/pts/22 l-wx------ 1 user user 64 Oct 8 11:28 3 -&gt; /mnt/logs/megapipe (gdb) quit A debugging session is active. Inferior 1 [process 5946] will be detached. Quit anyway? (y or n) y Detaching from program: /usr/bin/python2.7, process 5946</code> </pre><br>  Überprüfen des Remote-Servers remote-server.example.com <br><br><pre> <code class="bash hljs">[user@localhost ~]$ ls -lah 123.txt -rw-rw-r-- 1 user user 38M Oct 8 14:21 123.txt</code> </pre><br>  Daten gehen, wir überprüfen einen Problemserver <br><br><pre> <code class="bash hljs">[user@localhost ~]$ ls -lah /mnt/logs/ total 7.9M drwxr-xr-x 2 user user 1.0K Oct 8 11:28 . drwxr-xr-x 4 root root 1.0K Oct 8 10:55 .. -rw-rw-r-- 1 user user 7.9M Oct 8 14:17 123.txt prw-rw-r-- 1 user user 0 Oct 8 14:22 megapipe</code> </pre><br>  Daten gespeichert, Problem behoben. <br><br>  Ich nutze diese Gelegenheit, um meinen Kollegen bei Degiro meine Grüße zu übermitteln. <br>  Hören Sie Radio T-Podcasts. <br><br>  Gut zu allen. <br><br>  Als Hausaufgabe schlage ich vor, darüber nachzudenken, was in den Dateideskriptoren des Katzen- und Schlafprozesses enthalten sein wird, wenn Sie diesen Befehl ausführen: <br><br><pre> <code class="bash hljs">[user@localhost ~]$ cat /dev/zero 2&gt;/dev/null| sleep 10000</code> </pre></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de471038/">https://habr.com/ru/post/de471038/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de471026/index.html">TypeScript Macht niemals</a></li>
<li><a href="../de471028/index.html">ROS LKW Wagen. Teil 6. Kilometerzähler mit Radgebern, Raumkarte, Lidar</a></li>
<li><a href="../de471032/index.html">Unsichtbares Foto</a></li>
<li><a href="../de471034/index.html">Interview mit Pornhub Web Developer</a></li>
<li><a href="../de471036/index.html">Lebe und lerne. Teil 5. Selbstbildung: Reiß dich zusammen</a></li>
<li><a href="../de471040/index.html">[Lesezeichen] PDF- und ePUB-Version des React-Handbuchs</a></li>
<li><a href="../de471042/index.html">Problemlösung mit pwnable.kr 25 - otp. Größenbeschränkung für Linux-Dateien</a></li>
<li><a href="../de471044/index.html">Sass MediaScreen - Definieren von CSS-Geräten</a></li>
<li><a href="../de471046/index.html">Stilvolle Avalonia</a></li>
<li><a href="../de471048/index.html">Reagieren + Mobx: Was ist der Sinn?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>