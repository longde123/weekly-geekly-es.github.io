<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üëäüèø üí¥ ü¶é Linux-Deskriptordatei mit Beispielen üë©üèæ‚Äçü§ù‚Äçüë®üèø üìô ü§∏üèæ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Einmal haben sie mich in einem Interview gefragt, was Sie tun sollen, wenn Sie einen Dienst finden, der nicht funktioniert, weil auf der Festplatte ni...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Linux-Deskriptordatei mit Beispielen</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/471038/"> Einmal haben sie mich in einem Interview gefragt, was Sie tun sollen, wenn Sie einen Dienst finden, der nicht funktioniert, weil auf der Festplatte nicht gen√ºgend Speicherplatz vorhanden ist. <br><br>  Nat√ºrlich antwortete ich, dass ich sehen w√ºrde, was dieser Ort besetzt ist, und wenn m√∂glich, w√ºrde ich den Ort reinigen. <br>  Dann fragte der Interviewer, was ist, wenn in der Sektion kein freier Speicherplatz vorhanden ist, Sie aber auch nicht die Dateien sehen, die den gesamten Platz einnehmen w√ºrden? <br><br>  Dazu habe ich gesagt, dass Sie immer offene Dateideskriptoren anzeigen k√∂nnen, beispielsweise mit dem Befehl lsof, und verstehen k√∂nnen, welche Anwendung den gesamten verf√ºgbaren Speicherplatz belegt hat, und dann je nach den Umst√§nden fortfahren k√∂nnen, je nachdem, ob die Daten ben√∂tigt werden. <br><br>  Der Interviewer unterbrach mich beim letzten Wort und f√ºgte meine Frage hinzu: "Angenommen, wir ben√∂tigen die Daten nicht, es ist nur ein Debug-Protokoll, aber die Anwendung funktioniert nicht, weil sie kein Debug aufzeichnen kann." <br><br>  "Okay", antwortete ich, "wir k√∂nnen das Debuggen in der Konfiguration der Anwendung deaktivieren und neu starten." <br>  Der Interviewer beanstandete: ‚ÄûNein, wir k√∂nnen die Anwendung nicht neu starten, wichtige Daten werden noch in unserem Speicher gespeichert und wichtige Clients sind mit dem Dienst selbst verbunden, den wir nicht erzwingen k√∂nnen, um die Verbindung wiederherzustellen.‚Äú <br><br>  "Nun", sagte ich, "wenn wir die Anwendung nicht neu starten k√∂nnen und die Daten f√ºr uns nicht wichtig sind, k√∂nnen wir diese ge√∂ffnete Datei einfach √ºber den Dateideskriptor l√∂schen, auch wenn wir sie im Befehl ls im Dateisystem nicht sehen." <br><br>  Der Interviewer war zufrieden, ich aber nicht. <br><br>  Dann dachte ich, warum gr√§bt die Person, die mein Wissen testet, nicht tiefer?  Was aber, wenn die Daten noch wichtig sind?  Was ist, wenn wir den Prozess nicht neu starten k√∂nnen und dieser Prozess gleichzeitig in einem Abschnitt, in dem kein freier Speicherplatz vorhanden ist, in das Dateisystem schreibt?  Was ist, wenn wir nicht nur nicht bereits aufgezeichnete Daten verlieren k√∂nnen, sondern auch die Daten, die dieser Prozess schreibt oder aufzuzeichnen versucht? <br><a name="habracut"></a><br><h3>  Tuzik </h3><br>  Zu Beginn meiner Karriere habe ich versucht, eine kleine Anwendung zu erstellen, in der Informationen √ºber Benutzer gespeichert werden mussten.  Und dann dachte ich, wie kann ich den Benutzer seinen Daten zuordnen.  Zum Beispiel habe ich Ivan Ivanov Ivanich, und er hat einige Daten, aber wie kann man sich mit ihnen anfreunden?  Ich kann direkt darauf hinweisen, dass der Hund namens "Tuzik" genau diesem Ivan geh√∂rt.  Aber was ist, wenn er seinen Namen √§ndert und anstelle von Ivan zum Beispiel Olya wird?  Dann stellt sich heraus, dass unsere Olya Ivanovna Ivanova keinen Hund mehr haben wird und unser Tuzik immer noch dem nicht existierenden Ivan geh√∂ren wird.  Diese Datenbank wurde durch eine Datenbank unterst√ºtzt, die jedem Benutzer eine eindeutige Kennung (ID) gab, und mein Tuzik wurde an diese ID angeh√§ngt, die eigentlich nur eine Ordnungszahl war.  Somit hatte der Besitzer des Tuzik die ID-Nummer 2, und irgendwann befand sich Ivan unter dieser ID, und dann wurde Olya dieselbe ID.  Das Problem der Menschlichkeit und Tierhaltung ist praktisch gel√∂st. <br><br><h3>  Dateideskriptor </h3><br>  Das Problem der Datei und des Programms, die mit dieser Datei arbeiten, ist ungef√§hr das gleiche wie das unseres Hundes und unserer Person.  Angenommen, ich habe eine Datei unter dem Namen ivan.txt ge√∂ffnet und mit dem Schreiben des Wortes tuzik begonnen, aber es ist mir gelungen, nur den ersten Buchstaben ‚Äût‚Äú in die Datei zu schreiben, und diese Datei wurde von jemandem umbenannt, z. B. olya.txt.  Aber die Datei ist dieselbe geblieben, und ich m√∂chte immer noch mein Ass darin schreiben.  Jedes Mal, wenn ich eine Datei mit dem offenen Systemaufruf in einer beliebigen Programmiersprache √∂ffne, erhalte ich eine eindeutige ID, die mich auf eine Datei verweist. Diese ID ist ein Dateideskriptor.  Und es spielt keine Rolle, was jemand als N√§chstes mit dieser Datei macht, er kann sie l√∂schen, umbenennen, den Eigent√ºmer √§ndern oder Lese- und Schreibberechtigungen wegnehmen. Ich habe weiterhin Zugriff darauf, da zum Zeitpunkt des √ñffnens der Datei Ich hatte das Recht, es zu lesen und / oder zu schreiben, und es gelang mir, mit ihm zusammenzuarbeiten, was bedeutet, dass ich dies weiterhin tun muss. <br><br>  Unter Linux wird die libc-Bibliothek f√ºr jede laufende Anwendungs- (Prozess-) 3-Deskriptordatei mit den Nummern 0,1,2 ge√∂ffnet.  Weitere Informationen finden Sie unter den Links <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">man stdio</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">man stdout</a> <br><br><ul><li>  Der Dateideskriptor 0 hei√üt STDIN und ist der Dateneingabe aus der Anwendung zugeordnet </li><li>  Der Dateideskriptor 1 hei√üt STDOUT und wird von Anwendungen verwendet, um Daten auszugeben, beispielsweise Druckbefehle </li><li>  Der Dateideskriptor 2 hei√üt STDERR und wird von Anwendungen zur Ausgabe von Fehlerberichtsdaten verwendet. </li></ul><br>  Wenn Sie in Ihrem Programm eine Datei zum Lesen oder Schreiben √∂ffnen, erhalten Sie h√∂chstwahrscheinlich die erste freie ID und dies ist Nummer 3. <br><br>  Eine Liste von Deskriptordateien kann von jedem Prozess aus angezeigt werden, wenn Sie die PID kennen. <br><br>  √ñffnen Sie beispielsweise eine Konsole mit Bash und sehen Sie die PID unseres Prozesses <br><br><pre><code class="bash hljs">[user@localhost ]$ <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> $$ 15771</code> </pre> <br>  F√ºhren Sie in der zweiten Konsole aus <br><br><pre> <code class="bash hljs">[user@localhost ]$ ls -lah /proc/15771/fd/ total 0 dr-x------ 2 user user 0 Oct 7 15:42 . dr-xr-xr-x 9 user user 0 Oct 7 15:42 .. lrwx------ 1 user user 64 Oct 7 15:42 0 -&gt; /dev/pts/21 lrwx------ 1 user user 64 Oct 7 15:42 1 -&gt; /dev/pts/21 lrwx------ 1 user user 64 Oct 7 15:42 2 -&gt; /dev/pts/21 lrwx------ 1 user user 64 Oct 7 15:42 255 -&gt; /dev/pts/21</code> </pre><br>  Sie k√∂nnen den Dateideskriptor Nr. 255 im Rahmen dieses Artikels ignorieren. Er wurde von bash selbst und nicht von einer verkn√ºpften Bibliothek f√ºr Ihre Anforderungen ge√∂ffnet. <br><br>  Jetzt sind alle 3 Deskriptordateien dem Pseudo-Endger√§t <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">/ dev / pts zugeordnet</a> , aber wir k√∂nnen sie weiterhin bearbeiten, z. B. in der zweiten Konsole ausf√ºhren <br><br><pre> <code class="bash hljs">[user@localhost ]$ <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">"hello world"</span></span> &gt; /proc/15771/fd/0</code> </pre><br>  Und in der ersten Konsole werden wir sehen <br><br><pre> <code class="bash hljs">[user@localhost ]$ hello world</code> </pre><br><h3>  Weiterleiten und leiten </h3><br>  Sie k√∂nnen diese 3 Deskriptordateien in jedem Prozess leicht √ºberschreiben, auch in Bash, z. B. √ºber eine Pipe, die zwei Prozesse verbindet <br><br><pre> <code class="bash hljs">[user@localhost ]$ cat /dev/zero | sleep 10000</code> </pre><br>  Sie k√∂nnen diesen Befehl selbst mit <i>strace -f ausf√ºhren</i> und sehen, was im Inneren passiert, aber ich werde es Ihnen kurz sagen. <br><br>  Unsere √ºbergeordnete Prozess-Bash mit PID 15771 analysiert unseren Befehl und versteht genau, wie viele Befehle wir ausf√ºhren m√∂chten. In unserem Fall gibt es zwei davon: Katze und Schlaf.  Bash wei√ü, dass er zwei untergeordnete Prozesse erstellen und mit einer Pipe kombinieren muss.  Total Bash ben√∂tigt 2 untergeordnete Prozesse und eine Pipe. <br><br>  Vor dem Erstellen untergeordneter Prozesse startet bash den <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Pipe</a> -Systemaufruf und empf√§ngt neue Dateideskriptoren f√ºr den tempor√§ren Pipe-Puffer. Dieser Puffer bindet unsere beiden untergeordneten Prozesse jedoch noch nicht. <br><br>  F√ºr den √ºbergeordneten Prozess scheint die Pipe bereits vorhanden zu sein, und es gibt noch keine untergeordneten Prozesse: <br><br><pre> <code class="bash hljs">PID <span class="hljs-built_in"><span class="hljs-built_in">command</span></span> 15771 bash lrwx------ 1 user user 64 Oct 7 15:42 0 -&gt; /dev/pts/21 lrwx------ 1 user user 64 Oct 7 15:42 1 -&gt; /dev/pts/21 lrwx------ 1 user user 64 Oct 7 15:42 2 -&gt; /dev/pts/21 lrwx------ 1 user user 64 Oct 7 15:42 3 -&gt; pipe:[253543032] lrwx------ 1 user user 64 Oct 7 15:42 4 -&gt; pipe:[253543032] lrwx------ 1 user user 64 Oct 7 15:42 255 -&gt; /dev/pts/21</code> </pre><br>  Dann erstellt <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Clone</a> Bash mithilfe eines Systemaufrufs zwei untergeordnete Prozesse, und unsere drei Prozesse sehen folgenderma√üen aus: <br><br><pre> <code class="bash hljs">PID <span class="hljs-built_in"><span class="hljs-built_in">command</span></span> 15771 bash lrwx------ 1 user user 64 Oct 7 15:42 0 -&gt; /dev/pts/21 lrwx------ 1 user user 64 Oct 7 15:42 1 -&gt; /dev/pts/21 lrwx------ 1 user user 64 Oct 7 15:42 2 -&gt; /dev/pts/21 lrwx------ 1 user user 64 Oct 7 15:42 3 -&gt; pipe:[253543032] lrwx------ 1 user user 64 Oct 7 15:42 4 -&gt; pipe:[253543032] lrwx------ 1 user user 64 Oct 7 15:42 255 -&gt; /dev/pts/21 PID <span class="hljs-built_in"><span class="hljs-built_in">command</span></span> 9004 bash lrwx------ 1 user user 64 Oct 7 15:57 0 -&gt; /dev/pts/21 lrwx------ 1 user user 64 Oct 7 15:57 1 -&gt; /dev/pts/21 lrwx------ 1 user user 64 Oct 7 15:57 2 -&gt; /dev/pts/21 lrwx------ 1 user user 64 Oct 7 15:57 3 -&gt; pipe:[253543032] lrwx------ 1 user user 64 Oct 7 15:57 4 -&gt; pipe:[253543032] lrwx------ 1 user user 64 Oct 7 15:57 255 -&gt; /dev/pts/21 PID <span class="hljs-built_in"><span class="hljs-built_in">command</span></span> 9005 bash lrwx------ 1 user user 64 Oct 7 15:57 0 -&gt; /dev/pts/21 lrwx------ 1 user user 64 Oct 7 15:57 1 -&gt; /dev/pts/21 lrwx------ 1 user user 64 Oct 7 15:57 2 -&gt; /dev/pts/21 lrwx------ 1 user user 64 Oct 7 15:57 3 -&gt; pipe:[253543032] lrwx------ 1 user user 64 Oct 7 15:57 4 -&gt; pipe:[253543032] lrwx------ 1 user user 64 Oct 7 15:57 255 -&gt; /dev/pts/21</code> </pre><br>  Vergessen Sie nicht, dass der Klon den Prozess zusammen mit allen Dateideskriptoren klont, damit sie im √ºbergeordneten und im untergeordneten Prozess gleich sind.  Die Aufgabe des √ºbergeordneten Prozesses mit PID 15771 besteht darin, die untergeordneten Prozesse zu √ºberwachen, sodass nur auf eine Antwort der untergeordneten Prozesse gewartet wird. <br><br>  Daher ben√∂tigt er keine Pipe und schlie√üt die Dateideskriptoren mit den Nummern 3 und 4. <br><br>  Im ersten <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">untergeordneten</a> Bash-Prozess mit PID 9004, dem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Systemaufruf dup2</a> , wird unser STDOUT-Dateideskriptor mit der Nummer 1 in einen Dateideskriptor ge√§ndert, der auf die Pipe zeigt. In unserem Fall ist es die Nummer 3. Somit wird alles, was der erste untergeordnete Prozess mit der PID 9004 in STDOUT schreibt f√§llt automatisch in den Rohrpuffer. <br><br>  Im zweiten untergeordneten Prozess mit PID 9005 √§ndert bash den Deskriptor STDIN mit der Nummer 0 unter Verwendung von dup2. Jetzt liest alles, was unser zweiter bash mit PID 9005 liest, aus der Pipe. <br><br>  Danach werden die Deskriptoren mit den Nummern 3 und 4 auch in untergeordneten Prozessen geschlossen, da sie nicht mehr verwendet werden. <br><br>  Ich ignoriere absichtlich den Dateideskriptor 255, er verwendet Bash f√ºr interne Anforderungen und wird auch in untergeordneten Prozessen geschlossen. <br><br>  Au√üerdem startet bash im ersten untergeordneten Prozess mit PID 9004 die ausf√ºhrbare Datei, die wir in der Befehlszeile mit dem Systemaufruf <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">exec angegeben haben</a> , in unserem Fall / usr / bin / cat. <br><br>  Im zweiten untergeordneten Prozess mit PID 9005 startet bash die zweite ausf√ºhrbare Datei, die wir angegeben haben, in unserem Fall / usr / bin / sleep. <br><br>  Der Systemaufruf exec schlie√üt keine Dateideskriptoren, wenn sie w√§hrend des Aufrufs nicht mit dem Flag O_CLOEXEC ge√∂ffnet wurden.  In unserem Fall werden nach dem Ausf√ºhren der ausf√ºhrbaren Dateien alle aktuellen Dateideskriptoren gespeichert. <br><br>  √úberpr√ºfen Sie in der Konsole: <br><br><pre> <code class="bash hljs">[user@localhost ]$ pgrep -P 15771 9004 9005 [user@localhost ]$ ls -lah /proc/15771/fd/ total 0 dr-x------ 2 user user 0 Oct 7 15:42 . dr-xr-xr-x 9 user user 0 Oct 7 15:42 .. lrwx------ 1 user user 64 Oct 7 15:42 0 -&gt; /dev/pts/21 lrwx------ 1 user user 64 Oct 7 15:42 1 -&gt; /dev/pts/21 lrwx------ 1 user user 64 Oct 7 15:42 2 -&gt; /dev/pts/21 lrwx------ 1 user user 64 Oct 7 15:42 255 -&gt; /dev/pts/21 [user@localhost ]$ ls -lah /proc/9004/fd total 0 dr-x------ 2 user user 0 Oct 7 15:57 . dr-xr-xr-x 9 user user 0 Oct 7 15:57 .. lrwx------ 1 user user 64 Oct 7 15:57 0 -&gt; /dev/pts/21 l-wx------ 1 user user 64 Oct 7 15:57 1 -&gt; pipe:[253543032] lrwx------ 1 user user 64 Oct 7 15:57 2 -&gt; /dev/pts/21 lr-x------ 1 user user 64 Oct 7 15:57 3 -&gt; /dev/zero [user@localhost ]$ ls -lah /proc/9005/fd total 0 dr-x------ 2 user user 0 Oct 7 15:57 . dr-xr-xr-x 9 user user 0 Oct 7 15:57 .. lr-x------ 1 user user 64 Oct 7 15:57 0 -&gt; pipe:[253543032] lrwx------ 1 user user 64 Oct 7 15:57 1 -&gt; /dev/pts/21 lrwx------ 1 user user 64 Oct 7 15:57 2 -&gt; /dev/pts/21 [user@localhost ]$ ps -up 9004 USER PID %CPU %MEM VSZ RSS TTY STAT START TIME COMMAND user 9004 0.0 0.0 107972 620 pts/21 S+ 15:57 0:00 cat /dev/zero [user@localhost ]$ ps -up 9005 USER PID %CPU %MEM VSZ RSS TTY STAT START TIME COMMAND user 9005 0.0 0.0 107952 360 pts/21 S+ 15:57 0:00 sleep 10000</code> </pre><br>  Wie Sie sehen k√∂nnen, ist die eindeutige Anzahl unserer Rohre in beiden Prozessen gleich.  Wir haben also eine Verbindung zwischen zwei verschiedenen Prozessen mit einem Elternteil. <br><br>  F√ºr diejenigen, die mit den von bash verwendeten Systemaufrufen nicht vertraut sind, empfehle ich dringend, die Befehle √ºber strace auszuf√ºhren und zu sehen, was im Inneren beispielsweise so passiert: <br><br><pre> <code class="bash hljs">strace -s 1024 -f bash -c <span class="hljs-string"><span class="hljs-string">"ls | grep hello"</span></span></code> </pre><br>  Kehren wir zu unserem Problem zur√ºck, bei dem der Speicherplatz knapp wird und versucht wird, Daten zu speichern, ohne den Prozess neu zu starten.  Schreiben wir ein kleines Programm, das ungef√§hr 1 Megabyte pro Sekunde auf die Festplatte schreibt.  Wenn wir aus irgendeinem Grund keine Daten auf die Festplatte schreiben konnten, ignorieren wir sie einfach und versuchen nach einer Sekunde erneut, Daten zu schreiben.  In dem Beispiel, in dem ich Python verwende, k√∂nnen Sie jede andere Programmiersprache verwenden. <br><br><pre> <code class="python hljs">[user@localhost ]$ cat openforwrite.py <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> datetime <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> time mystr=<span class="hljs-string"><span class="hljs-string">"a"</span></span>*<span class="hljs-number"><span class="hljs-number">1024</span></span>*<span class="hljs-number"><span class="hljs-number">1024</span></span>+<span class="hljs-string"><span class="hljs-string">"\n"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> open(<span class="hljs-string"><span class="hljs-string">"123.txt"</span></span>, <span class="hljs-string"><span class="hljs-string">"w"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> f: <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">try</span></span>: f.write(str(datetime.datetime.now())) f.write(mystr) f.flush() time.sleep(<span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">except</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">pass</span></span></code> </pre><br>  F√ºhren Sie das Programm aus und sehen Sie sich die Dateideskriptoren an <br><br><pre> <code class="bash hljs">[user@localhost ]$ python openforwrite.py &amp; [1] 3762 [user@localhost ]$ ps axuf | grep [o]penforwrite user 3762 0.0 0.0 128600 5744 pts/22 S+ 16:28 0:00 | \_ python openforwrite.py [user@localhost ]$ ls -la /proc/3762/fd total 0 dr-x------ 2 user user 0 Oct 7 16:29 . dr-xr-xr-x 9 user user 0 Oct 7 16:29 .. lrwx------ 1 user user 64 Oct 7 16:29 0 -&gt; /dev/pts/22 lrwx------ 1 user user 64 Oct 7 16:29 1 -&gt; /dev/pts/22 lrwx------ 1 user user 64 Oct 7 16:29 2 -&gt; /dev/pts/22 l-wx------ 1 user user 64 Oct 7 16:29 3 -&gt; /home/user/123.txt</code> </pre><br>  Wie Sie sehen k√∂nnen, haben wir unsere 3 Standard-Dateideskriptoren und einen weiteren, den wir ge√∂ffnet haben.  √úberpr√ºfen Sie die Dateigr√∂√üe: <br><br><pre> <code class="bash hljs">[user@localhost ]$ ls -lah 123.txt -rw-rw-r-- 1 user user 117M Oct 7 16:30 123.txt</code> </pre><br>  Daten werden geschrieben. Versuchen Sie, die Dateiberechtigungen zu √§ndern: <br><br><pre> <code class="bash hljs">[user@localhost ]$ sudo chown root: 123.txt [user@localhost ]$ ls -lah 123.txt -rw-rw-r-- 1 root root 168M Oct 7 16:31 123.txt [user@localhost ]$ ls -lah 123.txt -rw-rw-r-- 1 root root 172M Oct 7 16:31 123.txt</code> </pre><br>  Wir sehen, dass die Daten noch geschrieben werden, obwohl unser Benutzer nicht das Recht hat, in die Datei zu schreiben.  Versuchen wir es zu entfernen: <br><br><pre> <code class="bash hljs">[user@localhost ]$ sudo rm 123.txt [user@localhost ]$ ls 123.txt ls: cannot access 123.txt: No such file or directory</code> </pre><br>  Wo sind die Daten geschrieben?  Und sind sie √ºberhaupt geschrieben?  Wir pr√ºfen: <br><br><pre> <code class="bash hljs">[user@localhost ]$ ls -la /proc/3762/fd total 0 dr-x------ 2 user user 0 Oct 7 16:29 . dr-xr-xr-x 9 user user 0 Oct 7 16:29 .. lrwx------ 1 user user 64 Oct 7 16:29 0 -&gt; /dev/pts/22 lrwx------ 1 user user 64 Oct 7 16:29 1 -&gt; /dev/pts/22 lrwx------ 1 user user 64 Oct 7 16:29 2 -&gt; /dev/pts/22 l-wx------ 1 user user 64 Oct 7 16:29 3 -&gt; /home/user/123.txt (deleted)</code> </pre><br>  Ja, unsere Deskriptordatei ist noch vorhanden, und wir k√∂nnen mit dieser Deskriptordatei wie mit unserer alten Datei arbeiten, sie lesen, bereinigen und kopieren. <br><br>  Wir betrachten die Dateigr√∂√üe: <br><br><pre> <code class="bash hljs">[user@localhost ]$ lsof | grep 123.txt python 31083 user 3w REG 8,5 19923457 2621522 /home/user/123.txt</code> </pre><br>  Dateigr√∂√üe 19923457. Versuch, die Datei zu l√∂schen: <br><br><pre> <code class="bash hljs">[user@localhost ]$ truncate -s 0 /proc/31083/fd/3 [user@localhost ]$ lsof | grep 123.txt python 31083 user 3w REG 8,5 136318390 2621522 /home/user/123.txt</code> </pre><br>  Wie Sie sehen k√∂nnen, nimmt die Dateigr√∂√üe nur zu und unser Trankate hat nicht funktioniert.  Informationen zum <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">√ñffnen des</a> Systemaufrufs finden Sie in der Dokumentation.  Wenn wir beim √ñffnen einer Datei das O_APPEND-Flag verwenden, geschieht dies jedes Mal atomar, wenn das Betriebssystem die Dateigr√∂√üe √ºberpr√ºft und Daten bis zum Ende der Datei schreibt.  Dadurch k√∂nnen mehrere Threads oder Prozesse in dieselbe Datei schreiben.  In unserem Code verwenden wir dieses Flag jedoch nicht.  Wir k√∂nnen eine andere Dateigr√∂√üe in lsof nach dem Trankieren nur sehen, wenn wir die Datei f√ºr zus√§tzliche Aufzeichnungen √∂ffnen, was bedeutet, dass anstelle von in unserem Code <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">with</span></span> open(<span class="hljs-string"><span class="hljs-string">"123.txt"</span></span>, <span class="hljs-string"><span class="hljs-string">"w"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> f:</code> </pre><br>  wir m√ºssen setzen <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">with</span></span> open(<span class="hljs-string"><span class="hljs-string">"123.txt"</span></span>, <span class="hljs-string"><span class="hljs-string">"a"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> f:</code> </pre><br>  √úberpr√ºfung mit dem Flag "w" <br><br><pre> <code class="bash hljs">[user@localhost ]$ strace -e trace=open python openforwrite.py 2&gt;&amp;1| grep 123.txt open(<span class="hljs-string"><span class="hljs-string">"123.txt"</span></span>, O_WRONLY|O_CREAT|O_TRUNC, 0666) = 3</code> </pre><br>  und mit der Flagge "a" <br><br><pre> <code class="bash hljs">[user@localhost ]$ strace -e trace=open python openforwrite.py 2&gt;&amp;1| grep 123.txt open(<span class="hljs-string"><span class="hljs-string">"123.txt"</span></span>, O_WRONLY|O_CREAT|O_APPEND, 0666) = 3</code> </pre><br><h3>  Programmieren Sie einen bereits laufenden Prozess </h3><br>  H√§ufig verwenden Programmierer beim Erstellen und Testen von Programmen Debugger (z. B. GDB) oder verschiedene Protokollierungsebenen in der Anwendung.  Linux bietet die M√∂glichkeit, ein bereits laufendes Programm tats√§chlich zu schreiben und zu √§ndern, z. B. die Werte von Variablen zu √§ndern, einen Haltepunkt festzulegen usw. usw. <br><br>  Zur√ºck zur urspr√ºnglichen Frage mit nicht gen√ºgend Speicherplatz zum Schreiben der Datei, werden wir versuchen, das Problem zu emulieren. <br><br>  Erstellen Sie eine Datei f√ºr unsere Partition, die wir als separate Festplatte bereitstellen: <br><br><pre> <code class="bash hljs">[user@localhost ~]$ dd <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>=/dev/zero of=~/tempfile_for_article.dd bs=1M count=10 10+0 records <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> 10+0 records out 10485760 bytes (10 MB) copied, 0.00525929 s, 2.0 GB/s [user@localhost ~]$</code> </pre><br>  Erstellen Sie ein Dateisystem: <br><br><pre> <code class="bash hljs">[user@localhost ~]$ mkfs.ext4 ~/tempfile_for_article.dd mke2fs 1.42.9 (28-Dec-2013) /home/user/tempfile_for_article.dd is not a block special device. Proceed anyway? (y,n) y ... Writing superblocks and filesystem accounting information: <span class="hljs-keyword"><span class="hljs-keyword">done</span></span> [user@localhost ~]$</code> </pre><br>  Mounten Sie das Dateisystem: <br><br><pre> <code class="bash hljs">[user@localhost ~]$ sudo mount ~/tempfile_for_article.dd /mnt/ [sudo] password <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> user: [user@localhost ~]$ df -h | grep mnt /dev/loop0 8.7M 172K 7.9M 3% /mnt</code> </pre><br>  Erstellen Sie ein Verzeichnis mit unserem Besitzer: <br><br><pre> <code class="bash hljs">[user@localhost ~]$ sudo mkdir /mnt/logs [user@localhost ~]$ sudo chown user: /mnt/logs</code> </pre><br>  Wir √∂ffnen die Datei nur zum Schreiben in unserem Programm: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">with</span></span> open(<span class="hljs-string"><span class="hljs-string">"/mnt/logs/123.txt"</span></span>, <span class="hljs-string"><span class="hljs-string">"w"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> f:</code> </pre><br>  Wir starten <br><br><pre> <code class="bash hljs">[user@localhost ]$ python openforwrite.py</code> </pre><br>  Ich warte ein paar Sekunden <br><br><pre> <code class="bash hljs">[user@localhost ~]$ df -h | grep mnt /dev/loop0 8.7M 8.0M 0 100% /mnt</code> </pre><br>  Wir haben also das am Anfang dieses Artikels beschriebene Problem.  Freier Speicherplatz 0, zu 100% belegt. <br><br>  Wir erinnern uns, dass wir gem√§√ü den Bedingungen der Aufgabe versuchen, sehr wichtige Daten aufzuzeichnen, die nicht verloren gehen k√∂nnen.  Gleichzeitig m√ºssen wir den Service reparieren, ohne den Prozess neu zu starten. <br><br>  Angenommen, wir haben noch Speicherplatz, aber in einer anderen Partition, zum Beispiel in / home. <br><br>  Versuchen wir, unseren Code "on the fly neu zu programmieren". <br><br>  Wir betrachten die PID unseres Prozesses, der den gesamten Speicherplatz verbraucht hat: <br><br><pre> <code class="bash hljs">[user@localhost ~]$ ps axuf | grep [o]penfor user 10078 27.2 0.0 128600 5744 pts/22 R+ 11:06 0:02 | \_ python openforwrite.py</code> </pre><br>  Wir verbinden uns √ºber gdb mit dem Prozess <br><br><pre> <code class="bash hljs">[user@localhost ~]$ gdb -p 10078 ... (gdb)</code> </pre><br>  Wir schauen uns die offenen Dateideskriptoren an: <br><br><pre> <code class="bash hljs">(gdb) shell ls -lah /proc/10078/fd/ total 0 dr-x------ 2 user user 0 Oct 8 11:06 . dr-xr-xr-x 9 user user 0 Oct 8 11:06 .. lrwx------ 1 user user 64 Oct 8 11:09 0 -&gt; /dev/pts/22 lrwx------ 1 user user 64 Oct 8 11:09 1 -&gt; /dev/pts/22 lrwx------ 1 user user 64 Oct 8 11:06 2 -&gt; /dev/pts/22 l-wx------ 1 user user 64 Oct 8 11:09 3 -&gt; /mnt/logs/123.txt</code> </pre><br>  Wir sehen uns die Informationen zum Dateideskriptor mit der Nummer 3 an, die uns interessieren <br><br><pre> <code class="bash hljs">(gdb) shell cat /proc/10078/fdinfo/3 pos: 8189952 flags: 0100001 mnt_id: 482</code> </pre><br>  Wenn wir uns daran erinnern, welche Art von Systemaufruf Python ausf√ºhrt (siehe oben, wo wir strace ausgef√ºhrt und den offenen Aufruf gefunden haben), unseren Code zum √ñffnen der Datei verarbeiten, tun wir dasselbe in unserem eigenen Namen, ben√∂tigen jedoch die Bits O_WRONLY | O_CREAT | O_TRUNC durch einen numerischen Wert ersetzen.  √ñffnen Sie dazu beispielsweise <a href="">hier</a> die Kernelquellen und sehen Sie, welche Flags f√ºr was verantwortlich sind <br><br>  #define O_WRONLY 00000001 <br>  #define O_CREAT 00000100 <br>  #define O_TRUNC 00001000 <br><br>  Wir kombinieren alle Werte zu einem, wir erhalten 00001101 <br><br>  F√ºhren Sie unseren Anruf von gdb aus <br><br><pre> <code class="bash hljs">(gdb) call open(<span class="hljs-string"><span class="hljs-string">"/home/user/123.txt"</span></span>, 00001101,0666) <span class="hljs-variable"><span class="hljs-variable">$1</span></span> = 4</code> </pre><br>  Also haben wir eine neue Deskriptordatei mit der Nummer 4 und eine neue ge√∂ffnete Datei in einem anderen Abschnitt. √úberpr√ºfen Sie: <br><br><pre> <code class="bash hljs">(gdb) shell ls -lah /proc/10078/fd/ total 0 dr-x------ 2 user user 0 Oct 8 11:06 . dr-xr-xr-x 9 user user 0 Oct 8 11:06 .. lrwx------ 1 user user 64 Oct 8 11:09 0 -&gt; /dev/pts/22 lrwx------ 1 user user 64 Oct 8 11:09 1 -&gt; /dev/pts/22 lrwx------ 1 user user 64 Oct 8 11:06 2 -&gt; /dev/pts/22 l-wx------ 1 user user 64 Oct 8 11:09 3 -&gt; /mnt/logs/123.txt l-wx------ 1 user user 64 Oct 8 11:15 4 -&gt; /home/user/123.txt</code> </pre><br>  Wir erinnern uns an das Pipe-Beispiel - wie bash Dateideskriptoren √§ndert und haben den Systemaufruf dup2 bereits gelernt. <br><br>  Wir versuchen, einen Dateideskriptor durch einen anderen zu ersetzen <br><br><pre> <code class="bash hljs">(gdb) call dup2(4,3) <span class="hljs-variable"><span class="hljs-variable">$2</span></span> = 3</code> </pre><br>  Wir pr√ºfen: <br><br><pre> <code class="bash hljs">(gdb) shell ls -lah /proc/10078/fd/ total 0 dr-x------ 2 user user 0 Oct 8 11:06 . dr-xr-xr-x 9 user user 0 Oct 8 11:06 .. lrwx------ 1 user user 64 Oct 8 11:09 0 -&gt; /dev/pts/22 lrwx------ 1 user user 64 Oct 8 11:09 1 -&gt; /dev/pts/22 lrwx------ 1 user user 64 Oct 8 11:06 2 -&gt; /dev/pts/22 l-wx------ 1 user user 64 Oct 8 11:09 3 -&gt; /home/user/123.txt l-wx------ 1 user user 64 Oct 8 11:15 4 -&gt; /home/user/123.txt</code> </pre><br>  Wir schlie√üen den Dateideskriptor 4, da wir ihn nicht ben√∂tigen: <br><br><pre> <code class="bash hljs">(gdb) call close (4) <span class="hljs-variable"><span class="hljs-variable">$1</span></span> = 0</code> </pre><br>  Und gdb verlassen <br><br><pre> <code class="bash hljs">(gdb) quit A debugging session is active. Inferior 1 [process 10078] will be detached. Quit anyway? (y or n) y Detaching from program: /usr/bin/python2.7, process 10078</code> </pre><br>  √úberpr√ºfen Sie die neue Datei: <br><br><pre> <code class="bash hljs">[user@localhost ~]$ ls -lah /home/user/123.txt -rw-rw-r-- 1 user user 5.1M Oct 8 11:18 /home/user/123.txt [user@localhost ~]$ ls -lah /home/user/123.txt -rw-rw-r-- 1 user user 7.1M Oct 8 11:18 /home/user/123.txt</code> </pre><br>  Wie Sie sehen k√∂nnen, werden die Daten in eine neue Datei geschrieben, wir √ºberpr√ºfen die alte: <br><br><pre> <code class="bash hljs">[user@localhost ~]$ ls -lah /mnt/logs/123.txt -rw-rw-r-- 1 user user 7.9M Oct 8 11:08 /mnt/logs/123.txt</code> </pre><br>  Daten gehen nicht verloren, die Anwendung funktioniert, Protokolle werden an einen neuen Ort geschrieben. <br><br><h3>  Lassen Sie uns die Aufgabe etwas komplizieren </h3><br>  Stellen Sie sich vor, die Daten sind f√ºr uns wichtig, aber wir haben in keinem der Abschnitte Speicherplatz und k√∂nnen die Festplatte nicht verbinden. <br><br>  Was wir tun k√∂nnen, ist, unsere Daten irgendwo umzuleiten, zum Beispiel an Pipe, und die Daten von Pipe werden wiederum √ºber ein Programm, zum Beispiel Netcat, zum Netzwerk umgeleitet. <br>  Mit dem Befehl mkfifo k√∂nnen wir eine Named Pipe erstellen.  Es wird eine Pseudodatei im Dateisystem erstellt, auch wenn kein freier Speicherplatz vorhanden ist. <br><br>  Wir starten die Anwendung neu und √ºberpr√ºfen: <br><br><pre> <code class="bash hljs">[user@localhost ]$ python openforwrite.py [user@localhost ~]$ ps axuf | grep [o]pen user 5946 72.9 0.0 128600 5744 pts/22 R+ 11:27 0:20 | \_ python openforwrite.py [user@localhost ~]$ ls -lah /proc/5946/fd total 0 dr-x------ 2 user user 0 Oct 8 11:27 . dr-xr-xr-x 9 user user 0 Oct 8 11:27 .. lrwx------ 1 user user 64 Oct 8 11:28 0 -&gt; /dev/pts/22 lrwx------ 1 user user 64 Oct 8 11:28 1 -&gt; /dev/pts/22 lrwx------ 1 user user 64 Oct 8 11:27 2 -&gt; /dev/pts/22 l-wx------ 1 user user 64 Oct 8 11:28 3 -&gt; /mnt/logs/123.txt [user@localhost ~]$ df -h | grep mnt /dev/loop0 8.7M 8.0M 0 100% /mnt</code> </pre><br>  Es gibt keinen Speicherplatz, aber wir haben dort erfolgreich eine Named Pipe erstellt: <br><br><pre> <code class="bash hljs">[user@localhost ~]$ mkfifo /mnt/logs/megapipe [user@localhost ~]$ ls -lah /mnt/logs/megapipe prw-rw-r-- 1 user user 0 Oct 8 11:28 /mnt/logs/megapipe</code> </pre><br>  Jetzt m√ºssen wir irgendwie alle Daten, die in diese Pipe gelangen, √ºber das Netzwerk auf einen anderen Server verpacken, da dies alles derselbe Netcat tun wird. <br><br>  F√ºhren Sie auf dem Server remote-server.example.com aus <br><br><pre> <code class="bash hljs">[user@localhost ~]$ nc -l 7777 &gt; 123.txt</code> </pre><br>  F√ºhren Sie auf unserem Problemserver ein separates Terminal aus <br><br><pre> <code class="bash hljs">[user@localhost ~]$ nc remote-server.example.com 7777 &lt; /mnt/logs/megapipe</code> </pre><br>  Jetzt werden alle Daten, die in die Pipe gelangen, automatisch in netcat an stdin gesendet, wodurch sie an Port 7777 an das Netzwerk gesendet werden. <br><br>  Alles was wir tun m√ºssen, ist unsere Daten in diese Named Pipe zu schreiben. <br><br>  Wir haben bereits eine laufende Anwendung: <br><br><pre> <code class="bash hljs">[user@localhost ~]$ ps axuf | grep [o]pen user 5946 99.8 0.0 128600 5744 pts/22 R+ 11:27 169:27 | \_ python openforwrite.py [user@localhost ~]$ ls -lah /proc/5946/fd total 0 dr-x------ 2 user user 0 Oct 8 11:27 . dr-xr-xr-x 9 user user 0 Oct 8 11:27 .. lrwx------ 1 user user 64 Oct 8 11:28 0 -&gt; /dev/pts/22 lrwx------ 1 user user 64 Oct 8 11:28 1 -&gt; /dev/pts/22 lrwx------ 1 user user 64 Oct 8 11:27 2 -&gt; /dev/pts/22 l-wx------ 1 user user 64 Oct 8 11:28 3 -&gt; /mnt/logs/123.txt</code> </pre><br>  Von allen Flags ben√∂tigen wir nur O_WRONLY, da die Datei bereits vorhanden ist und wir sie nicht l√∂schen m√ºssen <br><br><pre> <code class="bash hljs">[user@localhost ~]$ gdb -p 5946 ... (gdb) call open(<span class="hljs-string"><span class="hljs-string">"/mnt/logs/megapipe"</span></span>, 00000001,0666) <span class="hljs-variable"><span class="hljs-variable">$1</span></span> = 4 (gdb) shell ls -lah /proc/5946/fd total 0 dr-x------ 2 user user 0 Oct 8 11:27 . dr-xr-xr-x 9 user user 0 Oct 8 11:27 .. lrwx------ 1 user user 64 Oct 8 11:28 0 -&gt; /dev/pts/22 lrwx------ 1 user user 64 Oct 8 11:28 1 -&gt; /dev/pts/22 lrwx------ 1 user user 64 Oct 8 11:27 2 -&gt; /dev/pts/22 l-wx------ 1 user user 64 Oct 8 11:28 3 -&gt; /mnt/logs/123.txt l-wx------ 1 user user 64 Oct 8 14:20 4 -&gt; /mnt/logs/megapipe (gdb) call dup2(4,3) <span class="hljs-variable"><span class="hljs-variable">$2</span></span> = 3 (gdb) shell ls -lah /proc/5946/fd total 0 dr-x------ 2 user user 0 Oct 8 11:27 . dr-xr-xr-x 9 user user 0 Oct 8 11:27 .. lrwx------ 1 user user 64 Oct 8 11:28 0 -&gt; /dev/pts/22 lrwx------ 1 user user 64 Oct 8 11:28 1 -&gt; /dev/pts/22 lrwx------ 1 user user 64 Oct 8 11:27 2 -&gt; /dev/pts/22 l-wx------ 1 user user 64 Oct 8 11:28 3 -&gt; /mnt/logs/megapipe l-wx------ 1 user user 64 Oct 8 14:20 4 -&gt; /mnt/logs/megapipe (gdb) call close(4) <span class="hljs-variable"><span class="hljs-variable">$3</span></span> = 0 (gdb) shell ls -lah /proc/5946/fd total 0 dr-x------ 2 user user 0 Oct 8 11:27 . dr-xr-xr-x 9 user user 0 Oct 8 11:27 .. lrwx------ 1 user user 64 Oct 8 11:28 0 -&gt; /dev/pts/22 lrwx------ 1 user user 64 Oct 8 11:28 1 -&gt; /dev/pts/22 lrwx------ 1 user user 64 Oct 8 11:27 2 -&gt; /dev/pts/22 l-wx------ 1 user user 64 Oct 8 11:28 3 -&gt; /mnt/logs/megapipe (gdb) quit A debugging session is active. Inferior 1 [process 5946] will be detached. Quit anyway? (y or n) y Detaching from program: /usr/bin/python2.7, process 5946</code> </pre><br>  √úberpr√ºfen des Remote-Servers remote-server.example.com <br><br><pre> <code class="bash hljs">[user@localhost ~]$ ls -lah 123.txt -rw-rw-r-- 1 user user 38M Oct 8 14:21 123.txt</code> </pre><br>  Daten gehen, wir √ºberpr√ºfen einen Problemserver <br><br><pre> <code class="bash hljs">[user@localhost ~]$ ls -lah /mnt/logs/ total 7.9M drwxr-xr-x 2 user user 1.0K Oct 8 11:28 . drwxr-xr-x 4 root root 1.0K Oct 8 10:55 .. -rw-rw-r-- 1 user user 7.9M Oct 8 14:17 123.txt prw-rw-r-- 1 user user 0 Oct 8 14:22 megapipe</code> </pre><br>  Daten gespeichert, Problem behoben. <br><br>  Ich nutze diese Gelegenheit, um meinen Kollegen bei Degiro meine Gr√º√üe zu √ºbermitteln. <br>  H√∂ren Sie Radio T-Podcasts. <br><br>  Gut zu allen. <br><br>  Als Hausaufgabe schlage ich vor, dar√ºber nachzudenken, was in den Dateideskriptoren des Katzen- und Schlafprozesses enthalten sein wird, wenn Sie diesen Befehl ausf√ºhren: <br><br><pre> <code class="bash hljs">[user@localhost ~]$ cat /dev/zero 2&gt;/dev/null| sleep 10000</code> </pre></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de471038/">https://habr.com/ru/post/de471038/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de471026/index.html">TypeScript Macht niemals</a></li>
<li><a href="../de471028/index.html">ROS LKW Wagen. Teil 6. Kilometerz√§hler mit Radgebern, Raumkarte, Lidar</a></li>
<li><a href="../de471032/index.html">Unsichtbares Foto</a></li>
<li><a href="../de471034/index.html">Interview mit Pornhub Web Developer</a></li>
<li><a href="../de471036/index.html">Lebe und lerne. Teil 5. Selbstbildung: Rei√ü dich zusammen</a></li>
<li><a href="../de471040/index.html">[Lesezeichen] PDF- und ePUB-Version des React-Handbuchs</a></li>
<li><a href="../de471042/index.html">Probleml√∂sung mit pwnable.kr 25 - otp. Gr√∂√üenbeschr√§nkung f√ºr Linux-Dateien</a></li>
<li><a href="../de471044/index.html">Sass MediaScreen - Definieren von CSS-Ger√§ten</a></li>
<li><a href="../de471046/index.html">Stilvolle Avalonia</a></li>
<li><a href="../de471048/index.html">Reagieren + Mobx: Was ist der Sinn?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>