<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ ğŸ‘§ğŸ½ ğŸš£ğŸ¿ Kami menerapkan OSGI di platform Karaf ğŸ‘¨ğŸ¿â€ğŸ¨ ğŸšµ ğŸš¶ğŸ¾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="OSGI tidak sulit 
 Saya telah bertemu berkali-kali bahwa OSGI sulit. Dan terlebih lagi, dia sendiri pernah memiliki pendapat seperti itu. Tahun 2009, ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Kami menerapkan OSGI di platform Karaf</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/435444/"><h2>  OSGI tidak sulit </h2><br>  Saya telah bertemu berkali-kali bahwa OSGI sulit.  Dan terlebih lagi, dia sendiri pernah memiliki pendapat seperti itu.  Tahun 2009, tepatnya.  Pada saat itu, kami mengumpulkan proyek menggunakan Maven Tycho, dan menyebarkannya ke Equinox.  Dan itu benar-benar lebih sulit daripada mengembangkan dan merakit proyek untuk JavaEE (pada saat itu versi EJB 3 baru saja muncul, yang kami beralih ke).  Equinox jauh lebih nyaman daripada Weblogic, misalnya, dan manfaat OSGI tidak jelas bagi saya saat itu. <br><br>  Tapi kemudian, setelah bertahun-tahun, saya harus memulai proyek di pekerjaan baru, yang disusun berdasarkan Apache Camel dan Apache Karaf.  Ini bukan ide saya, saya sudah lama mengenal Camel, dan memutuskan untuk membaca tentang Karaf, bahkan tanpa tawaran.  Saya membacanya suatu malam, dan menyadari - ini dia, sederhana dan siap pakai, solusi yang hampir sama untuk beberapa masalah khas JavaEE, mirip dengan yang pernah saya lakukan pada lutut saya menggunakan Weblogic WLST, Jython, dan Maven Aether. <br><br>  Jadi, katakanlah Anda memutuskan untuk mencoba OSGI di platform Karaf.  Di mana kita mulai? <br><a name="habracut"></a><br><h3>  Jika Anda menginginkan pemahaman yang lebih dalam </h3><br>  Anda tentu saja dapat memulai dengan membaca dokumentasi.  Dan itu mungkin dengan HabrÃ© - ada artikel yang sangat bagus di sini, katakanlah dulu sekali.  Tetapi secara umum, karaf menerima begitu sedikit perhatian.  Ada beberapa ulasan lagi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ini</a> atau <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ini</a> .  Lebih baik untuk tidak menyebutkan karaf ini.  Seperti yang mereka katakan, jangan baca koran Soviet malam ini ... karena mereka akan memberi tahu Anda di sana bahwa karaf adalah kerangka kerja OSGI - jadi Anda tidak percaya.  Kerangka OSGI adalah Apache Felix atau Eclipse Equinox, atas dasar yang hanya bekerja karaf.  Anda dapat memilih salah satu dari mereka. <br><br>  Perlu dicatat bahwa ketika Jboss Fuse, atau Apache ServiceMix disebutkan, itu harus dibaca sebagai "Karaf, dengan komponen yang sudah diinstal", yaitu.  sebenarnya - hal yang sama, hanya dikumpulkan oleh vendor.  Saya tidak akan menyarankan memulai dengan ini dalam praktik, tetapi sangat mungkin untuk membaca artikel ulasan tentang ServiceMix, misalnya. <br><br>  Untuk memulainya, saya akan mencoba menentukan secara singkat di sini apa OSGI itu dan untuk apa OSGI itu digunakan. <br><br>  Secara umum, OSGI adalah alat untuk membuat aplikasi Java dari modul.  Analog yang dekat dapat dianggap, misalnya, JavaEE, dan sampai batas tertentu wadah OSGI dapat mengeksekusi modul JavaEE (katakanlah, aplikasi web dalam bentuk Perang), dan di sisi lain, banyak wadah JavaEE mengandung OSGI di dalam sebagai cara menerapkan modularitas "untuk diri mereka sendiri ".  Artinya, JavaEE dan OSGI adalah hal-hal yang mirip dengan kompatibilitas, dan berhasil saling melengkapi. <br><br>  Bagian penting dari setiap sistem modular adalah definisi dari modul itu sendiri.  Dalam kasus OSGI, modul ini disebut bundel, dan itu adalah arsip jar yang terkenal untuk semua pengembang dengan beberapa tambahan (yaitu, sangat mirip di sini, misalnya, untuk perang atau telinga).  Dengan analogi dengan JavaEE, bundel dapat mengekspor dan mengimpor layanan, yang pada dasarnya adalah metode kelas (yaitu, layanan adalah antarmuka, atau semua metode umum kelas). <br><br>  Metadata bundel tidak asing bagi semua META-INF / MANIFEST.MF.  Header manifes OSGI tidak bersinggungan dengan header untuk JRE, masing-masing, di luar bundel wadah OSGI adalah toples biasa.  Penting bahwa di antara metadata ada: <br><br><pre><code class="plaintext hljs">Bundle-SymbolicName: com.example.myosgi Bundle-Version: 1.0.0</code> </pre> <br>  Ini adalah "koordinat" bundel, dan fakta bahwa kita dapat memiliki dua atau lebih yang diinstal secara bersamaan dan versi kerja dari bundel yang sama dalam satu wadah adalah penting. <br><br>  Mirip dengan JavaEE, bundel memiliki siklus hidup yang terlihat seperti ini: <img src="https://habrastorage.org/getpro/habr/post_images/b71/a55/263/b71a5526390ea0fd4eaf02a3d5edc67a.png" alt="gambar">  Selain layanan, bundel juga dapat mengimpor dan mengekspor paket (paket, dalam arti biasa untuk java).  Paket yang diekspor didefinisikan di dalam bundel, dan dibuat tersedia untuk komponen lain ketika bundel diinstal pada sistem.  Yang diimpor didefinisikan di suatu tempat dari luar, harus diekspor oleh seseorang, dan diberikan kepada bundel oleh wadah sebelum dapat mulai bekerja. <br><br>  Paket impor dapat dinyatakan opsional, serta layanan impor.  Dan cukup signifikan bahwa impor dan ekspor mengandung indikasi versi (atau rentang versi). <br><br><h4>  Perbedaan dari JavaEE </h4><br>  Yah, bagus juga mereka sama - kami mengerti.  Dan bagaimana perbedaannya? <br><br>  Menurut pendapat saya, perbedaan utama adalah bahwa OSGI memberi kita lebih banyak fleksibilitas.  Setelah bundel dalam keadaan MULAI, kemungkinan hanya dibatasi oleh imajinasi Anda.  Katakanlah Anda dapat dengan mudah membuat utas (ya, ya, saya tahu tentang ManagedExecutorService), kumpulan koneksi ke basis data, dll.  Sebuah wadah tidak mengambil kendali atas semua sumber daya sampai tingkat yang sama seperti JavaEE. <br><br>  Anda dapat mengekspor layanan baru dalam proses.  Coba katakan di JavaEE secara dinamis buat servlet baru?  Dan di sini sangat mungkin, apalagi, wadah servle karaf yang dibuat atas dasar dermaga akan segera terdeteksi oleh servlet yang Anda buat dan akan tersedia untuk klien di URL tertentu. <br><br>  Meskipun ini sedikit penyederhanaan, tetapi jika aplikasi JavaEE dalam bentuk klasiknya terutama terdiri dari komponen: <br><br><ul><li>  pasif, menunggu panggilan dari klien </li><li>  didefinisikan secara statis, yaitu, pada saat penyebaran aplikasi. </li></ul><br>  Di sisi lain, aplikasi berbasis OSGI dapat berisi: <br><br><ul><li>  komponen terjadwal aktif dan pasif, melakukan jajak pendapat, baik, mendengarkan soket, dll. </li><li>  layanan dapat didefinisikan dan dipublikasikan secara dinamis </li><li>  Anda dapat berlangganan acara kerangka kerja, misalnya, mendengarkan pendaftaran layanan, bundel, dll., Menerima tautan ke bundel dan layanan lain, dan melakukan lebih banyak lagi. </li></ul><br>  Ya, pada JavaEE, banyak dari ini juga sebagian mungkin (misalnya, melalui JNDI), tetapi dalam kasus OSGI, dalam praktiknya menjadi lebih mudah.  Meskipun mungkin ada beberapa risiko lagi di sini. <br><br><h4>  Perbedaan antara karaf dan OSGI murni </h4><br>  Selain kerangka karaf, ada banyak hal berguna.  Pada dasarnya, karaf adalah alat untuk mengelola kerangka kerja OSGI dengan nyaman - memasang bundel (termasuk grup) di sana, mengonfigurasinya, memantau, menjelaskan model peran dan memastikan keamanan, dan sejenisnya. <br><br><h2>  Dan mari kita berlatih? </h2><br>  Kalau begitu, mari kita mulai segera dengan instalasi.  Tidak banyak yang bisa ditulis di sini - buka karaf.apache.org, unduh paket distribusi, buka paketnya.  Versi karaf berbeda dalam mendukung spesifikasi OSGI yang berbeda (4, 5 atau 6), dan versi Java.  Saya tidak merekomendasikan keluarga 2.x, tetapi di sini ada 3 (jika Anda memiliki Java 8, seperti milik saya), dan 4 dapat digunakan, meskipun hari ini hanya keluarga 4.x yang berkembang (versi 4.2.2 saat ini, mendukung OSGI 6 dan Java hingga 10). <br><br>  Karaf bekerja dengan baik di Windows dan Linux, semua yang Anda butuhkan untuk membuat layanan dan autorun tersedia.  Dukungan untuk MacOS dan banyak jenis Unix lainnya juga dinyatakan. <br><br>  Anda biasanya dapat memulai karaf segera jika Anda menggunakan Internet.  Jika tidak, maka biasanya layak memperbaiki file konfigurasi, yang menunjukkan di mana Anda memiliki repositori maven.  Biasanya itu akan menjadi Nexus perusahaan, atau katakan Artifactory, siapa pun suka apa.  Konfigurasi karaf terletak di folder distribusi dll.  Nama-nama file konfigurasi tidak terlalu jelas, tetapi dalam hal ini Anda memerlukan file org.ops4j.pax.url.mvn.cfg.  Format file ini adalah properti java. <br><br>  Anda dapat menentukan repositori di file konfigurasi itu sendiri, mendaftar daftar URL di pengaturan, atau hanya menunjukkan di mana pengaturan Anda.xml berada.  Di sana, karaf akan mengambil lokasi proxy Anda, yang biasanya perlu diketahui di intranet. <br><br>  Kafar membutuhkan beberapa port, ini adalah HTTP, HTTPS (jika web dikonfigurasi, secara default tidak), SSH, RMI, JMX.  Jika mereka sibuk dengan Anda, atau Anda ingin menjalankan beberapa salinan pada host yang sama, Anda harus mengubahnya juga.  Ada sekitar lima port ini. <br><br>  Port seperti jmx dan rmi - di sini: org.apache.karaf.management.cfg, ssh - org.apache.karaf.shell.cfg, untuk mengubah port http / https, Anda perlu membuat (kemungkinan besar tidak) file / etc / file org.ops4j.pax.web.cfg, dan tulis nilai org.osgi.service.http.port = port yang Anda butuhkan di dalamnya. <br><br>  Maka Anda pasti bisa memulainya, dan sebagai aturan, semuanya akan mulai.  Untuk penggunaan industri, jelas, Anda harus membuat perubahan pada file bin / setenv, atau bin / setenv.bat, misalnya, untuk mengalokasikan jumlah memori yang diperlukan, tetapi pertama-tama, untuk melihat, itu tidak perlu. <br><br>  Anda dapat memulai Karaf segera dengan konsol, perintah karaf, atau Anda dapat menjalankannya di latar belakang dengan perintah mulai server, dan kemudian terhubung ke sana melalui SSH.  Ini adalah SSH yang sepenuhnya standar, dengan dukungan untuk SCP, dan SFTP.  Anda dapat menjalankan perintah, dan menyalin file bolak-balik.  Dimungkinkan untuk terhubung dengan klien mana pun, misalnya, alat favorit saya adalah Far NetBox.  Login tersedia dengan login dan kata sandi, serta dengan kunci.  Di jeroan ayam itik jsch, dengan semua yang tersirat. <br><br>  Saya sarankan memiliki jendela konsol tambahan segera untuk melihat log yang terletak di data / log / karaf.log (dan file lain biasanya ada di sana, meskipun ini dapat disesuaikan).  Log berguna bagi Anda, dari pesan singkat di konsol, tidak semuanya jelas. <br><br>  Saya akan menyarankan menginstal web segera, dan konsol web hawtio.  Dua hal ini akan membuat Anda lebih mudah untuk menavigasi apa yang terjadi dalam wadah dan mengarahkan proses dari sana ke tingkat yang luas (sebagai bonus, Anda akan mendapatkan jolokia dan kemampuan untuk memantau melalui http).  Instalasi hawtio dilakukan oleh dua perintah dari konsol karaf ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">seperti dijelaskan di sini</a> ), dan sayangnya, hari ini versi karaf 3.x tidak lagi didukung (Anda harus mencari versi hawtio yang lebih lama). <br><br>  Di luar kotak, https tidak akan langsung, untuk ini Anda perlu melakukan beberapa upaya seperti menghasilkan sertifikat, dll. Implementasinya didasarkan pada dermaga, jadi semua upaya ini sebagian besar dilakukan dengan cara yang sama. <br><br><h2>  Oke, sudah mulai, selanjutnya apa? </h2><br><img src="https://habrastorage.org/webt/lh/ty/ge/lhtygefalzjfywb-3lr088qvrha.png"><br><br>  Sebenarnya apa yang kamu harapkan?  Saya bilang itu ssh.  Tab berfungsi, jika itu. <br><br>  Sudah waktunya untuk menginstal beberapa aplikasi.  Aplikasi untuk OSGI adalah bundel, atau terdiri dari beberapa bundel.  Karaf dapat menggunakan aplikasi dalam beberapa format: <br><br><ul><li>  Bundel toples, dengan atau tanpa manifes OSGI </li><li>  xml mengandung Spring DM atau Blueprint </li><li>  xml berisi fitur yang disebut, yang merupakan kumpulan bundel, fitur lain, dan sumber daya (file konfigurasi) </li><li>  Arsip .kar yang berisi beberapa fitur dan repositori maven dengan dependensi </li><li>  Aplikasi JavaEE (dalam beberapa kondisi tambahan), misalnya .war </li></ul><br>  Ada beberapa cara untuk melakukan ini: <br><br><ul><li>  menempatkan aplikasi dalam folder deploy </li><li>  instal dari konsol dengan perintah install </li><li>  instal fitur dengan perintah dari fitur: install console </li><li>  kar: instal </li></ul><br>  Ya, secara umum, ini sangat mirip dengan apa yang bisa dilakukan oleh wadah JavaEE biasa, tetapi agak lebih nyaman (saya akan mengatakan itu jauh lebih nyaman). <br><br><h3>  Guci sederhana </h3><br>  Opsi termudah adalah memasang toples biasa.  Jika Anda memilikinya di repositori maven, maka perintahnya cukup untuk menginstal: <br><br><pre> <code class="bash hljs">install mvn:groupId/artifactId/version</code> </pre> <br>  Pada saat yang sama, Karaf menyadari bahwa ia memiliki kendi biasa di depannya, dan memprosesnya, membuat bungkus bundel dengan cepat, yang disebut  bungkus, menghasilkan manifes default, dengan paket impor dan ekspor. <br><br>  Rasa memasang hanya sebuah toples biasanya tidak banyak, karena bundel ini akan pasif - hanya mengekspor kelas yang akan tersedia untuk bundel lain. <br><br>  Metode ini digunakan untuk menginstal komponen seperti Apache Commons Lang, misalnya: <br><br><pre> <code class="bash hljs">install mvn:org.apache.commons.lang3/commons-lang/3.8.1</code> </pre> <br>  Tapi itu tidak berhasil :) Berikut adalah koordinat yang benar: <br><br><pre> <code class="bash hljs">install mvn:org.apache.commons/commons-lang3/3.8.1</code> </pre> <br>  Mari kita lihat apa yang terjadi: list -u akan menunjukkan kepada kita bundel dan sumbernya: <br><br><pre> <code class="bash hljs">karaf@root()&gt; list -u START LEVEL 100 , List Threshold: 50 ID | State | Lvl | Version | Name | Update location ------------------------------------------------------------------------------------------------- 87 | Installed | 80 | 3.8.1 | Apache Commons Lang | mvn:org.apache.commons/commons-lang3/3.8.1 88 | Installed | 80 | 3.6.0 | Apache Commons Lang | mvn:org.apache.commons/commons-lang3/3.6</code> </pre> <br>  Seperti yang Anda lihat, sangat mungkin untuk menginstal dua versi dari satu komponen.  Perbarui lokasi - ini adalah tempat kami memperoleh bundel, dan di mana ia dapat diperbarui jika perlu. <br><br><h3>  Konteks guci dan pegas </h3><br>  Jika ada Konteks Musim Semi di dalam botol Anda, segalanya menjadi lebih menarik.  Karaf Deployer secara otomatis mencari konteks xml di folder META-INF / spring, dan membuatnya jika semua bundel eksternal yang diperlukan oleh bundel telah berhasil ditemukan. <br><br>  Dengan demikian, semua layanan yang ada di dalam konteks sudah akan mulai.  Jika Anda memiliki Musim Semi Unta di sana, misalnya, rute Unta akan mulai juga.  Ini berarti bahwa kami mengatakan layanan REST, atau layanan yang mendengarkan pada port TCP, Anda sudah dapat memulai.  Tentu saja, meluncurkan beberapa layanan mendengarkan pada satu port tidak akan berhasil seperti itu. <br><br><h3>  Hanya pegas konteks XML </h3><br>  Jika Anda memiliki, misalnya, definisi JDBC DataSources di dalam Spring Context, maka Anda dapat menginstalnya secara terpisah di Karaf.  Yaitu  ambil file xml yang hanya berisi DataSource dalam bentuk &lt;bean&gt;, atau set komponen lainnya, Anda bisa meletakkannya di folder deploy.  Konteks akan diluncurkan dengan cara standar.  Satu-satunya masalah adalah bahwa Sumber Data yang dibuat dengan cara ini tidak akan terlihat oleh bundel lain.  Mereka perlu diekspor ke OSGI sebagai layanan.  Tentang ini - sesaat kemudian. <br><br><h3>  Musim semi dm </h3><br>  Apa perbedaan antara Spring DM (versi yang mendukung OSGI) dan Spring klasik?  Jadi dalam kasus klasik, semua biji dalam konteks dibuat pada tahap inisialisasi konteks.  Yang baru tidak bisa muncul, yang lama tidak akan kemana-mana.  Dalam kasus OSGI, bundel baru dapat diinstal dan bundel lama dihapus.  Lingkungan menjadi lebih dinamis, Anda perlu merespons. <br><br>  Metode respons disebut layanan.  Suatu layanan biasanya merupakan antarmuka tertentu, dengan metode sendiri, yang diterbitkan oleh beberapa bundel.  Layanan memiliki metadata yang memungkinkannya untuk dicari dan dibedakan dari layanan lain yang mengimplementasikan antarmuka serupa (jelas, dari DataSource lain).  Metadata adalah sekumpulan properti nilai kunci sederhana. <br><br>  Karena layanan dapat muncul dan menghilang, mereka yang membutuhkannya dapat berlangganan layanan saat startup atau mendengarkan acara untuk mengetahui tentang penampilan atau menghilangnya mereka.  Pada tingkat Spring DM, dalam XML, ini diimplementasikan sebagai dua elemen, layanan dan referensi, yang tujuan dasarnya cukup sederhana: menerbitkan kacang yang ada dari konteksnya sebagai layanan, dan berlangganan ke layanan eksternal dengan menerbitkannya ke konteks musim semi saat ini. <br><br>  Dengan demikian, ketika menginisialisasi bundel seperti itu, wadah akan menemukan layanan eksternal yang dibutuhkannya, dan menerbitkan bundel yang diimplementasikan di dalamnya, membuatnya dapat diakses dari luar.  Bundel dimulai hanya setelah tautan layanan diselesaikan. <br><br>  Bahkan, semuanya sedikit lebih rumit, karena bundel dapat menggunakan daftar layanan serupa, dan berlangganan segera ke daftar.  Yaitu  suatu layanan, secara umum, memiliki properti seperti kardinalitas, yang mengambil nilai 0..N.  Dalam hal ini, langganan, di mana 0..1 ditunjukkan, menggambarkan layanan opsional, dan dalam hal ini bundel mulai berhasil bahkan jika tidak ada layanan seperti itu dalam sistem (dan alih-alih tautan ke sana, ia akan mendapatkan sebuah rintisan). <br><br>  Saya perhatikan bahwa layanan hanyalah antarmuka apa saja (atau Anda dapat menerbitkan kelas saja), sehingga Anda dapat menerbitkan java.util.Map dengan data sebagai layanan. <br><br>  Antara lain, layanan memungkinkan Anda menentukan metadata, dan referensi memungkinkan Anda untuk mencari layanan dengan metadata ini. <br><br><h3>  Cetak Biru </h3><br>  Blueprint adalah inkarnasi Spring DM yang lebih baru, yang sedikit lebih sederhana.  Yaitu, jika di Spring Anda memiliki elemen XML khusus, maka mereka tidak ada di sini, karena tidak perlu.  Kadang-kadang ini masih menyebabkan ketidaknyamanan, tetapi terus terang - jarang.  Jika Anda tidak memigrasi proyek dari Spring, Anda dapat segera mulai dengan Cetak Biru. <br><br>  Intinya di sini adalah sama - itu XML, yang menggambarkan komponen dari mana konteks bundel dirakit.  Bagi mereka yang mengenal Spring, tidak ada yang asing sama sekali. <br><br>  Berikut adalah contoh cara menggambarkan DataSource dan mengekspornya sebagai layanan: <br><br><pre> <code class="xml hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">blueprint</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">xmlns</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"http://www.osgi.org/xmlns/blueprint/v1.0.0"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">bean</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">id</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"dataSource"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">class</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"oracle.jdbc.pool.OracleDataSource"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">property</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"URL"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">value</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"URL"</span></span></span><span class="hljs-tag">/&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">property</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"user"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">value</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"USER"</span></span></span><span class="hljs-tag">/&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">property</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"password"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">value</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"PASSWORD"</span></span></span><span class="hljs-tag">/&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">bean</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">service</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">interface</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"javax.sql.DataSource"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">ref</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"dataSource"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">id</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"ds"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">service-properties</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">entry</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">key</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"osgi.jndi.service.name"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">value</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"jdbc/ds"</span></span></span><span class="hljs-tag">/&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">service-properties</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">service</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">blueprint</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br>  Yah, kami menyebarkan file ini ke folder penempatan, dan melihat hasil dari perintah daftar.  Mereka melihat bahwa bundel itu tidak mulai - dalam status Indtalled.  Kami mencoba memulai, dan kami mendapatkan pesan kesalahan. <br><br>  Sekarang dalam daftar bundel dalam status Gagal.  Ada apa?  Jelas, ia juga membutuhkan dependensi, dalam hal ini, Jar dengan kelas Oracle JDBC, atau lebih tepatnya, paket oracle.jdbc.pool. <br>  Kami menemukan tabung yang diperlukan di repositori, atau unduh dari situs Oracle, dan instal, seperti yang dijelaskan sebelumnya.  Sumber Data kami telah dimulai. <br><br>  Bagaimana cara menggunakan semua ini?  Tautan layanan disebut dalam referensi Cetak Biru (di suatu tempat, dalam konteks bundel lain): <br><br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">reference</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">id</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"dataSource"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">interface</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"javax.sql.DataSource"</span></span></span><span class="hljs-tag">/&gt;</span></span></code> </pre> <br>  Kemudian, kacang ini menjadi, seperti biasa, ketergantungan untuk kacang lainnya (dalam contoh unta-sql): <br><br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">bean</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">id</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"sql"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">class</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"org.apache.camel.component.sql.SqlComponent"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">property</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"dataSource"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">ref</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"dataSource"</span></span></span><span class="hljs-tag">/&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">bean</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br><h3>  Jar dan Aktivator </h3><br>  Cara kanonik untuk menginisialisasi bundel adalah dengan menggunakan kelas yang mengimplementasikan antarmuka Activator.  Ini adalah antarmuka siklus hidup khas yang berisi metode mulai dan berhenti yang melewati <i>konteks</i> .  Di dalamnya, bundel biasanya memulai utasnya, jika perlu, mulai mendengarkan port, berlangganan layanan eksternal menggunakan OSGI API, dan sebagainya.  Ini mungkin cara yang paling kompleks, paling mendasar, dan paling fleksibel.  Selama tiga tahun saya tidak pernah membutuhkannya. <br><br><h2>  Pengaturan dan konfigurasi </h2><br>  Jelaslah bahwa konfigurasi DataSource seperti itu, seperti yang diperlihatkan dalam contoh, hanya beberapa orang yang perlu.  Login, kata sandi, dan banyak lagi, semuanya dikodekan dalam XML.  Perlu untuk mengambil parameter ini. <br><br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">property</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"url"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">value</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"${oracle.ds.url}"</span></span></span><span class="hljs-tag">/&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">property</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"user"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">value</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"${oracle.ds.user}"</span></span></span><span class="hljs-tag">/&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">property</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"password"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">value</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"${oracle.ds.password}"</span></span></span><span class="hljs-tag">/&gt;</span></span></code> </pre> <br>  Solusinya cukup sederhana, dan mirip dengan yang digunakan dalam Spring klasik: pada titik tertentu dalam konteks siklus hidup, nilai properti diganti dari berbagai sumber. <br><br>  Pada ini kita akan mengakhiri bagian pertama.  Jika ada minat pada topik ini, maka untuk dilanjutkan.  Kami akan mempertimbangkan cara merakit aplikasi dari bundel, mengkonfigurasi, memantau, dan secara otomatis menggunakan sistem pada platform ini. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id435444/">https://habr.com/ru/post/id435444/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id435430/index.html">Berita paling keren CES 2019</a></li>
<li><a href="../id435432/index.html">Tahun Baru, GitHub Baru: Repositori Pribadi Gratis Tanpa Batas</a></li>
<li><a href="../id435436/index.html">5 tren dalam infrastruktur TI: perkiraan untuk 2019</a></li>
<li><a href="../id435438/index.html">PHP: mengubah struktur basis data dalam pengembangan tim</a></li>
<li><a href="../id435442/index.html">Saluran perubahan</a></li>
<li><a href="../id435446/index.html">Algoritma Verhuff untuk sistem bilangan genap acak</a></li>
<li><a href="../id435448/index.html">Tentang pengalaman berkomunikasi dengan generator sinyal melalui QTcpSocket dan SCPI</a></li>
<li><a href="../id435450/index.html">Selamat Tahun Baru, Selamat Baru MQTT / UDP</a></li>
<li><a href="../id435452/index.html">Pengujian ujung ke ujung dari layanan microser dengan Catcher</a></li>
<li><a href="../id435454/index.html">AOP vs Fitur</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>