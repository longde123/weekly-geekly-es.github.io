<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üõ≥Ô∏è üõåüèª üëÇ Schnelle Protokollierung üí¶ üëÉüèª ‚ò£Ô∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In diesem Artikel habe ich Benchmarks f√ºr die privatesten Anrufe von Loggern gesetzt. Ich habe alle Experimente mit log4net und NLog unter Intel Windo...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Schnelle Protokollierung</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/456488/"><p>  In diesem Artikel habe ich Benchmarks f√ºr die privatesten Anrufe von Loggern gesetzt.  Ich habe alle Experimente mit log4net und NLog unter Intel Windows 10 x64 mit M.2 SSD durchgef√ºhrt. </p><br><p>  Rohergebnisse k√∂nnen auf <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">GitHub</a> angezeigt werden.  Der Code befindet sich im selben Repository (zum Ausf√ºhren ben√∂tigen Sie .Net 4.7.2 + Microsoft Visual Studio 2017+). </p><br><p>  Was, wie und warum - unter dem Schnitt. </p><a name="habracut"></a><br><p>  Um lange nicht zu lesen, die Ergebnistabelle: </p><br><div class="scrollable-table"><table><thead><tr><th>  Methode </th><th>  Mittelwert </th><th>  Fehler </th><th>  Stddev </th></tr></thead><tbody><tr><td>  KeepFileOpen = true, ConcurrentWrites = false, Async = true </td><td>  1.144.677 ns </td><td>  26.3805 ns </td><td>  77,7835 ns </td></tr><tr><td>  KeepFileOpen = true, ConcurrentWrites = true, Async = true </td><td>  1.106.691 ns </td><td>  31.4041 ns </td><td>  87,5421 ns </td></tr><tr><td>  KeepFileOpen = false, ConcurrentWrites = false, Async = true </td><td>  4.804,426 ns </td><td>  110,3406 ns </td><td>  103,2126 ns </td></tr><tr><td>  KeepFileOpen = false, ConcurrentWrites = true, Async = true </td><td>  5,303.602 ns </td><td>  104.3022 ns </td><td>  102,4387 ns </td></tr><tr><td>  KeepFileOpen = true, ConcurrentWrites = false, Async = false </td><td>  5.642,301 ns </td><td>  73,2291 ns </td><td>  68,4986 ns </td></tr><tr><td>  KeepFileOpen = true, ConcurrentWrites = true, Async = false </td><td>  11.834,892 ns </td><td>  82,7578 ns </td><td>  77,4117 ns </td></tr><tr><td>  KeepFileOpen = false, ConcurrentWrites = false, Async = false </td><td>  731.250,539 ns </td><td>  14.612,0117 ns </td><td>  27.444,8998 ns </td></tr><tr><td>  KeepFileOpen = false, ConcurrentWrites = true, Async = false </td><td>  730.271.927 ns </td><td>  11.330.0172 ns </td><td>  10.598,1051 ns </td></tr><tr><td>  CreateLog4NetFromString </td><td>  1.470,662 ns </td><td>  19.9492 ns </td><td>  18.6605 ns </td></tr><tr><td>  CreateNLogFromString </td><td>  228,774 ns </td><td>  2,1315 ns </td><td>  1,8895 ns </td></tr><tr><td>  CreateLog4NetLogger </td><td>  21.046,294 ns </td><td>  284,1171 ns </td><td>  265,7633 ns </td></tr><tr><td>  CreateNLogTypeOfLogger </td><td>  164.487,931 ns </td><td>  3,240.4372 ns </td><td> 3,031.1070 ns </td></tr><tr><td>  CreateNLogDynamicLogger </td><td>  134,459.092 ns </td><td>  1,882.8663 ns </td><td>  1,761.2344 ns </td></tr><tr><td>  FileLoggingLog4NetNoParams </td><td>  8,251.032 ns </td><td>  109,3075 ns </td><td>  102,2463 ns </td></tr><tr><td>  FileLoggingLog4NetSingleReferenceParam </td><td>  8,260,452 ns </td><td>  145,9028 ns </td><td>  136,4776 ns </td></tr><tr><td>  FileLoggingLog4NetSingleValueParam </td><td>  8,378.693 ns </td><td>  121.3003 ns </td><td>  113.4643 ns </td></tr><tr><td>  FileLoggingLog4NetMultipleReferencesParam </td><td>  9,133.136 ns </td><td>  89,7420 ns </td><td>  79,5539 ns </td></tr><tr><td>  FileLoggingLog4NetMultipleValuesParam </td><td>  9.393,989 ns </td><td>  166.0347 ns </td><td>  155.3089 ns </td></tr><tr><td>  FileLoggingNLogNetNoParams </td><td>  6.061,837 ns </td><td>  69,5666 ns </td><td>  65.0726 ns </td></tr><tr><td>  FileLoggingNLogNetSingleReferenceParam </td><td>  6.458,201 ns </td><td>  94,5617 ns </td><td>  88,4530 ns </td></tr><tr><td>  FileLoggingNLogNetSingleValueParam </td><td>  6.460,859 ns </td><td>  95,5435 ns </td><td>  84,6969 ns </td></tr><tr><td>  FileLoggingNLogNetMultipleReferencesParam </td><td>  7,236.886 ns </td><td>  89,7334 ns </td><td>  83,9367 ns </td></tr><tr><td>  FileLoggingNLogNetMultipleValuesParam </td><td>  7.524,876 ns </td><td>  82,8979 ns </td><td>  77,5427 ns </td></tr><tr><td>  NoOpLog4NetNoParams </td><td>  12.684 ns </td><td>  0,0795 ns </td><td>  0,0743 ns </td></tr><tr><td>  NoOpLog4NetSingleReferenceParam </td><td>  10,506 ns </td><td>  0,0571 ns </td><td>  0,0506 ns </td></tr><tr><td>  NoOpLog4NetSingleValueParam </td><td>  12.608 ns </td><td>  0,1012 ns </td><td>  0,0946 ns </td></tr><tr><td>  NoOpLog4NetMultipleReferencesParam </td><td>  48,858 ns </td><td>  0,3988 ns </td><td>  0,3730 ns </td></tr><tr><td>  NoOpLog4NetMultipleValuesParam </td><td>  69,463 ns </td><td>  0,9444 ns </td><td>  0,8834 ns </td></tr><tr><td>  NoOpNLogNetNoParams </td><td>  2,073 ns </td><td>  0,0253 ns </td><td>  0,0225 ns </td></tr><tr><td>  NoOpNLogNetSingleReferenceParam </td><td>  2,625 ns </td><td>  0,0364 ns </td><td>  0,0340 ns </td></tr><tr><td>  NoOpNLogNetSingleValueParam </td><td>  2,281 ns </td><td>  0,0222 ns </td><td>  0,0208 ns </td></tr><tr><td>  NoOpNLogNetMultipleReferencesParam </td><td>  41,525 ns </td><td>  0,4481 ns </td><td>  0,4191 ns </td></tr><tr><td>  NoOpNLogNetMultipleValuesParam </td><td>  57,622 ns </td><td>  0,5341 ns </td><td>  0,4996 ns </td></tr></tbody></table></div><br><h1 id="nooplogging">  NoOpLogging </h1><br><p>  Lassen Sie uns zun√§chst absch√§tzen, wie viel Zeit wir damit verbringen, eine Protokollierungsmethode aufzurufen, was letztendlich zu nichts f√ºhrt.  In den meisten F√§llen (meiner Erfahrung nach) ist das ausf√ºhrliche Debug auf Kampfservern deaktiviert, aber niemand entfernt Anrufe. </p><br><p>  Zun√§chst das Ergebnis: </p><br><div class="scrollable-table"><table><thead><tr><th>  Methode </th><th>  Mittelwert </th><th>  Fehler </th><th>  Stddev </th></tr></thead><tbody><tr><td>  NoOpLog4NetNoParams </td><td>  12.684 ns </td><td>  0,0795 ns </td><td>  0,0743 ns </td></tr><tr><td>  NoOpLog4NetSingleReferenceParam </td><td>  10,506 ns </td><td>  0,0571 ns </td><td>  0,0506 ns </td></tr><tr><td>  NoOpLog4NetSingleValueParam </td><td>  12.608 ns </td><td>  0,1012 ns </td><td>  0,0946 ns </td></tr><tr><td>  NoOpLog4NetMultipleReferencesParam </td><td>  48,858 ns </td><td>  0,3988 ns </td><td>  0,3730 ns </td></tr><tr><td>  NoOpLog4NetMultipleValuesParam </td><td>  69,463 ns </td><td>  0,9444 ns </td><td>  0,8834 ns </td></tr><tr><td>  NoOpNLogNetNoParams </td><td>  2,073 ns </td><td>  0,0253 ns </td><td>  0,0225 ns </td></tr><tr><td>  NoOpNLogNetSingleReferenceParam </td><td>  2,625 ns </td><td>  0,0364 ns </td><td>  0,0340 ns </td></tr><tr><td>  NoOpNLogNetSingleValueParam </td><td>  2,281 ns </td><td>  0,0222 ns </td><td>  0,0208 ns </td></tr><tr><td>  NoOpNLogNetMultipleReferencesParam </td><td>  41,525 ns </td><td>  0,4481 ns </td><td>  0,4191 ns </td></tr><tr><td>  NoOpNLogNetMultipleValuesParam </td><td>  57,622 ns </td><td>  0,5341 ns </td><td>  0,4996 ns </td></tr></tbody></table></div><br><p>  Und der Code: </p><br><pre><code class="plaintext hljs">void Log4NetNoParams() =&gt; _log4Net.Debug("test"); void Log4NetSingleReferenceParam() =&gt; _log4Net.DebugFormat("test {0}", _stringArgument); void Log4NetSingleValueParam() =&gt; _log4Net.DebugFormat("test {0}", _intArgument); void Log4NetMultipleReferencesParam() =&gt; _log4Net.DebugFormat( "test {0} {1} {2} {3} {4} {5} {6} {7} {8}", _stringArgument, _stringArgument, _stringArgument, _stringArgument, _stringArgument, _stringArgument, _stringArgument, _stringArgument, _stringArgument); void Log4NetMultipleValuesParam() =&gt; _log4Net.DebugFormat( "test {0} {1} {2} {3} {4} {5} {6} {7} {8}", _intArgument, _intArgument, _intArgument, _intArgument, _intArgument, _intArgument, _intArgument, _intArgument, _intArgument); void NLogNetNoParams() =&gt; _nlog.Debug("test"); void NLogNetSingleReferenceParam() =&gt; _nlog.Debug("test {0}", _stringArgument); void NLogNetSingleValueParam() =&gt; _nlog.Debug("test {0}", _intArgument); void NLogNetMultipleReferencesParam() =&gt; _nlog.Debug( "test {0} {1} {2} {3} {4} {5} {6} {7} {8}", _stringArgument, _stringArgument, _stringArgument, _stringArgument, _stringArgument, _stringArgument, _stringArgument, _stringArgument, _stringArgument); void NLogNetMultipleValuesParam() =&gt; _nlog.Debug( "test {0} {1} {2} {3} {4} {5} {6} {7} {8}", _intArgument, _intArgument, _intArgument, _intArgument, _intArgument, _intArgument, _intArgument, _intArgument, _intArgument);</code> </pre> <br><p>  Lassen Sie uns zun√§chst feststellen, warum solche Tests ausgew√§hlt wurden: </p><br><ul><li>  Die Experimente wurden an den beliebtesten Bibliotheken durchgef√ºhrt. </li><li><p>  NLog und log4net haben unterschiedliche Funktionssignaturen f√ºr eine kleine Anzahl von Argumenten: </p><br><ul><li>  log4net: </li></ul><br><pre> <code class="plaintext hljs">void DebugFormat(string format, object arg0)</code> </pre> <br><ul><li>  Nlog: </li></ul><br><pre> <code class="plaintext hljs">void Debug(string message, string argument) void Debug&lt;TArgument&gt;(string message, TArgument argument)</code> </pre> <br><ul><li>  Theorie: Bei der √úbertragung eines signifikanten Typs auf log4net sollte ein Boxen auftreten, das einfach Prozessorzeit verbringt und zu nichts f√ºhrt.  Im Fall von NLog gibt es kein solches Verhalten, daher sollte letzteres schneller funktionieren. </li></ul><br></li><li>  Die Signaturen f√ºr eine gro√üe Anzahl von Argumenten in Bibliotheken sind ungef√§hr gleich, daher w√ºrde ich gerne wissen: <br><ul><li>  Wie viel effizienter ist es, Methoden mit einer kleinen Anzahl von Parametern aufzurufen. </li><li>  Gibt es einen Unterschied in der Geschwindigkeit beim Aufrufen der Methode "Is ... Enabled" zwischen den beiden Bibliotheken? </li></ul></li></ul><br><p>  Und nun die Analyse der Ergebnisse: </p><br><ul><li>  Aufgrund der Verwendung generischer Argumente in NLog funktioniert dies schneller, wenn keine direkte Protokollierung erforderlich ist.  Das hei√üt, wenn in Ihrem Debug-Programm die Ebene nur auf dem Testsystem aktiviert ist, kann das √Ñndern der Bibliothek die Software beschleunigen (und das Leben der Benutzer verbessern). </li><li>  Wenn Sie die Protokollierung deaktiviert haben und eine Methode mit einer gro√üen Anzahl von Argumenten aufrufen m√∂chten, ist es effizienter, sie in zwei Teile aufzuteilen.  Aus diesem Grund funktionieren die oben genannten Methodenaufrufe zehnmal schneller. </li><li>  Wenn Sie eine Funktion schreiben, die ein beliebiges Objekt aufnehmen kann, ist es h√§ufig am effektivsten, verwirrt zu sein und eine generische Funktion zu erstellen.  Aufgrund dieser einfachen Optimierung arbeitet der Code schneller (dies zeigt sich deutlich im Zeitunterschied zwischen den Aufrufen von <code>Log4NetSingleReferenceParam</code> und <code>Log4NetSingleValueParam</code> ). </li></ul><br><h1 id="filelogging">  Filelogging </h1><br><p>  Die meisten Programme (nach meinen Beobachtungen) protokollieren die Ergebnisse immer noch in einer Datei, daher w√§hlen wir zum Vergleich diese Operation.  Der Einfachheit halber nehmen wir nur die Konfiguration der Logger, wenn eine Datei ohne Pufferung, ohne zus√§tzliche Sperren usw. in die Datei geschrieben wird. </p><br><p>  Ergebnisse: </p><br><div class="scrollable-table"><table><thead><tr><th>  Methode </th><th>  Mittelwert </th><th>  Fehler </th><th>  Stddev </th></tr></thead><tbody><tr><td>  FileLoggingLog4NetNoParams </td><td>  8,251.032 ns </td><td>  109,3075 ns </td><td>  102,2463 ns </td></tr><tr><td>  FileLoggingLog4NetSingleReferenceParam </td><td>  8,260,452 ns </td><td>  145,9028 ns </td><td>  136,4776 ns </td></tr><tr><td>  FileLoggingLog4NetSingleValueParam </td><td>  8,378.693 ns </td><td>  121.3003 ns </td><td>  113.4643 ns </td></tr><tr><td>  FileLoggingLog4NetMultipleReferencesParam </td><td>  9,133.136 ns </td><td>  89,7420 ns </td><td>  79,5539 ns </td></tr><tr><td>  FileLoggingLog4NetMultipleValuesParam </td><td>  9.393,989 ns </td><td>  166.0347 ns </td><td>  155.3089 ns </td></tr><tr><td>  FileLoggingNLogNetNoParams </td><td>  6.061,837 ns </td><td>  69,5666 ns </td><td>  65.0726 ns </td></tr><tr><td>  FileLoggingNLogNetSingleReferenceParam </td><td>  6.458,201 ns </td><td>  94,5617 ns </td><td>  88,4530 ns </td></tr><tr><td>  FileLoggingNLogNetSingleValueParam </td><td>  6.460,859 ns </td><td>  95,5435 ns </td><td>  84,6969 ns </td></tr><tr><td>  FileLoggingNLogNetMultipleReferencesParam </td><td>  7,236.886 ns </td><td>  89,7334 ns </td><td>  83,9367 ns </td></tr><tr><td>  FileLoggingNLogNetMultipleValuesParam </td><td>  7.524,876 ns </td><td>  82,8979 ns </td><td>  77,5427 ns </td></tr></tbody></table></div><br><p>  Verwendeter Code: </p><br><ul><li>  log4net: </li></ul><br><pre> <code class="plaintext hljs">var roller = new RollingFileAppender(); roller.ImmediateFlush = true; roller.RollingStyle = RollingFileAppender.RollingMode.Once; roller.MaxFileSize = 128 * 1000 * 1000;</code> </pre> <br><ul><li>  Nlog: </li></ul><br><pre> <code class="plaintext hljs">new FileTarget($"target_{_logIndex++}") { ArchiveAboveSize = 128 * 1000 * 1000, MaxArchiveFiles = 16, AutoFlush = true, ConcurrentWrites = false, KeepFileOpen = false };</code> </pre><br><p>  Wie Sie sehen k√∂nnen, ist die Konfiguration der Logger mehr oder weniger √§hnlich und entspricht den Ergebnissen: </p><br><ul><li>  NLog ist etwas schneller als log4net, irgendwo um die 15%. </li><li>  Tests zufolge stellte sich heraus, dass es effizienter ist, weniger Parameter zu protokollieren.  Man sollte jedoch nicht vergessen, dass mit einer gr√∂√üeren Anzahl von Parametern auch die resultierende Zeichenfolge erweitert wurde.  Daher vergleicht die Tabelle NLog nur korrekt mit log4net. </li></ul><br><h1 id="nlog---raznye-sposoby-blokirovok">  NLog - verschiedene Arten von Schl√∂ssern </h1><br><div class="scrollable-table"><table><thead><tr><th>  Methode </th><th>  Mittelwert </th><th>  Fehler </th><th>  Stddev </th></tr></thead><tbody><tr><td>  KeepFileOpen = true, ConcurrentWrites = false, Async = false </td><td>  5.642,301 ns </td><td>  73,2291 ns </td><td>  68,4986 ns </td></tr><tr><td>  KeepFileOpen = true, ConcurrentWrites = true, Async = false </td><td>  11.834,892 ns </td><td>  82,7578 ns </td><td>  77,4117 ns </td></tr><tr><td>  KeepFileOpen = false, ConcurrentWrites = false, Async = false </td><td>  731.250,539 ns </td><td>  14.612,0117 ns </td><td>  27.444,8998 ns </td></tr><tr><td>  KeepFileOpen = false, ConcurrentWrites = true, Async = false </td><td>  730.271.927 ns </td><td>  11.330.0172 ns </td><td>  10.598,1051 ns </td></tr></tbody></table></div><br><p>  Quellcode: </p><br><pre> <code class="plaintext hljs">new FileTarget($"target_{_logIndex++}") { ArchiveAboveSize = 128 * 1000 * 1000, MaxArchiveFiles = 16, AutoFlush = true, ConcurrentWrites = XXXXX, KeepFileOpen = YYYYY };</code> </pre><br><p>  Wenn wir alle m√∂glichen Kombinationen anstelle von XXXXX und JJJJJ einsetzen, erhalten wir den Test aus der Tabelle. </p><br><p>  Die Ergebnisse sind ziemlich vorhersehbar: </p><br><ul><li>  Wenn Sie ConcurrentWrites aktivieren, nimmt das System st√§ndig Mutex und gibt es, was nicht kostenlos ist.  Wie wir jedoch sehen, entspricht das Schreiben einer Zeile in eine Datei ungef√§hr einer Systemsperre. </li><li>  Wie wir sehen, wirkt sich das Schlie√üen und √ñffnen einer Datei noch st√§rker auf die Systemleistung aus.  In den Beispielen mit <code>KeepFileOpen=true</code> wir f√ºr jeden Protokollierungsvorgang eine Datei (zusammen mit Handle) erstellt, auf die Festplatte mit dem Namen Flush geschrieben, Handle zur√ºckgegeben und auch viele Motorhaubenoperationen durchgef√ºhrt.  Infolgedessen sinkt die Geschwindigkeit hunderte Male. </li></ul><br><h1 id="asinhronnoe-loggirovanie-i-raznye-sposoby-blokirovok">  Asynchrone Protokollierung und verschiedene Sperrmethoden </h1><br><p>  Die NLog-Bibliothek kann auch alle E / A-Vorg√§nge f√ºr einen anderen Thread ausf√ºhren und den aktuellen Thread sofort freigeben.  Und er tut es kompetent, indem er die Reihenfolge der Ereignisse beibeh√§lt, alle Daten in Bl√∂cken l√∂scht und in jedem Block eine Ganzzahl eine Ereignisnummer ist (so dass keine zugeschnittenen Zeilen erhalten werden) und so weiter. </p><br><p>  Die Ergebnisse verschiedener nicht blockierender Methoden: </p><br><div class="scrollable-table"><table><thead><tr><th>  Methode </th><th>  Mittelwert </th><th>  Fehler </th><th>  Stddev </th></tr></thead><tbody><tr><td>  KeepFileOpen = true, ConcurrentWrites = false, Async = true </td><td>  1.144.677 ns </td><td>  26.3805 ns </td><td>  77,7835 ns </td></tr><tr><td>  KeepFileOpen = true, ConcurrentWrites = true, Async = true </td><td>  1.106.691 ns </td><td>  31.4041 ns </td><td>  87,5421 ns </td></tr><tr><td>  KeepFileOpen = false, ConcurrentWrites = false, Async = true </td><td>  4.804,426 ns </td><td>  110,3406 ns </td><td>  103,2126 ns </td></tr><tr><td>  KeepFileOpen = false, ConcurrentWrites = true, Async = true </td><td>  5,303.602 ns </td><td>  104.3022 ns </td><td>  102,4387 ns </td></tr></tbody></table></div><br><p>  Der Vergleich von blockierenden und asynchronen Ans√§tzen wird weiter gehen, aber hier - nur der letzte. </p><br><p>  <code>AsyncTargetWrapper</code> Code: </p><br><pre> <code class="plaintext hljs">new AsyncTargetWrapper(fileTargetWithConcurrentWritesAndCloseFileAsync) { OverflowAction = AsyncTargetWrapperOverflowAction.Block, QueueLimit = 10000 }</code> </pre> <br><p>  Wie Sie sehen k√∂nnen, sind die Wrapper-Einstellungen so, dass ein direkter Speicherauszug in die Datei nicht lange dauert.  Somit wird ein gro√üer Puffer akkumuliert, was bedeutet, dass alle ressourcenintensiven Operationen wie "offene Datei" einmal f√ºr den gesamten Block ausgef√ºhrt werden.  Ein solcher Algorithmus erfordert jedoch zus√§tzlichen Speicher (und viel). </p><br><p>  Schlussfolgerungen: </p><br><ul><li>  Wenn eine asynchrone Ausgabe verwendet wird, spielt es keine Rolle, welche Ausgabeeinstellungen f√ºr die Datei verwendet werden.  Sie k√∂nnen die Datei jedes Mal √∂ffnen und schlie√üen. Mit einem gro√üen Puffer ist sie fast nicht wahrnehmbar. </li><li>  Alle Messungen gelten nur f√ºr den Fall, dass Daten mit ungef√§hr der gleichen Geschwindigkeit wie das F√ºllen von Puffern auf die Festplatte gesp√ºlt werden (ich habe dies aufgrund des schnellen Dateisystems + nat√ºrlicher Pausen zwischen den Messungen getan). </li></ul><br><h1 id="sinhronnoe-i-asinhronnoe-loggirovanie">  Synchrone und asynchrone Protokollierung </h1><br><div class="scrollable-table"><table><thead><tr><th>  Ergebnisse: </th><th>  Methode </th><th>  Mittelwert </th><th>  Fehler </th><th>  Stddev </th><th>  Median </th></tr></thead><tbody><tr><td>  KeepFileOpen = true, ConcurrentWrites = false, Async = true </td><td>  1,835,730 ns </td><td>  55,3980 ns </td><td>  163,3422 ns </td><td>  1.791,901 ns </td></tr><tr><td>  FileLoggingLog4NetNoParams </td><td>  7.076,251 ns </td><td>  41,5518 ns </td><td>  38.8676 ns </td><td>  7.075,394 ns </td></tr><tr><td>  FileLoggingNLogNetNoParams </td><td>  5.438,306 ns </td><td>  42.0170 ns </td><td>  37,2470 ns </td><td>  5,427.805 ns </td></tr><tr><td>  NoOpLog4NetNoParams </td><td>  11.063 ns </td><td>  0,0141 ns </td><td>  0,0125 ns </td><td>  11.065 ns </td></tr><tr><td>  NoOpNLogNetNoParams </td><td>  1,045 ns </td><td>  0,0037 ns </td><td>  0,0033 ns </td><td>  1,045 ns </td></tr></tbody></table></div><br><p>  Schlussfolgerungen: </p><br><ul><li>  Trotz der schnellen Festplatte (in meinem Fall - M.2 SSD) beschleunigt das Schreiben in eine Datei in einem anderen Stream die Arbeit um ein Vielfaches.  Wenn Ihre Anwendung auf Festplatten schreibt und sogar auf einer virtuellen Maschine ausgef√ºhrt wird, ist die Verst√§rkung noch gr√∂√üer. </li><li>  Trotz des gleichm√§√üig schnellen Betriebs des asynchronen Codes f√ºhrt das Fehlen der Protokollierung zu einem noch gr√∂√üeren Gewinn (wenn auch je nach Bibliothek geringf√ºgig unterschiedlich). </li></ul><br><h1 id="sozdanie-loggerov">  Logger erstellen </h1><br><p>  Ergebnisse: </p><br><div class="scrollable-table"><table><thead><tr><th>  Methode </th><th>  Mittelwert </th><th>  Fehler </th><th>  Stddev </th></tr></thead><tbody><tr><td>  CreateLog4NetFromString </td><td>  1.470,662 ns </td><td>  19.9492 ns </td><td>  18.6605 ns </td></tr><tr><td>  CreateNLogFromString </td><td>  228,774 ns </td><td>  2,1315 ns </td><td>  1,8895 ns </td></tr><tr><td>  CreateLog4NetLogger </td><td>  21.046,294 ns </td><td>  284,1171 ns </td><td>  265,7633 ns </td></tr><tr><td>  CreateNLogTypeOfLogger </td><td>  164.487,931 ns </td><td>  3,240.4372 ns </td><td>  3,031.1070 ns </td></tr><tr><td>  CreateNLogDynamicLogger </td><td>  134,459.092 ns </td><td>  1,882.8663 ns </td><td>  1,761.2344 ns </td></tr></tbody></table></div><br><p>  Was wurde getestet: </p><br><pre> <code class="plaintext hljs">[Benchmark] public object CreateLog4NetFromString() { return LogManager.GetLogger("my-logger_" + (Interlocked.Increment(ref _log4NetStringLogIndex) % 1000)); } [Benchmark] public object CreateNLogFromString() { return NLog.LogManager.GetLogger("my-logger_" + (Interlocked.Increment(ref _nLogStringLogIndex) % 1000)); } [Benchmark] public object CreateLog4NetLogger() { return new [] { LogManager.GetLogger(typeof(BaseTest)), // x16 times }; } [Benchmark] public object CreateNLogTypeOfLogger() { return new[] { NLog.LogManager.GetCurrentClassLogger(typeof(BaseTest)), // x16 times }; } [Benchmark] public object CreateNLogDynamicLogger() { return new[] { NLog.LogManager.GetCurrentClassLogger(), // x16 times }; }</code> </pre> <br><p>  Wichtige Bemerkung: Leider war es f√ºr mich schwierig, einen reproduzierbaren Benchmark zu erstellen, der nicht zu Speichermangel f√ºhrte, aber unterschiedliche Logger erzeugte (d. H. F√ºr verschiedene Typen, f√ºr verschiedene Zeilen usw.). </p><br><p>  Nachdem ich jedoch die Arbeit von Bibliotheken untersucht hatte, stellte ich fest, dass fast die schwierigsten Operationen ausgef√ºhrt werden, um einen Protokollierungsschl√ºssel zu erstellen (d. H. Einen Namen zu bestimmen, generische Argumente zu l√∂schen usw.). <br>  Um den Benchmark f√ºr die Erstellung eines Loggers f√ºr log4net zu stabilisieren, war es au√üerdem erforderlich, nicht eine Operation auszuf√ºhren, sondern 16 (d. H. Ein Array von 16 identischen Objekten wird zur√ºckgegeben).  Wenn Sie nichts zur√ºckgeben, hat .Net die Ausf√ºhrung f√ºr mich optimiert (anscheinend nur das Ergebnis nicht zur√ºckgegeben), was zu falschen Ergebnissen f√ºhrte. </p><br><p>  Und Schlussfolgerungen: </p><br><ul><li>  Logger werden am schnellsten aus Zeichenfolgen erstellt (NLog ist wieder schneller, der Unterschied zwischen den Bibliotheken ist jedoch gering, wenn man bedenkt, dass Logger nicht nur so erstellt werden, sondern f√ºr die sp√§tere Arbeit mit ihnen). </li><li>  log4net ist beim Initialisieren eines Projekts schneller als NLog.  M√∂glicherweise liegt dies an der zus√§tzlichen Zwischenspeicherung auf der NLog-Seite, die dazu beitr√§gt, direkte Aufrufe von <code>Debug</code> , <code>Info</code> usw. zu beschleunigen.  Tats√§chlich kennt jeder <code>ILogger</code> die Antwort auf sich selbst: ob die folgenden Methoden aufgerufen werden sollen oder nicht (und dies erfordert zumindest eine Bindung an die allgemeine Konfiguration).  Aufgrund dieses Arbeitsschemas wurde Out Of Memory von mir bei den meisten Tests verwendet (wenn ich andere Zeilen usw. verwende). </li><li>  <code>LogManager.GetCurrentClassLogger()</code> ist noch langsamer als <code>LogManager.GetLogget(typeof(XXX))</code> .  Dies ist logisch, selbst NLog-Entwickler empfehlen nicht, die erste Methode in einer Schleife aufzurufen. </li><li>  Und am wichtigsten: Die Geschwindigkeit all dieser Methoden wirkt sich h√§ufig nur auf den Kaltstart der Anwendung aus, wenn Felder des Formulars <code>private static readonly ILogger Log = LogManager.GetCurrentClassLogger()</code> .  Das hei√üt, es wirkt sich nicht direkt auf die Leistung des Systems aus. </li></ul><br><h1 id="vyvod">  Fazit </h1><br><p>  Was ist der beste Weg, um mit Protokollen umzugehen: </p><br><ul><li>  Wenn es m√∂glich ist, sich √ºberhaupt nicht anzumelden, ist dies die schnellste (was bisher offensichtlich ist). </li><li>  Wenn das Projekt viele Logger-Aufrufe hat, die keine Daten in eine Datei (an die Konsole usw.) ausgeben, ist NLog schneller.  Au√üerdem werden weniger Objekte auf dem Heap zugewiesen. </li><li>  Wenn Sie immer noch in eine Datei schreiben m√ºssen, arbeitet NLog am schnellsten asynchron.  Ja, es verbraucht mehr Speicher (im Vergleich zu NLog im synchronen Modus, da log4net nach meinen vorherigen Messungen nicht einmal versucht, Arrays und <code>Stream</code> wiederzuverwenden).  Das Programm kann jedoch schneller ausgef√ºhrt werden. </li><li>  Das Erstellen eines Loggers ist kein freier Vorgang, daher ist es oft besser, ihn mit einem statischen Feld zu erstellen.  Dies gilt nicht f√ºr das Erstellen aus einer Zeichenfolge, <code>LogManager.GetLogger("123")</code> .  Solche Aufrufe arbeiten schneller, was bedeutet, dass ein Logger f√ºr gro√üe Instanzen von Objekten erstellt werden kann (z. B. "ein Logger f√ºr den Kontext der Abfrage"). </li><li>  Wenn Sie viele Parameter in das Protokoll ausgeben m√∂chten, in den meisten F√§llen jedoch kein direkter Datenauszug in die Datei erfolgt, sollten Sie mehrere Aufrufe durchf√ºhren.  Daher erstellt NLog keine zus√§tzlichen Objekte auf dem Heap, wenn sie dort nicht ben√∂tigt werden. </li></ul><br><p>  Schlussfolgerungen f√ºr Ihren Code: </p><br><ul><li>  Wenn Ihre Methode ein beliebiges Objekt (d. H. Ein <code>object</code> ) akzeptiert und in den meisten F√§llen nichts tut (was f√ºr Vertr√§ge / Validatoren gilt), ist es am korrektesten, Aufrufe in eine generische Form zu verpacken (d. H. Methoden der Form <code>Something&lt;TArg&gt;(TArg arg)</code> ).  Dies wird sehr schnell funktionieren. </li><li>  Wenn in Ihrem Code ein Zur√ºcksetzen der Dateidaten zul√§ssig ist und gleichzeitig mit etwas anderem gearbeitet wird, ist es besser, verwirrt zu sein und dies zu unterst√ºtzen.  Ja, es scheint offensichtlich, dass die parallele Ausf√ºhrung die Arbeit beschleunigen kann. Bei E / A-Vorg√§ngen bietet dieser Ansatz jedoch auch eine zus√§tzliche Leistungssteigerung auf Computern mit langsamen Festplatten. </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de456488/">https://habr.com/ru/post/de456488/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de456472/index.html">Einf√ºhrung in Go und das Mggo Framework</a></li>
<li><a href="../de456474/index.html">Tic Tac Toe Teil 0: Vergleich von Svelte und React</a></li>
<li><a href="../de456476/index.html">√Ñnderungen am Bluetooth-Stack zur Verbesserung der Audioqualit√§t von Kopfh√∂rern ohne AAC-, aptX- oder LDAC-Codecs</a></li>
<li><a href="../de456482/index.html">Fang mich, wenn du kannst. K√∂nig Version</a></li>
<li><a href="../de456486/index.html">Schnittstelle und Auswahl (2014)</a></li>
<li><a href="../de456490/index.html">Vortr√§ge √ºber das Gehirn, Teil 1. Die Entwicklung des menschlichen Gehirns. Das Gehirn funktioniert in jeder Phase seiner Entwicklung</a></li>
<li><a href="../de456492/index.html">Trollarmee</a></li>
<li><a href="../de456494/index.html">In den Staaten sind GOSTs auch so lala. YubiKey FIPS schwerwiegende Sicherheitsl√ºcke, die h√§tte vermieden werden k√∂nnen</a></li>
<li><a href="../de456498/index.html">Ger√§te-Manager Erweitern Sie MIS auf Ger√§te</a></li>
<li><a href="../de456500/index.html">Wie man lehrt, um Schwierigkeiten zu √ºberwinden und gleichzeitig Zyklen zu schreiben</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>