<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🚆 🧒🏼 🧔🏻 Admin tanpa senjata = hyperconvergence? 🔯 📩 🚔</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ini adalah mitos yang cukup umum di bidang perangkat keras server. Dalam praktiknya, solusi hyperconverged (ketika semuanya) membutuhkan banyak untuk ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Admin tanpa senjata = hyperconvergence?</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/croc/blog/471508/"><img src="https://habrastorage.org/webt/_a/wu/gy/_awugy9unrbypap90hlhc86-maa.png"><br><img src="https://habrastorage.org/webt/_k/kx/sa/_kkxsa4xs7rgz-fzktgy10mdeuc.png"><br><br>  Ini adalah mitos yang cukup umum di bidang perangkat keras server.  Dalam praktiknya, solusi hyperconverged (ketika semuanya) membutuhkan banyak untuk apa.  Secara historis, arsitektur pertama dikembangkan oleh Amazon dan Google untuk layanan mereka.  Kemudian idenya adalah membuat pertanian komputasi dari node yang sama, masing-masing memiliki drive sendiri.  Semua ini dikombinasikan oleh beberapa perangkat lunak pembentuk sistem (hypervisor) dan sudah dibagi menjadi mesin virtual.  Tugas utama adalah upaya minimal untuk mempertahankan satu node dan minimal masalah penskalaan: kami baru saja membeli seribu atau dua server yang sama dan terhubung di dekatnya.  Dalam praktiknya, ini adalah kasus yang terisolasi, dan lebih sering kita berbicara tentang jumlah node yang lebih sedikit dan arsitektur yang sedikit berbeda. <br><br>  Namun plus tetap sama - kemudahan penskalaan dan kontrol yang luar biasa.  Minus - tugas yang berbeda menggunakan sumber daya secara berbeda, dan di suatu tempat akan ada banyak disk lokal, di suatu tempat akan ada sedikit RAM, dan seterusnya, yaitu, dengan berbagai jenis tugas, pemanfaatan sumber daya akan turun. <br><br>  Ternyata Anda membayar 10-15% lebih untuk kemudahan pengaturan.  Ini menyebabkan mitos judul.  Kami mencari waktu yang lama di mana teknologi akan diterapkan secara optimal, dan menemukannya.  Faktanya adalah bahwa Tsiska tidak memiliki sistem penyimpanan sendiri, tetapi mereka menginginkan pasar server yang lengkap.  Dan mereka membuat Cisco Hyperflex, solusi penyimpanan lokal pada node. <br><br>  Dan ini tiba-tiba menjadi solusi yang sangat bagus untuk pusat data cadangan (Disaster Recovery).  Mengapa dan bagaimana - sekarang saya akan memberi tahu.  Dan saya akan menunjukkan tes cluster. <a name="habracut"></a><br><br><h3>  Kemana? </h3><br>  Konvergensi hiper adalah: <br><br><ol><li>  Transfer disk untuk menghitung node. </li><li>  Integrasi penuh dari subsistem penyimpanan dengan subsistem virtualisasi. </li><li>  Transfer / integrasi dengan subsistem jaringan. </li></ol><br>  Kombinasi seperti itu memungkinkan Anda untuk mengimplementasikan banyak fitur sistem penyimpanan di tingkat virtualisasi dan semuanya dari satu jendela kontrol. <br><br>  Di perusahaan kami, proyek untuk mendesain pusat data yang berlebihan sangat populer, dan seringkali itu adalah solusi hyperconverged yang sering dipilih karena tumpukan opsi replikasi (hingga cluster metro) di luar kotak. <br><br>  Dalam kasus pusat data cadangan, biasanya pertanyaan tentang fasilitas jarak jauh di situs di sisi lain kota atau di kota lain pada umumnya.  Ini memungkinkan Anda untuk mengembalikan sistem penting jika terjadi kegagalan sebagian atau seluruhnya dari pusat data utama.  Data penjualan terus-menerus direplikasi di sana, dan replikasi ini bisa di level aplikasi atau di level perangkat blok (SHD). <br><br>  Jadi sekarang saya akan berbicara tentang perangkat dan pengujian sistem, dan kemudian tentang beberapa skenario kehidupan nyata dengan data tentang penghematan. <br><br><h3>  Tes </h3><br>  Salinan kami terdiri dari empat server, yang masing-masing memiliki 10 disk SSD per 960 GB.  Ada disk khusus untuk operasi penulisan caching dan penyimpanan mesin virtual layanan.  Solusinya sendiri adalah versi keempat.  Yang pertama terus terang mentah (dilihat dari ulasan), yang kedua lembab, yang ketiga sudah cukup stabil, dan yang ini bisa disebut rilis setelah akhir pengujian beta untuk masyarakat umum.  Selama pengujian masalah yang tidak saya lihat, semuanya bekerja seperti jam. <br><br><div class="spoiler">  <b class="spoiler_title">Perubahan pada v4</b> <div class="spoiler_text">  Memperbaiki banyak bug. <br><br>  Awalnya, platform hanya bisa bekerja dengan hypervisor VMware ESXi dan mendukung sejumlah kecil node.  Selain itu, proses penyebaran tidak selalu berakhir dengan sukses, saya harus memulai kembali beberapa langkah, ada masalah memperbarui dari versi lama, data dalam GUI tidak selalu ditampilkan dengan benar (walaupun saya masih tidak senang dengan menampilkan grafik kinerja), kadang-kadang ada masalah di persimpangan dengan virtualisasi . <br><br>  Sekarang semua luka anak-anak telah diperbaiki, HyperFlex dapat melakukan ESXi dan Hyper-V, ditambah ini dimungkinkan: <br><br><ol><li>  Membuat kluster yang diregangkan. </li><li>  Membuat cluster untuk kantor tanpa menggunakan Fabric Interconnect, dari dua hingga empat node (kami hanya membeli server). </li><li>  Kemampuan untuk bekerja dengan penyimpanan eksternal. </li><li>  Dukungan untuk kontainer dan Kubernet. </li><li>  Pembuatan zona aksesibilitas. </li><li>  Integrasi dengan VMware SRM, jika fungsionalitas bawaan tidak sesuai. </li></ol><br></div></div><br>  Arsitekturnya tidak jauh berbeda dengan keputusan para pesaing utama, mereka tidak mulai membuat sepeda.  Semuanya berfungsi pada platform virtualisasi VMware atau Hyper-V.  Perangkat keras di-host di server milik Cisco UCS.  Ada orang yang membenci platform karena kompleksitas relatif dari pengaturan awal, banyak tombol, sistem templat dan dependensi yang tidak sepele, tetapi ada juga yang telah mempelajari Zen, terinspirasi oleh ide tersebut dan tidak lagi ingin bekerja dengan server lain. <br><br>  Kami akan mempertimbangkan solusi khusus untuk VMware, karena solusi ini awalnya dibuat untuk itu dan memiliki lebih banyak fungsi, Hyper-V ditambahkan sepanjang jalan untuk bersaing dengan pesaing dan memenuhi harapan pasar. <br><br>  Ada sekelompok server yang penuh dengan disk.  Ada disk untuk penyimpanan data (SSD atau HDD - sesuai selera dan kebutuhan Anda), ada satu disk SSD untuk cache.  Ketika data ditulis ke datastore, data disimpan pada lapisan caching (SSD-disk khusus dan layanan VM RAM).  Secara paralel, blok data dikirim ke node dalam cluster (jumlah node tergantung pada faktor replikasi cluster).  Setelah konfirmasi dari semua node tentang rekaman yang sukses, konfirmasi rekaman dikirim ke hypervisor dan kemudian ke VM.  Data yang direkam di latar belakang dideduplikasi, dikompresi, dan ditulis ke disk penyimpanan.  Pada saat yang sama, blok besar selalu ditulis ke disk penyimpanan dan secara berurutan, yang mengurangi beban pada disk penyimpanan. <br><br>  Deduplikasi dan kompresi selalu aktif dan tidak dapat dinonaktifkan.  Data dibaca langsung dari disk penyimpanan atau dari cache RAM.  Jika konfigurasi hibrid digunakan, pembacaan juga di-cache pada SSD. <br><br>  Data tidak terikat ke lokasi saat ini dari mesin virtual dan didistribusikan secara merata antara node.  Pendekatan ini memungkinkan Anda memuat semua drive dan antarmuka jaringan secara merata.  Minus yang jelas meminta: kami tidak dapat meminimalkan penundaan baca, karena tidak ada jaminan ketersediaan data secara lokal.  Tetapi saya percaya bahwa ini adalah pengorbanan yang tidak penting dibandingkan dengan nilai plus yang diterima.  Terlebih lagi, keterlambatan jaringan telah mencapai nilai sedemikian rupa sehingga secara praktis tidak mempengaruhi hasil keseluruhan. <br><br>  Untuk semua logika subsistem disk, VM layanan khusus pengontrol Platform Data HyperFlex Cisco bertanggung jawab, yang dibuat pada setiap node penyimpanan.  Dalam konfigurasi VM layanan kami, delapan vCPU dan 72 GB RAM dialokasikan, yang tidak begitu kecil.  Biarkan saya mengingatkan Anda bahwa host itu sendiri memiliki 28 core fisik dan RAM 512 GB. <br><br>  Layanan VM memiliki akses ke disk fisik secara langsung dengan meneruskan pengontrol SAS ke VM.  Komunikasi dengan hypervisor terjadi melalui modul IOVisor khusus, yang mencegat operasi I / O, dan menggunakan agen yang memungkinkan Anda untuk mentransfer perintah ke API hypervisor.  Agen bertanggung jawab untuk bekerja dengan snapshot dan klon HyperFlex. <br><br>  Di hypervisor, sumber daya disk dipasang sebagai bola NFS atau SMB (tergantung pada jenis hypervisor, tebak yang mana).  Dan di bawah tenda, ini adalah sistem file terdistribusi yang memungkinkan Anda untuk menambahkan fitur sistem penyimpanan dewasa penuh: alokasi volume tipis, kompresi dan deduplikasi, snapshot menggunakan teknologi Redirect-on-Write, replikasi sinkron / asinkron. <br><br>  Layanan VM menyediakan akses ke antarmuka WEB dari manajemen subsistem HyperFlex.  Ada integrasi dengan vCenter, dan sebagian besar tugas sehari-hari dapat dilakukan darinya, tetapi datastore, misalnya, lebih nyaman untuk memotong dari webcam terpisah jika Anda telah beralih ke antarmuka HTML5 yang cepat, atau menggunakan klien Flash lengkap dengan integrasi penuh.  Di webcam layanan, Anda dapat melihat kinerja dan status terperinci sistem. <br><br><img src="https://habrastorage.org/webt/o0/bj/od/o0bjod1zrf25ubnrtis5q4e1ywc.png"><br><br>  Ada jenis lain dari node dalam sebuah cluster - node komputasi.  Ini bisa berupa server rak atau blade tanpa drive internal.  Di server ini, Anda dapat menjalankan VM yang datanya disimpan di server dengan disk.  Dari sudut pandang akses data, tidak ada perbedaan antara jenis-jenis node, karena arsitektur melibatkan abstrak dari lokasi fisik data.  Rasio maksimum node komputasi dan node penyimpanan adalah 2: 1. <br><br>  Menggunakan node komputasi meningkatkan fleksibilitas saat scaling sumber daya cluster: kita tidak perlu membeli node dengan disk jika kita hanya membutuhkan CPU / RAM.  Selain itu, kita dapat menambahkan keranjang blade dan menghemat ruang server rak. <br><br>  Hasilnya, kami memiliki platform hyperconverged dengan fitur-fitur berikut: <br><br><ul><li>  Hingga 64 node dalam satu cluster (hingga 32 node penyimpanan). </li><li>  Jumlah minimum node dalam sebuah cluster adalah tiga (dua untuk cluster Edge). </li><li>  Mekanisme redundansi data: mirroring dengan faktor replikasi 2 dan 3. </li><li>  Cluster metro. </li><li>  Replikasi VM asinkron ke kluster HyperFlex lain. </li><li>  Orkestrasi untuk mengalihkan VM ke pusat data jarak jauh. </li><li>  Jepretan asli menggunakan teknologi Redirect-on-Write. </li><li>  Hingga 1 PB ruang yang dapat digunakan dengan faktor replikasi 3 dan tanpa deduplikasi.  Kami tidak memperhitungkan faktor replikasi akun 2, karena ini bukan opsi untuk penjualan serius. </li></ul><br>  Nilai tambah besar lainnya adalah kemudahan manajemen dan penyebaran.  Semua kompleksitas konfigurasi server UCS ditangani oleh VM khusus yang disiapkan oleh para insinyur Cisco. <br><br><h3>  Konfigurasi yang diuji: </h3><br><ul><li>  2 x Cisco UCS Fabric Interconnect 6248UP sebagai cluster manajemen dan komponen jaringan (48 port yang beroperasi dalam mode Ethernet 10G / FC 16G). </li><li>  Empat Server Cisco UCS HXAF240 M4. </li></ul><br>  Fitur Server: <br><p></p><div class="scrollable-table"><table><tbody><tr><td><br><p>  CPU </p><br></td><td><br><p>  2 x Intel® Xeon® E5-2690 v4 </p><br></td></tr><tr><td><br><p>  RAM </p><br></td><td><br><p>  RDIMM / PC4-19200 / DDR4-2400-MHz DDR4-2400-MHz 16 x 32GB </p><br></td></tr><tr><td><br><p>  Jaringan </p><br></td><td><br><p>  UCSC-MLOM-CSC-02 (VIC 1227)  2 x 10G Ethernet </p><br></td></tr><tr><td><br><p>  Hba penyimpanan </p><br></td><td><br><p>  Cisco 12G Modular SAS Lewati Pengontrol </p><br></td></tr><tr><td><br><p>  Disk penyimpanan </p><br></td><td><br><p>  1 x SSD Intel S3520 120 GB, 1 x SSD Samsung MZ-IES800D, 10 x SSD Samsung PM863a 960 GB </p><br></td></tr></tbody></table></div><br><br><div class="spoiler">  <b class="spoiler_title">Opsi konfigurasi lainnya</b> <div class="spoiler_text">  Selain setrika yang dipilih, opsi berikut saat ini tersedia: <br><br><ul><li>  HXAF240c M5. </li><li>  Satu atau dua CPU mulai dari Intel Silver 4110 hingga Intel Platinum I8260Y.  Generasi kedua tersedia. </li><li>  24 slot memori, bilah dari 16 GB RDIMM 2600 hingga 128 GB LRDIMM 2933. </li><li>  Dari 6 hingga 23 disk untuk data, satu disk caching, satu sistem, dan satu disk boot. </li></ul><br>  <b>Drive kapasitas</b> <br><br><ul><li>  HX-SD960G61X-EV 960GB 2.5 Inch Nilai Perusahaan 6G SATA SSD (daya tahan 1X) SAS 960 GB. </li><li>  HX-SD38T61X-EV 3.8TB Nilai Perusahaan 2,5 inci 6G SATA SSD (daya tahan 1X) SAS 3,8 TB. </li><li>  Driver caching </li><li>  HX-NVMEXPB-I375 375GB 2,5 inci Intel Optane Drive, Extreme Perf &amp; Endurance. </li><li>  HX-NVMEHW-H1600 * 1.6TB 2,5 inci Ent.  Perf  NVMe SSD (daya tahan 3X) NVMe 1.6 TB. </li><li>  HX-SD400G12TX-EP 400GB 2,5 inci Ent.  Perf  SSD SAS 12G (daya tahan 10X) SAS 400 GB. </li><li>  HX-SD800GBENK9 ** 800GB 2,5 inci Ent.  Perf  SSD SED 12G SAS (daya tahan 10X) SAS 800 GB. </li><li>  HX-SD16T123X-EP 1.6TB 2.5 inch Kinerja perusahaan 12G SAS SSD (daya tahan 3X). </li></ul><br>  <b>Sistem / Drive Log</b> <br><br><ul><li>  HX-SD240GM1X-EV 240GB 2,5 inci Nilai Perusahaan 6G SATA SSD (Membutuhkan peningkatan). </li></ul><br>  <b>Driver boot</b> <br><br><ul><li>  HX-M2-240GB 240GB SATA M.2 SSD SATA 240 GB. </li></ul><br></div></div><br>  Koneksi ke jaringan pada port Ethernet 40G, 25G atau 10G. <br><br>  Karena FI dapat berupa HX-FI-6332 (40G), HX-FI-6332-16UP (40G), HX-FI-6454 (40G / 100G). <br><br><h3>  Tes sendiri </h3><br>  Untuk menguji subsistem disk, saya menggunakan HCIBench 2.2.1.  Ini adalah utilitas gratis yang memungkinkan Anda untuk mengotomatisasi pembuatan beban dari banyak mesin virtual.  Beban itu sendiri dihasilkan oleh fio biasa. <br><br>  Cluster kami terdiri dari empat node, faktor replikasi 3, semua drive Flash. <br><br>  Untuk pengujian, saya membuat empat datastore dan delapan mesin virtual.  Untuk tes tulis, diasumsikan bahwa disk caching tidak penuh. <br><br>  Hasil tes adalah sebagai berikut: <br><div class="scrollable-table"><table><tbody><tr><td></td><td colspan="5"><br><p>  100% Baca 100% Acak </p><br></td><td colspan="5"><br><p>  0% Baca 100% Acak </p><br></td></tr><tr><td><br><p>  Blok / Kedalaman Antrian </p><br></td><td><br><p>  128 </p><br></td><td><br><p>  256 </p><br></td><td><br><p>  512 </p><br></td><td><br><p>  1024 </p><br></td><td><br><p>  2048 </p><br></td><td><br><p>  128 </p><br></td><td><br><p>  256 </p><br></td><td><br><p>  512 </p><br></td><td><br><p>  1024 </p><br></td><td><br><p>  2048 </p><br></td></tr><tr><td><br><p>  4 rb </p><br></td><td><br><p>  0,59 ms 213804 IOPS </p><br></td><td><br><p>  0,84 ms 303540 IOPS </p><br></td><td><br><p>  1.36ms 374348 IOPS </p><br></td><td><br><p>  2,47 ms 414116 IOPS </p><br></td><td><br><p>  <b>4.86ms 420180 IOPS</b> </p><br></td><td><br><p>  2,22 ms 57408 IOPS </p><br></td><td><br><p>  3,09 ms 82744 IOPS </p><br></td><td><br><p>  5,02 ms 101824 IPOS </p><br></td><td><br><p>  8,75 ms 116912 IOPS </p><br></td><td><br><p>  <b>17,2 ms 118592 IOPS</b> </p><br></td></tr><tr><td><br><p>  8 rb </p><br></td><td><br><p>  0,67 ms 188416 IOPS </p><br></td><td><br><p>  0,93 ms 273280 IOPS </p><br></td><td><br><p>  1,7 ms 299932 IOPS </p><br></td><td><br><p>  2.72 ms 376.484 IOPS </p><br></td><td><br><p>  <b>5.47 ms 373.176 IOPS</b> </p><br></td><td><br><p>  3,1 ms 41148 IOPS </p><br></td><td><br><p>  4,7 ms 54396 IOPS </p><br></td><td><br><p>  7,09 ms 72192 IOPS </p><br></td><td><br><p>  <b>12,77 ms 80.132 IOPS</b> </p><br></td><td></td></tr><tr><td><br><p>  16 rb </p><br></td><td><br><p>  0,77 ms 164116 IOPS </p><br></td><td><br><p>  1,12 ms 228328 IOPS </p><br></td><td><br><p>  1,9 ms 268140 IOPS </p><br></td><td><br><p>  <b>3,96 ms 258480 IOPS</b> </p><br></td><td></td><td><br><p>  3,8 ms 33640 IOPS </p><br></td><td><br><p>  6,97 ms 36696 IOPS </p><br></td><td><br><p>  <b>11,35 ms 45060 IOPS</b> </p><br></td><td></td><td></td></tr><tr><td><br><p>  32rb </p><br></td><td><br><p>  1,07 ms 119292 IOPS </p><br></td><td><br><p>  1,79 ms 142888 IOPS </p><br></td><td><br><p>  <b>3,56 ms 143760 IOPS</b> </p><br></td><td></td><td></td><td><br><p>  7,17 ms 17810 IOPS </p><br></td><td><br><p>  <b>11,96 ms 21396 IOPS</b> </p><br></td><td></td><td></td><td></td></tr><tr><td><br><p>  64rb </p><br></td><td><br><p>  1,84 ms 69440 IOPS </p><br></td><td><br><p>  3,6 ms 71008 IOPS </p><br></td><td><br><p>  <b>7,26 ms 70404 IOPS</b> </p><br></td><td></td><td></td><td><br><p>  <b>11,37 ms 11248 IOPS</b> </p><br></td><td></td><td></td><td></td><td></td></tr></tbody></table></div><br>  <i>Nilai tebal ditunjukkan, setelah itu tidak ada peningkatan produktivitas, kadang-kadang bahkan degradasi terlihat.</i>  <i>Karena kenyataan bahwa kita bersandar pada kinerja jaringan / pengontrol / drive.</i> <br><br><ul><li>  Sequential read 4432 MB / s. </li><li>  Menulis berurutan 804 MB / s. </li><li>  Jika satu controller gagal (mesin virtual atau kegagalan host), drawdown kinerja digandakan. </li><li>  Jika drive penyimpanan gagal, drawdownnya adalah 1/3.  Disk rebild mengambil 5% sumber daya dari setiap pengontrol. </li></ul><br>  Pada blok kecil, kita mengalami kinerja controller (mesin virtual), CPU-nya 100% dimuat, sementara meningkatkan blok kita lari ke port bandwidth.  10 Gbps tidak cukup untuk membuka kunci potensi sistem AllFlash.  Sayangnya, parameter dari demo stand yang disediakan tidak memungkinkan memeriksa pekerjaan pada 40 Gb / s. <br><br>  Dalam kesan saya tentang tes dan studi arsitektur, karena algoritma yang menempatkan data antara semua host, kami mendapatkan kinerja yang dapat diprediksi terukur, tetapi ini juga merupakan batasan saat membaca, karena mungkin untuk memeras lebih banyak dari disk lokal dan banyak lagi, di sini untuk menyimpan jaringan yang lebih produktif, misalnya, 40 Gbps FI tersedia. <br><br>  Juga, satu disk untuk caching dan deduplikasi dapat menjadi batasan, pada kenyataannya, dalam stand ini kita dapat menulis pada empat disk SSD.  Akan sangat bagus untuk dapat meningkatkan jumlah disk yang di-cache dan melihat perbedaannya. <br><br><h3>  Penggunaan nyata </h3><br>  Dua pendekatan dapat digunakan untuk mengatur pusat data cadangan (kami tidak mempertimbangkan menempatkan cadangan di situs jarak jauh): <br><br><ol><li>  Pasif aktif  Semua aplikasi di-host di pusat data utama.  Replikasi sinkron atau asinkron.  Jika terjadi penurunan di pusat data utama, kita perlu mengaktifkan yang cadangan.  Ini dapat dilakukan secara manual / skrip / aplikasi orkestrasi.  Di sini kita mendapatkan RPO yang sepadan dengan frekuensi replikasi, dan RTO tergantung pada reaksi dan keterampilan administrator dan kualitas pengembangan / debugging dari rencana switching. </li><li>  Aktif Aktif  Dalam hal ini, hanya replikasi sinkron hadir, ketersediaan pusat data ditentukan oleh kuorum / arbiter, ditempatkan secara ketat pada platform ketiga.  RPO = 0, dan RTO dapat mencapai 0 (jika aplikasi memungkinkan) atau sama dengan waktu gagal atas sebuah node dalam cluster virtualisasi.  Pada tingkat virtualisasi, kluster terentang (Metro) dibuat yang memerlukan penyimpanan Active-Active. </li></ol><br>  Biasanya, kami melihat dengan pelanggan arsitektur yang sudah diterapkan dengan penyimpanan klasik di pusat data utama, jadi kami merancang yang lain untuk replikasi.  Seperti yang saya sebutkan, Cisco HyperFlex menawarkan replikasi asinkron dan pembuatan cluster virtualisasi yang diperluas.  Pada saat yang sama, kita tidak memerlukan sistem penyimpanan Midrange atau yang lebih tinggi dengan fungsi replikasi yang mahal dan akses data Aktif-Aktif pada dua sistem penyimpanan. <br><br>  <b>Skenario 1:</b> Kami memiliki pusat data primer dan cadangan, platform virtualisasi di VMware vSphere.  Semua sistem produktif terletak terutama di pusat data, dan replikasi mesin virtual dilakukan di tingkat hypervisor, ini akan memungkinkan untuk tidak membuat VM diaktifkan di pusat data cadangan.  Kami mereplikasi basis data dan aplikasi khusus dengan alat bawaan dan menjaga VM tetap hidup.  Jika pusat data utama gagal, kami memulai sistem di pusat data cadangan.  Kami percaya bahwa kami memiliki sekitar 100 mesin virtual.  Selama pusat data utama beroperasi, lingkungan pengujian dan sistem lainnya dapat diluncurkan di pusat data cadangan, yang dapat dinonaktifkan jika pusat data utama diaktifkan.  Mungkin juga kita menggunakan replikasi dua arah.  Dari sudut pandang peralatan, tidak ada yang akan berubah. <br><br>  Dalam kasus arsitektur klasik, kami akan menempatkan sistem penyimpanan hybrid di setiap pusat data dengan akses melalui FibreChannel, merobek, deduplikasi dan kompresi (tetapi tidak online), 8 server per situs, 2 sakelar FibreChannel, dan Ethernet 10G.  Untuk kontrol replikasi dan switching dalam arsitektur klasik, kita dapat menggunakan alat VMware (Replikasi + SRM) atau alat pihak ketiga yang akan sedikit lebih murah dan terkadang lebih nyaman. <br><br>  Gambar tersebut menunjukkan diagram. <br><br><img src="https://habrastorage.org/webt/ej/an/92/ejan92jvmtt1ejtbtd1eyytngw8.png"><br><br>  Jika Anda menggunakan Cisco HyperFlex, Anda mendapatkan arsitektur berikut: <br><br><img src="https://habrastorage.org/webt/9w/xs/hl/9wxshlz45c53uyitqulmrmwlraq.png"><br><br>  Untuk HyperFlex, saya menggunakan server dengan sumber daya CPU / RAM besar, sebagai  bagian dari sumber daya akan pergi ke VM pengontrol HyperFlex, saya bahkan memuat ulang sedikit dalam konfigurasi HyperFlex pada CPU dan memori, agar tidak bermain bersama Cisco dan menjamin sumber daya untuk sisa VM.  Tapi kita bisa menolak dari switch FibreChannel, dan kita tidak perlu port Ethernet untuk setiap server, lalu lintas lokal diaktifkan di dalam FI. <br><br>  Hasilnya adalah konfigurasi berikut untuk setiap pusat data: <br><div class="scrollable-table"><table><tbody><tr><td><br><p>  Server </p><br></td><td><br><p>  Server 8 x 1U (RAM 384 GB, 2 x Intel Gold 6132, FC HBA) </p><br></td><td><br><p>  8 x HX240C-M5L (RAM 512 GB, 2 x Intel Gold 6150, SSD 3,2 GB, NL-SAS 10 x 6 TB) </p><br></td></tr><tr><td><br><p>  SHD </p><br></td><td><br><p>  Penyimpanan Hibrid dengan FC Front-End (20TB SSD, 130 TB NL-SAS) </p><br></td><td><br><p>  - </p><br></td></tr><tr><td><br><p>  LAN </p><br></td><td><br><p>  2 x Ethernet switch 10G 12 port </p><br></td><td><br><p>  - </p><br></td></tr><tr><td><br><p>  San </p><br></td><td><br><p>  2 x FC switch 32/16Gb 24 port </p><br></td><td><br><p>  2 x Cisco UCS FI 6332 </p><br></td></tr><tr><td><br><p>  Lisensi </p><br></td><td><br><p>  VMware Ent Plus </p><br><p>  Replikasi dan / atau orkestrasi VM </p><br></td><td><br><p>  VMware Ent Plus </p><br></td></tr></tbody></table></div><br>  Untuk Hyperflex, saya tidak menjanjikan lisensi perangkat lunak replikasi, karena ini tersedia di luar kotak bersama kami. <br><br>  Untuk arsitektur klasik, saya mengambil vendor yang memantapkan dirinya sebagai produsen yang berkualitas dan murah.  Untuk kedua opsi, saya menggunakan standar untuk skid solusi spesifik, pada output saya mendapatkan harga riil. <br><br>  Solusi pada Cisco HyperFlex adalah 13% lebih murah. <br><br>  <b>Skenario 2:</b> membuat dua pusat data aktif.  Dalam skenario ini, kami merancang cluster yang diperluas pada VMware. <br><br>  Arsitektur klasik terdiri dari server virtualisasi, SAN (protokol FC) dan dua sistem penyimpanan yang dapat membaca dan menulis yang membentang di antara mereka.  Pada setiap SHD kami memasang kapasitas yang berguna untuk kunci. <br><br><img src="https://habrastorage.org/webt/lm/1i/yu/lm1iyuqivylf7dl0xrmff21swlw.png"><br><br>  Di HyperFlex, kami cukup membuat Stretch Cluster dengan jumlah node yang sama di kedua situs.  Dalam hal ini, faktor replikasi 2 + 2 digunakan. <br><br><img src="https://habrastorage.org/webt/e7/mq/sd/e7mqsd7codjtfbqefl40icsohpu.png"><br><br>  Konfigurasi berikut telah berubah: <br><div class="scrollable-table"><table><tbody><tr><td></td><td><br><p>  Arsitektur klasik </p><br></td><td><br><p>  Hyperflex </p><br></td></tr><tr><td><br><p>  Server </p><br></td><td><br><p>  Server 16 x 1U (RAM 384 GB, 2 x Intel Gold 6132, FC HBA, NIC 2 x 10G) </p><br></td><td><br><p>  16 x HX240C-M5L (RAM 512 GB, 2 x Intel Gold 6132, NVMe 1,6 TB, SSD 12 x 3,8 TB, VIC 1387) </p><br></td></tr><tr><td><br><p>  SHD </p><br></td><td><br><p>  2 x AllFlash Storage (150 TB SSD) </p><br></td><td><br><p>  - </p><br></td></tr><tr><td><br><p>  LAN </p><br></td><td><br><p>  4 x Ethernet switch 10G 24 port </p><br></td><td><br><p>  - </p><br></td></tr><tr><td><br><p>  San </p><br></td><td><br><p>  4 x FC switch 32/16Gb 24 port </p><br></td><td><br><p>  4 x Cisco UCS FI 6332 </p><br></td></tr><tr><td><br><p>  Lisensi </p><br></td><td><br><p>  VMware Ent Plus </p><br></td><td><br><p>  VMware Ent Plus </p><br></td></tr></tbody></table></div><br>  Dalam semua perhitungan, saya tidak memperhitungkan infrastruktur jaringan, biaya pusat data, dll: semuanya akan sama untuk arsitektur klasik dan untuk solusi HyperFlex. <br><br>  Pada biaya HyperFlex ternyata 5% lebih mahal.  Perlu dicatat di sini bahwa untuk sumber daya CPU / RAM, saya mendapat bias untuk Cisco, karena dalam konfigurasi itu mengisi saluran pengendali memori secara merata.   ,    ,   ,     «  »,         .      ,      Cisco UCS     . <br><br>        SAN  , -  ,      (, ,   — ),   (    ),  . <br><br>   ,         — Cisco.        Cisco UCS,    ,  HyperFlex     ,    .          ,     .       : «    ,  ?»  «  - ,     . !» —           , : «    »   . <br><br><h3>  Referensi </h3><br><ul><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="></a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="> -</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">-   </a> </li><li>   — StGeneralov@croc.ru </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id471508/">https://habr.com/ru/post/id471508/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id471498/index.html">Peta kamera fiksasi jalan dibuat publik: bersukacita atau menangis?</a></li>
<li><a href="../id471500/index.html">Callback atau “Meningkatkan loyalitas pelanggan”</a></li>
<li><a href="../id471502/index.html">Pertanian Ide</a></li>
<li><a href="../id471504/index.html">Duet dua dimensi: pembuatan heterostruktur borofen-graphene</a></li>
<li><a href="../id471506/index.html">Pembulatan angka desimal yang benar dalam kode biner</a></li>
<li><a href="../id471512/index.html">28 Oktober, Yekaterinburg - Komunikasi Berkualitas</a></li>
<li><a href="../id471514/index.html">Judul "Baca artikel untuk Anda." Januari - Juni 2019</a></li>
<li><a href="../id471516/index.html">Intel 665p - SSD dengan QLC NAND 96-layer</a></li>
<li><a href="../id471518/index.html">Apple pada 2019 adalah Linux pada 2000</a></li>
<li><a href="../id471520/index.html">Buku "Tugas Ilmu Komputer Klasik dengan Python"</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>