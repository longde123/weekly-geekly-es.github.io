<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🧑🏽‍🤝‍🧑🏻 👇🏾 💃🏿 Criando mapas a partir de recursos de ruído 👰 🧚🏼 👩🏿‍🔬</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Um dos artigos mais populares do meu site é dedicado à geração de mapas poligonais ( tradução em Habré). Criar tais cartões requer muito esforço. Mas ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Criando mapas a partir de recursos de ruído</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/430384/">  Um dos artigos mais populares do meu site é dedicado à <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">geração de mapas poligonais</a> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">tradução</a> em Habré).  Criar tais cartões requer muito esforço.  Mas não comecei com isso, mas com uma tarefa <em>muito</em> mais simples, que descreverei aqui.  Essa técnica simples permite criar esses cartões em menos de 50 linhas de código: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b16/95e/c42/b1695ec42f626197fddd201f7f40fa8a.png"></div><br>  Não vou explicar como <em>comprar</em> tais cartões: depende do idioma, biblioteca gráfica, plataforma etc.  Vou apenas explicar como <em>preencher a matriz</em> com dados do mapa. <br><br><h2>  O barulho </h2><br>  A maneira padrão de gerar mapas 2D é usar o ruído com uma banda de frequência limitada como um componente básico, como o ruído Perlin ou o ruído simplex.  Aqui está a aparência da função de ruído: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/855/159/49e/85515949e4c77ba82599050333ec79fa.png" alt="imagem"></div><br>  Atribuímos um número de 0,0 a 1,0 a cada ponto no mapa.  Nesta imagem, 0.0 é preto e 1.0 é branco. <a name="habracut"></a>  Veja como definir a cor de cada ponto da grade na sintaxe de um idioma semelhante ao C: <br><br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> y = <span class="hljs-number"><span class="hljs-number">0</span></span>; y &lt; height; y++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x = <span class="hljs-number"><span class="hljs-number">0</span></span>; x &lt; width; x++) { <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> nx = x/width - <span class="hljs-number"><span class="hljs-number">0.5</span></span>, ny = y/height - <span class="hljs-number"><span class="hljs-number">0.5</span></span>; value[y][x] = noise(nx, ny); } }</code> </pre> <br>  O loop funcionará da mesma maneira em Javascript, Python, Haxe, C ++, C #, Java e na maioria das outras linguagens populares, portanto, mostrarei isso em uma sintaxe do tipo C para que você possa convertê-lo para o idioma necessário.  No restante do tutorial, mostrarei como o corpo do ciclo muda ( <code>value[y][x]=…</code> linha <code>value[y][x]=…</code> ) ao adicionar novas funções.  A demonstração mostrará um exemplo completo. <br><br>  Em algumas bibliotecas, será necessário alterar ou multiplicar os valores resultantes para retorná-los no intervalo de 0,0 a 1,0. <br><br><h2>  Altura </h2><br>  O ruído em si é apenas uma coleção de números.  Precisamos dar <em>sentido a</em> isso.  A primeira coisa que você pode pensar é vincular o valor do ruído à altura (isso é chamado de "mapa de altura").  Vamos pegar o ruído mostrado acima e desenhá-lo como altura: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/047/4bf/8d9/0474bf8d9dd73ad63fefc84140385f50.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b14/cb9/c53/b14cb9c535820e30c6eab79dda6322ec.png"></div><br>  O código permaneceu quase o mesmo, exceto pelo loop interno.  Agora fica assim: <br><br><pre> <code class="cpp hljs">elevation[y][x] = noise(nx, ny);</code> </pre> <br>  Sim, e é isso.  Os dados do mapa permaneceram os mesmos, mas agora vou chamá-los de <code>elevation</code> (altura), não <code>value</code> . <br><br>  Temos muitas colinas, mas nada mais.  O que está errado? <br><br><h3>  Frequência </h3><br>  O ruído pode ser gerado em qualquer <em>frequência</em> .  Até agora, escolhi apenas uma frequência.  Vamos ver como isso afeta. <br><br>  <strong>Tente alterar o valor com o controle deslizante</strong> (no artigo original) e veja o que acontece em diferentes frequências: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/pu/ox/dh/puoxdhmnucu5e3miflqogwqddwq.gif"></div><br>  Apenas muda a escala.  A princípio, isso não parece muito útil, mas não é.  Eu tenho mais um <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">tutorial</a> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">tradução</a> em Habré), que explica a <em>teoria</em> : conceitos como frequência, amplitude, oitavas, ruído rosa e azul, e assim por diante. <br><br><pre> <code class="cpp hljs">elevation[y][x] = noise(freq * nx, freq * ny);</code> </pre> <br>  Às vezes, também é útil recordar o <em>comprimento de onda</em> , que é o recíproco da magnitude.  Quando a frequência é duplicada, o tamanho é reduzido apenas pela metade.  Dobrar o comprimento de onda todos os dobra.  Comprimento de onda é a distância medida em pixels / ladrilhos / metros ou em qualquer outra unidade que você selecionou para mapas.  Está relacionado à frequência: <code>wavelength = map_size / frequency</code> . <br><br><h3>  Oitavas </h3><br>  Para tornar o mapa de altura mais interessante, <em>adicionaremos ruído com diferentes frequências</em> : <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/dr/wt/uj/drwtujuho39t3uluoanf5vthl6o.png"></div><br><br><pre> <code class="cpp hljs">elevation[y][x] = <span class="hljs-number"><span class="hljs-number">1</span></span> * noise(<span class="hljs-number"><span class="hljs-number">1</span></span> * nx, <span class="hljs-number"><span class="hljs-number">1</span></span> * ny); + <span class="hljs-number"><span class="hljs-number">0.5</span></span> * noise(<span class="hljs-number"><span class="hljs-number">2</span></span> * nx, <span class="hljs-number"><span class="hljs-number">2</span></span> * ny); + <span class="hljs-number"><span class="hljs-number">0.25</span></span> * noise(<span class="hljs-number"><span class="hljs-number">4</span></span> * nx, <span class="hljs-number"><span class="hljs-number">2</span></span> * ny);</code> </pre> <br>  Vamos misturar grandes colinas de baixa frequência com pequenas colinas de alta frequência em um mapa.  <strong>Mova o controle deslizante</strong> (no artigo original) para adicionar pequenas colinas à mistura: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/km/wh/bb/kmwhbbf29gwpdqcwtrbrnsighhw.gif"></div><br>  Agora é muito mais parecido com o relevo fractal que precisamos!  Podemos ter colinas e montanhas irregulares, mas ainda não temos planícies.  Para fazer isso, você precisa de outra coisa. <br><br><h3>  Redistribuição </h3><br>  A função de ruído fornece valores entre 0 e 1 (ou de -1 a +1, dependendo da biblioteca).  Para criar planícies planas, podemos <em>elevar a altura a uma potência</em> .  <strong>Mova o controle deslizante</strong> (no artigo original) para obter diferentes graus. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/3d/px/wc/3dpxwcatvtjknukqlih0hs7fecs.gif"></div><br><pre> <code class="cpp hljs">e = <span class="hljs-number"><span class="hljs-number">1</span></span> * noise(<span class="hljs-number"><span class="hljs-number">1</span></span> * nx, <span class="hljs-number"><span class="hljs-number">1</span></span> * ny); + <span class="hljs-number"><span class="hljs-number">0.5</span></span> * noise(<span class="hljs-number"><span class="hljs-number">2</span></span> * nx, <span class="hljs-number"><span class="hljs-number">2</span></span> * ny); + <span class="hljs-number"><span class="hljs-number">0.25</span></span> * noise(<span class="hljs-number"><span class="hljs-number">4</span></span> * nx, <span class="hljs-number"><span class="hljs-number">4</span></span> * ny); elevation[y][x] = Math.<span class="hljs-built_in"><span class="hljs-built_in">pow</span></span>(e, exponent);</code> </pre> <br>  Valores altos <em>abaixam as alturas médias das planícies</em> e valores baixos elevam as alturas médias para os picos das montanhas.  Precisamos omiti-los.  Uso funções de poder porque são mais simples, mas você pode usar qualquer curva;  Eu tenho uma <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">demonstração</a> mais complicada. <br><br>  Agora que temos um mapa de elevação realista, vamos adicionar biomas! <br><br><h2>  Biomas </h2><br>  O barulho dá números, mas precisamos de um mapa com florestas, desertos e oceanos.  A primeira coisa que você pode fazer é transformar pequenas alturas em água: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/et/hu/hv/ethuhvixmvjso_zt-_ev3gtu-tu.gif"></div><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">function </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">biome</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(e)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (e &lt; waterlevel) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> WATER; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> LAND; }</code> </pre> <br>  Uau, isso já está se tornando um mundo processualmente gerado!  Temos água, grama e neve.  Mas e se precisarmos de mais?  Vamos fazer uma sequência de água, areia, grama, floresta, savana, deserto e neve: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5fd/aa0/237/5fdaa023713e487a95fed02484380d03.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/656/1d9/8b4/6561d98b4ceda31b7ff49ece890e4e83.png"></div><br>  <i>Alívio baseado na altura</i> <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">function </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">biome</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(e)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (e &lt; <span class="hljs-number"><span class="hljs-number">0.1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> WATER; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (e &lt; <span class="hljs-number"><span class="hljs-number">0.2</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> BEACH; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (e &lt; <span class="hljs-number"><span class="hljs-number">0.3</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> FOREST; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (e &lt; <span class="hljs-number"><span class="hljs-number">0.5</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> JUNGLE; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (e &lt; <span class="hljs-number"><span class="hljs-number">0.7</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> SAVANNAH; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (e &lt; <span class="hljs-number"><span class="hljs-number">0.9</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> DESERT; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> SNOW; }</code> </pre> <br>  Uau, isso parece ótimo!  Para o seu jogo, você pode alterar os valores e os biomas.  Crysis terá muito mais selva;  Skyrim tem muito mais gelo e neve.  Mas não importa como você altere os números, essa abordagem é bastante limitada.  Os tipos de relevo correspondem a alturas, portanto formam faixas.  Para torná-los mais interessantes, precisamos escolher biomas baseados em outra coisa.  Vamos criar um <em>segundo</em> mapa de ruído para umidade. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4f4/1e3/de8/4f41e3de81e756ee9097be620ff5e08e.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c7c/b6a/317/c7cb6a31702505881dbbf3d2ddb1244b.png"></div><br>  <i>Acima está o barulho das alturas;</i>  <i>ruído de umidade inferior</i> <br><br>  Agora vamos usar altura e umidade <em>juntos</em> .  Na primeira imagem mostrada abaixo, o eixo y é a altura (tirada da imagem acima) e o eixo x é a umidade (a segunda imagem é mais alta).  Isso nos dá um mapa atraente: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0e9/34c/6c1/0e934c6c1358e89adc1b8e4e11b4b21c.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3ca/d11/e8e/3cad11e8edae614c2600342c37d6d4eb.png"></div><br>  <i>Alívio baseado em dois valores de ruído</i> <br><br>  Pequenas alturas são oceanos e costas.  Grandes alturas são rochosas e com neve.  No meio, obtemos uma ampla gama de biomas.  O código fica assim: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">function </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">biome</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(e, m)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (e &lt; <span class="hljs-number"><span class="hljs-number">0.1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> OCEAN; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (e &lt; <span class="hljs-number"><span class="hljs-number">0.12</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> BEACH; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (e &gt; <span class="hljs-number"><span class="hljs-number">0.8</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (m &lt; <span class="hljs-number"><span class="hljs-number">0.1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> SCORCHED; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (m &lt; <span class="hljs-number"><span class="hljs-number">0.2</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> BARE; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (m &lt; <span class="hljs-number"><span class="hljs-number">0.5</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> TUNDRA; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> SNOW; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (e &gt; <span class="hljs-number"><span class="hljs-number">0.6</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (m &lt; <span class="hljs-number"><span class="hljs-number">0.33</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> TEMPERATE_DESERT; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (m &lt; <span class="hljs-number"><span class="hljs-number">0.66</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> SHRUBLAND; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> TAIGA; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (e &gt; <span class="hljs-number"><span class="hljs-number">0.3</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (m &lt; <span class="hljs-number"><span class="hljs-number">0.16</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> TEMPERATE_DESERT; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (m &lt; <span class="hljs-number"><span class="hljs-number">0.50</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> GRASSLAND; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (m &lt; <span class="hljs-number"><span class="hljs-number">0.83</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> TEMPERATE_DECIDUOUS_FOREST; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> TEMPERATE_RAIN_FOREST; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (m &lt; <span class="hljs-number"><span class="hljs-number">0.16</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> SUBTROPICAL_DESERT; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (m &lt; <span class="hljs-number"><span class="hljs-number">0.33</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> GRASSLAND; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (m &lt; <span class="hljs-number"><span class="hljs-number">0.66</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> TROPICAL_SEASONAL_FOREST; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> TROPICAL_RAIN_FOREST; }</code> </pre> <br>  Se necessário, você pode alterar todos esses valores de acordo com os requisitos do seu jogo. <br><br>  Se não precisarmos de biomas, os gradientes suaves (consulte <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">este artigo</a> ) podem criar cores: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bd4/963/61d/bd496361d481367788a33ebece885cb6.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/28e/799/58e/28e79958eb0b9990fa9e1978fa727def.png"></div><br>  Para biomas e gradientes, um único valor de ruído não fornece variabilidade suficiente, mas dois são suficientes. <br><br><h2>  Clima </h2><br>  Na seção anterior, usei a <em>altitude</em> como substituto da <em>temperatura</em> .  Quanto maior a altura, menor a temperatura.  No entanto, a latitude geográfica também afeta as temperaturas.  Vamos usar a altura e a latitude para controlar a temperatura: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/mr/fz/qn/mrfzqnq2ouo7zupt4kscz5a2gv8.png"></div><br>  Perto dos pólos (grandes latitudes) o clima é mais frio, e no topo das montanhas (grandes alturas) o clima também é mais frio.  Até agora, resolvi isso não muito difícil: para a abordagem correta desses parâmetros, você precisa de muitas configurações sutis. <br><br>  Há também mudanças climáticas <em>sazonais</em> .  No verão e no inverno, os hemisférios norte e sul ficam mais quentes e frios, mas no equador a situação não muda muito.  Muito também pode ser feito aqui, por exemplo, é possível simular os ventos e as correntes oceânicas predominantes, o efeito dos biomas no clima e o efeito médio dos oceanos nas temperaturas. <br><br><h2>  As ilhas </h2><br>  Em alguns projetos, eu precisava que as bordas do mapa fossem de água.  Isso transforma o mundo em uma ou mais ilhas.  Existem várias maneiras de fazer isso, mas usei uma solução bastante simples em meu gerador de mapas de polígonos: Alterei a altura como <code>e = e + a - b*d^c</code> , onde <code>d</code> é a distância do centro (em uma escala de 0-1).  Outra opção é alterar <code>e = (e + a) * (1 - b*d^c)</code> .  A constante <code>a</code> eleva tudo, <code>b</code> abaixa as bordas e <code>c</code> controla a taxa de declínio. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/uq/gb/s4/uqgbs4h2ifsrwd2hsfvrrhue3ju.png"></div><br>  <em>Não estou completamente satisfeito com isso</em> e ainda há muito a ser explorado.  Deveria ser Manhattan ou distância euclidiana?  Deveria depender da distância ao centro ou da distância até a borda?  A distância deve ser ao quadrado, ou linear, ou ter algum outro grau?  Deveria ser adição / subtração, multiplicação / divisão ou qualquer outra coisa?  No artigo original, <b>tente</b> Adicionar, a = 0,1, b = 0,3, c = 2,0 ou <b>tente</b> Multiplicar, a = 0,05, b = 1,00, c = 1,5.  As opções adequadas a você dependem do seu projeto. <br><br>  Por que manter as funções matemáticas padrão?  Como contei no meu <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">artigo sobre danos no RPG</a> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">tradução</a> em Habré), todos (inclusive eu) usam funções matemáticas, como polinômios, distribuições exponenciais, etc., mas no computador não podemos nos limitar a eles.  Podemos pegar <em>qualquer</em> função de formação e usá-la aqui, usando a tabela de pesquisa <code>e = e + height_adjust[d]</code> .  Até agora, não estudei esse assunto. <br><br><h2>  Ruído espetado </h2><br>  Em vez de elevar a altura a uma potência, podemos usar o valor absoluto para criar picos agudos: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">function </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ridgenoise</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(nx, ny)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> * (<span class="hljs-number"><span class="hljs-number">0.5</span></span> - <span class="hljs-built_in"><span class="hljs-built_in">abs</span></span>(<span class="hljs-number"><span class="hljs-number">0.5</span></span> - noise(nx, ny))); }</code> </pre> <br>  Para adicionar oitavas, podemos variar as amplitudes das altas frequências para que apenas as montanhas recebam o ruído adicional: <br><br><pre> <code class="cpp hljs">e0 = <span class="hljs-number"><span class="hljs-number">1</span></span> * ridgenoise(<span class="hljs-number"><span class="hljs-number">1</span></span> * nx, <span class="hljs-number"><span class="hljs-number">1</span></span> * ny); e1 = <span class="hljs-number"><span class="hljs-number">0.5</span></span> * ridgenoise(<span class="hljs-number"><span class="hljs-number">2</span></span> * nx, <span class="hljs-number"><span class="hljs-number">2</span></span> * ny) * e0; e2 = <span class="hljs-number"><span class="hljs-number">0.25</span></span> * ridgenoise(<span class="hljs-number"><span class="hljs-number">4</span></span> * nx, <span class="hljs-number"><span class="hljs-number">4</span></span> * ny) * (e0+e1); e = e0 + e1 + e2; elevation[y][x] = Math.<span class="hljs-built_in"><span class="hljs-built_in">pow</span></span>(e, exponent);</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/webt/co/ku/kg/cokukg_3lgom28_bnm3cu4u-4dc.gif"></div><br>  Como não tenho muita experiência com essa técnica, preciso experimentar para aprender como usá-la bem.  Também pode ser interessante misturar ruídos pontiagudos de baixa frequência com ruídos não pontiagudos de alta frequência. <br><br><h2>  Terraços </h2><br>  Se arredondarmos a altura para os próximos n níveis, obteremos terraços: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/zv/bo/5k/zvbo5k_de80zv8utx6fxorpxfha.png"></div><br>  Este é o resultado da aplicação da função de redistribuição de altura no formato <code>e = f(e)</code> .  Acima, usamos <code>e = Math.pow(e, exponent)</code> para afiar os picos das montanhas;  aqui usamos <code>e = Math.round(e * n) / n</code> para criar terraços.  Se você usar uma função que não seja degrau, os terraços poderão ser arredondados ou ocorrer apenas em determinadas alturas. <br><br><h2>  Posicionamento em árvore </h2><br>  Geralmente usamos ruído fractal para altura e umidade, mas também pode ser usado para colocar objetos espaçados de maneira desigual, como árvores e pedras.  Para altura, usamos amplitudes altas com baixas frequências ("ruído vermelho").  Para colocar objetos, você precisa usar altas amplitudes com altas frequências ("ruído azul").  À esquerda, há um padrão de ruído azul;  à direita, são locais onde o ruído é maior que os valores adjacentes: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/xo/u4/ze/xou4zen4vzp46h3l7ecmcmdqsda.png"></div><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> yc = <span class="hljs-number"><span class="hljs-number">0</span></span>; yc &lt; height; yc++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> xc = <span class="hljs-number"><span class="hljs-number">0</span></span>; xc &lt; width; xc++) { <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> max = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-comment"><span class="hljs-comment">//     for (int yn = yc - R; yn &lt;= yc + R; yn++) { for (int xn = xc - R; xn &lt;= xc + R; xn++) { double e = value[yn][xn]; if (e &gt; max) { max = e; } } } if (value[yc][xc] == max) { //    xc,yc } } }</span></span></code> </pre> <br>  Escolhendo R diferente para cada bioma, podemos obter uma densidade variável de árvores: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/764/e0e/32a/764e0e32ac9171654161a94a29f66118.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/aa1/940/61f/aa194061fd97796c08238123b57199c7.png"></div><br>  É ótimo que esse ruído possa ser usado para colocar árvores, mas outros algoritmos geralmente são mais eficazes e criam uma distribuição mais uniforme: pontos Poisson, ladrilhos Van ou pontilhamento gráfico. <br><br><h2>  Para o infinito e além </h2><br>  Os cálculos do bioma na posição (x, y) são independentes dos cálculos de todas as outras posições.  Essa <strong>computação local</strong> possui duas propriedades convenientes: pode ser calculada em paralelo e pode ser usada para terrenos sem fim.  <strong>Coloque o cursor do mouse no minimapa</strong> (no artigo original) à esquerda para gerar o mapa à direita.  Você pode gerar qualquer parte do cartão sem gerar (e mesmo sem armazenar) o cartão inteiro. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/98b/932/152/98b932152f6c24f496034283fa904499.png"><img src="https://habrastorage.org/getpro/habr/post_images/6a5/811/c84/6a5811c84c56c1706aedbc505fc32aa9.png"><br><br><h2>  Implementação </h2><br>  Usar o ruído para gerar terreno é uma solução popular e, na Internet, você encontra tutoriais para diversos idiomas e plataformas.  O código para gerar cartões em diferentes idiomas é aproximadamente o mesmo.  Aqui está o loop mais simples em três idiomas diferentes: <br><br><ul><li>  <b>Javascript:</b> <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> gen = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SimplexNoise(); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">noise</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">nx, ny</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// Rescale from -1.0:+1.0 to 0.0:1.0 return gen.noise2D(nx, ny) / 2 + 0.5; } let value = []; for (let y = 0; y &lt; height; y++) { value[y] = []; for (let x = 0; x &lt; width; x++) { let nx = x/width - 0.5, ny = y/height - 0.5; value[y][x] = noise(nx, ny); } }</span></span></code> </pre> </li><li>  <b>C ++:</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">module</span></span>::Perlin gen; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">double</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">noise</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> nx, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> ny)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// Rescale from -1.0:+1.0 to 0.0:1.0 return gen.GetValue(nx, ny, 0) / 2.0 + 0.5; } double value[height][width]; for (int y = 0; y &lt; height; y++) { for (int x = 0; x &lt; width; x++) { double nx = x/width - 0.5, ny = y/height - 0.5; value[y][x] = noise(nx, ny); } }</span></span></code> </pre> </li><li>  <b>Python:</b> <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> opensimplex <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> OpenSimplex gen = OpenSimplex() <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">noise</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(nx, ny)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-comment"><span class="hljs-comment"># Rescale from -1.0:+1.0 to 0.0:1.0 return gen.noise2d(nx, ny) / 2.0 + 0.5 value = [] for y in range(height): value.append([0] * width) for x in range(width): nx = x/width - 0.5 ny = y/height - 0.5 value[y][x] = noise(nx, ny)</span></span></code> </pre> </li></ul><br>  Todas as bibliotecas de ruído são muito parecidas.  Tente <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">opensimplex para Python</a> , ou <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">libnoise para C ++</a> , ou <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">simplex-noise</a> para Javascript.  Para os idiomas mais populares, existem muitas bibliotecas de ruído.  Ou você pode aprender como funciona o ruído Perlin ou perceber o ruído você mesmo.  <em>Eu não fiz isso.</em> <br><br>  Em diferentes bibliotecas de ruído para o seu idioma, os detalhes do aplicativo podem variar um pouco (alguns números de retorno no intervalo de 0,0 a 1,0, outros no intervalo de -1,0 a +1,0), mas a idéia básica é a mesma.  Para um projeto real, pode ser necessário agrupar a função de <code>noise</code> e o objeto <code>gen</code> em uma classe, mas esses detalhes são irrelevantes, então eu os tornei globais. <br><br>  Para um projeto tão simples, não importa o ruído usado: ruído Perlin, ruído simplex, ruído OpenSimplex, ruído de valor, deslocamento do ponto médio, algoritmo de diamante ou a transformada inversa de Fourier.  Cada um deles tem seus prós e contras, mas para um gerador de cartões semelhante, todos criam mais ou menos os mesmos valores de saída. <br><br>  <em>A renderização do</em> mapa depende da plataforma e do jogo, então eu não o implementei;  esse código é necessário apenas para gerar alturas e biomas, cuja renderização depende do estilo usado no jogo.  Você pode copiar, portar e usá-lo em seus projetos. <br><br><h2>  Os experimentos </h2><br>  Eu olhei para misturar oitavas, elevar graus a uma potência e combinar alturas com umidade para criar um bioma.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Aqui</a> você pode estudar um gráfico interativo que permite experimentar todos esses parâmetros, o que mostra em que consiste o código: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/lh/yq/xn/lhyqxnbeaj0friycenleop7mcdw.png"></div><br>  Aqui está um código de exemplo: <br><br><pre> <code class="cpp hljs">var rng1 = PM_PRNG.create(seed1); var rng2 = PM_PRNG.create(seed2); var gen1 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SimplexNoise(rng1.nextDouble.bind(rng1)); var gen2 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SimplexNoise(rng2.nextDouble.bind(rng2)); <span class="hljs-function"><span class="hljs-function">function </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">noise1</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(nx, ny)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> gen1.noise2D(nx, ny)/<span class="hljs-number"><span class="hljs-number">2</span></span> + <span class="hljs-number"><span class="hljs-number">0.5</span></span>; } <span class="hljs-function"><span class="hljs-function">function </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">noise2</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(nx, ny)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> gen2.noise2D(nx, ny)/<span class="hljs-number"><span class="hljs-number">2</span></span> + <span class="hljs-number"><span class="hljs-number">0.5</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (var y = <span class="hljs-number"><span class="hljs-number">0</span></span>; y &lt; height; y++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (var x = <span class="hljs-number"><span class="hljs-number">0</span></span>; x &lt; width; x++) { var nx = x/width - <span class="hljs-number"><span class="hljs-number">0.5</span></span>, ny = y/height - <span class="hljs-number"><span class="hljs-number">0.5</span></span>; var e = (<span class="hljs-number"><span class="hljs-number">1.00</span></span> * noise1( <span class="hljs-number"><span class="hljs-number">1</span></span> * nx, <span class="hljs-number"><span class="hljs-number">1</span></span> * ny) + <span class="hljs-number"><span class="hljs-number">0.50</span></span> * noise1( <span class="hljs-number"><span class="hljs-number">2</span></span> * nx, <span class="hljs-number"><span class="hljs-number">2</span></span> * ny) + <span class="hljs-number"><span class="hljs-number">0.25</span></span> * noise1( <span class="hljs-number"><span class="hljs-number">4</span></span> * nx, <span class="hljs-number"><span class="hljs-number">4</span></span> * ny) + <span class="hljs-number"><span class="hljs-number">0.13</span></span> * noise1( <span class="hljs-number"><span class="hljs-number">8</span></span> * nx, <span class="hljs-number"><span class="hljs-number">8</span></span> * ny) + <span class="hljs-number"><span class="hljs-number">0.06</span></span> * noise1(<span class="hljs-number"><span class="hljs-number">16</span></span> * nx, <span class="hljs-number"><span class="hljs-number">16</span></span> * ny) + <span class="hljs-number"><span class="hljs-number">0.03</span></span> * noise1(<span class="hljs-number"><span class="hljs-number">32</span></span> * nx, <span class="hljs-number"><span class="hljs-number">32</span></span> * ny)); e /= (<span class="hljs-number"><span class="hljs-number">1.00</span></span>+<span class="hljs-number"><span class="hljs-number">0.50</span></span>+<span class="hljs-number"><span class="hljs-number">0.25</span></span>+<span class="hljs-number"><span class="hljs-number">0.13</span></span>+<span class="hljs-number"><span class="hljs-number">0.06</span></span>+<span class="hljs-number"><span class="hljs-number">0.03</span></span>); e = Math.<span class="hljs-built_in"><span class="hljs-built_in">pow</span></span>(e, <span class="hljs-number"><span class="hljs-number">5.00</span></span>); var m = (<span class="hljs-number"><span class="hljs-number">1.00</span></span> * noise2( <span class="hljs-number"><span class="hljs-number">1</span></span> * nx, <span class="hljs-number"><span class="hljs-number">1</span></span> * ny) + <span class="hljs-number"><span class="hljs-number">0.75</span></span> * noise2( <span class="hljs-number"><span class="hljs-number">2</span></span> * nx, <span class="hljs-number"><span class="hljs-number">2</span></span> * ny) + <span class="hljs-number"><span class="hljs-number">0.33</span></span> * noise2( <span class="hljs-number"><span class="hljs-number">4</span></span> * nx, <span class="hljs-number"><span class="hljs-number">4</span></span> * ny) + <span class="hljs-number"><span class="hljs-number">0.33</span></span> * noise2( <span class="hljs-number"><span class="hljs-number">8</span></span> * nx, <span class="hljs-number"><span class="hljs-number">8</span></span> * ny) + <span class="hljs-number"><span class="hljs-number">0.33</span></span> * noise2(<span class="hljs-number"><span class="hljs-number">16</span></span> * nx, <span class="hljs-number"><span class="hljs-number">16</span></span> * ny) + <span class="hljs-number"><span class="hljs-number">0.50</span></span> * noise2(<span class="hljs-number"><span class="hljs-number">32</span></span> * nx, <span class="hljs-number"><span class="hljs-number">32</span></span> * ny)); m /= (<span class="hljs-number"><span class="hljs-number">1.00</span></span>+<span class="hljs-number"><span class="hljs-number">0.75</span></span>+<span class="hljs-number"><span class="hljs-number">0.33</span></span>+<span class="hljs-number"><span class="hljs-number">0.33</span></span>+<span class="hljs-number"><span class="hljs-number">0.33</span></span>+<span class="hljs-number"><span class="hljs-number">0.50</span></span>); <span class="hljs-comment"><span class="hljs-comment">/* draw biome(e, m) at x,y */</span></span> } }</code> </pre> <br>  Existe uma dificuldade: para ruídos de altura e umidade, é necessário usar uma semente diferente; caso contrário, elas serão as mesmas e as cartas não parecerão tão interessantes.  Em Javascript, eu uso <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">a biblioteca prng-parkmiller</a> ;  em C ++, você pode usar dois <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">objetos linear_congruential_engine</a> separados;  no Python, você pode criar duas instâncias separadas de uma <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">classe random.Random</a> . <br><br><h2>  Pensamentos </h2><br>  Eu gosto dessa abordagem para mapear a geração por sua <b>simplicidade</b> .  É rápido e requer muito pouco código para produzir resultados decentes. <br><br>  Não gosto das limitações dele nessa abordagem.  Cálculos locais significam que cada ponto é independente de todos os outros.  Áreas diferentes do mapa <em>não</em> estão <em>conectadas entre si</em> .  Cada lugar no mapa "parece" o mesmo.  Não há restrições globais, por exemplo, “deve haver de 3 a 5 lagos no mapa” ou recursos globais, como um rio que flui do topo do pico mais alto para o oceano.  Além disso, não gosto do fato de que, para obter uma boa imagem, você precisa configurar os parâmetros por um longo tempo. <br><br>  Por que eu recomendo?  Penso que este é um bom ponto de partida, especialmente para jogos indie e compotas de jogos.  Dois dos meus amigos escreveram a versão inicial de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Realm of the Mad God em</a> apenas 30 dias para um <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">concurso de jogos</a> .  Eles me pediram para ajudar a criar mapas.  Eu usei essa técnica (além de mais alguns recursos que acabaram não sendo muito úteis) e fiz um mapa para eles.  Alguns meses depois, depois de receber feedback dos jogadores e estudar cuidadosamente o design do jogo, criamos um gerador de mapas mais avançado, baseado nos polígonos de Voronoi, descritos <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aqui</a> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">tradução</a> em Habré).  Este gerador de cartões não usa as técnicas descritas neste artigo.  Ele usa ruído para criar mapas de uma maneira completamente diferente. <br><br><h2>  Informações Adicionais </h2><br>  Há <em>muitas</em> coisas legais que você pode fazer com as funções de ruído.  Se você pesquisar na Internet, poderá encontrar opções como turbulência, ondulação, multifractal sulcado, amortecimento de amplitude, terraços, ruído voronoi, derivados analíticos, distorção de domínio e outros.  Você pode usar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">esta página</a> como fonte de inspiração.  Não os considero aqui, meu artigo se concentra na simplicidade. <br><br>  Este projeto foi influenciado pelos meus projetos anteriores de geração de mapas: <br><br><ul><li>  Usei o ruído geral de Perlin no <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">meu primeiro gerador de cartões Reino do Deus Louco</a> .  Nós o usamos nos primeiros seis meses de teste alfa e, em seguida, o substituímos por <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">um gerador de mapas nos polígonos Voronoi</a> , criado especialmente para os requisitos de jogabilidade que determinamos durante o teste alfa.  Os biomas e suas cores para o artigo são retirados desses projetos. </li><li>  Ao estudar o processamento de sinais de áudio, escrevi um <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">tutorial sobre ruído</a> que explica conceitos como frequência, amplitude, oitavas e a "cor" do ruído.  Os mesmos conceitos que funcionam para o som também se aplicam à geração de cartões com base em ruído.  Naquele momento, criei uma <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">geração</a> bruta de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">alívio de demonstração</a> , mas não a terminei. </li><li>  Às vezes, experimento encontrar limites.  Eu queria saber quanto código é minimamente necessário para criar mapas atraentes.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Neste mini-projeto,</a> cheguei a <b>zero</b> linha de código - tudo é feito com filtros de imagem (turbulência, limites, gradientes de cores).  Isso me deixou feliz e triste.  Até que ponto a geração de mapas pode ser realizada por filtros de imagem?  Em grande o suficiente.  Tudo o que foi descrito acima sobre o "esquema de gradientes de cores suaves" é retirado desta experiência.  A camada de ruído é um filtro de imagem de turbulência;  oitavas são imagens sobrepostas;  A ferramenta de graduação é chamada de "correção de curva" no Photoshop. </li></ul><br>  O que me incomoda um pouco é que a maior parte do código que os desenvolvedores de jogos escrevem para a geração de terreno com base em ruído (incluindo deslocamento do ponto médio) acaba sendo a mesma que nos filtros de som e imagem.  Por outro lado, ele cria resultados bastante decentes em apenas algumas linhas de código, e foi por isso que escrevi este artigo.  Este é um <em>ponto de referência rápido e fácil</em> .  Normalmente, não uso essas cartas por muito tempo, mas as substituo por um gerador de mapas mais complexo assim que descobrir quais tipos de cartas são mais adequados ao design do jogo.  Para mim, esse é um padrão padrão: começar com algo extremamente simples e substituí-lo somente depois que eu entender melhor o sistema com o qual estou trabalhando. <br><br>  Há <em>muito</em> mais coisas que podem ser feitas com ruído, no artigo que mencionei apenas algumas.  Experimente o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Noise Studio</a> para testar interativamente vários recursos. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt430384/">https://habr.com/ru/post/pt430384/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt430374/index.html">Engenharia de dados e muito mais: gravações de vídeo e slides da reunião</a></li>
<li><a href="../pt430376/index.html">Guia do JavaScript Parte 6: Exceções, ponto e vírgula, literais de modelo</a></li>
<li><a href="../pt430378/index.html">J2CL - Antes tarde do que nunca</a></li>
<li><a href="../pt430380/index.html">Guia JavaScript Parte 5: matrizes e loops</a></li>
<li><a href="../pt430382/index.html">Guia de JavaScript Parte 4: Recursos</a></li>
<li><a href="../pt430386/index.html">Usina de armazenamento de estado sólido a ser construída na Índia</a></li>
<li><a href="../pt430388/index.html">Desconfiança na Web Summit</a></li>
<li><a href="../pt430392/index.html">Como desenvolvo e teste APIs com minha “bicicleta” PieceofScript</a></li>
<li><a href="../pt430394/index.html">Implementando pesquisa instantânea no Android usando RxJava</a></li>
<li><a href="../pt430396/index.html">Replicação em cadeia: construindo um repositório KV eficaz (parte 1/2)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>