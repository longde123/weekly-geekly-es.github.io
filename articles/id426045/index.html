<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏿‍🔧 🕺🏼 🙆🏾 Pengecualian khusus dalam .NET dan cara menyiapkannya 🚒 🤞 🤟🏾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Berbagai pengecualian di .NET memiliki karakteristiknya sendiri, dan dapat sangat berguna untuk mengetahuinya. Bagaimana cara menipu CLR? Bagaimana ag...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Pengecualian khusus dalam .NET dan cara menyiapkannya</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/jugru/blog/426045/">  Berbagai pengecualian di .NET memiliki karakteristiknya sendiri, dan dapat sangat berguna untuk mengetahuinya.  Bagaimana cara menipu CLR?  Bagaimana agar tetap hidup di runtime dengan menangkap StackOverflowException?  Pengecualian apa yang tampaknya tidak mungkin ditangkap, tetapi jika Anda benar-benar menginginkannya, bukan? <br><br><img src="https://habrastorage.org/getpro/habr/post_images/4f1/314/78d/4f131478de33b4a6acd0ed25a0e53987.png"><br><br>  Di bawah potongan, transkrip laporan Eugene ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" class="user_link">epeshk</a> ) <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" class="user_link">Peshkov</a> dari konferensi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Piter DotNext 2018</a> kami, di mana ia membicarakan hal ini dan fitur pengecualian lainnya. <br><a name="habracut"></a><br><iframe width="560" height="315" src="https://www.youtube.com/embed/WLSrYgMWif4" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><br>  Hai  Nama saya Eugene.  Saya bekerja untuk SKB Kontur dan mengembangkan sistem hosting dan menyebarkan aplikasi untuk Windows.  Intinya adalah bahwa kami memiliki banyak tim produk yang menulis layanan mereka sendiri dan menjamu mereka bersama kami.  Kami memberi mereka solusi mudah dan sederhana untuk berbagai tugas infrastruktur.  Misalnya, untuk memantau konsumsi sumber daya sistem atau menyelesaikan replika ke layanan. <br><br>  Terkadang ternyata aplikasi yang dihosting di sistem kami berantakan.  Kami telah melihat banyak cara bagaimana aplikasi dapat crash di runtime.  Salah satu metode tersebut adalah membuang beberapa pengecualian yang tak terduga dan mempesona. <br><br>  Hari ini saya akan berbicara tentang fitur pengecualian di .NET.  Kami menemui beberapa fitur ini dalam produksi, dan beberapa di antaranya dalam proses percobaan. <br><br><h2>  Rencanakan </h2><br><ol><li>  .NET Exception Behavior <br></li><li>  Penanganan pengecualian Windows dan peretasan <br></li></ol><br>  Semua hal berikut ini berlaku untuk Windows.  Semua contoh diuji pada versi terbaru dari kerangka penuh .NET 4.7.1.  Juga akan ada beberapa referensi untuk .NET Core. <br><br><h2>  Pelanggaran akses </h2><br>  Pengecualian ini terjadi selama operasi memori yang salah.  Misalnya, jika suatu aplikasi mencoba mengakses area memori yang tidak dapat diaksesnya.  Pengecualiannya adalah level rendah, dan biasanya, jika itu terjadi, diperlukan debugging yang sangat lama. <br><br>  Mari kita coba dapatkan pengecualian ini menggunakan C #.  Untuk melakukan ini, kami menulis byte 42 ke alamat 1000 (kami menganggap bahwa 1000 adalah alamat yang cukup acak dan aplikasi kami kemungkinan besar tidak memiliki akses ke sana). <br><br><pre><code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { Marshal.WriteByte((IntPtr) <span class="hljs-number"><span class="hljs-number">1000</span></span>, <span class="hljs-number"><span class="hljs-number">42</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (AccessViolationException) { ... }</code> </pre> <br>  WriteByte melakukan apa yang kita butuhkan: ia menulis byte ke alamat yang diberikan.  Kami berharap panggilan ini untuk melemparkan AccessViolationException.  Kode ini memang akan membuang pengecualian ini, itu akan dapat menangani dan aplikasi akan terus bekerja.  Sekarang mari kita ubah sedikit kode: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> bytes = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[] {<span class="hljs-number"><span class="hljs-number">42</span></span>}; Marshal.Copy(bytes, <span class="hljs-number"><span class="hljs-number">0</span></span>, (IntPtr) <span class="hljs-number"><span class="hljs-number">1000</span></span>, bytes.Length); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (AccessViolationException) { ... }</code> </pre><br>  Jika alih-alih WriteByte Anda menggunakan metode Salin dan salin byte 42 ke alamat 1000, kemudian menggunakan try-catch, AccessViolation tidak dapat ditangkap.  Pada saat yang sama, sebuah pesan akan ditampilkan pada konsol yang menyatakan bahwa aplikasi dihentikan karena AccessViolationException yang tidak ditangani. <br><br><pre> <code class="cs hljs">Marshal.Copy(bytes, <span class="hljs-number"><span class="hljs-number">0</span></span>, (IntPtr) <span class="hljs-number"><span class="hljs-number">1000</span></span>, bytes.Length); Marshal.WriteByte((IntPtr) <span class="hljs-number"><span class="hljs-number">1000</span></span>, <span class="hljs-number"><span class="hljs-number">42</span></span>);</code> </pre><br>  Ternyata kami memiliki dua baris kode, sedangkan yang pertama crash seluruh aplikasi dengan AccessViolation, dan yang kedua melempar pengecualian yang diproses dari jenis yang sama.  Untuk memahami mengapa ini terjadi, kita akan melihat bagaimana metode ini diatur dari dalam. <br><br>  Mari kita mulai dengan metode Salin. <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Copy</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">...</span></span></span><span class="hljs-function">)</span></span> { Marshal.CopyToNative((<span class="hljs-keyword"><span class="hljs-keyword">object</span></span>) source, startIndex, destination, length); } [MethodImpl(MethodImplOptions.InternalCall)] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">extern</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CopyToNative</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params"> source, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> startIndex, IntPtr destination, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> length</span></span></span><span class="hljs-function">)</span></span>;</code> </pre><br>  Satu-satunya hal yang dilakukan metode Salin adalah memanggil metode CopyToNative, diimplementasikan dalam.  Jika aplikasi kita masih macet dan pengecualian terjadi di suatu tempat, maka ini hanya dapat terjadi di dalam CopyToNative.  Dari sini kita dapat melakukan pengamatan pertama: jika kode .NET disebut kode asli dan AccessViolation terjadi di dalamnya, maka kode .NET tidak dapat menangani pengecualian ini karena beberapa alasan. <br><br>  Sekarang kita akan mengerti mengapa dimungkinkan untuk memproses AccessViolation menggunakan metode WriteByte.  Mari kita lihat kode untuk metode ini: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">unsafe</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">WriteByte</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IntPtr ptr, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">byte</span></span></span></span><span class="hljs-function"><span class="hljs-params"> val</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { *(<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>*) ptr = val; } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (NullReferenceException) {     <span class="hljs-comment"><span class="hljs-comment">// this method is documented to throw AccessViolationException on any AV throw new AccessViolationException(); } }</span></span></code> </pre><br>  Metode ini sepenuhnya diterapkan dalam kode terkelola.  Menggunakan C # -pointer untuk menulis data ke alamat yang diinginkan, dan juga menangkap NullReferenceException.  Jika NRE dicegat, AccessViolationException dilempar.  Jadi itu perlu karena <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">spesifikasinya</a> .  Dalam hal ini, semua pengecualian yang dilemparkan oleh konstruk lemparan ditangani.  Dengan demikian, jika NullReferenceException terjadi selama eksekusi kode di dalam WriteByte, kita bisa menangkap AccessViolation.  Bisakah NRE terjadi, dalam kasus kami, ketika mengakses alamat 1000 daripada alamat nol? <br><br>  Kami menulis ulang kode menggunakan pointer C # secara langsung, dan melihat bahwa ketika mengakses alamat yang tidak nol, NullReferenceException sebenarnya dilemparkan: <br><br><pre> <code class="cs hljs">*(<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>*) <span class="hljs-number"><span class="hljs-number">1000</span></span> = <span class="hljs-number"><span class="hljs-number">42</span></span>;</code> </pre><br>  Untuk memahami mengapa ini terjadi, kita perlu mengingat bagaimana memori proses bekerja.  Dalam memori proses, semua alamat adalah virtual.  Ini berarti bahwa aplikasi memiliki ruang alamat yang besar dan hanya beberapa halaman darinya yang ditampilkan dalam memori fisik nyata.  Tetapi ada kekhasan: alamat 64 KB pertama tidak pernah dipetakan ke memori fisik dan tidak diberikan ke aplikasi.  Rantime .NET tahu ini dan menggunakannya.  Jika AccessViolation terjadi dalam kode yang dikelola, maka runtime akan memeriksa alamat mana dalam memori yang diakses dan menghasilkan pengecualian yang sesuai.  Untuk alamat dari 0 hingga 2 ^ 16 - NullReference, untuk semua yang lain - AccessViolation. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/775/3d4/38f/7753d438fc8a977ac0bb54e431d81c6f.png"><br><br>  Mari kita lihat mengapa NullReference terlempar tidak hanya saat mengakses ke alamat nol.  Bayangkan Anda sedang mengakses bidang objek jenis referensi, dan referensi ke objek ini adalah nol: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/127/a27/867/127a27867ef7a568a242797758855b44.png"><br><br>  Dalam situasi ini, kami berharap mendapatkan NullReferenceException.  Akses ke bidang objek terjadi dengan mengimbangi relatif ke alamat objek ini.  Ternyata kami akan beralih ke alamat yang cukup dekat ke nol (ingat bahwa tautan ke objek asli kami adalah nol).  Dengan perilaku runtime ini, kami mendapatkan pengecualian yang diharapkan tanpa verifikasi tambahan dari alamat objek itu sendiri. <br><br>  Tetapi apa yang terjadi jika kita beralih ke bidang objek, dan objek ini sendiri membutuhkan lebih dari 64 KB? <br><br><img src="https://habrastorage.org/getpro/habr/post_images/356/897/143/356897143b1275403569dc9f9a71471a.png"><br><br>  Bisakah kita mendapatkan AccessViolation dalam kasus ini?  Ayo lakukan percobaan.  Mari kita buat objek yang sangat besar dan kita akan merujuk ke bidangnya.  Satu bidang di awal objek, yang kedua di akhir: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/08d/619/95a/08d61995a01630f94f31f759890af4a8.png"><br><br>  Kedua metode akan melempar NullReferenceException.  AccessViolationException tidak akan terjadi. <br>  Mari kita lihat instruksi yang akan dihasilkan untuk metode ini.  Dalam kasus kedua, kompiler JIT menambahkan instruksi cmp tambahan yang mengakses alamat objek itu sendiri, sehingga memanggil AccessViolation dengan alamat nol, yang akan dikonversi oleh runtime ke NullReferenceException. <br><br>  Perlu dicatat bahwa untuk percobaan ini tidak cukup menggunakan array sebagai objek besar.  Mengapa  Serahkan pertanyaan ini kepada pembaca, tulis ide di komentar :) <br><br>  Mari kita simpulkan eksperimen dengan AccessViolation. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ffa/86b/0a8/ffa86b0a85f29a16936c92845f5d3e1e.png"><br><br>  AccessViolationException berperilaku berbeda tergantung di mana pengecualian terjadi (dalam kode terkelola atau asli).  Selain itu, jika pengecualian terjadi pada kode yang dikelola, alamat objek akan diperiksa. <br><br>  Pertanyaannya adalah: dapatkah kita menangani AccessViolationException yang terjadi dalam kode asli atau dalam kode terkelola, tetapi tidak dikonversi ke NullReference dan tidak dibuang menggunakan lemparan?  Ini kadang-kadang fitur yang berguna, terutama ketika bekerja dengan kode yang tidak aman.  Jawaban untuk pertanyaan ini tergantung pada versi .NET. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/67a/785/318/67a785318bc8b5f084a3b23fa36e766b.png"><br><br>  Di .NET 1.0, sama sekali tidak ada AccessViolationException.  Semua tautan dianggap valid atau null.  Pada saat .NET 2.0, menjadi jelas bahwa tanpa kerja langsung dengan memori - tidak mungkin, dan AccessViolation muncul, sementara itu dapat diproses.  Di 4.0 dan di atas, itu masih bisa diterapkan, tetapi memprosesnya tidak begitu sederhana.  Untuk menangkap pengecualian ini, Anda sekarang harus menandai metode di mana blok tangkap terletak dengan atribut HandleProcessCorruptedStateException.  Rupanya, para pengembang melakukan ini karena mereka berpikir bahwa AccessViolationException bukan pengecualian yang harus ditangkap dalam aplikasi reguler. <br>  Selain itu, untuk kompatibilitas ke belakang, dimungkinkan untuk menggunakan pengaturan runtime: <br><br><ul><li>  legacyNullReferenceExceptionPolicy mengembalikan perilaku .NET 1.0 - semua AV berubah menjadi NRE <br></li><li>  legacyCorruptedStateExceptionsPolicy mengembalikan perilaku .NET 2.0 - semua AV dicegat <br></li></ul><br>  Di .NET, Core AccessViolation tidak ditangani sama sekali. <br><br>  Dalam produksi kami ada situasi seperti itu: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ad7/0f1/6d3/ad70f16d3438d1e8ab80e43ba29d5412.png"><br><br>  Aplikasi yang dibangun di bawah .NET 4.7.1 menggunakan pustaka kode bersama yang dibangun di bawah .NET 3.5.  Ada pembantu di perpustakaan ini untuk menjalankan tindakan berkala: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (isRunning) { <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { action(); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (Exception e) { log.Error(e); } WaitForNextExecution(... ); }</code> </pre><br>  Kami meneruskan tindakan dari aplikasi kami ke penolong ini.  Kebetulan dia jatuh dengan AccessViolation.  Akibatnya, aplikasi kami terus-menerus mencatat AccessViolation, alih-alih mogok karena  kode di perpustakaan di bawah 3,5 bisa menangkapnya.  Perlu dicatat bahwa intersepsi tidak tergantung pada versi runtime tempat aplikasi berjalan, tetapi pada TargetFramework, di mana aplikasi itu dibangun, dan dependensinya. <br><br>  Untuk meringkas.  Pemrosesan AccessVilolation tergantung pada asalnya - dalam kode asli atau dikelola - serta pengaturan TargetFramework dan runtime. <br><br><h2>  Batalkan utas </h2><br>  Terkadang dalam kode Anda harus menghentikan eksekusi salah satu utas.  Untuk melakukan ini, Anda dapat menggunakan utas. Amort (); <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> thread = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Thread(() =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { ... } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (ThreadAbortException e) { ... Thread.ResetAbort(); } }); ... thread.Abort();</code> </pre><br>  Ketika metode Abort dipanggil dalam thread yang dihentikan, sebuah ThreadAbortException dilemparkan.  Mari kita menganalisis fitur-fiturnya.  Misalnya, kode seperti ini: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> thread = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Thread(() =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { … } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (ThreadAbortException e) { … } }); ... thread.Abort();</code> </pre><br>  Sepadan dengan ini: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> thread = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Thread(() =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { ... } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (ThreadAbortException e) { ... <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span>; } }); ... thread.Abort();</code> </pre><br>  Jika Anda masih perlu memproses ThreadAbort dan melakukan beberapa tindakan lain di utas terhenti, maka Anda dapat menggunakan metode Thread.ResetAbort ();  Ini menghentikan proses menghentikan aliran dan pengecualian berhenti melemparkan lebih tinggi ke tumpukan.  Penting untuk memahami bahwa metode thread.Abort () itu sendiri tidak menjamin apa pun - kode di utas terhenti dapat mencegahnya berhenti. <br><br>  Fitur lain dari thread.Abort () adalah bahwa ia tidak akan dapat mengganggu kode jika ada dalam tangkapan dan akhirnya blok. <br><br>  Di dalam kode kerangka kerja, Anda sering dapat menemukan metode di mana blok coba kosong dan semua logika akhirnya ada di dalam.  Ini dilakukan hanya untuk mencegah kode ini dilempar oleh ThreadAbortException. <br><br>  Juga, panggilan ke metode thread.Abort () menunggu untuk ThreadAbortException untuk melemparkan.  Gabungkan kedua fakta ini dan dapatkan bahwa metode thread.Abort () dapat memblokir utas panggilan. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> thread = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Thread(() =&gt; {   <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { }       <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> { } <span class="hljs-comment"><span class="hljs-comment">// &lt;-- No ThreadAbortException in catch       finally { // &lt;-- No ThreadAbortException in finally           Thread.Sleep(- 1); } }); thread.Start(); ... thread.Abort(); // Never returns</span></span></code> </pre><br>  Pada kenyataannya, ini bisa ditemui ketika menggunakan menggunakan.  Itu digunakan di try / akhirnya, di dalam akhirnya, metode Buang disebut.  Ini bisa kompleks semena-mena, berisi penangan acara, gunakan kunci.  Dan jika thread.Abort dipanggil saat dijalankan, Buang - thread.Abort () akan menunggu untuk itu.  Jadi kami mendapatkan kunci hampir dari awal. <br><br>  Dalam .NET Core, metode thread.Abort () melempar PlatformNotSupportedException.  Dan saya pikir ini sangat bagus, karena itu memotivasi saya untuk menggunakan bukan thread.Abort (), tetapi metode non-invasif untuk menghentikan eksekusi kode, misalnya menggunakan CancelledToken. <br><br><h2>  LUAR MEMORI </h2><br>  Pengecualian ini dapat diperoleh jika memori pada mesin kurang dari yang dibutuhkan.  Atau ketika kita mengalami keterbatasan proses 32-bit.  Tetapi Anda bisa mendapatkannya bahkan jika komputer memiliki banyak memori bebas, dan prosesnya 64-bit. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> arr4gb = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>.MaxValue/<span class="hljs-number"><span class="hljs-number">2</span></span>];</code> </pre><br>  Kode di atas akan membuang OutOfMemory.  Masalahnya adalah, secara default, objek yang lebih besar dari 2 GB tidak diperbolehkan.  Ini dapat diperbaiki dengan mengatur gcAllowVeryLargeObjects di App.config.  Dalam hal ini, array 4 GB dibuat. <br><br>  Sekarang mari kita coba membuat array lebih banyak lagi. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> largeArr = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>.MaxValue];</code> </pre><br>  Sekarang bahkan gcAllowVeryLargeObjects tidak akan membantu.  Ini karena .NET memiliki <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">batasan pada indeks maksimum dalam array</a> .  Pembatasan ini kurang dari int.MaxValue. <br><br>  Indeks array maks: <br><br><ul><li>  array byte - 0x7FFFFFC7 <br></li><li>  array lainnya - 0X7F <b>E</b> FFFFF <br></li></ul><br>  Dalam hal ini, OutOfMemoryException akan terjadi, meskipun pada kenyataannya kita telah menghadapi pembatasan tipe data, bukan kekurangan memori. <br><br>  Terkadang OutOfMemory secara eksplisit dibuang oleh kode terkelola di dalam kerangka .NET: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/efd/c84/d98/efdc84d98a7786e39c9c5931ac523d13.png"><br>  Ini adalah implementasi dari metode string.Compat.  Jika panjang string hasil lebih besar dari int.MaxValue, OutOfMemoryException segera dibuang. <br><br>  Mari kita beralih ke situasi ketika OutOfMemory muncul dalam kasus ketika memori benar-benar habis. <br><br><pre> <code class="cs hljs">LimitMemory(<span class="hljs-number"><span class="hljs-number">64.</span></span>Mb()); <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-literal"><span class="hljs-literal">true</span></span>)   list.Add(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[size]); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (OutOfMemoryException e) { Console.WriteLine(e); }</code> </pre><br>  Pertama, kami membatasi memori proses kami menjadi 64 MB.  Selanjutnya, di dalam loop, pilih array byte baru, simpan ke beberapa lembar sehingga GC tidak mengumpulkannya, dan cobalah untuk menangkap OutOfMemory. <br><br>  Dalam hal ini, apa pun bisa terjadi: <br><br><ul><li>  Pengecualian ditangani <br></li><li>  Proses akan jatuh <br></li><li>  Mari kita menangkap, tetapi pengecualian akan crash lagi <br></li><li>  Mari kita mulai menangkap, tetapi StackOverflow akan crash <br></li></ul><br>  Dalam hal ini, program akan sepenuhnya non-deterministik.  Mari kita menganalisis semua opsi: <br><br><ol><li>  Pengecualian dapat ditangani.  Di dalam .NET, tidak ada yang menghentikan Anda dari menangani OutOfMemoryException. <br></li><li>  Prosesnya mungkin jatuh.  Jangan lupa bahwa kami memiliki aplikasi yang dikelola.  Ini berarti bahwa di dalamnya dieksekusi tidak hanya kode kita, tetapi juga kode runtime.  Misalnya, GC.  Dengan demikian, suatu situasi dapat terjadi ketika runtime ingin mengalokasikan memori untuk dirinya sendiri, tetapi tidak dapat melakukannya, maka kita tidak akan dapat menangkap pengecualian. <br></li><li>  Mari kita masuk ke tangkapan, tetapi pengecualian akan crash lagi.  Di dalam tangkapan, kami juga melakukan pekerjaan di mana kami membutuhkan memori (kami mencetak pengecualian untuk konsol), dan ini dapat menyebabkan pengecualian baru. <br></li><li>  Mari kita mulai menangkap, tetapi StackOverflow akan crash.  StackOverflow sendiri terjadi ketika metode WriteLine dipanggil, tetapi tidak ada stack overflow di sini, tetapi situasi yang berbeda terjadi.  Mari kita analisa lebih detail. <br></li></ol><br><img src="https://habrastorage.org/getpro/habr/post_images/6e3/d32/752/6e3d32752ba10fd39d1f4a5e2e6648a7.png"><br><br>  Dalam memori virtual, halaman tidak hanya dapat dipetakan ke memori fisik, tetapi juga dapat dipesan.  Jika halaman dicadangkan, maka aplikasi mencatat bahwa itu akan menggunakannya.  Jika halaman sudah dipetakan ke memori nyata atau swap, maka itu disebut "berkomitmen" (berkomitmen).  Tumpukan menggunakan kemampuan ini untuk membagi memori menjadi cadangan dan berkomitmen.  Itu terlihat seperti ini: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/b17/9e4/41f/b179e441f0c00f18e2a5fdf12b3093a9.png"><br><br>  Ternyata kita memanggil metode WriteLine, yang mengambil beberapa tempat di stack.  Ternyata semua memori yang dikunci telah berakhir, yang berarti sistem operasi saat ini harus mengambil halaman cadangan lain di tumpukan dan memetakannya ke memori fisik nyata, yang sudah diisi dengan byte array.  Ini mengarah ke pengecualian StackOverflow. <br><br>  Kode berikut akan memungkinkan Anda untuk mengkomit semua memori ke stack pada awal aliran sekaligus. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Thread(() =&gt; F(), <span class="hljs-number"><span class="hljs-number">4</span></span>*<span class="hljs-number"><span class="hljs-number">1024</span></span>*<span class="hljs-number"><span class="hljs-number">1024</span></span>).Start();</code> </pre><br>  Atau, Anda dapat menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pengaturan runtime</a> disableCommitThreadStack.  Itu perlu dinonaktifkan agar tumpukan thread dilakukan sebelumnya.  Perlu dicatat bahwa perilaku default yang dijelaskan dalam dokumentasi dan diamati pada kenyataannya berbeda. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/46e/0e6/dbd/46e0e6dbd47906fb1d0ddf74ac927383.png"><br><br><h2>  Stack overflow </h2><br>  Mari kita lihat lebih dekat StackOverflowException.  Mari kita lihat dua contoh kode.  Di salah satu dari mereka, kita menjalankan rekursi tak terbatas, yang mengarah ke stack overflow, yang kedua kita hanya melempar pengecualian ini dengan throw. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { InfiniteRecursion(); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (Exception) { ... }</code> </pre><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StackOverflowException(); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (Exception) { ... }</code> </pre><br>  Karena semua pengecualian yang dilemparkan dengan lemparan ditangani, dalam kasus kedua kita akan menangkap pengecualian.  Dan dengan kasus pertama, semuanya lebih menarik.  Beralih ke <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">MSDN</a> : <br><br><blockquote>  "Anda tidak dapat menangkap pengecualian stack overflow, karena kode penanganan pengecualian mungkin memerlukan stack." <br>  MSDN </blockquote><br>  Dikatakan di sini bahwa kita tidak akan dapat menangkap StackOverflowException, karena intersepsi itu sendiri mungkin memerlukan ruang stack tambahan yang telah berakhir. <br><br>  Untuk melindungi dari pengecualian ini, kita dapat melakukan hal berikut.  Pertama, Anda dapat membatasi kedalaman rekursi.  Kedua, Anda bisa menggunakan metode dari kelas RuntimeHelpers: <br><br><blockquote>  RuntimeHelpers.EnsureSufficientExecutionStack (); <br><br><ul><li>  "Memastikan bahwa ruang tumpukan yang tersisa cukup besar untuk menjalankan fungsi .NET Framework."  - MSDN <br></li><li>  InsufficientExecutionStackException <br></li><li>  512 KB - x86, AnyCPU, 2 MB - x64 (setengah dari ukuran tumpukan) <br></li><li>  64/128 KB - .NET Core <br></li><li>  Periksa hanya ruang alamat tumpukan <br></li></ul><br></blockquote><br>  Dokumentasi untuk metode ini mengatakan bahwa ia memeriksa bahwa ada cukup ruang pada stack untuk menjalankan fungsi .NET.  Tapi apa fungsi <i>rata</i> - <i>rata</i> ?  Bahkan, dalam .NET Framework metode ini memverifikasi bahwa setidaknya setengah dari ukurannya gratis di stack.  Di .NET Core, ia memeriksa 64K gratis. <br><br>  Sebuah analog juga telah muncul di .NET Core: RuntimeHelpers.TryEnsureSufficientExecutionStack () yang mengembalikan bool, daripada melempar pengecualian. <br><br>  C # 7.2 memperkenalkan kemampuan untuk menggunakan Span dan stackallock bersama tanpa menggunakan kode yang tidak aman.  Mungkin karena ini, stackalloc akan lebih sering digunakan dalam kode dan akan berguna untuk memiliki cara untuk melindungi diri Anda dari StackOverflow saat menggunakannya, memilih tempat untuk mengalokasikan memori.  Dengan demikian, diusulkan metode <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">yang memverifikasi kemungkinan alokasi pada stack</a> dan konstruksi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">trystackalloc</a> . <br><br><pre> <code class="cs hljs">Span&lt;<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>&gt; span; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (CanAllocateOnStack(size)) span = <span class="hljs-keyword"><span class="hljs-keyword">stackalloc</span></span> <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[size]; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> span = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[size];</code> </pre><br>  Kembali ke dokumentasi StackOverflow di MSDN <br><br><blockquote>  Sebaliknya, ketika stack overflow terjadi dalam <b>aplikasi normal</b> , Common Language Runtime (CLR) mengakhiri proses. " <br>  MSDN <br></blockquote><br>  Jika ada aplikasi "normal" yang jatuh selama StackOverflow, lalu ada aplikasi non-normal yang tidak jatuh?  Untuk menjawab pertanyaan ini, Anda harus turun dari level aplikasi terkelola ke level CLR. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/186/516/64d/18651664dd1c1d1346e5377f0e0b3995.png"><br><br><blockquote>  "Sebuah aplikasi yang <b>meng-host CLR</b> dapat mengubah perilaku default dan menentukan bahwa CLR <b>membongkar domain aplikasi</b> tempat pengecualian terjadi, tetapi membiarkan proses berlanjut."  - MSDN <br>  StackOverflowException -&gt; AppDomainUnloadedException <br></blockquote><br>  Aplikasi yang meng-host CLR dapat mendefinisikan kembali perilaku stack overflow sehingga alih-alih menyelesaikan seluruh proses, Domain Aplikasi diturunkan, dalam aliran yang terjadi overflow ini.  Jadi kita bisa mengubah StackOverflowException menjadi AppDomainUnloadedException. <br><br>  Ketika aplikasi yang dikelola diluncurkan, runtime .NET secara otomatis dimulai.  Tetapi Anda bisa pergi ke arah lain.  Misalnya, tulis aplikasi yang tidak dikelola (dalam C ++ atau bahasa lain) yang akan menggunakan API khusus untuk menaikkan CLR dan meluncurkan aplikasi kami.  Aplikasi yang menjalankan CLR secara internal akan disebut CLR-host.  Dengan menulisnya, kita dapat mengonfigurasi banyak hal dalam runtime.  Misalnya, ganti manajer memori dan manajer utas.  Kami dalam produksi menggunakan CLR-host untuk menghindari pertukaran halaman memori. <br><br>  Kode berikut mengonfigurasi host CLR sehingga AppDomain (C ++) diturunkan saat StackOverflow: <br><br><pre> <code class="cpp hljs">ICLRPolicyManager *policyMgr; pCLRControl-&gt;GetCLRManager(IID_ICLRPolicyManager, (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>**) (&amp;policyMgr)); policyMgr-&gt;SetActionOnFailure(FAIL_StackOverflow, eRudeUnloadAppDomain);</code> </pre><br>  Apakah ini cara yang baik untuk melarikan diri dari StackOverflow?  Mungkin tidak terlalu.  Pertama, kami harus menulis kode C ++, yang tidak ingin kami lakukan.  Kedua, kita harus mengubah kode C # kita sehingga fungsi yang dapat melempar StackOverflowException dieksekusi di AppDomain terpisah dan di utas terpisah.  Kode kami akan segera berubah menjadi mie tersebut: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> appDomain = AppDomain.CreateDomain(<span class="hljs-string"><span class="hljs-string">"..."</span></span>); appDomain.DoCallBack(() =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> thread = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Thread(() =&gt; InfiniteRecursion()); thread.Start(); thread.Join(); }); AppDomain.Unload(appDomain); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (AppDomainUnloadedException) { }</code> </pre><br>  Untuk memanggil metode InfiniteRecursion, kami menulis banyak baris.  Ketiga, kami mulai menggunakan AppDomain.  Dan ini hampir menjamin banyak masalah baru.  Termasuk dengan pengecualian.  Pertimbangkan sebuah contoh: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">CustomException</span></span> : <span class="hljs-title"><span class="hljs-title">Exception</span></span> {} <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> appDomain = AppDomain.CreateDomain( <span class="hljs-string"><span class="hljs-string">"..."</span></span>); appDomain.DoCallBack(() =&gt; <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CustomException()); System.Runtime.Serialization.SerializationException: Type <span class="hljs-string"><span class="hljs-string">'CustomException'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> not marked <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> serializable. at System.AppDomain.DoCallBack(CrossAppDomainDelegate callBackDelegate)</code> </pre><br>  Karena pengecualian kami tidak ditandai sebagai serializable, kode kami akan turun dengan SerializationException.  Dan untuk memperbaiki masalah ini, tidak cukup bagi kita untuk menandai pengecualian kita dengan atribut Serializable, kita masih perlu mengimplementasikan konstruktor tambahan untuk serialisasi. <br><br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">Serializable</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">CustomException</span></span> : <span class="hljs-title"><span class="hljs-title">Exception</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CustomException</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CustomException</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">SerializationInfo info, StreamingContext ctx</span></span></span><span class="hljs-function">) : </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">base</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">info, context</span></span></span><span class="hljs-function">)</span></span>{} } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> appDomain = AppDomain.CreateDomain(<span class="hljs-string"><span class="hljs-string">"..."</span></span>); appDomain.DoCallBack(() =&gt; <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CustomException());</code> </pre><br>  Itu semua ternyata tidak terlalu indah, jadi kita melangkah lebih jauh - ke tingkat sistem operasi dan peretasan, yang seharusnya tidak digunakan dalam produksi. <br><br><h2>  Seh / kend </h2><br><img src="https://habrastorage.org/getpro/habr/post_images/2c5/7a2/aff/2c57a2aff0542b2a02ad8ab34d097412.png"><br><br>  Perhatikan bahwa sementara Terkelola-pengecualian terbang antara Terkelola dan CLR, pengecualian SEH terbang antara CLR dan Windows. <br><br>  SEH - Penanganan Eksepsi Terstruktur <br><br><ul><li>  Mesin penanganan pengecualian Windows <br></li><li>  Seragam perangkat lunak dan penanganan pengecualian perangkat keras <br></li><li>  Pengecualian C # diterapkan di atas SEH <br></li></ul><br>  SEH adalah mekanisme penanganan pengecualian di Windows, ini memungkinkan Anda untuk secara merata menangani pengecualian apa pun yang datang, misalnya, dari tingkat prosesor, atau dikaitkan dengan logika aplikasi itu sendiri. <br><br>  Rantime .NET tahu tentang pengecualian SEH dan dapat mengubahnya menjadi pengecualian yang dikelola: <br><br><ul><li>  EXCEPTION_STACK_OVERFLOW -&gt; Kecelakaan <br></li><li>  EXCEPTION_ACCESS_VIOLATION -&gt; AccessViolationException <br></li><li>  EXCEPTION_ACCESS_VIOLATION -&gt; NullReferenceException <br></li><li>  EXCEPTION_INT_DIVIDE_BY_ZERO -&gt; DivideByZeroException <br></li><li>  Pengecualian SEH tidak dikenal -&gt; SEHException <br></li></ul><br>  Kita dapat berinteraksi dengan SEH melalui WinApi. <br><br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">DllImport(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"kernel32.dll"</span></span></span><span class="hljs-meta">)</span></span>] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">extern</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RaiseException</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint</span></span></span></span><span class="hljs-function"><span class="hljs-params"> dwExceptionCode, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint</span></span></span></span><span class="hljs-function"><span class="hljs-params"> dwExceptionFlags, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint</span></span></span></span><span class="hljs-function"><span class="hljs-params"> nNumberOfArguments,IntPtr lpArguments</span></span></span><span class="hljs-function">)</span></span>; <span class="hljs-comment"><span class="hljs-comment">// DivideByZeroException RaiseException(0xc0000094, 0, 0, IntPtr.Zero); // Stack overflow RaiseException(0xc00000fd, 0, 0, IntPtr.Zero);</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Bahkan, konstruksi lemparan juga bekerja melalui SEH. </font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> -&gt; RaiseException(<span class="hljs-number"><span class="hljs-number">0xe0434f4d</span></span>, ...)</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Perlu dicatat di sini bahwa kode pengecualian CLR selalu sama, jadi apa pun jenis pengecualian yang kita lemparkan, kode CLR akan selalu diproses. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">VEH adalah penanganan pengecualian vektor, perpanjangan dari SEH, tetapi bekerja pada level proses, dan bukan pada level utas tunggal. </font><font style="vertical-align: inherit;">Jika SEH secara semantik mirip dengan try-catch, maka VEH secara semantik mirip dengan interrupt handler. </font><font style="vertical-align: inherit;">Kami cukup mengatur penangan kami dan dapat menerima informasi tentang semua pengecualian yang terjadi dalam proses kami. </font><font style="vertical-align: inherit;">Fitur menarik dari VEH adalah memungkinkan Anda untuk mengubah pengecualian SEH sebelum sampai ke handler.</font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/7b8/79d/848/7b879d848390b9e3d1b9156b00b8e2bf.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kita dapat menempatkan vektor handler kita sendiri antara sistem operasi dan runtime, yang akan menangani pengecualian SEH dan, ketika bertemu EXCEPTION_STACK_OVERFLOW, ubahlah sehingga .NET runtime tidak merusak proses. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Anda dapat berinteraksi dengan VEH melalui WinApi:</font></font><br><br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">DllImport(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"kernel32.dll"</span></span></span><span class="hljs-meta">, SetLastError = true)</span></span>] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">extern</span></span></span><span class="hljs-function"> IntPtr </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddVectoredExceptionHandler</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IntPtr FirstHandler,  VECTORED_EXCEPTION_HANDLER VectoredHandler</span></span></span><span class="hljs-function">)</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">delegate</span></span></span><span class="hljs-function"> VEH </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PVECTORED_EXCEPTION_HANDLER</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">ref</span></span></span></span><span class="hljs-function"><span class="hljs-params"> EXCEPTION_POINTERS exceptionPointers</span></span></span><span class="hljs-function">)</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> VEH : <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> { EXCEPTION_CONTINUE_SEARCH = <span class="hljs-number"><span class="hljs-number">0</span></span>, EXCEPTION_EXECUTE_HANDLER = <span class="hljs-number"><span class="hljs-number">1</span></span>, EXCEPTION_CONTINUE_EXECUTION = <span class="hljs-number"><span class="hljs-number">-1</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">delegate</span></span></span><span class="hljs-function"> VEH </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PVECTORED_EXCEPTION_HANDLER</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">ref</span></span></span></span><span class="hljs-function"><span class="hljs-params"> EXCEPTION_POINTERS exceptionPointers</span></span></span><span class="hljs-function">)</span></span>; [StructLayout(LayoutKind.Sequential)] <span class="hljs-keyword"><span class="hljs-keyword">unsafe</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> EXCEPTION_POINTERS { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> EXCEPTION_RECORD* ExceptionRecord; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> IntPtr Context; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">delegate</span></span></span><span class="hljs-function"> VEH </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PVECTORED_EXCEPTION_HANDLER</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">ref</span></span></span></span><span class="hljs-function"><span class="hljs-params"> EXCEPTION_POINTERS exceptionPointers</span></span></span><span class="hljs-function">)</span></span>; [StructLayout(LayoutKind.Sequential)] <span class="hljs-keyword"><span class="hljs-keyword">unsafe</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> EXCEPTION_RECORD { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint</span></span> ExceptionCode; ... }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Konteks berisi informasi tentang status semua register prosesor pada saat pengecualian. </font><font style="vertical-align: inherit;">Kami akan tertarik pada EXCEPTION_RECORD dan bidang ExceptionCode di dalamnya. </font><font style="vertical-align: inherit;">Kita bisa menggantinya dengan kode pengecualian kita sendiri, yang CLR tidak tahu apa-apa tentangnya. </font><font style="vertical-align: inherit;">Handler vektor terlihat seperti ini:</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">unsafe</span></span></span><span class="hljs-function"> VEH </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Handler</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">ref</span></span></span></span><span class="hljs-function"><span class="hljs-params"> EXCEPTION_POINTERS e</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (e.ExceptionRecord == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> VEH. EXCEPTION_CONTINUE_SEARCH; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> record = e. ExceptionRecord; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (record-&gt;ExceptionCode != ExceptionStackOverflow) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> VEH. EXCEPTION_CONTINUE_SEARCH; record-&gt;ExceptionCode = <span class="hljs-number"><span class="hljs-number">0x01234567</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> VEH. EXCEPTION_EXECUTE_HANDLER; }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Sekarang kita akan membuat pembungkus yang menginstal handler vektor dalam bentuk metode HandleSO, yang mengambil delegasi yang berpotensi jatuh dari StackOverflowException (untuk kejelasan, kode tidak menangani kesalahan fungsi WinApi dan menghapus handler vektor). </font></font><br><br><pre> <code class="cs hljs">HandleSO(() =&gt; InfiniteRecursion()) ; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> T HandleSO&lt;T&gt;(Func&lt;T&gt; action) { Kernel32. AddVectoredExceptionHandler(IntPtr.Zero, Handler); Kernel32.SetThreadStackGuarantee(<span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> size); <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> action(); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (Exception e) when ((<span class="hljs-keyword"><span class="hljs-keyword">uint</span></span>) Marshal. GetExceptionCode() == <span class="hljs-number"><span class="hljs-number">0x01234567</span></span>) {} <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>(T); } HandleSO(() =&gt; InfiniteRecursion());</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Di dalamnya, metode SetThreadStackGuarantee juga digunakan. </font><font style="vertical-align: inherit;">Metode ini menyimpan ruang tumpukan untuk pemrosesan StackOverflow. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dengan cara ini, kita bisa selamat dari doa metode dengan rekursi tak terbatas. </font><font style="vertical-align: inherit;">Aliran kami akan terus berfungsi seolah-olah tidak ada yang terjadi, seolah-olah tidak terjadi luapan. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tetapi apa yang terjadi jika Anda memanggil HandleSO dua kali di utas yang sama?</font></font><br><br><pre> <code class="cs hljs">HandleSO(() =&gt; InfiniteRecursion()); HandleSO(() =&gt; InfiniteRecursion());</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dan akan ada AccessViolationException. Kembali ke perangkat tumpukan. </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/639/e93/c8d/639e93c8d187dc31fc37a2ac7247f193.png"><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sistem operasi dapat mendeteksi stack overflows. Di bagian paling atas tumpukan adalah halaman khusus yang ditandai dengan bendera halaman Penjaga. Pertama kali halaman ini diakses, pengecualian lain akan terjadi - STATUS_GUARD_PAGE_VIOLATION, dan bendera halaman Guard akan dihapus dari halaman. Jika Anda cukup mencegat overflow ini, maka halaman ini tidak lagi berada di stack - di overflow berikutnya, sistem operasi tidak akan dapat memahami hal ini dan stack-pointer akan melampaui memori yang dialokasikan untuk stack. Akibatnya, AccessViolationException akan terjadi. Jadi Anda perlu mengembalikan bendera halaman setelah memproses StackOverflow - cara termudah untuk melakukannya adalah dengan menggunakan metode _resetstkoflw dari pustaka runtime C (msvcrt.dll).</font></font><br><br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">DllImport(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"msvcrt.dll"</span></span></span><span class="hljs-meta">)</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> _resetstkoflw();</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dengan cara yang sama, Anda dapat menangkap AccessViolationException di .NET Core di bawah Windows, yang menyebabkan proses macet. </font><font style="vertical-align: inherit;">Dalam hal ini, Anda perlu mempertimbangkan urutan penangan vektor dipanggil dan mengatur penangan Anda ke awal rantai, karena .NET Core juga menggunakan VEH saat memproses AccessViolation. </font><font style="vertical-align: inherit;">Parameter pertama dari fungsi AddVectoredExceptionHandler bertanggung jawab atas urutan penangan yang disebut:</font></font><br><br><pre> <code class="cs hljs">Kernel32.AddVectoredExceptionHandler(FirstHandler: (IntPtr) <span class="hljs-number"><span class="hljs-number">1</span></span>, handler);</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Setelah mempelajari masalah praktis, kami merangkum hasil umum: </font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Pengecualian tidak sesederhana yang terlihat; </font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Tidak semua pengecualian ditangani dengan cara yang sama; </font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Penanganan pengecualian terjadi pada berbagai tingkat abstraksi; </font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Anda dapat melakukan intervensi dalam proses penanganan pengecualian dan membuat .NET runtime berfungsi berbeda dari yang dimaksudkan. </font></font><br></li></ul><br><h2>  Referensi </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">→ </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Repositori dengan contoh-contoh dari laporan</font></font></a> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> → </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dotnext 2016 Moscow - Adam Sitnik - Pengecualian Luar Biasa dalam .NET</font></font></a> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> → </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">DotNetBook: Pengecualian</font></font></a> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> → </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.NET Inside Out Bagian 8 - Menangani Stack Overflow Pengecualian di C # dengan VEH</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> adalah cara lain untuk mencegat StackOverflow.</font></font><br><br><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pada 22-23 November, Eugene akan berbicara di </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">DotNext 2018 Moskow</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dengan laporan </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"Metrik Sistem: </font></font></a><font style="vertical-align: inherit;"><b><font style="vertical-align: inherit;">Mengumpulkan </font></b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;">Kesalahan</font></a><font style="vertical-align: inherit;"> . </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;">" </font></a><font style="vertical-align: inherit;">Jeffrey Richter, Greg Young, Pavel Yosifovich dan pembicara lain yang sama menariknya akan datang ke Moskow. </font><font style="vertical-align: inherit;">Topik-topik laporan dapat dilihat di </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sini</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , dan beli tiket di </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sini</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Bergabunglah sekarang!</font></font></blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id426045/">https://habr.com/ru/post/id426045/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id426029/index.html">Apakah Anda menyerah dan ingin berhenti dari tugas itu? Seperti inilah pelatihan pengembang yang efektif</a></li>
<li><a href="../id426031/index.html">Khawatir tentang kecerdasan buatan yang mengambil alih dunia mungkin didasarkan pada asumsi yang tidak ilmiah</a></li>
<li><a href="../id426033/index.html">Titans matematika berbenturan dengan bukti epik hipotesis abc</a></li>
<li><a href="../id426039/index.html">Peluncuran darurat "Soyuz MS-10" (kru diselamatkan, disiarkan)</a></li>
<li><a href="../id426041/index.html">Solusi simbolik dari persamaan diferensial linear dan sistem dengan metode transformasi Laplace menggunakan SymPy</a></li>
<li><a href="../id426047/index.html">10 buku bagus untuk pemula dalam bahasa Inggris</a></li>
<li><a href="../id426051/index.html">Meningkatkan keterampilan debugging perangkat lunak - beberapa tips</a></li>
<li><a href="../id426053/index.html">Caching Handler Peristiwa dan Reaksi Peningkatan Kinerja Aplikasi</a></li>
<li><a href="../id426055/index.html">TensorFlow.js dan clmtrackr.js: melacak arah pandangan pengguna di browser</a></li>
<li><a href="../id426059/index.html">Tutu PHP Meetup # 2: Pidato Video</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>