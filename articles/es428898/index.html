<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🚎 👩🏾‍🔬 🦇 Aspectos problemáticos de la programación en C ++ ⏬ 🥇 👩🏿‍🚒</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="En C ++, hay bastantes características que pueden considerarse potencialmente peligrosas: con errores de cálculo en el diseño o codificación inexacta,...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Aspectos problemáticos de la programación en C ++</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/428898/"><hr><p>  <i>En C ++, hay bastantes características que pueden considerarse potencialmente peligrosas: con errores de cálculo en el diseño o codificación inexacta, pueden conducir fácilmente a errores.</i>  <i>El artículo proporciona una selección de tales características, da consejos sobre cómo reducir su impacto negativo.</i> <i><br></i> </p><hr><br><a name="habracut"></a><br><h1>  Tabla de contenidos </h1><br><div class="spoiler">  <b class="spoiler_title">Tabla de contenidos</b> <div class="spoiler_text"><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Introduccion</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">1. Tipos</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">1.1.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Instrucciones condicionales y operadores</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">1.2.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Conversiones implícitas</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">2. Resolución de nombre</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">2.1.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Ocultar variables en ámbitos anidados</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">2.2.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Sobrecarga de funciones</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">3. Constructores, destructores, inicialización, eliminación.</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">3.1.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Funciones de miembro de clase generadas por el compilador</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">3.2.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Variables no inicializadas</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">3.3.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Procedimiento de inicialización para clases base y miembros de clase no estáticos</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">3.4.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Procedimiento de inicialización para miembros de clase estáticos y variables globales</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">3.5.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Excepciones en destructores</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">3.6.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Eliminar objetos dinámicos y matrices</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">3.7.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Eliminar cuando la declaración de clase está incompleta</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">4. Operadores, expresiones</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">4.1.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Prioridad del operador</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">4.2.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Sobrecarga del operador</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">4.3.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">El procedimiento para calcular subexpresiones</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">5. Funciones virtuales</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">5.1 Anulación de funciones virtuales</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">5.2 Sobrecarga y uso de parámetros predeterminados</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">5.3 Llamar a funciones virtuales en el constructor y destructor</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">5.4 Destructor virtual</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">6. Trabajo directo con memoria.</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">6.1 Desbordamiento del búfer</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">6.2 Cuerdas terminadas en Z</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">6.3 Funciones con un número variable de parámetros</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">7. Sintaxis</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">7.1 Anuncios complicados</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">7.2 Ambigüedad de sintaxis</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">8. Varios</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">8.1 Palabra clave en línea y ODR</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">8.2 Archivos de encabezado</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">8.3 declaración de cambio</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">8.4 Pasando parámetros por valor</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">8.5 Gestión de recursos</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">8.6 Enlaces propios y no poseedores</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">8.7 Compatibilidad binaria</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">8.8 macros</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">9. Resumen</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Referencias</a> <br></p><br></div></div><br><p>  <i>Praemonitus, praemunitus.</i> <i><br></i>  <i>Prevenido significa armado.</i>  <i>(lat.)</i> <br></p><br><a name="id-introdaction"></a><br><h1>  Introduccion </h1><br><p>  En C ++, hay bastantes características que pueden considerarse potencialmente peligrosas: con errores de cálculo en el diseño o codificación inexacta, pueden conducir fácilmente a errores.  Algunos de ellos pueden atribuirse a la infancia difícil, algunos al estándar C ++ 98 obsoleto, pero otros ya están asociados con las características de C ++ moderno.  Considere los principales e intente dar consejos sobre cómo reducir su impacto negativo. </p><br><a name="id-1"></a><br><h1>  1. Tipos </h1><br><a name="id-1-1"></a><br><h2>  1.1.  Instrucciones condicionales y operadores </h2><br><p> La necesidad de compatibilidad con C lleva al hecho de que en la declaración <code>if(...)</code> y similares, puede sustituir cualquier expresión numérica o puntero, y no solo expresiones como <code>bool</code> .  El problema se agrava por la conversión implícita de <code>bool</code> a <code>int</code> en expresiones aritméticas y la prioridad de algunos operadores.  Esto lleva, por ejemplo, a los siguientes errores: </p><br><p>  <code>if(a=b)</code> cuando correctamente <code>if(a==b)</code> , <br>  <code>if(a&lt;x&lt;b)</code> , cuando correctamente <code>if(a&lt;x &amp;&amp; x&lt;b)</code> , <br>  <code>if(a&amp;x==0)</code> , cuando correctamente <code>if((a&amp;x)==0)</code> , <br>  <code>if(Foo)</code> cuando correctamente <code>if(Foo())</code> , <br>  <code>if(arr)</code> cuando correctamente <code>if(arr[0])</code> , <br>  <code>if(strcmp(s,r))</code> cuando es correcto <code>if(strcmp(s,r)==0)</code> . </p><br><p>  Algunos de estos errores provocan una advertencia del compilador, pero no un error.  Los analizadores de código también pueden ayudar a veces.  En C #, tales errores son casi imposibles, la <code>if(...)</code> y similares requieren un tipo <code>bool</code> , no puede mezclar tipos <code>bool</code> y numéricos en expresiones aritméticas. </p><br><p>  Cómo pelear </p><br><ul><li>  Programa sin advertencias.  Desafortunadamente, esto no siempre ayuda; algunos de los errores descritos anteriormente no dan advertencias. </li><li>  Use analizadores de código estático. </li><li>  Técnica de recepción anticuada: cuando se compara con una constante, <code>if(MAX_PATH==x)</code> a la izquierda, por ejemplo <code>if(MAX_PATH==x)</code> .  Se ve bastante condominio (e incluso tiene su propio nombre - "notación Yoda"), y ayuda en un pequeño número de casos considerados. </li><li>  Use el calificador <code>const</code> más ampliamente posible.  De nuevo, no siempre ayuda. </li><li>  Acostúmbrate a escribir las expresiones lógicas correctas: <code>if(x!=0)</code> lugar de <code>if(x)</code> .  (Aunque puede caer en la trampa de las prioridades del operador aquí, vea el tercer ejemplo). </li><li>  Se extremadamente atento. </li></ul><br><a name="id-1-2"></a><br><h2>  1.2.  Conversiones implícitas </h2><br><p>  C ++ se refiere a lenguajes fuertemente tipados, pero las conversiones de tipos implícitas se usan ampliamente para acortar el código.  Estas conversiones implícitas pueden en algunos casos conducir a errores. </p><br><p>  Las conversiones implícitas más molestas son las conversiones de un tipo numérico o puntero a <code>bool</code> y de <code>bool</code> a <code>int</code> .  Son estas transformaciones (necesarias para la compatibilidad con C) las que causan los problemas descritos en la sección 1.1.  Las conversiones implícitas que potencialmente causan una pérdida en la precisión de los datos numéricos (reduciendo las conversiones), por ejemplo, de <code>double</code> a <code>int</code> tampoco son siempre apropiadas.  En muchos casos, el compilador genera una advertencia (especialmente cuando puede haber una pérdida de precisión de los datos numéricos), pero una advertencia no es un error.  En C #, las conversiones entre tipos numéricos y <code>bool</code> prohibidas (incluso explícitas), y las conversiones que potencialmente causan pérdida de precisión en los datos numéricos son casi siempre un error. </p><br><p>  El programador puede agregar otras conversiones implícitas: (1) definir un constructor con un parámetro sin la palabra clave <code>explicit</code> ;  (2) la definición de un operador de conversión de tipo.  Estas transformaciones rompen brechas de seguridad adicionales basadas en sólidos principios de escritura. </p><br><p>  En C #, el número de conversiones implícitas incorporadas es mucho menor; las conversiones implícitas personalizadas deben declararse utilizando la palabra clave <code>implicit</code> . </p><br><p>  Cómo pelear </p><br><ul><li>  Programa sin advertencias. </li><li>  Tenga mucho cuidado con los diseños descritos anteriormente, no los use sin extrema necesidad. </li></ul><br><a name="id-2"></a><br><h1>  2. Resolución de nombre </h1><br><a name="id-2-1"></a><br><h2>  2.1.  Ocultar variables en ámbitos anidados </h2><br><p>  En C ++, se aplica la siguiente regla.  Dejar </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//   {    int x;    // ... //  ,       {        int x;        // ...    } }</span></span></code> </pre> <br><p>  De acuerdo con las reglas de C ++, la variable <code></code> declarada en <code></code> oculta la variable <code></code> declarada en <code></code>  La primera declaración <code>x</code> no tiene que estar en un bloque: puede ser miembro de una clase o una variable global, solo debe ser visible en el bloque <code></code> </p><br><p>  Imagine ahora la situación en la que necesita refactorizar el siguiente código </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//   {    int x;    // ... //  ,       {    // -         } }</span></span></code> </pre> <br><p>  Por error, se realizan cambios: </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//   {    //  , :    int x;    // -         // ...    //  :    // -      }</span></span></code> </pre> <br><p>  ¡Y ahora el código "se está haciendo algo con <code></code> de <code></code> " hará algo con <code></code> de <code></code> !  Está claro que todo no funciona como antes, y encontrar lo que a menudo es muy difícil.  No es en vano que en C # esté prohibido ocultar variables locales (aunque los miembros de la clase sí pueden).  Tenga en cuenta que el mecanismo de ocultar variables de una forma u otra se usa en casi todos los lenguajes de programación. </p><br><p>  Cómo pelear </p><br><ul><li>  Declarar variables en el alcance más estrecho posible. </li><li>  No escriba bloques largos y profundamente anidados. </li><li>  Use convenciones de codificación para distinguir visualmente identificadores de diferente alcance. </li><li>  Se extremadamente atento. </li></ul><br><a name="id-2-2"></a><br><h2>  2.2.  Sobrecarga de funciones </h2><br><p>  La sobrecarga de funciones es una característica integral de muchos lenguajes de programación y C ++ no es una excepción.  Pero esta oportunidad debe usarse con cuidado, de lo contrario puede tener problemas.  En algunos casos, por ejemplo, cuando el constructor está sobrecargado, el programador no tiene otra opción, pero en otros casos, la negativa a sobrecargarse puede justificarse.  Considere los problemas que surgen al usar funciones sobrecargadas. </p><br><p>  Si intenta considerar todas las opciones posibles que pueden surgir al resolver una sobrecarga, las reglas para resolver una sobrecarga resultan muy complicadas y, por lo tanto, difíciles de predecir.  La complejidad añadida se introduce por las funciones de la plantilla y la sobrecarga de los operadores integrados.  C ++ 11 agregó problemas con enlaces rvalue y listas de inicialización. </p><br><p>  El algoritmo de búsqueda puede crear problemas para que los candidatos resuelvan la sobrecarga en áreas de visibilidad anidadas.  Si el compilador encontró algún candidato en el alcance actual, entonces se termina la búsqueda adicional.  Si los candidatos encontrados no son adecuados, conflictivos, eliminados o inaccesibles, se genera un error, pero no se intenta buscar más.  Y solo si no hay candidatos en el alcance actual, la búsqueda se mueve al siguiente alcance, más amplio.  El mecanismo de ocultación de nombres funciona, que es casi el mismo que se discutió en la sección 2.1, ver [Desvanecimiento]. </p><br><p>  Las funciones de sobrecarga pueden reducir la legibilidad del código, lo que significa provocar errores. </p><br><p>  El uso de funciones con parámetros predeterminados se parece al uso de funciones sobrecargadas, aunque, por supuesto, hay menos problemas potenciales.  Pero el problema con mala legibilidad y posibles errores persiste. </p><br><p>  Con extrema precaución, se deben utilizar los parámetros predeterminados y de sobrecarga para las funciones virtuales, consulte la sección 5.2. </p><br><p>  C # también admite la sobrecarga de funciones, pero las reglas para resolver sobrecargas son ligeramente diferentes. </p><br><p>  Cómo pelear </p><br><ul><li>  No abuse de la sobrecarga de funciones, así como del diseño de funciones con parámetros predeterminados. </li><li>  Si las funciones están sobrecargadas, utilice firmas que no tengan dudas al resolver sobrecargas. </li><li>  No declare funciones del mismo nombre en ámbito anidado. </li><li>  No olvide que el mecanismo de funciones remotas ( <code>=delete</code> ) que apareció en C ++ 11 puede usarse para prohibir ciertas opciones de sobrecarga. </li></ul><br><a name="id-3"></a><br><h1>  3. Constructores, destructores, inicialización, eliminación. </h1><br><a name="id-3-1"></a><br><h2>  3.1.  Funciones de miembro de clase generadas por el compilador </h2><br><p>  Si el programador no ha definido las funciones miembro de la clase de la siguiente lista (el constructor predeterminado, el constructor de copia, el operador de asignación de copia, el destructor), entonces el compilador puede hacer esto por él.  C ++ 11 agregó un constructor de movimientos y un operador de asignación de movimientos a esta lista.  Estas funciones miembro se denominan funciones miembro especiales.  Se generan solo si se usan y se cumplen condiciones adicionales específicas para cada función.  Tenga en cuenta que este uso puede resultar bastante oculto (por ejemplo, al implementar la herencia).  Si no se puede generar la función requerida, se genera un error.  (Con la excepción de las operaciones de reubicación, se reemplazan por operaciones de copia). Las funciones miembro generadas por el compilador son públicas e integrables.  Los detalles sobre funciones especiales para miembros se pueden encontrar en [Meyers2]. </p><br><p>  En algunos casos, dicha ayuda del compilador puede ser un "servicio de soporte".  La ausencia de funciones miembro especiales personalizadas puede conducir a la creación de un tipo trivial, y esto, a su vez, causa el problema de las variables no inicializadas, consulte la sección 3.2.  Las funciones miembro generadas son públicas, y esto no siempre es coherente con el diseño de las clases.  En las clases base, el constructor debe estar protegido; a veces, para un control más fino sobre el ciclo de vida del objeto, se necesita un destructor protegido.  Si una clase tiene un descriptor de recursos sin procesar como miembro y posee este recurso, entonces el programador debe implementar un constructor de copia, un operador de asignación de copia y un destructor.  La llamada "regla de los Tres Grandes" es bien conocida, y establece que si un programador define al menos una de las tres operaciones: constructor de copia, operador de asignación de copia o destructor, debe definir las tres operaciones.  El constructor de movimientos y el operador de asignación de movimientos generado por el compilador también están lejos de ser siempre lo que necesita.  El destructor generado por el compilador en algunos casos conduce a problemas muy sutiles, cuyo resultado puede ser una pérdida de recursos, consulte la sección 3.7. </p><br><p>  El programador puede prohibir la generación de funciones miembro especiales, en C ++ 11 es necesario usar la construcción <code>"=delete"</code> al declarar, en C ++ 98 declara la función miembro correspondiente privada y no define. </p><br><p>  Si el programador se siente cómodo con las funciones miembro generadas por el compilador, entonces en C ++ 11 puede indicar esto explícitamente, y no simplemente descartar la declaración.  Para hacer esto, debe usar la construcción <code>"=default"</code> al declarar, mientras que el código se lee mejor y aparecen características adicionales relacionadas con la administración del nivel de acceso. </p><br><p>  En C #, el compilador puede generar un constructor predeterminado, generalmente esto no causa ningún problema. </p><br><p>  Cómo pelear </p><br><ul><li>  Controle el compilador que genera funciones especiales para miembros.  Si es necesario, impleméntelos usted mismo o prohíbalos. </li></ul><br><a name="id-3-2"></a><br><h2>  3.2.  Variables no inicializadas </h2><br><p>  Los constructores y destructores pueden llamarse elementos clave del modelo de objetos C ++.  Al crear un objeto, se debe llamar al constructor, y al eliminar, se llama al destructor.  Pero los problemas de compatibilidad con C han forzado algunas excepciones, y esta excepción se llama tipos triviales.  Se introducen para simular los tipos sichny y el ciclo de vida syshny de las variables, sin la llamada obligatoria del constructor y destructor.  El código C, si se compila y ejecuta en C ++, debería funcionar igual que en C. Los tipos triviales incluyen tipos numéricos, punteros, enumeraciones, así como clases, estructuras, uniones y matrices que consisten en tipos triviales.  Las clases y estructuras deben cumplir algunas condiciones adicionales: la ausencia de un constructor personalizado, destructor, copia, funciones virtuales.  Para una clase trivial, el compilador puede generar un constructor predeterminado y un destructor.  El constructor predeterminado pone a cero el objeto, el destructor no hace nada.  Pero este constructor se generará y usará solo si se llama explícitamente cuando se inicializa la variable.  Una variable de tipo trivial no se inicializará si no utiliza alguna variante de inicialización explícita.  La sintaxis de inicialización depende del tipo y el contexto de la declaración de variable.  Las variables estáticas y locales se inicializan cuando se declaran.  Para una clase, las clases base inmediatas y los miembros de clase no estáticos se inicializan en la lista de inicialización del constructor.  (C ++ 11 le permite inicializar miembros de clase no estáticos al declarar, ver más adelante). Para los objetos dinámicos, la expresión <code>new T()</code> crea un objeto inicializado por el constructor predeterminado, pero la <code>new T</code> para tipos triviales crea un objeto no inicializado.  Al crear una matriz dinámica de tipo trivial, <code>new T[N]</code> , sus elementos siempre estarán sin inicializar.  Si se crea o extiende una instancia de <code>std::vector&lt;T&gt;</code> y no se proporcionan parámetros para la inicialización explícita de los elementos, se garantiza que llamarán al constructor predeterminado.  C ++ 11 introduce una nueva sintaxis de inicialización, utilizando llaves.  Un par de paréntesis vacío significa inicialización utilizando el constructor predeterminado.  Dicha inicialización es posible en todas partes donde se usa la inicialización tradicional, además se hizo posible inicializar miembros no estáticos de la clase al declarar, lo que reemplaza la inicialización en la lista de inicialización del constructor. </p><br><p>  Una variable no inicializada se estructura de la siguiente manera: si se define en el ámbito del <code>namespace</code> (globalmente), tendrá todos los bits cero, si es local o se crea dinámicamente, recibirá un conjunto aleatorio de bits.  Está claro que el uso de dicha variable puede conducir a un comportamiento impredecible del programa. </p><br><p>  Es cierto que el progreso no se detiene, los compiladores modernos, en algunos casos, detectan variables no inicializadas y arrojan un error.  Los analizadores de código no inicializados detectan aún mejor. </p><br><p>  La biblioteca estándar de C ++ 11 tiene plantillas llamadas propiedades de tipo (archivo de encabezado <code>&lt;type_traits&gt;</code> ).  Uno de ellos le permite determinar si el tipo es trivial.  La expresión <code>std::is_trivial&lt;&gt;::value</code> es <code>true</code> si <code>T</code> tipo trivial y <code>false</code> caso contrario. </p><br><p>  Las estructuras síslicas a menudo también se denominan datos antiguos simples (POD).  Podemos suponer que POD y el "tipo trivial" son términos casi equivalentes. </p><br><p>  En C #, las variables no inicializadas causan un error; esto es controlado por el compilador.  Los campos de objetos de un tipo de referencia se inicializan de forma predeterminada si no se realiza una inicialización explícita.  Los campos de objetos de un tipo significativo se inicializan, ya sea de forma predeterminada, o todos deben inicializarse explícitamente. </p><br><p>  Cómo pelear </p><br><ul><li>  Tiene la costumbre de inicializar explícitamente una variable.  Una variable no inicializada debería "cortar el ojo". </li><li>  Declarar variables en el alcance más estrecho posible. </li><li>  Use analizadores de código estático. </li><li>  No diseñe tipos triviales.  Para garantizar que el tipo no sea trivial, es suficiente definir un constructor personalizado. </li></ul><br><a name="id-3-3"></a><br><h2>  3.3.  Procedimiento de inicialización para clases base y miembros de clase no estáticos </h2><br><p>  Al implementar el constructor de clases, se inicializan las clases base inmediatas y los miembros de clase no estáticos.  El orden de inicialización está determinado por el estándar: primero, las clases base en el orden en que se declaran en la lista de clases base, luego los miembros no estáticos de la clase en el orden de declaración.  Si es necesario, la inicialización explícita de las clases base y los miembros no estáticos usa la lista de inicialización del constructor.  Desafortunadamente, no es necesario que los elementos de esta lista estén en el orden en que se produce la inicialización.  Esto debe tenerse en cuenta si, durante la inicialización, los elementos de la lista usan referencias a otros elementos de la lista.  En caso de error, el enlace puede ser a un objeto que aún no se ha inicializado.  C ++ 11 le permite inicializar miembros de clase no estáticos al declarar (usando llaves).  En este caso, no necesitan inicializarse en la lista de inicialización del constructor y el problema se elimina parcialmente. </p><br><p>  En C #, un objeto se inicializa de la siguiente manera: primero se inicializan los campos, desde el subobjeto base hasta la última derivada, luego los constructores se llaman en el mismo orden.  El problema descrito no ocurre. </p><br><p>  Cómo pelear </p><br><ul><li>  Mantener la lista de inicialización del constructor en orden de declaración. </li><li>  Intente hacer que la inicialización de las clases base y los miembros de la clase sean independientes. </li><li>  Utilice la inicialización de miembros no estáticos al declarar. </li></ul><br><a name="id-3-4"></a><br><h2>  3.4.  Procedimiento de inicialización para miembros de clase estáticos y variables globales </h2><br><p>  Los miembros de clase estática, así como las variables definidas en el espacio de <code>namespace</code> ámbito (globalmente) en diferentes unidades de compilación (archivos), se inicializan en el orden determinado por la implementación.  Esto debe tenerse en cuenta si durante la inicialización dichas variables usan referencias entre sí.  El enlace puede ser a una variable no inicializada. </p><br><p>  Cómo pelear </p><br><ul><li>  Tome medidas especiales para prevenir esta situación.  Por ejemplo, use variables estáticas locales (singleton), se inicializan en el primer uso. </li></ul><br><a name="id-3-5"></a><br><h2>  3.5.  Excepciones en destructores </h2><br><p>  El destructor no debe lanzar excepciones.  Si viola esta regla, puede obtener un comportamiento indefinido, a menudo una terminación anormal. </p><br><p>  Cómo pelear </p><br><ul><li>  Evite lanzar excepciones en el destructor. </li></ul><br><a name="id-3-6"></a><br><h2>  3.6.  Eliminar objetos dinámicos y matrices </h2><br><p>  Si <code>T</code> un objeto dinámico de algún tipo <code>T</code> </p><br><pre> <code class="cpp hljs">T* pt = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> T(<span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span>);</code> </pre> <br><p>  luego se elimina con el operador de <code>delete</code> </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> pt;</code> </pre> <br><p>  Si se crea una matriz dinámica </p><br><pre> <code class="cpp hljs">T* pt = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> T[N];</code> </pre> <br><p>  luego se elimina con el operador <code>delete[]</code> </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">delete</span></span>[] pt;</code> </pre> <br><p>  Si no sigue esta regla, puede obtener un comportamiento indefinido, es decir, puede suceder cualquier cosa: una pérdida de memoria, un bloqueo, etc.  Ver [Meyers1] para más detalles. </p><br><p>  Cómo pelear </p><br><ul><li>  Use el formulario de <code>delete</code> correcto. </li></ul><br><a name="id-3-7"></a><br><h2>  3.7.  Eliminación con declaración de clase incompleta </h2><br><p>  La omnivorosidad del operador de <code>delete</code> puede crear ciertos problemas; se puede aplicar a un puntero de tipo <code>void*</code> o a un puntero a una clase que tiene una declaración incompleta (preventiva).  El operador de <code>delete</code> aplicado a un puntero a una clase es una operación de dos fases; primero, se llama al destructor, luego se libera la memoria.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si el operador se aplica </font></font><code>delete</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">a un puntero a una clase con una declaración incompleta, no se produce ningún error, el compilador simplemente omite la llamada al destructor (aunque se emite una advertencia).</font></font> Considere un ejemplo: </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">X</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-comment"><span class="hljs-comment">//   X* CreateX(); void Foo() {    X* p = CreateX();    delete p; }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Este código se compila incluso si la </font></font><code>delete</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">declaración de clase completa no está disponible </font><font style="vertical-align: inherit;">en el dial-peer </font></font><code>X</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Visual Studio muestra la siguiente advertencia:</font></font><br><p> <code>warning C4150: deletion of pointer to incomplete type 'X'; no destructor called</code> <br> </p><br><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si hay una implementación </font></font><code>X</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y </font></font><code>CreateX()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">luego se compila el código, si </font></font><code>CreateX()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">devuelve un puntero a un objeto creado por el operador </font></font><code>new</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, la llamada se </font></font><code>Foo()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ejecuta con éxito, no se llama al destructor. </font><font style="vertical-align: inherit;">Está claro que esto puede conducir a una fuga de recursos, por lo que una vez más sobre la necesidad de tener cuidado con las advertencias.</font></font></p><br><p>    ,           -.      ,  .       ,      ,   ,   ,   .        [Meyers2]. </p><br><p>  : </p><br><ul><li>   . </li><li>            . </li><li>     . </li></ul><br><a name="id-4"></a><br><h1> 4. ,  </h1><br><a name="id-4-1"></a><br><h2>  4.1.   </h2><br><p>   ++ ,     .      .       .   ,    1.1. </p><br><p>  Aquí hay un ejemplo: </p><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::out&lt;&lt;c?x:y;</code> </pre> <br><p>        </p><br><pre> <code class="cpp hljs">(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::out&lt;&lt;c)?x:y;</code> </pre> <br><p>   </p><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::out&lt;&lt;(c?x:y);</code> </pre> <br><p> ,  ,  . </p><br><p>         .            <code>&lt;&lt;</code>      <code>?:</code>      <code>std::out</code>  <code>void*</code> .  ++            ,     . -,          ,    .    <code>?:</code>      .       ,     (  ). </p><br><p>   :  <code>x&amp;f==0</code>    <code>x&amp;(f==0)</code> ,   <code>(x&amp;f)==0</code> , ,  ,  .     -  , ,     ,         ,   . </p><br><p>  . /          .  /    ,  /,    . ,     <code>x/4+1</code>  <code>x&gt;&gt;2+1</code> ,   <code>x&gt;&gt;(2+1)</code> ,   <code>(x&gt;&gt;2)+1</code> ,  . </p><br><p> C#      ,   C++,      ,    -      . </p><br><p>  : </p><br><ul><li>   ,     . , ,    . </li></ul><br><a name="id-4-2"></a><br><h2>  4.2.   </h2><br><p> ++     ,      .        .        ,          , .  4.1.    —    <code>+</code>  <code>+=</code>   .     . ,   : <code>,</code> (), <code>&amp;&amp;</code> , <code>||</code>  .   ,         (-),            (short-circuit evaluation semantics),        ,        .      &amp; ( ).     &amp;    , ..       . </p><br><p>        ,  -    (-) ,  .      . </p><br><p>  -  ,    ,    .  . [Dewhurst]. </p><br><p> C#    ,     , ,   . </p><br><p>  : </p><br><ul><li>    . </li><li>       . </li></ul><br><a name="id-4-3"></a><br><h2>  4.3.    </h2><br><p>   ++           ,         . (   : <code>,</code> (), <code>&amp;&amp;</code> , <code>||</code> , <code>?:</code> .)     ,  ,   ,    .    : </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x=<span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> y=(++x*<span class="hljs-number"><span class="hljs-number">2</span></span>)+(++x*<span class="hljs-number"><span class="hljs-number">3</span></span>);</code> </pre> <br><p>  <code>y</code>     . </p><br><p>      ,        .  . </p><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">X</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Y</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">shared_ptr</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;X&gt;, </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">shared_ptr</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;Y&gt;)</span></span></span></span>;</code> </pre> <br><p>  <code>Foo()</code>   : </p><br><pre> <code class="cpp hljs">Foo(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt;X&gt;(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> X()), <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt;Y&gt;(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Y()));</code> </pre> <br><p>     :  <code>X</code> ,  <code>Y</code> ,  <code>std::shared_ptr&lt;X&gt;</code> ,  <code>std::shared_ptr&lt;Y&gt;</code> .   <code>Y</code>  ,   <code>X</code>   . </p><br><p>     : </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> p1 = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt;X&gt;(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> X()); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> p2 = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt;Y&gt;(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Y()); Foo(p1, p2);</code> </pre> <br><p>     <code>std::make_shared&lt;Y&gt;</code> (    ,     ): </p><br><pre> <code class="cpp hljs">Foo(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::make_shared&lt;X&gt;(), <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::make_shared&lt;Y&gt;());</code> </pre> <br><p>  . [Meyers2]. </p><br><p>  : </p><br><ul><li>    . </li></ul><br><a name="id-5"></a><br><h1> 5.   </h1><br><a name="id-5-1"></a><br><h2>  5.1.    </h2><br><p>  ++98  ,           ( ), ,     (     ,    ).      <code>virtual</code> ,   ,    .   ( ),   ,   ,     . ,     ,  .  ,  ++11    <code>override</code> ,    ,    ,       .          . </p><br><p>  : </p><br><ul><li>    <code>override</code> . </li><li>    .    ,         . </li></ul><br><a name="id-5-2"></a><br><h2>  5.2.       </h2><br><p>            .   ,              ,     .               .    . [Dewhurst]. </p><br><p>  : </p><br><ul><li>           . </li></ul><br><a name="id-5-3"></a><br><h2>  5.3.        </h2><br><p> ,     ,          . , ,     post_construct  pre_destroy. ,      —         .    .   ,        :     ( )   . (, ,      .)     ,           ( ),    ( ).  . [Dewhurst]. ,         ,  . </p><br><p>       —  -         . </p><br><p> ,   C#  ,     ,   ,     .  C#    :   ,      ,       .  ,           ( ,    ). </p><br><p>  : </p><br><ul><li>        ,     ,   . </li></ul><br><a name="id-5-4"></a><br><h2>  5.4.   </h2><br><p>     ,        ,           <code>delete</code>     .          , -    . </p><br><p>  : </p><br><ul><li>     . </li></ul><br><a name="id-6"></a><br><h1> 6.     </h1><br><p>        —      C/C++,        .           .        .     «  ». </p><br><p>  C#        unsafe mode,    . </p><br><a name="id-6-1"></a><br><h2> 6.1.     </h2><br><p>    /++  ,        : <code>strcpy()</code> , <code>strcat()</code> , <code>sprinf()</code> , etc.    ( <code>std::vector&lt;&gt;</code> , etc.)         ,    . (,         ,         ,     . . <strong>Checked Iterators</strong>  MSDN.)      ,      :   ,      ,     ;     ,      . </p><br><p>  C#,   unsafe mode,      . </p><br><p>  : </p><br><ul><li>    , . </li><li>     . </li><li>   z-terminated   ,    <code>_s</code> (.   ). </li></ul><br><a name="id-6-2"></a><br><h2> 6.2. Z-terminated  </h2><br><p>       ,  .    ,  : </p><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">strncpy</span></span>(dst,src,n);</code> </pre> <br><p>  <code>strlen(src)&gt;=n</code> ,  <code>dst</code>     (,      ).      ,       , .  .       —       .   <code>if(*str)</code> ,  <code>if(strlen(str)&gt;0)</code> ,           .         [Spolsky]. </p><br><p>  C#  <code>string</code>      . </p><br><p>  : </p><br><ul><li>    . </li><li>     z-terminated   ,    <code>_s</code> (.   ). </li></ul><br><a name="id-6-3"></a><br><h2> 6.3.      </h2><br><p>    <code>...</code>    .      <code>printf</code> - ,     C.          , ,  ,     ,      .         ,       . </p><br><p>  C#    <code>printf</code> ,     . </p><br><p>  : </p><br><ul><li>     . ,  <code>printf</code> -    /. </li><li>   . </li></ul><br><a name="id-7"></a><br><h1> 7.  </h1><br><a name="id-7-1"></a><br><h2> 7.1.   </h2><br><p>  ++     , ,   ,        .  Aquí hay un ejemplo: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> N = <span class="hljs-number"><span class="hljs-number">4</span></span>, M = <span class="hljs-number"><span class="hljs-number">6</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x,                <span class="hljs-comment"><span class="hljs-comment">// 1    *px,              // 2    ax[N],            // 3    *apx[N],          // 4    F(char),          // 5    *G(char),          // 6    (*pF)(char),      // 7    (*apF[N])(char),  // 8    (*pax)[N],        // 9    (*apax[M])[N],    // 10    (*H(char))(long);  // 11</span></span></code> </pre> <br><p>        : </p><br><ol><li>   <code>int</code> ; </li><li>   <code>int</code> ; </li><li>   <code>N</code>   <code>int</code> ; </li><li>   <code>N</code>     <code>int</code> ; </li><li> ,  <code>char</code>   <code>int</code> ; </li><li> ,  <code>char</code>     <code>int</code> ; </li><li>   ,  <code>char</code>   <code>int</code> ; </li><li>   <code>N</code>     ,  <code>char</code>   <code>int</code> ; </li><li>     <code>N</code>   <code>int</code> ; </li><li>   <code>M</code>       <code>N</code>   <code>int</code> ; </li><li> ,  <code>char</code>     ,  <code>long</code>   <code>int</code> . </li></ol><br><p> ,             . (     .) </p><br><p>     <code>*</code>    <code>&amp;</code>     . (    .) </p><br><p>        <code>typedef</code> ( <code>using</code> -). ,       : </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">typedef</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">int</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(*P)</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; PH(<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>);</code> </pre> <br><p>      ,     . </p><br><p>  C#    ,    . </p><br><p>  : </p><br><ul><li>   . </li></ul><br><a name="id-7-2"></a><br><h2> 7.2.   </h2><br><p>           .     </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">X</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>:    X(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> val = <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-comment"><span class="hljs-comment">// ... };</span></span></code> </pre> <br><p>     </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">X </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">x</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">5</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>;</code> </pre> <br><p>    <code>x</code>  <code>X</code> ,   5.    </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">X </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">x</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>;</code> </pre> <br><p>    <code>x</code> ,    <code>X</code>    ,     <code>x</code>  <code>X</code> ,    .     <code>X</code> ,    ,     : </p><br><pre> <code class="cpp hljs">X x; X x = X(); X x{};    <span class="hljs-comment"><span class="hljs-comment">//   C++11</span></span></code> </pre> <br><p>   ,    ,          ,   .         [Sutter]. </p><br><p>  ,  ,   C++     (      ).         . (    C++  .) </p><br><p>  , ,      ,       ,         . </p><br><p>  C#   ,         ,      . </p><br><p>  : </p><br><ul><li>    . </li></ul><br><a name="id-8"></a><br><h1> 8.  </h1><br><a name="id-8-1"></a><br><h2> 8.1.   <code>inline</code>  ODR </h2><br><p>   ,    <code>inline</code> —             .  ,     .   <code>inline</code>          (One Defenition Rule, ODR).  .            ,   .          ,  ODR.       <code>static</code> :    ,       ,   .   <code>static</code>  <code>inline</code> .      ,        ,  ODR,     . ,       .   - ,          -.         . </p><br><p>  : </p><br><ul><li>  «» <code>inline</code> .          <code>namespace</code> .      ,     . </li><li>        —  <code>namespace</code> . </li></ul><br><a name="id-8-2"></a><br><h2> 8.2.   </h2><br><p>        .        .    ,    ,     ,   ,      . </p><br><p>  : </p><br><ul><li>     ,     . </li><li>  ,     :  () ,    -. </li><li>            <code>using</code> -: <code>using namespace <i></i></code> ,   <code>using</code> -. </li><li>           . </li></ul><br><a name="id-8-3"></a><br><h2> 8.3.  <code>switch</code> <br></h2><br><p>   —  <code>break</code>    <code>case</code> . (  .)  C#     . </p><br><p>  : </p><br><ul><li>   . </li></ul><br><a name="id-8-4"></a><br><h2> 8.4.     </h2><br><p>  ++    ,      —     , —       .    (  <code>class</code>  <code>struct</code> )    ,         . (      ,      #  Java.)    —   ,     . </p><br><ol><li>      ,   .           (  <code>std::string</code> , <code>std::vector</code> , etc.),    ,           . </li><li>    ,        ,     . </li><li>          ,      (slicing),      ,       . </li></ol><br><p>     ,      ,  ,     .      . ,       ,         . ,          .           .    —     ( <code>=delete</code> ),   —     <code>explicit</code> . </p><br><p>  C#      ,           . </p><br><p>  : </p><br><ul><li>   ,     . </li><li>       . </li></ul><br><a name="id-8-5"></a><br><h2> 8.5.  Gestión de recursos </h2><br><p>  ++         .     ,     . -       (    ),   ++11   ,        ,   ,           . </p><br><p>      C++   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="></a> . </p><br><p>  C#   ,       .        ,     .        (using-)      Basic Dispose. </p><br><p>  : </p><br><ul><li>  -       . </li></ul><br><a name="id-8-6"></a><br><h2> 8.6.     </h2><br><p>     «»     .     ,  , C++ , STL-   - . </p><br><p>       .         .     ,        .      .        «»,      .          COM-      . (,    .)      ,    C++   .      —      .        .            .  ,      («»     )    ,      .        . </p><br><p>  #    ,     .     —    . </p><br><p>  : </p><br><ul><li>   . </li><li>        . </li></ul><br><a name="id-8-7"></a><br><h2> 8.7.   </h2><br><p>  C++      ,     :   ,    ,   . (     !)      .        ,      .     ,   .     ,   ,     . (,           .) </p><br><p>      C (    ),   C++       C  (   <code>extern "C"</code> ).      C/C++ . </p><br><p>          -.   <code>#pragma</code> -    ,    ,   . </p><br><p>        , ,    ,    . </p><br><p>     , ,    COM. COM-,    ,   (     ,      ).  COM     ,   ,     . </p><br><p>  C#     . ,   —    ,      C#,    C#  C/C++. </p><br><p>  : </p><br><ul><li>        . </li></ul><br><a name="id-8-8"></a><br><h2> 8.8.  </h2><br><p>        ,         .    ,       .  C++    .  En cambio </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> XXL 32</span></span></code> </pre> <br><p>   </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> XXL=<span class="hljs-number"><span class="hljs-number">32</span></span>;</code> </pre> <br><p>   .       <code>inline</code>   . </p><br><p>  #   (   ). </p><br><p>  : </p><br><ul><li>       . </li></ul><br><a name="id-conclusion"></a><br><h1> 9.  </h1><br><ol><li>      .       .   .      ,       . </li><li>    . </li><li>    .   ++      — ++11/14/17. </li><li>   - ,  -   . </li><li>        . </li></ol><br><a name="id-refs"></a><br><h1>  Referencias </h1><br><div class="spoiler"> <b class="spoiler_title"></b> <div class="spoiler_text"><p> [Dewhurst] <br> ,  .   C++.         .: .  del ingles — .:  , 2012. </p><br><p> [Meyers1] <br> , .   C++. 55        .: .  del ingles — .:  , 2014. </p><br><p> [Meyers2] <br> , .    C++: 42    C++11  C++14.: .  del ingles — .:  «.. », 2016. </p><br><p> [Sutter] <br> , .     C++.: .  del ingles — :  «.. », 2015. </p><br><p> [Spolsky] <br> , .   .: .  del ingles — .: -, 2008. </p><br></div></div><br><br></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es428898/">https://habr.com/ru/post/es428898/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es428888/index.html">qml: poder y simplicidad</a></li>
<li><a href="../es428890/index.html">Toda la verdad sobre RTOS. Artículo # 18. Grupos de banderas de eventos: servicios auxiliares y estructuras de datos</a></li>
<li><a href="../es428892/index.html">Cómo crear un juego AI: una guía para principiantes</a></li>
<li><a href="../es428894/index.html">IVA en compras nacionales</a></li>
<li><a href="../es428896/index.html">Censura hentai redes neuronales</a></li>
<li><a href="../es428900/index.html">Los robots con ruedas comienzan a entregar productos a los residentes de los Estados Unidos y Gran Bretaña</a></li>
<li><a href="../es428902/index.html">Etiquetas inalámbricas NFC</a></li>
<li><a href="../es428904/index.html">Fintech Digest: Robótica del Banco Central, Ethereum 2.0, Control de Criptomonedas por Monitoreo Rosfin y Tendencias en Fintech</a></li>
<li><a href="../es428906/index.html">Crear juegos de rompecabezas en Puzzle Script</a></li>
<li><a href="../es428908/index.html">Frostpunk: mecánica de desmontaje</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>