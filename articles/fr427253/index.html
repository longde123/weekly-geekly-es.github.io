<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚ûø üíì üíáüèæ typeof Tout et les malentendus de canard üë®üèø‚Äçüéì üëçüèº ‚Ñ¢Ô∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Tout le monde utilise un merveilleux JavaScript pour n'importe quel but se demande: pourquoi est-ce que typeof est un "objet" nul ? typeof d'une fonct...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>typeof Tout et les malentendus de canard</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/427253/"><p><img src="https://habrastorage.org/webt/w2/mj/_p/w2mj_pc_kr_unyrw31d2f27xdra.jpeg" alt="image"></p><br><p>  Tout le monde utilise un merveilleux <strong>JavaScript</strong> pour n'importe quel but se demande: pourquoi est-ce que <em>typeof</em> est <em>un</em> <em>"objet"</em> <em>nul</em> ?  <em>typeof</em> d'une fonction renvoie <em>"fonction"</em> , mais de <em>Array</em> - <em>"objet"</em> ?  et o√π <em>getClass</em> dans vos cours tant vant√©s?  Et bien que pour l'essentiel les <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">sp√©cifications</a> et <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">les faits historiques</a> r√©pondent facilement et naturellement, je voudrais tracer un peu un trait ... plus pour moi. </p><br><p>  Si, lecteur, votre <em>typeof</em> et <em>instanceof</em> ne vous suffisent pas dans vos t√¢ches, et que vous voulez des d√©tails, plut√¥t que des <em>"objets"</em> , alors cela peut √™tre utile plus tard.  Oh oui, √† propos des canards: ils le seront aussi, juste un peu mal. </p><a name="habracut"></a><br><h2 id="kratkaya-istoriya-voprosa">  Bref historique </h2><br><p>  Obtenir de mani√®re fiable le type d'une variable en JavaScript a toujours √©t√© une t√¢che non triviale, certainement pas pour un d√©butant.  Dans la plupart des cas, ce n'est bien s√ªr pas obligatoire, juste: </p><br><pre><code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span> value === <span class="hljs-string"><span class="hljs-string">'object'</span></span> &amp;&amp; value !== <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-comment"><span class="hljs-comment">// awesome code around the object }</span></span></code> </pre> <br><p>  et maintenant vous n'attrapez pas <code>Cannot read property of null</code> - un analogue local de NPE.  Est-ce familier? </p><br><p>  Et puis nous avons commenc√© √† utiliser les fonctions plus souvent en tant que constructeurs, et il est parfois utile d'inspecter le type de l'objet cr√©√© de cette fa√ßon.  Mais l'utilisation de <em>typeof √†</em> partir de l'instance ne fonctionnera pas, car nous obtenons correctement <em>"l'objet"</em> . </p><br><p>  Ensuite, il √©tait toujours normal d'utiliser un prototype de mod√®le OOP en JavaScript, vous vous en souvenez?  Nous avons un objet, et gr√¢ce au lien vers son prototype, nous pouvons trouver la propri√©t√© <em>constructeur</em> qui pointe vers la fonction avec laquelle l'objet a √©t√© cr√©√©.  Et puis un peu de magie avec <em>toString</em> de la fonction et des expressions r√©guli√®res, et voici le r√©sultat: </p><br><pre> <code class="javascript hljs">f.toString().match(<span class="hljs-regexp"><span class="hljs-regexp">/function\s+(\w+)(?=\s*\()/m</span></span>)[<span class="hljs-number"><span class="hljs-number">1</span></span>]</code> </pre> <br><p>  Parfois, ils ont pos√© de telles questions lors des entretiens, mais pourquoi? </p><br><p>  Oui, nous pourrions simplement enregistrer une repr√©sentation sous forme de cha√Æne du type en tant que propri√©t√© sp√©ciale et l'obtenir √† partir de l'objet via la cha√Æne de prototype: </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Type</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{}; Type.prototype.typeName = <span class="hljs-string"><span class="hljs-string">'Type'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> o = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Type; o.typeName; <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt; "</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">Type</span></span></span></span><span class="xml"><span class="hljs-tag">"</span></span></span></span></code> </pre> <br><p>  Vous n'avez qu'√† √©crire deux fois <em>"Type"</em> : dans la d√©claration de fonction et dans la propri√©t√©. </p><br><p>  Pour les objets int√©gr√©s (comme <em>Array</em> ou <em>Date</em> ), nous avions une <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">propri√©t√© secr√®te</a> <em>[[Class]]</em> , qui pouvait √™tre accroch√©e via <em>toString √†</em> partir de l' <em>objet</em> standard: </p><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.prototype.toString.call(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>); <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt; "[</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">object</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">Array</span></span></span></span><span class="xml"><span class="hljs-tag">]"</span></span></span></span></code> </pre> <br><p>  Nous avons maintenant des classes, et les types personnalis√©s sont finalement corrig√©s dans le langage: ce n'est pas un LiveScript pour vous;  nous √©crivons du code pris en charge en grande quantit√©! </p><br><p>  Vers la m√™me √©poque, <em>Symbol.toStringTag</em> et <em>Function.name sont apparus</em> , avec lesquels nous pouvons prendre notre <em>typeof</em> d'une nouvelle mani√®re. </p><br><p>  En g√©n√©ral, avant de poursuivre, je tiens √† noter que la question √† l'examen √©volue avec StackOverflow avec le langage et remonte du comit√© de r√©daction au comit√© de r√©daction: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">il y a 9 ans</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">7 ans, il</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">n'y a pas si longtemps,</a> ou <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ceci</a> et <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">cela</a> . </p><br><h2 id="tekuschee-polozhenie-del">  Situation actuelle </h2><br><p>  Plus t√¥t, nous avons <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">d√©j√† examin√©</a> suffisamment en d√©tail <em>Symbol.toStringTag</em> et <em>Function.name</em> .  En bref, le caract√®re interne <em>toStringTag</em> est moderne <em>[[Class]]</em> , nous seuls pouvons le red√©finir pour nos objets.  Et la propri√©t√© <em>Function.name</em> est l√©galis√©e dans presque tous les navigateurs du m√™me <em>typeName</em> de l'exemple: renvoie le nom de la fonction. </p><br><p>  Sans h√©sitation, vous pouvez d√©finir une telle fonction: </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getTag</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">any</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span> any === <span class="hljs-string"><span class="hljs-string">'object'</span></span> &amp;&amp; any !== <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span> any[<span class="hljs-built_in"><span class="hljs-built_in">Symbol</span></span>.toStringTag] === <span class="hljs-string"><span class="hljs-string">'string'</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> any[<span class="hljs-built_in"><span class="hljs-built_in">Symbol</span></span>.toStringTag]; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span> any.constructor === <span class="hljs-string"><span class="hljs-string">'function'</span></span> &amp;&amp; <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span> any.constructor.name === <span class="hljs-string"><span class="hljs-string">'string'</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> any.constructor.name; } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.prototype.toString.call(any).match(<span class="hljs-regexp"><span class="hljs-regexp">/\[object\s(\w+)]/</span></span>)[<span class="hljs-number"><span class="hljs-number">1</span></span>]; }</code> </pre> <br><ol><li>  SI la variable est un objet, alors: <br>  1.1.  SI l'objet est substitu√© <em>√†StringTag</em> , puis retournez-le; <br>  1.2.  SI la fonction <em>constructeur</em> est connue pour l'objet et que la fonction a une propri√©t√© de <em>nom</em> , renvoyez-la; </li><li>  ENFIN AUTREMENT, utilisez la m√©thode <em>toString</em> de l' <em>objet Object</em> , qui fera <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">tout le travail polymorphe</a> pour nous pour absolument toute autre variable. </li></ol><br><p>  Objet avec <em>toStringTag</em> : </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> kitten = { [<span class="hljs-built_in"><span class="hljs-built_in">Symbol</span></span>.toStringTag]: <span class="hljs-string"><span class="hljs-string">'Kitten'</span></span> }; getTag(kitten); <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt; "</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">Kitten</span></span></span></span><span class="xml"><span class="hljs-tag">"</span></span></span></span></code> </pre> <br><p>  Classe avec <em>toStringTag</em> : </p><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Cat</span></span></span><span class="hljs-class"> </span></span>{ get [<span class="hljs-built_in"><span class="hljs-built_in">Symbol</span></span>.toStringTag]() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">'Kitten'</span></span>; } } getTag(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Cat); <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt; "</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">Kitten</span></span></span></span><span class="xml"><span class="hljs-tag">"</span></span></span></span></code> </pre> <br><p>  Utilisation de <em>constructor.name</em> : </p><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Dog</span></span></span><span class="hljs-class"> </span></span>{} getTag(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Dog); <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt; "</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">Dog</span></span></span></span><span class="xml"><span class="hljs-tag">"</span></span></span></span></code> </pre> <br><p>  ‚Üí Plus d'exemples peuvent √™tre trouv√©s dans <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ce r√©f√©rentiel.</a> </p><br><p>  Ainsi, il est assez facile maintenant de d√©terminer le type de n'importe quelle variable en JavaScript.  Cette fonction vous permet de v√©rifier uniform√©ment le type des variables et d'utiliser une <em>expression de commutateur</em> simple au lieu des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">v√©rifications</a> de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">canard</a> dans les fonctions polymorphes.  En g√©n√©ral, je n'ai jamais aim√© l'approche bas√©e sur le typage du canard, ils disent que si quelque chose a la propri√©t√© <em>splice</em> , est-ce un tableau ou quelque chose? </p><br><h2 id="kakie-to-nepravilnye-utki">  Quelques mauvais canards </h2><br><p>  La compr√©hension du type d'une variable par la pr√©sence de certaines m√©thodes ou propri√©t√©s est bien s√ªr l'affaire de tous et d√©pend de la situation.  Mais je vais prendre ce <em>getTag</em> et inspecter quelques trucs de langue. </p><br><h3 id="klassy">  Des cours? </h3><br><p>  Mon ¬´canard¬ª pr√©f√©r√© en JavaScript est les cours.  Les gars qui ont commenc√© √† √©crire JavaScript avec ES-2015, ne soup√ßonnent parfois pas ce que sont ces classes.  Et la v√©rit√© est: </p><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Person</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(name) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.name = name; } hello() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.name; } } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> user = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Person(<span class="hljs-string"><span class="hljs-string">'John'</span></span>); user.hello(); <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt; "</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">John</span></span></span></span><span class="xml"><span class="hljs-tag">"</span></span></span></span></code> </pre> <br><p>  Nous avons un mot <em>-</em> cl√© de <em>classe</em> , un constructeur, certaines m√©thodes, voire des <em>extensions</em> .  Nous cr√©ons √©galement une instance de cette classe via <em>new</em> .  Cela ressemble √† une classe dans son sens habituel - cela signifie une classe! </p><br><p>  Cependant, lorsque vous commencez √† ajouter de nouvelles m√©thodes en temps <em>r√©el</em> √† la "classe" et qu'elles deviennent en m√™me temps imm√©diatement disponibles pour les instances d√©j√† cr√©√©es, certaines sont perdues: </p><br><pre> <code class="javascript hljs">Person.prototype.hello = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">`Is not </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${</span></span><span class="hljs-keyword"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-string"><span class="hljs-subst">.name}</span></span></span><span class="hljs-string">`</span></span>; } user.hello(); <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt; "</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">Is</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">not</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">John</span></span></span></span><span class="xml"><span class="hljs-tag">"</span></span></span></span></code> </pre> <br><p>  <strong>Ne fais pas √ßa!</strong> </p><br><p>  Et certains ne savent pas de mani√®re fiable qu'il ne s'agit que de sucre syntaxique par rapport au mod√®le prototype, car conceptuellement rien n'a chang√© dans le langage.  Si nous appelons <em>getTag</em> de <em>Person</em> , nous obtenons <em>"Function"</em> , pas la <em>"Class"</em> <em>invent√©e</em> , et cela m√©rite d'√™tre rappel√©. </p><br><h3 id="drugie-funkcii">  Autres fonctions </h3><br><p>  Il existe plusieurs fa√ßons de d√©clarer une fonction en JavaScript: <em>FunctionDeclaration</em> , <em>FunctionExpression</em> et r√©cemment <em>ArrowFunction</em> .  Nous savons tous quand et quoi utiliser: les choses sont tr√®s diff√©rentes.  De plus, si nous appelons <em>getTag √†</em> partir de la fonction d√©clar√©e par l'une des options propos√©es, nous obtenons <em>"Function"</em> . </p><br><p>  En fait, le langage a beaucoup plus de fa√ßons de d√©finir une fonction.  Ajoutez √† la liste au moins la <em>classe ClassDeclaration</em> , puis les fonctions et g√©n√©rateurs asynchrones, etc.: <em>AsyncFunctionDeclaration</em> , <em>AsyncFunctionExpression</em> , <em>AsyncArrowFunction</em> , <em>GeneratorDeclaration</em> , <em>GeneratorExpression</em> , <em>ClassExpression</em> , <em>MethodDefinition</em> (la liste n'est pas compl√®te).  Et il semble qu'ils disent quoi?  tout ce qui pr√©c√®de se comporte comme une fonction - ce qui signifie que <em>getTag renverra</em> √©galement <em>"Function"</em> .  Mais il y a une caract√©ristique: toutes les options sont certainement des fonctions, mais pas toutes directement - <em>Fonction</em> . </p><br><p>  Il existe <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">des sous-types de</a> <em>fonction</em> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">int√©gr√©s</a> : </p><br><blockquote>  Le constructeur Function est con√ßu pour √™tre sous-classable. <br>  Il n'existe aucun moyen syntaxique pour cr√©er des instances de sous-classes Function, √† l'exception des sous-classes GeneratorFunction et AsyncFunction int√©gr√©es. </blockquote><p>  Nous avons <em>Function</em> et <em>Inside</em> <em>GeneratorFunction</em> et <em>AsyncFunction</em> avec leurs constructeurs "h√©rit√©s" de celui-ci.  Cela souligne que les puits et les g√©n√©rateurs ont leur propre nature unique.  Et par cons√©quent: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sleep</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">ms</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve</span></span></span><span class="hljs-function"> =&gt;</span></span> setTimeout(resolve, ms)); } getTag(sleep); <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt; "</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">AsyncFunction</span></span></span></span><span class="xml"><span class="hljs-tag">"</span></span></span></span></code> </pre> <br><p>  Dans le m√™me temps, nous ne pouvons pas instancier une telle fonction via le <em>nouvel</em> op√©rateur, et son appel nous renvoie <em>Promise</em> : </p><br><pre> <code class="javascript hljs">getTag(sleep(<span class="hljs-number"><span class="hljs-number">100</span></span>)); <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt; "</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">Promise</span></span></span></span><span class="xml"><span class="hljs-tag">"</span></span></span></span></code> </pre> <br><p>  Un exemple avec une fonction g√©n√©rateur: </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">incg</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">i</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> i += <span class="hljs-number"><span class="hljs-number">1</span></span>; } getTag(incg); <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt; "</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">GeneratorFunction</span></span></span></span><span class="xml"><span class="hljs-tag">"</span></span></span></span></code> </pre> <br><p>  L'appel d'une telle fonction renvoie une instance - l'objet <em>Generator</em> : </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> inc = incg(<span class="hljs-number"><span class="hljs-number">0</span></span>); getTag(inc); <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt; "</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">Generator</span></span></span></span><span class="xml"><span class="hljs-tag">"</span></span></span></span></code> </pre> <br><p>  Le symbole <em>toStringTag</em> est assez red√©fini pour les asinks et les g√©n√©rateurs.  Mais <em>typeof</em> pour n'importe quelle fonction affichera <em>"fonction"</em> . </p><br><h3 id="vstroennye-obekty">  Objets en ligne </h3><br><p>  Nous avons des choses comme <em>Set</em> , <em>Map</em> , <em>Date</em> ou <em>Error</em> .  <em>Leur</em> appliquer <em>getTag</em> renverra <em>"Function"</em> , car ce sont les fonctions - constructeurs de collections it√©rables, dates et erreurs.  Des instances que nous obtenons respectivement - <em>"Set"</em> , <em>"Map"</em> , <em>"Date"</em> et " <em>Error</em> ". </p><br><p>  Mais attention!  il y a encore des objets comme <em>JSON</em> ou <em>Math</em> .  Si vous vous d√©p√™chez, vous pouvez supposer une situation similaire.  Mais non!  c'est compl√®tement diff√©rent - des objets uniques int√©gr√©s.  Ils ne sont pas instanciables ( <code>is not a constructor</code> ).  Un appel de type renverra <em>"objet"</em> (qui en douterait).  Mais <em>getTag</em> se tournera vers <em>toStringTag</em> et obtiendra <em>"JSON"</em> et <em>"Math"</em> .  Ceci est la derni√®re observation que je veux partager. </p><br><h2 id="davayte-bez-fanatizma">  Allons sans fanatisme </h2><br><p>  J'ai pos√© des questions un peu plus profond√©ment que d'habitude sur le type d'une variable en JavaScript r√©cemment lorsque j'ai d√©cid√© d'√©crire mon <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">simple inspecteur d'objets</a> pour l'analyse de code dynamique (jouer).  Le mat√©riel n'est pas seulement publi√© dans la <em>programmation anormale</em> , car vous n'en avez pas besoin en production: il y a <em>typeof</em> , <em>instanceof</em> , <em>Array.isArray</em> , <em>isNaN</em> et tout ce qui m√©rite d'√™tre rappel√© lors de la v√©rification n√©cessaire.  La plupart des projets ont TypeScript, Dart ou Flow.  J'adore <strong>JavaScript</strong> ! </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr427253/">https://habr.com/ru/post/fr427253/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr427243/index.html">Voir la lumi√®re: notre appel √† un protocole standardis√© de messagerie entre robots</a></li>
<li><a href="../fr427245/index.html">Gestion de la messagerie vocale et de l'enregistrement des appels dans le PBX 3CX</a></li>
<li><a href="../fr427247/index.html">Application Web avec IoC Starter. Mappage de requ√™te de base √† l'aide du contexte ioc, du web ioc et de l'orm ioc</a></li>
<li><a href="../fr427249/index.html">Selon la structure mat√©rielle de l'article imprim√©, vous pouvez d√©terminer le mod√®le d'une imprimante 3D et d'un appareil sp√©cifique</a></li>
<li><a href="../fr427251/index.html">Le d√©partement am√©ricain de la S√©curit√© int√©rieure saisit des batteries reconditionn√©es pour les ordinateurs portables Apple, les qualifiant de faux</a></li>
<li><a href="../fr427255/index.html">Cowon D2: Musical Long-Liver</a></li>
<li><a href="../fr427257/index.html">Cameron Craig: sept le√ßons tir√©es de 10 ans de gestion des relations publiques d'Apple</a></li>
<li><a href="../fr427259/index.html">Ce que le test de Turing v√©rifie vraiment</a></li>
<li><a href="../fr427263/index.html">Soyez un ninja de la s√©curit√©: enregistrement de webinaire et niveau bonus</a></li>
<li><a href="../fr427265/index.html">Les protobuffers ont tort</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>