<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ–‹ï¸ ğŸ‘©ğŸ¼â€ğŸŒ¾ ğŸ¦ Apa gunanya Analisis Dinamis Ketika Anda Memiliki Analisis Statis? ğŸ˜® ğŸ¦‰ ğŸ¤™ğŸ½</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Untuk memverifikasi kualitas perangkat lunak, Anda harus menggunakan banyak alat yang berbeda, termasuk analisis statis dan dinamis. Pada artikel ini,...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Apa gunanya Analisis Dinamis Ketika Anda Memiliki Analisis Statis?</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/pvs-studio/blog/461173/">  Untuk memverifikasi kualitas perangkat lunak, Anda harus menggunakan banyak alat yang berbeda, termasuk analisis statis dan dinamis.  Pada artikel ini, kami akan mencoba mencari tahu mengapa hanya satu jenis analisis, apakah statis atau dinamis, mungkin tidak cukup untuk analisis perangkat lunak yang komprehensif dan mengapa lebih baik menggunakan keduanya. <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ff6/72e/d2b/ff672ed2bf84a53f4170fef43c54a861.png" alt="Gambar 1"></div><br><a name="habracut"></a><br>  Tim kami banyak menulis tentang kegunaan analisis statis dan manfaatnya untuk proyek Anda.  Kami suka menjalankan alat kami di berbagai proyek open-source untuk menemukan kemungkinan bug, yang merupakan cara kami untuk mempopulerkan metode analisis kode statis.  Pada gilirannya, analisis statis membantu membuat program lebih berkualitas tinggi dan andal serta mengurangi jumlah kerentanan potensial.  Mungkin setiap orang yang terlibat langsung dalam pekerjaan pada kode sumber memiliki perasaan puas memiliki bug diperbaiki.  Tetapi bahkan jika proses berhasil menemukan (dan memperbaiki) bug tidak memicu endorfin Anda, Anda pasti menikmati pemikiran untuk mengurangi biaya pengembangan berkat penganalisa statis, yang telah membantu programmer Anda menggunakan waktu mereka lebih efektif dan efisien.  Untuk mengetahui lebih lanjut tentang bagaimana Anda bisa mendapat manfaat dari penggunaan analisis statis dalam hal uang, lihat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">artikel ini</a> .  Ini memberikan perkiraan perkiraan untuk PVS-Studio, tetapi hasil tersebut dapat diekstrapolasi ke alat analisis statis lain yang tersedia di pasar. <br><br>  Semua yang dikatakan di atas tampaknya menunjukkan bahwa tujuan analisis statis adalah untuk menemukan bug dalam kode sumber sedini mungkin, sehingga mengurangi biaya perbaikan bug.  Tetapi mengapa kita memerlukan analisis dinamis, dan mengapa hanya berpegang pada satu dari dua teknik saja mungkin tidak cukup?  Mari kita berikan definisi analisis statis dan dinamis yang lebih formal dan jelas dan mencoba menjawab pertanyaan-pertanyaan ini. <br><br>  Analisis kode statis adalah proses mendeteksi kesalahan dan bau kode dalam kode sumber perangkat lunak.  Untuk menganalisis suatu program, Anda tidak perlu menjalankannya;  analisis akan dilakukan pada basis kode yang tersedia.  Analogi terdekat dengan analisis statis adalah tinjauan kode yang disebut kecuali bahwa analisis statis adalah versi otomatis dari tinjauan kode (yaitu dilakukan oleh program bot). <br><br>  Pro utama analisis statis: <br><br><ol><li>  Deteksi bug pada tahap pengembangan awal.  Ini membantu untuk membuat perbaikan bug jauh lebih murah karena semakin cepat cacat terdeteksi, semakin mudah - dan, oleh karena itu, semakin murah - untuk memperbaikinya. </li><li>  Ini memungkinkan Anda untuk secara tepat menemukan bug potensial dalam kode sumber. </li><li>  Cakupan kode lengkap.  Tidak peduli seberapa sering satu blok kode atau lainnya mendapat kendali saat mengeksekusi, analisis statis memeriksa seluruh basis kode. </li><li>  Mudah digunakan.  Anda tidak perlu menyiapkan set data input apa pun untuk melakukan pemeriksaan. </li><li>  Analisis statis mendeteksi kesalahan ketik dan salin-tempel terkait dengan cukup cepat dan mudah. </li></ol><br>  Kontra objektif analisis statis: <br><br><ol><li>  Positif palsu yang tak terhindarkan.  Penganalisa statis bisa marah tentang fragmen kode yang sebenarnya tidak memiliki bug di dalamnya.  Hanya pemrogram yang dapat menyelesaikan masalah ini dan menandai peringatan sebagai false positive, yang berarti akan memakan waktu kerja mereka. </li><li>  Analisis statis umumnya buruk dalam mendeteksi kebocoran memori dan kesalahan terkait konkurensi.  Untuk mendeteksi kesalahan seperti itu, Anda sebenarnya harus menjalankan beberapa bagian dari program dalam mode virtual, yang merupakan tugas yang sangat sulit.  Selain itu, algoritma seperti itu akan membutuhkan terlalu banyak memori dan waktu CPU.  Analisis statis biasanya tidak berjalan lebih jauh daripada menganalisis beberapa <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">kasus</a> sederhana.  Analisis dinamis lebih cocok untuk mendiagnosis kebocoran memori dan kesalahan terkait konkurensi. </li></ol><br>  Perlu dicatat bahwa analisa statis tidak fokus secara eksklusif pada penangkapan bug.  Misalnya, mereka dapat memberikan rekomendasi tentang pemformatan kode.  Beberapa alat memungkinkan Anda untuk memeriksa kode Anda untuk kepatuhan dengan standar pengkodean yang melekat di perusahaan Anda.  Ini termasuk lekukan berbagai konstruksi, penggunaan karakter spasi / tabulasi, dan sebagainya.  Selain itu, analisis statis dapat membantu untuk mengukur metrik.  Metrik perangkat lunak adalah ukuran kuantitatif sejauh mana suatu program atau spesifikasinya memiliki beberapa properti.  Lihat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">artikel ini</a> untuk mempelajari tentang penggunaan analisis statis lainnya. <br><br>  Analisis kode dinamis adalah analisis yang dilakukan pada suatu program pada waktu eksekusi.  Ini berarti Anda harus mengubah kode sumber Anda menjadi file yang dapat dieksekusi terlebih dahulu.  Dengan kata lain, kode yang mengandung kesalahan kompilasi atau build tidak dapat diperiksa oleh jenis analisis ini.  Pemeriksaan dilakukan dengan set input data yang diumpankan ke program yang sedang dianalisis.  Itu sebabnya efektivitas analisis dinamis secara langsung tergantung pada kualitas dan kuantitas data input uji.  Data inilah yang menentukan tingkat cakupan kode pada akhir tes. <br><br>  Dengan pengujian dinamis, Anda bisa mendapatkan metrik dan peringatan berikut: <br><br><ol><li>  Sumber daya yang digunakan: waktu pelaksanaan seluruh program atau bagian-bagian individualnya, jumlah permintaan eksternal (misalnya, ke database), jumlah RAM dan sumber daya lain yang digunakan oleh program. </li><li>  Tingkat cakupan kode dengan tes dan metrik lainnya. </li><li>  Bug perangkat lunak: pembagian dengan nol, null dereference, kebocoran memori, kondisi balapan. </li><li>  Beberapa kerentanan keamanan. </li></ol><br>  Pro utama analisis dinamis: <br><br><ol><li> Anda tidak harus memiliki akses ke kode sumber program untuk menganalisisnya.  Namun perlu dicatat bahwa alat analisis dinamis dibedakan berdasarkan cara mereka berinteraksi dengan program yang sedang dianalisis (ini dibahas lebih rinci di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> ).  Misalnya, satu teknik analisis dinamis yang cukup umum melibatkan instrumentasi kode sebelum pemeriksaan, yaitu penambahan fragmen kode khusus ke kode sumber aplikasi agar penganalisa dapat mendiagnosis kesalahan.  Dalam hal ini, Anda harus memiliki kode sumber program. </li><li>  Ini dapat mendeteksi kesalahan penanganan memori yang kompleks seperti pengindeksan di luar batas array dan kebocoran memori. </li><li>  Itu dapat menganalisis kode multithreaded pada waktu eksekusi, sehingga mendeteksi potensi masalah yang berkaitan dengan akses ke sumber daya bersama atau kemungkinan deadlock. </li><li>  Sebagian besar implementasi analisis dinamis tidak menghasilkan positif palsu karena kesalahan tertangkap saat terjadi.  Oleh karena itu, peringatan yang dikeluarkan oleh penganalisa dinamis bukanlah prediksi yang dibuat oleh alat berdasarkan analisis model program tetapi hanya pernyataan fakta bahwa kesalahan telah terjadi. </li></ol><br>  Kontra analisis dinamis: <br><br><ol><li>  Cakupan kode lengkap tidak dijamin.  Artinya, Anda sangat tidak mungkin mendapatkan cakupan 100% dengan pengujian dinamis. </li><li>  Analisis dinamis buruk dalam mendeteksi kesalahan logika.  Sebagai contoh, kondisi yang selalu benar bukanlah bug dari perspektif penganalisa dinamis karena pemeriksaan yang salah hanya menghilang sebelumnya pada langkah kompilasi. </li><li>  Lebih sulit menemukan kesalahan dalam kode dengan tepat. </li><li>  Analisis dinamis lebih sulit digunakan dibandingkan dengan analisis statis karena Anda perlu memasukkan cukup data ke program untuk mendapatkan hasil yang lebih baik dan mencapai cakupan kode lengkap sebanyak mungkin. </li></ol><br>  Analisis dinamis sangat berguna di bidang-bidang di mana keandalan program, waktu respons, atau sumber daya yang dikonsumsi adalah perhatian utama.  Sistem waktu nyata yang mengelola sektor produksi kritis atau server basis data adalah beberapa contoh dari sistem tersebut.  Kesalahan apa pun di area ini bisa menjadi kritis. <br><br>  Kembali ke pertanyaan mengapa hanya berpegang pada salah satu dari dua jenis analisis mungkin tidak cukup, mari kita lihat beberapa contoh bug yang sepele bahwa satu metode analisis tidak memiliki masalah dalam mendiagnosis sementara yang lain tidak cocok untuk dideteksi. , dan sebaliknya. <br><br>  Contoh berikut diambil dari proyek Dentang: <br><br><pre><code class="cpp hljs">MapTy PerPtrTopDown; MapTy PerPtrBottomUp; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">clearBottomUpPointers</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ PerPtrTopDown.clear(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">clearTopDownPointers</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ PerPtrTopDown.clear(); }</code> </pre> <br>  Analisis statis akan menunjukkan bahwa tubuh kedua fungsi tersebut identik.  Tentu saja, dua fungsi yang memiliki tubuh yang identik belum tentu merupakan tanda bug yang pasti, tetapi sangat mungkin bahwa mereka telah dihasilkan dari menggunakan teknik copy-paste dikombinasikan dengan kecerobohan di sisi programmer - dan itu mengarah pada perilaku yang tidak terduga.  Dalam hal ini, metode <i>clearBottomUpPointers</i> harus memanggil metode <i>PerPtrBottomUp.clear</i> .  Analisis dinamis tidak akan melihat ada yang salah dalam contoh ini karena ini merupakan potongan kode yang benar-benar sah dari sudut pandangnya. <br><br>  Contoh lain.  Misalkan kita memiliki fungsi berikut: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OutstandingIssue</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *strCount)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> nCount; sscanf_s(strCount, <span class="hljs-string"><span class="hljs-string">"%u"</span></span>, &amp;nCount); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-built_in"><span class="hljs-built_in">array</span></span>[<span class="hljs-number"><span class="hljs-number">10</span></span>]; <span class="hljs-built_in"><span class="hljs-built_in">memset</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">array</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, nCount * <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)); }</code> </pre> <br>  Secara teori, penganalisa statis dapat menduga ada sesuatu yang salah dengan kode ini, tetapi menerapkan diagnostik seperti itu adalah tugas yang sangat sulit dan tidak berguna.  Contoh diambil dari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">artikel ini</a> , yang juga menguraikan mengapa itu adalah ide yang buruk untuk mengajarkan analisis statis bagaimana mendiagnosis kesalahan seperti itu.  Singkatnya, analisis statis sangat buruk dalam mencari tahu bahwa panggilan fungsi <i>memset</i> dapat mengakibatkan pengindeksan di luar batas array karena mereka tidak dapat melihat nomor apa yang akan dibaca dari string <i>strCount</i> ;  dan jika nilai <i>strCount</i> dibaca dari file, itu menjadi tugas yang mustahil untuk analisis statis sama sekali.  Di sisi lain, penganalisa dinamis tidak akan kesulitan memperhatikan dan menunjukkan kesalahan penanganan memori dalam kode ini (mengingat bahwa program diberi makan data yang benar). <br><br>  Artikel ini tidak bertujuan membandingkan analisis statis dan dinamis.  Tidak ada teknik tunggal yang dapat mendiagnosis seluruh variasi cacat perangkat lunak.  Kedua jenis analisis tidak dapat sepenuhnya menggantikan yang lain.  Untuk meningkatkan kualitas program Anda, Anda harus menggunakan berbagai jenis alat agar saling melengkapi.  Saya harap contoh-contoh yang ditunjukkan di atas cukup meyakinkan. <br><br>  Saya tidak ingin terlihat terlalu bias terhadap analisis statis, tetapi teknik inilah yang paling banyak dibicarakan dan, yang lebih penting, dimasukkan oleh perusahaan ke dalam proses CI mereka belakangan ini.  Analisis statis bertindak sebagai salah satu langkah gerbang mutu untuk membangun produk perangkat lunak yang andal dan berkualitas tinggi.  Kami percaya analisis statis akan menjadi praktik pengembangan perangkat lunak standar dalam beberapa tahun, sama seperti pengujian unit dulu. <br><br>  Singkatnya, saya ingin menunjukkan sekali lagi bahwa analisis dinamis dan analisis statis hanyalah dua metode yang berbeda, yang saling melengkapi.  Pada akhirnya, semua teknik ini melayani tujuan tunggal untuk meningkatkan kualitas perangkat lunak dan mengurangi biaya pengembangan. <br><br>  <b>Referensi:</b> <br><br><ol><li>  Terminologi.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Analisis kode statis</a> . </li><li>  Terminologi.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Analisis kode dinamis</a> . </li><li>  Andrey Karpov.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Analisis Kode Statis dan Dinamis</a> . </li><li>  Andrey Karpov.  Mitos tentang analisis statis.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Mitos ketiga - analisis dinamis lebih baik daripada analisis statis</a> . </li><li>  Andrey Karpov.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ROI PVS-Studio</a> . </li></ol></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id461173/">https://habr.com/ru/post/id461173/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id461159/index.html">Ivideon Bridge: cara menghubungkan sistem CCTV lama ke cloud</a></li>
<li><a href="../id461161/index.html">Delegasi preferensi Android</a></li>
<li><a href="../id461163/index.html">Apa yang menghubungkan paradoks ulang tahun dan kerentanan tanda tangan elektronik?</a></li>
<li><a href="../id461165/index.html">Biometri semakin dekat</a></li>
<li><a href="../id461171/index.html">Telegram belajar untuk menyamar sebagai HTTPS</a></li>
<li><a href="../id461175/index.html">27 hal yang ingin saya ketahui sebelumnya sebelum memulai pemrograman</a></li>
<li><a href="../id461177/index.html">Sejarah Internet: ARPANET - Subnet</a></li>
<li><a href="../id461179/index.html">Mengapa bukti Teorema Hebat Fermat tidak perlu diperbaiki</a></li>
<li><a href="../id461185/index.html">JsonDiscovery: Mengubah pengalaman melihat JSON di browser</a></li>
<li><a href="../id461191/index.html">Rekaman dari musim panas Pertemuan DIYorDIE 16 Juni</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>