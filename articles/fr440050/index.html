<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🎛️ 👩‍🌾 🚩 Proxy DNS à faire soi-même sur Node.JS 🙇🏾 👩🏾‍🏭 ↖️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Un paquet sur les bosses dans une forêt lointaine pour DNS ... 
 L. Kaganov "Hamlet au fond" 

 Lors du développement d'une application réseau, il dev...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Proxy DNS à faire soi-même sur Node.JS</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/440050/"><blockquote> Un paquet sur les bosses dans une forêt lointaine pour DNS ... <br>  <em>L. Kaganov "Hamlet au fond"</em> </blockquote><p>  Lors du développement d'une application réseau, il devient parfois nécessaire de l'exécuter localement, mais d'y accéder en utilisant un vrai nom de domaine.  La solution standard éprouvée consiste à enregistrer le domaine dans le fichier hosts.  L'inconvénient de l'approche est que les hôtes nécessitent une correspondance claire des noms de domaine, c'est-à-dire  ne prend pas en charge les étoiles.  C'est-à-dire  s'il existe des domaines du formulaire: </p><br><pre><code class="plaintext hljs">dom1.example.com, dom2.example.com, dom3.example.com, ................ domN.example.com,</code> </pre> <br><p>  puis dans les hôtes, vous devez tous les enregistrer.  Dans certains cas, le domaine de troisième niveau n'est pas connu à l'avance.  Il y a un désir (j'écris pour moi, quelqu'un pourrait dire que c'est normal) de s'en sortir avec une ligne comme celle-ci: </p><br><pre> <code class="plaintext hljs">*.example.com</code> </pre> <br><p>  La solution au problème peut être d'utiliser votre propre serveur DNS, qui traitera les demandes conformément à la logique spécifiée.  Il existe de tels serveurs, à la fois entièrement gratuits et avec une interface graphique pratique, comme <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">CoreDNS</a> .  Vous pouvez également modifier les enregistrements DNS sur le routeur.  Enfin, utilisez un service comme <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">xip.io</a> , ce n'est pas tout à fait un serveur DNS à part entière, mais il est parfait pour certaines tâches.  Bref, des solutions toutes faites existent, vous pouvez les utiliser et ne pas vous embêter. </p><br><p>  Mais cet article décrit une autre façon - écrire votre propre vélo, le point de départ pour créer un outil comme ceux énumérés ci-dessus.  Nous écrirons notre proxy DNS, qui écoutera les requêtes DNS entrantes, et si le nom de domaine demandé est dans la liste, il renverra l'IP spécifiée, et sinon, il demandera un serveur DNS supérieur et transmettra la réponse reçue sans modifications au programme demandeur. </p><a name="habracut"></a><br><p>  Dans le même temps, vous pouvez enregistrer les demandes et les réponses reçues.  Étant donné que le DNS est nécessaire à tout le monde - navigateurs, messagers et antivirus, et services de système d'exploitation, etc., il peut être très informatif. </p><br><p>  Le principe est simple.  Dans les paramètres de connexion réseau pour IPv4, nous changeons l'adresse du serveur DNS en l'adresse de la machine avec notre proxy DNS auto-écrit en cours d'exécution (127.0.0.1, si nous ne travaillons pas sur le réseau), et dans ses paramètres, nous spécifions l'adresse du serveur DNS supérieur.  Et, semble-t-il, c'est tout! </p><br><p>  Nous n'utiliserons pas les fonctions standard pour résoudre les noms de domaine <em>nslookup</em> et <em>nsresolve</em> , donc les paramètres du système DNS et le contenu du <em>fichier hosts</em> n'affecteront pas le fonctionnement du programme.  Selon la situation, cela peut être utile ou non, il suffit de s'en souvenir.  Par souci de simplicité, nous nous limitons à l'implémentation de la fonctionnalité de base elle-même: </p><br><ul><li>  Usurpation d'adresse IP uniquement pour les enregistrements de type A (adresse d'hôte) et de classe IN (Internet) </li><li>  adresses IP usurpées uniquement version 4 </li><li>  connexion pour les demandes entrantes locales sur UDP uniquement </li><li>  connexion au serveur DNS en amont via UDP ou TLS </li><li>  s'il y a plusieurs interfaces réseau, les demandes locales entrantes seront acceptées sur l'une d'entre elles </li><li>  pas de support EDNS </li></ul><br><div class="spoiler">  <b class="spoiler_title">En parlant de tests</b> <div class="spoiler_text"><p>  Il y a peu de tests unitaires dans le projet.  Certes, ils fonctionnent selon le principe: je l'ai lancé, et si quelque chose de sain est affiché dans la console, alors tout va bien, mais si une exception vole, alors il y a un problème.  Mais même une approche aussi maladroite vous permet de localiser avec succès le problème, alors Unit. </p></div></div><br><h2 id="nachalo--server-na-53-m-portu">  Démarrer - serveur sur le port 53 </h2><br><p>  Commençons.  Tout d'abord, vous devez apprendre à l'application à accepter les requêtes DNS entrantes.  Nous écrivons un simple serveur TCP qui écoute simplement le port 53 et enregistre les connexions entrantes.  Dans les propriétés de la connexion réseau, nous écrivons l'adresse du serveur DNS 127.0.0.1, lançons l'application, allons sur le navigateur pour plusieurs pages - et ... silence dans la console, le navigateur affiche la page normalement.  Eh bien, nous changeons TCP en UDP, nous commençons, nous passons par le navigateur - dans le navigateur il y a une erreur de connexion, des données binaires versées dans la console.  Ainsi, le système envoie des requêtes via UDP, et nous écouterons les connexions entrantes via UDP sur le port 53.  Une demi-heure de travail, dont 15 minutes pour savoir comment élever un serveur TCP et UDP sur NodeJS - et nous avons résolu la tâche fondamentale du projet, qui détermine la structure de la future application.  Le code est le suivant: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> dgram = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'dgram'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> server = dgram.createSocket(<span class="hljs-string"><span class="hljs-string">'udp4'</span></span>); <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">function</span></span></span></span><span class="hljs-function"><span class="hljs-params">(</span></span></span><span class="hljs-function">) { </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">server</span></span></span><span class="hljs-function">.</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">on</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">'error'</span></span></span></span><span class="hljs-function"><span class="hljs-params">, (err</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">`server error:\n</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${err.stack}</span></span></span><span class="hljs-string">`</span></span>); server.close(); }); server.on(<span class="hljs-string"><span class="hljs-string">'message'</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> (localReq, linfo) =&gt; { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(localReq); <span class="hljs-comment"><span class="hljs-comment">//            }); server.on('listening', () =&gt; { const address = server.address(); console.log(`server listening ${address.address}:${address.port}`); }); const localListenPort = 53; const localListenAddress = 'localhost'; server.bind(localListenPort, localListenAddress); // server listening 0.0.0.0:53 }());</span></span></code> </pre> <br><p>  <em>Listing 1. Le code minimum nécessaire pour recevoir des requêtes DNS locales</em> </p><br><p>  Le point suivant est de lire le message afin de comprendre s'il est nécessaire de renvoyer notre IP en réponse, ou simplement de le transmettre. </p><br><h2 id="dns-soobschenie">  Message DNS </h2><br><p>  La structure du message DNS est décrite dans la RFC-1035.  Les demandes et les réponses suivent cette structure et, en principe, diffèrent par un indicateur de bit (champ QR) dans l'en-tête du message.  Le message comprend cinq sections: </p><br><pre> <code class="plaintext hljs">+---------------------+ | Header | +---------------------+ | Question | the question for the name server +---------------------+ | Answer | RRs answering the question +---------------------+ | Authority | RRs pointing toward an authority +---------------------+ | Additional | RRs holding additional information +---------------------+</code> </pre> <br><p>  <em>Structure (s) générale (s) des messages DNS <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">https://tools.ietf.org/html/rfc1035#section-4.1</a></em> </p><br><p>  Un message DNS commence par un en-tête de longueur fixe (il s'agit de la section dite en- <em>tête</em> ), qui contient des champs de 1 bit à deux octets (ainsi, un octet dans l'en-tête peut contenir plusieurs champs).  L'en-tête commence par le champ ID - il s'agit de l'identifiant de requête 16 bits, la réponse doit avoir le même ID.  Les champs suivants décrivent le type de demande, le résultat de son exécution et le nombre d'enregistrements dans chacune des sections suivantes du message.  Décrivez-les tous pendant longtemps, alors peu importe - bien dans la RFC: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">https://tools.ietf.org/html/rfc1035#section-4.1.1</a> .  La section <em>En</em> - <em>tête</em> est toujours présente dans le message DNS. </p><br><pre> <code class="plaintext hljs"> 1 1 1 1 1 1 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+ | ID | +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+ |QR| Opcode |AA|TC|RD|RA| Z | RCODE | +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+ | QDCOUNT | +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+ | ANCOUNT | +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+ | NSCOUNT | +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+ | ARCOUNT | +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+</code> </pre> <br><p>  <em>Structure (s) d'en-tête de message DNS <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">https://tools.ietf.org/html/rfc1035#section-4.1.1</a></em> </p><br><h3 id="sekciya-question">  Section des questions </h3><br><p>  La section <em>Question</em> contient une entrée indiquant au serveur exactement quelles informations sont nécessaires.  Théoriquement, dans la section de ces enregistrements, il peut y en avoir un ou plusieurs, leur nombre est indiqué dans le champ QDCOUNT de l'en-tête du message et peut être 0, 1 ou plus.  Mais en pratique, la section Question ne peut contenir qu'une seule entrée.  Si la section <em>Question</em> contenait plusieurs enregistrements et que l'un d'entre eux entraînait une erreur lors du traitement de la demande sur le serveur, une situation indéfinie se produirait.  Bien que le serveur renvoie un code d'erreur dans le champ RCODE du message de réponse, il ne pourra pas indiquer lors du traitement de l'enregistrement de l'incident, la spécification ne le décrit pas.  Les enregistrements n'ont également aucun champ contenant une indication de l'erreur et de son type.  Par conséquent, il existe un accord (non documenté), selon lequel la section <em>Question</em> ne peut contenir qu'un seul enregistrement et le champ QDCOUNT a une valeur de 1. Il n'est pas non plus entièrement clair comment traiter la demande côté serveur, si elle contient toujours plusieurs enregistrements dans <em>Question</em> .  Quelqu'un conseille de renvoyer un message avec une erreur de demande.  Et, par exemple, Google DNS ne traite que le premier enregistrement de la section <em>Question</em> , il ignore simplement le reste.  Apparemment, cela reste à la discrétion des développeurs de services DNS. </p><br><p>  Dans le message DNS de réponse du serveur, la section <em>Question</em> est également présente et doit copier complètement la <em>question de la</em> demande (afin d'éviter les conflits, au cas où un champ ID ne suffirait pas). </p><br><p>  La seule entrée dans la section <em>Question</em> contient les champs: QNAME (nom de domaine), QTYPE (type), QCLASS (classe).  QTYPE et QCLASS sont des nombres à deux octets indiquant le type et la classe de la demande.  Les types et classes possibles sont décrits dans la RFC-1035 <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">https://tools.ietf.org/html/rfc1035#section-3.2</a> , tout y est clair.  Mais sur la méthode d'enregistrement d'un nom de domaine, nous nous attarderons plus en détail dans la section "Format d'enregistrement des noms de domaine". </p><br><p>  Dans le cas d'une requête, le message DNS se termine le plus souvent par la section <em>Question</em> , parfois la section <em>supplémentaire</em> peut le suivre. </p><br><p>  Si une erreur s'est produite lors du traitement de la demande sur le serveur (par exemple, une demande entrante a été mal formée), le message de réponse se terminera également par la section <em>Question</em> ou <em>supplémentaire</em> , et le champ RCODE de l'en-tête du message de réponse contiendra un code d'erreur. </p><br><h3 id="sekcii-answer-authority-i-additional">  <em>Réponse</em> , <em>autorisation</em> et sections <em>supplémentaires</em> </h3><br><p>  Les sections suivantes sont <em>Réponse</em> , <em>Autorité</em> et <em>Supplémentaire</em> (La <em>réponse</em> et l' <em>Autorité</em> sont contenues uniquement dans le message DNS de réponse, des informations <em>supplémentaires</em> peuvent apparaître dans la demande et dans la réponse).  Ils sont facultatifs, c'est-à-dire  l'un d'eux peut être présent ou non, selon la demande.  Ces sections ont la même structure et contiennent des informations au format des «enregistrements de ressources» (enregistrement de ressource, ou RR).  Au sens figuré, chacune de ces sections est un tableau d'enregistrements de ressources, et un enregistrement est un objet avec des champs.  Chaque section peut contenir un ou plusieurs enregistrements, leur numéro est indiqué dans le champ correspondant de l'en-tête du message (ANCOUNT, NSCOUNT, ARCOUNT, respectivement).  Par exemple, une demande IP pour le domaine "google.com" renverra plusieurs adresses IP, il y aura donc également plusieurs entrées dans la section <em>Réponse</em> , une pour chaque adresse.  Si la section est absente, le champ d'en-tête correspondant contient 0. </p><br><p>  Chaque <em>enregistrement de ressource</em> (RR) commence par un champ NAME contenant un nom de domaine.  Le format de ce champ est le même que le champ QNAME de la section <em>Question</em> . <br>  À côté de NAME se trouvent les champs TYPE (type d'enregistrement) et CLASS (sa classe), les deux champs sont numériques sur 16 bits, indiquent le type et la classe de l'enregistrement.  Cela ressemble également à la section <em>Question</em> , à la différence que ses QTYPE et QCLASS peuvent avoir toutes les mêmes valeurs que TYPE et CLASS, et certaines autres qui leur sont propres.  Autrement dit, dans un langage scientifique sec, l'ensemble des valeurs QTYPE et QCLASS est un sur-ensemble des valeurs TYPE et CLASS.  En savoir plus sur les différences sur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">https://tools.ietf.org/html/rfc1035#section-3.2.2</a> . <br>  Les champs restants sont: </p><br><ul><li>  TTL est un nombre de 32 bits indiquant la dernière fois que l'enregistrement a été (en secondes). </li><li>  RDLENGTH est un nombre de 16 bits qui indique la longueur du champ RDATA suivant en octets. </li><li>  RDATA est en fait une charge utile, le format dépend du type d'enregistrement.  Par exemple, pour un enregistrement de type A (adresse d'hôte) et de classe IN (Internet), ce sont 4 octets représentant une adresse IPv4. </li></ul><br><h2 id="format-zapisi-domennyh-imyon">  Format d'enregistrement de nom de domaine </h2><br><p>  Le format d'enregistrement des noms de domaine est le même pour les champs QNAME et NAME, ainsi que pour le champ RDATA, s'il s'agit d'un enregistrement CNAME, MX, NS ou autre enregistrement de classe qui suppose un nom de domaine comme résultat. </p><br><p>  Un nom de domaine est une séquence d'étiquettes (sections d'un nom, sous-domaines - c'est une <strong>étiquette</strong> dans l'original, je n'ai pas trouvé de meilleure traduction).  Une étiquette est un seul octet de longueur contenant un nombre - la longueur du contenu de l'étiquette en octets, suivie d'une séquence d'octets de la longueur spécifiée.  Les étiquettes se succèdent jusqu'à ce qu'un octet de longueur contenant 0 soit rencontré. La toute première étiquette peut être immédiatement de longueur nulle, cela indique le domaine racine (domaine racine) avec un nom de domaine vide (parfois écrit ""). </p><br><p>  Dans les versions antérieures de DNS, les octets de l'étiquette pouvaient avoir n'importe quelle valeur de (0 à 255).  Il y avait des règles qui étaient de la nature d'une recommandation urgente: que le libellé commence par une lettre, se termine par une lettre ou un chiffre et ne contienne que des lettres, des chiffres ou des tirets en codage ASCII 7 bits, avec le bit zéro le plus significatif.  La spécification EDNS actuelle exige déjà le respect de ces règles clairement, sans déviation. </p><br><p>  Les deux bits les plus significatifs de l'octet de longueur sont utilisés comme attribut de type d'étiquette.  S'ils sont nuls ( <em>0b00xxxxxx</em> ), il s'agit alors d'une étiquette normale et les bits restants de l'octet de longueur indiquent le nombre d'octets de données inclus dans sa composition.  La longueur maximale de l'étiquette est de 63 caractères.  63 en codage binaire est juste <em>0b00111111</em> . </p><br><p>  Si les deux bits de poids fort sont respectivement 0 et 1 ( <em>0b01xxxxxx</em> ), il s'agit d'une étiquette de type étendue de la norme EDNS ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">https://tools.ietf.org/html/rfc2671#section-3.1</a> ), qui nous est parvenue le 1er février 2019.  Les six bits inférieurs contiendront la valeur de l'étiquette.  Nous ne discutons pas d'EDNS dans cet article, mais il est utile de savoir que cela se produit également. </p><br><p>  La combinaison des deux bits les plus significatifs, égaux à 1 et 0 ( <em>0b10xxxxxx</em> ), est réservée pour une utilisation future. </p><br><p>  Si les deux bits hauts sont égaux à 1 ( <em>0b11xxxxxx</em> ), cela signifie que les noms de domaine sont compressés ( <em>compression</em> ), et nous nous attarderons sur cela plus en détail. </p><br><h3 id="szhatie-domennyh-imyon">  Compression des noms de domaine </h3><br><p>  Donc, si un octet de longueur a deux bits hauts égaux à 1 ( <em>0b11xxxxxx</em> ), c'est un signe de compression de nom de domaine.  La compression est utilisée pour rendre les messages plus courts et plus concis.  Cela est particulièrement vrai lorsque vous travaillez sur UDP, lorsque la longueur totale du message DNS est limitée à 512 octets (bien qu'il s'agisse de l'ancienne norme, voir <em><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">https://tools.ietf.org/html/rfc1035#section-2.3.4</a> Limites de taille</em> , le nouveau EDNS permet d'envoyer des messages UPD et plus).  L'essence du processus est que si un message DNS contient des noms de domaine avec les mêmes sous-domaines de premier niveau (par exemple, <em>mail.yandex.ru</em> et <em>yandex.ru</em> ), au lieu de re-spécifier le nom de domaine entier, le numéro d'octet dans le message DNS à partir duquel Continuez à lire le nom de domaine.  Il peut s'agir de n'importe quel octet du message DNS, non seulement dans l'enregistrement ou la section en cours, mais à condition qu'il s'agisse d'un octet de la longueur de l'étiquette de domaine.  Vous ne pouvez pas vous référer au milieu de la marque.  Supposons qu'il y ait un domaine <em>mail.yandex.ru</em> dans le message, puis à l'aide de la compression, il est possible de désigner également les <em>domaines yandex.ru</em> , <em>ru</em> et root "" (bien sûr, la racine est plus facile à écrire sans compression, mais il est techniquement possible de le faire avec la compression), et ici pour faire <em>ndex.ru</em> ne fonctionnera pas.  De plus, tous les noms de domaine dérivés se termineront dans le domaine racine, c'est-à-dire que l'écriture, disons, <em>mail.yandex</em> échouera également. </p><br><p>  Un nom de domaine peut: </p><br><ul><li>  être entièrement enregistré sans compression, </li><li>  partir d'un endroit qui utilise la compression </li><li>  commencez par une ou plusieurs étiquettes sans compression, puis passez en compression, </li><li>  être vide (pour le domaine racine). </li></ul><br><p>  Par exemple, nous compilons un message DNS, et nous y avions déjà rencontré le nom "dom3.example.com", nous devons maintenant spécifier "dom4.dom3.example.com".  Dans ce cas, vous pouvez enregistrer la section "dom4" sans compression, puis basculer vers la compression, c'est-à-dire ajouter un lien vers "dom3.example.com".  Ou vice versa, si le nom "dom4.dom3.example.com" a déjà été rencontré, pour indiquer "dom3.example.com", vous pouvez immédiatement utiliser la compression en vous référant à l'étiquette "dom3".  Ce que nous ne pouvons pas faire est, comme cela a déjà été dit, d'indiquer la partie de "dom4.dom3" par compression, car le nom doit se terminer par une section de niveau supérieur.  Si vous devez soudainement spécifier des segments à partir du milieu, ils sont simplement indiqués sans compression. </p><br><p>  Par souci de simplicité, notre programme ne sait pas écrire les noms de domaine avec compression, il ne peut que lire.  La norme le permet, la lecture doit être implémentée nécessairement, l'écriture est facultative.  Techniquement, la lecture est implémentée comme ceci: si les deux bits les plus significatifs d'un octet de longueur contiennent 1, alors nous lisons l'octet qui le suit et traitons ces deux octets comme un entier non signé de 16 bits, avec l'ordre des bits Big Endian.  Nous supprimons les deux bits les plus significatifs (contenant 1), lisons le nombre de 14 bits résultant et continuons à lire le nom de domaine de l'octet dans le message DNS sous le numéro correspondant à ce numéro. </p><br><p>  Le code de la fonction de lecture de nom de domaine est le suivant: </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">readDomainName</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">buf, startOffset, objReturnValue = {}</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> currentByteIndex = startOffset; <span class="hljs-comment"><span class="hljs-comment">//    ,  DNS- ,      let initOctet = buf.readUInt8(currentByteIndex); let domain = ''; //      , ..       0, //  ,      // "the root domain name has no labels." (c) RFC-1035, p. 4.1.4. Message compression objReturnValue['endOffset'] = currentByteIndex; let lengthOctet = initOctet; while (lengthOctet &gt; 0) { //     var label; if (lengthOctet &gt;= 192) { //   :  0b1100 0000   const pointer = buf.readUInt16BE(currentByteIndex) - 49152; // 49152 === 0b1100 0000 0000 0000 === 192 * 256 const returnValue = {} label = readDomainName(buf, pointer, returnValue); domain += ('.' + label); objReturnValue['endOffset'] = currentByteIndex + 1; //      ,      break; } else { currentByteIndex++; label = buf.toString('ascii', currentByteIndex, currentByteIndex + lengthOctet); domain += ('.' + label); currentByteIndex += lengthOctet; lengthOctet = buf.readUInt8(currentByteIndex); objReturnValue['endOffset'] = currentByteIndex; } } return domain.substring(1); //    —  "." }</span></span></code> </pre> <br><p>  <em>Listing 2. Lecture de noms de domaine à partir d'une requête DNS</em> </p><br><p>  Code complet de la fonction pour lire l'enregistrement DNS à partir du tampon binaire: </p><br><div class="spoiler">  <b class="spoiler_title">Listing 3. Lecture d'un enregistrement DNS à partir d'un tampon binaire</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">parseDnsMessageBytes</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">buf</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> msgFields = {}; <span class="hljs-comment"><span class="hljs-comment">// (c) RFC 1035 p. 4.1.1. Header section format msgFields['ID'] = buf.readUInt16BE(0); const byte_2 = buf.readUInt8(2); //  #2 (starting from 0) const mask_QR = 0b10000000; msgFields['QR'] = !!(byte_2 &amp; mask_QR); //  : 0 "false" =&gt; , 1 "true" =&gt;  const mask_Opcode = 0b01111000; const opcode = (byte_2 &amp; mask_Opcode) &gt;&gt;&gt; 3; //   (): 0, 1, 2,   msgFields['Opcode'] = opcode; const mask_AA = 0b00000100; msgFields['AA'] = !!(byte_2 &amp; mask_AA); const mask_TC = 0b00000010; msgFields['TC'] = !!(byte_2 &amp; mask_TC); const mask_RD = 0b00000001; msgFields['RD'] = !!(byte_2 &amp; mask_RD); const byte_3 = buf.readUInt8(3); //  #3 const mask_RA = 0b10000000; msgFields['RA'] = !!(byte_3 &amp; mask_RA); const mask_Z = 0b01110000; msgFields['Z'] = (byte_3 &amp; mask_Z) &gt;&gt;&gt; 4; //  0,  const mask_RCODE = 0b00001111; msgFields['RCODE'] = (byte_3 &amp; mask_RCODE); // 0 =&gt; no error; (dec) 1, 2, 3, 4, 5 - errors, see RFC msgFields['QDCOUNT'] = buf.readUInt16BE(4); //     Question,   0  1 msgFields['ANCOUNT'] = buf.readUInt16BE(6); //     Answer msgFields['NSCOUNT'] = buf.readUInt16BE(8); //     Authority msgFields['ARCOUNT'] = buf.readUInt16BE(10); //     Additional //    Question let currentByteIndex = 12; //  Question   12-  DNS- (c) RFC 1035 p. 4.1.2. Question section format msgFields['questions'] = []; for (let qdcount = 0; qdcount &lt; msgFields['QDCOUNT']; qdcount++) { const question = {}; const resultByteIndexObj = { endOffset: undefined }; const domain = readDomainName(buf, currentByteIndex, resultByteIndexObj); currentByteIndex = resultByteIndexObj.endOffset + 1; question['domainName'] = domain; question['qtype'] = buf.readUInt16BE(currentByteIndex); // 1 =&gt; "A" record currentByteIndex += 2; question['qclass'] = buf.readUInt16BE(currentByteIndex); // 1 =&gt; "IN" Internet currentByteIndex += 2; msgFields['questions'].push(question); } // (c) RFC 1035 p. 4.1.3. Resource record format //    (Resourse Records, RR)  Answer, Authority, Additional ['answer', 'authority', 'additional'].forEach(function(section, i, arr) { let msgFieldsName, countFieldName; switch(section) { case 'answer': msgFieldsName = 'answers'; countFieldName = 'ANCOUNT'; break; case 'authority': msgFieldsName = 'authorities'; countFieldName = 'NSCOUNT'; break; case 'additional': msgFieldsName = 'additionals'; countFieldName = 'ARCOUNT'; break; } msgFields[msgFieldsName] = []; for (let recordsCount = 0; recordsCount &lt; msgFields[countFieldName]; recordsCount++) { let record = {}; const objReturnValue = {}; const domain = readDomainName(buf, currentByteIndex, objReturnValue); currentByteIndex = objReturnValue['endOffset'] + 1; record['domainName'] = domain; record['type'] = buf.readUInt16BE(currentByteIndex); // 1 =&gt; "A" record currentByteIndex += 2; record['class'] = buf.readUInt16BE(currentByteIndex); // 1 =&gt; "IN" Internet currentByteIndex += 2; // TTL  4  record['ttl'] = buf.readUIntBE(currentByteIndex, 4); currentByteIndex += 4; record['rdlength'] = buf.readUInt16BE(currentByteIndex); currentByteIndex += 2; const rdataBinTempBuf = buf.slice(currentByteIndex, currentByteIndex + record['rdlength']); record['rdata_bin'] = Buffer.alloc(record['rdlength'], rdataBinTempBuf); if (record['type'] === 1 &amp;&amp; record['class'] === 1) { //      IPv4,      let ipStr = ''; for (ipv4ByteIndex = 0; ipv4ByteIndex &lt; 4; ipv4ByteIndex++) { ipStr += '.' + buf.readUInt8(currentByteIndex).toString(); currentByteIndex++; } record['IPv4'] = ipStr.substring(1); //    '.' } else { //    ,   currentByteIndex += record['rdlength']; } msgFields[msgFieldsName].push(record); } }); return msgFields; }</span></span></code> </pre> <br><p> <em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Listing 3. Lecture d'un enregistrement DNS à partir d'un tampon binaire</font></font></em> </p></div></div><br><p> ,       . ,     ,   ,    .   ,     DNS-,     ,   .  ,       . </p><br><p>  ,        - <code>server.on("message", () =&gt; {})</code>   1.   : </p><br><div class="spoiler"> <b class="spoiler_title"> 4.    DNS-</b> <div class="spoiler_text"><pre> <code class="javascript hljs">server.on(<span class="hljs-string"><span class="hljs-string">'message'</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> (localReq, linfo) =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> dnsRequest = functions.parseDnsMessageBytes(localReq); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> question = dnsRequest.questions[<span class="hljs-number"><span class="hljs-number">0</span></span>]; <span class="hljs-comment"><span class="hljs-comment">// currently, only one question per query is supported by DNS implementations let forgingHostParams = undefined; // ,         IP for (let i = 0; i &lt; config.requestsToForge.length; i++) { const requestToForge = config.requestsToForge[i]; const targetDomainName = requestToForge.hostName; if (functions.domainNameMatchesTemplate(question.domainName, targetDomainName) &amp;&amp; question.qclass === 1 &amp;&amp; question.qtype === 1) { forgingHostParams = requestToForge; break; } } //  ,    DNS-      if (!!forgingHostParams) { const forgeIp = forgingHostParams.ip; const answers = []; answers.push({ domainName: question.domainName, type: question.qtype, class: question.qclass, ttl: forgedRequestsTTL, rdlength: 4, rdata_bin: functions.ip4StringToBuffer(forgeIp), IPv4: forgeIp }); const localDnsResponse = { ID: dnsRequest.ID, QR: dnsRequest.QR, Opcode: dnsRequest.Opcode, AA: dnsRequest.AA, TC: false, // dnsRequest.TC, RD: dnsRequest.RD, RA: true, Z: dnsRequest.Z, RCODE: 0, // dnsRequest.RCODE, 0 - no errors, look in RFC-1035 for other error conditions QDCOUNT: dnsRequest.QDCOUNT, ANCOUNT: answers.length, NSCOUNT: dnsRequest.NSCOUNT, ARCOUNT: dnsRequest.ARCOUNT, questions: dnsRequest.questions, answers: answers } //     DNS-    const responseBuf = functions.composeDnsMessageBin(localDnsResponse); console.log('response composed for: ', localDnsResponse.questions[0]); server.send(responseBuf, linfo.port, linfo.address, (err, bytes) =&gt; {}); } // ,     DNS-,         else { //     DNS-  UDP,     const responseBuf = await functions.getRemoteDnsResponseBin(localReq, upstreamDnsIP, upstreamDnsPort); //        server.send(responseBuf, linfo.port, linfo.address, (err, bytes) =&gt; {}); //     DNS-  TLS,   , .  9 } });</span></span></code> </pre> <br><p> <em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Listing 4. Traitement d'une requête DNS locale entrante</font></font></em> </p></div></div><br><h2 id="dobavlyaem-podderzhku-tls">   TLS </h2><br><p>        DNS-.    ,      DNS-   TLS (HTTPS    ).  DNS-  TLS     TCP,    ,   TLS    .          TCP,   RFC-7766 DNS Transport over TCP ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">https://tools.ietf.org/html/rfc7766</a> ).    ,  :      TLS,   TCP   ( ,       DNS  TCP,      TLS-  TCP-,     ). </p><br><h3 id="ustanovka-tls-soedineniya">  TLS- </h3><br><p>  TLS-           ,       ,   .  ,         TLS-,       .  RFC-7858 -        : </p><br><pre> <code class="plaintext hljs">In order to amortize TCP and TLS connection setup costs, clients and servers SHOULD NOT immediately close a connection after each response. Instead, clients and servers SHOULD reuse existing connections for subsequent queries as long as they have sufficient resources. In some cases, this means that clients and servers may need to keep idle connections open for some amount of time. () https://tools.ietf.org/html/rfc7858#section-3.4</code> </pre> <br><p>       ,   TLS-,   ,     ,   ,   ,       .   ,        30 ,   ,      ,        DNS-.  30  ~  ~   ,   15  60 ,         .        ,         .   - . </p><br><p> TLS-     NodeJS.    ,    TLS-     : </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> tls = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'tls'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> TLS_SOCKET_IDLE_TIMEOUT = <span class="hljs-number"><span class="hljs-number">30000</span></span>; <span class="hljs-comment"><span class="hljs-comment">//    ,     TLS- function Module(connectionOptions, funcOnData, funcOnError, funcOnClose, funcOnEnd) { let socket; function connect() { socket = tls.connect(connectionOptions, () =&gt; { console.log('client connection established:', socket.authorized ? 'authorized' : 'unauthorized'); }); socket.on('data', funcOnData); // connection.on('end', () =&gt; {}); socket.on('close', (hasTransmissionError) =&gt; { //   ,     . //   ,     console.log('connection closed; transmission error:', hasTransmissionError); }); socket.on('end', () =&gt; { console.log('remote TLS server connection closed.') }); socket.on('error', (err) =&gt; { console.log('connection error:', err); console.log('\tmessage:', err.message); console.log('\tstack:', err.stack); }) socket.setTimeout(TLS_SOCKET_IDLE_TIMEOUT); socket.on('timeout', () =&gt; { console.log('socket idle timeout, disconnected.'); socket.end(); }); } this.write = function (dataBuf) { if (socket &amp;&amp; socket.writable) { //  ,     } else { connect(); } socket.write(dataBuf); } return this; } module.exports = Module;</span></span></code> </pre> <br><p> <em> 5. ,   TLS-</em> </p><br><p>       DNS-over-TLS ,   Google DNS.        ,               <code>socket = tls.connect(connectionOptions, () =&gt; {})</code> .     NodeJS: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">https://nodejs.org/api/tls.html#tls_tls_connect_options_callback</a> ,       . </p><br><p>  TLS-   : </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> options = { <span class="hljs-attr"><span class="hljs-attr">port</span></span>: config.upstreamDnsTlsPort, <span class="hljs-comment"><span class="hljs-comment">//        host: config.upstreamDnsTlsHost } const onData = (data) =&gt; { //     , .       7 }; remoteTlsClient = new TlsClient(options, onData);</span></span></code> </pre> <br><p> <em> 6.  TLS-</em> </p><br><p>     ,        TCP-.   TCP/TLS-      DNS-,     ,    ,     ,   .    TCP (  TLS),  DNS-   512 ,    UDP (,  EDNS    UDP  ).  ,  DNS-    UDP,             .       <strong>onData()</strong>   6. </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> onData = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">data</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-comment"><span class="hljs-comment">//    DNS-,       TLS-   //    ,     2 ,       let dataCurrentPos = 0; try { while (dataCurrentPos &lt; data.length) { const respLen = data.readUInt16BE(dataCurrentPos); respBuf = data.slice(dataCurrentPos + 2, dataCurrentPos + 2 + respLen); const respData = functions.parseDnsMessageBytes(respBuf); const requestKey = functions.getRequestIdentifier(respData); const localResponseParams = localRequestsAwaiting.get(requestKey); localRequestsAwaiting.delete(requestKey); server.send(respBuf, localResponseParams.port, localResponseParams.address, (err, bytesNum) =&gt; {}); dataCurrentPos += 2 + respLen; } } catch (err) { console.error(err); //   ,     throw err; } };</span></span></code> </pre> <br><p> <em> 7.   TLS-   DNS-   6</em> </p><br><h3 id="poryadok-otvetov-ot-udalyonnogo-dns-servera">     DNS- </h3><br><p>  ,            ,     .   ,         ID     QNAME, QTYPE  QCLASS  <em>Question</em> : </p><br><pre> <code class="plaintext hljs">Since pipelined responses can arrive out of order, clients MUST match responses to outstanding queries on the same TLS connection using the Message ID. If the response contains a Question Section, the client MUST match the QNAME, QCLASS, and QTYPE fields. () https://tools.ietf.org/html/rfc7858#section-3.3</code> </pre> <br><p>     ,  ,    ,   ID   <em>Question</em> (   ,      ). </p><br><p>        UDP (.  4),    ,         -,    ,   UDP-     .        ,       DNS-,       .          ,       -.  ,         ,      UDP-         -.  ,  ,    . </p><br><p>      TLS,               .         (IP  ),    ,       . </p><br><p>        IP      "-".   ,    ,   ,     DNS-.   ,    ,         IP  ,     .        7: </p><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//        const requestKey = functions.getRequestIdentifier(respData); //    IP    ,   const localResponseParams = localRequestsAwaiting.get(requestKey); localRequestsAwaiting.delete(requestKey); //      IP   server.send(respBuf, localResponseParams.port, localResponseParams.address, (err, bytesNum) =&gt; {});</span></span></code> </pre> <br><p> <em> 8.        7</em> </p><br><p>      TLS-: </p><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//   ,     const localReqParams = { address: linfo.address, port: linfo.port }; //        const requestKey = functions.getRequestIdentifier(dnsRequest); //       localRequestsAwaiting.set(requestKey, localReqParams); //       ,      const lenBuf = Buffer.alloc(2); lenBuf.writeUInt16BE(localReq.length); const prepReqBuf = Buffer.concat([lenBuf, localReq], 2 + localReq.length); remoteTlsClient.write(prepReqBuf); //  RFC-7766 p.8, 2               </span></span></code> </pre> <br><p> <em> 9.    DNS-  TLS- (  .  4)</em> </p><br><h2 id="chtenie-konfiguracii-iz-fayla-i-eyo-obnovlenie">        </h2><br><p>   ,   ,      .     JSON,    ,   NodeJS   JSON-      .  JSON —      ,      .  ,    JSON-  "comment" (  )       . ,  ,  ,    ,  .  ,        ,     .      ,   -  ,    ,            NodeJS.    ,   ,     .  ,         ,       ;   ,   .           ,     - . </p><br><div class="spoiler"> <b class="spoiler_title"> 10.     </b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> path = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'path'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> fs = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'fs'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> CONFIG_FILE_PATH = path.resolve(<span class="hljs-string"><span class="hljs-string">'./config.json'</span></span>); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Module</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// config  -,       . //    config        , //         . ,    : // const conf = config; //   conf     ,    : // const requestsToForge = config.requestsToForge; //    , requestsToForge   . const config = {}; Object.defineProperty(this, 'config', { get() { return config; }, enumerable: true }) this.initConfig = async function() { const fileContents = await readConfigFile(CONFIG_FILE_PATH); console.log('initConfig:'); console.log(fileContents); console.log('fileContents logged ^^'); const parsedConfigData = parseConfig(fileContents); Object.assign(config, parsedConfigData); }; async function readConfigFile(configPath) { const promise = new Promise((resolve, reject) =&gt; { fs.readFile(configPath, { encoding: 'utf8', flag: 'r' }, (err, data) =&gt; { if (err) { console.log('readConfigFile err to throw'); throw err; } resolve(data); }); }) .then( fileContents =&gt; { return fileContents; } ) .catch(err =&gt; { console.log('readConfigFile error: ', err); }); return promise; } function parseConfig(fileContents) { const configData = JSON.parse(fileContents); return configData; } //   ,       . //  Windows,    fs.watch     , //      ,   configReadInProgress let configReadInProgress = false; fs.watch(CONFIG_FILE_PATH, async () =&gt; { if(!configReadInProgress) { configReadInProgress = true; console.log('===== config changed, run initConfig() ====='); try { await this.initConfig(); } catch (err) { console.log('===== error initConfig(), skip =====,', err); configReadInProgress = false; } configReadInProgress = false; } else { console.log('===== config changed, initConfig() already running, skip ====='); } }); } let instance; async function getInstance() { if(!instance) { instance = new Module(); await instance.initConfig(); } return instance; } module.exports = getInstance;</span></span></code> </pre> <br><p> <em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Listing 10. Lecteur et module de mise à jour de la configuration</font></font></em> </p></div></div><br><h2 id="itogo">  Total </h2><br><p>    DNS-  NodeJS,     <em>npm</em>   .    ,        ,   ,  ,         . </p><br><p> <strong><a href="">   GitHub</a></strong> </p><br><h3 id="istochniki"> : </h3><br><ul><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">RFC-1035</a> DOMAIN NAMES — IMPLEMENTATION AND SPECIFICATION </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">RFC-7858</a> Specification for DNS over Transport Layer Security (TLS) </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">RFC-7766</a> DNS Transport over TCP — Implementation Requirements </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">https://stackoverflow.com/questions/4082081/requesting-a-and-aaaa-records-in-single-dns-query/4083071#4083071</a> </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr440050/">https://habr.com/ru/post/fr440050/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr440036/index.html">Saisie tactile</a></li>
<li><a href="../fr440040/index.html">En développement - chacun pour soi. Mais parfois, cela conduit à une impasse.</a></li>
<li><a href="../fr440044/index.html">Historique détaillé de Qualcomm</a></li>
<li><a href="../fr440046/index.html">Leçon ouverte "Création de clients REST au printemps"</a></li>
<li><a href="../fr440048/index.html">Statistiques préférées: 5 indicateurs que chaque équipe commerciale doit suivre</a></li>
<li><a href="../fr440052/index.html">Analyse statique du BIOS / UEFI ou comment obtenir un graphique de dépendance</a></li>
<li><a href="../fr440054/index.html">Transférer le service Web vers Yandex.Cloud avec AWS</a></li>
<li><a href="../fr440058/index.html">Rapport sur les problèmes et la disponibilité d'Internet 2018-2019</a></li>
<li><a href="../fr440060/index.html">TensorFlow sur Apache Ignite</a></li>
<li><a href="../fr440062/index.html">Planifier avec plaisir. Comment nous mettons en place des processus sans managers</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>